
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:32:49.900] plan(): Setting new future strategy stack:
[10:32:49.900] List of future strategies:
[10:32:49.900] 1. sequential:
[10:32:49.900]    - args: function (..., envir = parent.frame())
[10:32:49.900]    - tweaked: FALSE
[10:32:49.900]    - call: future::plan("sequential")
[10:32:49.915] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[10:32:49.966] plan(): Setting new future strategy stack:
[10:32:49.966] List of future strategies:
[10:32:49.966] 1. sequential:
[10:32:49.966]    - args: function (..., envir = parent.frame())
[10:32:49.966]    - tweaked: FALSE
[10:32:49.966]    - call: plan(strategy)
[10:32:49.978] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:32:49.978] getGlobalsAndPackages() ...
[10:32:49.979] Searching for globals...
[10:32:49.981] 
[10:32:49.981] Searching for globals ... DONE
[10:32:49.981] - globals: [0] <none>
[10:32:49.981] getGlobalsAndPackages() ... DONE
[10:32:49.982] run() for ‘Future’ ...
[10:32:49.982] - state: ‘created’
[10:32:49.982] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:49.982] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:49.983] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:49.983]   - Field: ‘label’
[10:32:49.983]   - Field: ‘local’
[10:32:49.983]   - Field: ‘owner’
[10:32:49.983]   - Field: ‘envir’
[10:32:49.983]   - Field: ‘packages’
[10:32:49.983]   - Field: ‘gc’
[10:32:49.983]   - Field: ‘conditions’
[10:32:49.983]   - Field: ‘expr’
[10:32:49.983]   - Field: ‘uuid’
[10:32:49.984]   - Field: ‘seed’
[10:32:49.984]   - Field: ‘version’
[10:32:49.984]   - Field: ‘result’
[10:32:49.984]   - Field: ‘asynchronous’
[10:32:49.984]   - Field: ‘calls’
[10:32:49.984]   - Field: ‘globals’
[10:32:49.984]   - Field: ‘stdout’
[10:32:49.984]   - Field: ‘earlySignal’
[10:32:49.984]   - Field: ‘lazy’
[10:32:49.984]   - Field: ‘state’
[10:32:49.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:49.984] - Launch lazy future ...
[10:32:49.985] Packages needed by the future expression (n = 0): <none>
[10:32:49.985] Packages needed by future strategies (n = 0): <none>
[10:32:49.986] {
[10:32:49.986]     {
[10:32:49.986]         {
[10:32:49.986]             ...future.startTime <- base::Sys.time()
[10:32:49.986]             {
[10:32:49.986]                 {
[10:32:49.986]                   {
[10:32:49.986]                     base::local({
[10:32:49.986]                       has_future <- base::requireNamespace("future", 
[10:32:49.986]                         quietly = TRUE)
[10:32:49.986]                       if (has_future) {
[10:32:49.986]                         ns <- base::getNamespace("future")
[10:32:49.986]                         version <- ns[[".package"]][["version"]]
[10:32:49.986]                         if (is.null(version)) 
[10:32:49.986]                           version <- utils::packageVersion("future")
[10:32:49.986]                       }
[10:32:49.986]                       else {
[10:32:49.986]                         version <- NULL
[10:32:49.986]                       }
[10:32:49.986]                       if (!has_future || version < "1.8.0") {
[10:32:49.986]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:49.986]                           "", base::R.version$version.string), 
[10:32:49.986]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:49.986]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:49.986]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:49.986]                             "release", "version")], collapse = " "), 
[10:32:49.986]                           hostname = base::Sys.info()[["nodename"]])
[10:32:49.986]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:49.986]                           info)
[10:32:49.986]                         info <- base::paste(info, collapse = "; ")
[10:32:49.986]                         if (!has_future) {
[10:32:49.986]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:49.986]                             info)
[10:32:49.986]                         }
[10:32:49.986]                         else {
[10:32:49.986]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:49.986]                             info, version)
[10:32:49.986]                         }
[10:32:49.986]                         base::stop(msg)
[10:32:49.986]                       }
[10:32:49.986]                     })
[10:32:49.986]                   }
[10:32:49.986]                   ...future.strategy.old <- future::plan("list")
[10:32:49.986]                   options(future.plan = NULL)
[10:32:49.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:49.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:49.986]                 }
[10:32:49.986]                 ...future.workdir <- getwd()
[10:32:49.986]             }
[10:32:49.986]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:49.986]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:49.986]         }
[10:32:49.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:49.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:49.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:49.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:49.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:49.986]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:49.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:49.986]             base::names(...future.oldOptions))
[10:32:49.986]     }
[10:32:49.986]     if (FALSE) {
[10:32:49.986]     }
[10:32:49.986]     else {
[10:32:49.986]         if (TRUE) {
[10:32:49.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:49.986]                 open = "w")
[10:32:49.986]         }
[10:32:49.986]         else {
[10:32:49.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:49.986]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:49.986]         }
[10:32:49.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:49.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:49.986]             base::sink(type = "output", split = FALSE)
[10:32:49.986]             base::close(...future.stdout)
[10:32:49.986]         }, add = TRUE)
[10:32:49.986]     }
[10:32:49.986]     ...future.frame <- base::sys.nframe()
[10:32:49.986]     ...future.conditions <- base::list()
[10:32:49.986]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:49.986]     if (FALSE) {
[10:32:49.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:49.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:49.986]     }
[10:32:49.986]     ...future.result <- base::tryCatch({
[10:32:49.986]         base::withCallingHandlers({
[10:32:49.986]             ...future.value <- base::withVisible(base::local(2))
[10:32:49.986]             future::FutureResult(value = ...future.value$value, 
[10:32:49.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:49.986]                   ...future.rng), globalenv = if (FALSE) 
[10:32:49.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:49.986]                     ...future.globalenv.names))
[10:32:49.986]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:49.986]         }, condition = base::local({
[10:32:49.986]             c <- base::c
[10:32:49.986]             inherits <- base::inherits
[10:32:49.986]             invokeRestart <- base::invokeRestart
[10:32:49.986]             length <- base::length
[10:32:49.986]             list <- base::list
[10:32:49.986]             seq.int <- base::seq.int
[10:32:49.986]             signalCondition <- base::signalCondition
[10:32:49.986]             sys.calls <- base::sys.calls
[10:32:49.986]             `[[` <- base::`[[`
[10:32:49.986]             `+` <- base::`+`
[10:32:49.986]             `<<-` <- base::`<<-`
[10:32:49.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:49.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:49.986]                   3L)]
[10:32:49.986]             }
[10:32:49.986]             function(cond) {
[10:32:49.986]                 is_error <- inherits(cond, "error")
[10:32:49.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:49.986]                   NULL)
[10:32:49.986]                 if (is_error) {
[10:32:49.986]                   sessionInformation <- function() {
[10:32:49.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:49.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:49.986]                       search = base::search(), system = base::Sys.info())
[10:32:49.986]                   }
[10:32:49.986]                   ...future.conditions[[length(...future.conditions) + 
[10:32:49.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:49.986]                     cond$call), session = sessionInformation(), 
[10:32:49.986]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:49.986]                   signalCondition(cond)
[10:32:49.986]                 }
[10:32:49.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:49.986]                 "immediateCondition"))) {
[10:32:49.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:49.986]                   ...future.conditions[[length(...future.conditions) + 
[10:32:49.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:49.986]                   if (TRUE && !signal) {
[10:32:49.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:49.986]                     {
[10:32:49.986]                       inherits <- base::inherits
[10:32:49.986]                       invokeRestart <- base::invokeRestart
[10:32:49.986]                       is.null <- base::is.null
[10:32:49.986]                       muffled <- FALSE
[10:32:49.986]                       if (inherits(cond, "message")) {
[10:32:49.986]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:49.986]                         if (muffled) 
[10:32:49.986]                           invokeRestart("muffleMessage")
[10:32:49.986]                       }
[10:32:49.986]                       else if (inherits(cond, "warning")) {
[10:32:49.986]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:49.986]                         if (muffled) 
[10:32:49.986]                           invokeRestart("muffleWarning")
[10:32:49.986]                       }
[10:32:49.986]                       else if (inherits(cond, "condition")) {
[10:32:49.986]                         if (!is.null(pattern)) {
[10:32:49.986]                           computeRestarts <- base::computeRestarts
[10:32:49.986]                           grepl <- base::grepl
[10:32:49.986]                           restarts <- computeRestarts(cond)
[10:32:49.986]                           for (restart in restarts) {
[10:32:49.986]                             name <- restart$name
[10:32:49.986]                             if (is.null(name)) 
[10:32:49.986]                               next
[10:32:49.986]                             if (!grepl(pattern, name)) 
[10:32:49.986]                               next
[10:32:49.986]                             invokeRestart(restart)
[10:32:49.986]                             muffled <- TRUE
[10:32:49.986]                             break
[10:32:49.986]                           }
[10:32:49.986]                         }
[10:32:49.986]                       }
[10:32:49.986]                       invisible(muffled)
[10:32:49.986]                     }
[10:32:49.986]                     muffleCondition(cond, pattern = "^muffle")
[10:32:49.986]                   }
[10:32:49.986]                 }
[10:32:49.986]                 else {
[10:32:49.986]                   if (TRUE) {
[10:32:49.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:49.986]                     {
[10:32:49.986]                       inherits <- base::inherits
[10:32:49.986]                       invokeRestart <- base::invokeRestart
[10:32:49.986]                       is.null <- base::is.null
[10:32:49.986]                       muffled <- FALSE
[10:32:49.986]                       if (inherits(cond, "message")) {
[10:32:49.986]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:49.986]                         if (muffled) 
[10:32:49.986]                           invokeRestart("muffleMessage")
[10:32:49.986]                       }
[10:32:49.986]                       else if (inherits(cond, "warning")) {
[10:32:49.986]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:49.986]                         if (muffled) 
[10:32:49.986]                           invokeRestart("muffleWarning")
[10:32:49.986]                       }
[10:32:49.986]                       else if (inherits(cond, "condition")) {
[10:32:49.986]                         if (!is.null(pattern)) {
[10:32:49.986]                           computeRestarts <- base::computeRestarts
[10:32:49.986]                           grepl <- base::grepl
[10:32:49.986]                           restarts <- computeRestarts(cond)
[10:32:49.986]                           for (restart in restarts) {
[10:32:49.986]                             name <- restart$name
[10:32:49.986]                             if (is.null(name)) 
[10:32:49.986]                               next
[10:32:49.986]                             if (!grepl(pattern, name)) 
[10:32:49.986]                               next
[10:32:49.986]                             invokeRestart(restart)
[10:32:49.986]                             muffled <- TRUE
[10:32:49.986]                             break
[10:32:49.986]                           }
[10:32:49.986]                         }
[10:32:49.986]                       }
[10:32:49.986]                       invisible(muffled)
[10:32:49.986]                     }
[10:32:49.986]                     muffleCondition(cond, pattern = "^muffle")
[10:32:49.986]                   }
[10:32:49.986]                 }
[10:32:49.986]             }
[10:32:49.986]         }))
[10:32:49.986]     }, error = function(ex) {
[10:32:49.986]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:49.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:49.986]                 ...future.rng), started = ...future.startTime, 
[10:32:49.986]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:49.986]             version = "1.8"), class = "FutureResult")
[10:32:49.986]     }, finally = {
[10:32:49.986]         if (!identical(...future.workdir, getwd())) 
[10:32:49.986]             setwd(...future.workdir)
[10:32:49.986]         {
[10:32:49.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:49.986]                 ...future.oldOptions$nwarnings <- NULL
[10:32:49.986]             }
[10:32:49.986]             base::options(...future.oldOptions)
[10:32:49.986]             if (.Platform$OS.type == "windows") {
[10:32:49.986]                 old_names <- names(...future.oldEnvVars)
[10:32:49.986]                 envs <- base::Sys.getenv()
[10:32:49.986]                 names <- names(envs)
[10:32:49.986]                 common <- intersect(names, old_names)
[10:32:49.986]                 added <- setdiff(names, old_names)
[10:32:49.986]                 removed <- setdiff(old_names, names)
[10:32:49.986]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:49.986]                   envs[common]]
[10:32:49.986]                 NAMES <- toupper(changed)
[10:32:49.986]                 args <- list()
[10:32:49.986]                 for (kk in seq_along(NAMES)) {
[10:32:49.986]                   name <- changed[[kk]]
[10:32:49.986]                   NAME <- NAMES[[kk]]
[10:32:49.986]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:49.986]                     next
[10:32:49.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:49.986]                 }
[10:32:49.986]                 NAMES <- toupper(added)
[10:32:49.986]                 for (kk in seq_along(NAMES)) {
[10:32:49.986]                   name <- added[[kk]]
[10:32:49.986]                   NAME <- NAMES[[kk]]
[10:32:49.986]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:49.986]                     next
[10:32:49.986]                   args[[name]] <- ""
[10:32:49.986]                 }
[10:32:49.986]                 NAMES <- toupper(removed)
[10:32:49.986]                 for (kk in seq_along(NAMES)) {
[10:32:49.986]                   name <- removed[[kk]]
[10:32:49.986]                   NAME <- NAMES[[kk]]
[10:32:49.986]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:49.986]                     next
[10:32:49.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:49.986]                 }
[10:32:49.986]                 if (length(args) > 0) 
[10:32:49.986]                   base::do.call(base::Sys.setenv, args = args)
[10:32:49.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:49.986]             }
[10:32:49.986]             else {
[10:32:49.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:49.986]             }
[10:32:49.986]             {
[10:32:49.986]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:49.986]                   0L) {
[10:32:49.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:49.986]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:49.986]                   base::options(opts)
[10:32:49.986]                 }
[10:32:49.986]                 {
[10:32:49.986]                   {
[10:32:49.986]                     NULL
[10:32:49.986]                     RNGkind("Mersenne-Twister")
[10:32:49.986]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:49.986]                       inherits = FALSE)
[10:32:49.986]                   }
[10:32:49.986]                   options(future.plan = NULL)
[10:32:49.986]                   if (is.na(NA_character_)) 
[10:32:49.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:49.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:49.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:49.986]                     .init = FALSE)
[10:32:49.986]                 }
[10:32:49.986]             }
[10:32:49.986]         }
[10:32:49.986]     })
[10:32:49.986]     if (TRUE) {
[10:32:49.986]         base::sink(type = "output", split = FALSE)
[10:32:49.986]         if (TRUE) {
[10:32:49.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:49.986]         }
[10:32:49.986]         else {
[10:32:49.986]             ...future.result["stdout"] <- base::list(NULL)
[10:32:49.986]         }
[10:32:49.986]         base::close(...future.stdout)
[10:32:49.986]         ...future.stdout <- NULL
[10:32:49.986]     }
[10:32:49.986]     ...future.result$conditions <- ...future.conditions
[10:32:49.986]     ...future.result$finished <- base::Sys.time()
[10:32:49.986]     ...future.result
[10:32:49.986] }
[10:32:49.988] plan(): Setting new future strategy stack:
[10:32:49.988] List of future strategies:
[10:32:49.988] 1. sequential:
[10:32:49.988]    - args: function (..., envir = parent.frame())
[10:32:49.988]    - tweaked: FALSE
[10:32:49.988]    - call: NULL
[10:32:49.988] plan(): nbrOfWorkers() = 1
[10:32:49.990] plan(): Setting new future strategy stack:
[10:32:49.990] List of future strategies:
[10:32:49.990] 1. sequential:
[10:32:49.990]    - args: function (..., envir = parent.frame())
[10:32:49.990]    - tweaked: FALSE
[10:32:49.990]    - call: plan(strategy)
[10:32:49.990] plan(): nbrOfWorkers() = 1
[10:32:49.990] SequentialFuture started (and completed)
[10:32:49.991] - Launch lazy future ... done
[10:32:49.991] run() for ‘SequentialFuture’ ... done
[10:32:49.991] getGlobalsAndPackages() ...
[10:32:49.991] Searching for globals...
[10:32:49.991] 
[10:32:49.991] Searching for globals ... DONE
[10:32:49.991] - globals: [0] <none>
[10:32:49.991] getGlobalsAndPackages() ... DONE
[10:32:49.992] run() for ‘Future’ ...
[10:32:49.992] - state: ‘created’
[10:32:49.992] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:49.992] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:49.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:49.992]   - Field: ‘label’
[10:32:49.992]   - Field: ‘local’
[10:32:49.993]   - Field: ‘owner’
[10:32:49.993]   - Field: ‘envir’
[10:32:49.993]   - Field: ‘packages’
[10:32:49.993]   - Field: ‘gc’
[10:32:49.993]   - Field: ‘conditions’
[10:32:49.993]   - Field: ‘expr’
[10:32:49.993]   - Field: ‘uuid’
[10:32:49.993]   - Field: ‘seed’
[10:32:49.993]   - Field: ‘version’
[10:32:49.993]   - Field: ‘result’
[10:32:49.993]   - Field: ‘asynchronous’
[10:32:49.994]   - Field: ‘calls’
[10:32:49.994]   - Field: ‘globals’
[10:32:49.994]   - Field: ‘stdout’
[10:32:49.994]   - Field: ‘earlySignal’
[10:32:49.994]   - Field: ‘lazy’
[10:32:49.994]   - Field: ‘state’
[10:32:49.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:49.994] - Launch lazy future ...
[10:32:49.994] Packages needed by the future expression (n = 0): <none>
[10:32:49.994] Packages needed by future strategies (n = 0): <none>
[10:32:49.995] {
[10:32:49.995]     {
[10:32:49.995]         {
[10:32:49.995]             ...future.startTime <- base::Sys.time()
[10:32:49.995]             {
[10:32:49.995]                 {
[10:32:49.995]                   {
[10:32:49.995]                     base::local({
[10:32:49.995]                       has_future <- base::requireNamespace("future", 
[10:32:49.995]                         quietly = TRUE)
[10:32:49.995]                       if (has_future) {
[10:32:49.995]                         ns <- base::getNamespace("future")
[10:32:49.995]                         version <- ns[[".package"]][["version"]]
[10:32:49.995]                         if (is.null(version)) 
[10:32:49.995]                           version <- utils::packageVersion("future")
[10:32:49.995]                       }
[10:32:49.995]                       else {
[10:32:49.995]                         version <- NULL
[10:32:49.995]                       }
[10:32:49.995]                       if (!has_future || version < "1.8.0") {
[10:32:49.995]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:49.995]                           "", base::R.version$version.string), 
[10:32:49.995]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:49.995]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:49.995]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:49.995]                             "release", "version")], collapse = " "), 
[10:32:49.995]                           hostname = base::Sys.info()[["nodename"]])
[10:32:49.995]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:49.995]                           info)
[10:32:49.995]                         info <- base::paste(info, collapse = "; ")
[10:32:49.995]                         if (!has_future) {
[10:32:49.995]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:49.995]                             info)
[10:32:49.995]                         }
[10:32:49.995]                         else {
[10:32:49.995]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:49.995]                             info, version)
[10:32:49.995]                         }
[10:32:49.995]                         base::stop(msg)
[10:32:49.995]                       }
[10:32:49.995]                     })
[10:32:49.995]                   }
[10:32:49.995]                   ...future.strategy.old <- future::plan("list")
[10:32:49.995]                   options(future.plan = NULL)
[10:32:49.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:49.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:49.995]                 }
[10:32:49.995]                 ...future.workdir <- getwd()
[10:32:49.995]             }
[10:32:49.995]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:49.995]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:49.995]         }
[10:32:49.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:49.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:49.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:49.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:49.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:49.995]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:49.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:49.995]             base::names(...future.oldOptions))
[10:32:49.995]     }
[10:32:49.995]     if (FALSE) {
[10:32:49.995]     }
[10:32:49.995]     else {
[10:32:49.995]         if (TRUE) {
[10:32:49.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:49.995]                 open = "w")
[10:32:49.995]         }
[10:32:49.995]         else {
[10:32:49.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:49.995]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:49.995]         }
[10:32:49.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:49.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:49.995]             base::sink(type = "output", split = FALSE)
[10:32:49.995]             base::close(...future.stdout)
[10:32:49.995]         }, add = TRUE)
[10:32:49.995]     }
[10:32:49.995]     ...future.frame <- base::sys.nframe()
[10:32:49.995]     ...future.conditions <- base::list()
[10:32:49.995]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:49.995]     if (FALSE) {
[10:32:49.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:49.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:49.995]     }
[10:32:49.995]     ...future.result <- base::tryCatch({
[10:32:49.995]         base::withCallingHandlers({
[10:32:49.995]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:49.995]             future::FutureResult(value = ...future.value$value, 
[10:32:49.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:49.995]                   ...future.rng), globalenv = if (FALSE) 
[10:32:49.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:49.995]                     ...future.globalenv.names))
[10:32:49.995]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:49.995]         }, condition = base::local({
[10:32:49.995]             c <- base::c
[10:32:49.995]             inherits <- base::inherits
[10:32:49.995]             invokeRestart <- base::invokeRestart
[10:32:49.995]             length <- base::length
[10:32:49.995]             list <- base::list
[10:32:49.995]             seq.int <- base::seq.int
[10:32:49.995]             signalCondition <- base::signalCondition
[10:32:49.995]             sys.calls <- base::sys.calls
[10:32:49.995]             `[[` <- base::`[[`
[10:32:49.995]             `+` <- base::`+`
[10:32:49.995]             `<<-` <- base::`<<-`
[10:32:49.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:49.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:49.995]                   3L)]
[10:32:49.995]             }
[10:32:49.995]             function(cond) {
[10:32:49.995]                 is_error <- inherits(cond, "error")
[10:32:49.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:49.995]                   NULL)
[10:32:49.995]                 if (is_error) {
[10:32:49.995]                   sessionInformation <- function() {
[10:32:49.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:49.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:49.995]                       search = base::search(), system = base::Sys.info())
[10:32:49.995]                   }
[10:32:49.995]                   ...future.conditions[[length(...future.conditions) + 
[10:32:49.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:49.995]                     cond$call), session = sessionInformation(), 
[10:32:49.995]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:49.995]                   signalCondition(cond)
[10:32:49.995]                 }
[10:32:49.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:49.995]                 "immediateCondition"))) {
[10:32:49.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:49.995]                   ...future.conditions[[length(...future.conditions) + 
[10:32:49.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:49.995]                   if (TRUE && !signal) {
[10:32:49.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:49.995]                     {
[10:32:49.995]                       inherits <- base::inherits
[10:32:49.995]                       invokeRestart <- base::invokeRestart
[10:32:49.995]                       is.null <- base::is.null
[10:32:49.995]                       muffled <- FALSE
[10:32:49.995]                       if (inherits(cond, "message")) {
[10:32:49.995]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:49.995]                         if (muffled) 
[10:32:49.995]                           invokeRestart("muffleMessage")
[10:32:49.995]                       }
[10:32:49.995]                       else if (inherits(cond, "warning")) {
[10:32:49.995]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:49.995]                         if (muffled) 
[10:32:49.995]                           invokeRestart("muffleWarning")
[10:32:49.995]                       }
[10:32:49.995]                       else if (inherits(cond, "condition")) {
[10:32:49.995]                         if (!is.null(pattern)) {
[10:32:49.995]                           computeRestarts <- base::computeRestarts
[10:32:49.995]                           grepl <- base::grepl
[10:32:49.995]                           restarts <- computeRestarts(cond)
[10:32:49.995]                           for (restart in restarts) {
[10:32:49.995]                             name <- restart$name
[10:32:49.995]                             if (is.null(name)) 
[10:32:49.995]                               next
[10:32:49.995]                             if (!grepl(pattern, name)) 
[10:32:49.995]                               next
[10:32:49.995]                             invokeRestart(restart)
[10:32:49.995]                             muffled <- TRUE
[10:32:49.995]                             break
[10:32:49.995]                           }
[10:32:49.995]                         }
[10:32:49.995]                       }
[10:32:49.995]                       invisible(muffled)
[10:32:49.995]                     }
[10:32:49.995]                     muffleCondition(cond, pattern = "^muffle")
[10:32:49.995]                   }
[10:32:49.995]                 }
[10:32:49.995]                 else {
[10:32:49.995]                   if (TRUE) {
[10:32:49.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:49.995]                     {
[10:32:49.995]                       inherits <- base::inherits
[10:32:49.995]                       invokeRestart <- base::invokeRestart
[10:32:49.995]                       is.null <- base::is.null
[10:32:49.995]                       muffled <- FALSE
[10:32:49.995]                       if (inherits(cond, "message")) {
[10:32:49.995]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:49.995]                         if (muffled) 
[10:32:49.995]                           invokeRestart("muffleMessage")
[10:32:49.995]                       }
[10:32:49.995]                       else if (inherits(cond, "warning")) {
[10:32:49.995]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:49.995]                         if (muffled) 
[10:32:49.995]                           invokeRestart("muffleWarning")
[10:32:49.995]                       }
[10:32:49.995]                       else if (inherits(cond, "condition")) {
[10:32:49.995]                         if (!is.null(pattern)) {
[10:32:49.995]                           computeRestarts <- base::computeRestarts
[10:32:49.995]                           grepl <- base::grepl
[10:32:49.995]                           restarts <- computeRestarts(cond)
[10:32:49.995]                           for (restart in restarts) {
[10:32:49.995]                             name <- restart$name
[10:32:49.995]                             if (is.null(name)) 
[10:32:49.995]                               next
[10:32:49.995]                             if (!grepl(pattern, name)) 
[10:32:49.995]                               next
[10:32:49.995]                             invokeRestart(restart)
[10:32:49.995]                             muffled <- TRUE
[10:32:49.995]                             break
[10:32:49.995]                           }
[10:32:49.995]                         }
[10:32:49.995]                       }
[10:32:49.995]                       invisible(muffled)
[10:32:49.995]                     }
[10:32:49.995]                     muffleCondition(cond, pattern = "^muffle")
[10:32:49.995]                   }
[10:32:49.995]                 }
[10:32:49.995]             }
[10:32:49.995]         }))
[10:32:49.995]     }, error = function(ex) {
[10:32:49.995]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:49.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:49.995]                 ...future.rng), started = ...future.startTime, 
[10:32:49.995]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:49.995]             version = "1.8"), class = "FutureResult")
[10:32:49.995]     }, finally = {
[10:32:49.995]         if (!identical(...future.workdir, getwd())) 
[10:32:49.995]             setwd(...future.workdir)
[10:32:49.995]         {
[10:32:49.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:49.995]                 ...future.oldOptions$nwarnings <- NULL
[10:32:49.995]             }
[10:32:49.995]             base::options(...future.oldOptions)
[10:32:49.995]             if (.Platform$OS.type == "windows") {
[10:32:49.995]                 old_names <- names(...future.oldEnvVars)
[10:32:49.995]                 envs <- base::Sys.getenv()
[10:32:49.995]                 names <- names(envs)
[10:32:49.995]                 common <- intersect(names, old_names)
[10:32:49.995]                 added <- setdiff(names, old_names)
[10:32:49.995]                 removed <- setdiff(old_names, names)
[10:32:49.995]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:49.995]                   envs[common]]
[10:32:49.995]                 NAMES <- toupper(changed)
[10:32:49.995]                 args <- list()
[10:32:49.995]                 for (kk in seq_along(NAMES)) {
[10:32:49.995]                   name <- changed[[kk]]
[10:32:49.995]                   NAME <- NAMES[[kk]]
[10:32:49.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:49.995]                     next
[10:32:49.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:49.995]                 }
[10:32:49.995]                 NAMES <- toupper(added)
[10:32:49.995]                 for (kk in seq_along(NAMES)) {
[10:32:49.995]                   name <- added[[kk]]
[10:32:49.995]                   NAME <- NAMES[[kk]]
[10:32:49.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:49.995]                     next
[10:32:49.995]                   args[[name]] <- ""
[10:32:49.995]                 }
[10:32:49.995]                 NAMES <- toupper(removed)
[10:32:49.995]                 for (kk in seq_along(NAMES)) {
[10:32:49.995]                   name <- removed[[kk]]
[10:32:49.995]                   NAME <- NAMES[[kk]]
[10:32:49.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:49.995]                     next
[10:32:49.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:49.995]                 }
[10:32:49.995]                 if (length(args) > 0) 
[10:32:49.995]                   base::do.call(base::Sys.setenv, args = args)
[10:32:49.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:49.995]             }
[10:32:49.995]             else {
[10:32:49.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:49.995]             }
[10:32:49.995]             {
[10:32:49.995]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:49.995]                   0L) {
[10:32:49.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:49.995]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:49.995]                   base::options(opts)
[10:32:49.995]                 }
[10:32:49.995]                 {
[10:32:49.995]                   {
[10:32:49.995]                     NULL
[10:32:49.995]                     RNGkind("Mersenne-Twister")
[10:32:49.995]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:49.995]                       inherits = FALSE)
[10:32:49.995]                   }
[10:32:49.995]                   options(future.plan = NULL)
[10:32:49.995]                   if (is.na(NA_character_)) 
[10:32:49.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:49.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:49.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:49.995]                     .init = FALSE)
[10:32:49.995]                 }
[10:32:49.995]             }
[10:32:49.995]         }
[10:32:49.995]     })
[10:32:49.995]     if (TRUE) {
[10:32:49.995]         base::sink(type = "output", split = FALSE)
[10:32:49.995]         if (TRUE) {
[10:32:49.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:49.995]         }
[10:32:49.995]         else {
[10:32:49.995]             ...future.result["stdout"] <- base::list(NULL)
[10:32:49.995]         }
[10:32:49.995]         base::close(...future.stdout)
[10:32:49.995]         ...future.stdout <- NULL
[10:32:49.995]     }
[10:32:49.995]     ...future.result$conditions <- ...future.conditions
[10:32:49.995]     ...future.result$finished <- base::Sys.time()
[10:32:49.995]     ...future.result
[10:32:49.995] }
[10:32:49.996] plan(): Setting new future strategy stack:
[10:32:49.997] List of future strategies:
[10:32:49.997] 1. sequential:
[10:32:49.997]    - args: function (..., envir = parent.frame())
[10:32:49.997]    - tweaked: FALSE
[10:32:49.997]    - call: NULL
[10:32:49.997] plan(): nbrOfWorkers() = 1
[10:32:49.998] plan(): Setting new future strategy stack:
[10:32:49.998] List of future strategies:
[10:32:49.998] 1. sequential:
[10:32:49.998]    - args: function (..., envir = parent.frame())
[10:32:49.998]    - tweaked: FALSE
[10:32:49.998]    - call: plan(strategy)
[10:32:49.998] plan(): nbrOfWorkers() = 1
[10:32:49.998] SequentialFuture started (and completed)
[10:32:49.998] - Launch lazy future ... done
[10:32:49.998] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0321920> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0bfcfb8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0321920> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0bfcfb8> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:32:50.004] resolved() for ‘SequentialFuture’ ...
[10:32:50.005] - state: ‘finished’
[10:32:50.005] - run: TRUE
[10:32:50.005] - result: ‘FutureResult’
[10:32:50.005] resolved() for ‘SequentialFuture’ ... done
[10:32:50.005] resolved() for ‘SequentialFuture’ ...
[10:32:50.005] - state: ‘finished’
[10:32:50.005] - run: TRUE
[10:32:50.005] - result: ‘FutureResult’
[10:32:50.005] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.006] resolve() on list ...
[10:32:50.006]  recursive: 0
[10:32:50.007]  length: 6
[10:32:50.007]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.007] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.007] - nx: 6
[10:32:50.007] - relay: TRUE
[10:32:50.007] - stdout: TRUE
[10:32:50.007] - signal: TRUE
[10:32:50.007] - resignal: FALSE
[10:32:50.007] - force: TRUE
[10:32:50.008] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.008] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.008]  - until=2
[10:32:50.008]  - relaying element #2
[10:32:50.008] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.008] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.008] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.008]  length: 5 (resolved future 1)
[10:32:50.008] resolved() for ‘SequentialFuture’ ...
[10:32:50.008] - state: ‘finished’
[10:32:50.008] - run: TRUE
[10:32:50.009] - result: ‘FutureResult’
[10:32:50.009] resolved() for ‘SequentialFuture’ ... done
[10:32:50.009] Future #2
[10:32:50.009] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.009] - nx: 6
[10:32:50.009] - relay: TRUE
[10:32:50.009] - stdout: TRUE
[10:32:50.009] - signal: TRUE
[10:32:50.010] - resignal: FALSE
[10:32:50.010] - force: TRUE
[10:32:50.010] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.010] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.010]  - until=2
[10:32:50.010]  - relaying element #2
[10:32:50.010] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.010] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.010] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.012]  length: 4 (resolved future 2)
[10:32:50.012] resolved() for ‘SequentialFuture’ ...
[10:32:50.012] - state: ‘finished’
[10:32:50.013] - run: TRUE
[10:32:50.013] - result: ‘FutureResult’
[10:32:50.013] resolved() for ‘SequentialFuture’ ... done
[10:32:50.013] Future #3
[10:32:50.013] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.013] - nx: 6
[10:32:50.013] - relay: TRUE
[10:32:50.013] - stdout: TRUE
[10:32:50.013] - signal: TRUE
[10:32:50.013] - resignal: FALSE
[10:32:50.014] - force: TRUE
[10:32:50.014] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.014] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.014]  - until=3
[10:32:50.014]  - relaying element #3
[10:32:50.014] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.014] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.014] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.014]  length: 3 (resolved future 3)
[10:32:50.014] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.015] - nx: 6
[10:32:50.015] - relay: TRUE
[10:32:50.015] - stdout: TRUE
[10:32:50.015] - signal: TRUE
[10:32:50.015] - resignal: FALSE
[10:32:50.015] - force: TRUE
[10:32:50.015] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.015] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.015]  - until=5
[10:32:50.015]  - relaying element #5
[10:32:50.015] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.015] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.015] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.016]  length: 2 (resolved future 4)
[10:32:50.016] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.016] - nx: 6
[10:32:50.016] - relay: TRUE
[10:32:50.016] - stdout: TRUE
[10:32:50.016] - signal: TRUE
[10:32:50.016] - resignal: FALSE
[10:32:50.016] - force: TRUE
[10:32:50.016] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.016] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.016]  - until=6
[10:32:50.016]  - relaying element #6
[10:32:50.017] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.017] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.017] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.017]  length: 1 (resolved future 5)
[10:32:50.017] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.017] - nx: 6
[10:32:50.017] - relay: TRUE
[10:32:50.017] - stdout: TRUE
[10:32:50.017] - signal: TRUE
[10:32:50.017] - resignal: FALSE
[10:32:50.017] - force: TRUE
[10:32:50.017] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.018] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.018]  - until=6
[10:32:50.018] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.018] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.018] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.018]  length: 0 (resolved future 6)
[10:32:50.018] Relaying remaining futures
[10:32:50.018] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.018] - nx: 6
[10:32:50.018] - relay: TRUE
[10:32:50.018] - stdout: TRUE
[10:32:50.018] - signal: TRUE
[10:32:50.019] - resignal: FALSE
[10:32:50.019] - force: TRUE
[10:32:50.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.019] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.019] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.019] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.019] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:32:50.021] getGlobalsAndPackages() ...
[10:32:50.021] Searching for globals...
[10:32:50.021] 
[10:32:50.022] Searching for globals ... DONE
[10:32:50.022] - globals: [0] <none>
[10:32:50.022] getGlobalsAndPackages() ... DONE
[10:32:50.022] run() for ‘Future’ ...
[10:32:50.022] - state: ‘created’
[10:32:50.022] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.022] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.023]   - Field: ‘label’
[10:32:50.023]   - Field: ‘local’
[10:32:50.023]   - Field: ‘owner’
[10:32:50.023]   - Field: ‘envir’
[10:32:50.023]   - Field: ‘packages’
[10:32:50.023]   - Field: ‘gc’
[10:32:50.023]   - Field: ‘conditions’
[10:32:50.023]   - Field: ‘expr’
[10:32:50.023]   - Field: ‘uuid’
[10:32:50.023]   - Field: ‘seed’
[10:32:50.024]   - Field: ‘version’
[10:32:50.024]   - Field: ‘result’
[10:32:50.024]   - Field: ‘asynchronous’
[10:32:50.024]   - Field: ‘calls’
[10:32:50.024]   - Field: ‘globals’
[10:32:50.024]   - Field: ‘stdout’
[10:32:50.024]   - Field: ‘earlySignal’
[10:32:50.024]   - Field: ‘lazy’
[10:32:50.024]   - Field: ‘state’
[10:32:50.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.024] - Launch lazy future ...
[10:32:50.025] Packages needed by the future expression (n = 0): <none>
[10:32:50.025] Packages needed by future strategies (n = 0): <none>
[10:32:50.025] {
[10:32:50.025]     {
[10:32:50.025]         {
[10:32:50.025]             ...future.startTime <- base::Sys.time()
[10:32:50.025]             {
[10:32:50.025]                 {
[10:32:50.025]                   {
[10:32:50.025]                     base::local({
[10:32:50.025]                       has_future <- base::requireNamespace("future", 
[10:32:50.025]                         quietly = TRUE)
[10:32:50.025]                       if (has_future) {
[10:32:50.025]                         ns <- base::getNamespace("future")
[10:32:50.025]                         version <- ns[[".package"]][["version"]]
[10:32:50.025]                         if (is.null(version)) 
[10:32:50.025]                           version <- utils::packageVersion("future")
[10:32:50.025]                       }
[10:32:50.025]                       else {
[10:32:50.025]                         version <- NULL
[10:32:50.025]                       }
[10:32:50.025]                       if (!has_future || version < "1.8.0") {
[10:32:50.025]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.025]                           "", base::R.version$version.string), 
[10:32:50.025]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.025]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.025]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.025]                             "release", "version")], collapse = " "), 
[10:32:50.025]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.025]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.025]                           info)
[10:32:50.025]                         info <- base::paste(info, collapse = "; ")
[10:32:50.025]                         if (!has_future) {
[10:32:50.025]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.025]                             info)
[10:32:50.025]                         }
[10:32:50.025]                         else {
[10:32:50.025]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.025]                             info, version)
[10:32:50.025]                         }
[10:32:50.025]                         base::stop(msg)
[10:32:50.025]                       }
[10:32:50.025]                     })
[10:32:50.025]                   }
[10:32:50.025]                   ...future.strategy.old <- future::plan("list")
[10:32:50.025]                   options(future.plan = NULL)
[10:32:50.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.025]                 }
[10:32:50.025]                 ...future.workdir <- getwd()
[10:32:50.025]             }
[10:32:50.025]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.025]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.025]         }
[10:32:50.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.025]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.025]             base::names(...future.oldOptions))
[10:32:50.025]     }
[10:32:50.025]     if (FALSE) {
[10:32:50.025]     }
[10:32:50.025]     else {
[10:32:50.025]         if (TRUE) {
[10:32:50.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.025]                 open = "w")
[10:32:50.025]         }
[10:32:50.025]         else {
[10:32:50.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.025]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.025]         }
[10:32:50.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.025]             base::sink(type = "output", split = FALSE)
[10:32:50.025]             base::close(...future.stdout)
[10:32:50.025]         }, add = TRUE)
[10:32:50.025]     }
[10:32:50.025]     ...future.frame <- base::sys.nframe()
[10:32:50.025]     ...future.conditions <- base::list()
[10:32:50.025]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.025]     if (FALSE) {
[10:32:50.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.025]     }
[10:32:50.025]     ...future.result <- base::tryCatch({
[10:32:50.025]         base::withCallingHandlers({
[10:32:50.025]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.025]             future::FutureResult(value = ...future.value$value, 
[10:32:50.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.025]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.025]                     ...future.globalenv.names))
[10:32:50.025]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.025]         }, condition = base::local({
[10:32:50.025]             c <- base::c
[10:32:50.025]             inherits <- base::inherits
[10:32:50.025]             invokeRestart <- base::invokeRestart
[10:32:50.025]             length <- base::length
[10:32:50.025]             list <- base::list
[10:32:50.025]             seq.int <- base::seq.int
[10:32:50.025]             signalCondition <- base::signalCondition
[10:32:50.025]             sys.calls <- base::sys.calls
[10:32:50.025]             `[[` <- base::`[[`
[10:32:50.025]             `+` <- base::`+`
[10:32:50.025]             `<<-` <- base::`<<-`
[10:32:50.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.025]                   3L)]
[10:32:50.025]             }
[10:32:50.025]             function(cond) {
[10:32:50.025]                 is_error <- inherits(cond, "error")
[10:32:50.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.025]                   NULL)
[10:32:50.025]                 if (is_error) {
[10:32:50.025]                   sessionInformation <- function() {
[10:32:50.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.025]                       search = base::search(), system = base::Sys.info())
[10:32:50.025]                   }
[10:32:50.025]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.025]                     cond$call), session = sessionInformation(), 
[10:32:50.025]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.025]                   signalCondition(cond)
[10:32:50.025]                 }
[10:32:50.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.025]                 "immediateCondition"))) {
[10:32:50.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.025]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.025]                   if (TRUE && !signal) {
[10:32:50.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.025]                     {
[10:32:50.025]                       inherits <- base::inherits
[10:32:50.025]                       invokeRestart <- base::invokeRestart
[10:32:50.025]                       is.null <- base::is.null
[10:32:50.025]                       muffled <- FALSE
[10:32:50.025]                       if (inherits(cond, "message")) {
[10:32:50.025]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.025]                         if (muffled) 
[10:32:50.025]                           invokeRestart("muffleMessage")
[10:32:50.025]                       }
[10:32:50.025]                       else if (inherits(cond, "warning")) {
[10:32:50.025]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.025]                         if (muffled) 
[10:32:50.025]                           invokeRestart("muffleWarning")
[10:32:50.025]                       }
[10:32:50.025]                       else if (inherits(cond, "condition")) {
[10:32:50.025]                         if (!is.null(pattern)) {
[10:32:50.025]                           computeRestarts <- base::computeRestarts
[10:32:50.025]                           grepl <- base::grepl
[10:32:50.025]                           restarts <- computeRestarts(cond)
[10:32:50.025]                           for (restart in restarts) {
[10:32:50.025]                             name <- restart$name
[10:32:50.025]                             if (is.null(name)) 
[10:32:50.025]                               next
[10:32:50.025]                             if (!grepl(pattern, name)) 
[10:32:50.025]                               next
[10:32:50.025]                             invokeRestart(restart)
[10:32:50.025]                             muffled <- TRUE
[10:32:50.025]                             break
[10:32:50.025]                           }
[10:32:50.025]                         }
[10:32:50.025]                       }
[10:32:50.025]                       invisible(muffled)
[10:32:50.025]                     }
[10:32:50.025]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.025]                   }
[10:32:50.025]                 }
[10:32:50.025]                 else {
[10:32:50.025]                   if (TRUE) {
[10:32:50.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.025]                     {
[10:32:50.025]                       inherits <- base::inherits
[10:32:50.025]                       invokeRestart <- base::invokeRestart
[10:32:50.025]                       is.null <- base::is.null
[10:32:50.025]                       muffled <- FALSE
[10:32:50.025]                       if (inherits(cond, "message")) {
[10:32:50.025]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.025]                         if (muffled) 
[10:32:50.025]                           invokeRestart("muffleMessage")
[10:32:50.025]                       }
[10:32:50.025]                       else if (inherits(cond, "warning")) {
[10:32:50.025]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.025]                         if (muffled) 
[10:32:50.025]                           invokeRestart("muffleWarning")
[10:32:50.025]                       }
[10:32:50.025]                       else if (inherits(cond, "condition")) {
[10:32:50.025]                         if (!is.null(pattern)) {
[10:32:50.025]                           computeRestarts <- base::computeRestarts
[10:32:50.025]                           grepl <- base::grepl
[10:32:50.025]                           restarts <- computeRestarts(cond)
[10:32:50.025]                           for (restart in restarts) {
[10:32:50.025]                             name <- restart$name
[10:32:50.025]                             if (is.null(name)) 
[10:32:50.025]                               next
[10:32:50.025]                             if (!grepl(pattern, name)) 
[10:32:50.025]                               next
[10:32:50.025]                             invokeRestart(restart)
[10:32:50.025]                             muffled <- TRUE
[10:32:50.025]                             break
[10:32:50.025]                           }
[10:32:50.025]                         }
[10:32:50.025]                       }
[10:32:50.025]                       invisible(muffled)
[10:32:50.025]                     }
[10:32:50.025]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.025]                   }
[10:32:50.025]                 }
[10:32:50.025]             }
[10:32:50.025]         }))
[10:32:50.025]     }, error = function(ex) {
[10:32:50.025]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.025]                 ...future.rng), started = ...future.startTime, 
[10:32:50.025]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.025]             version = "1.8"), class = "FutureResult")
[10:32:50.025]     }, finally = {
[10:32:50.025]         if (!identical(...future.workdir, getwd())) 
[10:32:50.025]             setwd(...future.workdir)
[10:32:50.025]         {
[10:32:50.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.025]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.025]             }
[10:32:50.025]             base::options(...future.oldOptions)
[10:32:50.025]             if (.Platform$OS.type == "windows") {
[10:32:50.025]                 old_names <- names(...future.oldEnvVars)
[10:32:50.025]                 envs <- base::Sys.getenv()
[10:32:50.025]                 names <- names(envs)
[10:32:50.025]                 common <- intersect(names, old_names)
[10:32:50.025]                 added <- setdiff(names, old_names)
[10:32:50.025]                 removed <- setdiff(old_names, names)
[10:32:50.025]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.025]                   envs[common]]
[10:32:50.025]                 NAMES <- toupper(changed)
[10:32:50.025]                 args <- list()
[10:32:50.025]                 for (kk in seq_along(NAMES)) {
[10:32:50.025]                   name <- changed[[kk]]
[10:32:50.025]                   NAME <- NAMES[[kk]]
[10:32:50.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.025]                     next
[10:32:50.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.025]                 }
[10:32:50.025]                 NAMES <- toupper(added)
[10:32:50.025]                 for (kk in seq_along(NAMES)) {
[10:32:50.025]                   name <- added[[kk]]
[10:32:50.025]                   NAME <- NAMES[[kk]]
[10:32:50.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.025]                     next
[10:32:50.025]                   args[[name]] <- ""
[10:32:50.025]                 }
[10:32:50.025]                 NAMES <- toupper(removed)
[10:32:50.025]                 for (kk in seq_along(NAMES)) {
[10:32:50.025]                   name <- removed[[kk]]
[10:32:50.025]                   NAME <- NAMES[[kk]]
[10:32:50.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.025]                     next
[10:32:50.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.025]                 }
[10:32:50.025]                 if (length(args) > 0) 
[10:32:50.025]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.025]             }
[10:32:50.025]             else {
[10:32:50.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.025]             }
[10:32:50.025]             {
[10:32:50.025]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.025]                   0L) {
[10:32:50.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.025]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.025]                   base::options(opts)
[10:32:50.025]                 }
[10:32:50.025]                 {
[10:32:50.025]                   {
[10:32:50.025]                     NULL
[10:32:50.025]                     RNGkind("Mersenne-Twister")
[10:32:50.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.025]                       inherits = FALSE)
[10:32:50.025]                   }
[10:32:50.025]                   options(future.plan = NULL)
[10:32:50.025]                   if (is.na(NA_character_)) 
[10:32:50.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.025]                     .init = FALSE)
[10:32:50.025]                 }
[10:32:50.025]             }
[10:32:50.025]         }
[10:32:50.025]     })
[10:32:50.025]     if (TRUE) {
[10:32:50.025]         base::sink(type = "output", split = FALSE)
[10:32:50.025]         if (TRUE) {
[10:32:50.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.025]         }
[10:32:50.025]         else {
[10:32:50.025]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.025]         }
[10:32:50.025]         base::close(...future.stdout)
[10:32:50.025]         ...future.stdout <- NULL
[10:32:50.025]     }
[10:32:50.025]     ...future.result$conditions <- ...future.conditions
[10:32:50.025]     ...future.result$finished <- base::Sys.time()
[10:32:50.025]     ...future.result
[10:32:50.025] }
[10:32:50.027] plan(): Setting new future strategy stack:
[10:32:50.027] List of future strategies:
[10:32:50.027] 1. sequential:
[10:32:50.027]    - args: function (..., envir = parent.frame())
[10:32:50.027]    - tweaked: FALSE
[10:32:50.027]    - call: NULL
[10:32:50.027] plan(): nbrOfWorkers() = 1
[10:32:50.028] plan(): Setting new future strategy stack:
[10:32:50.028] List of future strategies:
[10:32:50.028] 1. sequential:
[10:32:50.028]    - args: function (..., envir = parent.frame())
[10:32:50.028]    - tweaked: FALSE
[10:32:50.028]    - call: plan(strategy)
[10:32:50.028] plan(): nbrOfWorkers() = 1
[10:32:50.028] SequentialFuture started (and completed)
[10:32:50.029] - Launch lazy future ... done
[10:32:50.029] run() for ‘SequentialFuture’ ... done
[10:32:50.029] getGlobalsAndPackages() ...
[10:32:50.029] Searching for globals...
[10:32:50.029] 
[10:32:50.029] Searching for globals ... DONE
[10:32:50.029] - globals: [0] <none>
[10:32:50.029] getGlobalsAndPackages() ... DONE
[10:32:50.030] run() for ‘Future’ ...
[10:32:50.030] - state: ‘created’
[10:32:50.030] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.030]   - Field: ‘label’
[10:32:50.030]   - Field: ‘local’
[10:32:50.030]   - Field: ‘owner’
[10:32:50.031]   - Field: ‘envir’
[10:32:50.031]   - Field: ‘packages’
[10:32:50.031]   - Field: ‘gc’
[10:32:50.031]   - Field: ‘conditions’
[10:32:50.031]   - Field: ‘expr’
[10:32:50.031]   - Field: ‘uuid’
[10:32:50.031]   - Field: ‘seed’
[10:32:50.031]   - Field: ‘version’
[10:32:50.031]   - Field: ‘result’
[10:32:50.031]   - Field: ‘asynchronous’
[10:32:50.031]   - Field: ‘calls’
[10:32:50.031]   - Field: ‘globals’
[10:32:50.032]   - Field: ‘stdout’
[10:32:50.032]   - Field: ‘earlySignal’
[10:32:50.032]   - Field: ‘lazy’
[10:32:50.032]   - Field: ‘state’
[10:32:50.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.032] - Launch lazy future ...
[10:32:50.032] Packages needed by the future expression (n = 0): <none>
[10:32:50.032] Packages needed by future strategies (n = 0): <none>
[10:32:50.033] {
[10:32:50.033]     {
[10:32:50.033]         {
[10:32:50.033]             ...future.startTime <- base::Sys.time()
[10:32:50.033]             {
[10:32:50.033]                 {
[10:32:50.033]                   {
[10:32:50.033]                     base::local({
[10:32:50.033]                       has_future <- base::requireNamespace("future", 
[10:32:50.033]                         quietly = TRUE)
[10:32:50.033]                       if (has_future) {
[10:32:50.033]                         ns <- base::getNamespace("future")
[10:32:50.033]                         version <- ns[[".package"]][["version"]]
[10:32:50.033]                         if (is.null(version)) 
[10:32:50.033]                           version <- utils::packageVersion("future")
[10:32:50.033]                       }
[10:32:50.033]                       else {
[10:32:50.033]                         version <- NULL
[10:32:50.033]                       }
[10:32:50.033]                       if (!has_future || version < "1.8.0") {
[10:32:50.033]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.033]                           "", base::R.version$version.string), 
[10:32:50.033]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.033]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.033]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.033]                             "release", "version")], collapse = " "), 
[10:32:50.033]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.033]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.033]                           info)
[10:32:50.033]                         info <- base::paste(info, collapse = "; ")
[10:32:50.033]                         if (!has_future) {
[10:32:50.033]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.033]                             info)
[10:32:50.033]                         }
[10:32:50.033]                         else {
[10:32:50.033]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.033]                             info, version)
[10:32:50.033]                         }
[10:32:50.033]                         base::stop(msg)
[10:32:50.033]                       }
[10:32:50.033]                     })
[10:32:50.033]                   }
[10:32:50.033]                   ...future.strategy.old <- future::plan("list")
[10:32:50.033]                   options(future.plan = NULL)
[10:32:50.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.033]                 }
[10:32:50.033]                 ...future.workdir <- getwd()
[10:32:50.033]             }
[10:32:50.033]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.033]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.033]         }
[10:32:50.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.033]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.033]             base::names(...future.oldOptions))
[10:32:50.033]     }
[10:32:50.033]     if (FALSE) {
[10:32:50.033]     }
[10:32:50.033]     else {
[10:32:50.033]         if (TRUE) {
[10:32:50.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.033]                 open = "w")
[10:32:50.033]         }
[10:32:50.033]         else {
[10:32:50.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.033]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.033]         }
[10:32:50.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.033]             base::sink(type = "output", split = FALSE)
[10:32:50.033]             base::close(...future.stdout)
[10:32:50.033]         }, add = TRUE)
[10:32:50.033]     }
[10:32:50.033]     ...future.frame <- base::sys.nframe()
[10:32:50.033]     ...future.conditions <- base::list()
[10:32:50.033]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.033]     if (FALSE) {
[10:32:50.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.033]     }
[10:32:50.033]     ...future.result <- base::tryCatch({
[10:32:50.033]         base::withCallingHandlers({
[10:32:50.033]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.033]             future::FutureResult(value = ...future.value$value, 
[10:32:50.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.033]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.033]                     ...future.globalenv.names))
[10:32:50.033]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.033]         }, condition = base::local({
[10:32:50.033]             c <- base::c
[10:32:50.033]             inherits <- base::inherits
[10:32:50.033]             invokeRestart <- base::invokeRestart
[10:32:50.033]             length <- base::length
[10:32:50.033]             list <- base::list
[10:32:50.033]             seq.int <- base::seq.int
[10:32:50.033]             signalCondition <- base::signalCondition
[10:32:50.033]             sys.calls <- base::sys.calls
[10:32:50.033]             `[[` <- base::`[[`
[10:32:50.033]             `+` <- base::`+`
[10:32:50.033]             `<<-` <- base::`<<-`
[10:32:50.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.033]                   3L)]
[10:32:50.033]             }
[10:32:50.033]             function(cond) {
[10:32:50.033]                 is_error <- inherits(cond, "error")
[10:32:50.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.033]                   NULL)
[10:32:50.033]                 if (is_error) {
[10:32:50.033]                   sessionInformation <- function() {
[10:32:50.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.033]                       search = base::search(), system = base::Sys.info())
[10:32:50.033]                   }
[10:32:50.033]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.033]                     cond$call), session = sessionInformation(), 
[10:32:50.033]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.033]                   signalCondition(cond)
[10:32:50.033]                 }
[10:32:50.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.033]                 "immediateCondition"))) {
[10:32:50.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.033]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.033]                   if (TRUE && !signal) {
[10:32:50.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.033]                     {
[10:32:50.033]                       inherits <- base::inherits
[10:32:50.033]                       invokeRestart <- base::invokeRestart
[10:32:50.033]                       is.null <- base::is.null
[10:32:50.033]                       muffled <- FALSE
[10:32:50.033]                       if (inherits(cond, "message")) {
[10:32:50.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.033]                         if (muffled) 
[10:32:50.033]                           invokeRestart("muffleMessage")
[10:32:50.033]                       }
[10:32:50.033]                       else if (inherits(cond, "warning")) {
[10:32:50.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.033]                         if (muffled) 
[10:32:50.033]                           invokeRestart("muffleWarning")
[10:32:50.033]                       }
[10:32:50.033]                       else if (inherits(cond, "condition")) {
[10:32:50.033]                         if (!is.null(pattern)) {
[10:32:50.033]                           computeRestarts <- base::computeRestarts
[10:32:50.033]                           grepl <- base::grepl
[10:32:50.033]                           restarts <- computeRestarts(cond)
[10:32:50.033]                           for (restart in restarts) {
[10:32:50.033]                             name <- restart$name
[10:32:50.033]                             if (is.null(name)) 
[10:32:50.033]                               next
[10:32:50.033]                             if (!grepl(pattern, name)) 
[10:32:50.033]                               next
[10:32:50.033]                             invokeRestart(restart)
[10:32:50.033]                             muffled <- TRUE
[10:32:50.033]                             break
[10:32:50.033]                           }
[10:32:50.033]                         }
[10:32:50.033]                       }
[10:32:50.033]                       invisible(muffled)
[10:32:50.033]                     }
[10:32:50.033]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.033]                   }
[10:32:50.033]                 }
[10:32:50.033]                 else {
[10:32:50.033]                   if (TRUE) {
[10:32:50.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.033]                     {
[10:32:50.033]                       inherits <- base::inherits
[10:32:50.033]                       invokeRestart <- base::invokeRestart
[10:32:50.033]                       is.null <- base::is.null
[10:32:50.033]                       muffled <- FALSE
[10:32:50.033]                       if (inherits(cond, "message")) {
[10:32:50.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.033]                         if (muffled) 
[10:32:50.033]                           invokeRestart("muffleMessage")
[10:32:50.033]                       }
[10:32:50.033]                       else if (inherits(cond, "warning")) {
[10:32:50.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.033]                         if (muffled) 
[10:32:50.033]                           invokeRestart("muffleWarning")
[10:32:50.033]                       }
[10:32:50.033]                       else if (inherits(cond, "condition")) {
[10:32:50.033]                         if (!is.null(pattern)) {
[10:32:50.033]                           computeRestarts <- base::computeRestarts
[10:32:50.033]                           grepl <- base::grepl
[10:32:50.033]                           restarts <- computeRestarts(cond)
[10:32:50.033]                           for (restart in restarts) {
[10:32:50.033]                             name <- restart$name
[10:32:50.033]                             if (is.null(name)) 
[10:32:50.033]                               next
[10:32:50.033]                             if (!grepl(pattern, name)) 
[10:32:50.033]                               next
[10:32:50.033]                             invokeRestart(restart)
[10:32:50.033]                             muffled <- TRUE
[10:32:50.033]                             break
[10:32:50.033]                           }
[10:32:50.033]                         }
[10:32:50.033]                       }
[10:32:50.033]                       invisible(muffled)
[10:32:50.033]                     }
[10:32:50.033]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.033]                   }
[10:32:50.033]                 }
[10:32:50.033]             }
[10:32:50.033]         }))
[10:32:50.033]     }, error = function(ex) {
[10:32:50.033]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.033]                 ...future.rng), started = ...future.startTime, 
[10:32:50.033]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.033]             version = "1.8"), class = "FutureResult")
[10:32:50.033]     }, finally = {
[10:32:50.033]         if (!identical(...future.workdir, getwd())) 
[10:32:50.033]             setwd(...future.workdir)
[10:32:50.033]         {
[10:32:50.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.033]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.033]             }
[10:32:50.033]             base::options(...future.oldOptions)
[10:32:50.033]             if (.Platform$OS.type == "windows") {
[10:32:50.033]                 old_names <- names(...future.oldEnvVars)
[10:32:50.033]                 envs <- base::Sys.getenv()
[10:32:50.033]                 names <- names(envs)
[10:32:50.033]                 common <- intersect(names, old_names)
[10:32:50.033]                 added <- setdiff(names, old_names)
[10:32:50.033]                 removed <- setdiff(old_names, names)
[10:32:50.033]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.033]                   envs[common]]
[10:32:50.033]                 NAMES <- toupper(changed)
[10:32:50.033]                 args <- list()
[10:32:50.033]                 for (kk in seq_along(NAMES)) {
[10:32:50.033]                   name <- changed[[kk]]
[10:32:50.033]                   NAME <- NAMES[[kk]]
[10:32:50.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.033]                     next
[10:32:50.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.033]                 }
[10:32:50.033]                 NAMES <- toupper(added)
[10:32:50.033]                 for (kk in seq_along(NAMES)) {
[10:32:50.033]                   name <- added[[kk]]
[10:32:50.033]                   NAME <- NAMES[[kk]]
[10:32:50.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.033]                     next
[10:32:50.033]                   args[[name]] <- ""
[10:32:50.033]                 }
[10:32:50.033]                 NAMES <- toupper(removed)
[10:32:50.033]                 for (kk in seq_along(NAMES)) {
[10:32:50.033]                   name <- removed[[kk]]
[10:32:50.033]                   NAME <- NAMES[[kk]]
[10:32:50.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.033]                     next
[10:32:50.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.033]                 }
[10:32:50.033]                 if (length(args) > 0) 
[10:32:50.033]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.033]             }
[10:32:50.033]             else {
[10:32:50.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.033]             }
[10:32:50.033]             {
[10:32:50.033]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.033]                   0L) {
[10:32:50.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.033]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.033]                   base::options(opts)
[10:32:50.033]                 }
[10:32:50.033]                 {
[10:32:50.033]                   {
[10:32:50.033]                     NULL
[10:32:50.033]                     RNGkind("Mersenne-Twister")
[10:32:50.033]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.033]                       inherits = FALSE)
[10:32:50.033]                   }
[10:32:50.033]                   options(future.plan = NULL)
[10:32:50.033]                   if (is.na(NA_character_)) 
[10:32:50.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.033]                     .init = FALSE)
[10:32:50.033]                 }
[10:32:50.033]             }
[10:32:50.033]         }
[10:32:50.033]     })
[10:32:50.033]     if (TRUE) {
[10:32:50.033]         base::sink(type = "output", split = FALSE)
[10:32:50.033]         if (TRUE) {
[10:32:50.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.033]         }
[10:32:50.033]         else {
[10:32:50.033]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.033]         }
[10:32:50.033]         base::close(...future.stdout)
[10:32:50.033]         ...future.stdout <- NULL
[10:32:50.033]     }
[10:32:50.033]     ...future.result$conditions <- ...future.conditions
[10:32:50.033]     ...future.result$finished <- base::Sys.time()
[10:32:50.033]     ...future.result
[10:32:50.033] }
[10:32:50.034] plan(): Setting new future strategy stack:
[10:32:50.034] List of future strategies:
[10:32:50.034] 1. sequential:
[10:32:50.034]    - args: function (..., envir = parent.frame())
[10:32:50.034]    - tweaked: FALSE
[10:32:50.034]    - call: NULL
[10:32:50.035] plan(): nbrOfWorkers() = 1
[10:32:50.035] plan(): Setting new future strategy stack:
[10:32:50.036] List of future strategies:
[10:32:50.036] 1. sequential:
[10:32:50.036]    - args: function (..., envir = parent.frame())
[10:32:50.036]    - tweaked: FALSE
[10:32:50.036]    - call: plan(strategy)
[10:32:50.036] plan(): nbrOfWorkers() = 1
[10:32:50.036] SequentialFuture started (and completed)
[10:32:50.036] - Launch lazy future ... done
[10:32:50.036] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0bccfd8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0fbdb88> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0bccfd8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0fbdb88> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:32:50.042] resolved() for ‘SequentialFuture’ ...
[10:32:50.042] - state: ‘finished’
[10:32:50.042] - run: TRUE
[10:32:50.042] - result: ‘FutureResult’
[10:32:50.042] resolved() for ‘SequentialFuture’ ... done
[10:32:50.042] resolved() for ‘SequentialFuture’ ...
[10:32:50.043] - state: ‘finished’
[10:32:50.043] - run: TRUE
[10:32:50.043] - result: ‘FutureResult’
[10:32:50.043] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.045] resolve() on list ...
[10:32:50.045]  recursive: 0
[10:32:50.045]  length: 6
[10:32:50.045]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.045] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.045] - nx: 6
[10:32:50.045] - relay: TRUE
[10:32:50.045] - stdout: TRUE
[10:32:50.045] - signal: TRUE
[10:32:50.045] - resignal: FALSE
[10:32:50.045] - force: TRUE
[10:32:50.046] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.046] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.046]  - until=2
[10:32:50.046]  - relaying element #2
[10:32:50.046] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.046] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.046] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.046]  length: 5 (resolved future 1)
[10:32:50.046] resolved() for ‘SequentialFuture’ ...
[10:32:50.046] - state: ‘finished’
[10:32:50.046] - run: TRUE
[10:32:50.047] - result: ‘FutureResult’
[10:32:50.047] resolved() for ‘SequentialFuture’ ... done
[10:32:50.047] Future #2
[10:32:50.047] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.047] - nx: 6
[10:32:50.047] - relay: TRUE
[10:32:50.047] - stdout: TRUE
[10:32:50.047] - signal: TRUE
[10:32:50.047] - resignal: FALSE
[10:32:50.047] - force: TRUE
[10:32:50.047] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.047] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.048]  - until=2
[10:32:50.048]  - relaying element #2
[10:32:50.048] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.048] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.048] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.048]  length: 4 (resolved future 2)
[10:32:50.048] resolved() for ‘SequentialFuture’ ...
[10:32:50.048] - state: ‘finished’
[10:32:50.048] - run: TRUE
[10:32:50.048] - result: ‘FutureResult’
[10:32:50.048] resolved() for ‘SequentialFuture’ ... done
[10:32:50.049] Future #3
[10:32:50.049] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.049] - nx: 6
[10:32:50.049] - relay: TRUE
[10:32:50.049] - stdout: TRUE
[10:32:50.049] - signal: TRUE
[10:32:50.049] - resignal: FALSE
[10:32:50.049] - force: TRUE
[10:32:50.049] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.049] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.049]  - until=3
[10:32:50.050]  - relaying element #3
[10:32:50.050] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.050] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.050] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.050]  length: 3 (resolved future 3)
[10:32:50.050] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.050] - nx: 6
[10:32:50.050] - relay: TRUE
[10:32:50.050] - stdout: TRUE
[10:32:50.050] - signal: TRUE
[10:32:50.050] - resignal: FALSE
[10:32:50.050] - force: TRUE
[10:32:50.051] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.051] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.051]  - until=5
[10:32:50.051]  - relaying element #5
[10:32:50.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.051] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.051] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.051]  length: 2 (resolved future 4)
[10:32:50.051] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.051] - nx: 6
[10:32:50.051] - relay: TRUE
[10:32:50.051] - stdout: TRUE
[10:32:50.052] - signal: TRUE
[10:32:50.052] - resignal: FALSE
[10:32:50.052] - force: TRUE
[10:32:50.052] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.052] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.052]  - until=6
[10:32:50.052]  - relaying element #6
[10:32:50.052] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.052] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.052] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.052]  length: 1 (resolved future 5)
[10:32:50.052] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.053] - nx: 6
[10:32:50.053] - relay: TRUE
[10:32:50.053] - stdout: TRUE
[10:32:50.053] - signal: TRUE
[10:32:50.053] - resignal: FALSE
[10:32:50.053] - force: TRUE
[10:32:50.053] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.053] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.053]  - until=6
[10:32:50.053] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.053] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.053] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.054]  length: 0 (resolved future 6)
[10:32:50.054] Relaying remaining futures
[10:32:50.054] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.054] - nx: 6
[10:32:50.054] - relay: TRUE
[10:32:50.054] - stdout: TRUE
[10:32:50.054] - signal: TRUE
[10:32:50.054] - resignal: FALSE
[10:32:50.054] - force: TRUE
[10:32:50.054] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.054] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.054] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.055] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.055] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.055] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:32:50.058] getGlobalsAndPackages() ...
[10:32:50.058] Searching for globals...
[10:32:50.058] 
[10:32:50.058] Searching for globals ... DONE
[10:32:50.058] - globals: [0] <none>
[10:32:50.058] getGlobalsAndPackages() ... DONE
[10:32:50.059] run() for ‘Future’ ...
[10:32:50.059] - state: ‘created’
[10:32:50.059] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.059] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.059]   - Field: ‘label’
[10:32:50.059]   - Field: ‘local’
[10:32:50.059]   - Field: ‘owner’
[10:32:50.059]   - Field: ‘envir’
[10:32:50.060]   - Field: ‘packages’
[10:32:50.060]   - Field: ‘gc’
[10:32:50.060]   - Field: ‘conditions’
[10:32:50.060]   - Field: ‘expr’
[10:32:50.060]   - Field: ‘uuid’
[10:32:50.060]   - Field: ‘seed’
[10:32:50.060]   - Field: ‘version’
[10:32:50.060]   - Field: ‘result’
[10:32:50.060]   - Field: ‘asynchronous’
[10:32:50.060]   - Field: ‘calls’
[10:32:50.060]   - Field: ‘globals’
[10:32:50.060]   - Field: ‘stdout’
[10:32:50.061]   - Field: ‘earlySignal’
[10:32:50.061]   - Field: ‘lazy’
[10:32:50.061]   - Field: ‘state’
[10:32:50.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.061] - Launch lazy future ...
[10:32:50.061] Packages needed by the future expression (n = 0): <none>
[10:32:50.061] Packages needed by future strategies (n = 0): <none>
[10:32:50.062] {
[10:32:50.062]     {
[10:32:50.062]         {
[10:32:50.062]             ...future.startTime <- base::Sys.time()
[10:32:50.062]             {
[10:32:50.062]                 {
[10:32:50.062]                   {
[10:32:50.062]                     base::local({
[10:32:50.062]                       has_future <- base::requireNamespace("future", 
[10:32:50.062]                         quietly = TRUE)
[10:32:50.062]                       if (has_future) {
[10:32:50.062]                         ns <- base::getNamespace("future")
[10:32:50.062]                         version <- ns[[".package"]][["version"]]
[10:32:50.062]                         if (is.null(version)) 
[10:32:50.062]                           version <- utils::packageVersion("future")
[10:32:50.062]                       }
[10:32:50.062]                       else {
[10:32:50.062]                         version <- NULL
[10:32:50.062]                       }
[10:32:50.062]                       if (!has_future || version < "1.8.0") {
[10:32:50.062]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.062]                           "", base::R.version$version.string), 
[10:32:50.062]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.062]                             "release", "version")], collapse = " "), 
[10:32:50.062]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.062]                           info)
[10:32:50.062]                         info <- base::paste(info, collapse = "; ")
[10:32:50.062]                         if (!has_future) {
[10:32:50.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.062]                             info)
[10:32:50.062]                         }
[10:32:50.062]                         else {
[10:32:50.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.062]                             info, version)
[10:32:50.062]                         }
[10:32:50.062]                         base::stop(msg)
[10:32:50.062]                       }
[10:32:50.062]                     })
[10:32:50.062]                   }
[10:32:50.062]                   ...future.strategy.old <- future::plan("list")
[10:32:50.062]                   options(future.plan = NULL)
[10:32:50.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.062]                 }
[10:32:50.062]                 ...future.workdir <- getwd()
[10:32:50.062]             }
[10:32:50.062]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.062]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.062]         }
[10:32:50.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.062]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.062]             base::names(...future.oldOptions))
[10:32:50.062]     }
[10:32:50.062]     if (FALSE) {
[10:32:50.062]     }
[10:32:50.062]     else {
[10:32:50.062]         if (TRUE) {
[10:32:50.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.062]                 open = "w")
[10:32:50.062]         }
[10:32:50.062]         else {
[10:32:50.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.062]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.062]         }
[10:32:50.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.062]             base::sink(type = "output", split = FALSE)
[10:32:50.062]             base::close(...future.stdout)
[10:32:50.062]         }, add = TRUE)
[10:32:50.062]     }
[10:32:50.062]     ...future.frame <- base::sys.nframe()
[10:32:50.062]     ...future.conditions <- base::list()
[10:32:50.062]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.062]     if (FALSE) {
[10:32:50.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.062]     }
[10:32:50.062]     ...future.result <- base::tryCatch({
[10:32:50.062]         base::withCallingHandlers({
[10:32:50.062]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.062]             future::FutureResult(value = ...future.value$value, 
[10:32:50.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.062]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.062]                     ...future.globalenv.names))
[10:32:50.062]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.062]         }, condition = base::local({
[10:32:50.062]             c <- base::c
[10:32:50.062]             inherits <- base::inherits
[10:32:50.062]             invokeRestart <- base::invokeRestart
[10:32:50.062]             length <- base::length
[10:32:50.062]             list <- base::list
[10:32:50.062]             seq.int <- base::seq.int
[10:32:50.062]             signalCondition <- base::signalCondition
[10:32:50.062]             sys.calls <- base::sys.calls
[10:32:50.062]             `[[` <- base::`[[`
[10:32:50.062]             `+` <- base::`+`
[10:32:50.062]             `<<-` <- base::`<<-`
[10:32:50.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.062]                   3L)]
[10:32:50.062]             }
[10:32:50.062]             function(cond) {
[10:32:50.062]                 is_error <- inherits(cond, "error")
[10:32:50.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.062]                   NULL)
[10:32:50.062]                 if (is_error) {
[10:32:50.062]                   sessionInformation <- function() {
[10:32:50.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.062]                       search = base::search(), system = base::Sys.info())
[10:32:50.062]                   }
[10:32:50.062]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.062]                     cond$call), session = sessionInformation(), 
[10:32:50.062]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.062]                   signalCondition(cond)
[10:32:50.062]                 }
[10:32:50.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.062]                 "immediateCondition"))) {
[10:32:50.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.062]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.062]                   if (TRUE && !signal) {
[10:32:50.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.062]                     {
[10:32:50.062]                       inherits <- base::inherits
[10:32:50.062]                       invokeRestart <- base::invokeRestart
[10:32:50.062]                       is.null <- base::is.null
[10:32:50.062]                       muffled <- FALSE
[10:32:50.062]                       if (inherits(cond, "message")) {
[10:32:50.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.062]                         if (muffled) 
[10:32:50.062]                           invokeRestart("muffleMessage")
[10:32:50.062]                       }
[10:32:50.062]                       else if (inherits(cond, "warning")) {
[10:32:50.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.062]                         if (muffled) 
[10:32:50.062]                           invokeRestart("muffleWarning")
[10:32:50.062]                       }
[10:32:50.062]                       else if (inherits(cond, "condition")) {
[10:32:50.062]                         if (!is.null(pattern)) {
[10:32:50.062]                           computeRestarts <- base::computeRestarts
[10:32:50.062]                           grepl <- base::grepl
[10:32:50.062]                           restarts <- computeRestarts(cond)
[10:32:50.062]                           for (restart in restarts) {
[10:32:50.062]                             name <- restart$name
[10:32:50.062]                             if (is.null(name)) 
[10:32:50.062]                               next
[10:32:50.062]                             if (!grepl(pattern, name)) 
[10:32:50.062]                               next
[10:32:50.062]                             invokeRestart(restart)
[10:32:50.062]                             muffled <- TRUE
[10:32:50.062]                             break
[10:32:50.062]                           }
[10:32:50.062]                         }
[10:32:50.062]                       }
[10:32:50.062]                       invisible(muffled)
[10:32:50.062]                     }
[10:32:50.062]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.062]                   }
[10:32:50.062]                 }
[10:32:50.062]                 else {
[10:32:50.062]                   if (TRUE) {
[10:32:50.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.062]                     {
[10:32:50.062]                       inherits <- base::inherits
[10:32:50.062]                       invokeRestart <- base::invokeRestart
[10:32:50.062]                       is.null <- base::is.null
[10:32:50.062]                       muffled <- FALSE
[10:32:50.062]                       if (inherits(cond, "message")) {
[10:32:50.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.062]                         if (muffled) 
[10:32:50.062]                           invokeRestart("muffleMessage")
[10:32:50.062]                       }
[10:32:50.062]                       else if (inherits(cond, "warning")) {
[10:32:50.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.062]                         if (muffled) 
[10:32:50.062]                           invokeRestart("muffleWarning")
[10:32:50.062]                       }
[10:32:50.062]                       else if (inherits(cond, "condition")) {
[10:32:50.062]                         if (!is.null(pattern)) {
[10:32:50.062]                           computeRestarts <- base::computeRestarts
[10:32:50.062]                           grepl <- base::grepl
[10:32:50.062]                           restarts <- computeRestarts(cond)
[10:32:50.062]                           for (restart in restarts) {
[10:32:50.062]                             name <- restart$name
[10:32:50.062]                             if (is.null(name)) 
[10:32:50.062]                               next
[10:32:50.062]                             if (!grepl(pattern, name)) 
[10:32:50.062]                               next
[10:32:50.062]                             invokeRestart(restart)
[10:32:50.062]                             muffled <- TRUE
[10:32:50.062]                             break
[10:32:50.062]                           }
[10:32:50.062]                         }
[10:32:50.062]                       }
[10:32:50.062]                       invisible(muffled)
[10:32:50.062]                     }
[10:32:50.062]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.062]                   }
[10:32:50.062]                 }
[10:32:50.062]             }
[10:32:50.062]         }))
[10:32:50.062]     }, error = function(ex) {
[10:32:50.062]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.062]                 ...future.rng), started = ...future.startTime, 
[10:32:50.062]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.062]             version = "1.8"), class = "FutureResult")
[10:32:50.062]     }, finally = {
[10:32:50.062]         if (!identical(...future.workdir, getwd())) 
[10:32:50.062]             setwd(...future.workdir)
[10:32:50.062]         {
[10:32:50.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.062]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.062]             }
[10:32:50.062]             base::options(...future.oldOptions)
[10:32:50.062]             if (.Platform$OS.type == "windows") {
[10:32:50.062]                 old_names <- names(...future.oldEnvVars)
[10:32:50.062]                 envs <- base::Sys.getenv()
[10:32:50.062]                 names <- names(envs)
[10:32:50.062]                 common <- intersect(names, old_names)
[10:32:50.062]                 added <- setdiff(names, old_names)
[10:32:50.062]                 removed <- setdiff(old_names, names)
[10:32:50.062]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.062]                   envs[common]]
[10:32:50.062]                 NAMES <- toupper(changed)
[10:32:50.062]                 args <- list()
[10:32:50.062]                 for (kk in seq_along(NAMES)) {
[10:32:50.062]                   name <- changed[[kk]]
[10:32:50.062]                   NAME <- NAMES[[kk]]
[10:32:50.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.062]                     next
[10:32:50.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.062]                 }
[10:32:50.062]                 NAMES <- toupper(added)
[10:32:50.062]                 for (kk in seq_along(NAMES)) {
[10:32:50.062]                   name <- added[[kk]]
[10:32:50.062]                   NAME <- NAMES[[kk]]
[10:32:50.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.062]                     next
[10:32:50.062]                   args[[name]] <- ""
[10:32:50.062]                 }
[10:32:50.062]                 NAMES <- toupper(removed)
[10:32:50.062]                 for (kk in seq_along(NAMES)) {
[10:32:50.062]                   name <- removed[[kk]]
[10:32:50.062]                   NAME <- NAMES[[kk]]
[10:32:50.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.062]                     next
[10:32:50.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.062]                 }
[10:32:50.062]                 if (length(args) > 0) 
[10:32:50.062]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.062]             }
[10:32:50.062]             else {
[10:32:50.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.062]             }
[10:32:50.062]             {
[10:32:50.062]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.062]                   0L) {
[10:32:50.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.062]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.062]                   base::options(opts)
[10:32:50.062]                 }
[10:32:50.062]                 {
[10:32:50.062]                   {
[10:32:50.062]                     NULL
[10:32:50.062]                     RNGkind("Mersenne-Twister")
[10:32:50.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.062]                       inherits = FALSE)
[10:32:50.062]                   }
[10:32:50.062]                   options(future.plan = NULL)
[10:32:50.062]                   if (is.na(NA_character_)) 
[10:32:50.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.062]                     .init = FALSE)
[10:32:50.062]                 }
[10:32:50.062]             }
[10:32:50.062]         }
[10:32:50.062]     })
[10:32:50.062]     if (TRUE) {
[10:32:50.062]         base::sink(type = "output", split = FALSE)
[10:32:50.062]         if (TRUE) {
[10:32:50.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.062]         }
[10:32:50.062]         else {
[10:32:50.062]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.062]         }
[10:32:50.062]         base::close(...future.stdout)
[10:32:50.062]         ...future.stdout <- NULL
[10:32:50.062]     }
[10:32:50.062]     ...future.result$conditions <- ...future.conditions
[10:32:50.062]     ...future.result$finished <- base::Sys.time()
[10:32:50.062]     ...future.result
[10:32:50.062] }
[10:32:50.063] plan(): Setting new future strategy stack:
[10:32:50.063] List of future strategies:
[10:32:50.063] 1. sequential:
[10:32:50.063]    - args: function (..., envir = parent.frame())
[10:32:50.063]    - tweaked: FALSE
[10:32:50.063]    - call: NULL
[10:32:50.064] plan(): nbrOfWorkers() = 1
[10:32:50.064] plan(): Setting new future strategy stack:
[10:32:50.064] List of future strategies:
[10:32:50.064] 1. sequential:
[10:32:50.064]    - args: function (..., envir = parent.frame())
[10:32:50.064]    - tweaked: FALSE
[10:32:50.064]    - call: plan(strategy)
[10:32:50.065] plan(): nbrOfWorkers() = 1
[10:32:50.065] SequentialFuture started (and completed)
[10:32:50.065] - Launch lazy future ... done
[10:32:50.065] run() for ‘SequentialFuture’ ... done
[10:32:50.065] getGlobalsAndPackages() ...
[10:32:50.065] Searching for globals...
[10:32:50.066] 
[10:32:50.067] Searching for globals ... DONE
[10:32:50.067] - globals: [0] <none>
[10:32:50.067] getGlobalsAndPackages() ... DONE
[10:32:50.067] run() for ‘Future’ ...
[10:32:50.067] - state: ‘created’
[10:32:50.067] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.067] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.068]   - Field: ‘label’
[10:32:50.068]   - Field: ‘local’
[10:32:50.068]   - Field: ‘owner’
[10:32:50.068]   - Field: ‘envir’
[10:32:50.068]   - Field: ‘packages’
[10:32:50.068]   - Field: ‘gc’
[10:32:50.068]   - Field: ‘conditions’
[10:32:50.068]   - Field: ‘expr’
[10:32:50.068]   - Field: ‘uuid’
[10:32:50.069]   - Field: ‘seed’
[10:32:50.069]   - Field: ‘version’
[10:32:50.069]   - Field: ‘result’
[10:32:50.069]   - Field: ‘asynchronous’
[10:32:50.069]   - Field: ‘calls’
[10:32:50.069]   - Field: ‘globals’
[10:32:50.069]   - Field: ‘stdout’
[10:32:50.069]   - Field: ‘earlySignal’
[10:32:50.069]   - Field: ‘lazy’
[10:32:50.069]   - Field: ‘state’
[10:32:50.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.070] - Launch lazy future ...
[10:32:50.070] Packages needed by the future expression (n = 0): <none>
[10:32:50.070] Packages needed by future strategies (n = 0): <none>
[10:32:50.070] {
[10:32:50.070]     {
[10:32:50.070]         {
[10:32:50.070]             ...future.startTime <- base::Sys.time()
[10:32:50.070]             {
[10:32:50.070]                 {
[10:32:50.070]                   {
[10:32:50.070]                     base::local({
[10:32:50.070]                       has_future <- base::requireNamespace("future", 
[10:32:50.070]                         quietly = TRUE)
[10:32:50.070]                       if (has_future) {
[10:32:50.070]                         ns <- base::getNamespace("future")
[10:32:50.070]                         version <- ns[[".package"]][["version"]]
[10:32:50.070]                         if (is.null(version)) 
[10:32:50.070]                           version <- utils::packageVersion("future")
[10:32:50.070]                       }
[10:32:50.070]                       else {
[10:32:50.070]                         version <- NULL
[10:32:50.070]                       }
[10:32:50.070]                       if (!has_future || version < "1.8.0") {
[10:32:50.070]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.070]                           "", base::R.version$version.string), 
[10:32:50.070]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.070]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.070]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.070]                             "release", "version")], collapse = " "), 
[10:32:50.070]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.070]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.070]                           info)
[10:32:50.070]                         info <- base::paste(info, collapse = "; ")
[10:32:50.070]                         if (!has_future) {
[10:32:50.070]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.070]                             info)
[10:32:50.070]                         }
[10:32:50.070]                         else {
[10:32:50.070]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.070]                             info, version)
[10:32:50.070]                         }
[10:32:50.070]                         base::stop(msg)
[10:32:50.070]                       }
[10:32:50.070]                     })
[10:32:50.070]                   }
[10:32:50.070]                   ...future.strategy.old <- future::plan("list")
[10:32:50.070]                   options(future.plan = NULL)
[10:32:50.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.070]                 }
[10:32:50.070]                 ...future.workdir <- getwd()
[10:32:50.070]             }
[10:32:50.070]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.070]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.070]         }
[10:32:50.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.070]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.070]             base::names(...future.oldOptions))
[10:32:50.070]     }
[10:32:50.070]     if (FALSE) {
[10:32:50.070]     }
[10:32:50.070]     else {
[10:32:50.070]         if (TRUE) {
[10:32:50.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.070]                 open = "w")
[10:32:50.070]         }
[10:32:50.070]         else {
[10:32:50.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.070]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.070]         }
[10:32:50.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.070]             base::sink(type = "output", split = FALSE)
[10:32:50.070]             base::close(...future.stdout)
[10:32:50.070]         }, add = TRUE)
[10:32:50.070]     }
[10:32:50.070]     ...future.frame <- base::sys.nframe()
[10:32:50.070]     ...future.conditions <- base::list()
[10:32:50.070]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.070]     if (FALSE) {
[10:32:50.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.070]     }
[10:32:50.070]     ...future.result <- base::tryCatch({
[10:32:50.070]         base::withCallingHandlers({
[10:32:50.070]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.070]             future::FutureResult(value = ...future.value$value, 
[10:32:50.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.070]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.070]                     ...future.globalenv.names))
[10:32:50.070]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.070]         }, condition = base::local({
[10:32:50.070]             c <- base::c
[10:32:50.070]             inherits <- base::inherits
[10:32:50.070]             invokeRestart <- base::invokeRestart
[10:32:50.070]             length <- base::length
[10:32:50.070]             list <- base::list
[10:32:50.070]             seq.int <- base::seq.int
[10:32:50.070]             signalCondition <- base::signalCondition
[10:32:50.070]             sys.calls <- base::sys.calls
[10:32:50.070]             `[[` <- base::`[[`
[10:32:50.070]             `+` <- base::`+`
[10:32:50.070]             `<<-` <- base::`<<-`
[10:32:50.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.070]                   3L)]
[10:32:50.070]             }
[10:32:50.070]             function(cond) {
[10:32:50.070]                 is_error <- inherits(cond, "error")
[10:32:50.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.070]                   NULL)
[10:32:50.070]                 if (is_error) {
[10:32:50.070]                   sessionInformation <- function() {
[10:32:50.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.070]                       search = base::search(), system = base::Sys.info())
[10:32:50.070]                   }
[10:32:50.070]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.070]                     cond$call), session = sessionInformation(), 
[10:32:50.070]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.070]                   signalCondition(cond)
[10:32:50.070]                 }
[10:32:50.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.070]                 "immediateCondition"))) {
[10:32:50.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.070]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.070]                   if (TRUE && !signal) {
[10:32:50.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.070]                     {
[10:32:50.070]                       inherits <- base::inherits
[10:32:50.070]                       invokeRestart <- base::invokeRestart
[10:32:50.070]                       is.null <- base::is.null
[10:32:50.070]                       muffled <- FALSE
[10:32:50.070]                       if (inherits(cond, "message")) {
[10:32:50.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.070]                         if (muffled) 
[10:32:50.070]                           invokeRestart("muffleMessage")
[10:32:50.070]                       }
[10:32:50.070]                       else if (inherits(cond, "warning")) {
[10:32:50.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.070]                         if (muffled) 
[10:32:50.070]                           invokeRestart("muffleWarning")
[10:32:50.070]                       }
[10:32:50.070]                       else if (inherits(cond, "condition")) {
[10:32:50.070]                         if (!is.null(pattern)) {
[10:32:50.070]                           computeRestarts <- base::computeRestarts
[10:32:50.070]                           grepl <- base::grepl
[10:32:50.070]                           restarts <- computeRestarts(cond)
[10:32:50.070]                           for (restart in restarts) {
[10:32:50.070]                             name <- restart$name
[10:32:50.070]                             if (is.null(name)) 
[10:32:50.070]                               next
[10:32:50.070]                             if (!grepl(pattern, name)) 
[10:32:50.070]                               next
[10:32:50.070]                             invokeRestart(restart)
[10:32:50.070]                             muffled <- TRUE
[10:32:50.070]                             break
[10:32:50.070]                           }
[10:32:50.070]                         }
[10:32:50.070]                       }
[10:32:50.070]                       invisible(muffled)
[10:32:50.070]                     }
[10:32:50.070]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.070]                   }
[10:32:50.070]                 }
[10:32:50.070]                 else {
[10:32:50.070]                   if (TRUE) {
[10:32:50.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.070]                     {
[10:32:50.070]                       inherits <- base::inherits
[10:32:50.070]                       invokeRestart <- base::invokeRestart
[10:32:50.070]                       is.null <- base::is.null
[10:32:50.070]                       muffled <- FALSE
[10:32:50.070]                       if (inherits(cond, "message")) {
[10:32:50.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.070]                         if (muffled) 
[10:32:50.070]                           invokeRestart("muffleMessage")
[10:32:50.070]                       }
[10:32:50.070]                       else if (inherits(cond, "warning")) {
[10:32:50.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.070]                         if (muffled) 
[10:32:50.070]                           invokeRestart("muffleWarning")
[10:32:50.070]                       }
[10:32:50.070]                       else if (inherits(cond, "condition")) {
[10:32:50.070]                         if (!is.null(pattern)) {
[10:32:50.070]                           computeRestarts <- base::computeRestarts
[10:32:50.070]                           grepl <- base::grepl
[10:32:50.070]                           restarts <- computeRestarts(cond)
[10:32:50.070]                           for (restart in restarts) {
[10:32:50.070]                             name <- restart$name
[10:32:50.070]                             if (is.null(name)) 
[10:32:50.070]                               next
[10:32:50.070]                             if (!grepl(pattern, name)) 
[10:32:50.070]                               next
[10:32:50.070]                             invokeRestart(restart)
[10:32:50.070]                             muffled <- TRUE
[10:32:50.070]                             break
[10:32:50.070]                           }
[10:32:50.070]                         }
[10:32:50.070]                       }
[10:32:50.070]                       invisible(muffled)
[10:32:50.070]                     }
[10:32:50.070]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.070]                   }
[10:32:50.070]                 }
[10:32:50.070]             }
[10:32:50.070]         }))
[10:32:50.070]     }, error = function(ex) {
[10:32:50.070]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.070]                 ...future.rng), started = ...future.startTime, 
[10:32:50.070]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.070]             version = "1.8"), class = "FutureResult")
[10:32:50.070]     }, finally = {
[10:32:50.070]         if (!identical(...future.workdir, getwd())) 
[10:32:50.070]             setwd(...future.workdir)
[10:32:50.070]         {
[10:32:50.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.070]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.070]             }
[10:32:50.070]             base::options(...future.oldOptions)
[10:32:50.070]             if (.Platform$OS.type == "windows") {
[10:32:50.070]                 old_names <- names(...future.oldEnvVars)
[10:32:50.070]                 envs <- base::Sys.getenv()
[10:32:50.070]                 names <- names(envs)
[10:32:50.070]                 common <- intersect(names, old_names)
[10:32:50.070]                 added <- setdiff(names, old_names)
[10:32:50.070]                 removed <- setdiff(old_names, names)
[10:32:50.070]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.070]                   envs[common]]
[10:32:50.070]                 NAMES <- toupper(changed)
[10:32:50.070]                 args <- list()
[10:32:50.070]                 for (kk in seq_along(NAMES)) {
[10:32:50.070]                   name <- changed[[kk]]
[10:32:50.070]                   NAME <- NAMES[[kk]]
[10:32:50.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.070]                     next
[10:32:50.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.070]                 }
[10:32:50.070]                 NAMES <- toupper(added)
[10:32:50.070]                 for (kk in seq_along(NAMES)) {
[10:32:50.070]                   name <- added[[kk]]
[10:32:50.070]                   NAME <- NAMES[[kk]]
[10:32:50.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.070]                     next
[10:32:50.070]                   args[[name]] <- ""
[10:32:50.070]                 }
[10:32:50.070]                 NAMES <- toupper(removed)
[10:32:50.070]                 for (kk in seq_along(NAMES)) {
[10:32:50.070]                   name <- removed[[kk]]
[10:32:50.070]                   NAME <- NAMES[[kk]]
[10:32:50.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.070]                     next
[10:32:50.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.070]                 }
[10:32:50.070]                 if (length(args) > 0) 
[10:32:50.070]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.070]             }
[10:32:50.070]             else {
[10:32:50.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.070]             }
[10:32:50.070]             {
[10:32:50.070]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.070]                   0L) {
[10:32:50.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.070]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.070]                   base::options(opts)
[10:32:50.070]                 }
[10:32:50.070]                 {
[10:32:50.070]                   {
[10:32:50.070]                     NULL
[10:32:50.070]                     RNGkind("Mersenne-Twister")
[10:32:50.070]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.070]                       inherits = FALSE)
[10:32:50.070]                   }
[10:32:50.070]                   options(future.plan = NULL)
[10:32:50.070]                   if (is.na(NA_character_)) 
[10:32:50.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.070]                     .init = FALSE)
[10:32:50.070]                 }
[10:32:50.070]             }
[10:32:50.070]         }
[10:32:50.070]     })
[10:32:50.070]     if (TRUE) {
[10:32:50.070]         base::sink(type = "output", split = FALSE)
[10:32:50.070]         if (TRUE) {
[10:32:50.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.070]         }
[10:32:50.070]         else {
[10:32:50.070]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.070]         }
[10:32:50.070]         base::close(...future.stdout)
[10:32:50.070]         ...future.stdout <- NULL
[10:32:50.070]     }
[10:32:50.070]     ...future.result$conditions <- ...future.conditions
[10:32:50.070]     ...future.result$finished <- base::Sys.time()
[10:32:50.070]     ...future.result
[10:32:50.070] }
[10:32:50.072] plan(): Setting new future strategy stack:
[10:32:50.072] List of future strategies:
[10:32:50.072] 1. sequential:
[10:32:50.072]    - args: function (..., envir = parent.frame())
[10:32:50.072]    - tweaked: FALSE
[10:32:50.072]    - call: NULL
[10:32:50.072] plan(): nbrOfWorkers() = 1
[10:32:50.073] plan(): Setting new future strategy stack:
[10:32:50.073] List of future strategies:
[10:32:50.073] 1. sequential:
[10:32:50.073]    - args: function (..., envir = parent.frame())
[10:32:50.073]    - tweaked: FALSE
[10:32:50.073]    - call: plan(strategy)
[10:32:50.073] plan(): nbrOfWorkers() = 1
[10:32:50.074] SequentialFuture started (and completed)
[10:32:50.074] - Launch lazy future ... done
[10:32:50.074] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d118db78> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d03a5dd0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d118db78> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d03a5dd0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:32:50.078] resolved() for ‘SequentialFuture’ ...
[10:32:50.078] - state: ‘finished’
[10:32:50.079] - run: TRUE
[10:32:50.079] - result: ‘FutureResult’
[10:32:50.079] resolved() for ‘SequentialFuture’ ... done
[10:32:50.079] resolved() for ‘SequentialFuture’ ...
[10:32:50.079] - state: ‘finished’
[10:32:50.079] - run: TRUE
[10:32:50.079] - result: ‘FutureResult’
[10:32:50.079] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.081] resolve() on list ...
[10:32:50.081]  recursive: 0
[10:32:50.081]  length: 6
[10:32:50.081]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.081] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.081] - nx: 6
[10:32:50.081] - relay: TRUE
[10:32:50.081] - stdout: TRUE
[10:32:50.081] - signal: TRUE
[10:32:50.081] - resignal: FALSE
[10:32:50.081] - force: TRUE
[10:32:50.081] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.082] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.082]  - until=2
[10:32:50.082]  - relaying element #2
[10:32:50.082] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.082] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.082] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.082]  length: 5 (resolved future 1)
[10:32:50.082] resolved() for ‘SequentialFuture’ ...
[10:32:50.082] - state: ‘finished’
[10:32:50.082] - run: TRUE
[10:32:50.082] - result: ‘FutureResult’
[10:32:50.083] resolved() for ‘SequentialFuture’ ... done
[10:32:50.083] Future #2
[10:32:50.083] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.083] - nx: 6
[10:32:50.083] - relay: TRUE
[10:32:50.083] - stdout: TRUE
[10:32:50.083] - signal: TRUE
[10:32:50.083] - resignal: FALSE
[10:32:50.083] - force: TRUE
[10:32:50.083] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.083] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.083]  - until=2
[10:32:50.084]  - relaying element #2
[10:32:50.084] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.084] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.084] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.084]  length: 4 (resolved future 2)
[10:32:50.084] resolved() for ‘SequentialFuture’ ...
[10:32:50.084] - state: ‘finished’
[10:32:50.084] - run: TRUE
[10:32:50.084] - result: ‘FutureResult’
[10:32:50.084] resolved() for ‘SequentialFuture’ ... done
[10:32:50.085] Future #3
[10:32:50.085] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.085] - nx: 6
[10:32:50.085] - relay: TRUE
[10:32:50.085] - stdout: TRUE
[10:32:50.085] - signal: TRUE
[10:32:50.085] - resignal: FALSE
[10:32:50.085] - force: TRUE
[10:32:50.085] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.085] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.085]  - until=3
[10:32:50.085]  - relaying element #3
[10:32:50.086] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.086] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.086] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.086]  length: 3 (resolved future 3)
[10:32:50.086] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.086] - nx: 6
[10:32:50.086] - relay: TRUE
[10:32:50.086] - stdout: TRUE
[10:32:50.086] - signal: TRUE
[10:32:50.086] - resignal: FALSE
[10:32:50.086] - force: TRUE
[10:32:50.087] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.087] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.087]  - until=5
[10:32:50.087]  - relaying element #5
[10:32:50.087] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.087] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.087] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.087]  length: 2 (resolved future 4)
[10:32:50.087] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.087] - nx: 6
[10:32:50.087] - relay: TRUE
[10:32:50.087] - stdout: TRUE
[10:32:50.087] - signal: TRUE
[10:32:50.088] - resignal: FALSE
[10:32:50.088] - force: TRUE
[10:32:50.088] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.088] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.088]  - until=6
[10:32:50.088]  - relaying element #6
[10:32:50.088] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.088] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.088] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.088]  length: 1 (resolved future 5)
[10:32:50.088] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.088] - nx: 6
[10:32:50.089] - relay: TRUE
[10:32:50.089] - stdout: TRUE
[10:32:50.089] - signal: TRUE
[10:32:50.089] - resignal: FALSE
[10:32:50.089] - force: TRUE
[10:32:50.089] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.089]  - until=6
[10:32:50.089] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.089] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.089]  length: 0 (resolved future 6)
[10:32:50.090] Relaying remaining futures
[10:32:50.090] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.090] - nx: 6
[10:32:50.090] - relay: TRUE
[10:32:50.090] - stdout: TRUE
[10:32:50.090] - signal: TRUE
[10:32:50.090] - resignal: FALSE
[10:32:50.090] - force: TRUE
[10:32:50.090] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.090] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.090] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.090] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.091] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.091] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:32:50.094] getGlobalsAndPackages() ...
[10:32:50.095] Searching for globals...
[10:32:50.095] 
[10:32:50.095] Searching for globals ... DONE
[10:32:50.095] - globals: [0] <none>
[10:32:50.095] getGlobalsAndPackages() ... DONE
[10:32:50.095] run() for ‘Future’ ...
[10:32:50.095] - state: ‘created’
[10:32:50.096] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.096] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.096]   - Field: ‘label’
[10:32:50.096]   - Field: ‘local’
[10:32:50.096]   - Field: ‘owner’
[10:32:50.096]   - Field: ‘envir’
[10:32:50.096]   - Field: ‘packages’
[10:32:50.096]   - Field: ‘gc’
[10:32:50.096]   - Field: ‘conditions’
[10:32:50.097]   - Field: ‘expr’
[10:32:50.097]   - Field: ‘uuid’
[10:32:50.097]   - Field: ‘seed’
[10:32:50.097]   - Field: ‘version’
[10:32:50.097]   - Field: ‘result’
[10:32:50.097]   - Field: ‘asynchronous’
[10:32:50.097]   - Field: ‘calls’
[10:32:50.097]   - Field: ‘globals’
[10:32:50.097]   - Field: ‘stdout’
[10:32:50.097]   - Field: ‘earlySignal’
[10:32:50.097]   - Field: ‘lazy’
[10:32:50.098]   - Field: ‘state’
[10:32:50.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.098] - Launch lazy future ...
[10:32:50.098] Packages needed by the future expression (n = 0): <none>
[10:32:50.098] Packages needed by future strategies (n = 0): <none>
[10:32:50.098] {
[10:32:50.098]     {
[10:32:50.098]         {
[10:32:50.098]             ...future.startTime <- base::Sys.time()
[10:32:50.098]             {
[10:32:50.098]                 {
[10:32:50.098]                   {
[10:32:50.098]                     base::local({
[10:32:50.098]                       has_future <- base::requireNamespace("future", 
[10:32:50.098]                         quietly = TRUE)
[10:32:50.098]                       if (has_future) {
[10:32:50.098]                         ns <- base::getNamespace("future")
[10:32:50.098]                         version <- ns[[".package"]][["version"]]
[10:32:50.098]                         if (is.null(version)) 
[10:32:50.098]                           version <- utils::packageVersion("future")
[10:32:50.098]                       }
[10:32:50.098]                       else {
[10:32:50.098]                         version <- NULL
[10:32:50.098]                       }
[10:32:50.098]                       if (!has_future || version < "1.8.0") {
[10:32:50.098]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.098]                           "", base::R.version$version.string), 
[10:32:50.098]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.098]                             "release", "version")], collapse = " "), 
[10:32:50.098]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.098]                           info)
[10:32:50.098]                         info <- base::paste(info, collapse = "; ")
[10:32:50.098]                         if (!has_future) {
[10:32:50.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.098]                             info)
[10:32:50.098]                         }
[10:32:50.098]                         else {
[10:32:50.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.098]                             info, version)
[10:32:50.098]                         }
[10:32:50.098]                         base::stop(msg)
[10:32:50.098]                       }
[10:32:50.098]                     })
[10:32:50.098]                   }
[10:32:50.098]                   ...future.strategy.old <- future::plan("list")
[10:32:50.098]                   options(future.plan = NULL)
[10:32:50.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.098]                 }
[10:32:50.098]                 ...future.workdir <- getwd()
[10:32:50.098]             }
[10:32:50.098]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.098]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.098]         }
[10:32:50.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.098]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.098]             base::names(...future.oldOptions))
[10:32:50.098]     }
[10:32:50.098]     if (FALSE) {
[10:32:50.098]     }
[10:32:50.098]     else {
[10:32:50.098]         if (TRUE) {
[10:32:50.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.098]                 open = "w")
[10:32:50.098]         }
[10:32:50.098]         else {
[10:32:50.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.098]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.098]         }
[10:32:50.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.098]             base::sink(type = "output", split = FALSE)
[10:32:50.098]             base::close(...future.stdout)
[10:32:50.098]         }, add = TRUE)
[10:32:50.098]     }
[10:32:50.098]     ...future.frame <- base::sys.nframe()
[10:32:50.098]     ...future.conditions <- base::list()
[10:32:50.098]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.098]     if (FALSE) {
[10:32:50.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.098]     }
[10:32:50.098]     ...future.result <- base::tryCatch({
[10:32:50.098]         base::withCallingHandlers({
[10:32:50.098]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.098]             future::FutureResult(value = ...future.value$value, 
[10:32:50.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.098]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.098]                     ...future.globalenv.names))
[10:32:50.098]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.098]         }, condition = base::local({
[10:32:50.098]             c <- base::c
[10:32:50.098]             inherits <- base::inherits
[10:32:50.098]             invokeRestart <- base::invokeRestart
[10:32:50.098]             length <- base::length
[10:32:50.098]             list <- base::list
[10:32:50.098]             seq.int <- base::seq.int
[10:32:50.098]             signalCondition <- base::signalCondition
[10:32:50.098]             sys.calls <- base::sys.calls
[10:32:50.098]             `[[` <- base::`[[`
[10:32:50.098]             `+` <- base::`+`
[10:32:50.098]             `<<-` <- base::`<<-`
[10:32:50.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.098]                   3L)]
[10:32:50.098]             }
[10:32:50.098]             function(cond) {
[10:32:50.098]                 is_error <- inherits(cond, "error")
[10:32:50.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.098]                   NULL)
[10:32:50.098]                 if (is_error) {
[10:32:50.098]                   sessionInformation <- function() {
[10:32:50.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.098]                       search = base::search(), system = base::Sys.info())
[10:32:50.098]                   }
[10:32:50.098]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.098]                     cond$call), session = sessionInformation(), 
[10:32:50.098]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.098]                   signalCondition(cond)
[10:32:50.098]                 }
[10:32:50.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.098]                 "immediateCondition"))) {
[10:32:50.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.098]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.098]                   if (TRUE && !signal) {
[10:32:50.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.098]                     {
[10:32:50.098]                       inherits <- base::inherits
[10:32:50.098]                       invokeRestart <- base::invokeRestart
[10:32:50.098]                       is.null <- base::is.null
[10:32:50.098]                       muffled <- FALSE
[10:32:50.098]                       if (inherits(cond, "message")) {
[10:32:50.098]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.098]                         if (muffled) 
[10:32:50.098]                           invokeRestart("muffleMessage")
[10:32:50.098]                       }
[10:32:50.098]                       else if (inherits(cond, "warning")) {
[10:32:50.098]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.098]                         if (muffled) 
[10:32:50.098]                           invokeRestart("muffleWarning")
[10:32:50.098]                       }
[10:32:50.098]                       else if (inherits(cond, "condition")) {
[10:32:50.098]                         if (!is.null(pattern)) {
[10:32:50.098]                           computeRestarts <- base::computeRestarts
[10:32:50.098]                           grepl <- base::grepl
[10:32:50.098]                           restarts <- computeRestarts(cond)
[10:32:50.098]                           for (restart in restarts) {
[10:32:50.098]                             name <- restart$name
[10:32:50.098]                             if (is.null(name)) 
[10:32:50.098]                               next
[10:32:50.098]                             if (!grepl(pattern, name)) 
[10:32:50.098]                               next
[10:32:50.098]                             invokeRestart(restart)
[10:32:50.098]                             muffled <- TRUE
[10:32:50.098]                             break
[10:32:50.098]                           }
[10:32:50.098]                         }
[10:32:50.098]                       }
[10:32:50.098]                       invisible(muffled)
[10:32:50.098]                     }
[10:32:50.098]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.098]                   }
[10:32:50.098]                 }
[10:32:50.098]                 else {
[10:32:50.098]                   if (TRUE) {
[10:32:50.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.098]                     {
[10:32:50.098]                       inherits <- base::inherits
[10:32:50.098]                       invokeRestart <- base::invokeRestart
[10:32:50.098]                       is.null <- base::is.null
[10:32:50.098]                       muffled <- FALSE
[10:32:50.098]                       if (inherits(cond, "message")) {
[10:32:50.098]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.098]                         if (muffled) 
[10:32:50.098]                           invokeRestart("muffleMessage")
[10:32:50.098]                       }
[10:32:50.098]                       else if (inherits(cond, "warning")) {
[10:32:50.098]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.098]                         if (muffled) 
[10:32:50.098]                           invokeRestart("muffleWarning")
[10:32:50.098]                       }
[10:32:50.098]                       else if (inherits(cond, "condition")) {
[10:32:50.098]                         if (!is.null(pattern)) {
[10:32:50.098]                           computeRestarts <- base::computeRestarts
[10:32:50.098]                           grepl <- base::grepl
[10:32:50.098]                           restarts <- computeRestarts(cond)
[10:32:50.098]                           for (restart in restarts) {
[10:32:50.098]                             name <- restart$name
[10:32:50.098]                             if (is.null(name)) 
[10:32:50.098]                               next
[10:32:50.098]                             if (!grepl(pattern, name)) 
[10:32:50.098]                               next
[10:32:50.098]                             invokeRestart(restart)
[10:32:50.098]                             muffled <- TRUE
[10:32:50.098]                             break
[10:32:50.098]                           }
[10:32:50.098]                         }
[10:32:50.098]                       }
[10:32:50.098]                       invisible(muffled)
[10:32:50.098]                     }
[10:32:50.098]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.098]                   }
[10:32:50.098]                 }
[10:32:50.098]             }
[10:32:50.098]         }))
[10:32:50.098]     }, error = function(ex) {
[10:32:50.098]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.098]                 ...future.rng), started = ...future.startTime, 
[10:32:50.098]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.098]             version = "1.8"), class = "FutureResult")
[10:32:50.098]     }, finally = {
[10:32:50.098]         if (!identical(...future.workdir, getwd())) 
[10:32:50.098]             setwd(...future.workdir)
[10:32:50.098]         {
[10:32:50.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.098]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.098]             }
[10:32:50.098]             base::options(...future.oldOptions)
[10:32:50.098]             if (.Platform$OS.type == "windows") {
[10:32:50.098]                 old_names <- names(...future.oldEnvVars)
[10:32:50.098]                 envs <- base::Sys.getenv()
[10:32:50.098]                 names <- names(envs)
[10:32:50.098]                 common <- intersect(names, old_names)
[10:32:50.098]                 added <- setdiff(names, old_names)
[10:32:50.098]                 removed <- setdiff(old_names, names)
[10:32:50.098]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.098]                   envs[common]]
[10:32:50.098]                 NAMES <- toupper(changed)
[10:32:50.098]                 args <- list()
[10:32:50.098]                 for (kk in seq_along(NAMES)) {
[10:32:50.098]                   name <- changed[[kk]]
[10:32:50.098]                   NAME <- NAMES[[kk]]
[10:32:50.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.098]                     next
[10:32:50.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.098]                 }
[10:32:50.098]                 NAMES <- toupper(added)
[10:32:50.098]                 for (kk in seq_along(NAMES)) {
[10:32:50.098]                   name <- added[[kk]]
[10:32:50.098]                   NAME <- NAMES[[kk]]
[10:32:50.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.098]                     next
[10:32:50.098]                   args[[name]] <- ""
[10:32:50.098]                 }
[10:32:50.098]                 NAMES <- toupper(removed)
[10:32:50.098]                 for (kk in seq_along(NAMES)) {
[10:32:50.098]                   name <- removed[[kk]]
[10:32:50.098]                   NAME <- NAMES[[kk]]
[10:32:50.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.098]                     next
[10:32:50.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.098]                 }
[10:32:50.098]                 if (length(args) > 0) 
[10:32:50.098]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.098]             }
[10:32:50.098]             else {
[10:32:50.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.098]             }
[10:32:50.098]             {
[10:32:50.098]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.098]                   0L) {
[10:32:50.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.098]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.098]                   base::options(opts)
[10:32:50.098]                 }
[10:32:50.098]                 {
[10:32:50.098]                   {
[10:32:50.098]                     NULL
[10:32:50.098]                     RNGkind("Mersenne-Twister")
[10:32:50.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.098]                       inherits = FALSE)
[10:32:50.098]                   }
[10:32:50.098]                   options(future.plan = NULL)
[10:32:50.098]                   if (is.na(NA_character_)) 
[10:32:50.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.098]                     .init = FALSE)
[10:32:50.098]                 }
[10:32:50.098]             }
[10:32:50.098]         }
[10:32:50.098]     })
[10:32:50.098]     if (TRUE) {
[10:32:50.098]         base::sink(type = "output", split = FALSE)
[10:32:50.098]         if (TRUE) {
[10:32:50.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.098]         }
[10:32:50.098]         else {
[10:32:50.098]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.098]         }
[10:32:50.098]         base::close(...future.stdout)
[10:32:50.098]         ...future.stdout <- NULL
[10:32:50.098]     }
[10:32:50.098]     ...future.result$conditions <- ...future.conditions
[10:32:50.098]     ...future.result$finished <- base::Sys.time()
[10:32:50.098]     ...future.result
[10:32:50.098] }
[10:32:50.100] plan(): Setting new future strategy stack:
[10:32:50.100] List of future strategies:
[10:32:50.100] 1. sequential:
[10:32:50.100]    - args: function (..., envir = parent.frame())
[10:32:50.100]    - tweaked: FALSE
[10:32:50.100]    - call: NULL
[10:32:50.100] plan(): nbrOfWorkers() = 1
[10:32:50.101] plan(): Setting new future strategy stack:
[10:32:50.101] List of future strategies:
[10:32:50.101] 1. sequential:
[10:32:50.101]    - args: function (..., envir = parent.frame())
[10:32:50.101]    - tweaked: FALSE
[10:32:50.101]    - call: plan(strategy)
[10:32:50.102] plan(): nbrOfWorkers() = 1
[10:32:50.102] SequentialFuture started (and completed)
[10:32:50.102] - Launch lazy future ... done
[10:32:50.102] run() for ‘SequentialFuture’ ... done
[10:32:50.102] getGlobalsAndPackages() ...
[10:32:50.102] Searching for globals...
[10:32:50.102] 
[10:32:50.102] Searching for globals ... DONE
[10:32:50.103] - globals: [0] <none>
[10:32:50.103] getGlobalsAndPackages() ... DONE
[10:32:50.103] run() for ‘Future’ ...
[10:32:50.103] - state: ‘created’
[10:32:50.103] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.103] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.103]   - Field: ‘label’
[10:32:50.104]   - Field: ‘local’
[10:32:50.104]   - Field: ‘owner’
[10:32:50.104]   - Field: ‘envir’
[10:32:50.104]   - Field: ‘packages’
[10:32:50.104]   - Field: ‘gc’
[10:32:50.104]   - Field: ‘conditions’
[10:32:50.104]   - Field: ‘expr’
[10:32:50.104]   - Field: ‘uuid’
[10:32:50.104]   - Field: ‘seed’
[10:32:50.104]   - Field: ‘version’
[10:32:50.104]   - Field: ‘result’
[10:32:50.105]   - Field: ‘asynchronous’
[10:32:50.105]   - Field: ‘calls’
[10:32:50.105]   - Field: ‘globals’
[10:32:50.105]   - Field: ‘stdout’
[10:32:50.105]   - Field: ‘earlySignal’
[10:32:50.105]   - Field: ‘lazy’
[10:32:50.105]   - Field: ‘state’
[10:32:50.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.105] - Launch lazy future ...
[10:32:50.105] Packages needed by the future expression (n = 0): <none>
[10:32:50.106] Packages needed by future strategies (n = 0): <none>
[10:32:50.106] {
[10:32:50.106]     {
[10:32:50.106]         {
[10:32:50.106]             ...future.startTime <- base::Sys.time()
[10:32:50.106]             {
[10:32:50.106]                 {
[10:32:50.106]                   {
[10:32:50.106]                     base::local({
[10:32:50.106]                       has_future <- base::requireNamespace("future", 
[10:32:50.106]                         quietly = TRUE)
[10:32:50.106]                       if (has_future) {
[10:32:50.106]                         ns <- base::getNamespace("future")
[10:32:50.106]                         version <- ns[[".package"]][["version"]]
[10:32:50.106]                         if (is.null(version)) 
[10:32:50.106]                           version <- utils::packageVersion("future")
[10:32:50.106]                       }
[10:32:50.106]                       else {
[10:32:50.106]                         version <- NULL
[10:32:50.106]                       }
[10:32:50.106]                       if (!has_future || version < "1.8.0") {
[10:32:50.106]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.106]                           "", base::R.version$version.string), 
[10:32:50.106]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.106]                             "release", "version")], collapse = " "), 
[10:32:50.106]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.106]                           info)
[10:32:50.106]                         info <- base::paste(info, collapse = "; ")
[10:32:50.106]                         if (!has_future) {
[10:32:50.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.106]                             info)
[10:32:50.106]                         }
[10:32:50.106]                         else {
[10:32:50.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.106]                             info, version)
[10:32:50.106]                         }
[10:32:50.106]                         base::stop(msg)
[10:32:50.106]                       }
[10:32:50.106]                     })
[10:32:50.106]                   }
[10:32:50.106]                   ...future.strategy.old <- future::plan("list")
[10:32:50.106]                   options(future.plan = NULL)
[10:32:50.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.106]                 }
[10:32:50.106]                 ...future.workdir <- getwd()
[10:32:50.106]             }
[10:32:50.106]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.106]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.106]         }
[10:32:50.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.106]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.106]             base::names(...future.oldOptions))
[10:32:50.106]     }
[10:32:50.106]     if (FALSE) {
[10:32:50.106]     }
[10:32:50.106]     else {
[10:32:50.106]         if (TRUE) {
[10:32:50.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.106]                 open = "w")
[10:32:50.106]         }
[10:32:50.106]         else {
[10:32:50.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.106]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.106]         }
[10:32:50.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.106]             base::sink(type = "output", split = FALSE)
[10:32:50.106]             base::close(...future.stdout)
[10:32:50.106]         }, add = TRUE)
[10:32:50.106]     }
[10:32:50.106]     ...future.frame <- base::sys.nframe()
[10:32:50.106]     ...future.conditions <- base::list()
[10:32:50.106]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.106]     if (FALSE) {
[10:32:50.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.106]     }
[10:32:50.106]     ...future.result <- base::tryCatch({
[10:32:50.106]         base::withCallingHandlers({
[10:32:50.106]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.106]             future::FutureResult(value = ...future.value$value, 
[10:32:50.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.106]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.106]                     ...future.globalenv.names))
[10:32:50.106]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.106]         }, condition = base::local({
[10:32:50.106]             c <- base::c
[10:32:50.106]             inherits <- base::inherits
[10:32:50.106]             invokeRestart <- base::invokeRestart
[10:32:50.106]             length <- base::length
[10:32:50.106]             list <- base::list
[10:32:50.106]             seq.int <- base::seq.int
[10:32:50.106]             signalCondition <- base::signalCondition
[10:32:50.106]             sys.calls <- base::sys.calls
[10:32:50.106]             `[[` <- base::`[[`
[10:32:50.106]             `+` <- base::`+`
[10:32:50.106]             `<<-` <- base::`<<-`
[10:32:50.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.106]                   3L)]
[10:32:50.106]             }
[10:32:50.106]             function(cond) {
[10:32:50.106]                 is_error <- inherits(cond, "error")
[10:32:50.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.106]                   NULL)
[10:32:50.106]                 if (is_error) {
[10:32:50.106]                   sessionInformation <- function() {
[10:32:50.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.106]                       search = base::search(), system = base::Sys.info())
[10:32:50.106]                   }
[10:32:50.106]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.106]                     cond$call), session = sessionInformation(), 
[10:32:50.106]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.106]                   signalCondition(cond)
[10:32:50.106]                 }
[10:32:50.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.106]                 "immediateCondition"))) {
[10:32:50.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.106]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.106]                   if (TRUE && !signal) {
[10:32:50.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.106]                     {
[10:32:50.106]                       inherits <- base::inherits
[10:32:50.106]                       invokeRestart <- base::invokeRestart
[10:32:50.106]                       is.null <- base::is.null
[10:32:50.106]                       muffled <- FALSE
[10:32:50.106]                       if (inherits(cond, "message")) {
[10:32:50.106]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.106]                         if (muffled) 
[10:32:50.106]                           invokeRestart("muffleMessage")
[10:32:50.106]                       }
[10:32:50.106]                       else if (inherits(cond, "warning")) {
[10:32:50.106]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.106]                         if (muffled) 
[10:32:50.106]                           invokeRestart("muffleWarning")
[10:32:50.106]                       }
[10:32:50.106]                       else if (inherits(cond, "condition")) {
[10:32:50.106]                         if (!is.null(pattern)) {
[10:32:50.106]                           computeRestarts <- base::computeRestarts
[10:32:50.106]                           grepl <- base::grepl
[10:32:50.106]                           restarts <- computeRestarts(cond)
[10:32:50.106]                           for (restart in restarts) {
[10:32:50.106]                             name <- restart$name
[10:32:50.106]                             if (is.null(name)) 
[10:32:50.106]                               next
[10:32:50.106]                             if (!grepl(pattern, name)) 
[10:32:50.106]                               next
[10:32:50.106]                             invokeRestart(restart)
[10:32:50.106]                             muffled <- TRUE
[10:32:50.106]                             break
[10:32:50.106]                           }
[10:32:50.106]                         }
[10:32:50.106]                       }
[10:32:50.106]                       invisible(muffled)
[10:32:50.106]                     }
[10:32:50.106]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.106]                   }
[10:32:50.106]                 }
[10:32:50.106]                 else {
[10:32:50.106]                   if (TRUE) {
[10:32:50.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.106]                     {
[10:32:50.106]                       inherits <- base::inherits
[10:32:50.106]                       invokeRestart <- base::invokeRestart
[10:32:50.106]                       is.null <- base::is.null
[10:32:50.106]                       muffled <- FALSE
[10:32:50.106]                       if (inherits(cond, "message")) {
[10:32:50.106]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.106]                         if (muffled) 
[10:32:50.106]                           invokeRestart("muffleMessage")
[10:32:50.106]                       }
[10:32:50.106]                       else if (inherits(cond, "warning")) {
[10:32:50.106]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.106]                         if (muffled) 
[10:32:50.106]                           invokeRestart("muffleWarning")
[10:32:50.106]                       }
[10:32:50.106]                       else if (inherits(cond, "condition")) {
[10:32:50.106]                         if (!is.null(pattern)) {
[10:32:50.106]                           computeRestarts <- base::computeRestarts
[10:32:50.106]                           grepl <- base::grepl
[10:32:50.106]                           restarts <- computeRestarts(cond)
[10:32:50.106]                           for (restart in restarts) {
[10:32:50.106]                             name <- restart$name
[10:32:50.106]                             if (is.null(name)) 
[10:32:50.106]                               next
[10:32:50.106]                             if (!grepl(pattern, name)) 
[10:32:50.106]                               next
[10:32:50.106]                             invokeRestart(restart)
[10:32:50.106]                             muffled <- TRUE
[10:32:50.106]                             break
[10:32:50.106]                           }
[10:32:50.106]                         }
[10:32:50.106]                       }
[10:32:50.106]                       invisible(muffled)
[10:32:50.106]                     }
[10:32:50.106]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.106]                   }
[10:32:50.106]                 }
[10:32:50.106]             }
[10:32:50.106]         }))
[10:32:50.106]     }, error = function(ex) {
[10:32:50.106]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.106]                 ...future.rng), started = ...future.startTime, 
[10:32:50.106]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.106]             version = "1.8"), class = "FutureResult")
[10:32:50.106]     }, finally = {
[10:32:50.106]         if (!identical(...future.workdir, getwd())) 
[10:32:50.106]             setwd(...future.workdir)
[10:32:50.106]         {
[10:32:50.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.106]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.106]             }
[10:32:50.106]             base::options(...future.oldOptions)
[10:32:50.106]             if (.Platform$OS.type == "windows") {
[10:32:50.106]                 old_names <- names(...future.oldEnvVars)
[10:32:50.106]                 envs <- base::Sys.getenv()
[10:32:50.106]                 names <- names(envs)
[10:32:50.106]                 common <- intersect(names, old_names)
[10:32:50.106]                 added <- setdiff(names, old_names)
[10:32:50.106]                 removed <- setdiff(old_names, names)
[10:32:50.106]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.106]                   envs[common]]
[10:32:50.106]                 NAMES <- toupper(changed)
[10:32:50.106]                 args <- list()
[10:32:50.106]                 for (kk in seq_along(NAMES)) {
[10:32:50.106]                   name <- changed[[kk]]
[10:32:50.106]                   NAME <- NAMES[[kk]]
[10:32:50.106]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.106]                     next
[10:32:50.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.106]                 }
[10:32:50.106]                 NAMES <- toupper(added)
[10:32:50.106]                 for (kk in seq_along(NAMES)) {
[10:32:50.106]                   name <- added[[kk]]
[10:32:50.106]                   NAME <- NAMES[[kk]]
[10:32:50.106]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.106]                     next
[10:32:50.106]                   args[[name]] <- ""
[10:32:50.106]                 }
[10:32:50.106]                 NAMES <- toupper(removed)
[10:32:50.106]                 for (kk in seq_along(NAMES)) {
[10:32:50.106]                   name <- removed[[kk]]
[10:32:50.106]                   NAME <- NAMES[[kk]]
[10:32:50.106]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.106]                     next
[10:32:50.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.106]                 }
[10:32:50.106]                 if (length(args) > 0) 
[10:32:50.106]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.106]             }
[10:32:50.106]             else {
[10:32:50.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.106]             }
[10:32:50.106]             {
[10:32:50.106]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.106]                   0L) {
[10:32:50.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.106]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.106]                   base::options(opts)
[10:32:50.106]                 }
[10:32:50.106]                 {
[10:32:50.106]                   {
[10:32:50.106]                     NULL
[10:32:50.106]                     RNGkind("Mersenne-Twister")
[10:32:50.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.106]                       inherits = FALSE)
[10:32:50.106]                   }
[10:32:50.106]                   options(future.plan = NULL)
[10:32:50.106]                   if (is.na(NA_character_)) 
[10:32:50.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.106]                     .init = FALSE)
[10:32:50.106]                 }
[10:32:50.106]             }
[10:32:50.106]         }
[10:32:50.106]     })
[10:32:50.106]     if (TRUE) {
[10:32:50.106]         base::sink(type = "output", split = FALSE)
[10:32:50.106]         if (TRUE) {
[10:32:50.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.106]         }
[10:32:50.106]         else {
[10:32:50.106]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.106]         }
[10:32:50.106]         base::close(...future.stdout)
[10:32:50.106]         ...future.stdout <- NULL
[10:32:50.106]     }
[10:32:50.106]     ...future.result$conditions <- ...future.conditions
[10:32:50.106]     ...future.result$finished <- base::Sys.time()
[10:32:50.106]     ...future.result
[10:32:50.106] }
[10:32:50.108] plan(): Setting new future strategy stack:
[10:32:50.108] List of future strategies:
[10:32:50.108] 1. sequential:
[10:32:50.108]    - args: function (..., envir = parent.frame())
[10:32:50.108]    - tweaked: FALSE
[10:32:50.108]    - call: NULL
[10:32:50.108] plan(): nbrOfWorkers() = 1
[10:32:50.109] plan(): Setting new future strategy stack:
[10:32:50.109] List of future strategies:
[10:32:50.109] 1. sequential:
[10:32:50.109]    - args: function (..., envir = parent.frame())
[10:32:50.109]    - tweaked: FALSE
[10:32:50.109]    - call: plan(strategy)
[10:32:50.109] plan(): nbrOfWorkers() = 1
[10:32:50.109] SequentialFuture started (and completed)
[10:32:50.109] - Launch lazy future ... done
[10:32:50.110] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652cf022468> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0aebc30> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652cf022468> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0aebc30> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:50.114] resolved() for ‘SequentialFuture’ ...
[10:32:50.114] - state: ‘finished’
[10:32:50.115] - run: TRUE
[10:32:50.115] - result: ‘FutureResult’
[10:32:50.115] resolved() for ‘SequentialFuture’ ... done
[10:32:50.115] resolved() for ‘SequentialFuture’ ...
[10:32:50.115] - state: ‘finished’
[10:32:50.115] - run: TRUE
[10:32:50.115] - result: ‘FutureResult’
[10:32:50.115] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.117] resolve() on list ...
[10:32:50.117]  recursive: 0
[10:32:50.117]  length: 6
[10:32:50.117]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.117] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.117] - nx: 6
[10:32:50.117] - relay: TRUE
[10:32:50.117] - stdout: TRUE
[10:32:50.118] - signal: TRUE
[10:32:50.118] - resignal: FALSE
[10:32:50.118] - force: TRUE
[10:32:50.118] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.118]  - until=2
[10:32:50.118]  - relaying element #2
[10:32:50.118] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.118] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.118]  length: 5 (resolved future 1)
[10:32:50.119] resolved() for ‘SequentialFuture’ ...
[10:32:50.120] - state: ‘finished’
[10:32:50.120] - run: TRUE
[10:32:50.120] - result: ‘FutureResult’
[10:32:50.120] resolved() for ‘SequentialFuture’ ... done
[10:32:50.120] Future #2
[10:32:50.120] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.120] - nx: 6
[10:32:50.120] - relay: TRUE
[10:32:50.120] - stdout: TRUE
[10:32:50.120] - signal: TRUE
[10:32:50.120] - resignal: FALSE
[10:32:50.120] - force: TRUE
[10:32:50.121] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.121]  - until=2
[10:32:50.121]  - relaying element #2
[10:32:50.121] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.121] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.121] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.121]  length: 4 (resolved future 2)
[10:32:50.121] resolved() for ‘SequentialFuture’ ...
[10:32:50.121] - state: ‘finished’
[10:32:50.122] - run: TRUE
[10:32:50.122] - result: ‘FutureResult’
[10:32:50.122] resolved() for ‘SequentialFuture’ ... done
[10:32:50.122] Future #3
[10:32:50.122] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.122] - nx: 6
[10:32:50.122] - relay: TRUE
[10:32:50.122] - stdout: TRUE
[10:32:50.122] - signal: TRUE
[10:32:50.122] - resignal: FALSE
[10:32:50.122] - force: TRUE
[10:32:50.123] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.123] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.123]  - until=3
[10:32:50.123]  - relaying element #3
[10:32:50.123] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.123] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.123] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.123]  length: 3 (resolved future 3)
[10:32:50.123] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.123] - nx: 6
[10:32:50.123] - relay: TRUE
[10:32:50.124] - stdout: TRUE
[10:32:50.124] - signal: TRUE
[10:32:50.124] - resignal: FALSE
[10:32:50.124] - force: TRUE
[10:32:50.124] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.124] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.124]  - until=5
[10:32:50.124]  - relaying element #5
[10:32:50.124] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.124] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.124] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.124]  length: 2 (resolved future 4)
[10:32:50.125] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.125] - nx: 6
[10:32:50.125] - relay: TRUE
[10:32:50.125] - stdout: TRUE
[10:32:50.125] - signal: TRUE
[10:32:50.125] - resignal: FALSE
[10:32:50.125] - force: TRUE
[10:32:50.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.125] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.125]  - until=6
[10:32:50.125]  - relaying element #6
[10:32:50.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.126] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.126] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.126]  length: 1 (resolved future 5)
[10:32:50.126] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.126] - nx: 6
[10:32:50.126] - relay: TRUE
[10:32:50.126] - stdout: TRUE
[10:32:50.126] - signal: TRUE
[10:32:50.126] - resignal: FALSE
[10:32:50.126] - force: TRUE
[10:32:50.126] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.126] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.127]  - until=6
[10:32:50.127] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.127] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.127] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.127]  length: 0 (resolved future 6)
[10:32:50.127] Relaying remaining futures
[10:32:50.127] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.127] - nx: 6
[10:32:50.127] - relay: TRUE
[10:32:50.127] - stdout: TRUE
[10:32:50.127] - signal: TRUE
[10:32:50.127] - resignal: FALSE
[10:32:50.127] - force: TRUE
[10:32:50.128] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.128] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.128] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.128] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.128] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.128] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:32:50.131] getGlobalsAndPackages() ...
[10:32:50.131] Searching for globals...
[10:32:50.132] 
[10:32:50.132] Searching for globals ... DONE
[10:32:50.132] - globals: [0] <none>
[10:32:50.132] getGlobalsAndPackages() ... DONE
[10:32:50.132] run() for ‘Future’ ...
[10:32:50.132] - state: ‘created’
[10:32:50.133] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.133]   - Field: ‘label’
[10:32:50.133]   - Field: ‘local’
[10:32:50.133]   - Field: ‘owner’
[10:32:50.133]   - Field: ‘envir’
[10:32:50.133]   - Field: ‘packages’
[10:32:50.134]   - Field: ‘gc’
[10:32:50.134]   - Field: ‘conditions’
[10:32:50.134]   - Field: ‘expr’
[10:32:50.134]   - Field: ‘uuid’
[10:32:50.134]   - Field: ‘seed’
[10:32:50.134]   - Field: ‘version’
[10:32:50.134]   - Field: ‘result’
[10:32:50.134]   - Field: ‘asynchronous’
[10:32:50.134]   - Field: ‘calls’
[10:32:50.134]   - Field: ‘globals’
[10:32:50.134]   - Field: ‘stdout’
[10:32:50.134]   - Field: ‘earlySignal’
[10:32:50.135]   - Field: ‘lazy’
[10:32:50.135]   - Field: ‘state’
[10:32:50.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.135] - Launch lazy future ...
[10:32:50.135] Packages needed by the future expression (n = 0): <none>
[10:32:50.135] Packages needed by future strategies (n = 0): <none>
[10:32:50.136] {
[10:32:50.136]     {
[10:32:50.136]         {
[10:32:50.136]             ...future.startTime <- base::Sys.time()
[10:32:50.136]             {
[10:32:50.136]                 {
[10:32:50.136]                   {
[10:32:50.136]                     base::local({
[10:32:50.136]                       has_future <- base::requireNamespace("future", 
[10:32:50.136]                         quietly = TRUE)
[10:32:50.136]                       if (has_future) {
[10:32:50.136]                         ns <- base::getNamespace("future")
[10:32:50.136]                         version <- ns[[".package"]][["version"]]
[10:32:50.136]                         if (is.null(version)) 
[10:32:50.136]                           version <- utils::packageVersion("future")
[10:32:50.136]                       }
[10:32:50.136]                       else {
[10:32:50.136]                         version <- NULL
[10:32:50.136]                       }
[10:32:50.136]                       if (!has_future || version < "1.8.0") {
[10:32:50.136]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.136]                           "", base::R.version$version.string), 
[10:32:50.136]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.136]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.136]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.136]                             "release", "version")], collapse = " "), 
[10:32:50.136]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.136]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.136]                           info)
[10:32:50.136]                         info <- base::paste(info, collapse = "; ")
[10:32:50.136]                         if (!has_future) {
[10:32:50.136]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.136]                             info)
[10:32:50.136]                         }
[10:32:50.136]                         else {
[10:32:50.136]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.136]                             info, version)
[10:32:50.136]                         }
[10:32:50.136]                         base::stop(msg)
[10:32:50.136]                       }
[10:32:50.136]                     })
[10:32:50.136]                   }
[10:32:50.136]                   ...future.strategy.old <- future::plan("list")
[10:32:50.136]                   options(future.plan = NULL)
[10:32:50.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.136]                 }
[10:32:50.136]                 ...future.workdir <- getwd()
[10:32:50.136]             }
[10:32:50.136]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.136]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.136]         }
[10:32:50.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.136]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.136]             base::names(...future.oldOptions))
[10:32:50.136]     }
[10:32:50.136]     if (FALSE) {
[10:32:50.136]     }
[10:32:50.136]     else {
[10:32:50.136]         if (TRUE) {
[10:32:50.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.136]                 open = "w")
[10:32:50.136]         }
[10:32:50.136]         else {
[10:32:50.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.136]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.136]         }
[10:32:50.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.136]             base::sink(type = "output", split = FALSE)
[10:32:50.136]             base::close(...future.stdout)
[10:32:50.136]         }, add = TRUE)
[10:32:50.136]     }
[10:32:50.136]     ...future.frame <- base::sys.nframe()
[10:32:50.136]     ...future.conditions <- base::list()
[10:32:50.136]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.136]     if (FALSE) {
[10:32:50.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.136]     }
[10:32:50.136]     ...future.result <- base::tryCatch({
[10:32:50.136]         base::withCallingHandlers({
[10:32:50.136]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.136]             future::FutureResult(value = ...future.value$value, 
[10:32:50.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.136]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.136]                     ...future.globalenv.names))
[10:32:50.136]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.136]         }, condition = base::local({
[10:32:50.136]             c <- base::c
[10:32:50.136]             inherits <- base::inherits
[10:32:50.136]             invokeRestart <- base::invokeRestart
[10:32:50.136]             length <- base::length
[10:32:50.136]             list <- base::list
[10:32:50.136]             seq.int <- base::seq.int
[10:32:50.136]             signalCondition <- base::signalCondition
[10:32:50.136]             sys.calls <- base::sys.calls
[10:32:50.136]             `[[` <- base::`[[`
[10:32:50.136]             `+` <- base::`+`
[10:32:50.136]             `<<-` <- base::`<<-`
[10:32:50.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.136]                   3L)]
[10:32:50.136]             }
[10:32:50.136]             function(cond) {
[10:32:50.136]                 is_error <- inherits(cond, "error")
[10:32:50.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.136]                   NULL)
[10:32:50.136]                 if (is_error) {
[10:32:50.136]                   sessionInformation <- function() {
[10:32:50.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.136]                       search = base::search(), system = base::Sys.info())
[10:32:50.136]                   }
[10:32:50.136]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.136]                     cond$call), session = sessionInformation(), 
[10:32:50.136]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.136]                   signalCondition(cond)
[10:32:50.136]                 }
[10:32:50.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.136]                 "immediateCondition"))) {
[10:32:50.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.136]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.136]                   if (TRUE && !signal) {
[10:32:50.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.136]                     {
[10:32:50.136]                       inherits <- base::inherits
[10:32:50.136]                       invokeRestart <- base::invokeRestart
[10:32:50.136]                       is.null <- base::is.null
[10:32:50.136]                       muffled <- FALSE
[10:32:50.136]                       if (inherits(cond, "message")) {
[10:32:50.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.136]                         if (muffled) 
[10:32:50.136]                           invokeRestart("muffleMessage")
[10:32:50.136]                       }
[10:32:50.136]                       else if (inherits(cond, "warning")) {
[10:32:50.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.136]                         if (muffled) 
[10:32:50.136]                           invokeRestart("muffleWarning")
[10:32:50.136]                       }
[10:32:50.136]                       else if (inherits(cond, "condition")) {
[10:32:50.136]                         if (!is.null(pattern)) {
[10:32:50.136]                           computeRestarts <- base::computeRestarts
[10:32:50.136]                           grepl <- base::grepl
[10:32:50.136]                           restarts <- computeRestarts(cond)
[10:32:50.136]                           for (restart in restarts) {
[10:32:50.136]                             name <- restart$name
[10:32:50.136]                             if (is.null(name)) 
[10:32:50.136]                               next
[10:32:50.136]                             if (!grepl(pattern, name)) 
[10:32:50.136]                               next
[10:32:50.136]                             invokeRestart(restart)
[10:32:50.136]                             muffled <- TRUE
[10:32:50.136]                             break
[10:32:50.136]                           }
[10:32:50.136]                         }
[10:32:50.136]                       }
[10:32:50.136]                       invisible(muffled)
[10:32:50.136]                     }
[10:32:50.136]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.136]                   }
[10:32:50.136]                 }
[10:32:50.136]                 else {
[10:32:50.136]                   if (TRUE) {
[10:32:50.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.136]                     {
[10:32:50.136]                       inherits <- base::inherits
[10:32:50.136]                       invokeRestart <- base::invokeRestart
[10:32:50.136]                       is.null <- base::is.null
[10:32:50.136]                       muffled <- FALSE
[10:32:50.136]                       if (inherits(cond, "message")) {
[10:32:50.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.136]                         if (muffled) 
[10:32:50.136]                           invokeRestart("muffleMessage")
[10:32:50.136]                       }
[10:32:50.136]                       else if (inherits(cond, "warning")) {
[10:32:50.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.136]                         if (muffled) 
[10:32:50.136]                           invokeRestart("muffleWarning")
[10:32:50.136]                       }
[10:32:50.136]                       else if (inherits(cond, "condition")) {
[10:32:50.136]                         if (!is.null(pattern)) {
[10:32:50.136]                           computeRestarts <- base::computeRestarts
[10:32:50.136]                           grepl <- base::grepl
[10:32:50.136]                           restarts <- computeRestarts(cond)
[10:32:50.136]                           for (restart in restarts) {
[10:32:50.136]                             name <- restart$name
[10:32:50.136]                             if (is.null(name)) 
[10:32:50.136]                               next
[10:32:50.136]                             if (!grepl(pattern, name)) 
[10:32:50.136]                               next
[10:32:50.136]                             invokeRestart(restart)
[10:32:50.136]                             muffled <- TRUE
[10:32:50.136]                             break
[10:32:50.136]                           }
[10:32:50.136]                         }
[10:32:50.136]                       }
[10:32:50.136]                       invisible(muffled)
[10:32:50.136]                     }
[10:32:50.136]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.136]                   }
[10:32:50.136]                 }
[10:32:50.136]             }
[10:32:50.136]         }))
[10:32:50.136]     }, error = function(ex) {
[10:32:50.136]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.136]                 ...future.rng), started = ...future.startTime, 
[10:32:50.136]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.136]             version = "1.8"), class = "FutureResult")
[10:32:50.136]     }, finally = {
[10:32:50.136]         if (!identical(...future.workdir, getwd())) 
[10:32:50.136]             setwd(...future.workdir)
[10:32:50.136]         {
[10:32:50.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.136]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.136]             }
[10:32:50.136]             base::options(...future.oldOptions)
[10:32:50.136]             if (.Platform$OS.type == "windows") {
[10:32:50.136]                 old_names <- names(...future.oldEnvVars)
[10:32:50.136]                 envs <- base::Sys.getenv()
[10:32:50.136]                 names <- names(envs)
[10:32:50.136]                 common <- intersect(names, old_names)
[10:32:50.136]                 added <- setdiff(names, old_names)
[10:32:50.136]                 removed <- setdiff(old_names, names)
[10:32:50.136]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.136]                   envs[common]]
[10:32:50.136]                 NAMES <- toupper(changed)
[10:32:50.136]                 args <- list()
[10:32:50.136]                 for (kk in seq_along(NAMES)) {
[10:32:50.136]                   name <- changed[[kk]]
[10:32:50.136]                   NAME <- NAMES[[kk]]
[10:32:50.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.136]                     next
[10:32:50.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.136]                 }
[10:32:50.136]                 NAMES <- toupper(added)
[10:32:50.136]                 for (kk in seq_along(NAMES)) {
[10:32:50.136]                   name <- added[[kk]]
[10:32:50.136]                   NAME <- NAMES[[kk]]
[10:32:50.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.136]                     next
[10:32:50.136]                   args[[name]] <- ""
[10:32:50.136]                 }
[10:32:50.136]                 NAMES <- toupper(removed)
[10:32:50.136]                 for (kk in seq_along(NAMES)) {
[10:32:50.136]                   name <- removed[[kk]]
[10:32:50.136]                   NAME <- NAMES[[kk]]
[10:32:50.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.136]                     next
[10:32:50.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.136]                 }
[10:32:50.136]                 if (length(args) > 0) 
[10:32:50.136]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.136]             }
[10:32:50.136]             else {
[10:32:50.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.136]             }
[10:32:50.136]             {
[10:32:50.136]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.136]                   0L) {
[10:32:50.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.136]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.136]                   base::options(opts)
[10:32:50.136]                 }
[10:32:50.136]                 {
[10:32:50.136]                   {
[10:32:50.136]                     NULL
[10:32:50.136]                     RNGkind("Mersenne-Twister")
[10:32:50.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.136]                       inherits = FALSE)
[10:32:50.136]                   }
[10:32:50.136]                   options(future.plan = NULL)
[10:32:50.136]                   if (is.na(NA_character_)) 
[10:32:50.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.136]                     .init = FALSE)
[10:32:50.136]                 }
[10:32:50.136]             }
[10:32:50.136]         }
[10:32:50.136]     })
[10:32:50.136]     if (TRUE) {
[10:32:50.136]         base::sink(type = "output", split = FALSE)
[10:32:50.136]         if (TRUE) {
[10:32:50.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.136]         }
[10:32:50.136]         else {
[10:32:50.136]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.136]         }
[10:32:50.136]         base::close(...future.stdout)
[10:32:50.136]         ...future.stdout <- NULL
[10:32:50.136]     }
[10:32:50.136]     ...future.result$conditions <- ...future.conditions
[10:32:50.136]     ...future.result$finished <- base::Sys.time()
[10:32:50.136]     ...future.result
[10:32:50.136] }
[10:32:50.137] plan(): Setting new future strategy stack:
[10:32:50.137] List of future strategies:
[10:32:50.137] 1. sequential:
[10:32:50.137]    - args: function (..., envir = parent.frame())
[10:32:50.137]    - tweaked: FALSE
[10:32:50.137]    - call: NULL
[10:32:50.138] plan(): nbrOfWorkers() = 1
[10:32:50.139] plan(): Setting new future strategy stack:
[10:32:50.139] List of future strategies:
[10:32:50.139] 1. sequential:
[10:32:50.139]    - args: function (..., envir = parent.frame())
[10:32:50.139]    - tweaked: FALSE
[10:32:50.139]    - call: plan(strategy)
[10:32:50.139] plan(): nbrOfWorkers() = 1
[10:32:50.139] SequentialFuture started (and completed)
[10:32:50.139] - Launch lazy future ... done
[10:32:50.139] run() for ‘SequentialFuture’ ... done
[10:32:50.139] getGlobalsAndPackages() ...
[10:32:50.140] Searching for globals...
[10:32:50.140] 
[10:32:50.140] Searching for globals ... DONE
[10:32:50.140] - globals: [0] <none>
[10:32:50.140] getGlobalsAndPackages() ... DONE
[10:32:50.140] run() for ‘Future’ ...
[10:32:50.140] - state: ‘created’
[10:32:50.140] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.141] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.141] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.141]   - Field: ‘label’
[10:32:50.141]   - Field: ‘local’
[10:32:50.141]   - Field: ‘owner’
[10:32:50.141]   - Field: ‘envir’
[10:32:50.141]   - Field: ‘packages’
[10:32:50.141]   - Field: ‘gc’
[10:32:50.142]   - Field: ‘conditions’
[10:32:50.142]   - Field: ‘expr’
[10:32:50.142]   - Field: ‘uuid’
[10:32:50.142]   - Field: ‘seed’
[10:32:50.142]   - Field: ‘version’
[10:32:50.142]   - Field: ‘result’
[10:32:50.142]   - Field: ‘asynchronous’
[10:32:50.142]   - Field: ‘calls’
[10:32:50.142]   - Field: ‘globals’
[10:32:50.142]   - Field: ‘stdout’
[10:32:50.142]   - Field: ‘earlySignal’
[10:32:50.143]   - Field: ‘lazy’
[10:32:50.143]   - Field: ‘state’
[10:32:50.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.143] - Launch lazy future ...
[10:32:50.143] Packages needed by the future expression (n = 0): <none>
[10:32:50.143] Packages needed by future strategies (n = 0): <none>
[10:32:50.143] {
[10:32:50.143]     {
[10:32:50.143]         {
[10:32:50.143]             ...future.startTime <- base::Sys.time()
[10:32:50.143]             {
[10:32:50.143]                 {
[10:32:50.143]                   {
[10:32:50.143]                     base::local({
[10:32:50.143]                       has_future <- base::requireNamespace("future", 
[10:32:50.143]                         quietly = TRUE)
[10:32:50.143]                       if (has_future) {
[10:32:50.143]                         ns <- base::getNamespace("future")
[10:32:50.143]                         version <- ns[[".package"]][["version"]]
[10:32:50.143]                         if (is.null(version)) 
[10:32:50.143]                           version <- utils::packageVersion("future")
[10:32:50.143]                       }
[10:32:50.143]                       else {
[10:32:50.143]                         version <- NULL
[10:32:50.143]                       }
[10:32:50.143]                       if (!has_future || version < "1.8.0") {
[10:32:50.143]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.143]                           "", base::R.version$version.string), 
[10:32:50.143]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.143]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.143]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.143]                             "release", "version")], collapse = " "), 
[10:32:50.143]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.143]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.143]                           info)
[10:32:50.143]                         info <- base::paste(info, collapse = "; ")
[10:32:50.143]                         if (!has_future) {
[10:32:50.143]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.143]                             info)
[10:32:50.143]                         }
[10:32:50.143]                         else {
[10:32:50.143]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.143]                             info, version)
[10:32:50.143]                         }
[10:32:50.143]                         base::stop(msg)
[10:32:50.143]                       }
[10:32:50.143]                     })
[10:32:50.143]                   }
[10:32:50.143]                   ...future.strategy.old <- future::plan("list")
[10:32:50.143]                   options(future.plan = NULL)
[10:32:50.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.143]                 }
[10:32:50.143]                 ...future.workdir <- getwd()
[10:32:50.143]             }
[10:32:50.143]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.143]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.143]         }
[10:32:50.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.143]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.143]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.143]             base::names(...future.oldOptions))
[10:32:50.143]     }
[10:32:50.143]     if (FALSE) {
[10:32:50.143]     }
[10:32:50.143]     else {
[10:32:50.143]         if (TRUE) {
[10:32:50.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.143]                 open = "w")
[10:32:50.143]         }
[10:32:50.143]         else {
[10:32:50.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.143]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.143]         }
[10:32:50.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.143]             base::sink(type = "output", split = FALSE)
[10:32:50.143]             base::close(...future.stdout)
[10:32:50.143]         }, add = TRUE)
[10:32:50.143]     }
[10:32:50.143]     ...future.frame <- base::sys.nframe()
[10:32:50.143]     ...future.conditions <- base::list()
[10:32:50.143]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.143]     if (FALSE) {
[10:32:50.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.143]     }
[10:32:50.143]     ...future.result <- base::tryCatch({
[10:32:50.143]         base::withCallingHandlers({
[10:32:50.143]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.143]             future::FutureResult(value = ...future.value$value, 
[10:32:50.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.143]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.143]                     ...future.globalenv.names))
[10:32:50.143]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.143]         }, condition = base::local({
[10:32:50.143]             c <- base::c
[10:32:50.143]             inherits <- base::inherits
[10:32:50.143]             invokeRestart <- base::invokeRestart
[10:32:50.143]             length <- base::length
[10:32:50.143]             list <- base::list
[10:32:50.143]             seq.int <- base::seq.int
[10:32:50.143]             signalCondition <- base::signalCondition
[10:32:50.143]             sys.calls <- base::sys.calls
[10:32:50.143]             `[[` <- base::`[[`
[10:32:50.143]             `+` <- base::`+`
[10:32:50.143]             `<<-` <- base::`<<-`
[10:32:50.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.143]                   3L)]
[10:32:50.143]             }
[10:32:50.143]             function(cond) {
[10:32:50.143]                 is_error <- inherits(cond, "error")
[10:32:50.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.143]                   NULL)
[10:32:50.143]                 if (is_error) {
[10:32:50.143]                   sessionInformation <- function() {
[10:32:50.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.143]                       search = base::search(), system = base::Sys.info())
[10:32:50.143]                   }
[10:32:50.143]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.143]                     cond$call), session = sessionInformation(), 
[10:32:50.143]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.143]                   signalCondition(cond)
[10:32:50.143]                 }
[10:32:50.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.143]                 "immediateCondition"))) {
[10:32:50.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.143]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.143]                   if (TRUE && !signal) {
[10:32:50.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.143]                     {
[10:32:50.143]                       inherits <- base::inherits
[10:32:50.143]                       invokeRestart <- base::invokeRestart
[10:32:50.143]                       is.null <- base::is.null
[10:32:50.143]                       muffled <- FALSE
[10:32:50.143]                       if (inherits(cond, "message")) {
[10:32:50.143]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.143]                         if (muffled) 
[10:32:50.143]                           invokeRestart("muffleMessage")
[10:32:50.143]                       }
[10:32:50.143]                       else if (inherits(cond, "warning")) {
[10:32:50.143]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.143]                         if (muffled) 
[10:32:50.143]                           invokeRestart("muffleWarning")
[10:32:50.143]                       }
[10:32:50.143]                       else if (inherits(cond, "condition")) {
[10:32:50.143]                         if (!is.null(pattern)) {
[10:32:50.143]                           computeRestarts <- base::computeRestarts
[10:32:50.143]                           grepl <- base::grepl
[10:32:50.143]                           restarts <- computeRestarts(cond)
[10:32:50.143]                           for (restart in restarts) {
[10:32:50.143]                             name <- restart$name
[10:32:50.143]                             if (is.null(name)) 
[10:32:50.143]                               next
[10:32:50.143]                             if (!grepl(pattern, name)) 
[10:32:50.143]                               next
[10:32:50.143]                             invokeRestart(restart)
[10:32:50.143]                             muffled <- TRUE
[10:32:50.143]                             break
[10:32:50.143]                           }
[10:32:50.143]                         }
[10:32:50.143]                       }
[10:32:50.143]                       invisible(muffled)
[10:32:50.143]                     }
[10:32:50.143]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.143]                   }
[10:32:50.143]                 }
[10:32:50.143]                 else {
[10:32:50.143]                   if (TRUE) {
[10:32:50.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.143]                     {
[10:32:50.143]                       inherits <- base::inherits
[10:32:50.143]                       invokeRestart <- base::invokeRestart
[10:32:50.143]                       is.null <- base::is.null
[10:32:50.143]                       muffled <- FALSE
[10:32:50.143]                       if (inherits(cond, "message")) {
[10:32:50.143]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.143]                         if (muffled) 
[10:32:50.143]                           invokeRestart("muffleMessage")
[10:32:50.143]                       }
[10:32:50.143]                       else if (inherits(cond, "warning")) {
[10:32:50.143]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.143]                         if (muffled) 
[10:32:50.143]                           invokeRestart("muffleWarning")
[10:32:50.143]                       }
[10:32:50.143]                       else if (inherits(cond, "condition")) {
[10:32:50.143]                         if (!is.null(pattern)) {
[10:32:50.143]                           computeRestarts <- base::computeRestarts
[10:32:50.143]                           grepl <- base::grepl
[10:32:50.143]                           restarts <- computeRestarts(cond)
[10:32:50.143]                           for (restart in restarts) {
[10:32:50.143]                             name <- restart$name
[10:32:50.143]                             if (is.null(name)) 
[10:32:50.143]                               next
[10:32:50.143]                             if (!grepl(pattern, name)) 
[10:32:50.143]                               next
[10:32:50.143]                             invokeRestart(restart)
[10:32:50.143]                             muffled <- TRUE
[10:32:50.143]                             break
[10:32:50.143]                           }
[10:32:50.143]                         }
[10:32:50.143]                       }
[10:32:50.143]                       invisible(muffled)
[10:32:50.143]                     }
[10:32:50.143]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.143]                   }
[10:32:50.143]                 }
[10:32:50.143]             }
[10:32:50.143]         }))
[10:32:50.143]     }, error = function(ex) {
[10:32:50.143]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.143]                 ...future.rng), started = ...future.startTime, 
[10:32:50.143]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.143]             version = "1.8"), class = "FutureResult")
[10:32:50.143]     }, finally = {
[10:32:50.143]         if (!identical(...future.workdir, getwd())) 
[10:32:50.143]             setwd(...future.workdir)
[10:32:50.143]         {
[10:32:50.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.143]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.143]             }
[10:32:50.143]             base::options(...future.oldOptions)
[10:32:50.143]             if (.Platform$OS.type == "windows") {
[10:32:50.143]                 old_names <- names(...future.oldEnvVars)
[10:32:50.143]                 envs <- base::Sys.getenv()
[10:32:50.143]                 names <- names(envs)
[10:32:50.143]                 common <- intersect(names, old_names)
[10:32:50.143]                 added <- setdiff(names, old_names)
[10:32:50.143]                 removed <- setdiff(old_names, names)
[10:32:50.143]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.143]                   envs[common]]
[10:32:50.143]                 NAMES <- toupper(changed)
[10:32:50.143]                 args <- list()
[10:32:50.143]                 for (kk in seq_along(NAMES)) {
[10:32:50.143]                   name <- changed[[kk]]
[10:32:50.143]                   NAME <- NAMES[[kk]]
[10:32:50.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.143]                     next
[10:32:50.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.143]                 }
[10:32:50.143]                 NAMES <- toupper(added)
[10:32:50.143]                 for (kk in seq_along(NAMES)) {
[10:32:50.143]                   name <- added[[kk]]
[10:32:50.143]                   NAME <- NAMES[[kk]]
[10:32:50.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.143]                     next
[10:32:50.143]                   args[[name]] <- ""
[10:32:50.143]                 }
[10:32:50.143]                 NAMES <- toupper(removed)
[10:32:50.143]                 for (kk in seq_along(NAMES)) {
[10:32:50.143]                   name <- removed[[kk]]
[10:32:50.143]                   NAME <- NAMES[[kk]]
[10:32:50.143]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.143]                     next
[10:32:50.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.143]                 }
[10:32:50.143]                 if (length(args) > 0) 
[10:32:50.143]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.143]             }
[10:32:50.143]             else {
[10:32:50.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.143]             }
[10:32:50.143]             {
[10:32:50.143]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.143]                   0L) {
[10:32:50.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.143]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.143]                   base::options(opts)
[10:32:50.143]                 }
[10:32:50.143]                 {
[10:32:50.143]                   {
[10:32:50.143]                     NULL
[10:32:50.143]                     RNGkind("Mersenne-Twister")
[10:32:50.143]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.143]                       inherits = FALSE)
[10:32:50.143]                   }
[10:32:50.143]                   options(future.plan = NULL)
[10:32:50.143]                   if (is.na(NA_character_)) 
[10:32:50.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.143]                     .init = FALSE)
[10:32:50.143]                 }
[10:32:50.143]             }
[10:32:50.143]         }
[10:32:50.143]     })
[10:32:50.143]     if (TRUE) {
[10:32:50.143]         base::sink(type = "output", split = FALSE)
[10:32:50.143]         if (TRUE) {
[10:32:50.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.143]         }
[10:32:50.143]         else {
[10:32:50.143]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.143]         }
[10:32:50.143]         base::close(...future.stdout)
[10:32:50.143]         ...future.stdout <- NULL
[10:32:50.143]     }
[10:32:50.143]     ...future.result$conditions <- ...future.conditions
[10:32:50.143]     ...future.result$finished <- base::Sys.time()
[10:32:50.143]     ...future.result
[10:32:50.143] }
[10:32:50.145] plan(): Setting new future strategy stack:
[10:32:50.145] List of future strategies:
[10:32:50.145] 1. sequential:
[10:32:50.145]    - args: function (..., envir = parent.frame())
[10:32:50.145]    - tweaked: FALSE
[10:32:50.145]    - call: NULL
[10:32:50.146] plan(): nbrOfWorkers() = 1
[10:32:50.148] plan(): Setting new future strategy stack:
[10:32:50.148] List of future strategies:
[10:32:50.148] 1. sequential:
[10:32:50.148]    - args: function (..., envir = parent.frame())
[10:32:50.148]    - tweaked: FALSE
[10:32:50.148]    - call: plan(strategy)
[10:32:50.148] plan(): nbrOfWorkers() = 1
[10:32:50.148] SequentialFuture started (and completed)
[10:32:50.148] - Launch lazy future ... done
[10:32:50.149] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0dc57f0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d121fd98> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d0dc57f0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5652d121fd98> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:50.154] resolved() for ‘SequentialFuture’ ...
[10:32:50.154] - state: ‘finished’
[10:32:50.154] - run: TRUE
[10:32:50.154] - result: ‘FutureResult’
[10:32:50.154] resolved() for ‘SequentialFuture’ ... done
[10:32:50.154] resolved() for ‘SequentialFuture’ ...
[10:32:50.154] - state: ‘finished’
[10:32:50.154] - run: TRUE
[10:32:50.155] - result: ‘FutureResult’
[10:32:50.155] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.157] resolve() on list ...
[10:32:50.157]  recursive: 0
[10:32:50.157]  length: 6
[10:32:50.157]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.157] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.157] - nx: 6
[10:32:50.157] - relay: TRUE
[10:32:50.157] - stdout: TRUE
[10:32:50.157] - signal: TRUE
[10:32:50.157] - resignal: FALSE
[10:32:50.157] - force: TRUE
[10:32:50.158] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.158] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.158]  - until=2
[10:32:50.158]  - relaying element #2
[10:32:50.158] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.158] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.158] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.158]  length: 5 (resolved future 1)
[10:32:50.158] resolved() for ‘SequentialFuture’ ...
[10:32:50.158] - state: ‘finished’
[10:32:50.158] - run: TRUE
[10:32:50.159] - result: ‘FutureResult’
[10:32:50.159] resolved() for ‘SequentialFuture’ ... done
[10:32:50.159] Future #2
[10:32:50.159] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.159] - nx: 6
[10:32:50.159] - relay: TRUE
[10:32:50.159] - stdout: TRUE
[10:32:50.159] - signal: TRUE
[10:32:50.159] - resignal: FALSE
[10:32:50.159] - force: TRUE
[10:32:50.159] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.160] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.160]  - until=2
[10:32:50.160]  - relaying element #2
[10:32:50.160] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.160] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.160] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.160]  length: 4 (resolved future 2)
[10:32:50.160] resolved() for ‘SequentialFuture’ ...
[10:32:50.160] - state: ‘finished’
[10:32:50.160] - run: TRUE
[10:32:50.161] - result: ‘FutureResult’
[10:32:50.161] resolved() for ‘SequentialFuture’ ... done
[10:32:50.161] Future #3
[10:32:50.161] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.161] - nx: 6
[10:32:50.161] - relay: TRUE
[10:32:50.161] - stdout: TRUE
[10:32:50.161] - signal: TRUE
[10:32:50.161] - resignal: FALSE
[10:32:50.161] - force: TRUE
[10:32:50.161] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.161] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.162]  - until=3
[10:32:50.162]  - relaying element #3
[10:32:50.162] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.162] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.162] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.162]  length: 3 (resolved future 3)
[10:32:50.162] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.162] - nx: 6
[10:32:50.162] - relay: TRUE
[10:32:50.162] - stdout: TRUE
[10:32:50.162] - signal: TRUE
[10:32:50.163] - resignal: FALSE
[10:32:50.163] - force: TRUE
[10:32:50.163] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.163] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.163]  - until=5
[10:32:50.163]  - relaying element #5
[10:32:50.163] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.163] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.163] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.163]  length: 2 (resolved future 4)
[10:32:50.163] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.163] - nx: 6
[10:32:50.164] - relay: TRUE
[10:32:50.164] - stdout: TRUE
[10:32:50.164] - signal: TRUE
[10:32:50.164] - resignal: FALSE
[10:32:50.164] - force: TRUE
[10:32:50.164] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.164] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.164]  - until=6
[10:32:50.164]  - relaying element #6
[10:32:50.164] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.164] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.164] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.164]  length: 1 (resolved future 5)
[10:32:50.165] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.165] - nx: 6
[10:32:50.165] - relay: TRUE
[10:32:50.165] - stdout: TRUE
[10:32:50.165] - signal: TRUE
[10:32:50.165] - resignal: FALSE
[10:32:50.165] - force: TRUE
[10:32:50.165] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.165] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.165]  - until=6
[10:32:50.165] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.165] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.166] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.166]  length: 0 (resolved future 6)
[10:32:50.166] Relaying remaining futures
[10:32:50.166] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.166] - nx: 6
[10:32:50.166] - relay: TRUE
[10:32:50.166] - stdout: TRUE
[10:32:50.166] - signal: TRUE
[10:32:50.166] - resignal: FALSE
[10:32:50.166] - force: TRUE
[10:32:50.166] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.166] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.167] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.167] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.167] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[10:32:50.176] plan(): Setting new future strategy stack:
[10:32:50.176] List of future strategies:
[10:32:50.176] 1. sequential:
[10:32:50.176]    - args: function (..., envir = parent.frame())
[10:32:50.176]    - tweaked: FALSE
[10:32:50.176]    - call: plan(strategy)
[10:32:50.176] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:32:50.176] getGlobalsAndPackages() ...
[10:32:50.177] Searching for globals...
[10:32:50.177] 
[10:32:50.177] Searching for globals ... DONE
[10:32:50.177] - globals: [0] <none>
[10:32:50.177] getGlobalsAndPackages() ... DONE
[10:32:50.177] run() for ‘Future’ ...
[10:32:50.177] - state: ‘created’
[10:32:50.178] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.178]   - Field: ‘label’
[10:32:50.178]   - Field: ‘local’
[10:32:50.178]   - Field: ‘owner’
[10:32:50.178]   - Field: ‘envir’
[10:32:50.178]   - Field: ‘packages’
[10:32:50.178]   - Field: ‘gc’
[10:32:50.179]   - Field: ‘conditions’
[10:32:50.179]   - Field: ‘expr’
[10:32:50.179]   - Field: ‘uuid’
[10:32:50.179]   - Field: ‘seed’
[10:32:50.179]   - Field: ‘version’
[10:32:50.179]   - Field: ‘result’
[10:32:50.179]   - Field: ‘asynchronous’
[10:32:50.179]   - Field: ‘calls’
[10:32:50.179]   - Field: ‘globals’
[10:32:50.179]   - Field: ‘stdout’
[10:32:50.179]   - Field: ‘earlySignal’
[10:32:50.180]   - Field: ‘lazy’
[10:32:50.180]   - Field: ‘state’
[10:32:50.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.180] - Launch lazy future ...
[10:32:50.180] Packages needed by the future expression (n = 0): <none>
[10:32:50.180] Packages needed by future strategies (n = 0): <none>
[10:32:50.180] {
[10:32:50.180]     {
[10:32:50.180]         {
[10:32:50.180]             ...future.startTime <- base::Sys.time()
[10:32:50.180]             {
[10:32:50.180]                 {
[10:32:50.180]                   {
[10:32:50.180]                     base::local({
[10:32:50.180]                       has_future <- base::requireNamespace("future", 
[10:32:50.180]                         quietly = TRUE)
[10:32:50.180]                       if (has_future) {
[10:32:50.180]                         ns <- base::getNamespace("future")
[10:32:50.180]                         version <- ns[[".package"]][["version"]]
[10:32:50.180]                         if (is.null(version)) 
[10:32:50.180]                           version <- utils::packageVersion("future")
[10:32:50.180]                       }
[10:32:50.180]                       else {
[10:32:50.180]                         version <- NULL
[10:32:50.180]                       }
[10:32:50.180]                       if (!has_future || version < "1.8.0") {
[10:32:50.180]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.180]                           "", base::R.version$version.string), 
[10:32:50.180]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.180]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.180]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.180]                             "release", "version")], collapse = " "), 
[10:32:50.180]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.180]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.180]                           info)
[10:32:50.180]                         info <- base::paste(info, collapse = "; ")
[10:32:50.180]                         if (!has_future) {
[10:32:50.180]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.180]                             info)
[10:32:50.180]                         }
[10:32:50.180]                         else {
[10:32:50.180]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.180]                             info, version)
[10:32:50.180]                         }
[10:32:50.180]                         base::stop(msg)
[10:32:50.180]                       }
[10:32:50.180]                     })
[10:32:50.180]                   }
[10:32:50.180]                   ...future.strategy.old <- future::plan("list")
[10:32:50.180]                   options(future.plan = NULL)
[10:32:50.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.180]                 }
[10:32:50.180]                 ...future.workdir <- getwd()
[10:32:50.180]             }
[10:32:50.180]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.180]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.180]         }
[10:32:50.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.180]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.180]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.180]             base::names(...future.oldOptions))
[10:32:50.180]     }
[10:32:50.180]     if (FALSE) {
[10:32:50.180]     }
[10:32:50.180]     else {
[10:32:50.180]         if (TRUE) {
[10:32:50.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.180]                 open = "w")
[10:32:50.180]         }
[10:32:50.180]         else {
[10:32:50.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.180]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.180]         }
[10:32:50.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.180]             base::sink(type = "output", split = FALSE)
[10:32:50.180]             base::close(...future.stdout)
[10:32:50.180]         }, add = TRUE)
[10:32:50.180]     }
[10:32:50.180]     ...future.frame <- base::sys.nframe()
[10:32:50.180]     ...future.conditions <- base::list()
[10:32:50.180]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.180]     if (FALSE) {
[10:32:50.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.180]     }
[10:32:50.180]     ...future.result <- base::tryCatch({
[10:32:50.180]         base::withCallingHandlers({
[10:32:50.180]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.180]             future::FutureResult(value = ...future.value$value, 
[10:32:50.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.180]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.180]                     ...future.globalenv.names))
[10:32:50.180]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.180]         }, condition = base::local({
[10:32:50.180]             c <- base::c
[10:32:50.180]             inherits <- base::inherits
[10:32:50.180]             invokeRestart <- base::invokeRestart
[10:32:50.180]             length <- base::length
[10:32:50.180]             list <- base::list
[10:32:50.180]             seq.int <- base::seq.int
[10:32:50.180]             signalCondition <- base::signalCondition
[10:32:50.180]             sys.calls <- base::sys.calls
[10:32:50.180]             `[[` <- base::`[[`
[10:32:50.180]             `+` <- base::`+`
[10:32:50.180]             `<<-` <- base::`<<-`
[10:32:50.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.180]                   3L)]
[10:32:50.180]             }
[10:32:50.180]             function(cond) {
[10:32:50.180]                 is_error <- inherits(cond, "error")
[10:32:50.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.180]                   NULL)
[10:32:50.180]                 if (is_error) {
[10:32:50.180]                   sessionInformation <- function() {
[10:32:50.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.180]                       search = base::search(), system = base::Sys.info())
[10:32:50.180]                   }
[10:32:50.180]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.180]                     cond$call), session = sessionInformation(), 
[10:32:50.180]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.180]                   signalCondition(cond)
[10:32:50.180]                 }
[10:32:50.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.180]                 "immediateCondition"))) {
[10:32:50.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.180]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.180]                   if (TRUE && !signal) {
[10:32:50.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.180]                     {
[10:32:50.180]                       inherits <- base::inherits
[10:32:50.180]                       invokeRestart <- base::invokeRestart
[10:32:50.180]                       is.null <- base::is.null
[10:32:50.180]                       muffled <- FALSE
[10:32:50.180]                       if (inherits(cond, "message")) {
[10:32:50.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.180]                         if (muffled) 
[10:32:50.180]                           invokeRestart("muffleMessage")
[10:32:50.180]                       }
[10:32:50.180]                       else if (inherits(cond, "warning")) {
[10:32:50.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.180]                         if (muffled) 
[10:32:50.180]                           invokeRestart("muffleWarning")
[10:32:50.180]                       }
[10:32:50.180]                       else if (inherits(cond, "condition")) {
[10:32:50.180]                         if (!is.null(pattern)) {
[10:32:50.180]                           computeRestarts <- base::computeRestarts
[10:32:50.180]                           grepl <- base::grepl
[10:32:50.180]                           restarts <- computeRestarts(cond)
[10:32:50.180]                           for (restart in restarts) {
[10:32:50.180]                             name <- restart$name
[10:32:50.180]                             if (is.null(name)) 
[10:32:50.180]                               next
[10:32:50.180]                             if (!grepl(pattern, name)) 
[10:32:50.180]                               next
[10:32:50.180]                             invokeRestart(restart)
[10:32:50.180]                             muffled <- TRUE
[10:32:50.180]                             break
[10:32:50.180]                           }
[10:32:50.180]                         }
[10:32:50.180]                       }
[10:32:50.180]                       invisible(muffled)
[10:32:50.180]                     }
[10:32:50.180]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.180]                   }
[10:32:50.180]                 }
[10:32:50.180]                 else {
[10:32:50.180]                   if (TRUE) {
[10:32:50.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.180]                     {
[10:32:50.180]                       inherits <- base::inherits
[10:32:50.180]                       invokeRestart <- base::invokeRestart
[10:32:50.180]                       is.null <- base::is.null
[10:32:50.180]                       muffled <- FALSE
[10:32:50.180]                       if (inherits(cond, "message")) {
[10:32:50.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.180]                         if (muffled) 
[10:32:50.180]                           invokeRestart("muffleMessage")
[10:32:50.180]                       }
[10:32:50.180]                       else if (inherits(cond, "warning")) {
[10:32:50.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.180]                         if (muffled) 
[10:32:50.180]                           invokeRestart("muffleWarning")
[10:32:50.180]                       }
[10:32:50.180]                       else if (inherits(cond, "condition")) {
[10:32:50.180]                         if (!is.null(pattern)) {
[10:32:50.180]                           computeRestarts <- base::computeRestarts
[10:32:50.180]                           grepl <- base::grepl
[10:32:50.180]                           restarts <- computeRestarts(cond)
[10:32:50.180]                           for (restart in restarts) {
[10:32:50.180]                             name <- restart$name
[10:32:50.180]                             if (is.null(name)) 
[10:32:50.180]                               next
[10:32:50.180]                             if (!grepl(pattern, name)) 
[10:32:50.180]                               next
[10:32:50.180]                             invokeRestart(restart)
[10:32:50.180]                             muffled <- TRUE
[10:32:50.180]                             break
[10:32:50.180]                           }
[10:32:50.180]                         }
[10:32:50.180]                       }
[10:32:50.180]                       invisible(muffled)
[10:32:50.180]                     }
[10:32:50.180]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.180]                   }
[10:32:50.180]                 }
[10:32:50.180]             }
[10:32:50.180]         }))
[10:32:50.180]     }, error = function(ex) {
[10:32:50.180]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.180]                 ...future.rng), started = ...future.startTime, 
[10:32:50.180]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.180]             version = "1.8"), class = "FutureResult")
[10:32:50.180]     }, finally = {
[10:32:50.180]         if (!identical(...future.workdir, getwd())) 
[10:32:50.180]             setwd(...future.workdir)
[10:32:50.180]         {
[10:32:50.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.180]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.180]             }
[10:32:50.180]             base::options(...future.oldOptions)
[10:32:50.180]             if (.Platform$OS.type == "windows") {
[10:32:50.180]                 old_names <- names(...future.oldEnvVars)
[10:32:50.180]                 envs <- base::Sys.getenv()
[10:32:50.180]                 names <- names(envs)
[10:32:50.180]                 common <- intersect(names, old_names)
[10:32:50.180]                 added <- setdiff(names, old_names)
[10:32:50.180]                 removed <- setdiff(old_names, names)
[10:32:50.180]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.180]                   envs[common]]
[10:32:50.180]                 NAMES <- toupper(changed)
[10:32:50.180]                 args <- list()
[10:32:50.180]                 for (kk in seq_along(NAMES)) {
[10:32:50.180]                   name <- changed[[kk]]
[10:32:50.180]                   NAME <- NAMES[[kk]]
[10:32:50.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.180]                     next
[10:32:50.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.180]                 }
[10:32:50.180]                 NAMES <- toupper(added)
[10:32:50.180]                 for (kk in seq_along(NAMES)) {
[10:32:50.180]                   name <- added[[kk]]
[10:32:50.180]                   NAME <- NAMES[[kk]]
[10:32:50.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.180]                     next
[10:32:50.180]                   args[[name]] <- ""
[10:32:50.180]                 }
[10:32:50.180]                 NAMES <- toupper(removed)
[10:32:50.180]                 for (kk in seq_along(NAMES)) {
[10:32:50.180]                   name <- removed[[kk]]
[10:32:50.180]                   NAME <- NAMES[[kk]]
[10:32:50.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.180]                     next
[10:32:50.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.180]                 }
[10:32:50.180]                 if (length(args) > 0) 
[10:32:50.180]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.180]             }
[10:32:50.180]             else {
[10:32:50.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.180]             }
[10:32:50.180]             {
[10:32:50.180]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.180]                   0L) {
[10:32:50.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.180]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.180]                   base::options(opts)
[10:32:50.180]                 }
[10:32:50.180]                 {
[10:32:50.180]                   {
[10:32:50.180]                     NULL
[10:32:50.180]                     RNGkind("Mersenne-Twister")
[10:32:50.180]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.180]                       inherits = FALSE)
[10:32:50.180]                   }
[10:32:50.180]                   options(future.plan = NULL)
[10:32:50.180]                   if (is.na(NA_character_)) 
[10:32:50.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.180]                     .init = FALSE)
[10:32:50.180]                 }
[10:32:50.180]             }
[10:32:50.180]         }
[10:32:50.180]     })
[10:32:50.180]     if (TRUE) {
[10:32:50.180]         base::sink(type = "output", split = FALSE)
[10:32:50.180]         if (TRUE) {
[10:32:50.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.180]         }
[10:32:50.180]         else {
[10:32:50.180]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.180]         }
[10:32:50.180]         base::close(...future.stdout)
[10:32:50.180]         ...future.stdout <- NULL
[10:32:50.180]     }
[10:32:50.180]     ...future.result$conditions <- ...future.conditions
[10:32:50.180]     ...future.result$finished <- base::Sys.time()
[10:32:50.180]     ...future.result
[10:32:50.180] }
[10:32:50.182] plan(): Setting new future strategy stack:
[10:32:50.182] List of future strategies:
[10:32:50.182] 1. sequential:
[10:32:50.182]    - args: function (..., envir = parent.frame())
[10:32:50.182]    - tweaked: FALSE
[10:32:50.182]    - call: NULL
[10:32:50.183] plan(): nbrOfWorkers() = 1
[10:32:50.183] plan(): Setting new future strategy stack:
[10:32:50.183] List of future strategies:
[10:32:50.183] 1. sequential:
[10:32:50.183]    - args: function (..., envir = parent.frame())
[10:32:50.183]    - tweaked: FALSE
[10:32:50.183]    - call: plan(strategy)
[10:32:50.184] plan(): nbrOfWorkers() = 1
[10:32:50.184] SequentialFuture started (and completed)
[10:32:50.184] - Launch lazy future ... done
[10:32:50.184] run() for ‘SequentialFuture’ ... done
[10:32:50.184] getGlobalsAndPackages() ...
[10:32:50.184] Searching for globals...
[10:32:50.184] 
[10:32:50.185] Searching for globals ... DONE
[10:32:50.185] - globals: [0] <none>
[10:32:50.185] getGlobalsAndPackages() ... DONE
[10:32:50.185] run() for ‘Future’ ...
[10:32:50.185] - state: ‘created’
[10:32:50.185] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.185] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.186]   - Field: ‘label’
[10:32:50.186]   - Field: ‘local’
[10:32:50.186]   - Field: ‘owner’
[10:32:50.186]   - Field: ‘envir’
[10:32:50.186]   - Field: ‘packages’
[10:32:50.186]   - Field: ‘gc’
[10:32:50.186]   - Field: ‘conditions’
[10:32:50.186]   - Field: ‘expr’
[10:32:50.186]   - Field: ‘uuid’
[10:32:50.186]   - Field: ‘seed’
[10:32:50.186]   - Field: ‘version’
[10:32:50.187]   - Field: ‘result’
[10:32:50.187]   - Field: ‘asynchronous’
[10:32:50.187]   - Field: ‘calls’
[10:32:50.187]   - Field: ‘globals’
[10:32:50.187]   - Field: ‘stdout’
[10:32:50.187]   - Field: ‘earlySignal’
[10:32:50.187]   - Field: ‘lazy’
[10:32:50.187]   - Field: ‘state’
[10:32:50.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.187] - Launch lazy future ...
[10:32:50.187] Packages needed by the future expression (n = 0): <none>
[10:32:50.188] Packages needed by future strategies (n = 0): <none>
[10:32:50.188] {
[10:32:50.188]     {
[10:32:50.188]         {
[10:32:50.188]             ...future.startTime <- base::Sys.time()
[10:32:50.188]             {
[10:32:50.188]                 {
[10:32:50.188]                   {
[10:32:50.188]                     base::local({
[10:32:50.188]                       has_future <- base::requireNamespace("future", 
[10:32:50.188]                         quietly = TRUE)
[10:32:50.188]                       if (has_future) {
[10:32:50.188]                         ns <- base::getNamespace("future")
[10:32:50.188]                         version <- ns[[".package"]][["version"]]
[10:32:50.188]                         if (is.null(version)) 
[10:32:50.188]                           version <- utils::packageVersion("future")
[10:32:50.188]                       }
[10:32:50.188]                       else {
[10:32:50.188]                         version <- NULL
[10:32:50.188]                       }
[10:32:50.188]                       if (!has_future || version < "1.8.0") {
[10:32:50.188]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.188]                           "", base::R.version$version.string), 
[10:32:50.188]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.188]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.188]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.188]                             "release", "version")], collapse = " "), 
[10:32:50.188]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.188]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.188]                           info)
[10:32:50.188]                         info <- base::paste(info, collapse = "; ")
[10:32:50.188]                         if (!has_future) {
[10:32:50.188]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.188]                             info)
[10:32:50.188]                         }
[10:32:50.188]                         else {
[10:32:50.188]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.188]                             info, version)
[10:32:50.188]                         }
[10:32:50.188]                         base::stop(msg)
[10:32:50.188]                       }
[10:32:50.188]                     })
[10:32:50.188]                   }
[10:32:50.188]                   ...future.strategy.old <- future::plan("list")
[10:32:50.188]                   options(future.plan = NULL)
[10:32:50.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.188]                 }
[10:32:50.188]                 ...future.workdir <- getwd()
[10:32:50.188]             }
[10:32:50.188]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.188]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.188]         }
[10:32:50.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.188]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.188]             base::names(...future.oldOptions))
[10:32:50.188]     }
[10:32:50.188]     if (FALSE) {
[10:32:50.188]     }
[10:32:50.188]     else {
[10:32:50.188]         if (TRUE) {
[10:32:50.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.188]                 open = "w")
[10:32:50.188]         }
[10:32:50.188]         else {
[10:32:50.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.188]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.188]         }
[10:32:50.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.188]             base::sink(type = "output", split = FALSE)
[10:32:50.188]             base::close(...future.stdout)
[10:32:50.188]         }, add = TRUE)
[10:32:50.188]     }
[10:32:50.188]     ...future.frame <- base::sys.nframe()
[10:32:50.188]     ...future.conditions <- base::list()
[10:32:50.188]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.188]     if (FALSE) {
[10:32:50.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.188]     }
[10:32:50.188]     ...future.result <- base::tryCatch({
[10:32:50.188]         base::withCallingHandlers({
[10:32:50.188]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.188]             future::FutureResult(value = ...future.value$value, 
[10:32:50.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.188]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.188]                     ...future.globalenv.names))
[10:32:50.188]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.188]         }, condition = base::local({
[10:32:50.188]             c <- base::c
[10:32:50.188]             inherits <- base::inherits
[10:32:50.188]             invokeRestart <- base::invokeRestart
[10:32:50.188]             length <- base::length
[10:32:50.188]             list <- base::list
[10:32:50.188]             seq.int <- base::seq.int
[10:32:50.188]             signalCondition <- base::signalCondition
[10:32:50.188]             sys.calls <- base::sys.calls
[10:32:50.188]             `[[` <- base::`[[`
[10:32:50.188]             `+` <- base::`+`
[10:32:50.188]             `<<-` <- base::`<<-`
[10:32:50.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.188]                   3L)]
[10:32:50.188]             }
[10:32:50.188]             function(cond) {
[10:32:50.188]                 is_error <- inherits(cond, "error")
[10:32:50.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.188]                   NULL)
[10:32:50.188]                 if (is_error) {
[10:32:50.188]                   sessionInformation <- function() {
[10:32:50.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.188]                       search = base::search(), system = base::Sys.info())
[10:32:50.188]                   }
[10:32:50.188]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.188]                     cond$call), session = sessionInformation(), 
[10:32:50.188]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.188]                   signalCondition(cond)
[10:32:50.188]                 }
[10:32:50.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.188]                 "immediateCondition"))) {
[10:32:50.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.188]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.188]                   if (TRUE && !signal) {
[10:32:50.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.188]                     {
[10:32:50.188]                       inherits <- base::inherits
[10:32:50.188]                       invokeRestart <- base::invokeRestart
[10:32:50.188]                       is.null <- base::is.null
[10:32:50.188]                       muffled <- FALSE
[10:32:50.188]                       if (inherits(cond, "message")) {
[10:32:50.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.188]                         if (muffled) 
[10:32:50.188]                           invokeRestart("muffleMessage")
[10:32:50.188]                       }
[10:32:50.188]                       else if (inherits(cond, "warning")) {
[10:32:50.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.188]                         if (muffled) 
[10:32:50.188]                           invokeRestart("muffleWarning")
[10:32:50.188]                       }
[10:32:50.188]                       else if (inherits(cond, "condition")) {
[10:32:50.188]                         if (!is.null(pattern)) {
[10:32:50.188]                           computeRestarts <- base::computeRestarts
[10:32:50.188]                           grepl <- base::grepl
[10:32:50.188]                           restarts <- computeRestarts(cond)
[10:32:50.188]                           for (restart in restarts) {
[10:32:50.188]                             name <- restart$name
[10:32:50.188]                             if (is.null(name)) 
[10:32:50.188]                               next
[10:32:50.188]                             if (!grepl(pattern, name)) 
[10:32:50.188]                               next
[10:32:50.188]                             invokeRestart(restart)
[10:32:50.188]                             muffled <- TRUE
[10:32:50.188]                             break
[10:32:50.188]                           }
[10:32:50.188]                         }
[10:32:50.188]                       }
[10:32:50.188]                       invisible(muffled)
[10:32:50.188]                     }
[10:32:50.188]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.188]                   }
[10:32:50.188]                 }
[10:32:50.188]                 else {
[10:32:50.188]                   if (TRUE) {
[10:32:50.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.188]                     {
[10:32:50.188]                       inherits <- base::inherits
[10:32:50.188]                       invokeRestart <- base::invokeRestart
[10:32:50.188]                       is.null <- base::is.null
[10:32:50.188]                       muffled <- FALSE
[10:32:50.188]                       if (inherits(cond, "message")) {
[10:32:50.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.188]                         if (muffled) 
[10:32:50.188]                           invokeRestart("muffleMessage")
[10:32:50.188]                       }
[10:32:50.188]                       else if (inherits(cond, "warning")) {
[10:32:50.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.188]                         if (muffled) 
[10:32:50.188]                           invokeRestart("muffleWarning")
[10:32:50.188]                       }
[10:32:50.188]                       else if (inherits(cond, "condition")) {
[10:32:50.188]                         if (!is.null(pattern)) {
[10:32:50.188]                           computeRestarts <- base::computeRestarts
[10:32:50.188]                           grepl <- base::grepl
[10:32:50.188]                           restarts <- computeRestarts(cond)
[10:32:50.188]                           for (restart in restarts) {
[10:32:50.188]                             name <- restart$name
[10:32:50.188]                             if (is.null(name)) 
[10:32:50.188]                               next
[10:32:50.188]                             if (!grepl(pattern, name)) 
[10:32:50.188]                               next
[10:32:50.188]                             invokeRestart(restart)
[10:32:50.188]                             muffled <- TRUE
[10:32:50.188]                             break
[10:32:50.188]                           }
[10:32:50.188]                         }
[10:32:50.188]                       }
[10:32:50.188]                       invisible(muffled)
[10:32:50.188]                     }
[10:32:50.188]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.188]                   }
[10:32:50.188]                 }
[10:32:50.188]             }
[10:32:50.188]         }))
[10:32:50.188]     }, error = function(ex) {
[10:32:50.188]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.188]                 ...future.rng), started = ...future.startTime, 
[10:32:50.188]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.188]             version = "1.8"), class = "FutureResult")
[10:32:50.188]     }, finally = {
[10:32:50.188]         if (!identical(...future.workdir, getwd())) 
[10:32:50.188]             setwd(...future.workdir)
[10:32:50.188]         {
[10:32:50.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.188]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.188]             }
[10:32:50.188]             base::options(...future.oldOptions)
[10:32:50.188]             if (.Platform$OS.type == "windows") {
[10:32:50.188]                 old_names <- names(...future.oldEnvVars)
[10:32:50.188]                 envs <- base::Sys.getenv()
[10:32:50.188]                 names <- names(envs)
[10:32:50.188]                 common <- intersect(names, old_names)
[10:32:50.188]                 added <- setdiff(names, old_names)
[10:32:50.188]                 removed <- setdiff(old_names, names)
[10:32:50.188]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.188]                   envs[common]]
[10:32:50.188]                 NAMES <- toupper(changed)
[10:32:50.188]                 args <- list()
[10:32:50.188]                 for (kk in seq_along(NAMES)) {
[10:32:50.188]                   name <- changed[[kk]]
[10:32:50.188]                   NAME <- NAMES[[kk]]
[10:32:50.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.188]                     next
[10:32:50.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.188]                 }
[10:32:50.188]                 NAMES <- toupper(added)
[10:32:50.188]                 for (kk in seq_along(NAMES)) {
[10:32:50.188]                   name <- added[[kk]]
[10:32:50.188]                   NAME <- NAMES[[kk]]
[10:32:50.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.188]                     next
[10:32:50.188]                   args[[name]] <- ""
[10:32:50.188]                 }
[10:32:50.188]                 NAMES <- toupper(removed)
[10:32:50.188]                 for (kk in seq_along(NAMES)) {
[10:32:50.188]                   name <- removed[[kk]]
[10:32:50.188]                   NAME <- NAMES[[kk]]
[10:32:50.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.188]                     next
[10:32:50.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.188]                 }
[10:32:50.188]                 if (length(args) > 0) 
[10:32:50.188]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.188]             }
[10:32:50.188]             else {
[10:32:50.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.188]             }
[10:32:50.188]             {
[10:32:50.188]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.188]                   0L) {
[10:32:50.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.188]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.188]                   base::options(opts)
[10:32:50.188]                 }
[10:32:50.188]                 {
[10:32:50.188]                   {
[10:32:50.188]                     NULL
[10:32:50.188]                     RNGkind("Mersenne-Twister")
[10:32:50.188]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.188]                       inherits = FALSE)
[10:32:50.188]                   }
[10:32:50.188]                   options(future.plan = NULL)
[10:32:50.188]                   if (is.na(NA_character_)) 
[10:32:50.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.188]                     .init = FALSE)
[10:32:50.188]                 }
[10:32:50.188]             }
[10:32:50.188]         }
[10:32:50.188]     })
[10:32:50.188]     if (TRUE) {
[10:32:50.188]         base::sink(type = "output", split = FALSE)
[10:32:50.188]         if (TRUE) {
[10:32:50.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.188]         }
[10:32:50.188]         else {
[10:32:50.188]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.188]         }
[10:32:50.188]         base::close(...future.stdout)
[10:32:50.188]         ...future.stdout <- NULL
[10:32:50.188]     }
[10:32:50.188]     ...future.result$conditions <- ...future.conditions
[10:32:50.188]     ...future.result$finished <- base::Sys.time()
[10:32:50.188]     ...future.result
[10:32:50.188] }
[10:32:50.190] plan(): Setting new future strategy stack:
[10:32:50.190] List of future strategies:
[10:32:50.190] 1. sequential:
[10:32:50.190]    - args: function (..., envir = parent.frame())
[10:32:50.190]    - tweaked: FALSE
[10:32:50.190]    - call: NULL
[10:32:50.190] plan(): nbrOfWorkers() = 1
[10:32:50.191] plan(): Setting new future strategy stack:
[10:32:50.191] List of future strategies:
[10:32:50.191] 1. sequential:
[10:32:50.191]    - args: function (..., envir = parent.frame())
[10:32:50.191]    - tweaked: FALSE
[10:32:50.191]    - call: plan(strategy)
[10:32:50.191] plan(): nbrOfWorkers() = 1
[10:32:50.191] SequentialFuture started (and completed)
[10:32:50.191] - Launch lazy future ... done
[10:32:50.191] run() for ‘SequentialFuture’ ... done
[10:32:50.193] getGlobalsAndPackages() ...
[10:32:50.193] Searching for globals...
[10:32:50.194] - globals found: [1] ‘{’
[10:32:50.194] Searching for globals ... DONE
[10:32:50.194] Resolving globals: FALSE
[10:32:50.195] 
[10:32:50.195] 
[10:32:50.195] getGlobalsAndPackages() ... DONE
[10:32:50.195] run() for ‘Future’ ...
[10:32:50.195] - state: ‘created’
[10:32:50.195] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.195] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.196]   - Field: ‘label’
[10:32:50.196]   - Field: ‘local’
[10:32:50.196]   - Field: ‘owner’
[10:32:50.196]   - Field: ‘envir’
[10:32:50.196]   - Field: ‘packages’
[10:32:50.196]   - Field: ‘gc’
[10:32:50.196]   - Field: ‘conditions’
[10:32:50.196]   - Field: ‘expr’
[10:32:50.196]   - Field: ‘uuid’
[10:32:50.196]   - Field: ‘seed’
[10:32:50.197]   - Field: ‘version’
[10:32:50.197]   - Field: ‘result’
[10:32:50.197]   - Field: ‘asynchronous’
[10:32:50.197]   - Field: ‘calls’
[10:32:50.197]   - Field: ‘globals’
[10:32:50.197]   - Field: ‘stdout’
[10:32:50.197]   - Field: ‘earlySignal’
[10:32:50.198]   - Field: ‘lazy’
[10:32:50.198]   - Field: ‘state’
[10:32:50.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.199] - Launch lazy future ...
[10:32:50.199] Packages needed by the future expression (n = 0): <none>
[10:32:50.199] Packages needed by future strategies (n = 0): <none>
[10:32:50.199] {
[10:32:50.199]     {
[10:32:50.199]         {
[10:32:50.199]             ...future.startTime <- base::Sys.time()
[10:32:50.199]             {
[10:32:50.199]                 {
[10:32:50.199]                   {
[10:32:50.199]                     base::local({
[10:32:50.199]                       has_future <- base::requireNamespace("future", 
[10:32:50.199]                         quietly = TRUE)
[10:32:50.199]                       if (has_future) {
[10:32:50.199]                         ns <- base::getNamespace("future")
[10:32:50.199]                         version <- ns[[".package"]][["version"]]
[10:32:50.199]                         if (is.null(version)) 
[10:32:50.199]                           version <- utils::packageVersion("future")
[10:32:50.199]                       }
[10:32:50.199]                       else {
[10:32:50.199]                         version <- NULL
[10:32:50.199]                       }
[10:32:50.199]                       if (!has_future || version < "1.8.0") {
[10:32:50.199]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.199]                           "", base::R.version$version.string), 
[10:32:50.199]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.199]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.199]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.199]                             "release", "version")], collapse = " "), 
[10:32:50.199]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.199]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.199]                           info)
[10:32:50.199]                         info <- base::paste(info, collapse = "; ")
[10:32:50.199]                         if (!has_future) {
[10:32:50.199]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.199]                             info)
[10:32:50.199]                         }
[10:32:50.199]                         else {
[10:32:50.199]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.199]                             info, version)
[10:32:50.199]                         }
[10:32:50.199]                         base::stop(msg)
[10:32:50.199]                       }
[10:32:50.199]                     })
[10:32:50.199]                   }
[10:32:50.199]                   ...future.strategy.old <- future::plan("list")
[10:32:50.199]                   options(future.plan = NULL)
[10:32:50.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.199]                 }
[10:32:50.199]                 ...future.workdir <- getwd()
[10:32:50.199]             }
[10:32:50.199]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.199]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.199]         }
[10:32:50.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.199]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.199]             base::names(...future.oldOptions))
[10:32:50.199]     }
[10:32:50.199]     if (FALSE) {
[10:32:50.199]     }
[10:32:50.199]     else {
[10:32:50.199]         if (TRUE) {
[10:32:50.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.199]                 open = "w")
[10:32:50.199]         }
[10:32:50.199]         else {
[10:32:50.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.199]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.199]         }
[10:32:50.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.199]             base::sink(type = "output", split = FALSE)
[10:32:50.199]             base::close(...future.stdout)
[10:32:50.199]         }, add = TRUE)
[10:32:50.199]     }
[10:32:50.199]     ...future.frame <- base::sys.nframe()
[10:32:50.199]     ...future.conditions <- base::list()
[10:32:50.199]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.199]     if (FALSE) {
[10:32:50.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.199]     }
[10:32:50.199]     ...future.result <- base::tryCatch({
[10:32:50.199]         base::withCallingHandlers({
[10:32:50.199]             ...future.value <- base::withVisible(base::local({
[10:32:50.199]                 4
[10:32:50.199]             }))
[10:32:50.199]             future::FutureResult(value = ...future.value$value, 
[10:32:50.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.199]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.199]                     ...future.globalenv.names))
[10:32:50.199]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.199]         }, condition = base::local({
[10:32:50.199]             c <- base::c
[10:32:50.199]             inherits <- base::inherits
[10:32:50.199]             invokeRestart <- base::invokeRestart
[10:32:50.199]             length <- base::length
[10:32:50.199]             list <- base::list
[10:32:50.199]             seq.int <- base::seq.int
[10:32:50.199]             signalCondition <- base::signalCondition
[10:32:50.199]             sys.calls <- base::sys.calls
[10:32:50.199]             `[[` <- base::`[[`
[10:32:50.199]             `+` <- base::`+`
[10:32:50.199]             `<<-` <- base::`<<-`
[10:32:50.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.199]                   3L)]
[10:32:50.199]             }
[10:32:50.199]             function(cond) {
[10:32:50.199]                 is_error <- inherits(cond, "error")
[10:32:50.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.199]                   NULL)
[10:32:50.199]                 if (is_error) {
[10:32:50.199]                   sessionInformation <- function() {
[10:32:50.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.199]                       search = base::search(), system = base::Sys.info())
[10:32:50.199]                   }
[10:32:50.199]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.199]                     cond$call), session = sessionInformation(), 
[10:32:50.199]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.199]                   signalCondition(cond)
[10:32:50.199]                 }
[10:32:50.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.199]                 "immediateCondition"))) {
[10:32:50.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.199]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.199]                   if (TRUE && !signal) {
[10:32:50.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.199]                     {
[10:32:50.199]                       inherits <- base::inherits
[10:32:50.199]                       invokeRestart <- base::invokeRestart
[10:32:50.199]                       is.null <- base::is.null
[10:32:50.199]                       muffled <- FALSE
[10:32:50.199]                       if (inherits(cond, "message")) {
[10:32:50.199]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.199]                         if (muffled) 
[10:32:50.199]                           invokeRestart("muffleMessage")
[10:32:50.199]                       }
[10:32:50.199]                       else if (inherits(cond, "warning")) {
[10:32:50.199]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.199]                         if (muffled) 
[10:32:50.199]                           invokeRestart("muffleWarning")
[10:32:50.199]                       }
[10:32:50.199]                       else if (inherits(cond, "condition")) {
[10:32:50.199]                         if (!is.null(pattern)) {
[10:32:50.199]                           computeRestarts <- base::computeRestarts
[10:32:50.199]                           grepl <- base::grepl
[10:32:50.199]                           restarts <- computeRestarts(cond)
[10:32:50.199]                           for (restart in restarts) {
[10:32:50.199]                             name <- restart$name
[10:32:50.199]                             if (is.null(name)) 
[10:32:50.199]                               next
[10:32:50.199]                             if (!grepl(pattern, name)) 
[10:32:50.199]                               next
[10:32:50.199]                             invokeRestart(restart)
[10:32:50.199]                             muffled <- TRUE
[10:32:50.199]                             break
[10:32:50.199]                           }
[10:32:50.199]                         }
[10:32:50.199]                       }
[10:32:50.199]                       invisible(muffled)
[10:32:50.199]                     }
[10:32:50.199]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.199]                   }
[10:32:50.199]                 }
[10:32:50.199]                 else {
[10:32:50.199]                   if (TRUE) {
[10:32:50.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.199]                     {
[10:32:50.199]                       inherits <- base::inherits
[10:32:50.199]                       invokeRestart <- base::invokeRestart
[10:32:50.199]                       is.null <- base::is.null
[10:32:50.199]                       muffled <- FALSE
[10:32:50.199]                       if (inherits(cond, "message")) {
[10:32:50.199]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.199]                         if (muffled) 
[10:32:50.199]                           invokeRestart("muffleMessage")
[10:32:50.199]                       }
[10:32:50.199]                       else if (inherits(cond, "warning")) {
[10:32:50.199]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.199]                         if (muffled) 
[10:32:50.199]                           invokeRestart("muffleWarning")
[10:32:50.199]                       }
[10:32:50.199]                       else if (inherits(cond, "condition")) {
[10:32:50.199]                         if (!is.null(pattern)) {
[10:32:50.199]                           computeRestarts <- base::computeRestarts
[10:32:50.199]                           grepl <- base::grepl
[10:32:50.199]                           restarts <- computeRestarts(cond)
[10:32:50.199]                           for (restart in restarts) {
[10:32:50.199]                             name <- restart$name
[10:32:50.199]                             if (is.null(name)) 
[10:32:50.199]                               next
[10:32:50.199]                             if (!grepl(pattern, name)) 
[10:32:50.199]                               next
[10:32:50.199]                             invokeRestart(restart)
[10:32:50.199]                             muffled <- TRUE
[10:32:50.199]                             break
[10:32:50.199]                           }
[10:32:50.199]                         }
[10:32:50.199]                       }
[10:32:50.199]                       invisible(muffled)
[10:32:50.199]                     }
[10:32:50.199]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.199]                   }
[10:32:50.199]                 }
[10:32:50.199]             }
[10:32:50.199]         }))
[10:32:50.199]     }, error = function(ex) {
[10:32:50.199]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.199]                 ...future.rng), started = ...future.startTime, 
[10:32:50.199]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.199]             version = "1.8"), class = "FutureResult")
[10:32:50.199]     }, finally = {
[10:32:50.199]         if (!identical(...future.workdir, getwd())) 
[10:32:50.199]             setwd(...future.workdir)
[10:32:50.199]         {
[10:32:50.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.199]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.199]             }
[10:32:50.199]             base::options(...future.oldOptions)
[10:32:50.199]             if (.Platform$OS.type == "windows") {
[10:32:50.199]                 old_names <- names(...future.oldEnvVars)
[10:32:50.199]                 envs <- base::Sys.getenv()
[10:32:50.199]                 names <- names(envs)
[10:32:50.199]                 common <- intersect(names, old_names)
[10:32:50.199]                 added <- setdiff(names, old_names)
[10:32:50.199]                 removed <- setdiff(old_names, names)
[10:32:50.199]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.199]                   envs[common]]
[10:32:50.199]                 NAMES <- toupper(changed)
[10:32:50.199]                 args <- list()
[10:32:50.199]                 for (kk in seq_along(NAMES)) {
[10:32:50.199]                   name <- changed[[kk]]
[10:32:50.199]                   NAME <- NAMES[[kk]]
[10:32:50.199]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.199]                     next
[10:32:50.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.199]                 }
[10:32:50.199]                 NAMES <- toupper(added)
[10:32:50.199]                 for (kk in seq_along(NAMES)) {
[10:32:50.199]                   name <- added[[kk]]
[10:32:50.199]                   NAME <- NAMES[[kk]]
[10:32:50.199]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.199]                     next
[10:32:50.199]                   args[[name]] <- ""
[10:32:50.199]                 }
[10:32:50.199]                 NAMES <- toupper(removed)
[10:32:50.199]                 for (kk in seq_along(NAMES)) {
[10:32:50.199]                   name <- removed[[kk]]
[10:32:50.199]                   NAME <- NAMES[[kk]]
[10:32:50.199]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.199]                     next
[10:32:50.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.199]                 }
[10:32:50.199]                 if (length(args) > 0) 
[10:32:50.199]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.199]             }
[10:32:50.199]             else {
[10:32:50.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.199]             }
[10:32:50.199]             {
[10:32:50.199]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.199]                   0L) {
[10:32:50.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.199]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.199]                   base::options(opts)
[10:32:50.199]                 }
[10:32:50.199]                 {
[10:32:50.199]                   {
[10:32:50.199]                     NULL
[10:32:50.199]                     RNGkind("Mersenne-Twister")
[10:32:50.199]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.199]                       inherits = FALSE)
[10:32:50.199]                   }
[10:32:50.199]                   options(future.plan = NULL)
[10:32:50.199]                   if (is.na(NA_character_)) 
[10:32:50.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.199]                     .init = FALSE)
[10:32:50.199]                 }
[10:32:50.199]             }
[10:32:50.199]         }
[10:32:50.199]     })
[10:32:50.199]     if (TRUE) {
[10:32:50.199]         base::sink(type = "output", split = FALSE)
[10:32:50.199]         if (TRUE) {
[10:32:50.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.199]         }
[10:32:50.199]         else {
[10:32:50.199]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.199]         }
[10:32:50.199]         base::close(...future.stdout)
[10:32:50.199]         ...future.stdout <- NULL
[10:32:50.199]     }
[10:32:50.199]     ...future.result$conditions <- ...future.conditions
[10:32:50.199]     ...future.result$finished <- base::Sys.time()
[10:32:50.199]     ...future.result
[10:32:50.199] }
[10:32:50.201] plan(): Setting new future strategy stack:
[10:32:50.201] List of future strategies:
[10:32:50.201] 1. sequential:
[10:32:50.201]    - args: function (..., envir = parent.frame())
[10:32:50.201]    - tweaked: FALSE
[10:32:50.201]    - call: NULL
[10:32:50.201] plan(): nbrOfWorkers() = 1
[10:32:50.202] plan(): Setting new future strategy stack:
[10:32:50.202] List of future strategies:
[10:32:50.202] 1. sequential:
[10:32:50.202]    - args: function (..., envir = parent.frame())
[10:32:50.202]    - tweaked: FALSE
[10:32:50.202]    - call: plan(strategy)
[10:32:50.202] plan(): nbrOfWorkers() = 1
[10:32:50.203] SequentialFuture started (and completed)
[10:32:50.203] - Launch lazy future ... done
[10:32:50.203] run() for ‘SequentialFuture’ ... done
<environment: 0x5652cf6da6f0> 
<environment: 0x5652cf05a860> 
[10:32:50.204] resolved() for ‘SequentialFuture’ ...
[10:32:50.204] - state: ‘finished’
[10:32:50.204] - run: TRUE
[10:32:50.204] - result: ‘FutureResult’
[10:32:50.205] resolved() for ‘SequentialFuture’ ... done
[10:32:50.205] resolved() for ‘SequentialFuture’ ...
[10:32:50.205] - state: ‘finished’
[10:32:50.205] - run: TRUE
[10:32:50.205] - result: ‘FutureResult’
[10:32:50.205] resolved() for ‘SequentialFuture’ ... done
[10:32:50.205] resolved() for ‘SequentialFuture’ ...
[10:32:50.205] - state: ‘finished’
[10:32:50.205] - run: TRUE
[10:32:50.205] - result: ‘FutureResult’
[10:32:50.205] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:50.207] resolve() on environment ...
[10:32:50.207]  recursive: 0
[10:32:50.207]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:50.207] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.208] - nx: 4
[10:32:50.208] - relay: TRUE
[10:32:50.208] - stdout: TRUE
[10:32:50.208] - signal: TRUE
[10:32:50.208] - resignal: FALSE
[10:32:50.208] - force: TRUE
[10:32:50.208] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.208] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.208]  - until=2
[10:32:50.208]  - relaying element #2
[10:32:50.208] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.208] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.209] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.209]  length: 3 (resolved future 1)
[10:32:50.209] resolved() for ‘SequentialFuture’ ...
[10:32:50.209] - state: ‘finished’
[10:32:50.209] - run: TRUE
[10:32:50.209] - result: ‘FutureResult’
[10:32:50.209] resolved() for ‘SequentialFuture’ ... done
[10:32:50.209] Future #2
[10:32:50.209] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.209] - nx: 4
[10:32:50.210] - relay: TRUE
[10:32:50.210] - stdout: TRUE
[10:32:50.210] - signal: TRUE
[10:32:50.210] - resignal: FALSE
[10:32:50.210] - force: TRUE
[10:32:50.210] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.210] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.210]  - until=2
[10:32:50.210]  - relaying element #2
[10:32:50.210] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.210] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.210] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.211]  length: 2 (resolved future 2)
[10:32:50.211] resolved() for ‘SequentialFuture’ ...
[10:32:50.211] - state: ‘finished’
[10:32:50.211] - run: TRUE
[10:32:50.211] - result: ‘FutureResult’
[10:32:50.211] resolved() for ‘SequentialFuture’ ... done
[10:32:50.211] Future #3
[10:32:50.211] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.211] - nx: 4
[10:32:50.211] - relay: TRUE
[10:32:50.211] - stdout: TRUE
[10:32:50.212] - signal: TRUE
[10:32:50.212] - resignal: FALSE
[10:32:50.212] - force: TRUE
[10:32:50.212] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.212] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.212]  - until=3
[10:32:50.212]  - relaying element #3
[10:32:50.212] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.212] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.212] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.212]  length: 1 (resolved future 3)
[10:32:50.213] resolved() for ‘SequentialFuture’ ...
[10:32:50.213] - state: ‘finished’
[10:32:50.213] - run: TRUE
[10:32:50.213] - result: ‘FutureResult’
[10:32:50.213] resolved() for ‘SequentialFuture’ ... done
[10:32:50.213] Future #4
[10:32:50.213] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.213] - nx: 4
[10:32:50.213] - relay: TRUE
[10:32:50.213] - stdout: TRUE
[10:32:50.213] - signal: TRUE
[10:32:50.214] - resignal: FALSE
[10:32:50.214] - force: TRUE
[10:32:50.214] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.214] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.214]  - until=4
[10:32:50.214]  - relaying element #4
[10:32:50.214] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.214] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.214] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.214]  length: 0 (resolved future 4)
[10:32:50.214] Relaying remaining futures
[10:32:50.215] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.215] - nx: 4
[10:32:50.215] - relay: TRUE
[10:32:50.215] - stdout: TRUE
[10:32:50.215] - signal: TRUE
[10:32:50.215] - resignal: FALSE
[10:32:50.215] - force: TRUE
[10:32:50.215] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.215] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:50.215] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.215] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.215] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.216] resolve() on environment ... DONE
<environment: 0x5652cf9106e0> 
Dimensions: c(1, 6)
[10:32:50.216] getGlobalsAndPackages() ...
[10:32:50.216] Searching for globals...
[10:32:50.216] 
[10:32:50.216] Searching for globals ... DONE
[10:32:50.217] - globals: [0] <none>
[10:32:50.217] getGlobalsAndPackages() ... DONE
[10:32:50.217] run() for ‘Future’ ...
[10:32:50.217] - state: ‘created’
[10:32:50.217] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.218]   - Field: ‘label’
[10:32:50.218]   - Field: ‘local’
[10:32:50.218]   - Field: ‘owner’
[10:32:50.218]   - Field: ‘envir’
[10:32:50.218]   - Field: ‘packages’
[10:32:50.218]   - Field: ‘gc’
[10:32:50.218]   - Field: ‘conditions’
[10:32:50.218]   - Field: ‘expr’
[10:32:50.218]   - Field: ‘uuid’
[10:32:50.218]   - Field: ‘seed’
[10:32:50.218]   - Field: ‘version’
[10:32:50.218]   - Field: ‘result’
[10:32:50.219]   - Field: ‘asynchronous’
[10:32:50.219]   - Field: ‘calls’
[10:32:50.219]   - Field: ‘globals’
[10:32:50.219]   - Field: ‘stdout’
[10:32:50.219]   - Field: ‘earlySignal’
[10:32:50.219]   - Field: ‘lazy’
[10:32:50.219]   - Field: ‘state’
[10:32:50.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.219] - Launch lazy future ...
[10:32:50.219] Packages needed by the future expression (n = 0): <none>
[10:32:50.220] Packages needed by future strategies (n = 0): <none>
[10:32:50.220] {
[10:32:50.220]     {
[10:32:50.220]         {
[10:32:50.220]             ...future.startTime <- base::Sys.time()
[10:32:50.220]             {
[10:32:50.220]                 {
[10:32:50.220]                   {
[10:32:50.220]                     base::local({
[10:32:50.220]                       has_future <- base::requireNamespace("future", 
[10:32:50.220]                         quietly = TRUE)
[10:32:50.220]                       if (has_future) {
[10:32:50.220]                         ns <- base::getNamespace("future")
[10:32:50.220]                         version <- ns[[".package"]][["version"]]
[10:32:50.220]                         if (is.null(version)) 
[10:32:50.220]                           version <- utils::packageVersion("future")
[10:32:50.220]                       }
[10:32:50.220]                       else {
[10:32:50.220]                         version <- NULL
[10:32:50.220]                       }
[10:32:50.220]                       if (!has_future || version < "1.8.0") {
[10:32:50.220]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.220]                           "", base::R.version$version.string), 
[10:32:50.220]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.220]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.220]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.220]                             "release", "version")], collapse = " "), 
[10:32:50.220]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.220]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.220]                           info)
[10:32:50.220]                         info <- base::paste(info, collapse = "; ")
[10:32:50.220]                         if (!has_future) {
[10:32:50.220]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.220]                             info)
[10:32:50.220]                         }
[10:32:50.220]                         else {
[10:32:50.220]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.220]                             info, version)
[10:32:50.220]                         }
[10:32:50.220]                         base::stop(msg)
[10:32:50.220]                       }
[10:32:50.220]                     })
[10:32:50.220]                   }
[10:32:50.220]                   ...future.strategy.old <- future::plan("list")
[10:32:50.220]                   options(future.plan = NULL)
[10:32:50.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.220]                 }
[10:32:50.220]                 ...future.workdir <- getwd()
[10:32:50.220]             }
[10:32:50.220]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.220]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.220]         }
[10:32:50.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.220]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.220]             base::names(...future.oldOptions))
[10:32:50.220]     }
[10:32:50.220]     if (FALSE) {
[10:32:50.220]     }
[10:32:50.220]     else {
[10:32:50.220]         if (TRUE) {
[10:32:50.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.220]                 open = "w")
[10:32:50.220]         }
[10:32:50.220]         else {
[10:32:50.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.220]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.220]         }
[10:32:50.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.220]             base::sink(type = "output", split = FALSE)
[10:32:50.220]             base::close(...future.stdout)
[10:32:50.220]         }, add = TRUE)
[10:32:50.220]     }
[10:32:50.220]     ...future.frame <- base::sys.nframe()
[10:32:50.220]     ...future.conditions <- base::list()
[10:32:50.220]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.220]     if (FALSE) {
[10:32:50.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.220]     }
[10:32:50.220]     ...future.result <- base::tryCatch({
[10:32:50.220]         base::withCallingHandlers({
[10:32:50.220]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.220]             future::FutureResult(value = ...future.value$value, 
[10:32:50.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.220]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.220]                     ...future.globalenv.names))
[10:32:50.220]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.220]         }, condition = base::local({
[10:32:50.220]             c <- base::c
[10:32:50.220]             inherits <- base::inherits
[10:32:50.220]             invokeRestart <- base::invokeRestart
[10:32:50.220]             length <- base::length
[10:32:50.220]             list <- base::list
[10:32:50.220]             seq.int <- base::seq.int
[10:32:50.220]             signalCondition <- base::signalCondition
[10:32:50.220]             sys.calls <- base::sys.calls
[10:32:50.220]             `[[` <- base::`[[`
[10:32:50.220]             `+` <- base::`+`
[10:32:50.220]             `<<-` <- base::`<<-`
[10:32:50.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.220]                   3L)]
[10:32:50.220]             }
[10:32:50.220]             function(cond) {
[10:32:50.220]                 is_error <- inherits(cond, "error")
[10:32:50.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.220]                   NULL)
[10:32:50.220]                 if (is_error) {
[10:32:50.220]                   sessionInformation <- function() {
[10:32:50.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.220]                       search = base::search(), system = base::Sys.info())
[10:32:50.220]                   }
[10:32:50.220]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.220]                     cond$call), session = sessionInformation(), 
[10:32:50.220]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.220]                   signalCondition(cond)
[10:32:50.220]                 }
[10:32:50.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.220]                 "immediateCondition"))) {
[10:32:50.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.220]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.220]                   if (TRUE && !signal) {
[10:32:50.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.220]                     {
[10:32:50.220]                       inherits <- base::inherits
[10:32:50.220]                       invokeRestart <- base::invokeRestart
[10:32:50.220]                       is.null <- base::is.null
[10:32:50.220]                       muffled <- FALSE
[10:32:50.220]                       if (inherits(cond, "message")) {
[10:32:50.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.220]                         if (muffled) 
[10:32:50.220]                           invokeRestart("muffleMessage")
[10:32:50.220]                       }
[10:32:50.220]                       else if (inherits(cond, "warning")) {
[10:32:50.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.220]                         if (muffled) 
[10:32:50.220]                           invokeRestart("muffleWarning")
[10:32:50.220]                       }
[10:32:50.220]                       else if (inherits(cond, "condition")) {
[10:32:50.220]                         if (!is.null(pattern)) {
[10:32:50.220]                           computeRestarts <- base::computeRestarts
[10:32:50.220]                           grepl <- base::grepl
[10:32:50.220]                           restarts <- computeRestarts(cond)
[10:32:50.220]                           for (restart in restarts) {
[10:32:50.220]                             name <- restart$name
[10:32:50.220]                             if (is.null(name)) 
[10:32:50.220]                               next
[10:32:50.220]                             if (!grepl(pattern, name)) 
[10:32:50.220]                               next
[10:32:50.220]                             invokeRestart(restart)
[10:32:50.220]                             muffled <- TRUE
[10:32:50.220]                             break
[10:32:50.220]                           }
[10:32:50.220]                         }
[10:32:50.220]                       }
[10:32:50.220]                       invisible(muffled)
[10:32:50.220]                     }
[10:32:50.220]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.220]                   }
[10:32:50.220]                 }
[10:32:50.220]                 else {
[10:32:50.220]                   if (TRUE) {
[10:32:50.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.220]                     {
[10:32:50.220]                       inherits <- base::inherits
[10:32:50.220]                       invokeRestart <- base::invokeRestart
[10:32:50.220]                       is.null <- base::is.null
[10:32:50.220]                       muffled <- FALSE
[10:32:50.220]                       if (inherits(cond, "message")) {
[10:32:50.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.220]                         if (muffled) 
[10:32:50.220]                           invokeRestart("muffleMessage")
[10:32:50.220]                       }
[10:32:50.220]                       else if (inherits(cond, "warning")) {
[10:32:50.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.220]                         if (muffled) 
[10:32:50.220]                           invokeRestart("muffleWarning")
[10:32:50.220]                       }
[10:32:50.220]                       else if (inherits(cond, "condition")) {
[10:32:50.220]                         if (!is.null(pattern)) {
[10:32:50.220]                           computeRestarts <- base::computeRestarts
[10:32:50.220]                           grepl <- base::grepl
[10:32:50.220]                           restarts <- computeRestarts(cond)
[10:32:50.220]                           for (restart in restarts) {
[10:32:50.220]                             name <- restart$name
[10:32:50.220]                             if (is.null(name)) 
[10:32:50.220]                               next
[10:32:50.220]                             if (!grepl(pattern, name)) 
[10:32:50.220]                               next
[10:32:50.220]                             invokeRestart(restart)
[10:32:50.220]                             muffled <- TRUE
[10:32:50.220]                             break
[10:32:50.220]                           }
[10:32:50.220]                         }
[10:32:50.220]                       }
[10:32:50.220]                       invisible(muffled)
[10:32:50.220]                     }
[10:32:50.220]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.220]                   }
[10:32:50.220]                 }
[10:32:50.220]             }
[10:32:50.220]         }))
[10:32:50.220]     }, error = function(ex) {
[10:32:50.220]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.220]                 ...future.rng), started = ...future.startTime, 
[10:32:50.220]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.220]             version = "1.8"), class = "FutureResult")
[10:32:50.220]     }, finally = {
[10:32:50.220]         if (!identical(...future.workdir, getwd())) 
[10:32:50.220]             setwd(...future.workdir)
[10:32:50.220]         {
[10:32:50.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.220]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.220]             }
[10:32:50.220]             base::options(...future.oldOptions)
[10:32:50.220]             if (.Platform$OS.type == "windows") {
[10:32:50.220]                 old_names <- names(...future.oldEnvVars)
[10:32:50.220]                 envs <- base::Sys.getenv()
[10:32:50.220]                 names <- names(envs)
[10:32:50.220]                 common <- intersect(names, old_names)
[10:32:50.220]                 added <- setdiff(names, old_names)
[10:32:50.220]                 removed <- setdiff(old_names, names)
[10:32:50.220]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.220]                   envs[common]]
[10:32:50.220]                 NAMES <- toupper(changed)
[10:32:50.220]                 args <- list()
[10:32:50.220]                 for (kk in seq_along(NAMES)) {
[10:32:50.220]                   name <- changed[[kk]]
[10:32:50.220]                   NAME <- NAMES[[kk]]
[10:32:50.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.220]                     next
[10:32:50.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.220]                 }
[10:32:50.220]                 NAMES <- toupper(added)
[10:32:50.220]                 for (kk in seq_along(NAMES)) {
[10:32:50.220]                   name <- added[[kk]]
[10:32:50.220]                   NAME <- NAMES[[kk]]
[10:32:50.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.220]                     next
[10:32:50.220]                   args[[name]] <- ""
[10:32:50.220]                 }
[10:32:50.220]                 NAMES <- toupper(removed)
[10:32:50.220]                 for (kk in seq_along(NAMES)) {
[10:32:50.220]                   name <- removed[[kk]]
[10:32:50.220]                   NAME <- NAMES[[kk]]
[10:32:50.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.220]                     next
[10:32:50.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.220]                 }
[10:32:50.220]                 if (length(args) > 0) 
[10:32:50.220]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.220]             }
[10:32:50.220]             else {
[10:32:50.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.220]             }
[10:32:50.220]             {
[10:32:50.220]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.220]                   0L) {
[10:32:50.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.220]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.220]                   base::options(opts)
[10:32:50.220]                 }
[10:32:50.220]                 {
[10:32:50.220]                   {
[10:32:50.220]                     NULL
[10:32:50.220]                     RNGkind("Mersenne-Twister")
[10:32:50.220]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.220]                       inherits = FALSE)
[10:32:50.220]                   }
[10:32:50.220]                   options(future.plan = NULL)
[10:32:50.220]                   if (is.na(NA_character_)) 
[10:32:50.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.220]                     .init = FALSE)
[10:32:50.220]                 }
[10:32:50.220]             }
[10:32:50.220]         }
[10:32:50.220]     })
[10:32:50.220]     if (TRUE) {
[10:32:50.220]         base::sink(type = "output", split = FALSE)
[10:32:50.220]         if (TRUE) {
[10:32:50.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.220]         }
[10:32:50.220]         else {
[10:32:50.220]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.220]         }
[10:32:50.220]         base::close(...future.stdout)
[10:32:50.220]         ...future.stdout <- NULL
[10:32:50.220]     }
[10:32:50.220]     ...future.result$conditions <- ...future.conditions
[10:32:50.220]     ...future.result$finished <- base::Sys.time()
[10:32:50.220]     ...future.result
[10:32:50.220] }
[10:32:50.222] plan(): Setting new future strategy stack:
[10:32:50.222] List of future strategies:
[10:32:50.222] 1. sequential:
[10:32:50.222]    - args: function (..., envir = parent.frame())
[10:32:50.222]    - tweaked: FALSE
[10:32:50.222]    - call: NULL
[10:32:50.222] plan(): nbrOfWorkers() = 1
[10:32:50.223] plan(): Setting new future strategy stack:
[10:32:50.223] List of future strategies:
[10:32:50.223] 1. sequential:
[10:32:50.223]    - args: function (..., envir = parent.frame())
[10:32:50.223]    - tweaked: FALSE
[10:32:50.223]    - call: plan(strategy)
[10:32:50.223] plan(): nbrOfWorkers() = 1
[10:32:50.223] SequentialFuture started (and completed)
[10:32:50.223] - Launch lazy future ... done
[10:32:50.223] run() for ‘SequentialFuture’ ... done
[10:32:50.225] getGlobalsAndPackages() ...
[10:32:50.225] Searching for globals...
[10:32:50.225] 
[10:32:50.225] Searching for globals ... DONE
[10:32:50.225] - globals: [0] <none>
[10:32:50.225] getGlobalsAndPackages() ... DONE
[10:32:50.226] run() for ‘Future’ ...
[10:32:50.226] - state: ‘created’
[10:32:50.226] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.226] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.226]   - Field: ‘label’
[10:32:50.226]   - Field: ‘local’
[10:32:50.226]   - Field: ‘owner’
[10:32:50.227]   - Field: ‘envir’
[10:32:50.227]   - Field: ‘packages’
[10:32:50.227]   - Field: ‘gc’
[10:32:50.227]   - Field: ‘conditions’
[10:32:50.227]   - Field: ‘expr’
[10:32:50.227]   - Field: ‘uuid’
[10:32:50.227]   - Field: ‘seed’
[10:32:50.227]   - Field: ‘version’
[10:32:50.227]   - Field: ‘result’
[10:32:50.227]   - Field: ‘asynchronous’
[10:32:50.227]   - Field: ‘calls’
[10:32:50.227]   - Field: ‘globals’
[10:32:50.228]   - Field: ‘stdout’
[10:32:50.228]   - Field: ‘earlySignal’
[10:32:50.228]   - Field: ‘lazy’
[10:32:50.228]   - Field: ‘state’
[10:32:50.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.228] - Launch lazy future ...
[10:32:50.228] Packages needed by the future expression (n = 0): <none>
[10:32:50.228] Packages needed by future strategies (n = 0): <none>
[10:32:50.229] {
[10:32:50.229]     {
[10:32:50.229]         {
[10:32:50.229]             ...future.startTime <- base::Sys.time()
[10:32:50.229]             {
[10:32:50.229]                 {
[10:32:50.229]                   {
[10:32:50.229]                     base::local({
[10:32:50.229]                       has_future <- base::requireNamespace("future", 
[10:32:50.229]                         quietly = TRUE)
[10:32:50.229]                       if (has_future) {
[10:32:50.229]                         ns <- base::getNamespace("future")
[10:32:50.229]                         version <- ns[[".package"]][["version"]]
[10:32:50.229]                         if (is.null(version)) 
[10:32:50.229]                           version <- utils::packageVersion("future")
[10:32:50.229]                       }
[10:32:50.229]                       else {
[10:32:50.229]                         version <- NULL
[10:32:50.229]                       }
[10:32:50.229]                       if (!has_future || version < "1.8.0") {
[10:32:50.229]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.229]                           "", base::R.version$version.string), 
[10:32:50.229]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.229]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.229]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.229]                             "release", "version")], collapse = " "), 
[10:32:50.229]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.229]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.229]                           info)
[10:32:50.229]                         info <- base::paste(info, collapse = "; ")
[10:32:50.229]                         if (!has_future) {
[10:32:50.229]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.229]                             info)
[10:32:50.229]                         }
[10:32:50.229]                         else {
[10:32:50.229]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.229]                             info, version)
[10:32:50.229]                         }
[10:32:50.229]                         base::stop(msg)
[10:32:50.229]                       }
[10:32:50.229]                     })
[10:32:50.229]                   }
[10:32:50.229]                   ...future.strategy.old <- future::plan("list")
[10:32:50.229]                   options(future.plan = NULL)
[10:32:50.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.229]                 }
[10:32:50.229]                 ...future.workdir <- getwd()
[10:32:50.229]             }
[10:32:50.229]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.229]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.229]         }
[10:32:50.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.229]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.229]             base::names(...future.oldOptions))
[10:32:50.229]     }
[10:32:50.229]     if (FALSE) {
[10:32:50.229]     }
[10:32:50.229]     else {
[10:32:50.229]         if (TRUE) {
[10:32:50.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.229]                 open = "w")
[10:32:50.229]         }
[10:32:50.229]         else {
[10:32:50.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.229]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.229]         }
[10:32:50.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.229]             base::sink(type = "output", split = FALSE)
[10:32:50.229]             base::close(...future.stdout)
[10:32:50.229]         }, add = TRUE)
[10:32:50.229]     }
[10:32:50.229]     ...future.frame <- base::sys.nframe()
[10:32:50.229]     ...future.conditions <- base::list()
[10:32:50.229]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.229]     if (FALSE) {
[10:32:50.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.229]     }
[10:32:50.229]     ...future.result <- base::tryCatch({
[10:32:50.229]         base::withCallingHandlers({
[10:32:50.229]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.229]             future::FutureResult(value = ...future.value$value, 
[10:32:50.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.229]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.229]                     ...future.globalenv.names))
[10:32:50.229]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.229]         }, condition = base::local({
[10:32:50.229]             c <- base::c
[10:32:50.229]             inherits <- base::inherits
[10:32:50.229]             invokeRestart <- base::invokeRestart
[10:32:50.229]             length <- base::length
[10:32:50.229]             list <- base::list
[10:32:50.229]             seq.int <- base::seq.int
[10:32:50.229]             signalCondition <- base::signalCondition
[10:32:50.229]             sys.calls <- base::sys.calls
[10:32:50.229]             `[[` <- base::`[[`
[10:32:50.229]             `+` <- base::`+`
[10:32:50.229]             `<<-` <- base::`<<-`
[10:32:50.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.229]                   3L)]
[10:32:50.229]             }
[10:32:50.229]             function(cond) {
[10:32:50.229]                 is_error <- inherits(cond, "error")
[10:32:50.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.229]                   NULL)
[10:32:50.229]                 if (is_error) {
[10:32:50.229]                   sessionInformation <- function() {
[10:32:50.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.229]                       search = base::search(), system = base::Sys.info())
[10:32:50.229]                   }
[10:32:50.229]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.229]                     cond$call), session = sessionInformation(), 
[10:32:50.229]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.229]                   signalCondition(cond)
[10:32:50.229]                 }
[10:32:50.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.229]                 "immediateCondition"))) {
[10:32:50.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.229]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.229]                   if (TRUE && !signal) {
[10:32:50.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.229]                     {
[10:32:50.229]                       inherits <- base::inherits
[10:32:50.229]                       invokeRestart <- base::invokeRestart
[10:32:50.229]                       is.null <- base::is.null
[10:32:50.229]                       muffled <- FALSE
[10:32:50.229]                       if (inherits(cond, "message")) {
[10:32:50.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.229]                         if (muffled) 
[10:32:50.229]                           invokeRestart("muffleMessage")
[10:32:50.229]                       }
[10:32:50.229]                       else if (inherits(cond, "warning")) {
[10:32:50.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.229]                         if (muffled) 
[10:32:50.229]                           invokeRestart("muffleWarning")
[10:32:50.229]                       }
[10:32:50.229]                       else if (inherits(cond, "condition")) {
[10:32:50.229]                         if (!is.null(pattern)) {
[10:32:50.229]                           computeRestarts <- base::computeRestarts
[10:32:50.229]                           grepl <- base::grepl
[10:32:50.229]                           restarts <- computeRestarts(cond)
[10:32:50.229]                           for (restart in restarts) {
[10:32:50.229]                             name <- restart$name
[10:32:50.229]                             if (is.null(name)) 
[10:32:50.229]                               next
[10:32:50.229]                             if (!grepl(pattern, name)) 
[10:32:50.229]                               next
[10:32:50.229]                             invokeRestart(restart)
[10:32:50.229]                             muffled <- TRUE
[10:32:50.229]                             break
[10:32:50.229]                           }
[10:32:50.229]                         }
[10:32:50.229]                       }
[10:32:50.229]                       invisible(muffled)
[10:32:50.229]                     }
[10:32:50.229]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.229]                   }
[10:32:50.229]                 }
[10:32:50.229]                 else {
[10:32:50.229]                   if (TRUE) {
[10:32:50.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.229]                     {
[10:32:50.229]                       inherits <- base::inherits
[10:32:50.229]                       invokeRestart <- base::invokeRestart
[10:32:50.229]                       is.null <- base::is.null
[10:32:50.229]                       muffled <- FALSE
[10:32:50.229]                       if (inherits(cond, "message")) {
[10:32:50.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.229]                         if (muffled) 
[10:32:50.229]                           invokeRestart("muffleMessage")
[10:32:50.229]                       }
[10:32:50.229]                       else if (inherits(cond, "warning")) {
[10:32:50.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.229]                         if (muffled) 
[10:32:50.229]                           invokeRestart("muffleWarning")
[10:32:50.229]                       }
[10:32:50.229]                       else if (inherits(cond, "condition")) {
[10:32:50.229]                         if (!is.null(pattern)) {
[10:32:50.229]                           computeRestarts <- base::computeRestarts
[10:32:50.229]                           grepl <- base::grepl
[10:32:50.229]                           restarts <- computeRestarts(cond)
[10:32:50.229]                           for (restart in restarts) {
[10:32:50.229]                             name <- restart$name
[10:32:50.229]                             if (is.null(name)) 
[10:32:50.229]                               next
[10:32:50.229]                             if (!grepl(pattern, name)) 
[10:32:50.229]                               next
[10:32:50.229]                             invokeRestart(restart)
[10:32:50.229]                             muffled <- TRUE
[10:32:50.229]                             break
[10:32:50.229]                           }
[10:32:50.229]                         }
[10:32:50.229]                       }
[10:32:50.229]                       invisible(muffled)
[10:32:50.229]                     }
[10:32:50.229]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.229]                   }
[10:32:50.229]                 }
[10:32:50.229]             }
[10:32:50.229]         }))
[10:32:50.229]     }, error = function(ex) {
[10:32:50.229]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.229]                 ...future.rng), started = ...future.startTime, 
[10:32:50.229]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.229]             version = "1.8"), class = "FutureResult")
[10:32:50.229]     }, finally = {
[10:32:50.229]         if (!identical(...future.workdir, getwd())) 
[10:32:50.229]             setwd(...future.workdir)
[10:32:50.229]         {
[10:32:50.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.229]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.229]             }
[10:32:50.229]             base::options(...future.oldOptions)
[10:32:50.229]             if (.Platform$OS.type == "windows") {
[10:32:50.229]                 old_names <- names(...future.oldEnvVars)
[10:32:50.229]                 envs <- base::Sys.getenv()
[10:32:50.229]                 names <- names(envs)
[10:32:50.229]                 common <- intersect(names, old_names)
[10:32:50.229]                 added <- setdiff(names, old_names)
[10:32:50.229]                 removed <- setdiff(old_names, names)
[10:32:50.229]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.229]                   envs[common]]
[10:32:50.229]                 NAMES <- toupper(changed)
[10:32:50.229]                 args <- list()
[10:32:50.229]                 for (kk in seq_along(NAMES)) {
[10:32:50.229]                   name <- changed[[kk]]
[10:32:50.229]                   NAME <- NAMES[[kk]]
[10:32:50.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.229]                     next
[10:32:50.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.229]                 }
[10:32:50.229]                 NAMES <- toupper(added)
[10:32:50.229]                 for (kk in seq_along(NAMES)) {
[10:32:50.229]                   name <- added[[kk]]
[10:32:50.229]                   NAME <- NAMES[[kk]]
[10:32:50.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.229]                     next
[10:32:50.229]                   args[[name]] <- ""
[10:32:50.229]                 }
[10:32:50.229]                 NAMES <- toupper(removed)
[10:32:50.229]                 for (kk in seq_along(NAMES)) {
[10:32:50.229]                   name <- removed[[kk]]
[10:32:50.229]                   NAME <- NAMES[[kk]]
[10:32:50.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.229]                     next
[10:32:50.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.229]                 }
[10:32:50.229]                 if (length(args) > 0) 
[10:32:50.229]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.229]             }
[10:32:50.229]             else {
[10:32:50.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.229]             }
[10:32:50.229]             {
[10:32:50.229]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.229]                   0L) {
[10:32:50.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.229]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.229]                   base::options(opts)
[10:32:50.229]                 }
[10:32:50.229]                 {
[10:32:50.229]                   {
[10:32:50.229]                     NULL
[10:32:50.229]                     RNGkind("Mersenne-Twister")
[10:32:50.229]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.229]                       inherits = FALSE)
[10:32:50.229]                   }
[10:32:50.229]                   options(future.plan = NULL)
[10:32:50.229]                   if (is.na(NA_character_)) 
[10:32:50.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.229]                     .init = FALSE)
[10:32:50.229]                 }
[10:32:50.229]             }
[10:32:50.229]         }
[10:32:50.229]     })
[10:32:50.229]     if (TRUE) {
[10:32:50.229]         base::sink(type = "output", split = FALSE)
[10:32:50.229]         if (TRUE) {
[10:32:50.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.229]         }
[10:32:50.229]         else {
[10:32:50.229]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.229]         }
[10:32:50.229]         base::close(...future.stdout)
[10:32:50.229]         ...future.stdout <- NULL
[10:32:50.229]     }
[10:32:50.229]     ...future.result$conditions <- ...future.conditions
[10:32:50.229]     ...future.result$finished <- base::Sys.time()
[10:32:50.229]     ...future.result
[10:32:50.229] }
[10:32:50.230] plan(): Setting new future strategy stack:
[10:32:50.230] List of future strategies:
[10:32:50.230] 1. sequential:
[10:32:50.230]    - args: function (..., envir = parent.frame())
[10:32:50.230]    - tweaked: FALSE
[10:32:50.230]    - call: NULL
[10:32:50.231] plan(): nbrOfWorkers() = 1
[10:32:50.231] plan(): Setting new future strategy stack:
[10:32:50.231] List of future strategies:
[10:32:50.231] 1. sequential:
[10:32:50.231]    - args: function (..., envir = parent.frame())
[10:32:50.231]    - tweaked: FALSE
[10:32:50.231]    - call: plan(strategy)
[10:32:50.232] plan(): nbrOfWorkers() = 1
[10:32:50.232] SequentialFuture started (and completed)
[10:32:50.232] - Launch lazy future ... done
[10:32:50.232] run() for ‘SequentialFuture’ ... done
[10:32:50.232] getGlobalsAndPackages() ...
[10:32:50.233] Searching for globals...
[10:32:50.233] - globals found: [1] ‘{’
[10:32:50.233] Searching for globals ... DONE
[10:32:50.233] Resolving globals: FALSE
[10:32:50.234] 
[10:32:50.234] 
[10:32:50.234] getGlobalsAndPackages() ... DONE
[10:32:50.234] run() for ‘Future’ ...
[10:32:50.234] - state: ‘created’
[10:32:50.234] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.235]   - Field: ‘label’
[10:32:50.235]   - Field: ‘local’
[10:32:50.235]   - Field: ‘owner’
[10:32:50.235]   - Field: ‘envir’
[10:32:50.235]   - Field: ‘packages’
[10:32:50.235]   - Field: ‘gc’
[10:32:50.235]   - Field: ‘conditions’
[10:32:50.235]   - Field: ‘expr’
[10:32:50.235]   - Field: ‘uuid’
[10:32:50.235]   - Field: ‘seed’
[10:32:50.235]   - Field: ‘version’
[10:32:50.236]   - Field: ‘result’
[10:32:50.236]   - Field: ‘asynchronous’
[10:32:50.236]   - Field: ‘calls’
[10:32:50.236]   - Field: ‘globals’
[10:32:50.236]   - Field: ‘stdout’
[10:32:50.236]   - Field: ‘earlySignal’
[10:32:50.236]   - Field: ‘lazy’
[10:32:50.236]   - Field: ‘state’
[10:32:50.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.236] - Launch lazy future ...
[10:32:50.236] Packages needed by the future expression (n = 0): <none>
[10:32:50.237] Packages needed by future strategies (n = 0): <none>
[10:32:50.237] {
[10:32:50.237]     {
[10:32:50.237]         {
[10:32:50.237]             ...future.startTime <- base::Sys.time()
[10:32:50.237]             {
[10:32:50.237]                 {
[10:32:50.237]                   {
[10:32:50.237]                     base::local({
[10:32:50.237]                       has_future <- base::requireNamespace("future", 
[10:32:50.237]                         quietly = TRUE)
[10:32:50.237]                       if (has_future) {
[10:32:50.237]                         ns <- base::getNamespace("future")
[10:32:50.237]                         version <- ns[[".package"]][["version"]]
[10:32:50.237]                         if (is.null(version)) 
[10:32:50.237]                           version <- utils::packageVersion("future")
[10:32:50.237]                       }
[10:32:50.237]                       else {
[10:32:50.237]                         version <- NULL
[10:32:50.237]                       }
[10:32:50.237]                       if (!has_future || version < "1.8.0") {
[10:32:50.237]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.237]                           "", base::R.version$version.string), 
[10:32:50.237]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.237]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.237]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.237]                             "release", "version")], collapse = " "), 
[10:32:50.237]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.237]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.237]                           info)
[10:32:50.237]                         info <- base::paste(info, collapse = "; ")
[10:32:50.237]                         if (!has_future) {
[10:32:50.237]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.237]                             info)
[10:32:50.237]                         }
[10:32:50.237]                         else {
[10:32:50.237]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.237]                             info, version)
[10:32:50.237]                         }
[10:32:50.237]                         base::stop(msg)
[10:32:50.237]                       }
[10:32:50.237]                     })
[10:32:50.237]                   }
[10:32:50.237]                   ...future.strategy.old <- future::plan("list")
[10:32:50.237]                   options(future.plan = NULL)
[10:32:50.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.237]                 }
[10:32:50.237]                 ...future.workdir <- getwd()
[10:32:50.237]             }
[10:32:50.237]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.237]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.237]         }
[10:32:50.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.237]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.237]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.237]             base::names(...future.oldOptions))
[10:32:50.237]     }
[10:32:50.237]     if (FALSE) {
[10:32:50.237]     }
[10:32:50.237]     else {
[10:32:50.237]         if (TRUE) {
[10:32:50.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.237]                 open = "w")
[10:32:50.237]         }
[10:32:50.237]         else {
[10:32:50.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.237]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.237]         }
[10:32:50.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.237]             base::sink(type = "output", split = FALSE)
[10:32:50.237]             base::close(...future.stdout)
[10:32:50.237]         }, add = TRUE)
[10:32:50.237]     }
[10:32:50.237]     ...future.frame <- base::sys.nframe()
[10:32:50.237]     ...future.conditions <- base::list()
[10:32:50.237]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.237]     if (FALSE) {
[10:32:50.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.237]     }
[10:32:50.237]     ...future.result <- base::tryCatch({
[10:32:50.237]         base::withCallingHandlers({
[10:32:50.237]             ...future.value <- base::withVisible(base::local({
[10:32:50.237]                 4
[10:32:50.237]             }))
[10:32:50.237]             future::FutureResult(value = ...future.value$value, 
[10:32:50.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.237]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.237]                     ...future.globalenv.names))
[10:32:50.237]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.237]         }, condition = base::local({
[10:32:50.237]             c <- base::c
[10:32:50.237]             inherits <- base::inherits
[10:32:50.237]             invokeRestart <- base::invokeRestart
[10:32:50.237]             length <- base::length
[10:32:50.237]             list <- base::list
[10:32:50.237]             seq.int <- base::seq.int
[10:32:50.237]             signalCondition <- base::signalCondition
[10:32:50.237]             sys.calls <- base::sys.calls
[10:32:50.237]             `[[` <- base::`[[`
[10:32:50.237]             `+` <- base::`+`
[10:32:50.237]             `<<-` <- base::`<<-`
[10:32:50.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.237]                   3L)]
[10:32:50.237]             }
[10:32:50.237]             function(cond) {
[10:32:50.237]                 is_error <- inherits(cond, "error")
[10:32:50.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.237]                   NULL)
[10:32:50.237]                 if (is_error) {
[10:32:50.237]                   sessionInformation <- function() {
[10:32:50.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.237]                       search = base::search(), system = base::Sys.info())
[10:32:50.237]                   }
[10:32:50.237]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.237]                     cond$call), session = sessionInformation(), 
[10:32:50.237]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.237]                   signalCondition(cond)
[10:32:50.237]                 }
[10:32:50.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.237]                 "immediateCondition"))) {
[10:32:50.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.237]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.237]                   if (TRUE && !signal) {
[10:32:50.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.237]                     {
[10:32:50.237]                       inherits <- base::inherits
[10:32:50.237]                       invokeRestart <- base::invokeRestart
[10:32:50.237]                       is.null <- base::is.null
[10:32:50.237]                       muffled <- FALSE
[10:32:50.237]                       if (inherits(cond, "message")) {
[10:32:50.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.237]                         if (muffled) 
[10:32:50.237]                           invokeRestart("muffleMessage")
[10:32:50.237]                       }
[10:32:50.237]                       else if (inherits(cond, "warning")) {
[10:32:50.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.237]                         if (muffled) 
[10:32:50.237]                           invokeRestart("muffleWarning")
[10:32:50.237]                       }
[10:32:50.237]                       else if (inherits(cond, "condition")) {
[10:32:50.237]                         if (!is.null(pattern)) {
[10:32:50.237]                           computeRestarts <- base::computeRestarts
[10:32:50.237]                           grepl <- base::grepl
[10:32:50.237]                           restarts <- computeRestarts(cond)
[10:32:50.237]                           for (restart in restarts) {
[10:32:50.237]                             name <- restart$name
[10:32:50.237]                             if (is.null(name)) 
[10:32:50.237]                               next
[10:32:50.237]                             if (!grepl(pattern, name)) 
[10:32:50.237]                               next
[10:32:50.237]                             invokeRestart(restart)
[10:32:50.237]                             muffled <- TRUE
[10:32:50.237]                             break
[10:32:50.237]                           }
[10:32:50.237]                         }
[10:32:50.237]                       }
[10:32:50.237]                       invisible(muffled)
[10:32:50.237]                     }
[10:32:50.237]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.237]                   }
[10:32:50.237]                 }
[10:32:50.237]                 else {
[10:32:50.237]                   if (TRUE) {
[10:32:50.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.237]                     {
[10:32:50.237]                       inherits <- base::inherits
[10:32:50.237]                       invokeRestart <- base::invokeRestart
[10:32:50.237]                       is.null <- base::is.null
[10:32:50.237]                       muffled <- FALSE
[10:32:50.237]                       if (inherits(cond, "message")) {
[10:32:50.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.237]                         if (muffled) 
[10:32:50.237]                           invokeRestart("muffleMessage")
[10:32:50.237]                       }
[10:32:50.237]                       else if (inherits(cond, "warning")) {
[10:32:50.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.237]                         if (muffled) 
[10:32:50.237]                           invokeRestart("muffleWarning")
[10:32:50.237]                       }
[10:32:50.237]                       else if (inherits(cond, "condition")) {
[10:32:50.237]                         if (!is.null(pattern)) {
[10:32:50.237]                           computeRestarts <- base::computeRestarts
[10:32:50.237]                           grepl <- base::grepl
[10:32:50.237]                           restarts <- computeRestarts(cond)
[10:32:50.237]                           for (restart in restarts) {
[10:32:50.237]                             name <- restart$name
[10:32:50.237]                             if (is.null(name)) 
[10:32:50.237]                               next
[10:32:50.237]                             if (!grepl(pattern, name)) 
[10:32:50.237]                               next
[10:32:50.237]                             invokeRestart(restart)
[10:32:50.237]                             muffled <- TRUE
[10:32:50.237]                             break
[10:32:50.237]                           }
[10:32:50.237]                         }
[10:32:50.237]                       }
[10:32:50.237]                       invisible(muffled)
[10:32:50.237]                     }
[10:32:50.237]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.237]                   }
[10:32:50.237]                 }
[10:32:50.237]             }
[10:32:50.237]         }))
[10:32:50.237]     }, error = function(ex) {
[10:32:50.237]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.237]                 ...future.rng), started = ...future.startTime, 
[10:32:50.237]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.237]             version = "1.8"), class = "FutureResult")
[10:32:50.237]     }, finally = {
[10:32:50.237]         if (!identical(...future.workdir, getwd())) 
[10:32:50.237]             setwd(...future.workdir)
[10:32:50.237]         {
[10:32:50.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.237]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.237]             }
[10:32:50.237]             base::options(...future.oldOptions)
[10:32:50.237]             if (.Platform$OS.type == "windows") {
[10:32:50.237]                 old_names <- names(...future.oldEnvVars)
[10:32:50.237]                 envs <- base::Sys.getenv()
[10:32:50.237]                 names <- names(envs)
[10:32:50.237]                 common <- intersect(names, old_names)
[10:32:50.237]                 added <- setdiff(names, old_names)
[10:32:50.237]                 removed <- setdiff(old_names, names)
[10:32:50.237]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.237]                   envs[common]]
[10:32:50.237]                 NAMES <- toupper(changed)
[10:32:50.237]                 args <- list()
[10:32:50.237]                 for (kk in seq_along(NAMES)) {
[10:32:50.237]                   name <- changed[[kk]]
[10:32:50.237]                   NAME <- NAMES[[kk]]
[10:32:50.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.237]                     next
[10:32:50.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.237]                 }
[10:32:50.237]                 NAMES <- toupper(added)
[10:32:50.237]                 for (kk in seq_along(NAMES)) {
[10:32:50.237]                   name <- added[[kk]]
[10:32:50.237]                   NAME <- NAMES[[kk]]
[10:32:50.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.237]                     next
[10:32:50.237]                   args[[name]] <- ""
[10:32:50.237]                 }
[10:32:50.237]                 NAMES <- toupper(removed)
[10:32:50.237]                 for (kk in seq_along(NAMES)) {
[10:32:50.237]                   name <- removed[[kk]]
[10:32:50.237]                   NAME <- NAMES[[kk]]
[10:32:50.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.237]                     next
[10:32:50.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.237]                 }
[10:32:50.237]                 if (length(args) > 0) 
[10:32:50.237]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.237]             }
[10:32:50.237]             else {
[10:32:50.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.237]             }
[10:32:50.237]             {
[10:32:50.237]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.237]                   0L) {
[10:32:50.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.237]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.237]                   base::options(opts)
[10:32:50.237]                 }
[10:32:50.237]                 {
[10:32:50.237]                   {
[10:32:50.237]                     NULL
[10:32:50.237]                     RNGkind("Mersenne-Twister")
[10:32:50.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.237]                       inherits = FALSE)
[10:32:50.237]                   }
[10:32:50.237]                   options(future.plan = NULL)
[10:32:50.237]                   if (is.na(NA_character_)) 
[10:32:50.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.237]                     .init = FALSE)
[10:32:50.237]                 }
[10:32:50.237]             }
[10:32:50.237]         }
[10:32:50.237]     })
[10:32:50.237]     if (TRUE) {
[10:32:50.237]         base::sink(type = "output", split = FALSE)
[10:32:50.237]         if (TRUE) {
[10:32:50.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.237]         }
[10:32:50.237]         else {
[10:32:50.237]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.237]         }
[10:32:50.237]         base::close(...future.stdout)
[10:32:50.237]         ...future.stdout <- NULL
[10:32:50.237]     }
[10:32:50.237]     ...future.result$conditions <- ...future.conditions
[10:32:50.237]     ...future.result$finished <- base::Sys.time()
[10:32:50.237]     ...future.result
[10:32:50.237] }
[10:32:50.239] plan(): Setting new future strategy stack:
[10:32:50.239] List of future strategies:
[10:32:50.239] 1. sequential:
[10:32:50.239]    - args: function (..., envir = parent.frame())
[10:32:50.239]    - tweaked: FALSE
[10:32:50.239]    - call: NULL
[10:32:50.239] plan(): nbrOfWorkers() = 1
[10:32:50.240] plan(): Setting new future strategy stack:
[10:32:50.240] List of future strategies:
[10:32:50.240] 1. sequential:
[10:32:50.240]    - args: function (..., envir = parent.frame())
[10:32:50.240]    - tweaked: FALSE
[10:32:50.240]    - call: plan(strategy)
[10:32:50.240] plan(): nbrOfWorkers() = 1
[10:32:50.240] SequentialFuture started (and completed)
[10:32:50.240] - Launch lazy future ... done
[10:32:50.240] run() for ‘SequentialFuture’ ... done
<environment: 0x5652d1011238> 
<environment: 0x5652d0dd8078> 
[10:32:50.242] resolved() for ‘SequentialFuture’ ...
[10:32:50.242] - state: ‘finished’
[10:32:50.242] - run: TRUE
[10:32:50.242] - result: ‘FutureResult’
[10:32:50.242] resolved() for ‘SequentialFuture’ ... done
[10:32:50.242] resolved() for ‘SequentialFuture’ ...
[10:32:50.242] - state: ‘finished’
[10:32:50.242] - run: TRUE
[10:32:50.242] - result: ‘FutureResult’
[10:32:50.242] resolved() for ‘SequentialFuture’ ... done
[10:32:50.243] resolved() for ‘SequentialFuture’ ...
[10:32:50.243] - state: ‘finished’
[10:32:50.243] - run: TRUE
[10:32:50.243] - result: ‘FutureResult’
[10:32:50.243] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:50.244] resolve() on environment ...
[10:32:50.244]  recursive: 0
[10:32:50.244]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:50.245] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.245] - nx: 4
[10:32:50.245] - relay: TRUE
[10:32:50.245] - stdout: TRUE
[10:32:50.245] - signal: TRUE
[10:32:50.245] - resignal: FALSE
[10:32:50.245] - force: TRUE
[10:32:50.245] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.245] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.245]  - until=2
[10:32:50.245]  - relaying element #2
[10:32:50.246] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.246] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.246] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.246]  length: 3 (resolved future 1)
[10:32:50.246] resolved() for ‘SequentialFuture’ ...
[10:32:50.246] - state: ‘finished’
[10:32:50.246] - run: TRUE
[10:32:50.246] - result: ‘FutureResult’
[10:32:50.246] resolved() for ‘SequentialFuture’ ... done
[10:32:50.246] Future #2
[10:32:50.246] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.247] - nx: 4
[10:32:50.247] - relay: TRUE
[10:32:50.247] - stdout: TRUE
[10:32:50.247] - signal: TRUE
[10:32:50.247] - resignal: FALSE
[10:32:50.247] - force: TRUE
[10:32:50.247] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.247] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.247]  - until=2
[10:32:50.247]  - relaying element #2
[10:32:50.247] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.248] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.248] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.248]  length: 2 (resolved future 2)
[10:32:50.248] resolved() for ‘SequentialFuture’ ...
[10:32:50.248] - state: ‘finished’
[10:32:50.248] - run: TRUE
[10:32:50.248] - result: ‘FutureResult’
[10:32:50.248] resolved() for ‘SequentialFuture’ ... done
[10:32:50.248] Future #3
[10:32:50.248] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.248] - nx: 4
[10:32:50.249] - relay: TRUE
[10:32:50.249] - stdout: TRUE
[10:32:50.249] - signal: TRUE
[10:32:50.249] - resignal: FALSE
[10:32:50.249] - force: TRUE
[10:32:50.249] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.249] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.249]  - until=3
[10:32:50.249]  - relaying element #3
[10:32:50.250] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.250] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.251] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.251]  length: 1 (resolved future 3)
[10:32:50.251] resolved() for ‘SequentialFuture’ ...
[10:32:50.251] - state: ‘finished’
[10:32:50.251] - run: TRUE
[10:32:50.251] - result: ‘FutureResult’
[10:32:50.251] resolved() for ‘SequentialFuture’ ... done
[10:32:50.251] Future #4
[10:32:50.251] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.251] - nx: 4
[10:32:50.252] - relay: TRUE
[10:32:50.252] - stdout: TRUE
[10:32:50.252] - signal: TRUE
[10:32:50.252] - resignal: FALSE
[10:32:50.252] - force: TRUE
[10:32:50.252] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.252] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.252]  - until=4
[10:32:50.252]  - relaying element #4
[10:32:50.252] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.252] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.253] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.253]  length: 0 (resolved future 4)
[10:32:50.253] Relaying remaining futures
[10:32:50.253] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.253] - nx: 4
[10:32:50.253] - relay: TRUE
[10:32:50.253] - stdout: TRUE
[10:32:50.253] - signal: TRUE
[10:32:50.253] - resignal: FALSE
[10:32:50.253] - force: TRUE
[10:32:50.253] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.253] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:50.254] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.254] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.254] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.254] resolve() on environment ... DONE
<environment: 0x5652d101d028> 
Dimensions: c(2, 3)
[10:32:50.254] getGlobalsAndPackages() ...
[10:32:50.254] Searching for globals...
[10:32:50.255] 
[10:32:50.255] Searching for globals ... DONE
[10:32:50.255] - globals: [0] <none>
[10:32:50.255] getGlobalsAndPackages() ... DONE
[10:32:50.255] run() for ‘Future’ ...
[10:32:50.255] - state: ‘created’
[10:32:50.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.256]   - Field: ‘label’
[10:32:50.256]   - Field: ‘local’
[10:32:50.256]   - Field: ‘owner’
[10:32:50.256]   - Field: ‘envir’
[10:32:50.256]   - Field: ‘packages’
[10:32:50.256]   - Field: ‘gc’
[10:32:50.256]   - Field: ‘conditions’
[10:32:50.256]   - Field: ‘expr’
[10:32:50.257]   - Field: ‘uuid’
[10:32:50.257]   - Field: ‘seed’
[10:32:50.257]   - Field: ‘version’
[10:32:50.257]   - Field: ‘result’
[10:32:50.257]   - Field: ‘asynchronous’
[10:32:50.257]   - Field: ‘calls’
[10:32:50.257]   - Field: ‘globals’
[10:32:50.257]   - Field: ‘stdout’
[10:32:50.257]   - Field: ‘earlySignal’
[10:32:50.257]   - Field: ‘lazy’
[10:32:50.257]   - Field: ‘state’
[10:32:50.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.258] - Launch lazy future ...
[10:32:50.258] Packages needed by the future expression (n = 0): <none>
[10:32:50.258] Packages needed by future strategies (n = 0): <none>
[10:32:50.258] {
[10:32:50.258]     {
[10:32:50.258]         {
[10:32:50.258]             ...future.startTime <- base::Sys.time()
[10:32:50.258]             {
[10:32:50.258]                 {
[10:32:50.258]                   {
[10:32:50.258]                     base::local({
[10:32:50.258]                       has_future <- base::requireNamespace("future", 
[10:32:50.258]                         quietly = TRUE)
[10:32:50.258]                       if (has_future) {
[10:32:50.258]                         ns <- base::getNamespace("future")
[10:32:50.258]                         version <- ns[[".package"]][["version"]]
[10:32:50.258]                         if (is.null(version)) 
[10:32:50.258]                           version <- utils::packageVersion("future")
[10:32:50.258]                       }
[10:32:50.258]                       else {
[10:32:50.258]                         version <- NULL
[10:32:50.258]                       }
[10:32:50.258]                       if (!has_future || version < "1.8.0") {
[10:32:50.258]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.258]                           "", base::R.version$version.string), 
[10:32:50.258]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.258]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.258]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.258]                             "release", "version")], collapse = " "), 
[10:32:50.258]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.258]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.258]                           info)
[10:32:50.258]                         info <- base::paste(info, collapse = "; ")
[10:32:50.258]                         if (!has_future) {
[10:32:50.258]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.258]                             info)
[10:32:50.258]                         }
[10:32:50.258]                         else {
[10:32:50.258]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.258]                             info, version)
[10:32:50.258]                         }
[10:32:50.258]                         base::stop(msg)
[10:32:50.258]                       }
[10:32:50.258]                     })
[10:32:50.258]                   }
[10:32:50.258]                   ...future.strategy.old <- future::plan("list")
[10:32:50.258]                   options(future.plan = NULL)
[10:32:50.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.258]                 }
[10:32:50.258]                 ...future.workdir <- getwd()
[10:32:50.258]             }
[10:32:50.258]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.258]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.258]         }
[10:32:50.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.258]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.258]             base::names(...future.oldOptions))
[10:32:50.258]     }
[10:32:50.258]     if (FALSE) {
[10:32:50.258]     }
[10:32:50.258]     else {
[10:32:50.258]         if (TRUE) {
[10:32:50.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.258]                 open = "w")
[10:32:50.258]         }
[10:32:50.258]         else {
[10:32:50.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.258]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.258]         }
[10:32:50.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.258]             base::sink(type = "output", split = FALSE)
[10:32:50.258]             base::close(...future.stdout)
[10:32:50.258]         }, add = TRUE)
[10:32:50.258]     }
[10:32:50.258]     ...future.frame <- base::sys.nframe()
[10:32:50.258]     ...future.conditions <- base::list()
[10:32:50.258]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.258]     if (FALSE) {
[10:32:50.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.258]     }
[10:32:50.258]     ...future.result <- base::tryCatch({
[10:32:50.258]         base::withCallingHandlers({
[10:32:50.258]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.258]             future::FutureResult(value = ...future.value$value, 
[10:32:50.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.258]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.258]                     ...future.globalenv.names))
[10:32:50.258]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.258]         }, condition = base::local({
[10:32:50.258]             c <- base::c
[10:32:50.258]             inherits <- base::inherits
[10:32:50.258]             invokeRestart <- base::invokeRestart
[10:32:50.258]             length <- base::length
[10:32:50.258]             list <- base::list
[10:32:50.258]             seq.int <- base::seq.int
[10:32:50.258]             signalCondition <- base::signalCondition
[10:32:50.258]             sys.calls <- base::sys.calls
[10:32:50.258]             `[[` <- base::`[[`
[10:32:50.258]             `+` <- base::`+`
[10:32:50.258]             `<<-` <- base::`<<-`
[10:32:50.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.258]                   3L)]
[10:32:50.258]             }
[10:32:50.258]             function(cond) {
[10:32:50.258]                 is_error <- inherits(cond, "error")
[10:32:50.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.258]                   NULL)
[10:32:50.258]                 if (is_error) {
[10:32:50.258]                   sessionInformation <- function() {
[10:32:50.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.258]                       search = base::search(), system = base::Sys.info())
[10:32:50.258]                   }
[10:32:50.258]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.258]                     cond$call), session = sessionInformation(), 
[10:32:50.258]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.258]                   signalCondition(cond)
[10:32:50.258]                 }
[10:32:50.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.258]                 "immediateCondition"))) {
[10:32:50.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.258]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.258]                   if (TRUE && !signal) {
[10:32:50.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.258]                     {
[10:32:50.258]                       inherits <- base::inherits
[10:32:50.258]                       invokeRestart <- base::invokeRestart
[10:32:50.258]                       is.null <- base::is.null
[10:32:50.258]                       muffled <- FALSE
[10:32:50.258]                       if (inherits(cond, "message")) {
[10:32:50.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.258]                         if (muffled) 
[10:32:50.258]                           invokeRestart("muffleMessage")
[10:32:50.258]                       }
[10:32:50.258]                       else if (inherits(cond, "warning")) {
[10:32:50.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.258]                         if (muffled) 
[10:32:50.258]                           invokeRestart("muffleWarning")
[10:32:50.258]                       }
[10:32:50.258]                       else if (inherits(cond, "condition")) {
[10:32:50.258]                         if (!is.null(pattern)) {
[10:32:50.258]                           computeRestarts <- base::computeRestarts
[10:32:50.258]                           grepl <- base::grepl
[10:32:50.258]                           restarts <- computeRestarts(cond)
[10:32:50.258]                           for (restart in restarts) {
[10:32:50.258]                             name <- restart$name
[10:32:50.258]                             if (is.null(name)) 
[10:32:50.258]                               next
[10:32:50.258]                             if (!grepl(pattern, name)) 
[10:32:50.258]                               next
[10:32:50.258]                             invokeRestart(restart)
[10:32:50.258]                             muffled <- TRUE
[10:32:50.258]                             break
[10:32:50.258]                           }
[10:32:50.258]                         }
[10:32:50.258]                       }
[10:32:50.258]                       invisible(muffled)
[10:32:50.258]                     }
[10:32:50.258]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.258]                   }
[10:32:50.258]                 }
[10:32:50.258]                 else {
[10:32:50.258]                   if (TRUE) {
[10:32:50.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.258]                     {
[10:32:50.258]                       inherits <- base::inherits
[10:32:50.258]                       invokeRestart <- base::invokeRestart
[10:32:50.258]                       is.null <- base::is.null
[10:32:50.258]                       muffled <- FALSE
[10:32:50.258]                       if (inherits(cond, "message")) {
[10:32:50.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.258]                         if (muffled) 
[10:32:50.258]                           invokeRestart("muffleMessage")
[10:32:50.258]                       }
[10:32:50.258]                       else if (inherits(cond, "warning")) {
[10:32:50.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.258]                         if (muffled) 
[10:32:50.258]                           invokeRestart("muffleWarning")
[10:32:50.258]                       }
[10:32:50.258]                       else if (inherits(cond, "condition")) {
[10:32:50.258]                         if (!is.null(pattern)) {
[10:32:50.258]                           computeRestarts <- base::computeRestarts
[10:32:50.258]                           grepl <- base::grepl
[10:32:50.258]                           restarts <- computeRestarts(cond)
[10:32:50.258]                           for (restart in restarts) {
[10:32:50.258]                             name <- restart$name
[10:32:50.258]                             if (is.null(name)) 
[10:32:50.258]                               next
[10:32:50.258]                             if (!grepl(pattern, name)) 
[10:32:50.258]                               next
[10:32:50.258]                             invokeRestart(restart)
[10:32:50.258]                             muffled <- TRUE
[10:32:50.258]                             break
[10:32:50.258]                           }
[10:32:50.258]                         }
[10:32:50.258]                       }
[10:32:50.258]                       invisible(muffled)
[10:32:50.258]                     }
[10:32:50.258]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.258]                   }
[10:32:50.258]                 }
[10:32:50.258]             }
[10:32:50.258]         }))
[10:32:50.258]     }, error = function(ex) {
[10:32:50.258]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.258]                 ...future.rng), started = ...future.startTime, 
[10:32:50.258]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.258]             version = "1.8"), class = "FutureResult")
[10:32:50.258]     }, finally = {
[10:32:50.258]         if (!identical(...future.workdir, getwd())) 
[10:32:50.258]             setwd(...future.workdir)
[10:32:50.258]         {
[10:32:50.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.258]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.258]             }
[10:32:50.258]             base::options(...future.oldOptions)
[10:32:50.258]             if (.Platform$OS.type == "windows") {
[10:32:50.258]                 old_names <- names(...future.oldEnvVars)
[10:32:50.258]                 envs <- base::Sys.getenv()
[10:32:50.258]                 names <- names(envs)
[10:32:50.258]                 common <- intersect(names, old_names)
[10:32:50.258]                 added <- setdiff(names, old_names)
[10:32:50.258]                 removed <- setdiff(old_names, names)
[10:32:50.258]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.258]                   envs[common]]
[10:32:50.258]                 NAMES <- toupper(changed)
[10:32:50.258]                 args <- list()
[10:32:50.258]                 for (kk in seq_along(NAMES)) {
[10:32:50.258]                   name <- changed[[kk]]
[10:32:50.258]                   NAME <- NAMES[[kk]]
[10:32:50.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.258]                     next
[10:32:50.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.258]                 }
[10:32:50.258]                 NAMES <- toupper(added)
[10:32:50.258]                 for (kk in seq_along(NAMES)) {
[10:32:50.258]                   name <- added[[kk]]
[10:32:50.258]                   NAME <- NAMES[[kk]]
[10:32:50.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.258]                     next
[10:32:50.258]                   args[[name]] <- ""
[10:32:50.258]                 }
[10:32:50.258]                 NAMES <- toupper(removed)
[10:32:50.258]                 for (kk in seq_along(NAMES)) {
[10:32:50.258]                   name <- removed[[kk]]
[10:32:50.258]                   NAME <- NAMES[[kk]]
[10:32:50.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.258]                     next
[10:32:50.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.258]                 }
[10:32:50.258]                 if (length(args) > 0) 
[10:32:50.258]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.258]             }
[10:32:50.258]             else {
[10:32:50.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.258]             }
[10:32:50.258]             {
[10:32:50.258]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.258]                   0L) {
[10:32:50.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.258]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.258]                   base::options(opts)
[10:32:50.258]                 }
[10:32:50.258]                 {
[10:32:50.258]                   {
[10:32:50.258]                     NULL
[10:32:50.258]                     RNGkind("Mersenne-Twister")
[10:32:50.258]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.258]                       inherits = FALSE)
[10:32:50.258]                   }
[10:32:50.258]                   options(future.plan = NULL)
[10:32:50.258]                   if (is.na(NA_character_)) 
[10:32:50.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.258]                     .init = FALSE)
[10:32:50.258]                 }
[10:32:50.258]             }
[10:32:50.258]         }
[10:32:50.258]     })
[10:32:50.258]     if (TRUE) {
[10:32:50.258]         base::sink(type = "output", split = FALSE)
[10:32:50.258]         if (TRUE) {
[10:32:50.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.258]         }
[10:32:50.258]         else {
[10:32:50.258]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.258]         }
[10:32:50.258]         base::close(...future.stdout)
[10:32:50.258]         ...future.stdout <- NULL
[10:32:50.258]     }
[10:32:50.258]     ...future.result$conditions <- ...future.conditions
[10:32:50.258]     ...future.result$finished <- base::Sys.time()
[10:32:50.258]     ...future.result
[10:32:50.258] }
[10:32:50.260] plan(): Setting new future strategy stack:
[10:32:50.260] List of future strategies:
[10:32:50.260] 1. sequential:
[10:32:50.260]    - args: function (..., envir = parent.frame())
[10:32:50.260]    - tweaked: FALSE
[10:32:50.260]    - call: NULL
[10:32:50.260] plan(): nbrOfWorkers() = 1
[10:32:50.261] plan(): Setting new future strategy stack:
[10:32:50.261] List of future strategies:
[10:32:50.261] 1. sequential:
[10:32:50.261]    - args: function (..., envir = parent.frame())
[10:32:50.261]    - tweaked: FALSE
[10:32:50.261]    - call: plan(strategy)
[10:32:50.261] plan(): nbrOfWorkers() = 1
[10:32:50.262] SequentialFuture started (and completed)
[10:32:50.262] - Launch lazy future ... done
[10:32:50.262] run() for ‘SequentialFuture’ ... done
[10:32:50.262] getGlobalsAndPackages() ...
[10:32:50.262] Searching for globals...
[10:32:50.262] 
[10:32:50.262] Searching for globals ... DONE
[10:32:50.262] - globals: [0] <none>
[10:32:50.263] getGlobalsAndPackages() ... DONE
[10:32:50.263] run() for ‘Future’ ...
[10:32:50.263] - state: ‘created’
[10:32:50.263] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.263] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.263]   - Field: ‘label’
[10:32:50.264]   - Field: ‘local’
[10:32:50.264]   - Field: ‘owner’
[10:32:50.264]   - Field: ‘envir’
[10:32:50.264]   - Field: ‘packages’
[10:32:50.264]   - Field: ‘gc’
[10:32:50.264]   - Field: ‘conditions’
[10:32:50.264]   - Field: ‘expr’
[10:32:50.264]   - Field: ‘uuid’
[10:32:50.264]   - Field: ‘seed’
[10:32:50.264]   - Field: ‘version’
[10:32:50.264]   - Field: ‘result’
[10:32:50.264]   - Field: ‘asynchronous’
[10:32:50.265]   - Field: ‘calls’
[10:32:50.265]   - Field: ‘globals’
[10:32:50.265]   - Field: ‘stdout’
[10:32:50.265]   - Field: ‘earlySignal’
[10:32:50.265]   - Field: ‘lazy’
[10:32:50.265]   - Field: ‘state’
[10:32:50.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.265] - Launch lazy future ...
[10:32:50.265] Packages needed by the future expression (n = 0): <none>
[10:32:50.265] Packages needed by future strategies (n = 0): <none>
[10:32:50.266] {
[10:32:50.266]     {
[10:32:50.266]         {
[10:32:50.266]             ...future.startTime <- base::Sys.time()
[10:32:50.266]             {
[10:32:50.266]                 {
[10:32:50.266]                   {
[10:32:50.266]                     base::local({
[10:32:50.266]                       has_future <- base::requireNamespace("future", 
[10:32:50.266]                         quietly = TRUE)
[10:32:50.266]                       if (has_future) {
[10:32:50.266]                         ns <- base::getNamespace("future")
[10:32:50.266]                         version <- ns[[".package"]][["version"]]
[10:32:50.266]                         if (is.null(version)) 
[10:32:50.266]                           version <- utils::packageVersion("future")
[10:32:50.266]                       }
[10:32:50.266]                       else {
[10:32:50.266]                         version <- NULL
[10:32:50.266]                       }
[10:32:50.266]                       if (!has_future || version < "1.8.0") {
[10:32:50.266]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.266]                           "", base::R.version$version.string), 
[10:32:50.266]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.266]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.266]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.266]                             "release", "version")], collapse = " "), 
[10:32:50.266]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.266]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.266]                           info)
[10:32:50.266]                         info <- base::paste(info, collapse = "; ")
[10:32:50.266]                         if (!has_future) {
[10:32:50.266]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.266]                             info)
[10:32:50.266]                         }
[10:32:50.266]                         else {
[10:32:50.266]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.266]                             info, version)
[10:32:50.266]                         }
[10:32:50.266]                         base::stop(msg)
[10:32:50.266]                       }
[10:32:50.266]                     })
[10:32:50.266]                   }
[10:32:50.266]                   ...future.strategy.old <- future::plan("list")
[10:32:50.266]                   options(future.plan = NULL)
[10:32:50.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.266]                 }
[10:32:50.266]                 ...future.workdir <- getwd()
[10:32:50.266]             }
[10:32:50.266]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.266]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.266]         }
[10:32:50.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.266]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.266]             base::names(...future.oldOptions))
[10:32:50.266]     }
[10:32:50.266]     if (FALSE) {
[10:32:50.266]     }
[10:32:50.266]     else {
[10:32:50.266]         if (TRUE) {
[10:32:50.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.266]                 open = "w")
[10:32:50.266]         }
[10:32:50.266]         else {
[10:32:50.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.266]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.266]         }
[10:32:50.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.266]             base::sink(type = "output", split = FALSE)
[10:32:50.266]             base::close(...future.stdout)
[10:32:50.266]         }, add = TRUE)
[10:32:50.266]     }
[10:32:50.266]     ...future.frame <- base::sys.nframe()
[10:32:50.266]     ...future.conditions <- base::list()
[10:32:50.266]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.266]     if (FALSE) {
[10:32:50.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.266]     }
[10:32:50.266]     ...future.result <- base::tryCatch({
[10:32:50.266]         base::withCallingHandlers({
[10:32:50.266]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.266]             future::FutureResult(value = ...future.value$value, 
[10:32:50.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.266]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.266]                     ...future.globalenv.names))
[10:32:50.266]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.266]         }, condition = base::local({
[10:32:50.266]             c <- base::c
[10:32:50.266]             inherits <- base::inherits
[10:32:50.266]             invokeRestart <- base::invokeRestart
[10:32:50.266]             length <- base::length
[10:32:50.266]             list <- base::list
[10:32:50.266]             seq.int <- base::seq.int
[10:32:50.266]             signalCondition <- base::signalCondition
[10:32:50.266]             sys.calls <- base::sys.calls
[10:32:50.266]             `[[` <- base::`[[`
[10:32:50.266]             `+` <- base::`+`
[10:32:50.266]             `<<-` <- base::`<<-`
[10:32:50.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.266]                   3L)]
[10:32:50.266]             }
[10:32:50.266]             function(cond) {
[10:32:50.266]                 is_error <- inherits(cond, "error")
[10:32:50.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.266]                   NULL)
[10:32:50.266]                 if (is_error) {
[10:32:50.266]                   sessionInformation <- function() {
[10:32:50.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.266]                       search = base::search(), system = base::Sys.info())
[10:32:50.266]                   }
[10:32:50.266]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.266]                     cond$call), session = sessionInformation(), 
[10:32:50.266]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.266]                   signalCondition(cond)
[10:32:50.266]                 }
[10:32:50.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.266]                 "immediateCondition"))) {
[10:32:50.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.266]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.266]                   if (TRUE && !signal) {
[10:32:50.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.266]                     {
[10:32:50.266]                       inherits <- base::inherits
[10:32:50.266]                       invokeRestart <- base::invokeRestart
[10:32:50.266]                       is.null <- base::is.null
[10:32:50.266]                       muffled <- FALSE
[10:32:50.266]                       if (inherits(cond, "message")) {
[10:32:50.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.266]                         if (muffled) 
[10:32:50.266]                           invokeRestart("muffleMessage")
[10:32:50.266]                       }
[10:32:50.266]                       else if (inherits(cond, "warning")) {
[10:32:50.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.266]                         if (muffled) 
[10:32:50.266]                           invokeRestart("muffleWarning")
[10:32:50.266]                       }
[10:32:50.266]                       else if (inherits(cond, "condition")) {
[10:32:50.266]                         if (!is.null(pattern)) {
[10:32:50.266]                           computeRestarts <- base::computeRestarts
[10:32:50.266]                           grepl <- base::grepl
[10:32:50.266]                           restarts <- computeRestarts(cond)
[10:32:50.266]                           for (restart in restarts) {
[10:32:50.266]                             name <- restart$name
[10:32:50.266]                             if (is.null(name)) 
[10:32:50.266]                               next
[10:32:50.266]                             if (!grepl(pattern, name)) 
[10:32:50.266]                               next
[10:32:50.266]                             invokeRestart(restart)
[10:32:50.266]                             muffled <- TRUE
[10:32:50.266]                             break
[10:32:50.266]                           }
[10:32:50.266]                         }
[10:32:50.266]                       }
[10:32:50.266]                       invisible(muffled)
[10:32:50.266]                     }
[10:32:50.266]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.266]                   }
[10:32:50.266]                 }
[10:32:50.266]                 else {
[10:32:50.266]                   if (TRUE) {
[10:32:50.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.266]                     {
[10:32:50.266]                       inherits <- base::inherits
[10:32:50.266]                       invokeRestart <- base::invokeRestart
[10:32:50.266]                       is.null <- base::is.null
[10:32:50.266]                       muffled <- FALSE
[10:32:50.266]                       if (inherits(cond, "message")) {
[10:32:50.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.266]                         if (muffled) 
[10:32:50.266]                           invokeRestart("muffleMessage")
[10:32:50.266]                       }
[10:32:50.266]                       else if (inherits(cond, "warning")) {
[10:32:50.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.266]                         if (muffled) 
[10:32:50.266]                           invokeRestart("muffleWarning")
[10:32:50.266]                       }
[10:32:50.266]                       else if (inherits(cond, "condition")) {
[10:32:50.266]                         if (!is.null(pattern)) {
[10:32:50.266]                           computeRestarts <- base::computeRestarts
[10:32:50.266]                           grepl <- base::grepl
[10:32:50.266]                           restarts <- computeRestarts(cond)
[10:32:50.266]                           for (restart in restarts) {
[10:32:50.266]                             name <- restart$name
[10:32:50.266]                             if (is.null(name)) 
[10:32:50.266]                               next
[10:32:50.266]                             if (!grepl(pattern, name)) 
[10:32:50.266]                               next
[10:32:50.266]                             invokeRestart(restart)
[10:32:50.266]                             muffled <- TRUE
[10:32:50.266]                             break
[10:32:50.266]                           }
[10:32:50.266]                         }
[10:32:50.266]                       }
[10:32:50.266]                       invisible(muffled)
[10:32:50.266]                     }
[10:32:50.266]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.266]                   }
[10:32:50.266]                 }
[10:32:50.266]             }
[10:32:50.266]         }))
[10:32:50.266]     }, error = function(ex) {
[10:32:50.266]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.266]                 ...future.rng), started = ...future.startTime, 
[10:32:50.266]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.266]             version = "1.8"), class = "FutureResult")
[10:32:50.266]     }, finally = {
[10:32:50.266]         if (!identical(...future.workdir, getwd())) 
[10:32:50.266]             setwd(...future.workdir)
[10:32:50.266]         {
[10:32:50.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.266]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.266]             }
[10:32:50.266]             base::options(...future.oldOptions)
[10:32:50.266]             if (.Platform$OS.type == "windows") {
[10:32:50.266]                 old_names <- names(...future.oldEnvVars)
[10:32:50.266]                 envs <- base::Sys.getenv()
[10:32:50.266]                 names <- names(envs)
[10:32:50.266]                 common <- intersect(names, old_names)
[10:32:50.266]                 added <- setdiff(names, old_names)
[10:32:50.266]                 removed <- setdiff(old_names, names)
[10:32:50.266]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.266]                   envs[common]]
[10:32:50.266]                 NAMES <- toupper(changed)
[10:32:50.266]                 args <- list()
[10:32:50.266]                 for (kk in seq_along(NAMES)) {
[10:32:50.266]                   name <- changed[[kk]]
[10:32:50.266]                   NAME <- NAMES[[kk]]
[10:32:50.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.266]                     next
[10:32:50.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.266]                 }
[10:32:50.266]                 NAMES <- toupper(added)
[10:32:50.266]                 for (kk in seq_along(NAMES)) {
[10:32:50.266]                   name <- added[[kk]]
[10:32:50.266]                   NAME <- NAMES[[kk]]
[10:32:50.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.266]                     next
[10:32:50.266]                   args[[name]] <- ""
[10:32:50.266]                 }
[10:32:50.266]                 NAMES <- toupper(removed)
[10:32:50.266]                 for (kk in seq_along(NAMES)) {
[10:32:50.266]                   name <- removed[[kk]]
[10:32:50.266]                   NAME <- NAMES[[kk]]
[10:32:50.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.266]                     next
[10:32:50.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.266]                 }
[10:32:50.266]                 if (length(args) > 0) 
[10:32:50.266]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.266]             }
[10:32:50.266]             else {
[10:32:50.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.266]             }
[10:32:50.266]             {
[10:32:50.266]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.266]                   0L) {
[10:32:50.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.266]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.266]                   base::options(opts)
[10:32:50.266]                 }
[10:32:50.266]                 {
[10:32:50.266]                   {
[10:32:50.266]                     NULL
[10:32:50.266]                     RNGkind("Mersenne-Twister")
[10:32:50.266]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.266]                       inherits = FALSE)
[10:32:50.266]                   }
[10:32:50.266]                   options(future.plan = NULL)
[10:32:50.266]                   if (is.na(NA_character_)) 
[10:32:50.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.266]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.266]                     .init = FALSE)
[10:32:50.266]                 }
[10:32:50.266]             }
[10:32:50.266]         }
[10:32:50.266]     })
[10:32:50.266]     if (TRUE) {
[10:32:50.266]         base::sink(type = "output", split = FALSE)
[10:32:50.266]         if (TRUE) {
[10:32:50.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.266]         }
[10:32:50.266]         else {
[10:32:50.266]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.266]         }
[10:32:50.266]         base::close(...future.stdout)
[10:32:50.266]         ...future.stdout <- NULL
[10:32:50.266]     }
[10:32:50.266]     ...future.result$conditions <- ...future.conditions
[10:32:50.266]     ...future.result$finished <- base::Sys.time()
[10:32:50.266]     ...future.result
[10:32:50.266] }
[10:32:50.267] plan(): Setting new future strategy stack:
[10:32:50.268] List of future strategies:
[10:32:50.268] 1. sequential:
[10:32:50.268]    - args: function (..., envir = parent.frame())
[10:32:50.268]    - tweaked: FALSE
[10:32:50.268]    - call: NULL
[10:32:50.268] plan(): nbrOfWorkers() = 1
[10:32:50.269] plan(): Setting new future strategy stack:
[10:32:50.269] List of future strategies:
[10:32:50.269] 1. sequential:
[10:32:50.269]    - args: function (..., envir = parent.frame())
[10:32:50.269]    - tweaked: FALSE
[10:32:50.269]    - call: plan(strategy)
[10:32:50.269] plan(): nbrOfWorkers() = 1
[10:32:50.269] SequentialFuture started (and completed)
[10:32:50.269] - Launch lazy future ... done
[10:32:50.270] run() for ‘SequentialFuture’ ... done
[10:32:50.270] getGlobalsAndPackages() ...
[10:32:50.270] Searching for globals...
[10:32:50.270] - globals found: [1] ‘{’
[10:32:50.271] Searching for globals ... DONE
[10:32:50.271] Resolving globals: FALSE
[10:32:50.271] 
[10:32:50.271] 
[10:32:50.271] getGlobalsAndPackages() ... DONE
[10:32:50.271] run() for ‘Future’ ...
[10:32:50.271] - state: ‘created’
[10:32:50.271] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.272] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.272]   - Field: ‘label’
[10:32:50.272]   - Field: ‘local’
[10:32:50.272]   - Field: ‘owner’
[10:32:50.272]   - Field: ‘envir’
[10:32:50.272]   - Field: ‘packages’
[10:32:50.272]   - Field: ‘gc’
[10:32:50.272]   - Field: ‘conditions’
[10:32:50.273]   - Field: ‘expr’
[10:32:50.273]   - Field: ‘uuid’
[10:32:50.273]   - Field: ‘seed’
[10:32:50.273]   - Field: ‘version’
[10:32:50.273]   - Field: ‘result’
[10:32:50.273]   - Field: ‘asynchronous’
[10:32:50.273]   - Field: ‘calls’
[10:32:50.273]   - Field: ‘globals’
[10:32:50.273]   - Field: ‘stdout’
[10:32:50.273]   - Field: ‘earlySignal’
[10:32:50.273]   - Field: ‘lazy’
[10:32:50.274]   - Field: ‘state’
[10:32:50.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.274] - Launch lazy future ...
[10:32:50.274] Packages needed by the future expression (n = 0): <none>
[10:32:50.274] Packages needed by future strategies (n = 0): <none>
[10:32:50.274] {
[10:32:50.274]     {
[10:32:50.274]         {
[10:32:50.274]             ...future.startTime <- base::Sys.time()
[10:32:50.274]             {
[10:32:50.274]                 {
[10:32:50.274]                   {
[10:32:50.274]                     base::local({
[10:32:50.274]                       has_future <- base::requireNamespace("future", 
[10:32:50.274]                         quietly = TRUE)
[10:32:50.274]                       if (has_future) {
[10:32:50.274]                         ns <- base::getNamespace("future")
[10:32:50.274]                         version <- ns[[".package"]][["version"]]
[10:32:50.274]                         if (is.null(version)) 
[10:32:50.274]                           version <- utils::packageVersion("future")
[10:32:50.274]                       }
[10:32:50.274]                       else {
[10:32:50.274]                         version <- NULL
[10:32:50.274]                       }
[10:32:50.274]                       if (!has_future || version < "1.8.0") {
[10:32:50.274]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.274]                           "", base::R.version$version.string), 
[10:32:50.274]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.274]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.274]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.274]                             "release", "version")], collapse = " "), 
[10:32:50.274]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.274]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.274]                           info)
[10:32:50.274]                         info <- base::paste(info, collapse = "; ")
[10:32:50.274]                         if (!has_future) {
[10:32:50.274]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.274]                             info)
[10:32:50.274]                         }
[10:32:50.274]                         else {
[10:32:50.274]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.274]                             info, version)
[10:32:50.274]                         }
[10:32:50.274]                         base::stop(msg)
[10:32:50.274]                       }
[10:32:50.274]                     })
[10:32:50.274]                   }
[10:32:50.274]                   ...future.strategy.old <- future::plan("list")
[10:32:50.274]                   options(future.plan = NULL)
[10:32:50.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.274]                 }
[10:32:50.274]                 ...future.workdir <- getwd()
[10:32:50.274]             }
[10:32:50.274]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.274]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.274]         }
[10:32:50.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.274]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.274]             base::names(...future.oldOptions))
[10:32:50.274]     }
[10:32:50.274]     if (FALSE) {
[10:32:50.274]     }
[10:32:50.274]     else {
[10:32:50.274]         if (TRUE) {
[10:32:50.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.274]                 open = "w")
[10:32:50.274]         }
[10:32:50.274]         else {
[10:32:50.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.274]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.274]         }
[10:32:50.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.274]             base::sink(type = "output", split = FALSE)
[10:32:50.274]             base::close(...future.stdout)
[10:32:50.274]         }, add = TRUE)
[10:32:50.274]     }
[10:32:50.274]     ...future.frame <- base::sys.nframe()
[10:32:50.274]     ...future.conditions <- base::list()
[10:32:50.274]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.274]     if (FALSE) {
[10:32:50.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.274]     }
[10:32:50.274]     ...future.result <- base::tryCatch({
[10:32:50.274]         base::withCallingHandlers({
[10:32:50.274]             ...future.value <- base::withVisible(base::local({
[10:32:50.274]                 4
[10:32:50.274]             }))
[10:32:50.274]             future::FutureResult(value = ...future.value$value, 
[10:32:50.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.274]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.274]                     ...future.globalenv.names))
[10:32:50.274]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.274]         }, condition = base::local({
[10:32:50.274]             c <- base::c
[10:32:50.274]             inherits <- base::inherits
[10:32:50.274]             invokeRestart <- base::invokeRestart
[10:32:50.274]             length <- base::length
[10:32:50.274]             list <- base::list
[10:32:50.274]             seq.int <- base::seq.int
[10:32:50.274]             signalCondition <- base::signalCondition
[10:32:50.274]             sys.calls <- base::sys.calls
[10:32:50.274]             `[[` <- base::`[[`
[10:32:50.274]             `+` <- base::`+`
[10:32:50.274]             `<<-` <- base::`<<-`
[10:32:50.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.274]                   3L)]
[10:32:50.274]             }
[10:32:50.274]             function(cond) {
[10:32:50.274]                 is_error <- inherits(cond, "error")
[10:32:50.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.274]                   NULL)
[10:32:50.274]                 if (is_error) {
[10:32:50.274]                   sessionInformation <- function() {
[10:32:50.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.274]                       search = base::search(), system = base::Sys.info())
[10:32:50.274]                   }
[10:32:50.274]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.274]                     cond$call), session = sessionInformation(), 
[10:32:50.274]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.274]                   signalCondition(cond)
[10:32:50.274]                 }
[10:32:50.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.274]                 "immediateCondition"))) {
[10:32:50.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.274]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.274]                   if (TRUE && !signal) {
[10:32:50.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.274]                     {
[10:32:50.274]                       inherits <- base::inherits
[10:32:50.274]                       invokeRestart <- base::invokeRestart
[10:32:50.274]                       is.null <- base::is.null
[10:32:50.274]                       muffled <- FALSE
[10:32:50.274]                       if (inherits(cond, "message")) {
[10:32:50.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.274]                         if (muffled) 
[10:32:50.274]                           invokeRestart("muffleMessage")
[10:32:50.274]                       }
[10:32:50.274]                       else if (inherits(cond, "warning")) {
[10:32:50.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.274]                         if (muffled) 
[10:32:50.274]                           invokeRestart("muffleWarning")
[10:32:50.274]                       }
[10:32:50.274]                       else if (inherits(cond, "condition")) {
[10:32:50.274]                         if (!is.null(pattern)) {
[10:32:50.274]                           computeRestarts <- base::computeRestarts
[10:32:50.274]                           grepl <- base::grepl
[10:32:50.274]                           restarts <- computeRestarts(cond)
[10:32:50.274]                           for (restart in restarts) {
[10:32:50.274]                             name <- restart$name
[10:32:50.274]                             if (is.null(name)) 
[10:32:50.274]                               next
[10:32:50.274]                             if (!grepl(pattern, name)) 
[10:32:50.274]                               next
[10:32:50.274]                             invokeRestart(restart)
[10:32:50.274]                             muffled <- TRUE
[10:32:50.274]                             break
[10:32:50.274]                           }
[10:32:50.274]                         }
[10:32:50.274]                       }
[10:32:50.274]                       invisible(muffled)
[10:32:50.274]                     }
[10:32:50.274]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.274]                   }
[10:32:50.274]                 }
[10:32:50.274]                 else {
[10:32:50.274]                   if (TRUE) {
[10:32:50.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.274]                     {
[10:32:50.274]                       inherits <- base::inherits
[10:32:50.274]                       invokeRestart <- base::invokeRestart
[10:32:50.274]                       is.null <- base::is.null
[10:32:50.274]                       muffled <- FALSE
[10:32:50.274]                       if (inherits(cond, "message")) {
[10:32:50.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.274]                         if (muffled) 
[10:32:50.274]                           invokeRestart("muffleMessage")
[10:32:50.274]                       }
[10:32:50.274]                       else if (inherits(cond, "warning")) {
[10:32:50.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.274]                         if (muffled) 
[10:32:50.274]                           invokeRestart("muffleWarning")
[10:32:50.274]                       }
[10:32:50.274]                       else if (inherits(cond, "condition")) {
[10:32:50.274]                         if (!is.null(pattern)) {
[10:32:50.274]                           computeRestarts <- base::computeRestarts
[10:32:50.274]                           grepl <- base::grepl
[10:32:50.274]                           restarts <- computeRestarts(cond)
[10:32:50.274]                           for (restart in restarts) {
[10:32:50.274]                             name <- restart$name
[10:32:50.274]                             if (is.null(name)) 
[10:32:50.274]                               next
[10:32:50.274]                             if (!grepl(pattern, name)) 
[10:32:50.274]                               next
[10:32:50.274]                             invokeRestart(restart)
[10:32:50.274]                             muffled <- TRUE
[10:32:50.274]                             break
[10:32:50.274]                           }
[10:32:50.274]                         }
[10:32:50.274]                       }
[10:32:50.274]                       invisible(muffled)
[10:32:50.274]                     }
[10:32:50.274]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.274]                   }
[10:32:50.274]                 }
[10:32:50.274]             }
[10:32:50.274]         }))
[10:32:50.274]     }, error = function(ex) {
[10:32:50.274]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.274]                 ...future.rng), started = ...future.startTime, 
[10:32:50.274]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.274]             version = "1.8"), class = "FutureResult")
[10:32:50.274]     }, finally = {
[10:32:50.274]         if (!identical(...future.workdir, getwd())) 
[10:32:50.274]             setwd(...future.workdir)
[10:32:50.274]         {
[10:32:50.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.274]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.274]             }
[10:32:50.274]             base::options(...future.oldOptions)
[10:32:50.274]             if (.Platform$OS.type == "windows") {
[10:32:50.274]                 old_names <- names(...future.oldEnvVars)
[10:32:50.274]                 envs <- base::Sys.getenv()
[10:32:50.274]                 names <- names(envs)
[10:32:50.274]                 common <- intersect(names, old_names)
[10:32:50.274]                 added <- setdiff(names, old_names)
[10:32:50.274]                 removed <- setdiff(old_names, names)
[10:32:50.274]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.274]                   envs[common]]
[10:32:50.274]                 NAMES <- toupper(changed)
[10:32:50.274]                 args <- list()
[10:32:50.274]                 for (kk in seq_along(NAMES)) {
[10:32:50.274]                   name <- changed[[kk]]
[10:32:50.274]                   NAME <- NAMES[[kk]]
[10:32:50.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.274]                     next
[10:32:50.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.274]                 }
[10:32:50.274]                 NAMES <- toupper(added)
[10:32:50.274]                 for (kk in seq_along(NAMES)) {
[10:32:50.274]                   name <- added[[kk]]
[10:32:50.274]                   NAME <- NAMES[[kk]]
[10:32:50.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.274]                     next
[10:32:50.274]                   args[[name]] <- ""
[10:32:50.274]                 }
[10:32:50.274]                 NAMES <- toupper(removed)
[10:32:50.274]                 for (kk in seq_along(NAMES)) {
[10:32:50.274]                   name <- removed[[kk]]
[10:32:50.274]                   NAME <- NAMES[[kk]]
[10:32:50.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.274]                     next
[10:32:50.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.274]                 }
[10:32:50.274]                 if (length(args) > 0) 
[10:32:50.274]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.274]             }
[10:32:50.274]             else {
[10:32:50.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.274]             }
[10:32:50.274]             {
[10:32:50.274]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.274]                   0L) {
[10:32:50.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.274]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.274]                   base::options(opts)
[10:32:50.274]                 }
[10:32:50.274]                 {
[10:32:50.274]                   {
[10:32:50.274]                     NULL
[10:32:50.274]                     RNGkind("Mersenne-Twister")
[10:32:50.274]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.274]                       inherits = FALSE)
[10:32:50.274]                   }
[10:32:50.274]                   options(future.plan = NULL)
[10:32:50.274]                   if (is.na(NA_character_)) 
[10:32:50.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.274]                     .init = FALSE)
[10:32:50.274]                 }
[10:32:50.274]             }
[10:32:50.274]         }
[10:32:50.274]     })
[10:32:50.274]     if (TRUE) {
[10:32:50.274]         base::sink(type = "output", split = FALSE)
[10:32:50.274]         if (TRUE) {
[10:32:50.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.274]         }
[10:32:50.274]         else {
[10:32:50.274]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.274]         }
[10:32:50.274]         base::close(...future.stdout)
[10:32:50.274]         ...future.stdout <- NULL
[10:32:50.274]     }
[10:32:50.274]     ...future.result$conditions <- ...future.conditions
[10:32:50.274]     ...future.result$finished <- base::Sys.time()
[10:32:50.274]     ...future.result
[10:32:50.274] }
[10:32:50.276] plan(): Setting new future strategy stack:
[10:32:50.276] List of future strategies:
[10:32:50.276] 1. sequential:
[10:32:50.276]    - args: function (..., envir = parent.frame())
[10:32:50.276]    - tweaked: FALSE
[10:32:50.276]    - call: NULL
[10:32:50.276] plan(): nbrOfWorkers() = 1
[10:32:50.278] plan(): Setting new future strategy stack:
[10:32:50.279] List of future strategies:
[10:32:50.279] 1. sequential:
[10:32:50.279]    - args: function (..., envir = parent.frame())
[10:32:50.279]    - tweaked: FALSE
[10:32:50.279]    - call: plan(strategy)
[10:32:50.279] plan(): nbrOfWorkers() = 1
[10:32:50.279] SequentialFuture started (and completed)
[10:32:50.279] - Launch lazy future ... done
[10:32:50.279] run() for ‘SequentialFuture’ ... done
<environment: 0x5652d042a528> 
<environment: 0x5652cf855c80> 
[10:32:50.280] resolved() for ‘SequentialFuture’ ...
[10:32:50.281] - state: ‘finished’
[10:32:50.281] - run: TRUE
[10:32:50.281] - result: ‘FutureResult’
[10:32:50.281] resolved() for ‘SequentialFuture’ ... done
[10:32:50.281] resolved() for ‘SequentialFuture’ ...
[10:32:50.281] - state: ‘finished’
[10:32:50.281] - run: TRUE
[10:32:50.281] - result: ‘FutureResult’
[10:32:50.281] resolved() for ‘SequentialFuture’ ... done
[10:32:50.281] resolved() for ‘SequentialFuture’ ...
[10:32:50.281] - state: ‘finished’
[10:32:50.282] - run: TRUE
[10:32:50.282] - result: ‘FutureResult’
[10:32:50.282] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:50.283] resolve() on environment ...
[10:32:50.283]  recursive: 0
[10:32:50.283]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:50.283] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.284] - nx: 4
[10:32:50.284] - relay: TRUE
[10:32:50.284] - stdout: TRUE
[10:32:50.284] - signal: TRUE
[10:32:50.284] - resignal: FALSE
[10:32:50.284] - force: TRUE
[10:32:50.284] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.284] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.284]  - until=2
[10:32:50.284]  - relaying element #2
[10:32:50.284] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.284] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.285] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.285]  length: 3 (resolved future 1)
[10:32:50.285] resolved() for ‘SequentialFuture’ ...
[10:32:50.285] - state: ‘finished’
[10:32:50.285] - run: TRUE
[10:32:50.285] - result: ‘FutureResult’
[10:32:50.285] resolved() for ‘SequentialFuture’ ... done
[10:32:50.285] Future #2
[10:32:50.285] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.285] - nx: 4
[10:32:50.286] - relay: TRUE
[10:32:50.286] - stdout: TRUE
[10:32:50.286] - signal: TRUE
[10:32:50.286] - resignal: FALSE
[10:32:50.286] - force: TRUE
[10:32:50.286] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.286] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.286]  - until=2
[10:32:50.286]  - relaying element #2
[10:32:50.286] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.286] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.287] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.287]  length: 2 (resolved future 2)
[10:32:50.287] resolved() for ‘SequentialFuture’ ...
[10:32:50.287] - state: ‘finished’
[10:32:50.287] - run: TRUE
[10:32:50.287] - result: ‘FutureResult’
[10:32:50.287] resolved() for ‘SequentialFuture’ ... done
[10:32:50.287] Future #3
[10:32:50.287] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.287] - nx: 4
[10:32:50.287] - relay: TRUE
[10:32:50.288] - stdout: TRUE
[10:32:50.288] - signal: TRUE
[10:32:50.288] - resignal: FALSE
[10:32:50.288] - force: TRUE
[10:32:50.288] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.288] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.288]  - until=3
[10:32:50.288]  - relaying element #3
[10:32:50.288] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.288] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.288] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.289]  length: 1 (resolved future 3)
[10:32:50.289] resolved() for ‘SequentialFuture’ ...
[10:32:50.289] - state: ‘finished’
[10:32:50.289] - run: TRUE
[10:32:50.289] - result: ‘FutureResult’
[10:32:50.289] resolved() for ‘SequentialFuture’ ... done
[10:32:50.289] Future #4
[10:32:50.289] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.289] - nx: 4
[10:32:50.289] - relay: TRUE
[10:32:50.289] - stdout: TRUE
[10:32:50.290] - signal: TRUE
[10:32:50.290] - resignal: FALSE
[10:32:50.290] - force: TRUE
[10:32:50.290] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.290] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.290]  - until=4
[10:32:50.290]  - relaying element #4
[10:32:50.290] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.290] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.290] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.290]  length: 0 (resolved future 4)
[10:32:50.291] Relaying remaining futures
[10:32:50.291] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.291] - nx: 4
[10:32:50.291] - relay: TRUE
[10:32:50.291] - stdout: TRUE
[10:32:50.291] - signal: TRUE
[10:32:50.291] - resignal: FALSE
[10:32:50.291] - force: TRUE
[10:32:50.291] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.291] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:50.291] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.291] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.292] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.292] resolve() on environment ... DONE
<environment: 0x5652cf1ea080> 
Dimensions: c(2, 3, 1)
[10:32:50.292] getGlobalsAndPackages() ...
[10:32:50.292] Searching for globals...
[10:32:50.292] 
[10:32:50.293] Searching for globals ... DONE
[10:32:50.293] - globals: [0] <none>
[10:32:50.293] getGlobalsAndPackages() ... DONE
[10:32:50.293] run() for ‘Future’ ...
[10:32:50.293] - state: ‘created’
[10:32:50.293] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.293] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.294]   - Field: ‘label’
[10:32:50.294]   - Field: ‘local’
[10:32:50.294]   - Field: ‘owner’
[10:32:50.294]   - Field: ‘envir’
[10:32:50.294]   - Field: ‘packages’
[10:32:50.294]   - Field: ‘gc’
[10:32:50.294]   - Field: ‘conditions’
[10:32:50.294]   - Field: ‘expr’
[10:32:50.294]   - Field: ‘uuid’
[10:32:50.294]   - Field: ‘seed’
[10:32:50.294]   - Field: ‘version’
[10:32:50.295]   - Field: ‘result’
[10:32:50.295]   - Field: ‘asynchronous’
[10:32:50.295]   - Field: ‘calls’
[10:32:50.295]   - Field: ‘globals’
[10:32:50.295]   - Field: ‘stdout’
[10:32:50.295]   - Field: ‘earlySignal’
[10:32:50.295]   - Field: ‘lazy’
[10:32:50.295]   - Field: ‘state’
[10:32:50.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.295] - Launch lazy future ...
[10:32:50.296] Packages needed by the future expression (n = 0): <none>
[10:32:50.296] Packages needed by future strategies (n = 0): <none>
[10:32:50.296] {
[10:32:50.296]     {
[10:32:50.296]         {
[10:32:50.296]             ...future.startTime <- base::Sys.time()
[10:32:50.296]             {
[10:32:50.296]                 {
[10:32:50.296]                   {
[10:32:50.296]                     base::local({
[10:32:50.296]                       has_future <- base::requireNamespace("future", 
[10:32:50.296]                         quietly = TRUE)
[10:32:50.296]                       if (has_future) {
[10:32:50.296]                         ns <- base::getNamespace("future")
[10:32:50.296]                         version <- ns[[".package"]][["version"]]
[10:32:50.296]                         if (is.null(version)) 
[10:32:50.296]                           version <- utils::packageVersion("future")
[10:32:50.296]                       }
[10:32:50.296]                       else {
[10:32:50.296]                         version <- NULL
[10:32:50.296]                       }
[10:32:50.296]                       if (!has_future || version < "1.8.0") {
[10:32:50.296]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.296]                           "", base::R.version$version.string), 
[10:32:50.296]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.296]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.296]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.296]                             "release", "version")], collapse = " "), 
[10:32:50.296]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.296]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.296]                           info)
[10:32:50.296]                         info <- base::paste(info, collapse = "; ")
[10:32:50.296]                         if (!has_future) {
[10:32:50.296]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.296]                             info)
[10:32:50.296]                         }
[10:32:50.296]                         else {
[10:32:50.296]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.296]                             info, version)
[10:32:50.296]                         }
[10:32:50.296]                         base::stop(msg)
[10:32:50.296]                       }
[10:32:50.296]                     })
[10:32:50.296]                   }
[10:32:50.296]                   ...future.strategy.old <- future::plan("list")
[10:32:50.296]                   options(future.plan = NULL)
[10:32:50.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.296]                 }
[10:32:50.296]                 ...future.workdir <- getwd()
[10:32:50.296]             }
[10:32:50.296]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.296]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.296]         }
[10:32:50.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.296]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.296]             base::names(...future.oldOptions))
[10:32:50.296]     }
[10:32:50.296]     if (FALSE) {
[10:32:50.296]     }
[10:32:50.296]     else {
[10:32:50.296]         if (TRUE) {
[10:32:50.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.296]                 open = "w")
[10:32:50.296]         }
[10:32:50.296]         else {
[10:32:50.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.296]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.296]         }
[10:32:50.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.296]             base::sink(type = "output", split = FALSE)
[10:32:50.296]             base::close(...future.stdout)
[10:32:50.296]         }, add = TRUE)
[10:32:50.296]     }
[10:32:50.296]     ...future.frame <- base::sys.nframe()
[10:32:50.296]     ...future.conditions <- base::list()
[10:32:50.296]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.296]     if (FALSE) {
[10:32:50.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.296]     }
[10:32:50.296]     ...future.result <- base::tryCatch({
[10:32:50.296]         base::withCallingHandlers({
[10:32:50.296]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.296]             future::FutureResult(value = ...future.value$value, 
[10:32:50.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.296]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.296]                     ...future.globalenv.names))
[10:32:50.296]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.296]         }, condition = base::local({
[10:32:50.296]             c <- base::c
[10:32:50.296]             inherits <- base::inherits
[10:32:50.296]             invokeRestart <- base::invokeRestart
[10:32:50.296]             length <- base::length
[10:32:50.296]             list <- base::list
[10:32:50.296]             seq.int <- base::seq.int
[10:32:50.296]             signalCondition <- base::signalCondition
[10:32:50.296]             sys.calls <- base::sys.calls
[10:32:50.296]             `[[` <- base::`[[`
[10:32:50.296]             `+` <- base::`+`
[10:32:50.296]             `<<-` <- base::`<<-`
[10:32:50.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.296]                   3L)]
[10:32:50.296]             }
[10:32:50.296]             function(cond) {
[10:32:50.296]                 is_error <- inherits(cond, "error")
[10:32:50.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.296]                   NULL)
[10:32:50.296]                 if (is_error) {
[10:32:50.296]                   sessionInformation <- function() {
[10:32:50.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.296]                       search = base::search(), system = base::Sys.info())
[10:32:50.296]                   }
[10:32:50.296]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.296]                     cond$call), session = sessionInformation(), 
[10:32:50.296]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.296]                   signalCondition(cond)
[10:32:50.296]                 }
[10:32:50.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.296]                 "immediateCondition"))) {
[10:32:50.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.296]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.296]                   if (TRUE && !signal) {
[10:32:50.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.296]                     {
[10:32:50.296]                       inherits <- base::inherits
[10:32:50.296]                       invokeRestart <- base::invokeRestart
[10:32:50.296]                       is.null <- base::is.null
[10:32:50.296]                       muffled <- FALSE
[10:32:50.296]                       if (inherits(cond, "message")) {
[10:32:50.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.296]                         if (muffled) 
[10:32:50.296]                           invokeRestart("muffleMessage")
[10:32:50.296]                       }
[10:32:50.296]                       else if (inherits(cond, "warning")) {
[10:32:50.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.296]                         if (muffled) 
[10:32:50.296]                           invokeRestart("muffleWarning")
[10:32:50.296]                       }
[10:32:50.296]                       else if (inherits(cond, "condition")) {
[10:32:50.296]                         if (!is.null(pattern)) {
[10:32:50.296]                           computeRestarts <- base::computeRestarts
[10:32:50.296]                           grepl <- base::grepl
[10:32:50.296]                           restarts <- computeRestarts(cond)
[10:32:50.296]                           for (restart in restarts) {
[10:32:50.296]                             name <- restart$name
[10:32:50.296]                             if (is.null(name)) 
[10:32:50.296]                               next
[10:32:50.296]                             if (!grepl(pattern, name)) 
[10:32:50.296]                               next
[10:32:50.296]                             invokeRestart(restart)
[10:32:50.296]                             muffled <- TRUE
[10:32:50.296]                             break
[10:32:50.296]                           }
[10:32:50.296]                         }
[10:32:50.296]                       }
[10:32:50.296]                       invisible(muffled)
[10:32:50.296]                     }
[10:32:50.296]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.296]                   }
[10:32:50.296]                 }
[10:32:50.296]                 else {
[10:32:50.296]                   if (TRUE) {
[10:32:50.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.296]                     {
[10:32:50.296]                       inherits <- base::inherits
[10:32:50.296]                       invokeRestart <- base::invokeRestart
[10:32:50.296]                       is.null <- base::is.null
[10:32:50.296]                       muffled <- FALSE
[10:32:50.296]                       if (inherits(cond, "message")) {
[10:32:50.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.296]                         if (muffled) 
[10:32:50.296]                           invokeRestart("muffleMessage")
[10:32:50.296]                       }
[10:32:50.296]                       else if (inherits(cond, "warning")) {
[10:32:50.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.296]                         if (muffled) 
[10:32:50.296]                           invokeRestart("muffleWarning")
[10:32:50.296]                       }
[10:32:50.296]                       else if (inherits(cond, "condition")) {
[10:32:50.296]                         if (!is.null(pattern)) {
[10:32:50.296]                           computeRestarts <- base::computeRestarts
[10:32:50.296]                           grepl <- base::grepl
[10:32:50.296]                           restarts <- computeRestarts(cond)
[10:32:50.296]                           for (restart in restarts) {
[10:32:50.296]                             name <- restart$name
[10:32:50.296]                             if (is.null(name)) 
[10:32:50.296]                               next
[10:32:50.296]                             if (!grepl(pattern, name)) 
[10:32:50.296]                               next
[10:32:50.296]                             invokeRestart(restart)
[10:32:50.296]                             muffled <- TRUE
[10:32:50.296]                             break
[10:32:50.296]                           }
[10:32:50.296]                         }
[10:32:50.296]                       }
[10:32:50.296]                       invisible(muffled)
[10:32:50.296]                     }
[10:32:50.296]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.296]                   }
[10:32:50.296]                 }
[10:32:50.296]             }
[10:32:50.296]         }))
[10:32:50.296]     }, error = function(ex) {
[10:32:50.296]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.296]                 ...future.rng), started = ...future.startTime, 
[10:32:50.296]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.296]             version = "1.8"), class = "FutureResult")
[10:32:50.296]     }, finally = {
[10:32:50.296]         if (!identical(...future.workdir, getwd())) 
[10:32:50.296]             setwd(...future.workdir)
[10:32:50.296]         {
[10:32:50.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.296]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.296]             }
[10:32:50.296]             base::options(...future.oldOptions)
[10:32:50.296]             if (.Platform$OS.type == "windows") {
[10:32:50.296]                 old_names <- names(...future.oldEnvVars)
[10:32:50.296]                 envs <- base::Sys.getenv()
[10:32:50.296]                 names <- names(envs)
[10:32:50.296]                 common <- intersect(names, old_names)
[10:32:50.296]                 added <- setdiff(names, old_names)
[10:32:50.296]                 removed <- setdiff(old_names, names)
[10:32:50.296]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.296]                   envs[common]]
[10:32:50.296]                 NAMES <- toupper(changed)
[10:32:50.296]                 args <- list()
[10:32:50.296]                 for (kk in seq_along(NAMES)) {
[10:32:50.296]                   name <- changed[[kk]]
[10:32:50.296]                   NAME <- NAMES[[kk]]
[10:32:50.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.296]                     next
[10:32:50.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.296]                 }
[10:32:50.296]                 NAMES <- toupper(added)
[10:32:50.296]                 for (kk in seq_along(NAMES)) {
[10:32:50.296]                   name <- added[[kk]]
[10:32:50.296]                   NAME <- NAMES[[kk]]
[10:32:50.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.296]                     next
[10:32:50.296]                   args[[name]] <- ""
[10:32:50.296]                 }
[10:32:50.296]                 NAMES <- toupper(removed)
[10:32:50.296]                 for (kk in seq_along(NAMES)) {
[10:32:50.296]                   name <- removed[[kk]]
[10:32:50.296]                   NAME <- NAMES[[kk]]
[10:32:50.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.296]                     next
[10:32:50.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.296]                 }
[10:32:50.296]                 if (length(args) > 0) 
[10:32:50.296]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.296]             }
[10:32:50.296]             else {
[10:32:50.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.296]             }
[10:32:50.296]             {
[10:32:50.296]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.296]                   0L) {
[10:32:50.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.296]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.296]                   base::options(opts)
[10:32:50.296]                 }
[10:32:50.296]                 {
[10:32:50.296]                   {
[10:32:50.296]                     NULL
[10:32:50.296]                     RNGkind("Mersenne-Twister")
[10:32:50.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.296]                       inherits = FALSE)
[10:32:50.296]                   }
[10:32:50.296]                   options(future.plan = NULL)
[10:32:50.296]                   if (is.na(NA_character_)) 
[10:32:50.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.296]                     .init = FALSE)
[10:32:50.296]                 }
[10:32:50.296]             }
[10:32:50.296]         }
[10:32:50.296]     })
[10:32:50.296]     if (TRUE) {
[10:32:50.296]         base::sink(type = "output", split = FALSE)
[10:32:50.296]         if (TRUE) {
[10:32:50.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.296]         }
[10:32:50.296]         else {
[10:32:50.296]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.296]         }
[10:32:50.296]         base::close(...future.stdout)
[10:32:50.296]         ...future.stdout <- NULL
[10:32:50.296]     }
[10:32:50.296]     ...future.result$conditions <- ...future.conditions
[10:32:50.296]     ...future.result$finished <- base::Sys.time()
[10:32:50.296]     ...future.result
[10:32:50.296] }
[10:32:50.298] plan(): Setting new future strategy stack:
[10:32:50.298] List of future strategies:
[10:32:50.298] 1. sequential:
[10:32:50.298]    - args: function (..., envir = parent.frame())
[10:32:50.298]    - tweaked: FALSE
[10:32:50.298]    - call: NULL
[10:32:50.298] plan(): nbrOfWorkers() = 1
[10:32:50.299] plan(): Setting new future strategy stack:
[10:32:50.299] List of future strategies:
[10:32:50.299] 1. sequential:
[10:32:50.299]    - args: function (..., envir = parent.frame())
[10:32:50.299]    - tweaked: FALSE
[10:32:50.299]    - call: plan(strategy)
[10:32:50.299] plan(): nbrOfWorkers() = 1
[10:32:50.299] SequentialFuture started (and completed)
[10:32:50.299] - Launch lazy future ... done
[10:32:50.300] run() for ‘SequentialFuture’ ... done
[10:32:50.300] getGlobalsAndPackages() ...
[10:32:50.300] Searching for globals...
[10:32:50.300] 
[10:32:50.300] Searching for globals ... DONE
[10:32:50.300] - globals: [0] <none>
[10:32:50.300] getGlobalsAndPackages() ... DONE
[10:32:50.300] run() for ‘Future’ ...
[10:32:50.301] - state: ‘created’
[10:32:50.301] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.301] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.302]   - Field: ‘label’
[10:32:50.302]   - Field: ‘local’
[10:32:50.302]   - Field: ‘owner’
[10:32:50.302]   - Field: ‘envir’
[10:32:50.303]   - Field: ‘packages’
[10:32:50.303]   - Field: ‘gc’
[10:32:50.303]   - Field: ‘conditions’
[10:32:50.303]   - Field: ‘expr’
[10:32:50.303]   - Field: ‘uuid’
[10:32:50.303]   - Field: ‘seed’
[10:32:50.303]   - Field: ‘version’
[10:32:50.303]   - Field: ‘result’
[10:32:50.303]   - Field: ‘asynchronous’
[10:32:50.303]   - Field: ‘calls’
[10:32:50.303]   - Field: ‘globals’
[10:32:50.304]   - Field: ‘stdout’
[10:32:50.304]   - Field: ‘earlySignal’
[10:32:50.304]   - Field: ‘lazy’
[10:32:50.304]   - Field: ‘state’
[10:32:50.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.304] - Launch lazy future ...
[10:32:50.304] Packages needed by the future expression (n = 0): <none>
[10:32:50.304] Packages needed by future strategies (n = 0): <none>
[10:32:50.305] {
[10:32:50.305]     {
[10:32:50.305]         {
[10:32:50.305]             ...future.startTime <- base::Sys.time()
[10:32:50.305]             {
[10:32:50.305]                 {
[10:32:50.305]                   {
[10:32:50.305]                     base::local({
[10:32:50.305]                       has_future <- base::requireNamespace("future", 
[10:32:50.305]                         quietly = TRUE)
[10:32:50.305]                       if (has_future) {
[10:32:50.305]                         ns <- base::getNamespace("future")
[10:32:50.305]                         version <- ns[[".package"]][["version"]]
[10:32:50.305]                         if (is.null(version)) 
[10:32:50.305]                           version <- utils::packageVersion("future")
[10:32:50.305]                       }
[10:32:50.305]                       else {
[10:32:50.305]                         version <- NULL
[10:32:50.305]                       }
[10:32:50.305]                       if (!has_future || version < "1.8.0") {
[10:32:50.305]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.305]                           "", base::R.version$version.string), 
[10:32:50.305]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.305]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.305]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.305]                             "release", "version")], collapse = " "), 
[10:32:50.305]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.305]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.305]                           info)
[10:32:50.305]                         info <- base::paste(info, collapse = "; ")
[10:32:50.305]                         if (!has_future) {
[10:32:50.305]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.305]                             info)
[10:32:50.305]                         }
[10:32:50.305]                         else {
[10:32:50.305]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.305]                             info, version)
[10:32:50.305]                         }
[10:32:50.305]                         base::stop(msg)
[10:32:50.305]                       }
[10:32:50.305]                     })
[10:32:50.305]                   }
[10:32:50.305]                   ...future.strategy.old <- future::plan("list")
[10:32:50.305]                   options(future.plan = NULL)
[10:32:50.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.305]                 }
[10:32:50.305]                 ...future.workdir <- getwd()
[10:32:50.305]             }
[10:32:50.305]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.305]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.305]         }
[10:32:50.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.305]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.305]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.305]             base::names(...future.oldOptions))
[10:32:50.305]     }
[10:32:50.305]     if (FALSE) {
[10:32:50.305]     }
[10:32:50.305]     else {
[10:32:50.305]         if (TRUE) {
[10:32:50.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.305]                 open = "w")
[10:32:50.305]         }
[10:32:50.305]         else {
[10:32:50.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.305]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.305]         }
[10:32:50.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.305]             base::sink(type = "output", split = FALSE)
[10:32:50.305]             base::close(...future.stdout)
[10:32:50.305]         }, add = TRUE)
[10:32:50.305]     }
[10:32:50.305]     ...future.frame <- base::sys.nframe()
[10:32:50.305]     ...future.conditions <- base::list()
[10:32:50.305]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.305]     if (FALSE) {
[10:32:50.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.305]     }
[10:32:50.305]     ...future.result <- base::tryCatch({
[10:32:50.305]         base::withCallingHandlers({
[10:32:50.305]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.305]             future::FutureResult(value = ...future.value$value, 
[10:32:50.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.305]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.305]                     ...future.globalenv.names))
[10:32:50.305]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.305]         }, condition = base::local({
[10:32:50.305]             c <- base::c
[10:32:50.305]             inherits <- base::inherits
[10:32:50.305]             invokeRestart <- base::invokeRestart
[10:32:50.305]             length <- base::length
[10:32:50.305]             list <- base::list
[10:32:50.305]             seq.int <- base::seq.int
[10:32:50.305]             signalCondition <- base::signalCondition
[10:32:50.305]             sys.calls <- base::sys.calls
[10:32:50.305]             `[[` <- base::`[[`
[10:32:50.305]             `+` <- base::`+`
[10:32:50.305]             `<<-` <- base::`<<-`
[10:32:50.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.305]                   3L)]
[10:32:50.305]             }
[10:32:50.305]             function(cond) {
[10:32:50.305]                 is_error <- inherits(cond, "error")
[10:32:50.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.305]                   NULL)
[10:32:50.305]                 if (is_error) {
[10:32:50.305]                   sessionInformation <- function() {
[10:32:50.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.305]                       search = base::search(), system = base::Sys.info())
[10:32:50.305]                   }
[10:32:50.305]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.305]                     cond$call), session = sessionInformation(), 
[10:32:50.305]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.305]                   signalCondition(cond)
[10:32:50.305]                 }
[10:32:50.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.305]                 "immediateCondition"))) {
[10:32:50.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.305]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.305]                   if (TRUE && !signal) {
[10:32:50.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.305]                     {
[10:32:50.305]                       inherits <- base::inherits
[10:32:50.305]                       invokeRestart <- base::invokeRestart
[10:32:50.305]                       is.null <- base::is.null
[10:32:50.305]                       muffled <- FALSE
[10:32:50.305]                       if (inherits(cond, "message")) {
[10:32:50.305]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.305]                         if (muffled) 
[10:32:50.305]                           invokeRestart("muffleMessage")
[10:32:50.305]                       }
[10:32:50.305]                       else if (inherits(cond, "warning")) {
[10:32:50.305]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.305]                         if (muffled) 
[10:32:50.305]                           invokeRestart("muffleWarning")
[10:32:50.305]                       }
[10:32:50.305]                       else if (inherits(cond, "condition")) {
[10:32:50.305]                         if (!is.null(pattern)) {
[10:32:50.305]                           computeRestarts <- base::computeRestarts
[10:32:50.305]                           grepl <- base::grepl
[10:32:50.305]                           restarts <- computeRestarts(cond)
[10:32:50.305]                           for (restart in restarts) {
[10:32:50.305]                             name <- restart$name
[10:32:50.305]                             if (is.null(name)) 
[10:32:50.305]                               next
[10:32:50.305]                             if (!grepl(pattern, name)) 
[10:32:50.305]                               next
[10:32:50.305]                             invokeRestart(restart)
[10:32:50.305]                             muffled <- TRUE
[10:32:50.305]                             break
[10:32:50.305]                           }
[10:32:50.305]                         }
[10:32:50.305]                       }
[10:32:50.305]                       invisible(muffled)
[10:32:50.305]                     }
[10:32:50.305]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.305]                   }
[10:32:50.305]                 }
[10:32:50.305]                 else {
[10:32:50.305]                   if (TRUE) {
[10:32:50.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.305]                     {
[10:32:50.305]                       inherits <- base::inherits
[10:32:50.305]                       invokeRestart <- base::invokeRestart
[10:32:50.305]                       is.null <- base::is.null
[10:32:50.305]                       muffled <- FALSE
[10:32:50.305]                       if (inherits(cond, "message")) {
[10:32:50.305]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.305]                         if (muffled) 
[10:32:50.305]                           invokeRestart("muffleMessage")
[10:32:50.305]                       }
[10:32:50.305]                       else if (inherits(cond, "warning")) {
[10:32:50.305]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.305]                         if (muffled) 
[10:32:50.305]                           invokeRestart("muffleWarning")
[10:32:50.305]                       }
[10:32:50.305]                       else if (inherits(cond, "condition")) {
[10:32:50.305]                         if (!is.null(pattern)) {
[10:32:50.305]                           computeRestarts <- base::computeRestarts
[10:32:50.305]                           grepl <- base::grepl
[10:32:50.305]                           restarts <- computeRestarts(cond)
[10:32:50.305]                           for (restart in restarts) {
[10:32:50.305]                             name <- restart$name
[10:32:50.305]                             if (is.null(name)) 
[10:32:50.305]                               next
[10:32:50.305]                             if (!grepl(pattern, name)) 
[10:32:50.305]                               next
[10:32:50.305]                             invokeRestart(restart)
[10:32:50.305]                             muffled <- TRUE
[10:32:50.305]                             break
[10:32:50.305]                           }
[10:32:50.305]                         }
[10:32:50.305]                       }
[10:32:50.305]                       invisible(muffled)
[10:32:50.305]                     }
[10:32:50.305]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.305]                   }
[10:32:50.305]                 }
[10:32:50.305]             }
[10:32:50.305]         }))
[10:32:50.305]     }, error = function(ex) {
[10:32:50.305]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.305]                 ...future.rng), started = ...future.startTime, 
[10:32:50.305]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.305]             version = "1.8"), class = "FutureResult")
[10:32:50.305]     }, finally = {
[10:32:50.305]         if (!identical(...future.workdir, getwd())) 
[10:32:50.305]             setwd(...future.workdir)
[10:32:50.305]         {
[10:32:50.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.305]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.305]             }
[10:32:50.305]             base::options(...future.oldOptions)
[10:32:50.305]             if (.Platform$OS.type == "windows") {
[10:32:50.305]                 old_names <- names(...future.oldEnvVars)
[10:32:50.305]                 envs <- base::Sys.getenv()
[10:32:50.305]                 names <- names(envs)
[10:32:50.305]                 common <- intersect(names, old_names)
[10:32:50.305]                 added <- setdiff(names, old_names)
[10:32:50.305]                 removed <- setdiff(old_names, names)
[10:32:50.305]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.305]                   envs[common]]
[10:32:50.305]                 NAMES <- toupper(changed)
[10:32:50.305]                 args <- list()
[10:32:50.305]                 for (kk in seq_along(NAMES)) {
[10:32:50.305]                   name <- changed[[kk]]
[10:32:50.305]                   NAME <- NAMES[[kk]]
[10:32:50.305]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.305]                     next
[10:32:50.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.305]                 }
[10:32:50.305]                 NAMES <- toupper(added)
[10:32:50.305]                 for (kk in seq_along(NAMES)) {
[10:32:50.305]                   name <- added[[kk]]
[10:32:50.305]                   NAME <- NAMES[[kk]]
[10:32:50.305]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.305]                     next
[10:32:50.305]                   args[[name]] <- ""
[10:32:50.305]                 }
[10:32:50.305]                 NAMES <- toupper(removed)
[10:32:50.305]                 for (kk in seq_along(NAMES)) {
[10:32:50.305]                   name <- removed[[kk]]
[10:32:50.305]                   NAME <- NAMES[[kk]]
[10:32:50.305]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.305]                     next
[10:32:50.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.305]                 }
[10:32:50.305]                 if (length(args) > 0) 
[10:32:50.305]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.305]             }
[10:32:50.305]             else {
[10:32:50.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.305]             }
[10:32:50.305]             {
[10:32:50.305]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.305]                   0L) {
[10:32:50.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.305]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.305]                   base::options(opts)
[10:32:50.305]                 }
[10:32:50.305]                 {
[10:32:50.305]                   {
[10:32:50.305]                     NULL
[10:32:50.305]                     RNGkind("Mersenne-Twister")
[10:32:50.305]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.305]                       inherits = FALSE)
[10:32:50.305]                   }
[10:32:50.305]                   options(future.plan = NULL)
[10:32:50.305]                   if (is.na(NA_character_)) 
[10:32:50.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.305]                     .init = FALSE)
[10:32:50.305]                 }
[10:32:50.305]             }
[10:32:50.305]         }
[10:32:50.305]     })
[10:32:50.305]     if (TRUE) {
[10:32:50.305]         base::sink(type = "output", split = FALSE)
[10:32:50.305]         if (TRUE) {
[10:32:50.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.305]         }
[10:32:50.305]         else {
[10:32:50.305]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.305]         }
[10:32:50.305]         base::close(...future.stdout)
[10:32:50.305]         ...future.stdout <- NULL
[10:32:50.305]     }
[10:32:50.305]     ...future.result$conditions <- ...future.conditions
[10:32:50.305]     ...future.result$finished <- base::Sys.time()
[10:32:50.305]     ...future.result
[10:32:50.305] }
[10:32:50.306] plan(): Setting new future strategy stack:
[10:32:50.306] List of future strategies:
[10:32:50.306] 1. sequential:
[10:32:50.306]    - args: function (..., envir = parent.frame())
[10:32:50.306]    - tweaked: FALSE
[10:32:50.306]    - call: NULL
[10:32:50.307] plan(): nbrOfWorkers() = 1
[10:32:50.307] plan(): Setting new future strategy stack:
[10:32:50.307] List of future strategies:
[10:32:50.307] 1. sequential:
[10:32:50.307]    - args: function (..., envir = parent.frame())
[10:32:50.307]    - tweaked: FALSE
[10:32:50.307]    - call: plan(strategy)
[10:32:50.308] plan(): nbrOfWorkers() = 1
[10:32:50.308] SequentialFuture started (and completed)
[10:32:50.308] - Launch lazy future ... done
[10:32:50.308] run() for ‘SequentialFuture’ ... done
[10:32:50.308] getGlobalsAndPackages() ...
[10:32:50.309] Searching for globals...
[10:32:50.309] - globals found: [1] ‘{’
[10:32:50.309] Searching for globals ... DONE
[10:32:50.309] Resolving globals: FALSE
[10:32:50.310] 
[10:32:50.310] 
[10:32:50.310] getGlobalsAndPackages() ... DONE
[10:32:50.310] run() for ‘Future’ ...
[10:32:50.310] - state: ‘created’
[10:32:50.310] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.310] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.311]   - Field: ‘label’
[10:32:50.311]   - Field: ‘local’
[10:32:50.311]   - Field: ‘owner’
[10:32:50.311]   - Field: ‘envir’
[10:32:50.311]   - Field: ‘packages’
[10:32:50.311]   - Field: ‘gc’
[10:32:50.311]   - Field: ‘conditions’
[10:32:50.311]   - Field: ‘expr’
[10:32:50.311]   - Field: ‘uuid’
[10:32:50.311]   - Field: ‘seed’
[10:32:50.311]   - Field: ‘version’
[10:32:50.312]   - Field: ‘result’
[10:32:50.312]   - Field: ‘asynchronous’
[10:32:50.312]   - Field: ‘calls’
[10:32:50.312]   - Field: ‘globals’
[10:32:50.312]   - Field: ‘stdout’
[10:32:50.312]   - Field: ‘earlySignal’
[10:32:50.312]   - Field: ‘lazy’
[10:32:50.312]   - Field: ‘state’
[10:32:50.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.312] - Launch lazy future ...
[10:32:50.312] Packages needed by the future expression (n = 0): <none>
[10:32:50.313] Packages needed by future strategies (n = 0): <none>
[10:32:50.313] {
[10:32:50.313]     {
[10:32:50.313]         {
[10:32:50.313]             ...future.startTime <- base::Sys.time()
[10:32:50.313]             {
[10:32:50.313]                 {
[10:32:50.313]                   {
[10:32:50.313]                     base::local({
[10:32:50.313]                       has_future <- base::requireNamespace("future", 
[10:32:50.313]                         quietly = TRUE)
[10:32:50.313]                       if (has_future) {
[10:32:50.313]                         ns <- base::getNamespace("future")
[10:32:50.313]                         version <- ns[[".package"]][["version"]]
[10:32:50.313]                         if (is.null(version)) 
[10:32:50.313]                           version <- utils::packageVersion("future")
[10:32:50.313]                       }
[10:32:50.313]                       else {
[10:32:50.313]                         version <- NULL
[10:32:50.313]                       }
[10:32:50.313]                       if (!has_future || version < "1.8.0") {
[10:32:50.313]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.313]                           "", base::R.version$version.string), 
[10:32:50.313]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.313]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.313]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.313]                             "release", "version")], collapse = " "), 
[10:32:50.313]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.313]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.313]                           info)
[10:32:50.313]                         info <- base::paste(info, collapse = "; ")
[10:32:50.313]                         if (!has_future) {
[10:32:50.313]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.313]                             info)
[10:32:50.313]                         }
[10:32:50.313]                         else {
[10:32:50.313]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.313]                             info, version)
[10:32:50.313]                         }
[10:32:50.313]                         base::stop(msg)
[10:32:50.313]                       }
[10:32:50.313]                     })
[10:32:50.313]                   }
[10:32:50.313]                   ...future.strategy.old <- future::plan("list")
[10:32:50.313]                   options(future.plan = NULL)
[10:32:50.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.313]                 }
[10:32:50.313]                 ...future.workdir <- getwd()
[10:32:50.313]             }
[10:32:50.313]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.313]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.313]         }
[10:32:50.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.313]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.313]             base::names(...future.oldOptions))
[10:32:50.313]     }
[10:32:50.313]     if (FALSE) {
[10:32:50.313]     }
[10:32:50.313]     else {
[10:32:50.313]         if (TRUE) {
[10:32:50.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.313]                 open = "w")
[10:32:50.313]         }
[10:32:50.313]         else {
[10:32:50.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.313]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.313]         }
[10:32:50.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.313]             base::sink(type = "output", split = FALSE)
[10:32:50.313]             base::close(...future.stdout)
[10:32:50.313]         }, add = TRUE)
[10:32:50.313]     }
[10:32:50.313]     ...future.frame <- base::sys.nframe()
[10:32:50.313]     ...future.conditions <- base::list()
[10:32:50.313]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.313]     if (FALSE) {
[10:32:50.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.313]     }
[10:32:50.313]     ...future.result <- base::tryCatch({
[10:32:50.313]         base::withCallingHandlers({
[10:32:50.313]             ...future.value <- base::withVisible(base::local({
[10:32:50.313]                 4
[10:32:50.313]             }))
[10:32:50.313]             future::FutureResult(value = ...future.value$value, 
[10:32:50.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.313]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.313]                     ...future.globalenv.names))
[10:32:50.313]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.313]         }, condition = base::local({
[10:32:50.313]             c <- base::c
[10:32:50.313]             inherits <- base::inherits
[10:32:50.313]             invokeRestart <- base::invokeRestart
[10:32:50.313]             length <- base::length
[10:32:50.313]             list <- base::list
[10:32:50.313]             seq.int <- base::seq.int
[10:32:50.313]             signalCondition <- base::signalCondition
[10:32:50.313]             sys.calls <- base::sys.calls
[10:32:50.313]             `[[` <- base::`[[`
[10:32:50.313]             `+` <- base::`+`
[10:32:50.313]             `<<-` <- base::`<<-`
[10:32:50.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.313]                   3L)]
[10:32:50.313]             }
[10:32:50.313]             function(cond) {
[10:32:50.313]                 is_error <- inherits(cond, "error")
[10:32:50.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.313]                   NULL)
[10:32:50.313]                 if (is_error) {
[10:32:50.313]                   sessionInformation <- function() {
[10:32:50.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.313]                       search = base::search(), system = base::Sys.info())
[10:32:50.313]                   }
[10:32:50.313]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.313]                     cond$call), session = sessionInformation(), 
[10:32:50.313]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.313]                   signalCondition(cond)
[10:32:50.313]                 }
[10:32:50.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.313]                 "immediateCondition"))) {
[10:32:50.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.313]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.313]                   if (TRUE && !signal) {
[10:32:50.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.313]                     {
[10:32:50.313]                       inherits <- base::inherits
[10:32:50.313]                       invokeRestart <- base::invokeRestart
[10:32:50.313]                       is.null <- base::is.null
[10:32:50.313]                       muffled <- FALSE
[10:32:50.313]                       if (inherits(cond, "message")) {
[10:32:50.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.313]                         if (muffled) 
[10:32:50.313]                           invokeRestart("muffleMessage")
[10:32:50.313]                       }
[10:32:50.313]                       else if (inherits(cond, "warning")) {
[10:32:50.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.313]                         if (muffled) 
[10:32:50.313]                           invokeRestart("muffleWarning")
[10:32:50.313]                       }
[10:32:50.313]                       else if (inherits(cond, "condition")) {
[10:32:50.313]                         if (!is.null(pattern)) {
[10:32:50.313]                           computeRestarts <- base::computeRestarts
[10:32:50.313]                           grepl <- base::grepl
[10:32:50.313]                           restarts <- computeRestarts(cond)
[10:32:50.313]                           for (restart in restarts) {
[10:32:50.313]                             name <- restart$name
[10:32:50.313]                             if (is.null(name)) 
[10:32:50.313]                               next
[10:32:50.313]                             if (!grepl(pattern, name)) 
[10:32:50.313]                               next
[10:32:50.313]                             invokeRestart(restart)
[10:32:50.313]                             muffled <- TRUE
[10:32:50.313]                             break
[10:32:50.313]                           }
[10:32:50.313]                         }
[10:32:50.313]                       }
[10:32:50.313]                       invisible(muffled)
[10:32:50.313]                     }
[10:32:50.313]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.313]                   }
[10:32:50.313]                 }
[10:32:50.313]                 else {
[10:32:50.313]                   if (TRUE) {
[10:32:50.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.313]                     {
[10:32:50.313]                       inherits <- base::inherits
[10:32:50.313]                       invokeRestart <- base::invokeRestart
[10:32:50.313]                       is.null <- base::is.null
[10:32:50.313]                       muffled <- FALSE
[10:32:50.313]                       if (inherits(cond, "message")) {
[10:32:50.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.313]                         if (muffled) 
[10:32:50.313]                           invokeRestart("muffleMessage")
[10:32:50.313]                       }
[10:32:50.313]                       else if (inherits(cond, "warning")) {
[10:32:50.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.313]                         if (muffled) 
[10:32:50.313]                           invokeRestart("muffleWarning")
[10:32:50.313]                       }
[10:32:50.313]                       else if (inherits(cond, "condition")) {
[10:32:50.313]                         if (!is.null(pattern)) {
[10:32:50.313]                           computeRestarts <- base::computeRestarts
[10:32:50.313]                           grepl <- base::grepl
[10:32:50.313]                           restarts <- computeRestarts(cond)
[10:32:50.313]                           for (restart in restarts) {
[10:32:50.313]                             name <- restart$name
[10:32:50.313]                             if (is.null(name)) 
[10:32:50.313]                               next
[10:32:50.313]                             if (!grepl(pattern, name)) 
[10:32:50.313]                               next
[10:32:50.313]                             invokeRestart(restart)
[10:32:50.313]                             muffled <- TRUE
[10:32:50.313]                             break
[10:32:50.313]                           }
[10:32:50.313]                         }
[10:32:50.313]                       }
[10:32:50.313]                       invisible(muffled)
[10:32:50.313]                     }
[10:32:50.313]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.313]                   }
[10:32:50.313]                 }
[10:32:50.313]             }
[10:32:50.313]         }))
[10:32:50.313]     }, error = function(ex) {
[10:32:50.313]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.313]                 ...future.rng), started = ...future.startTime, 
[10:32:50.313]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.313]             version = "1.8"), class = "FutureResult")
[10:32:50.313]     }, finally = {
[10:32:50.313]         if (!identical(...future.workdir, getwd())) 
[10:32:50.313]             setwd(...future.workdir)
[10:32:50.313]         {
[10:32:50.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.313]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.313]             }
[10:32:50.313]             base::options(...future.oldOptions)
[10:32:50.313]             if (.Platform$OS.type == "windows") {
[10:32:50.313]                 old_names <- names(...future.oldEnvVars)
[10:32:50.313]                 envs <- base::Sys.getenv()
[10:32:50.313]                 names <- names(envs)
[10:32:50.313]                 common <- intersect(names, old_names)
[10:32:50.313]                 added <- setdiff(names, old_names)
[10:32:50.313]                 removed <- setdiff(old_names, names)
[10:32:50.313]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.313]                   envs[common]]
[10:32:50.313]                 NAMES <- toupper(changed)
[10:32:50.313]                 args <- list()
[10:32:50.313]                 for (kk in seq_along(NAMES)) {
[10:32:50.313]                   name <- changed[[kk]]
[10:32:50.313]                   NAME <- NAMES[[kk]]
[10:32:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.313]                     next
[10:32:50.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.313]                 }
[10:32:50.313]                 NAMES <- toupper(added)
[10:32:50.313]                 for (kk in seq_along(NAMES)) {
[10:32:50.313]                   name <- added[[kk]]
[10:32:50.313]                   NAME <- NAMES[[kk]]
[10:32:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.313]                     next
[10:32:50.313]                   args[[name]] <- ""
[10:32:50.313]                 }
[10:32:50.313]                 NAMES <- toupper(removed)
[10:32:50.313]                 for (kk in seq_along(NAMES)) {
[10:32:50.313]                   name <- removed[[kk]]
[10:32:50.313]                   NAME <- NAMES[[kk]]
[10:32:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.313]                     next
[10:32:50.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.313]                 }
[10:32:50.313]                 if (length(args) > 0) 
[10:32:50.313]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.313]             }
[10:32:50.313]             else {
[10:32:50.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.313]             }
[10:32:50.313]             {
[10:32:50.313]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.313]                   0L) {
[10:32:50.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.313]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.313]                   base::options(opts)
[10:32:50.313]                 }
[10:32:50.313]                 {
[10:32:50.313]                   {
[10:32:50.313]                     NULL
[10:32:50.313]                     RNGkind("Mersenne-Twister")
[10:32:50.313]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.313]                       inherits = FALSE)
[10:32:50.313]                   }
[10:32:50.313]                   options(future.plan = NULL)
[10:32:50.313]                   if (is.na(NA_character_)) 
[10:32:50.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.313]                     .init = FALSE)
[10:32:50.313]                 }
[10:32:50.313]             }
[10:32:50.313]         }
[10:32:50.313]     })
[10:32:50.313]     if (TRUE) {
[10:32:50.313]         base::sink(type = "output", split = FALSE)
[10:32:50.313]         if (TRUE) {
[10:32:50.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.313]         }
[10:32:50.313]         else {
[10:32:50.313]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.313]         }
[10:32:50.313]         base::close(...future.stdout)
[10:32:50.313]         ...future.stdout <- NULL
[10:32:50.313]     }
[10:32:50.313]     ...future.result$conditions <- ...future.conditions
[10:32:50.313]     ...future.result$finished <- base::Sys.time()
[10:32:50.313]     ...future.result
[10:32:50.313] }
[10:32:50.315] plan(): Setting new future strategy stack:
[10:32:50.315] List of future strategies:
[10:32:50.315] 1. sequential:
[10:32:50.315]    - args: function (..., envir = parent.frame())
[10:32:50.315]    - tweaked: FALSE
[10:32:50.315]    - call: NULL
[10:32:50.315] plan(): nbrOfWorkers() = 1
[10:32:50.316] plan(): Setting new future strategy stack:
[10:32:50.316] List of future strategies:
[10:32:50.316] 1. sequential:
[10:32:50.316]    - args: function (..., envir = parent.frame())
[10:32:50.316]    - tweaked: FALSE
[10:32:50.316]    - call: plan(strategy)
[10:32:50.316] plan(): nbrOfWorkers() = 1
[10:32:50.316] SequentialFuture started (and completed)
[10:32:50.316] - Launch lazy future ... done
[10:32:50.317] run() for ‘SequentialFuture’ ... done
<environment: 0x5652d0e6e758> 
<environment: 0x5652d0d2a908> 
[10:32:50.318] resolved() for ‘SequentialFuture’ ...
[10:32:50.318] - state: ‘finished’
[10:32:50.318] - run: TRUE
[10:32:50.318] - result: ‘FutureResult’
[10:32:50.318] resolved() for ‘SequentialFuture’ ... done
[10:32:50.318] resolved() for ‘SequentialFuture’ ...
[10:32:50.318] - state: ‘finished’
[10:32:50.318] - run: TRUE
[10:32:50.318] - result: ‘FutureResult’
[10:32:50.318] resolved() for ‘SequentialFuture’ ... done
[10:32:50.319] resolved() for ‘SequentialFuture’ ...
[10:32:50.319] - state: ‘finished’
[10:32:50.319] - run: TRUE
[10:32:50.319] - result: ‘FutureResult’
[10:32:50.319] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:50.320] resolve() on environment ...
[10:32:50.320]  recursive: 0
[10:32:50.320]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:50.321] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.321] - nx: 4
[10:32:50.321] - relay: TRUE
[10:32:50.321] - stdout: TRUE
[10:32:50.321] - signal: TRUE
[10:32:50.321] - resignal: FALSE
[10:32:50.321] - force: TRUE
[10:32:50.321] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.321] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.321]  - until=2
[10:32:50.321]  - relaying element #2
[10:32:50.322] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.322] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.322] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.322]  length: 3 (resolved future 1)
[10:32:50.322] resolved() for ‘SequentialFuture’ ...
[10:32:50.322] - state: ‘finished’
[10:32:50.322] - run: TRUE
[10:32:50.322] - result: ‘FutureResult’
[10:32:50.322] resolved() for ‘SequentialFuture’ ... done
[10:32:50.322] Future #2
[10:32:50.322] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.323] - nx: 4
[10:32:50.323] - relay: TRUE
[10:32:50.323] - stdout: TRUE
[10:32:50.323] - signal: TRUE
[10:32:50.323] - resignal: FALSE
[10:32:50.323] - force: TRUE
[10:32:50.323] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.323] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.323]  - until=2
[10:32:50.323]  - relaying element #2
[10:32:50.323] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.324] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.324] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.324]  length: 2 (resolved future 2)
[10:32:50.324] resolved() for ‘SequentialFuture’ ...
[10:32:50.324] - state: ‘finished’
[10:32:50.324] - run: TRUE
[10:32:50.324] - result: ‘FutureResult’
[10:32:50.324] resolved() for ‘SequentialFuture’ ... done
[10:32:50.324] Future #3
[10:32:50.324] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.324] - nx: 4
[10:32:50.325] - relay: TRUE
[10:32:50.325] - stdout: TRUE
[10:32:50.325] - signal: TRUE
[10:32:50.325] - resignal: FALSE
[10:32:50.325] - force: TRUE
[10:32:50.325] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.325] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.325]  - until=3
[10:32:50.325]  - relaying element #3
[10:32:50.325] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.325] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.326] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.326]  length: 1 (resolved future 3)
[10:32:50.326] resolved() for ‘SequentialFuture’ ...
[10:32:50.326] - state: ‘finished’
[10:32:50.326] - run: TRUE
[10:32:50.326] - result: ‘FutureResult’
[10:32:50.326] resolved() for ‘SequentialFuture’ ... done
[10:32:50.327] Future #4
[10:32:50.327] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.327] - nx: 4
[10:32:50.327] - relay: TRUE
[10:32:50.328] - stdout: TRUE
[10:32:50.328] - signal: TRUE
[10:32:50.328] - resignal: FALSE
[10:32:50.328] - force: TRUE
[10:32:50.328] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.328] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.328]  - until=4
[10:32:50.328]  - relaying element #4
[10:32:50.328] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.328] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.328] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.329]  length: 0 (resolved future 4)
[10:32:50.329] Relaying remaining futures
[10:32:50.329] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.329] - nx: 4
[10:32:50.329] - relay: TRUE
[10:32:50.329] - stdout: TRUE
[10:32:50.329] - signal: TRUE
[10:32:50.329] - resignal: FALSE
[10:32:50.329] - force: TRUE
[10:32:50.329] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.329] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:50.329] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.330] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.330] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.330] resolve() on environment ... DONE
<environment: 0x5652d0ed92a0> 
Dimensions: c(2, 1, 3, 1)
[10:32:50.330] getGlobalsAndPackages() ...
[10:32:50.330] Searching for globals...
[10:32:50.331] 
[10:32:50.331] Searching for globals ... DONE
[10:32:50.331] - globals: [0] <none>
[10:32:50.331] getGlobalsAndPackages() ... DONE
[10:32:50.331] run() for ‘Future’ ...
[10:32:50.331] - state: ‘created’
[10:32:50.331] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.332] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.332] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.332]   - Field: ‘label’
[10:32:50.332]   - Field: ‘local’
[10:32:50.332]   - Field: ‘owner’
[10:32:50.332]   - Field: ‘envir’
[10:32:50.332]   - Field: ‘packages’
[10:32:50.332]   - Field: ‘gc’
[10:32:50.332]   - Field: ‘conditions’
[10:32:50.332]   - Field: ‘expr’
[10:32:50.332]   - Field: ‘uuid’
[10:32:50.333]   - Field: ‘seed’
[10:32:50.333]   - Field: ‘version’
[10:32:50.333]   - Field: ‘result’
[10:32:50.333]   - Field: ‘asynchronous’
[10:32:50.333]   - Field: ‘calls’
[10:32:50.333]   - Field: ‘globals’
[10:32:50.333]   - Field: ‘stdout’
[10:32:50.333]   - Field: ‘earlySignal’
[10:32:50.333]   - Field: ‘lazy’
[10:32:50.333]   - Field: ‘state’
[10:32:50.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.334] - Launch lazy future ...
[10:32:50.334] Packages needed by the future expression (n = 0): <none>
[10:32:50.334] Packages needed by future strategies (n = 0): <none>
[10:32:50.334] {
[10:32:50.334]     {
[10:32:50.334]         {
[10:32:50.334]             ...future.startTime <- base::Sys.time()
[10:32:50.334]             {
[10:32:50.334]                 {
[10:32:50.334]                   {
[10:32:50.334]                     base::local({
[10:32:50.334]                       has_future <- base::requireNamespace("future", 
[10:32:50.334]                         quietly = TRUE)
[10:32:50.334]                       if (has_future) {
[10:32:50.334]                         ns <- base::getNamespace("future")
[10:32:50.334]                         version <- ns[[".package"]][["version"]]
[10:32:50.334]                         if (is.null(version)) 
[10:32:50.334]                           version <- utils::packageVersion("future")
[10:32:50.334]                       }
[10:32:50.334]                       else {
[10:32:50.334]                         version <- NULL
[10:32:50.334]                       }
[10:32:50.334]                       if (!has_future || version < "1.8.0") {
[10:32:50.334]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.334]                           "", base::R.version$version.string), 
[10:32:50.334]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.334]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.334]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.334]                             "release", "version")], collapse = " "), 
[10:32:50.334]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.334]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.334]                           info)
[10:32:50.334]                         info <- base::paste(info, collapse = "; ")
[10:32:50.334]                         if (!has_future) {
[10:32:50.334]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.334]                             info)
[10:32:50.334]                         }
[10:32:50.334]                         else {
[10:32:50.334]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.334]                             info, version)
[10:32:50.334]                         }
[10:32:50.334]                         base::stop(msg)
[10:32:50.334]                       }
[10:32:50.334]                     })
[10:32:50.334]                   }
[10:32:50.334]                   ...future.strategy.old <- future::plan("list")
[10:32:50.334]                   options(future.plan = NULL)
[10:32:50.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.334]                 }
[10:32:50.334]                 ...future.workdir <- getwd()
[10:32:50.334]             }
[10:32:50.334]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.334]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.334]         }
[10:32:50.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.334]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.334]             base::names(...future.oldOptions))
[10:32:50.334]     }
[10:32:50.334]     if (FALSE) {
[10:32:50.334]     }
[10:32:50.334]     else {
[10:32:50.334]         if (TRUE) {
[10:32:50.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.334]                 open = "w")
[10:32:50.334]         }
[10:32:50.334]         else {
[10:32:50.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.334]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.334]         }
[10:32:50.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.334]             base::sink(type = "output", split = FALSE)
[10:32:50.334]             base::close(...future.stdout)
[10:32:50.334]         }, add = TRUE)
[10:32:50.334]     }
[10:32:50.334]     ...future.frame <- base::sys.nframe()
[10:32:50.334]     ...future.conditions <- base::list()
[10:32:50.334]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.334]     if (FALSE) {
[10:32:50.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.334]     }
[10:32:50.334]     ...future.result <- base::tryCatch({
[10:32:50.334]         base::withCallingHandlers({
[10:32:50.334]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.334]             future::FutureResult(value = ...future.value$value, 
[10:32:50.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.334]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.334]                     ...future.globalenv.names))
[10:32:50.334]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.334]         }, condition = base::local({
[10:32:50.334]             c <- base::c
[10:32:50.334]             inherits <- base::inherits
[10:32:50.334]             invokeRestart <- base::invokeRestart
[10:32:50.334]             length <- base::length
[10:32:50.334]             list <- base::list
[10:32:50.334]             seq.int <- base::seq.int
[10:32:50.334]             signalCondition <- base::signalCondition
[10:32:50.334]             sys.calls <- base::sys.calls
[10:32:50.334]             `[[` <- base::`[[`
[10:32:50.334]             `+` <- base::`+`
[10:32:50.334]             `<<-` <- base::`<<-`
[10:32:50.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.334]                   3L)]
[10:32:50.334]             }
[10:32:50.334]             function(cond) {
[10:32:50.334]                 is_error <- inherits(cond, "error")
[10:32:50.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.334]                   NULL)
[10:32:50.334]                 if (is_error) {
[10:32:50.334]                   sessionInformation <- function() {
[10:32:50.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.334]                       search = base::search(), system = base::Sys.info())
[10:32:50.334]                   }
[10:32:50.334]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.334]                     cond$call), session = sessionInformation(), 
[10:32:50.334]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.334]                   signalCondition(cond)
[10:32:50.334]                 }
[10:32:50.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.334]                 "immediateCondition"))) {
[10:32:50.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.334]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.334]                   if (TRUE && !signal) {
[10:32:50.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.334]                     {
[10:32:50.334]                       inherits <- base::inherits
[10:32:50.334]                       invokeRestart <- base::invokeRestart
[10:32:50.334]                       is.null <- base::is.null
[10:32:50.334]                       muffled <- FALSE
[10:32:50.334]                       if (inherits(cond, "message")) {
[10:32:50.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.334]                         if (muffled) 
[10:32:50.334]                           invokeRestart("muffleMessage")
[10:32:50.334]                       }
[10:32:50.334]                       else if (inherits(cond, "warning")) {
[10:32:50.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.334]                         if (muffled) 
[10:32:50.334]                           invokeRestart("muffleWarning")
[10:32:50.334]                       }
[10:32:50.334]                       else if (inherits(cond, "condition")) {
[10:32:50.334]                         if (!is.null(pattern)) {
[10:32:50.334]                           computeRestarts <- base::computeRestarts
[10:32:50.334]                           grepl <- base::grepl
[10:32:50.334]                           restarts <- computeRestarts(cond)
[10:32:50.334]                           for (restart in restarts) {
[10:32:50.334]                             name <- restart$name
[10:32:50.334]                             if (is.null(name)) 
[10:32:50.334]                               next
[10:32:50.334]                             if (!grepl(pattern, name)) 
[10:32:50.334]                               next
[10:32:50.334]                             invokeRestart(restart)
[10:32:50.334]                             muffled <- TRUE
[10:32:50.334]                             break
[10:32:50.334]                           }
[10:32:50.334]                         }
[10:32:50.334]                       }
[10:32:50.334]                       invisible(muffled)
[10:32:50.334]                     }
[10:32:50.334]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.334]                   }
[10:32:50.334]                 }
[10:32:50.334]                 else {
[10:32:50.334]                   if (TRUE) {
[10:32:50.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.334]                     {
[10:32:50.334]                       inherits <- base::inherits
[10:32:50.334]                       invokeRestart <- base::invokeRestart
[10:32:50.334]                       is.null <- base::is.null
[10:32:50.334]                       muffled <- FALSE
[10:32:50.334]                       if (inherits(cond, "message")) {
[10:32:50.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.334]                         if (muffled) 
[10:32:50.334]                           invokeRestart("muffleMessage")
[10:32:50.334]                       }
[10:32:50.334]                       else if (inherits(cond, "warning")) {
[10:32:50.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.334]                         if (muffled) 
[10:32:50.334]                           invokeRestart("muffleWarning")
[10:32:50.334]                       }
[10:32:50.334]                       else if (inherits(cond, "condition")) {
[10:32:50.334]                         if (!is.null(pattern)) {
[10:32:50.334]                           computeRestarts <- base::computeRestarts
[10:32:50.334]                           grepl <- base::grepl
[10:32:50.334]                           restarts <- computeRestarts(cond)
[10:32:50.334]                           for (restart in restarts) {
[10:32:50.334]                             name <- restart$name
[10:32:50.334]                             if (is.null(name)) 
[10:32:50.334]                               next
[10:32:50.334]                             if (!grepl(pattern, name)) 
[10:32:50.334]                               next
[10:32:50.334]                             invokeRestart(restart)
[10:32:50.334]                             muffled <- TRUE
[10:32:50.334]                             break
[10:32:50.334]                           }
[10:32:50.334]                         }
[10:32:50.334]                       }
[10:32:50.334]                       invisible(muffled)
[10:32:50.334]                     }
[10:32:50.334]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.334]                   }
[10:32:50.334]                 }
[10:32:50.334]             }
[10:32:50.334]         }))
[10:32:50.334]     }, error = function(ex) {
[10:32:50.334]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.334]                 ...future.rng), started = ...future.startTime, 
[10:32:50.334]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.334]             version = "1.8"), class = "FutureResult")
[10:32:50.334]     }, finally = {
[10:32:50.334]         if (!identical(...future.workdir, getwd())) 
[10:32:50.334]             setwd(...future.workdir)
[10:32:50.334]         {
[10:32:50.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.334]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.334]             }
[10:32:50.334]             base::options(...future.oldOptions)
[10:32:50.334]             if (.Platform$OS.type == "windows") {
[10:32:50.334]                 old_names <- names(...future.oldEnvVars)
[10:32:50.334]                 envs <- base::Sys.getenv()
[10:32:50.334]                 names <- names(envs)
[10:32:50.334]                 common <- intersect(names, old_names)
[10:32:50.334]                 added <- setdiff(names, old_names)
[10:32:50.334]                 removed <- setdiff(old_names, names)
[10:32:50.334]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.334]                   envs[common]]
[10:32:50.334]                 NAMES <- toupper(changed)
[10:32:50.334]                 args <- list()
[10:32:50.334]                 for (kk in seq_along(NAMES)) {
[10:32:50.334]                   name <- changed[[kk]]
[10:32:50.334]                   NAME <- NAMES[[kk]]
[10:32:50.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.334]                     next
[10:32:50.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.334]                 }
[10:32:50.334]                 NAMES <- toupper(added)
[10:32:50.334]                 for (kk in seq_along(NAMES)) {
[10:32:50.334]                   name <- added[[kk]]
[10:32:50.334]                   NAME <- NAMES[[kk]]
[10:32:50.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.334]                     next
[10:32:50.334]                   args[[name]] <- ""
[10:32:50.334]                 }
[10:32:50.334]                 NAMES <- toupper(removed)
[10:32:50.334]                 for (kk in seq_along(NAMES)) {
[10:32:50.334]                   name <- removed[[kk]]
[10:32:50.334]                   NAME <- NAMES[[kk]]
[10:32:50.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.334]                     next
[10:32:50.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.334]                 }
[10:32:50.334]                 if (length(args) > 0) 
[10:32:50.334]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.334]             }
[10:32:50.334]             else {
[10:32:50.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.334]             }
[10:32:50.334]             {
[10:32:50.334]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.334]                   0L) {
[10:32:50.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.334]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.334]                   base::options(opts)
[10:32:50.334]                 }
[10:32:50.334]                 {
[10:32:50.334]                   {
[10:32:50.334]                     NULL
[10:32:50.334]                     RNGkind("Mersenne-Twister")
[10:32:50.334]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.334]                       inherits = FALSE)
[10:32:50.334]                   }
[10:32:50.334]                   options(future.plan = NULL)
[10:32:50.334]                   if (is.na(NA_character_)) 
[10:32:50.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.334]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.334]                     .init = FALSE)
[10:32:50.334]                 }
[10:32:50.334]             }
[10:32:50.334]         }
[10:32:50.334]     })
[10:32:50.334]     if (TRUE) {
[10:32:50.334]         base::sink(type = "output", split = FALSE)
[10:32:50.334]         if (TRUE) {
[10:32:50.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.334]         }
[10:32:50.334]         else {
[10:32:50.334]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.334]         }
[10:32:50.334]         base::close(...future.stdout)
[10:32:50.334]         ...future.stdout <- NULL
[10:32:50.334]     }
[10:32:50.334]     ...future.result$conditions <- ...future.conditions
[10:32:50.334]     ...future.result$finished <- base::Sys.time()
[10:32:50.334]     ...future.result
[10:32:50.334] }
[10:32:50.336] plan(): Setting new future strategy stack:
[10:32:50.336] List of future strategies:
[10:32:50.336] 1. sequential:
[10:32:50.336]    - args: function (..., envir = parent.frame())
[10:32:50.336]    - tweaked: FALSE
[10:32:50.336]    - call: NULL
[10:32:50.336] plan(): nbrOfWorkers() = 1
[10:32:50.337] plan(): Setting new future strategy stack:
[10:32:50.337] List of future strategies:
[10:32:50.337] 1. sequential:
[10:32:50.337]    - args: function (..., envir = parent.frame())
[10:32:50.337]    - tweaked: FALSE
[10:32:50.337]    - call: plan(strategy)
[10:32:50.337] plan(): nbrOfWorkers() = 1
[10:32:50.337] SequentialFuture started (and completed)
[10:32:50.338] - Launch lazy future ... done
[10:32:50.338] run() for ‘SequentialFuture’ ... done
[10:32:50.338] getGlobalsAndPackages() ...
[10:32:50.338] Searching for globals...
[10:32:50.338] 
[10:32:50.338] Searching for globals ... DONE
[10:32:50.338] - globals: [0] <none>
[10:32:50.338] getGlobalsAndPackages() ... DONE
[10:32:50.339] run() for ‘Future’ ...
[10:32:50.339] - state: ‘created’
[10:32:50.339] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.339] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.339] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.339]   - Field: ‘label’
[10:32:50.339]   - Field: ‘local’
[10:32:50.339]   - Field: ‘owner’
[10:32:50.339]   - Field: ‘envir’
[10:32:50.340]   - Field: ‘packages’
[10:32:50.340]   - Field: ‘gc’
[10:32:50.340]   - Field: ‘conditions’
[10:32:50.340]   - Field: ‘expr’
[10:32:50.340]   - Field: ‘uuid’
[10:32:50.340]   - Field: ‘seed’
[10:32:50.340]   - Field: ‘version’
[10:32:50.340]   - Field: ‘result’
[10:32:50.340]   - Field: ‘asynchronous’
[10:32:50.340]   - Field: ‘calls’
[10:32:50.340]   - Field: ‘globals’
[10:32:50.340]   - Field: ‘stdout’
[10:32:50.341]   - Field: ‘earlySignal’
[10:32:50.341]   - Field: ‘lazy’
[10:32:50.341]   - Field: ‘state’
[10:32:50.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.341] - Launch lazy future ...
[10:32:50.341] Packages needed by the future expression (n = 0): <none>
[10:32:50.341] Packages needed by future strategies (n = 0): <none>
[10:32:50.342] {
[10:32:50.342]     {
[10:32:50.342]         {
[10:32:50.342]             ...future.startTime <- base::Sys.time()
[10:32:50.342]             {
[10:32:50.342]                 {
[10:32:50.342]                   {
[10:32:50.342]                     base::local({
[10:32:50.342]                       has_future <- base::requireNamespace("future", 
[10:32:50.342]                         quietly = TRUE)
[10:32:50.342]                       if (has_future) {
[10:32:50.342]                         ns <- base::getNamespace("future")
[10:32:50.342]                         version <- ns[[".package"]][["version"]]
[10:32:50.342]                         if (is.null(version)) 
[10:32:50.342]                           version <- utils::packageVersion("future")
[10:32:50.342]                       }
[10:32:50.342]                       else {
[10:32:50.342]                         version <- NULL
[10:32:50.342]                       }
[10:32:50.342]                       if (!has_future || version < "1.8.0") {
[10:32:50.342]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.342]                           "", base::R.version$version.string), 
[10:32:50.342]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.342]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.342]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.342]                             "release", "version")], collapse = " "), 
[10:32:50.342]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.342]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.342]                           info)
[10:32:50.342]                         info <- base::paste(info, collapse = "; ")
[10:32:50.342]                         if (!has_future) {
[10:32:50.342]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.342]                             info)
[10:32:50.342]                         }
[10:32:50.342]                         else {
[10:32:50.342]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.342]                             info, version)
[10:32:50.342]                         }
[10:32:50.342]                         base::stop(msg)
[10:32:50.342]                       }
[10:32:50.342]                     })
[10:32:50.342]                   }
[10:32:50.342]                   ...future.strategy.old <- future::plan("list")
[10:32:50.342]                   options(future.plan = NULL)
[10:32:50.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.342]                 }
[10:32:50.342]                 ...future.workdir <- getwd()
[10:32:50.342]             }
[10:32:50.342]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.342]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.342]         }
[10:32:50.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.342]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.342]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.342]             base::names(...future.oldOptions))
[10:32:50.342]     }
[10:32:50.342]     if (FALSE) {
[10:32:50.342]     }
[10:32:50.342]     else {
[10:32:50.342]         if (TRUE) {
[10:32:50.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.342]                 open = "w")
[10:32:50.342]         }
[10:32:50.342]         else {
[10:32:50.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.342]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.342]         }
[10:32:50.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.342]             base::sink(type = "output", split = FALSE)
[10:32:50.342]             base::close(...future.stdout)
[10:32:50.342]         }, add = TRUE)
[10:32:50.342]     }
[10:32:50.342]     ...future.frame <- base::sys.nframe()
[10:32:50.342]     ...future.conditions <- base::list()
[10:32:50.342]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.342]     if (FALSE) {
[10:32:50.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.342]     }
[10:32:50.342]     ...future.result <- base::tryCatch({
[10:32:50.342]         base::withCallingHandlers({
[10:32:50.342]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.342]             future::FutureResult(value = ...future.value$value, 
[10:32:50.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.342]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.342]                     ...future.globalenv.names))
[10:32:50.342]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.342]         }, condition = base::local({
[10:32:50.342]             c <- base::c
[10:32:50.342]             inherits <- base::inherits
[10:32:50.342]             invokeRestart <- base::invokeRestart
[10:32:50.342]             length <- base::length
[10:32:50.342]             list <- base::list
[10:32:50.342]             seq.int <- base::seq.int
[10:32:50.342]             signalCondition <- base::signalCondition
[10:32:50.342]             sys.calls <- base::sys.calls
[10:32:50.342]             `[[` <- base::`[[`
[10:32:50.342]             `+` <- base::`+`
[10:32:50.342]             `<<-` <- base::`<<-`
[10:32:50.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.342]                   3L)]
[10:32:50.342]             }
[10:32:50.342]             function(cond) {
[10:32:50.342]                 is_error <- inherits(cond, "error")
[10:32:50.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.342]                   NULL)
[10:32:50.342]                 if (is_error) {
[10:32:50.342]                   sessionInformation <- function() {
[10:32:50.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.342]                       search = base::search(), system = base::Sys.info())
[10:32:50.342]                   }
[10:32:50.342]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.342]                     cond$call), session = sessionInformation(), 
[10:32:50.342]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.342]                   signalCondition(cond)
[10:32:50.342]                 }
[10:32:50.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.342]                 "immediateCondition"))) {
[10:32:50.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.342]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.342]                   if (TRUE && !signal) {
[10:32:50.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.342]                     {
[10:32:50.342]                       inherits <- base::inherits
[10:32:50.342]                       invokeRestart <- base::invokeRestart
[10:32:50.342]                       is.null <- base::is.null
[10:32:50.342]                       muffled <- FALSE
[10:32:50.342]                       if (inherits(cond, "message")) {
[10:32:50.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.342]                         if (muffled) 
[10:32:50.342]                           invokeRestart("muffleMessage")
[10:32:50.342]                       }
[10:32:50.342]                       else if (inherits(cond, "warning")) {
[10:32:50.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.342]                         if (muffled) 
[10:32:50.342]                           invokeRestart("muffleWarning")
[10:32:50.342]                       }
[10:32:50.342]                       else if (inherits(cond, "condition")) {
[10:32:50.342]                         if (!is.null(pattern)) {
[10:32:50.342]                           computeRestarts <- base::computeRestarts
[10:32:50.342]                           grepl <- base::grepl
[10:32:50.342]                           restarts <- computeRestarts(cond)
[10:32:50.342]                           for (restart in restarts) {
[10:32:50.342]                             name <- restart$name
[10:32:50.342]                             if (is.null(name)) 
[10:32:50.342]                               next
[10:32:50.342]                             if (!grepl(pattern, name)) 
[10:32:50.342]                               next
[10:32:50.342]                             invokeRestart(restart)
[10:32:50.342]                             muffled <- TRUE
[10:32:50.342]                             break
[10:32:50.342]                           }
[10:32:50.342]                         }
[10:32:50.342]                       }
[10:32:50.342]                       invisible(muffled)
[10:32:50.342]                     }
[10:32:50.342]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.342]                   }
[10:32:50.342]                 }
[10:32:50.342]                 else {
[10:32:50.342]                   if (TRUE) {
[10:32:50.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.342]                     {
[10:32:50.342]                       inherits <- base::inherits
[10:32:50.342]                       invokeRestart <- base::invokeRestart
[10:32:50.342]                       is.null <- base::is.null
[10:32:50.342]                       muffled <- FALSE
[10:32:50.342]                       if (inherits(cond, "message")) {
[10:32:50.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.342]                         if (muffled) 
[10:32:50.342]                           invokeRestart("muffleMessage")
[10:32:50.342]                       }
[10:32:50.342]                       else if (inherits(cond, "warning")) {
[10:32:50.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.342]                         if (muffled) 
[10:32:50.342]                           invokeRestart("muffleWarning")
[10:32:50.342]                       }
[10:32:50.342]                       else if (inherits(cond, "condition")) {
[10:32:50.342]                         if (!is.null(pattern)) {
[10:32:50.342]                           computeRestarts <- base::computeRestarts
[10:32:50.342]                           grepl <- base::grepl
[10:32:50.342]                           restarts <- computeRestarts(cond)
[10:32:50.342]                           for (restart in restarts) {
[10:32:50.342]                             name <- restart$name
[10:32:50.342]                             if (is.null(name)) 
[10:32:50.342]                               next
[10:32:50.342]                             if (!grepl(pattern, name)) 
[10:32:50.342]                               next
[10:32:50.342]                             invokeRestart(restart)
[10:32:50.342]                             muffled <- TRUE
[10:32:50.342]                             break
[10:32:50.342]                           }
[10:32:50.342]                         }
[10:32:50.342]                       }
[10:32:50.342]                       invisible(muffled)
[10:32:50.342]                     }
[10:32:50.342]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.342]                   }
[10:32:50.342]                 }
[10:32:50.342]             }
[10:32:50.342]         }))
[10:32:50.342]     }, error = function(ex) {
[10:32:50.342]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.342]                 ...future.rng), started = ...future.startTime, 
[10:32:50.342]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.342]             version = "1.8"), class = "FutureResult")
[10:32:50.342]     }, finally = {
[10:32:50.342]         if (!identical(...future.workdir, getwd())) 
[10:32:50.342]             setwd(...future.workdir)
[10:32:50.342]         {
[10:32:50.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.342]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.342]             }
[10:32:50.342]             base::options(...future.oldOptions)
[10:32:50.342]             if (.Platform$OS.type == "windows") {
[10:32:50.342]                 old_names <- names(...future.oldEnvVars)
[10:32:50.342]                 envs <- base::Sys.getenv()
[10:32:50.342]                 names <- names(envs)
[10:32:50.342]                 common <- intersect(names, old_names)
[10:32:50.342]                 added <- setdiff(names, old_names)
[10:32:50.342]                 removed <- setdiff(old_names, names)
[10:32:50.342]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.342]                   envs[common]]
[10:32:50.342]                 NAMES <- toupper(changed)
[10:32:50.342]                 args <- list()
[10:32:50.342]                 for (kk in seq_along(NAMES)) {
[10:32:50.342]                   name <- changed[[kk]]
[10:32:50.342]                   NAME <- NAMES[[kk]]
[10:32:50.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.342]                     next
[10:32:50.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.342]                 }
[10:32:50.342]                 NAMES <- toupper(added)
[10:32:50.342]                 for (kk in seq_along(NAMES)) {
[10:32:50.342]                   name <- added[[kk]]
[10:32:50.342]                   NAME <- NAMES[[kk]]
[10:32:50.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.342]                     next
[10:32:50.342]                   args[[name]] <- ""
[10:32:50.342]                 }
[10:32:50.342]                 NAMES <- toupper(removed)
[10:32:50.342]                 for (kk in seq_along(NAMES)) {
[10:32:50.342]                   name <- removed[[kk]]
[10:32:50.342]                   NAME <- NAMES[[kk]]
[10:32:50.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.342]                     next
[10:32:50.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.342]                 }
[10:32:50.342]                 if (length(args) > 0) 
[10:32:50.342]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.342]             }
[10:32:50.342]             else {
[10:32:50.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.342]             }
[10:32:50.342]             {
[10:32:50.342]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.342]                   0L) {
[10:32:50.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.342]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.342]                   base::options(opts)
[10:32:50.342]                 }
[10:32:50.342]                 {
[10:32:50.342]                   {
[10:32:50.342]                     NULL
[10:32:50.342]                     RNGkind("Mersenne-Twister")
[10:32:50.342]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.342]                       inherits = FALSE)
[10:32:50.342]                   }
[10:32:50.342]                   options(future.plan = NULL)
[10:32:50.342]                   if (is.na(NA_character_)) 
[10:32:50.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.342]                     .init = FALSE)
[10:32:50.342]                 }
[10:32:50.342]             }
[10:32:50.342]         }
[10:32:50.342]     })
[10:32:50.342]     if (TRUE) {
[10:32:50.342]         base::sink(type = "output", split = FALSE)
[10:32:50.342]         if (TRUE) {
[10:32:50.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.342]         }
[10:32:50.342]         else {
[10:32:50.342]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.342]         }
[10:32:50.342]         base::close(...future.stdout)
[10:32:50.342]         ...future.stdout <- NULL
[10:32:50.342]     }
[10:32:50.342]     ...future.result$conditions <- ...future.conditions
[10:32:50.342]     ...future.result$finished <- base::Sys.time()
[10:32:50.342]     ...future.result
[10:32:50.342] }
[10:32:50.343] plan(): Setting new future strategy stack:
[10:32:50.343] List of future strategies:
[10:32:50.343] 1. sequential:
[10:32:50.343]    - args: function (..., envir = parent.frame())
[10:32:50.343]    - tweaked: FALSE
[10:32:50.343]    - call: NULL
[10:32:50.344] plan(): nbrOfWorkers() = 1
[10:32:50.344] plan(): Setting new future strategy stack:
[10:32:50.344] List of future strategies:
[10:32:50.344] 1. sequential:
[10:32:50.344]    - args: function (..., envir = parent.frame())
[10:32:50.344]    - tweaked: FALSE
[10:32:50.344]    - call: plan(strategy)
[10:32:50.345] plan(): nbrOfWorkers() = 1
[10:32:50.345] SequentialFuture started (and completed)
[10:32:50.345] - Launch lazy future ... done
[10:32:50.345] run() for ‘SequentialFuture’ ... done
[10:32:50.345] getGlobalsAndPackages() ...
[10:32:50.345] Searching for globals...
[10:32:50.346] - globals found: [1] ‘{’
[10:32:50.346] Searching for globals ... DONE
[10:32:50.346] Resolving globals: FALSE
[10:32:50.346] 
[10:32:50.347] 
[10:32:50.347] getGlobalsAndPackages() ... DONE
[10:32:50.347] run() for ‘Future’ ...
[10:32:50.347] - state: ‘created’
[10:32:50.347] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.347] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.347]   - Field: ‘label’
[10:32:50.348]   - Field: ‘local’
[10:32:50.348]   - Field: ‘owner’
[10:32:50.348]   - Field: ‘envir’
[10:32:50.348]   - Field: ‘packages’
[10:32:50.348]   - Field: ‘gc’
[10:32:50.348]   - Field: ‘conditions’
[10:32:50.348]   - Field: ‘expr’
[10:32:50.348]   - Field: ‘uuid’
[10:32:50.348]   - Field: ‘seed’
[10:32:50.348]   - Field: ‘version’
[10:32:50.348]   - Field: ‘result’
[10:32:50.349]   - Field: ‘asynchronous’
[10:32:50.349]   - Field: ‘calls’
[10:32:50.349]   - Field: ‘globals’
[10:32:50.349]   - Field: ‘stdout’
[10:32:50.349]   - Field: ‘earlySignal’
[10:32:50.349]   - Field: ‘lazy’
[10:32:50.349]   - Field: ‘state’
[10:32:50.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.349] - Launch lazy future ...
[10:32:50.349] Packages needed by the future expression (n = 0): <none>
[10:32:50.350] Packages needed by future strategies (n = 0): <none>
[10:32:50.350] {
[10:32:50.350]     {
[10:32:50.350]         {
[10:32:50.350]             ...future.startTime <- base::Sys.time()
[10:32:50.350]             {
[10:32:50.350]                 {
[10:32:50.350]                   {
[10:32:50.350]                     base::local({
[10:32:50.350]                       has_future <- base::requireNamespace("future", 
[10:32:50.350]                         quietly = TRUE)
[10:32:50.350]                       if (has_future) {
[10:32:50.350]                         ns <- base::getNamespace("future")
[10:32:50.350]                         version <- ns[[".package"]][["version"]]
[10:32:50.350]                         if (is.null(version)) 
[10:32:50.350]                           version <- utils::packageVersion("future")
[10:32:50.350]                       }
[10:32:50.350]                       else {
[10:32:50.350]                         version <- NULL
[10:32:50.350]                       }
[10:32:50.350]                       if (!has_future || version < "1.8.0") {
[10:32:50.350]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.350]                           "", base::R.version$version.string), 
[10:32:50.350]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.350]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.350]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.350]                             "release", "version")], collapse = " "), 
[10:32:50.350]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.350]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.350]                           info)
[10:32:50.350]                         info <- base::paste(info, collapse = "; ")
[10:32:50.350]                         if (!has_future) {
[10:32:50.350]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.350]                             info)
[10:32:50.350]                         }
[10:32:50.350]                         else {
[10:32:50.350]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.350]                             info, version)
[10:32:50.350]                         }
[10:32:50.350]                         base::stop(msg)
[10:32:50.350]                       }
[10:32:50.350]                     })
[10:32:50.350]                   }
[10:32:50.350]                   ...future.strategy.old <- future::plan("list")
[10:32:50.350]                   options(future.plan = NULL)
[10:32:50.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.350]                 }
[10:32:50.350]                 ...future.workdir <- getwd()
[10:32:50.350]             }
[10:32:50.350]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.350]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.350]         }
[10:32:50.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.350]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.350]             base::names(...future.oldOptions))
[10:32:50.350]     }
[10:32:50.350]     if (FALSE) {
[10:32:50.350]     }
[10:32:50.350]     else {
[10:32:50.350]         if (TRUE) {
[10:32:50.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.350]                 open = "w")
[10:32:50.350]         }
[10:32:50.350]         else {
[10:32:50.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.350]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.350]         }
[10:32:50.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.350]             base::sink(type = "output", split = FALSE)
[10:32:50.350]             base::close(...future.stdout)
[10:32:50.350]         }, add = TRUE)
[10:32:50.350]     }
[10:32:50.350]     ...future.frame <- base::sys.nframe()
[10:32:50.350]     ...future.conditions <- base::list()
[10:32:50.350]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.350]     if (FALSE) {
[10:32:50.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.350]     }
[10:32:50.350]     ...future.result <- base::tryCatch({
[10:32:50.350]         base::withCallingHandlers({
[10:32:50.350]             ...future.value <- base::withVisible(base::local({
[10:32:50.350]                 4
[10:32:50.350]             }))
[10:32:50.350]             future::FutureResult(value = ...future.value$value, 
[10:32:50.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.350]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.350]                     ...future.globalenv.names))
[10:32:50.350]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.350]         }, condition = base::local({
[10:32:50.350]             c <- base::c
[10:32:50.350]             inherits <- base::inherits
[10:32:50.350]             invokeRestart <- base::invokeRestart
[10:32:50.350]             length <- base::length
[10:32:50.350]             list <- base::list
[10:32:50.350]             seq.int <- base::seq.int
[10:32:50.350]             signalCondition <- base::signalCondition
[10:32:50.350]             sys.calls <- base::sys.calls
[10:32:50.350]             `[[` <- base::`[[`
[10:32:50.350]             `+` <- base::`+`
[10:32:50.350]             `<<-` <- base::`<<-`
[10:32:50.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.350]                   3L)]
[10:32:50.350]             }
[10:32:50.350]             function(cond) {
[10:32:50.350]                 is_error <- inherits(cond, "error")
[10:32:50.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.350]                   NULL)
[10:32:50.350]                 if (is_error) {
[10:32:50.350]                   sessionInformation <- function() {
[10:32:50.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.350]                       search = base::search(), system = base::Sys.info())
[10:32:50.350]                   }
[10:32:50.350]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.350]                     cond$call), session = sessionInformation(), 
[10:32:50.350]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.350]                   signalCondition(cond)
[10:32:50.350]                 }
[10:32:50.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.350]                 "immediateCondition"))) {
[10:32:50.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.350]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.350]                   if (TRUE && !signal) {
[10:32:50.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.350]                     {
[10:32:50.350]                       inherits <- base::inherits
[10:32:50.350]                       invokeRestart <- base::invokeRestart
[10:32:50.350]                       is.null <- base::is.null
[10:32:50.350]                       muffled <- FALSE
[10:32:50.350]                       if (inherits(cond, "message")) {
[10:32:50.350]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.350]                         if (muffled) 
[10:32:50.350]                           invokeRestart("muffleMessage")
[10:32:50.350]                       }
[10:32:50.350]                       else if (inherits(cond, "warning")) {
[10:32:50.350]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.350]                         if (muffled) 
[10:32:50.350]                           invokeRestart("muffleWarning")
[10:32:50.350]                       }
[10:32:50.350]                       else if (inherits(cond, "condition")) {
[10:32:50.350]                         if (!is.null(pattern)) {
[10:32:50.350]                           computeRestarts <- base::computeRestarts
[10:32:50.350]                           grepl <- base::grepl
[10:32:50.350]                           restarts <- computeRestarts(cond)
[10:32:50.350]                           for (restart in restarts) {
[10:32:50.350]                             name <- restart$name
[10:32:50.350]                             if (is.null(name)) 
[10:32:50.350]                               next
[10:32:50.350]                             if (!grepl(pattern, name)) 
[10:32:50.350]                               next
[10:32:50.350]                             invokeRestart(restart)
[10:32:50.350]                             muffled <- TRUE
[10:32:50.350]                             break
[10:32:50.350]                           }
[10:32:50.350]                         }
[10:32:50.350]                       }
[10:32:50.350]                       invisible(muffled)
[10:32:50.350]                     }
[10:32:50.350]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.350]                   }
[10:32:50.350]                 }
[10:32:50.350]                 else {
[10:32:50.350]                   if (TRUE) {
[10:32:50.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.350]                     {
[10:32:50.350]                       inherits <- base::inherits
[10:32:50.350]                       invokeRestart <- base::invokeRestart
[10:32:50.350]                       is.null <- base::is.null
[10:32:50.350]                       muffled <- FALSE
[10:32:50.350]                       if (inherits(cond, "message")) {
[10:32:50.350]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.350]                         if (muffled) 
[10:32:50.350]                           invokeRestart("muffleMessage")
[10:32:50.350]                       }
[10:32:50.350]                       else if (inherits(cond, "warning")) {
[10:32:50.350]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.350]                         if (muffled) 
[10:32:50.350]                           invokeRestart("muffleWarning")
[10:32:50.350]                       }
[10:32:50.350]                       else if (inherits(cond, "condition")) {
[10:32:50.350]                         if (!is.null(pattern)) {
[10:32:50.350]                           computeRestarts <- base::computeRestarts
[10:32:50.350]                           grepl <- base::grepl
[10:32:50.350]                           restarts <- computeRestarts(cond)
[10:32:50.350]                           for (restart in restarts) {
[10:32:50.350]                             name <- restart$name
[10:32:50.350]                             if (is.null(name)) 
[10:32:50.350]                               next
[10:32:50.350]                             if (!grepl(pattern, name)) 
[10:32:50.350]                               next
[10:32:50.350]                             invokeRestart(restart)
[10:32:50.350]                             muffled <- TRUE
[10:32:50.350]                             break
[10:32:50.350]                           }
[10:32:50.350]                         }
[10:32:50.350]                       }
[10:32:50.350]                       invisible(muffled)
[10:32:50.350]                     }
[10:32:50.350]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.350]                   }
[10:32:50.350]                 }
[10:32:50.350]             }
[10:32:50.350]         }))
[10:32:50.350]     }, error = function(ex) {
[10:32:50.350]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.350]                 ...future.rng), started = ...future.startTime, 
[10:32:50.350]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.350]             version = "1.8"), class = "FutureResult")
[10:32:50.350]     }, finally = {
[10:32:50.350]         if (!identical(...future.workdir, getwd())) 
[10:32:50.350]             setwd(...future.workdir)
[10:32:50.350]         {
[10:32:50.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.350]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.350]             }
[10:32:50.350]             base::options(...future.oldOptions)
[10:32:50.350]             if (.Platform$OS.type == "windows") {
[10:32:50.350]                 old_names <- names(...future.oldEnvVars)
[10:32:50.350]                 envs <- base::Sys.getenv()
[10:32:50.350]                 names <- names(envs)
[10:32:50.350]                 common <- intersect(names, old_names)
[10:32:50.350]                 added <- setdiff(names, old_names)
[10:32:50.350]                 removed <- setdiff(old_names, names)
[10:32:50.350]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.350]                   envs[common]]
[10:32:50.350]                 NAMES <- toupper(changed)
[10:32:50.350]                 args <- list()
[10:32:50.350]                 for (kk in seq_along(NAMES)) {
[10:32:50.350]                   name <- changed[[kk]]
[10:32:50.350]                   NAME <- NAMES[[kk]]
[10:32:50.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.350]                     next
[10:32:50.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.350]                 }
[10:32:50.350]                 NAMES <- toupper(added)
[10:32:50.350]                 for (kk in seq_along(NAMES)) {
[10:32:50.350]                   name <- added[[kk]]
[10:32:50.350]                   NAME <- NAMES[[kk]]
[10:32:50.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.350]                     next
[10:32:50.350]                   args[[name]] <- ""
[10:32:50.350]                 }
[10:32:50.350]                 NAMES <- toupper(removed)
[10:32:50.350]                 for (kk in seq_along(NAMES)) {
[10:32:50.350]                   name <- removed[[kk]]
[10:32:50.350]                   NAME <- NAMES[[kk]]
[10:32:50.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.350]                     next
[10:32:50.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.350]                 }
[10:32:50.350]                 if (length(args) > 0) 
[10:32:50.350]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.350]             }
[10:32:50.350]             else {
[10:32:50.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.350]             }
[10:32:50.350]             {
[10:32:50.350]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.350]                   0L) {
[10:32:50.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.350]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.350]                   base::options(opts)
[10:32:50.350]                 }
[10:32:50.350]                 {
[10:32:50.350]                   {
[10:32:50.350]                     NULL
[10:32:50.350]                     RNGkind("Mersenne-Twister")
[10:32:50.350]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.350]                       inherits = FALSE)
[10:32:50.350]                   }
[10:32:50.350]                   options(future.plan = NULL)
[10:32:50.350]                   if (is.na(NA_character_)) 
[10:32:50.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.350]                     .init = FALSE)
[10:32:50.350]                 }
[10:32:50.350]             }
[10:32:50.350]         }
[10:32:50.350]     })
[10:32:50.350]     if (TRUE) {
[10:32:50.350]         base::sink(type = "output", split = FALSE)
[10:32:50.350]         if (TRUE) {
[10:32:50.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.350]         }
[10:32:50.350]         else {
[10:32:50.350]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.350]         }
[10:32:50.350]         base::close(...future.stdout)
[10:32:50.350]         ...future.stdout <- NULL
[10:32:50.350]     }
[10:32:50.350]     ...future.result$conditions <- ...future.conditions
[10:32:50.350]     ...future.result$finished <- base::Sys.time()
[10:32:50.350]     ...future.result
[10:32:50.350] }
[10:32:50.352] plan(): Setting new future strategy stack:
[10:32:50.352] List of future strategies:
[10:32:50.352] 1. sequential:
[10:32:50.352]    - args: function (..., envir = parent.frame())
[10:32:50.352]    - tweaked: FALSE
[10:32:50.352]    - call: NULL
[10:32:50.352] plan(): nbrOfWorkers() = 1
[10:32:50.355] plan(): Setting new future strategy stack:
[10:32:50.355] List of future strategies:
[10:32:50.355] 1. sequential:
[10:32:50.355]    - args: function (..., envir = parent.frame())
[10:32:50.355]    - tweaked: FALSE
[10:32:50.355]    - call: plan(strategy)
[10:32:50.355] plan(): nbrOfWorkers() = 1
[10:32:50.355] SequentialFuture started (and completed)
[10:32:50.355] - Launch lazy future ... done
[10:32:50.355] run() for ‘SequentialFuture’ ... done
<environment: 0x5652cf245228> 
<environment: 0x5652cf9a2ae0> 
[10:32:50.357] resolved() for ‘SequentialFuture’ ...
[10:32:50.357] - state: ‘finished’
[10:32:50.357] - run: TRUE
[10:32:50.357] - result: ‘FutureResult’
[10:32:50.357] resolved() for ‘SequentialFuture’ ... done
[10:32:50.357] resolved() for ‘SequentialFuture’ ...
[10:32:50.357] - state: ‘finished’
[10:32:50.357] - run: TRUE
[10:32:50.357] - result: ‘FutureResult’
[10:32:50.358] resolved() for ‘SequentialFuture’ ... done
[10:32:50.358] resolved() for ‘SequentialFuture’ ...
[10:32:50.358] - state: ‘finished’
[10:32:50.358] - run: TRUE
[10:32:50.358] - result: ‘FutureResult’
[10:32:50.358] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:50.359] resolve() on environment ...
[10:32:50.359]  recursive: 0
[10:32:50.360]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:50.360] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.360] - nx: 4
[10:32:50.360] - relay: TRUE
[10:32:50.360] - stdout: TRUE
[10:32:50.360] - signal: TRUE
[10:32:50.360] - resignal: FALSE
[10:32:50.360] - force: TRUE
[10:32:50.360] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.360] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.361]  - until=2
[10:32:50.361]  - relaying element #2
[10:32:50.361] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.361] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.361] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.361]  length: 3 (resolved future 1)
[10:32:50.361] resolved() for ‘SequentialFuture’ ...
[10:32:50.361] - state: ‘finished’
[10:32:50.361] - run: TRUE
[10:32:50.361] - result: ‘FutureResult’
[10:32:50.362] resolved() for ‘SequentialFuture’ ... done
[10:32:50.362] Future #2
[10:32:50.362] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.362] - nx: 4
[10:32:50.362] - relay: TRUE
[10:32:50.362] - stdout: TRUE
[10:32:50.362] - signal: TRUE
[10:32:50.362] - resignal: FALSE
[10:32:50.362] - force: TRUE
[10:32:50.362] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:50.362] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:50.363]  - until=2
[10:32:50.363]  - relaying element #2
[10:32:50.363] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.363] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.363] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.363]  length: 2 (resolved future 2)
[10:32:50.363] resolved() for ‘SequentialFuture’ ...
[10:32:50.363] - state: ‘finished’
[10:32:50.363] - run: TRUE
[10:32:50.363] - result: ‘FutureResult’
[10:32:50.364] resolved() for ‘SequentialFuture’ ... done
[10:32:50.364] Future #3
[10:32:50.364] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.364] - nx: 4
[10:32:50.364] - relay: TRUE
[10:32:50.364] - stdout: TRUE
[10:32:50.364] - signal: TRUE
[10:32:50.364] - resignal: FALSE
[10:32:50.364] - force: TRUE
[10:32:50.364] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:50.364] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:50.364]  - until=3
[10:32:50.365]  - relaying element #3
[10:32:50.365] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.365] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.365] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.365]  length: 1 (resolved future 3)
[10:32:50.365] resolved() for ‘SequentialFuture’ ...
[10:32:50.365] - state: ‘finished’
[10:32:50.365] - run: TRUE
[10:32:50.365] - result: ‘FutureResult’
[10:32:50.365] resolved() for ‘SequentialFuture’ ... done
[10:32:50.366] Future #4
[10:32:50.366] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.366] - nx: 4
[10:32:50.366] - relay: TRUE
[10:32:50.366] - stdout: TRUE
[10:32:50.366] - signal: TRUE
[10:32:50.366] - resignal: FALSE
[10:32:50.366] - force: TRUE
[10:32:50.366] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:50.366] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:50.366]  - until=4
[10:32:50.367]  - relaying element #4
[10:32:50.367] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.367] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.367] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.367]  length: 0 (resolved future 4)
[10:32:50.367] Relaying remaining futures
[10:32:50.367] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.367] - nx: 4
[10:32:50.367] - relay: TRUE
[10:32:50.367] - stdout: TRUE
[10:32:50.367] - signal: TRUE
[10:32:50.368] - resignal: FALSE
[10:32:50.368] - force: TRUE
[10:32:50.368] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.368] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:50.368] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:50.368] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:50.368] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.368] resolve() on environment ... DONE
<environment: 0x5652cfb75128> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[10:32:50.369] plan(): Setting new future strategy stack:
[10:32:50.369] List of future strategies:
[10:32:50.369] 1. sequential:
[10:32:50.369]    - args: function (..., envir = parent.frame())
[10:32:50.369]    - tweaked: FALSE
[10:32:50.369]    - call: plan(strategy)
[10:32:50.369] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:32:50.370] getGlobalsAndPackages() ...
[10:32:50.370] Searching for globals...
[10:32:50.370] 
[10:32:50.370] Searching for globals ... DONE
[10:32:50.370] - globals: [0] <none>
[10:32:50.370] getGlobalsAndPackages() ... DONE
[10:32:50.371] run() for ‘Future’ ...
[10:32:50.371] - state: ‘created’
[10:32:50.371] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.371]   - Field: ‘label’
[10:32:50.371]   - Field: ‘local’
[10:32:50.371]   - Field: ‘owner’
[10:32:50.372]   - Field: ‘envir’
[10:32:50.372]   - Field: ‘packages’
[10:32:50.372]   - Field: ‘gc’
[10:32:50.372]   - Field: ‘conditions’
[10:32:50.372]   - Field: ‘expr’
[10:32:50.372]   - Field: ‘uuid’
[10:32:50.372]   - Field: ‘seed’
[10:32:50.372]   - Field: ‘version’
[10:32:50.372]   - Field: ‘result’
[10:32:50.372]   - Field: ‘asynchronous’
[10:32:50.372]   - Field: ‘calls’
[10:32:50.373]   - Field: ‘globals’
[10:32:50.373]   - Field: ‘stdout’
[10:32:50.373]   - Field: ‘earlySignal’
[10:32:50.373]   - Field: ‘lazy’
[10:32:50.373]   - Field: ‘state’
[10:32:50.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.373] - Launch lazy future ...
[10:32:50.373] Packages needed by the future expression (n = 0): <none>
[10:32:50.373] Packages needed by future strategies (n = 0): <none>
[10:32:50.374] {
[10:32:50.374]     {
[10:32:50.374]         {
[10:32:50.374]             ...future.startTime <- base::Sys.time()
[10:32:50.374]             {
[10:32:50.374]                 {
[10:32:50.374]                   {
[10:32:50.374]                     base::local({
[10:32:50.374]                       has_future <- base::requireNamespace("future", 
[10:32:50.374]                         quietly = TRUE)
[10:32:50.374]                       if (has_future) {
[10:32:50.374]                         ns <- base::getNamespace("future")
[10:32:50.374]                         version <- ns[[".package"]][["version"]]
[10:32:50.374]                         if (is.null(version)) 
[10:32:50.374]                           version <- utils::packageVersion("future")
[10:32:50.374]                       }
[10:32:50.374]                       else {
[10:32:50.374]                         version <- NULL
[10:32:50.374]                       }
[10:32:50.374]                       if (!has_future || version < "1.8.0") {
[10:32:50.374]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.374]                           "", base::R.version$version.string), 
[10:32:50.374]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.374]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.374]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.374]                             "release", "version")], collapse = " "), 
[10:32:50.374]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.374]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.374]                           info)
[10:32:50.374]                         info <- base::paste(info, collapse = "; ")
[10:32:50.374]                         if (!has_future) {
[10:32:50.374]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.374]                             info)
[10:32:50.374]                         }
[10:32:50.374]                         else {
[10:32:50.374]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.374]                             info, version)
[10:32:50.374]                         }
[10:32:50.374]                         base::stop(msg)
[10:32:50.374]                       }
[10:32:50.374]                     })
[10:32:50.374]                   }
[10:32:50.374]                   ...future.strategy.old <- future::plan("list")
[10:32:50.374]                   options(future.plan = NULL)
[10:32:50.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.374]                 }
[10:32:50.374]                 ...future.workdir <- getwd()
[10:32:50.374]             }
[10:32:50.374]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.374]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.374]         }
[10:32:50.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.374]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.374]             base::names(...future.oldOptions))
[10:32:50.374]     }
[10:32:50.374]     if (FALSE) {
[10:32:50.374]     }
[10:32:50.374]     else {
[10:32:50.374]         if (TRUE) {
[10:32:50.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.374]                 open = "w")
[10:32:50.374]         }
[10:32:50.374]         else {
[10:32:50.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.374]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.374]         }
[10:32:50.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.374]             base::sink(type = "output", split = FALSE)
[10:32:50.374]             base::close(...future.stdout)
[10:32:50.374]         }, add = TRUE)
[10:32:50.374]     }
[10:32:50.374]     ...future.frame <- base::sys.nframe()
[10:32:50.374]     ...future.conditions <- base::list()
[10:32:50.374]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.374]     if (FALSE) {
[10:32:50.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.374]     }
[10:32:50.374]     ...future.result <- base::tryCatch({
[10:32:50.374]         base::withCallingHandlers({
[10:32:50.374]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.374]             future::FutureResult(value = ...future.value$value, 
[10:32:50.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.374]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.374]                     ...future.globalenv.names))
[10:32:50.374]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.374]         }, condition = base::local({
[10:32:50.374]             c <- base::c
[10:32:50.374]             inherits <- base::inherits
[10:32:50.374]             invokeRestart <- base::invokeRestart
[10:32:50.374]             length <- base::length
[10:32:50.374]             list <- base::list
[10:32:50.374]             seq.int <- base::seq.int
[10:32:50.374]             signalCondition <- base::signalCondition
[10:32:50.374]             sys.calls <- base::sys.calls
[10:32:50.374]             `[[` <- base::`[[`
[10:32:50.374]             `+` <- base::`+`
[10:32:50.374]             `<<-` <- base::`<<-`
[10:32:50.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.374]                   3L)]
[10:32:50.374]             }
[10:32:50.374]             function(cond) {
[10:32:50.374]                 is_error <- inherits(cond, "error")
[10:32:50.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.374]                   NULL)
[10:32:50.374]                 if (is_error) {
[10:32:50.374]                   sessionInformation <- function() {
[10:32:50.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.374]                       search = base::search(), system = base::Sys.info())
[10:32:50.374]                   }
[10:32:50.374]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.374]                     cond$call), session = sessionInformation(), 
[10:32:50.374]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.374]                   signalCondition(cond)
[10:32:50.374]                 }
[10:32:50.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.374]                 "immediateCondition"))) {
[10:32:50.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.374]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.374]                   if (TRUE && !signal) {
[10:32:50.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.374]                     {
[10:32:50.374]                       inherits <- base::inherits
[10:32:50.374]                       invokeRestart <- base::invokeRestart
[10:32:50.374]                       is.null <- base::is.null
[10:32:50.374]                       muffled <- FALSE
[10:32:50.374]                       if (inherits(cond, "message")) {
[10:32:50.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.374]                         if (muffled) 
[10:32:50.374]                           invokeRestart("muffleMessage")
[10:32:50.374]                       }
[10:32:50.374]                       else if (inherits(cond, "warning")) {
[10:32:50.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.374]                         if (muffled) 
[10:32:50.374]                           invokeRestart("muffleWarning")
[10:32:50.374]                       }
[10:32:50.374]                       else if (inherits(cond, "condition")) {
[10:32:50.374]                         if (!is.null(pattern)) {
[10:32:50.374]                           computeRestarts <- base::computeRestarts
[10:32:50.374]                           grepl <- base::grepl
[10:32:50.374]                           restarts <- computeRestarts(cond)
[10:32:50.374]                           for (restart in restarts) {
[10:32:50.374]                             name <- restart$name
[10:32:50.374]                             if (is.null(name)) 
[10:32:50.374]                               next
[10:32:50.374]                             if (!grepl(pattern, name)) 
[10:32:50.374]                               next
[10:32:50.374]                             invokeRestart(restart)
[10:32:50.374]                             muffled <- TRUE
[10:32:50.374]                             break
[10:32:50.374]                           }
[10:32:50.374]                         }
[10:32:50.374]                       }
[10:32:50.374]                       invisible(muffled)
[10:32:50.374]                     }
[10:32:50.374]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.374]                   }
[10:32:50.374]                 }
[10:32:50.374]                 else {
[10:32:50.374]                   if (TRUE) {
[10:32:50.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.374]                     {
[10:32:50.374]                       inherits <- base::inherits
[10:32:50.374]                       invokeRestart <- base::invokeRestart
[10:32:50.374]                       is.null <- base::is.null
[10:32:50.374]                       muffled <- FALSE
[10:32:50.374]                       if (inherits(cond, "message")) {
[10:32:50.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.374]                         if (muffled) 
[10:32:50.374]                           invokeRestart("muffleMessage")
[10:32:50.374]                       }
[10:32:50.374]                       else if (inherits(cond, "warning")) {
[10:32:50.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.374]                         if (muffled) 
[10:32:50.374]                           invokeRestart("muffleWarning")
[10:32:50.374]                       }
[10:32:50.374]                       else if (inherits(cond, "condition")) {
[10:32:50.374]                         if (!is.null(pattern)) {
[10:32:50.374]                           computeRestarts <- base::computeRestarts
[10:32:50.374]                           grepl <- base::grepl
[10:32:50.374]                           restarts <- computeRestarts(cond)
[10:32:50.374]                           for (restart in restarts) {
[10:32:50.374]                             name <- restart$name
[10:32:50.374]                             if (is.null(name)) 
[10:32:50.374]                               next
[10:32:50.374]                             if (!grepl(pattern, name)) 
[10:32:50.374]                               next
[10:32:50.374]                             invokeRestart(restart)
[10:32:50.374]                             muffled <- TRUE
[10:32:50.374]                             break
[10:32:50.374]                           }
[10:32:50.374]                         }
[10:32:50.374]                       }
[10:32:50.374]                       invisible(muffled)
[10:32:50.374]                     }
[10:32:50.374]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.374]                   }
[10:32:50.374]                 }
[10:32:50.374]             }
[10:32:50.374]         }))
[10:32:50.374]     }, error = function(ex) {
[10:32:50.374]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.374]                 ...future.rng), started = ...future.startTime, 
[10:32:50.374]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.374]             version = "1.8"), class = "FutureResult")
[10:32:50.374]     }, finally = {
[10:32:50.374]         if (!identical(...future.workdir, getwd())) 
[10:32:50.374]             setwd(...future.workdir)
[10:32:50.374]         {
[10:32:50.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.374]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.374]             }
[10:32:50.374]             base::options(...future.oldOptions)
[10:32:50.374]             if (.Platform$OS.type == "windows") {
[10:32:50.374]                 old_names <- names(...future.oldEnvVars)
[10:32:50.374]                 envs <- base::Sys.getenv()
[10:32:50.374]                 names <- names(envs)
[10:32:50.374]                 common <- intersect(names, old_names)
[10:32:50.374]                 added <- setdiff(names, old_names)
[10:32:50.374]                 removed <- setdiff(old_names, names)
[10:32:50.374]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.374]                   envs[common]]
[10:32:50.374]                 NAMES <- toupper(changed)
[10:32:50.374]                 args <- list()
[10:32:50.374]                 for (kk in seq_along(NAMES)) {
[10:32:50.374]                   name <- changed[[kk]]
[10:32:50.374]                   NAME <- NAMES[[kk]]
[10:32:50.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.374]                     next
[10:32:50.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.374]                 }
[10:32:50.374]                 NAMES <- toupper(added)
[10:32:50.374]                 for (kk in seq_along(NAMES)) {
[10:32:50.374]                   name <- added[[kk]]
[10:32:50.374]                   NAME <- NAMES[[kk]]
[10:32:50.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.374]                     next
[10:32:50.374]                   args[[name]] <- ""
[10:32:50.374]                 }
[10:32:50.374]                 NAMES <- toupper(removed)
[10:32:50.374]                 for (kk in seq_along(NAMES)) {
[10:32:50.374]                   name <- removed[[kk]]
[10:32:50.374]                   NAME <- NAMES[[kk]]
[10:32:50.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.374]                     next
[10:32:50.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.374]                 }
[10:32:50.374]                 if (length(args) > 0) 
[10:32:50.374]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.374]             }
[10:32:50.374]             else {
[10:32:50.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.374]             }
[10:32:50.374]             {
[10:32:50.374]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.374]                   0L) {
[10:32:50.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.374]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.374]                   base::options(opts)
[10:32:50.374]                 }
[10:32:50.374]                 {
[10:32:50.374]                   {
[10:32:50.374]                     NULL
[10:32:50.374]                     RNGkind("Mersenne-Twister")
[10:32:50.374]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.374]                       inherits = FALSE)
[10:32:50.374]                   }
[10:32:50.374]                   options(future.plan = NULL)
[10:32:50.374]                   if (is.na(NA_character_)) 
[10:32:50.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.374]                     .init = FALSE)
[10:32:50.374]                 }
[10:32:50.374]             }
[10:32:50.374]         }
[10:32:50.374]     })
[10:32:50.374]     if (TRUE) {
[10:32:50.374]         base::sink(type = "output", split = FALSE)
[10:32:50.374]         if (TRUE) {
[10:32:50.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.374]         }
[10:32:50.374]         else {
[10:32:50.374]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.374]         }
[10:32:50.374]         base::close(...future.stdout)
[10:32:50.374]         ...future.stdout <- NULL
[10:32:50.374]     }
[10:32:50.374]     ...future.result$conditions <- ...future.conditions
[10:32:50.374]     ...future.result$finished <- base::Sys.time()
[10:32:50.374]     ...future.result
[10:32:50.374] }
[10:32:50.375] plan(): Setting new future strategy stack:
[10:32:50.376] List of future strategies:
[10:32:50.376] 1. sequential:
[10:32:50.376]    - args: function (..., envir = parent.frame())
[10:32:50.376]    - tweaked: FALSE
[10:32:50.376]    - call: NULL
[10:32:50.376] plan(): nbrOfWorkers() = 1
[10:32:50.376] plan(): Setting new future strategy stack:
[10:32:50.377] List of future strategies:
[10:32:50.377] 1. sequential:
[10:32:50.377]    - args: function (..., envir = parent.frame())
[10:32:50.377]    - tweaked: FALSE
[10:32:50.377]    - call: plan(strategy)
[10:32:50.377] plan(): nbrOfWorkers() = 1
[10:32:50.377] SequentialFuture started (and completed)
[10:32:50.377] - Launch lazy future ... done
[10:32:50.377] run() for ‘SequentialFuture’ ... done
[10:32:50.377] getGlobalsAndPackages() ...
[10:32:50.378] Searching for globals...
[10:32:50.379] 
[10:32:50.379] Searching for globals ... DONE
[10:32:50.379] - globals: [0] <none>
[10:32:50.379] getGlobalsAndPackages() ... DONE
[10:32:50.379] run() for ‘Future’ ...
[10:32:50.379] - state: ‘created’
[10:32:50.380] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.380]   - Field: ‘label’
[10:32:50.380]   - Field: ‘local’
[10:32:50.380]   - Field: ‘owner’
[10:32:50.380]   - Field: ‘envir’
[10:32:50.380]   - Field: ‘packages’
[10:32:50.381]   - Field: ‘gc’
[10:32:50.381]   - Field: ‘conditions’
[10:32:50.381]   - Field: ‘expr’
[10:32:50.381]   - Field: ‘uuid’
[10:32:50.381]   - Field: ‘seed’
[10:32:50.381]   - Field: ‘version’
[10:32:50.381]   - Field: ‘result’
[10:32:50.381]   - Field: ‘asynchronous’
[10:32:50.381]   - Field: ‘calls’
[10:32:50.381]   - Field: ‘globals’
[10:32:50.381]   - Field: ‘stdout’
[10:32:50.381]   - Field: ‘earlySignal’
[10:32:50.382]   - Field: ‘lazy’
[10:32:50.382]   - Field: ‘state’
[10:32:50.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.382] - Launch lazy future ...
[10:32:50.382] Packages needed by the future expression (n = 0): <none>
[10:32:50.382] Packages needed by future strategies (n = 0): <none>
[10:32:50.382] {
[10:32:50.382]     {
[10:32:50.382]         {
[10:32:50.382]             ...future.startTime <- base::Sys.time()
[10:32:50.382]             {
[10:32:50.382]                 {
[10:32:50.382]                   {
[10:32:50.382]                     base::local({
[10:32:50.382]                       has_future <- base::requireNamespace("future", 
[10:32:50.382]                         quietly = TRUE)
[10:32:50.382]                       if (has_future) {
[10:32:50.382]                         ns <- base::getNamespace("future")
[10:32:50.382]                         version <- ns[[".package"]][["version"]]
[10:32:50.382]                         if (is.null(version)) 
[10:32:50.382]                           version <- utils::packageVersion("future")
[10:32:50.382]                       }
[10:32:50.382]                       else {
[10:32:50.382]                         version <- NULL
[10:32:50.382]                       }
[10:32:50.382]                       if (!has_future || version < "1.8.0") {
[10:32:50.382]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.382]                           "", base::R.version$version.string), 
[10:32:50.382]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.382]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.382]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.382]                             "release", "version")], collapse = " "), 
[10:32:50.382]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.382]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.382]                           info)
[10:32:50.382]                         info <- base::paste(info, collapse = "; ")
[10:32:50.382]                         if (!has_future) {
[10:32:50.382]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.382]                             info)
[10:32:50.382]                         }
[10:32:50.382]                         else {
[10:32:50.382]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.382]                             info, version)
[10:32:50.382]                         }
[10:32:50.382]                         base::stop(msg)
[10:32:50.382]                       }
[10:32:50.382]                     })
[10:32:50.382]                   }
[10:32:50.382]                   ...future.strategy.old <- future::plan("list")
[10:32:50.382]                   options(future.plan = NULL)
[10:32:50.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.382]                 }
[10:32:50.382]                 ...future.workdir <- getwd()
[10:32:50.382]             }
[10:32:50.382]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.382]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.382]         }
[10:32:50.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.382]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.382]             base::names(...future.oldOptions))
[10:32:50.382]     }
[10:32:50.382]     if (FALSE) {
[10:32:50.382]     }
[10:32:50.382]     else {
[10:32:50.382]         if (TRUE) {
[10:32:50.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.382]                 open = "w")
[10:32:50.382]         }
[10:32:50.382]         else {
[10:32:50.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.382]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.382]         }
[10:32:50.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.382]             base::sink(type = "output", split = FALSE)
[10:32:50.382]             base::close(...future.stdout)
[10:32:50.382]         }, add = TRUE)
[10:32:50.382]     }
[10:32:50.382]     ...future.frame <- base::sys.nframe()
[10:32:50.382]     ...future.conditions <- base::list()
[10:32:50.382]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.382]     if (FALSE) {
[10:32:50.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.382]     }
[10:32:50.382]     ...future.result <- base::tryCatch({
[10:32:50.382]         base::withCallingHandlers({
[10:32:50.382]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.382]             future::FutureResult(value = ...future.value$value, 
[10:32:50.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.382]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.382]                     ...future.globalenv.names))
[10:32:50.382]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.382]         }, condition = base::local({
[10:32:50.382]             c <- base::c
[10:32:50.382]             inherits <- base::inherits
[10:32:50.382]             invokeRestart <- base::invokeRestart
[10:32:50.382]             length <- base::length
[10:32:50.382]             list <- base::list
[10:32:50.382]             seq.int <- base::seq.int
[10:32:50.382]             signalCondition <- base::signalCondition
[10:32:50.382]             sys.calls <- base::sys.calls
[10:32:50.382]             `[[` <- base::`[[`
[10:32:50.382]             `+` <- base::`+`
[10:32:50.382]             `<<-` <- base::`<<-`
[10:32:50.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.382]                   3L)]
[10:32:50.382]             }
[10:32:50.382]             function(cond) {
[10:32:50.382]                 is_error <- inherits(cond, "error")
[10:32:50.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.382]                   NULL)
[10:32:50.382]                 if (is_error) {
[10:32:50.382]                   sessionInformation <- function() {
[10:32:50.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.382]                       search = base::search(), system = base::Sys.info())
[10:32:50.382]                   }
[10:32:50.382]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.382]                     cond$call), session = sessionInformation(), 
[10:32:50.382]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.382]                   signalCondition(cond)
[10:32:50.382]                 }
[10:32:50.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.382]                 "immediateCondition"))) {
[10:32:50.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.382]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.382]                   if (TRUE && !signal) {
[10:32:50.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.382]                     {
[10:32:50.382]                       inherits <- base::inherits
[10:32:50.382]                       invokeRestart <- base::invokeRestart
[10:32:50.382]                       is.null <- base::is.null
[10:32:50.382]                       muffled <- FALSE
[10:32:50.382]                       if (inherits(cond, "message")) {
[10:32:50.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.382]                         if (muffled) 
[10:32:50.382]                           invokeRestart("muffleMessage")
[10:32:50.382]                       }
[10:32:50.382]                       else if (inherits(cond, "warning")) {
[10:32:50.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.382]                         if (muffled) 
[10:32:50.382]                           invokeRestart("muffleWarning")
[10:32:50.382]                       }
[10:32:50.382]                       else if (inherits(cond, "condition")) {
[10:32:50.382]                         if (!is.null(pattern)) {
[10:32:50.382]                           computeRestarts <- base::computeRestarts
[10:32:50.382]                           grepl <- base::grepl
[10:32:50.382]                           restarts <- computeRestarts(cond)
[10:32:50.382]                           for (restart in restarts) {
[10:32:50.382]                             name <- restart$name
[10:32:50.382]                             if (is.null(name)) 
[10:32:50.382]                               next
[10:32:50.382]                             if (!grepl(pattern, name)) 
[10:32:50.382]                               next
[10:32:50.382]                             invokeRestart(restart)
[10:32:50.382]                             muffled <- TRUE
[10:32:50.382]                             break
[10:32:50.382]                           }
[10:32:50.382]                         }
[10:32:50.382]                       }
[10:32:50.382]                       invisible(muffled)
[10:32:50.382]                     }
[10:32:50.382]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.382]                   }
[10:32:50.382]                 }
[10:32:50.382]                 else {
[10:32:50.382]                   if (TRUE) {
[10:32:50.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.382]                     {
[10:32:50.382]                       inherits <- base::inherits
[10:32:50.382]                       invokeRestart <- base::invokeRestart
[10:32:50.382]                       is.null <- base::is.null
[10:32:50.382]                       muffled <- FALSE
[10:32:50.382]                       if (inherits(cond, "message")) {
[10:32:50.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.382]                         if (muffled) 
[10:32:50.382]                           invokeRestart("muffleMessage")
[10:32:50.382]                       }
[10:32:50.382]                       else if (inherits(cond, "warning")) {
[10:32:50.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.382]                         if (muffled) 
[10:32:50.382]                           invokeRestart("muffleWarning")
[10:32:50.382]                       }
[10:32:50.382]                       else if (inherits(cond, "condition")) {
[10:32:50.382]                         if (!is.null(pattern)) {
[10:32:50.382]                           computeRestarts <- base::computeRestarts
[10:32:50.382]                           grepl <- base::grepl
[10:32:50.382]                           restarts <- computeRestarts(cond)
[10:32:50.382]                           for (restart in restarts) {
[10:32:50.382]                             name <- restart$name
[10:32:50.382]                             if (is.null(name)) 
[10:32:50.382]                               next
[10:32:50.382]                             if (!grepl(pattern, name)) 
[10:32:50.382]                               next
[10:32:50.382]                             invokeRestart(restart)
[10:32:50.382]                             muffled <- TRUE
[10:32:50.382]                             break
[10:32:50.382]                           }
[10:32:50.382]                         }
[10:32:50.382]                       }
[10:32:50.382]                       invisible(muffled)
[10:32:50.382]                     }
[10:32:50.382]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.382]                   }
[10:32:50.382]                 }
[10:32:50.382]             }
[10:32:50.382]         }))
[10:32:50.382]     }, error = function(ex) {
[10:32:50.382]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.382]                 ...future.rng), started = ...future.startTime, 
[10:32:50.382]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.382]             version = "1.8"), class = "FutureResult")
[10:32:50.382]     }, finally = {
[10:32:50.382]         if (!identical(...future.workdir, getwd())) 
[10:32:50.382]             setwd(...future.workdir)
[10:32:50.382]         {
[10:32:50.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.382]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.382]             }
[10:32:50.382]             base::options(...future.oldOptions)
[10:32:50.382]             if (.Platform$OS.type == "windows") {
[10:32:50.382]                 old_names <- names(...future.oldEnvVars)
[10:32:50.382]                 envs <- base::Sys.getenv()
[10:32:50.382]                 names <- names(envs)
[10:32:50.382]                 common <- intersect(names, old_names)
[10:32:50.382]                 added <- setdiff(names, old_names)
[10:32:50.382]                 removed <- setdiff(old_names, names)
[10:32:50.382]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.382]                   envs[common]]
[10:32:50.382]                 NAMES <- toupper(changed)
[10:32:50.382]                 args <- list()
[10:32:50.382]                 for (kk in seq_along(NAMES)) {
[10:32:50.382]                   name <- changed[[kk]]
[10:32:50.382]                   NAME <- NAMES[[kk]]
[10:32:50.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.382]                     next
[10:32:50.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.382]                 }
[10:32:50.382]                 NAMES <- toupper(added)
[10:32:50.382]                 for (kk in seq_along(NAMES)) {
[10:32:50.382]                   name <- added[[kk]]
[10:32:50.382]                   NAME <- NAMES[[kk]]
[10:32:50.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.382]                     next
[10:32:50.382]                   args[[name]] <- ""
[10:32:50.382]                 }
[10:32:50.382]                 NAMES <- toupper(removed)
[10:32:50.382]                 for (kk in seq_along(NAMES)) {
[10:32:50.382]                   name <- removed[[kk]]
[10:32:50.382]                   NAME <- NAMES[[kk]]
[10:32:50.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.382]                     next
[10:32:50.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.382]                 }
[10:32:50.382]                 if (length(args) > 0) 
[10:32:50.382]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.382]             }
[10:32:50.382]             else {
[10:32:50.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.382]             }
[10:32:50.382]             {
[10:32:50.382]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.382]                   0L) {
[10:32:50.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.382]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.382]                   base::options(opts)
[10:32:50.382]                 }
[10:32:50.382]                 {
[10:32:50.382]                   {
[10:32:50.382]                     NULL
[10:32:50.382]                     RNGkind("Mersenne-Twister")
[10:32:50.382]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.382]                       inherits = FALSE)
[10:32:50.382]                   }
[10:32:50.382]                   options(future.plan = NULL)
[10:32:50.382]                   if (is.na(NA_character_)) 
[10:32:50.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.382]                     .init = FALSE)
[10:32:50.382]                 }
[10:32:50.382]             }
[10:32:50.382]         }
[10:32:50.382]     })
[10:32:50.382]     if (TRUE) {
[10:32:50.382]         base::sink(type = "output", split = FALSE)
[10:32:50.382]         if (TRUE) {
[10:32:50.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.382]         }
[10:32:50.382]         else {
[10:32:50.382]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.382]         }
[10:32:50.382]         base::close(...future.stdout)
[10:32:50.382]         ...future.stdout <- NULL
[10:32:50.382]     }
[10:32:50.382]     ...future.result$conditions <- ...future.conditions
[10:32:50.382]     ...future.result$finished <- base::Sys.time()
[10:32:50.382]     ...future.result
[10:32:50.382] }
[10:32:50.384] plan(): Setting new future strategy stack:
[10:32:50.384] List of future strategies:
[10:32:50.384] 1. sequential:
[10:32:50.384]    - args: function (..., envir = parent.frame())
[10:32:50.384]    - tweaked: FALSE
[10:32:50.384]    - call: NULL
[10:32:50.385] plan(): nbrOfWorkers() = 1
[10:32:50.385] plan(): Setting new future strategy stack:
[10:32:50.385] List of future strategies:
[10:32:50.385] 1. sequential:
[10:32:50.385]    - args: function (..., envir = parent.frame())
[10:32:50.385]    - tweaked: FALSE
[10:32:50.385]    - call: plan(strategy)
[10:32:50.386] plan(): nbrOfWorkers() = 1
[10:32:50.386] SequentialFuture started (and completed)
[10:32:50.386] - Launch lazy future ... done
[10:32:50.386] run() for ‘SequentialFuture’ ... done
[10:32:50.387] getGlobalsAndPackages() ...
[10:32:50.387] Searching for globals...
[10:32:50.387] - globals found: [1] ‘{’
[10:32:50.387] Searching for globals ... DONE
[10:32:50.387] Resolving globals: FALSE
[10:32:50.388] 
[10:32:50.388] 
[10:32:50.388] getGlobalsAndPackages() ... DONE
[10:32:50.388] run() for ‘Future’ ...
[10:32:50.388] - state: ‘created’
[10:32:50.388] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.388] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.389]   - Field: ‘label’
[10:32:50.389]   - Field: ‘local’
[10:32:50.389]   - Field: ‘owner’
[10:32:50.389]   - Field: ‘envir’
[10:32:50.389]   - Field: ‘packages’
[10:32:50.389]   - Field: ‘gc’
[10:32:50.389]   - Field: ‘conditions’
[10:32:50.389]   - Field: ‘expr’
[10:32:50.389]   - Field: ‘uuid’
[10:32:50.390]   - Field: ‘seed’
[10:32:50.390]   - Field: ‘version’
[10:32:50.390]   - Field: ‘result’
[10:32:50.390]   - Field: ‘asynchronous’
[10:32:50.390]   - Field: ‘calls’
[10:32:50.390]   - Field: ‘globals’
[10:32:50.390]   - Field: ‘stdout’
[10:32:50.390]   - Field: ‘earlySignal’
[10:32:50.390]   - Field: ‘lazy’
[10:32:50.390]   - Field: ‘state’
[10:32:50.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.390] - Launch lazy future ...
[10:32:50.391] Packages needed by the future expression (n = 0): <none>
[10:32:50.391] Packages needed by future strategies (n = 0): <none>
[10:32:50.391] {
[10:32:50.391]     {
[10:32:50.391]         {
[10:32:50.391]             ...future.startTime <- base::Sys.time()
[10:32:50.391]             {
[10:32:50.391]                 {
[10:32:50.391]                   {
[10:32:50.391]                     base::local({
[10:32:50.391]                       has_future <- base::requireNamespace("future", 
[10:32:50.391]                         quietly = TRUE)
[10:32:50.391]                       if (has_future) {
[10:32:50.391]                         ns <- base::getNamespace("future")
[10:32:50.391]                         version <- ns[[".package"]][["version"]]
[10:32:50.391]                         if (is.null(version)) 
[10:32:50.391]                           version <- utils::packageVersion("future")
[10:32:50.391]                       }
[10:32:50.391]                       else {
[10:32:50.391]                         version <- NULL
[10:32:50.391]                       }
[10:32:50.391]                       if (!has_future || version < "1.8.0") {
[10:32:50.391]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.391]                           "", base::R.version$version.string), 
[10:32:50.391]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.391]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.391]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.391]                             "release", "version")], collapse = " "), 
[10:32:50.391]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.391]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.391]                           info)
[10:32:50.391]                         info <- base::paste(info, collapse = "; ")
[10:32:50.391]                         if (!has_future) {
[10:32:50.391]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.391]                             info)
[10:32:50.391]                         }
[10:32:50.391]                         else {
[10:32:50.391]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.391]                             info, version)
[10:32:50.391]                         }
[10:32:50.391]                         base::stop(msg)
[10:32:50.391]                       }
[10:32:50.391]                     })
[10:32:50.391]                   }
[10:32:50.391]                   ...future.strategy.old <- future::plan("list")
[10:32:50.391]                   options(future.plan = NULL)
[10:32:50.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.391]                 }
[10:32:50.391]                 ...future.workdir <- getwd()
[10:32:50.391]             }
[10:32:50.391]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.391]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.391]         }
[10:32:50.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.391]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.391]             base::names(...future.oldOptions))
[10:32:50.391]     }
[10:32:50.391]     if (FALSE) {
[10:32:50.391]     }
[10:32:50.391]     else {
[10:32:50.391]         if (TRUE) {
[10:32:50.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.391]                 open = "w")
[10:32:50.391]         }
[10:32:50.391]         else {
[10:32:50.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.391]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.391]         }
[10:32:50.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.391]             base::sink(type = "output", split = FALSE)
[10:32:50.391]             base::close(...future.stdout)
[10:32:50.391]         }, add = TRUE)
[10:32:50.391]     }
[10:32:50.391]     ...future.frame <- base::sys.nframe()
[10:32:50.391]     ...future.conditions <- base::list()
[10:32:50.391]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.391]     if (FALSE) {
[10:32:50.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.391]     }
[10:32:50.391]     ...future.result <- base::tryCatch({
[10:32:50.391]         base::withCallingHandlers({
[10:32:50.391]             ...future.value <- base::withVisible(base::local({
[10:32:50.391]                 4
[10:32:50.391]             }))
[10:32:50.391]             future::FutureResult(value = ...future.value$value, 
[10:32:50.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.391]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.391]                     ...future.globalenv.names))
[10:32:50.391]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.391]         }, condition = base::local({
[10:32:50.391]             c <- base::c
[10:32:50.391]             inherits <- base::inherits
[10:32:50.391]             invokeRestart <- base::invokeRestart
[10:32:50.391]             length <- base::length
[10:32:50.391]             list <- base::list
[10:32:50.391]             seq.int <- base::seq.int
[10:32:50.391]             signalCondition <- base::signalCondition
[10:32:50.391]             sys.calls <- base::sys.calls
[10:32:50.391]             `[[` <- base::`[[`
[10:32:50.391]             `+` <- base::`+`
[10:32:50.391]             `<<-` <- base::`<<-`
[10:32:50.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.391]                   3L)]
[10:32:50.391]             }
[10:32:50.391]             function(cond) {
[10:32:50.391]                 is_error <- inherits(cond, "error")
[10:32:50.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.391]                   NULL)
[10:32:50.391]                 if (is_error) {
[10:32:50.391]                   sessionInformation <- function() {
[10:32:50.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.391]                       search = base::search(), system = base::Sys.info())
[10:32:50.391]                   }
[10:32:50.391]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.391]                     cond$call), session = sessionInformation(), 
[10:32:50.391]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.391]                   signalCondition(cond)
[10:32:50.391]                 }
[10:32:50.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.391]                 "immediateCondition"))) {
[10:32:50.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.391]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.391]                   if (TRUE && !signal) {
[10:32:50.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.391]                     {
[10:32:50.391]                       inherits <- base::inherits
[10:32:50.391]                       invokeRestart <- base::invokeRestart
[10:32:50.391]                       is.null <- base::is.null
[10:32:50.391]                       muffled <- FALSE
[10:32:50.391]                       if (inherits(cond, "message")) {
[10:32:50.391]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.391]                         if (muffled) 
[10:32:50.391]                           invokeRestart("muffleMessage")
[10:32:50.391]                       }
[10:32:50.391]                       else if (inherits(cond, "warning")) {
[10:32:50.391]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.391]                         if (muffled) 
[10:32:50.391]                           invokeRestart("muffleWarning")
[10:32:50.391]                       }
[10:32:50.391]                       else if (inherits(cond, "condition")) {
[10:32:50.391]                         if (!is.null(pattern)) {
[10:32:50.391]                           computeRestarts <- base::computeRestarts
[10:32:50.391]                           grepl <- base::grepl
[10:32:50.391]                           restarts <- computeRestarts(cond)
[10:32:50.391]                           for (restart in restarts) {
[10:32:50.391]                             name <- restart$name
[10:32:50.391]                             if (is.null(name)) 
[10:32:50.391]                               next
[10:32:50.391]                             if (!grepl(pattern, name)) 
[10:32:50.391]                               next
[10:32:50.391]                             invokeRestart(restart)
[10:32:50.391]                             muffled <- TRUE
[10:32:50.391]                             break
[10:32:50.391]                           }
[10:32:50.391]                         }
[10:32:50.391]                       }
[10:32:50.391]                       invisible(muffled)
[10:32:50.391]                     }
[10:32:50.391]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.391]                   }
[10:32:50.391]                 }
[10:32:50.391]                 else {
[10:32:50.391]                   if (TRUE) {
[10:32:50.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.391]                     {
[10:32:50.391]                       inherits <- base::inherits
[10:32:50.391]                       invokeRestart <- base::invokeRestart
[10:32:50.391]                       is.null <- base::is.null
[10:32:50.391]                       muffled <- FALSE
[10:32:50.391]                       if (inherits(cond, "message")) {
[10:32:50.391]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.391]                         if (muffled) 
[10:32:50.391]                           invokeRestart("muffleMessage")
[10:32:50.391]                       }
[10:32:50.391]                       else if (inherits(cond, "warning")) {
[10:32:50.391]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.391]                         if (muffled) 
[10:32:50.391]                           invokeRestart("muffleWarning")
[10:32:50.391]                       }
[10:32:50.391]                       else if (inherits(cond, "condition")) {
[10:32:50.391]                         if (!is.null(pattern)) {
[10:32:50.391]                           computeRestarts <- base::computeRestarts
[10:32:50.391]                           grepl <- base::grepl
[10:32:50.391]                           restarts <- computeRestarts(cond)
[10:32:50.391]                           for (restart in restarts) {
[10:32:50.391]                             name <- restart$name
[10:32:50.391]                             if (is.null(name)) 
[10:32:50.391]                               next
[10:32:50.391]                             if (!grepl(pattern, name)) 
[10:32:50.391]                               next
[10:32:50.391]                             invokeRestart(restart)
[10:32:50.391]                             muffled <- TRUE
[10:32:50.391]                             break
[10:32:50.391]                           }
[10:32:50.391]                         }
[10:32:50.391]                       }
[10:32:50.391]                       invisible(muffled)
[10:32:50.391]                     }
[10:32:50.391]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.391]                   }
[10:32:50.391]                 }
[10:32:50.391]             }
[10:32:50.391]         }))
[10:32:50.391]     }, error = function(ex) {
[10:32:50.391]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.391]                 ...future.rng), started = ...future.startTime, 
[10:32:50.391]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.391]             version = "1.8"), class = "FutureResult")
[10:32:50.391]     }, finally = {
[10:32:50.391]         if (!identical(...future.workdir, getwd())) 
[10:32:50.391]             setwd(...future.workdir)
[10:32:50.391]         {
[10:32:50.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.391]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.391]             }
[10:32:50.391]             base::options(...future.oldOptions)
[10:32:50.391]             if (.Platform$OS.type == "windows") {
[10:32:50.391]                 old_names <- names(...future.oldEnvVars)
[10:32:50.391]                 envs <- base::Sys.getenv()
[10:32:50.391]                 names <- names(envs)
[10:32:50.391]                 common <- intersect(names, old_names)
[10:32:50.391]                 added <- setdiff(names, old_names)
[10:32:50.391]                 removed <- setdiff(old_names, names)
[10:32:50.391]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.391]                   envs[common]]
[10:32:50.391]                 NAMES <- toupper(changed)
[10:32:50.391]                 args <- list()
[10:32:50.391]                 for (kk in seq_along(NAMES)) {
[10:32:50.391]                   name <- changed[[kk]]
[10:32:50.391]                   NAME <- NAMES[[kk]]
[10:32:50.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.391]                     next
[10:32:50.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.391]                 }
[10:32:50.391]                 NAMES <- toupper(added)
[10:32:50.391]                 for (kk in seq_along(NAMES)) {
[10:32:50.391]                   name <- added[[kk]]
[10:32:50.391]                   NAME <- NAMES[[kk]]
[10:32:50.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.391]                     next
[10:32:50.391]                   args[[name]] <- ""
[10:32:50.391]                 }
[10:32:50.391]                 NAMES <- toupper(removed)
[10:32:50.391]                 for (kk in seq_along(NAMES)) {
[10:32:50.391]                   name <- removed[[kk]]
[10:32:50.391]                   NAME <- NAMES[[kk]]
[10:32:50.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.391]                     next
[10:32:50.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.391]                 }
[10:32:50.391]                 if (length(args) > 0) 
[10:32:50.391]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.391]             }
[10:32:50.391]             else {
[10:32:50.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.391]             }
[10:32:50.391]             {
[10:32:50.391]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.391]                   0L) {
[10:32:50.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.391]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.391]                   base::options(opts)
[10:32:50.391]                 }
[10:32:50.391]                 {
[10:32:50.391]                   {
[10:32:50.391]                     NULL
[10:32:50.391]                     RNGkind("Mersenne-Twister")
[10:32:50.391]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.391]                       inherits = FALSE)
[10:32:50.391]                   }
[10:32:50.391]                   options(future.plan = NULL)
[10:32:50.391]                   if (is.na(NA_character_)) 
[10:32:50.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.391]                     .init = FALSE)
[10:32:50.391]                 }
[10:32:50.391]             }
[10:32:50.391]         }
[10:32:50.391]     })
[10:32:50.391]     if (TRUE) {
[10:32:50.391]         base::sink(type = "output", split = FALSE)
[10:32:50.391]         if (TRUE) {
[10:32:50.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.391]         }
[10:32:50.391]         else {
[10:32:50.391]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.391]         }
[10:32:50.391]         base::close(...future.stdout)
[10:32:50.391]         ...future.stdout <- NULL
[10:32:50.391]     }
[10:32:50.391]     ...future.result$conditions <- ...future.conditions
[10:32:50.391]     ...future.result$finished <- base::Sys.time()
[10:32:50.391]     ...future.result
[10:32:50.391] }
[10:32:50.393] plan(): Setting new future strategy stack:
[10:32:50.393] List of future strategies:
[10:32:50.393] 1. sequential:
[10:32:50.393]    - args: function (..., envir = parent.frame())
[10:32:50.393]    - tweaked: FALSE
[10:32:50.393]    - call: NULL
[10:32:50.393] plan(): nbrOfWorkers() = 1
[10:32:50.394] plan(): Setting new future strategy stack:
[10:32:50.394] List of future strategies:
[10:32:50.394] 1. sequential:
[10:32:50.394]    - args: function (..., envir = parent.frame())
[10:32:50.394]    - tweaked: FALSE
[10:32:50.394]    - call: plan(strategy)
[10:32:50.394] plan(): nbrOfWorkers() = 1
[10:32:50.395] SequentialFuture started (and completed)
[10:32:50.395] - Launch lazy future ... done
[10:32:50.395] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d0edf0b0> 
Classes 'listenv', 'environment' <environment: 0x5652d0e09d90> 
[10:32:50.398] resolved() for ‘SequentialFuture’ ...
[10:32:50.398] - state: ‘finished’
[10:32:50.398] - run: TRUE
[10:32:50.398] - result: ‘FutureResult’
[10:32:50.398] resolved() for ‘SequentialFuture’ ... done
[10:32:50.398] resolved() for ‘SequentialFuture’ ...
[10:32:50.398] - state: ‘finished’
[10:32:50.398] - run: TRUE
[10:32:50.398] - result: ‘FutureResult’
[10:32:50.399] resolved() for ‘SequentialFuture’ ... done
[10:32:50.399] resolved() for ‘SequentialFuture’ ...
[10:32:50.399] - state: ‘finished’
[10:32:50.399] - run: TRUE
[10:32:50.399] - result: ‘FutureResult’
[10:32:50.399] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:50.401] resolve() on list environment ...
[10:32:50.401]  recursive: 0
[10:32:50.402]  length: 6
[10:32:50.402]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:50.402] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.402] - nx: 6
[10:32:50.402] - relay: TRUE
[10:32:50.402] - stdout: TRUE
[10:32:50.402] - signal: TRUE
[10:32:50.402] - resignal: FALSE
[10:32:50.402] - force: TRUE
[10:32:50.403] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.403] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.403]  - until=2
[10:32:50.403]  - relaying element #2
[10:32:50.404] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.404] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.404] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.404]  length: 5 (resolved future 1)
[10:32:50.404] resolved() for ‘SequentialFuture’ ...
[10:32:50.405] - state: ‘finished’
[10:32:50.405] - run: TRUE
[10:32:50.405] - result: ‘FutureResult’
[10:32:50.405] resolved() for ‘SequentialFuture’ ... done
[10:32:50.405] Future #2
[10:32:50.405] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.405] - nx: 6
[10:32:50.405] - relay: TRUE
[10:32:50.405] - stdout: TRUE
[10:32:50.405] - signal: TRUE
[10:32:50.405] - resignal: FALSE
[10:32:50.406] - force: TRUE
[10:32:50.406] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.406] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.406]  - until=2
[10:32:50.406]  - relaying element #2
[10:32:50.406] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.406] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.406] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.406]  length: 4 (resolved future 2)
[10:32:50.406] resolved() for ‘SequentialFuture’ ...
[10:32:50.407] - state: ‘finished’
[10:32:50.407] - run: TRUE
[10:32:50.407] - result: ‘FutureResult’
[10:32:50.407] resolved() for ‘SequentialFuture’ ... done
[10:32:50.407] Future #3
[10:32:50.407] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.407] - nx: 6
[10:32:50.407] - relay: TRUE
[10:32:50.407] - stdout: TRUE
[10:32:50.407] - signal: TRUE
[10:32:50.407] - resignal: FALSE
[10:32:50.407] - force: TRUE
[10:32:50.408] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.408] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.408]  - until=3
[10:32:50.408]  - relaying element #3
[10:32:50.408] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.408] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.408] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.408]  length: 3 (resolved future 3)
[10:32:50.408] resolved() for ‘SequentialFuture’ ...
[10:32:50.408] - state: ‘finished’
[10:32:50.409] - run: TRUE
[10:32:50.409] - result: ‘FutureResult’
[10:32:50.409] resolved() for ‘SequentialFuture’ ... done
[10:32:50.409] Future #4
[10:32:50.409] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.409] - nx: 6
[10:32:50.409] - relay: TRUE
[10:32:50.409] - stdout: TRUE
[10:32:50.409] - signal: TRUE
[10:32:50.409] - resignal: FALSE
[10:32:50.409] - force: TRUE
[10:32:50.409] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.410] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.410]  - until=4
[10:32:50.410]  - relaying element #4
[10:32:50.410] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.410] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.410] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.410]  length: 2 (resolved future 4)
[10:32:50.410] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.410] - nx: 6
[10:32:50.410] - relay: TRUE
[10:32:50.410] - stdout: TRUE
[10:32:50.411] - signal: TRUE
[10:32:50.411] - resignal: FALSE
[10:32:50.411] - force: TRUE
[10:32:50.411] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.411] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.411]  - until=6
[10:32:50.411]  - relaying element #6
[10:32:50.411] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.411] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.411] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.411]  length: 1 (resolved future 5)
[10:32:50.411] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.412] - nx: 6
[10:32:50.412] - relay: TRUE
[10:32:50.412] - stdout: TRUE
[10:32:50.412] - signal: TRUE
[10:32:50.412] - resignal: FALSE
[10:32:50.412] - force: TRUE
[10:32:50.412] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.412] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.412]  - until=6
[10:32:50.412] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.412] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.412] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.413]  length: 0 (resolved future 6)
[10:32:50.413] Relaying remaining futures
[10:32:50.413] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.413] - nx: 6
[10:32:50.413] - relay: TRUE
[10:32:50.413] - stdout: TRUE
[10:32:50.413] - signal: TRUE
[10:32:50.413] - resignal: FALSE
[10:32:50.413] - force: TRUE
[10:32:50.413] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.413] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:50.413] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.414] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.414] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.414] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5652d114c900> 
Dimensions: c(1, 6)
[10:32:50.414] getGlobalsAndPackages() ...
[10:32:50.415] Searching for globals...
[10:32:50.415] 
[10:32:50.415] Searching for globals ... DONE
[10:32:50.415] - globals: [0] <none>
[10:32:50.415] getGlobalsAndPackages() ... DONE
[10:32:50.415] run() for ‘Future’ ...
[10:32:50.415] - state: ‘created’
[10:32:50.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.416]   - Field: ‘label’
[10:32:50.416]   - Field: ‘local’
[10:32:50.416]   - Field: ‘owner’
[10:32:50.416]   - Field: ‘envir’
[10:32:50.416]   - Field: ‘packages’
[10:32:50.416]   - Field: ‘gc’
[10:32:50.416]   - Field: ‘conditions’
[10:32:50.417]   - Field: ‘expr’
[10:32:50.417]   - Field: ‘uuid’
[10:32:50.417]   - Field: ‘seed’
[10:32:50.417]   - Field: ‘version’
[10:32:50.417]   - Field: ‘result’
[10:32:50.417]   - Field: ‘asynchronous’
[10:32:50.417]   - Field: ‘calls’
[10:32:50.417]   - Field: ‘globals’
[10:32:50.417]   - Field: ‘stdout’
[10:32:50.417]   - Field: ‘earlySignal’
[10:32:50.417]   - Field: ‘lazy’
[10:32:50.418]   - Field: ‘state’
[10:32:50.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.418] - Launch lazy future ...
[10:32:50.418] Packages needed by the future expression (n = 0): <none>
[10:32:50.418] Packages needed by future strategies (n = 0): <none>
[10:32:50.418] {
[10:32:50.418]     {
[10:32:50.418]         {
[10:32:50.418]             ...future.startTime <- base::Sys.time()
[10:32:50.418]             {
[10:32:50.418]                 {
[10:32:50.418]                   {
[10:32:50.418]                     base::local({
[10:32:50.418]                       has_future <- base::requireNamespace("future", 
[10:32:50.418]                         quietly = TRUE)
[10:32:50.418]                       if (has_future) {
[10:32:50.418]                         ns <- base::getNamespace("future")
[10:32:50.418]                         version <- ns[[".package"]][["version"]]
[10:32:50.418]                         if (is.null(version)) 
[10:32:50.418]                           version <- utils::packageVersion("future")
[10:32:50.418]                       }
[10:32:50.418]                       else {
[10:32:50.418]                         version <- NULL
[10:32:50.418]                       }
[10:32:50.418]                       if (!has_future || version < "1.8.0") {
[10:32:50.418]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.418]                           "", base::R.version$version.string), 
[10:32:50.418]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.418]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.418]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.418]                             "release", "version")], collapse = " "), 
[10:32:50.418]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.418]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.418]                           info)
[10:32:50.418]                         info <- base::paste(info, collapse = "; ")
[10:32:50.418]                         if (!has_future) {
[10:32:50.418]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.418]                             info)
[10:32:50.418]                         }
[10:32:50.418]                         else {
[10:32:50.418]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.418]                             info, version)
[10:32:50.418]                         }
[10:32:50.418]                         base::stop(msg)
[10:32:50.418]                       }
[10:32:50.418]                     })
[10:32:50.418]                   }
[10:32:50.418]                   ...future.strategy.old <- future::plan("list")
[10:32:50.418]                   options(future.plan = NULL)
[10:32:50.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.418]                 }
[10:32:50.418]                 ...future.workdir <- getwd()
[10:32:50.418]             }
[10:32:50.418]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.418]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.418]         }
[10:32:50.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.418]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.418]             base::names(...future.oldOptions))
[10:32:50.418]     }
[10:32:50.418]     if (FALSE) {
[10:32:50.418]     }
[10:32:50.418]     else {
[10:32:50.418]         if (TRUE) {
[10:32:50.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.418]                 open = "w")
[10:32:50.418]         }
[10:32:50.418]         else {
[10:32:50.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.418]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.418]         }
[10:32:50.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.418]             base::sink(type = "output", split = FALSE)
[10:32:50.418]             base::close(...future.stdout)
[10:32:50.418]         }, add = TRUE)
[10:32:50.418]     }
[10:32:50.418]     ...future.frame <- base::sys.nframe()
[10:32:50.418]     ...future.conditions <- base::list()
[10:32:50.418]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.418]     if (FALSE) {
[10:32:50.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.418]     }
[10:32:50.418]     ...future.result <- base::tryCatch({
[10:32:50.418]         base::withCallingHandlers({
[10:32:50.418]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.418]             future::FutureResult(value = ...future.value$value, 
[10:32:50.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.418]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.418]                     ...future.globalenv.names))
[10:32:50.418]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.418]         }, condition = base::local({
[10:32:50.418]             c <- base::c
[10:32:50.418]             inherits <- base::inherits
[10:32:50.418]             invokeRestart <- base::invokeRestart
[10:32:50.418]             length <- base::length
[10:32:50.418]             list <- base::list
[10:32:50.418]             seq.int <- base::seq.int
[10:32:50.418]             signalCondition <- base::signalCondition
[10:32:50.418]             sys.calls <- base::sys.calls
[10:32:50.418]             `[[` <- base::`[[`
[10:32:50.418]             `+` <- base::`+`
[10:32:50.418]             `<<-` <- base::`<<-`
[10:32:50.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.418]                   3L)]
[10:32:50.418]             }
[10:32:50.418]             function(cond) {
[10:32:50.418]                 is_error <- inherits(cond, "error")
[10:32:50.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.418]                   NULL)
[10:32:50.418]                 if (is_error) {
[10:32:50.418]                   sessionInformation <- function() {
[10:32:50.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.418]                       search = base::search(), system = base::Sys.info())
[10:32:50.418]                   }
[10:32:50.418]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.418]                     cond$call), session = sessionInformation(), 
[10:32:50.418]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.418]                   signalCondition(cond)
[10:32:50.418]                 }
[10:32:50.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.418]                 "immediateCondition"))) {
[10:32:50.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.418]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.418]                   if (TRUE && !signal) {
[10:32:50.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.418]                     {
[10:32:50.418]                       inherits <- base::inherits
[10:32:50.418]                       invokeRestart <- base::invokeRestart
[10:32:50.418]                       is.null <- base::is.null
[10:32:50.418]                       muffled <- FALSE
[10:32:50.418]                       if (inherits(cond, "message")) {
[10:32:50.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.418]                         if (muffled) 
[10:32:50.418]                           invokeRestart("muffleMessage")
[10:32:50.418]                       }
[10:32:50.418]                       else if (inherits(cond, "warning")) {
[10:32:50.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.418]                         if (muffled) 
[10:32:50.418]                           invokeRestart("muffleWarning")
[10:32:50.418]                       }
[10:32:50.418]                       else if (inherits(cond, "condition")) {
[10:32:50.418]                         if (!is.null(pattern)) {
[10:32:50.418]                           computeRestarts <- base::computeRestarts
[10:32:50.418]                           grepl <- base::grepl
[10:32:50.418]                           restarts <- computeRestarts(cond)
[10:32:50.418]                           for (restart in restarts) {
[10:32:50.418]                             name <- restart$name
[10:32:50.418]                             if (is.null(name)) 
[10:32:50.418]                               next
[10:32:50.418]                             if (!grepl(pattern, name)) 
[10:32:50.418]                               next
[10:32:50.418]                             invokeRestart(restart)
[10:32:50.418]                             muffled <- TRUE
[10:32:50.418]                             break
[10:32:50.418]                           }
[10:32:50.418]                         }
[10:32:50.418]                       }
[10:32:50.418]                       invisible(muffled)
[10:32:50.418]                     }
[10:32:50.418]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.418]                   }
[10:32:50.418]                 }
[10:32:50.418]                 else {
[10:32:50.418]                   if (TRUE) {
[10:32:50.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.418]                     {
[10:32:50.418]                       inherits <- base::inherits
[10:32:50.418]                       invokeRestart <- base::invokeRestart
[10:32:50.418]                       is.null <- base::is.null
[10:32:50.418]                       muffled <- FALSE
[10:32:50.418]                       if (inherits(cond, "message")) {
[10:32:50.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.418]                         if (muffled) 
[10:32:50.418]                           invokeRestart("muffleMessage")
[10:32:50.418]                       }
[10:32:50.418]                       else if (inherits(cond, "warning")) {
[10:32:50.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.418]                         if (muffled) 
[10:32:50.418]                           invokeRestart("muffleWarning")
[10:32:50.418]                       }
[10:32:50.418]                       else if (inherits(cond, "condition")) {
[10:32:50.418]                         if (!is.null(pattern)) {
[10:32:50.418]                           computeRestarts <- base::computeRestarts
[10:32:50.418]                           grepl <- base::grepl
[10:32:50.418]                           restarts <- computeRestarts(cond)
[10:32:50.418]                           for (restart in restarts) {
[10:32:50.418]                             name <- restart$name
[10:32:50.418]                             if (is.null(name)) 
[10:32:50.418]                               next
[10:32:50.418]                             if (!grepl(pattern, name)) 
[10:32:50.418]                               next
[10:32:50.418]                             invokeRestart(restart)
[10:32:50.418]                             muffled <- TRUE
[10:32:50.418]                             break
[10:32:50.418]                           }
[10:32:50.418]                         }
[10:32:50.418]                       }
[10:32:50.418]                       invisible(muffled)
[10:32:50.418]                     }
[10:32:50.418]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.418]                   }
[10:32:50.418]                 }
[10:32:50.418]             }
[10:32:50.418]         }))
[10:32:50.418]     }, error = function(ex) {
[10:32:50.418]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.418]                 ...future.rng), started = ...future.startTime, 
[10:32:50.418]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.418]             version = "1.8"), class = "FutureResult")
[10:32:50.418]     }, finally = {
[10:32:50.418]         if (!identical(...future.workdir, getwd())) 
[10:32:50.418]             setwd(...future.workdir)
[10:32:50.418]         {
[10:32:50.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.418]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.418]             }
[10:32:50.418]             base::options(...future.oldOptions)
[10:32:50.418]             if (.Platform$OS.type == "windows") {
[10:32:50.418]                 old_names <- names(...future.oldEnvVars)
[10:32:50.418]                 envs <- base::Sys.getenv()
[10:32:50.418]                 names <- names(envs)
[10:32:50.418]                 common <- intersect(names, old_names)
[10:32:50.418]                 added <- setdiff(names, old_names)
[10:32:50.418]                 removed <- setdiff(old_names, names)
[10:32:50.418]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.418]                   envs[common]]
[10:32:50.418]                 NAMES <- toupper(changed)
[10:32:50.418]                 args <- list()
[10:32:50.418]                 for (kk in seq_along(NAMES)) {
[10:32:50.418]                   name <- changed[[kk]]
[10:32:50.418]                   NAME <- NAMES[[kk]]
[10:32:50.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.418]                     next
[10:32:50.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.418]                 }
[10:32:50.418]                 NAMES <- toupper(added)
[10:32:50.418]                 for (kk in seq_along(NAMES)) {
[10:32:50.418]                   name <- added[[kk]]
[10:32:50.418]                   NAME <- NAMES[[kk]]
[10:32:50.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.418]                     next
[10:32:50.418]                   args[[name]] <- ""
[10:32:50.418]                 }
[10:32:50.418]                 NAMES <- toupper(removed)
[10:32:50.418]                 for (kk in seq_along(NAMES)) {
[10:32:50.418]                   name <- removed[[kk]]
[10:32:50.418]                   NAME <- NAMES[[kk]]
[10:32:50.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.418]                     next
[10:32:50.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.418]                 }
[10:32:50.418]                 if (length(args) > 0) 
[10:32:50.418]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.418]             }
[10:32:50.418]             else {
[10:32:50.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.418]             }
[10:32:50.418]             {
[10:32:50.418]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.418]                   0L) {
[10:32:50.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.418]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.418]                   base::options(opts)
[10:32:50.418]                 }
[10:32:50.418]                 {
[10:32:50.418]                   {
[10:32:50.418]                     NULL
[10:32:50.418]                     RNGkind("Mersenne-Twister")
[10:32:50.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.418]                       inherits = FALSE)
[10:32:50.418]                   }
[10:32:50.418]                   options(future.plan = NULL)
[10:32:50.418]                   if (is.na(NA_character_)) 
[10:32:50.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.418]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.418]                     .init = FALSE)
[10:32:50.418]                 }
[10:32:50.418]             }
[10:32:50.418]         }
[10:32:50.418]     })
[10:32:50.418]     if (TRUE) {
[10:32:50.418]         base::sink(type = "output", split = FALSE)
[10:32:50.418]         if (TRUE) {
[10:32:50.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.418]         }
[10:32:50.418]         else {
[10:32:50.418]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.418]         }
[10:32:50.418]         base::close(...future.stdout)
[10:32:50.418]         ...future.stdout <- NULL
[10:32:50.418]     }
[10:32:50.418]     ...future.result$conditions <- ...future.conditions
[10:32:50.418]     ...future.result$finished <- base::Sys.time()
[10:32:50.418]     ...future.result
[10:32:50.418] }
[10:32:50.420] plan(): Setting new future strategy stack:
[10:32:50.420] List of future strategies:
[10:32:50.420] 1. sequential:
[10:32:50.420]    - args: function (..., envir = parent.frame())
[10:32:50.420]    - tweaked: FALSE
[10:32:50.420]    - call: NULL
[10:32:50.420] plan(): nbrOfWorkers() = 1
[10:32:50.421] plan(): Setting new future strategy stack:
[10:32:50.421] List of future strategies:
[10:32:50.421] 1. sequential:
[10:32:50.421]    - args: function (..., envir = parent.frame())
[10:32:50.421]    - tweaked: FALSE
[10:32:50.421]    - call: plan(strategy)
[10:32:50.422] plan(): nbrOfWorkers() = 1
[10:32:50.422] SequentialFuture started (and completed)
[10:32:50.422] - Launch lazy future ... done
[10:32:50.422] run() for ‘SequentialFuture’ ... done
[10:32:50.422] getGlobalsAndPackages() ...
[10:32:50.422] Searching for globals...
[10:32:50.422] 
[10:32:50.422] Searching for globals ... DONE
[10:32:50.423] - globals: [0] <none>
[10:32:50.423] getGlobalsAndPackages() ... DONE
[10:32:50.423] run() for ‘Future’ ...
[10:32:50.423] - state: ‘created’
[10:32:50.423] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.423] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.424]   - Field: ‘label’
[10:32:50.424]   - Field: ‘local’
[10:32:50.424]   - Field: ‘owner’
[10:32:50.424]   - Field: ‘envir’
[10:32:50.424]   - Field: ‘packages’
[10:32:50.424]   - Field: ‘gc’
[10:32:50.424]   - Field: ‘conditions’
[10:32:50.424]   - Field: ‘expr’
[10:32:50.424]   - Field: ‘uuid’
[10:32:50.424]   - Field: ‘seed’
[10:32:50.424]   - Field: ‘version’
[10:32:50.424]   - Field: ‘result’
[10:32:50.425]   - Field: ‘asynchronous’
[10:32:50.425]   - Field: ‘calls’
[10:32:50.425]   - Field: ‘globals’
[10:32:50.425]   - Field: ‘stdout’
[10:32:50.425]   - Field: ‘earlySignal’
[10:32:50.425]   - Field: ‘lazy’
[10:32:50.425]   - Field: ‘state’
[10:32:50.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.447] - Launch lazy future ...
[10:32:50.448] Packages needed by the future expression (n = 0): <none>
[10:32:50.448] Packages needed by future strategies (n = 0): <none>
[10:32:50.448] {
[10:32:50.448]     {
[10:32:50.448]         {
[10:32:50.448]             ...future.startTime <- base::Sys.time()
[10:32:50.448]             {
[10:32:50.448]                 {
[10:32:50.448]                   {
[10:32:50.448]                     base::local({
[10:32:50.448]                       has_future <- base::requireNamespace("future", 
[10:32:50.448]                         quietly = TRUE)
[10:32:50.448]                       if (has_future) {
[10:32:50.448]                         ns <- base::getNamespace("future")
[10:32:50.448]                         version <- ns[[".package"]][["version"]]
[10:32:50.448]                         if (is.null(version)) 
[10:32:50.448]                           version <- utils::packageVersion("future")
[10:32:50.448]                       }
[10:32:50.448]                       else {
[10:32:50.448]                         version <- NULL
[10:32:50.448]                       }
[10:32:50.448]                       if (!has_future || version < "1.8.0") {
[10:32:50.448]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.448]                           "", base::R.version$version.string), 
[10:32:50.448]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.448]                             "release", "version")], collapse = " "), 
[10:32:50.448]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.448]                           info)
[10:32:50.448]                         info <- base::paste(info, collapse = "; ")
[10:32:50.448]                         if (!has_future) {
[10:32:50.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.448]                             info)
[10:32:50.448]                         }
[10:32:50.448]                         else {
[10:32:50.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.448]                             info, version)
[10:32:50.448]                         }
[10:32:50.448]                         base::stop(msg)
[10:32:50.448]                       }
[10:32:50.448]                     })
[10:32:50.448]                   }
[10:32:50.448]                   ...future.strategy.old <- future::plan("list")
[10:32:50.448]                   options(future.plan = NULL)
[10:32:50.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.448]                 }
[10:32:50.448]                 ...future.workdir <- getwd()
[10:32:50.448]             }
[10:32:50.448]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.448]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.448]         }
[10:32:50.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.448]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.448]             base::names(...future.oldOptions))
[10:32:50.448]     }
[10:32:50.448]     if (FALSE) {
[10:32:50.448]     }
[10:32:50.448]     else {
[10:32:50.448]         if (TRUE) {
[10:32:50.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.448]                 open = "w")
[10:32:50.448]         }
[10:32:50.448]         else {
[10:32:50.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.448]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.448]         }
[10:32:50.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.448]             base::sink(type = "output", split = FALSE)
[10:32:50.448]             base::close(...future.stdout)
[10:32:50.448]         }, add = TRUE)
[10:32:50.448]     }
[10:32:50.448]     ...future.frame <- base::sys.nframe()
[10:32:50.448]     ...future.conditions <- base::list()
[10:32:50.448]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.448]     if (FALSE) {
[10:32:50.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.448]     }
[10:32:50.448]     ...future.result <- base::tryCatch({
[10:32:50.448]         base::withCallingHandlers({
[10:32:50.448]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.448]             future::FutureResult(value = ...future.value$value, 
[10:32:50.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.448]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.448]                     ...future.globalenv.names))
[10:32:50.448]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.448]         }, condition = base::local({
[10:32:50.448]             c <- base::c
[10:32:50.448]             inherits <- base::inherits
[10:32:50.448]             invokeRestart <- base::invokeRestart
[10:32:50.448]             length <- base::length
[10:32:50.448]             list <- base::list
[10:32:50.448]             seq.int <- base::seq.int
[10:32:50.448]             signalCondition <- base::signalCondition
[10:32:50.448]             sys.calls <- base::sys.calls
[10:32:50.448]             `[[` <- base::`[[`
[10:32:50.448]             `+` <- base::`+`
[10:32:50.448]             `<<-` <- base::`<<-`
[10:32:50.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.448]                   3L)]
[10:32:50.448]             }
[10:32:50.448]             function(cond) {
[10:32:50.448]                 is_error <- inherits(cond, "error")
[10:32:50.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.448]                   NULL)
[10:32:50.448]                 if (is_error) {
[10:32:50.448]                   sessionInformation <- function() {
[10:32:50.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.448]                       search = base::search(), system = base::Sys.info())
[10:32:50.448]                   }
[10:32:50.448]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.448]                     cond$call), session = sessionInformation(), 
[10:32:50.448]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.448]                   signalCondition(cond)
[10:32:50.448]                 }
[10:32:50.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.448]                 "immediateCondition"))) {
[10:32:50.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.448]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.448]                   if (TRUE && !signal) {
[10:32:50.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.448]                     {
[10:32:50.448]                       inherits <- base::inherits
[10:32:50.448]                       invokeRestart <- base::invokeRestart
[10:32:50.448]                       is.null <- base::is.null
[10:32:50.448]                       muffled <- FALSE
[10:32:50.448]                       if (inherits(cond, "message")) {
[10:32:50.448]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.448]                         if (muffled) 
[10:32:50.448]                           invokeRestart("muffleMessage")
[10:32:50.448]                       }
[10:32:50.448]                       else if (inherits(cond, "warning")) {
[10:32:50.448]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.448]                         if (muffled) 
[10:32:50.448]                           invokeRestart("muffleWarning")
[10:32:50.448]                       }
[10:32:50.448]                       else if (inherits(cond, "condition")) {
[10:32:50.448]                         if (!is.null(pattern)) {
[10:32:50.448]                           computeRestarts <- base::computeRestarts
[10:32:50.448]                           grepl <- base::grepl
[10:32:50.448]                           restarts <- computeRestarts(cond)
[10:32:50.448]                           for (restart in restarts) {
[10:32:50.448]                             name <- restart$name
[10:32:50.448]                             if (is.null(name)) 
[10:32:50.448]                               next
[10:32:50.448]                             if (!grepl(pattern, name)) 
[10:32:50.448]                               next
[10:32:50.448]                             invokeRestart(restart)
[10:32:50.448]                             muffled <- TRUE
[10:32:50.448]                             break
[10:32:50.448]                           }
[10:32:50.448]                         }
[10:32:50.448]                       }
[10:32:50.448]                       invisible(muffled)
[10:32:50.448]                     }
[10:32:50.448]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.448]                   }
[10:32:50.448]                 }
[10:32:50.448]                 else {
[10:32:50.448]                   if (TRUE) {
[10:32:50.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.448]                     {
[10:32:50.448]                       inherits <- base::inherits
[10:32:50.448]                       invokeRestart <- base::invokeRestart
[10:32:50.448]                       is.null <- base::is.null
[10:32:50.448]                       muffled <- FALSE
[10:32:50.448]                       if (inherits(cond, "message")) {
[10:32:50.448]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.448]                         if (muffled) 
[10:32:50.448]                           invokeRestart("muffleMessage")
[10:32:50.448]                       }
[10:32:50.448]                       else if (inherits(cond, "warning")) {
[10:32:50.448]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.448]                         if (muffled) 
[10:32:50.448]                           invokeRestart("muffleWarning")
[10:32:50.448]                       }
[10:32:50.448]                       else if (inherits(cond, "condition")) {
[10:32:50.448]                         if (!is.null(pattern)) {
[10:32:50.448]                           computeRestarts <- base::computeRestarts
[10:32:50.448]                           grepl <- base::grepl
[10:32:50.448]                           restarts <- computeRestarts(cond)
[10:32:50.448]                           for (restart in restarts) {
[10:32:50.448]                             name <- restart$name
[10:32:50.448]                             if (is.null(name)) 
[10:32:50.448]                               next
[10:32:50.448]                             if (!grepl(pattern, name)) 
[10:32:50.448]                               next
[10:32:50.448]                             invokeRestart(restart)
[10:32:50.448]                             muffled <- TRUE
[10:32:50.448]                             break
[10:32:50.448]                           }
[10:32:50.448]                         }
[10:32:50.448]                       }
[10:32:50.448]                       invisible(muffled)
[10:32:50.448]                     }
[10:32:50.448]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.448]                   }
[10:32:50.448]                 }
[10:32:50.448]             }
[10:32:50.448]         }))
[10:32:50.448]     }, error = function(ex) {
[10:32:50.448]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.448]                 ...future.rng), started = ...future.startTime, 
[10:32:50.448]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.448]             version = "1.8"), class = "FutureResult")
[10:32:50.448]     }, finally = {
[10:32:50.448]         if (!identical(...future.workdir, getwd())) 
[10:32:50.448]             setwd(...future.workdir)
[10:32:50.448]         {
[10:32:50.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.448]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.448]             }
[10:32:50.448]             base::options(...future.oldOptions)
[10:32:50.448]             if (.Platform$OS.type == "windows") {
[10:32:50.448]                 old_names <- names(...future.oldEnvVars)
[10:32:50.448]                 envs <- base::Sys.getenv()
[10:32:50.448]                 names <- names(envs)
[10:32:50.448]                 common <- intersect(names, old_names)
[10:32:50.448]                 added <- setdiff(names, old_names)
[10:32:50.448]                 removed <- setdiff(old_names, names)
[10:32:50.448]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.448]                   envs[common]]
[10:32:50.448]                 NAMES <- toupper(changed)
[10:32:50.448]                 args <- list()
[10:32:50.448]                 for (kk in seq_along(NAMES)) {
[10:32:50.448]                   name <- changed[[kk]]
[10:32:50.448]                   NAME <- NAMES[[kk]]
[10:32:50.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.448]                     next
[10:32:50.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.448]                 }
[10:32:50.448]                 NAMES <- toupper(added)
[10:32:50.448]                 for (kk in seq_along(NAMES)) {
[10:32:50.448]                   name <- added[[kk]]
[10:32:50.448]                   NAME <- NAMES[[kk]]
[10:32:50.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.448]                     next
[10:32:50.448]                   args[[name]] <- ""
[10:32:50.448]                 }
[10:32:50.448]                 NAMES <- toupper(removed)
[10:32:50.448]                 for (kk in seq_along(NAMES)) {
[10:32:50.448]                   name <- removed[[kk]]
[10:32:50.448]                   NAME <- NAMES[[kk]]
[10:32:50.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.448]                     next
[10:32:50.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.448]                 }
[10:32:50.448]                 if (length(args) > 0) 
[10:32:50.448]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.448]             }
[10:32:50.448]             else {
[10:32:50.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.448]             }
[10:32:50.448]             {
[10:32:50.448]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.448]                   0L) {
[10:32:50.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.448]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.448]                   base::options(opts)
[10:32:50.448]                 }
[10:32:50.448]                 {
[10:32:50.448]                   {
[10:32:50.448]                     NULL
[10:32:50.448]                     RNGkind("Mersenne-Twister")
[10:32:50.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.448]                       inherits = FALSE)
[10:32:50.448]                   }
[10:32:50.448]                   options(future.plan = NULL)
[10:32:50.448]                   if (is.na(NA_character_)) 
[10:32:50.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.448]                     .init = FALSE)
[10:32:50.448]                 }
[10:32:50.448]             }
[10:32:50.448]         }
[10:32:50.448]     })
[10:32:50.448]     if (TRUE) {
[10:32:50.448]         base::sink(type = "output", split = FALSE)
[10:32:50.448]         if (TRUE) {
[10:32:50.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.448]         }
[10:32:50.448]         else {
[10:32:50.448]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.448]         }
[10:32:50.448]         base::close(...future.stdout)
[10:32:50.448]         ...future.stdout <- NULL
[10:32:50.448]     }
[10:32:50.448]     ...future.result$conditions <- ...future.conditions
[10:32:50.448]     ...future.result$finished <- base::Sys.time()
[10:32:50.448]     ...future.result
[10:32:50.448] }
[10:32:50.450] plan(): Setting new future strategy stack:
[10:32:50.450] List of future strategies:
[10:32:50.450] 1. sequential:
[10:32:50.450]    - args: function (..., envir = parent.frame())
[10:32:50.450]    - tweaked: FALSE
[10:32:50.450]    - call: NULL
[10:32:50.451] plan(): nbrOfWorkers() = 1
[10:32:50.451] plan(): Setting new future strategy stack:
[10:32:50.451] List of future strategies:
[10:32:50.451] 1. sequential:
[10:32:50.451]    - args: function (..., envir = parent.frame())
[10:32:50.451]    - tweaked: FALSE
[10:32:50.451]    - call: plan(strategy)
[10:32:50.452] plan(): nbrOfWorkers() = 1
[10:32:50.452] SequentialFuture started (and completed)
[10:32:50.452] - Launch lazy future ... done
[10:32:50.452] run() for ‘SequentialFuture’ ... done
[10:32:50.452] getGlobalsAndPackages() ...
[10:32:50.453] Searching for globals...
[10:32:50.453] - globals found: [1] ‘{’
[10:32:50.453] Searching for globals ... DONE
[10:32:50.453] Resolving globals: FALSE
[10:32:50.454] 
[10:32:50.454] 
[10:32:50.454] getGlobalsAndPackages() ... DONE
[10:32:50.454] run() for ‘Future’ ...
[10:32:50.454] - state: ‘created’
[10:32:50.454] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.455]   - Field: ‘label’
[10:32:50.455]   - Field: ‘local’
[10:32:50.455]   - Field: ‘owner’
[10:32:50.455]   - Field: ‘envir’
[10:32:50.455]   - Field: ‘packages’
[10:32:50.455]   - Field: ‘gc’
[10:32:50.455]   - Field: ‘conditions’
[10:32:50.455]   - Field: ‘expr’
[10:32:50.455]   - Field: ‘uuid’
[10:32:50.456]   - Field: ‘seed’
[10:32:50.456]   - Field: ‘version’
[10:32:50.456]   - Field: ‘result’
[10:32:50.456]   - Field: ‘asynchronous’
[10:32:50.456]   - Field: ‘calls’
[10:32:50.456]   - Field: ‘globals’
[10:32:50.456]   - Field: ‘stdout’
[10:32:50.456]   - Field: ‘earlySignal’
[10:32:50.456]   - Field: ‘lazy’
[10:32:50.456]   - Field: ‘state’
[10:32:50.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.456] - Launch lazy future ...
[10:32:50.457] Packages needed by the future expression (n = 0): <none>
[10:32:50.457] Packages needed by future strategies (n = 0): <none>
[10:32:50.457] {
[10:32:50.457]     {
[10:32:50.457]         {
[10:32:50.457]             ...future.startTime <- base::Sys.time()
[10:32:50.457]             {
[10:32:50.457]                 {
[10:32:50.457]                   {
[10:32:50.457]                     base::local({
[10:32:50.457]                       has_future <- base::requireNamespace("future", 
[10:32:50.457]                         quietly = TRUE)
[10:32:50.457]                       if (has_future) {
[10:32:50.457]                         ns <- base::getNamespace("future")
[10:32:50.457]                         version <- ns[[".package"]][["version"]]
[10:32:50.457]                         if (is.null(version)) 
[10:32:50.457]                           version <- utils::packageVersion("future")
[10:32:50.457]                       }
[10:32:50.457]                       else {
[10:32:50.457]                         version <- NULL
[10:32:50.457]                       }
[10:32:50.457]                       if (!has_future || version < "1.8.0") {
[10:32:50.457]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.457]                           "", base::R.version$version.string), 
[10:32:50.457]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.457]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.457]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.457]                             "release", "version")], collapse = " "), 
[10:32:50.457]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.457]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.457]                           info)
[10:32:50.457]                         info <- base::paste(info, collapse = "; ")
[10:32:50.457]                         if (!has_future) {
[10:32:50.457]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.457]                             info)
[10:32:50.457]                         }
[10:32:50.457]                         else {
[10:32:50.457]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.457]                             info, version)
[10:32:50.457]                         }
[10:32:50.457]                         base::stop(msg)
[10:32:50.457]                       }
[10:32:50.457]                     })
[10:32:50.457]                   }
[10:32:50.457]                   ...future.strategy.old <- future::plan("list")
[10:32:50.457]                   options(future.plan = NULL)
[10:32:50.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.457]                 }
[10:32:50.457]                 ...future.workdir <- getwd()
[10:32:50.457]             }
[10:32:50.457]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.457]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.457]         }
[10:32:50.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.457]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.457]             base::names(...future.oldOptions))
[10:32:50.457]     }
[10:32:50.457]     if (FALSE) {
[10:32:50.457]     }
[10:32:50.457]     else {
[10:32:50.457]         if (TRUE) {
[10:32:50.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.457]                 open = "w")
[10:32:50.457]         }
[10:32:50.457]         else {
[10:32:50.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.457]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.457]         }
[10:32:50.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.457]             base::sink(type = "output", split = FALSE)
[10:32:50.457]             base::close(...future.stdout)
[10:32:50.457]         }, add = TRUE)
[10:32:50.457]     }
[10:32:50.457]     ...future.frame <- base::sys.nframe()
[10:32:50.457]     ...future.conditions <- base::list()
[10:32:50.457]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.457]     if (FALSE) {
[10:32:50.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.457]     }
[10:32:50.457]     ...future.result <- base::tryCatch({
[10:32:50.457]         base::withCallingHandlers({
[10:32:50.457]             ...future.value <- base::withVisible(base::local({
[10:32:50.457]                 4
[10:32:50.457]             }))
[10:32:50.457]             future::FutureResult(value = ...future.value$value, 
[10:32:50.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.457]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.457]                     ...future.globalenv.names))
[10:32:50.457]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.457]         }, condition = base::local({
[10:32:50.457]             c <- base::c
[10:32:50.457]             inherits <- base::inherits
[10:32:50.457]             invokeRestart <- base::invokeRestart
[10:32:50.457]             length <- base::length
[10:32:50.457]             list <- base::list
[10:32:50.457]             seq.int <- base::seq.int
[10:32:50.457]             signalCondition <- base::signalCondition
[10:32:50.457]             sys.calls <- base::sys.calls
[10:32:50.457]             `[[` <- base::`[[`
[10:32:50.457]             `+` <- base::`+`
[10:32:50.457]             `<<-` <- base::`<<-`
[10:32:50.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.457]                   3L)]
[10:32:50.457]             }
[10:32:50.457]             function(cond) {
[10:32:50.457]                 is_error <- inherits(cond, "error")
[10:32:50.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.457]                   NULL)
[10:32:50.457]                 if (is_error) {
[10:32:50.457]                   sessionInformation <- function() {
[10:32:50.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.457]                       search = base::search(), system = base::Sys.info())
[10:32:50.457]                   }
[10:32:50.457]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.457]                     cond$call), session = sessionInformation(), 
[10:32:50.457]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.457]                   signalCondition(cond)
[10:32:50.457]                 }
[10:32:50.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.457]                 "immediateCondition"))) {
[10:32:50.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.457]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.457]                   if (TRUE && !signal) {
[10:32:50.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.457]                     {
[10:32:50.457]                       inherits <- base::inherits
[10:32:50.457]                       invokeRestart <- base::invokeRestart
[10:32:50.457]                       is.null <- base::is.null
[10:32:50.457]                       muffled <- FALSE
[10:32:50.457]                       if (inherits(cond, "message")) {
[10:32:50.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.457]                         if (muffled) 
[10:32:50.457]                           invokeRestart("muffleMessage")
[10:32:50.457]                       }
[10:32:50.457]                       else if (inherits(cond, "warning")) {
[10:32:50.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.457]                         if (muffled) 
[10:32:50.457]                           invokeRestart("muffleWarning")
[10:32:50.457]                       }
[10:32:50.457]                       else if (inherits(cond, "condition")) {
[10:32:50.457]                         if (!is.null(pattern)) {
[10:32:50.457]                           computeRestarts <- base::computeRestarts
[10:32:50.457]                           grepl <- base::grepl
[10:32:50.457]                           restarts <- computeRestarts(cond)
[10:32:50.457]                           for (restart in restarts) {
[10:32:50.457]                             name <- restart$name
[10:32:50.457]                             if (is.null(name)) 
[10:32:50.457]                               next
[10:32:50.457]                             if (!grepl(pattern, name)) 
[10:32:50.457]                               next
[10:32:50.457]                             invokeRestart(restart)
[10:32:50.457]                             muffled <- TRUE
[10:32:50.457]                             break
[10:32:50.457]                           }
[10:32:50.457]                         }
[10:32:50.457]                       }
[10:32:50.457]                       invisible(muffled)
[10:32:50.457]                     }
[10:32:50.457]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.457]                   }
[10:32:50.457]                 }
[10:32:50.457]                 else {
[10:32:50.457]                   if (TRUE) {
[10:32:50.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.457]                     {
[10:32:50.457]                       inherits <- base::inherits
[10:32:50.457]                       invokeRestart <- base::invokeRestart
[10:32:50.457]                       is.null <- base::is.null
[10:32:50.457]                       muffled <- FALSE
[10:32:50.457]                       if (inherits(cond, "message")) {
[10:32:50.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.457]                         if (muffled) 
[10:32:50.457]                           invokeRestart("muffleMessage")
[10:32:50.457]                       }
[10:32:50.457]                       else if (inherits(cond, "warning")) {
[10:32:50.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.457]                         if (muffled) 
[10:32:50.457]                           invokeRestart("muffleWarning")
[10:32:50.457]                       }
[10:32:50.457]                       else if (inherits(cond, "condition")) {
[10:32:50.457]                         if (!is.null(pattern)) {
[10:32:50.457]                           computeRestarts <- base::computeRestarts
[10:32:50.457]                           grepl <- base::grepl
[10:32:50.457]                           restarts <- computeRestarts(cond)
[10:32:50.457]                           for (restart in restarts) {
[10:32:50.457]                             name <- restart$name
[10:32:50.457]                             if (is.null(name)) 
[10:32:50.457]                               next
[10:32:50.457]                             if (!grepl(pattern, name)) 
[10:32:50.457]                               next
[10:32:50.457]                             invokeRestart(restart)
[10:32:50.457]                             muffled <- TRUE
[10:32:50.457]                             break
[10:32:50.457]                           }
[10:32:50.457]                         }
[10:32:50.457]                       }
[10:32:50.457]                       invisible(muffled)
[10:32:50.457]                     }
[10:32:50.457]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.457]                   }
[10:32:50.457]                 }
[10:32:50.457]             }
[10:32:50.457]         }))
[10:32:50.457]     }, error = function(ex) {
[10:32:50.457]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.457]                 ...future.rng), started = ...future.startTime, 
[10:32:50.457]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.457]             version = "1.8"), class = "FutureResult")
[10:32:50.457]     }, finally = {
[10:32:50.457]         if (!identical(...future.workdir, getwd())) 
[10:32:50.457]             setwd(...future.workdir)
[10:32:50.457]         {
[10:32:50.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.457]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.457]             }
[10:32:50.457]             base::options(...future.oldOptions)
[10:32:50.457]             if (.Platform$OS.type == "windows") {
[10:32:50.457]                 old_names <- names(...future.oldEnvVars)
[10:32:50.457]                 envs <- base::Sys.getenv()
[10:32:50.457]                 names <- names(envs)
[10:32:50.457]                 common <- intersect(names, old_names)
[10:32:50.457]                 added <- setdiff(names, old_names)
[10:32:50.457]                 removed <- setdiff(old_names, names)
[10:32:50.457]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.457]                   envs[common]]
[10:32:50.457]                 NAMES <- toupper(changed)
[10:32:50.457]                 args <- list()
[10:32:50.457]                 for (kk in seq_along(NAMES)) {
[10:32:50.457]                   name <- changed[[kk]]
[10:32:50.457]                   NAME <- NAMES[[kk]]
[10:32:50.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.457]                     next
[10:32:50.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.457]                 }
[10:32:50.457]                 NAMES <- toupper(added)
[10:32:50.457]                 for (kk in seq_along(NAMES)) {
[10:32:50.457]                   name <- added[[kk]]
[10:32:50.457]                   NAME <- NAMES[[kk]]
[10:32:50.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.457]                     next
[10:32:50.457]                   args[[name]] <- ""
[10:32:50.457]                 }
[10:32:50.457]                 NAMES <- toupper(removed)
[10:32:50.457]                 for (kk in seq_along(NAMES)) {
[10:32:50.457]                   name <- removed[[kk]]
[10:32:50.457]                   NAME <- NAMES[[kk]]
[10:32:50.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.457]                     next
[10:32:50.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.457]                 }
[10:32:50.457]                 if (length(args) > 0) 
[10:32:50.457]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.457]             }
[10:32:50.457]             else {
[10:32:50.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.457]             }
[10:32:50.457]             {
[10:32:50.457]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.457]                   0L) {
[10:32:50.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.457]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.457]                   base::options(opts)
[10:32:50.457]                 }
[10:32:50.457]                 {
[10:32:50.457]                   {
[10:32:50.457]                     NULL
[10:32:50.457]                     RNGkind("Mersenne-Twister")
[10:32:50.457]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.457]                       inherits = FALSE)
[10:32:50.457]                   }
[10:32:50.457]                   options(future.plan = NULL)
[10:32:50.457]                   if (is.na(NA_character_)) 
[10:32:50.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.457]                     .init = FALSE)
[10:32:50.457]                 }
[10:32:50.457]             }
[10:32:50.457]         }
[10:32:50.457]     })
[10:32:50.457]     if (TRUE) {
[10:32:50.457]         base::sink(type = "output", split = FALSE)
[10:32:50.457]         if (TRUE) {
[10:32:50.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.457]         }
[10:32:50.457]         else {
[10:32:50.457]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.457]         }
[10:32:50.457]         base::close(...future.stdout)
[10:32:50.457]         ...future.stdout <- NULL
[10:32:50.457]     }
[10:32:50.457]     ...future.result$conditions <- ...future.conditions
[10:32:50.457]     ...future.result$finished <- base::Sys.time()
[10:32:50.457]     ...future.result
[10:32:50.457] }
[10:32:50.459] plan(): Setting new future strategy stack:
[10:32:50.459] List of future strategies:
[10:32:50.459] 1. sequential:
[10:32:50.459]    - args: function (..., envir = parent.frame())
[10:32:50.459]    - tweaked: FALSE
[10:32:50.459]    - call: NULL
[10:32:50.459] plan(): nbrOfWorkers() = 1
[10:32:50.460] plan(): Setting new future strategy stack:
[10:32:50.460] List of future strategies:
[10:32:50.460] 1. sequential:
[10:32:50.460]    - args: function (..., envir = parent.frame())
[10:32:50.460]    - tweaked: FALSE
[10:32:50.460]    - call: plan(strategy)
[10:32:50.460] plan(): nbrOfWorkers() = 1
[10:32:50.461] SequentialFuture started (and completed)
[10:32:50.461] - Launch lazy future ... done
[10:32:50.461] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d0c92538> 
Classes 'listenv', 'environment' <environment: 0x5652d0a65688> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:32:50.464] resolved() for ‘SequentialFuture’ ...
[10:32:50.464] - state: ‘finished’
[10:32:50.465] - run: TRUE
[10:32:50.465] - result: ‘FutureResult’
[10:32:50.465] resolved() for ‘SequentialFuture’ ... done
[10:32:50.465] resolved() for ‘SequentialFuture’ ...
[10:32:50.465] - state: ‘finished’
[10:32:50.465] - run: TRUE
[10:32:50.465] - result: ‘FutureResult’
[10:32:50.465] resolved() for ‘SequentialFuture’ ... done
[10:32:50.465] resolved() for ‘SequentialFuture’ ...
[10:32:50.465] - state: ‘finished’
[10:32:50.466] - run: TRUE
[10:32:50.466] - result: ‘FutureResult’
[10:32:50.466] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:50.468] resolve() on list environment ...
[10:32:50.468]  recursive: 0
[10:32:50.469]  length: 6
[10:32:50.469]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:50.469] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.469] - nx: 6
[10:32:50.469] - relay: TRUE
[10:32:50.470] - stdout: TRUE
[10:32:50.470] - signal: TRUE
[10:32:50.470] - resignal: FALSE
[10:32:50.470] - force: TRUE
[10:32:50.470] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.470] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.470]  - until=2
[10:32:50.470]  - relaying element #2
[10:32:50.470] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.470] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.470] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.471]  length: 5 (resolved future 1)
[10:32:50.471] resolved() for ‘SequentialFuture’ ...
[10:32:50.471] - state: ‘finished’
[10:32:50.471] - run: TRUE
[10:32:50.471] - result: ‘FutureResult’
[10:32:50.471] resolved() for ‘SequentialFuture’ ... done
[10:32:50.471] Future #2
[10:32:50.471] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.471] - nx: 6
[10:32:50.471] - relay: TRUE
[10:32:50.472] - stdout: TRUE
[10:32:50.472] - signal: TRUE
[10:32:50.472] - resignal: FALSE
[10:32:50.472] - force: TRUE
[10:32:50.472] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.472] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.472]  - until=2
[10:32:50.472]  - relaying element #2
[10:32:50.472] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.472] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.472] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.473]  length: 4 (resolved future 2)
[10:32:50.473] resolved() for ‘SequentialFuture’ ...
[10:32:50.473] - state: ‘finished’
[10:32:50.473] - run: TRUE
[10:32:50.473] - result: ‘FutureResult’
[10:32:50.473] resolved() for ‘SequentialFuture’ ... done
[10:32:50.473] Future #3
[10:32:50.473] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.473] - nx: 6
[10:32:50.473] - relay: TRUE
[10:32:50.474] - stdout: TRUE
[10:32:50.474] - signal: TRUE
[10:32:50.474] - resignal: FALSE
[10:32:50.474] - force: TRUE
[10:32:50.474] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.474] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.474]  - until=3
[10:32:50.474]  - relaying element #3
[10:32:50.475] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.475] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.475] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.475]  length: 3 (resolved future 3)
[10:32:50.476] resolved() for ‘SequentialFuture’ ...
[10:32:50.476] - state: ‘finished’
[10:32:50.476] - run: TRUE
[10:32:50.476] - result: ‘FutureResult’
[10:32:50.476] resolved() for ‘SequentialFuture’ ... done
[10:32:50.476] Future #4
[10:32:50.476] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.476] - nx: 6
[10:32:50.476] - relay: TRUE
[10:32:50.476] - stdout: TRUE
[10:32:50.477] - signal: TRUE
[10:32:50.477] - resignal: FALSE
[10:32:50.477] - force: TRUE
[10:32:50.477] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.477] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.477]  - until=4
[10:32:50.477]  - relaying element #4
[10:32:50.477] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.477] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.477] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.477]  length: 2 (resolved future 4)
[10:32:50.478] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.478] - nx: 6
[10:32:50.478] - relay: TRUE
[10:32:50.478] - stdout: TRUE
[10:32:50.478] - signal: TRUE
[10:32:50.478] - resignal: FALSE
[10:32:50.478] - force: TRUE
[10:32:50.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.478] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.478]  - until=6
[10:32:50.478]  - relaying element #6
[10:32:50.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.479] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.479] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.479]  length: 1 (resolved future 5)
[10:32:50.479] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.479] - nx: 6
[10:32:50.479] - relay: TRUE
[10:32:50.479] - stdout: TRUE
[10:32:50.479] - signal: TRUE
[10:32:50.479] - resignal: FALSE
[10:32:50.479] - force: TRUE
[10:32:50.479] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.479] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.480]  - until=6
[10:32:50.480] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.480] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.480] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.480]  length: 0 (resolved future 6)
[10:32:50.480] Relaying remaining futures
[10:32:50.480] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.480] - nx: 6
[10:32:50.480] - relay: TRUE
[10:32:50.480] - stdout: TRUE
[10:32:50.480] - signal: TRUE
[10:32:50.480] - resignal: FALSE
[10:32:50.481] - force: TRUE
[10:32:50.481] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.481] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:50.481] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.481] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.481] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.481] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5652d0fe8170> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:32:50.483] getGlobalsAndPackages() ...
[10:32:50.483] Searching for globals...
[10:32:50.483] 
[10:32:50.484] Searching for globals ... DONE
[10:32:50.484] - globals: [0] <none>
[10:32:50.484] getGlobalsAndPackages() ... DONE
[10:32:50.484] run() for ‘Future’ ...
[10:32:50.484] - state: ‘created’
[10:32:50.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.484] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.485]   - Field: ‘label’
[10:32:50.485]   - Field: ‘local’
[10:32:50.485]   - Field: ‘owner’
[10:32:50.485]   - Field: ‘envir’
[10:32:50.485]   - Field: ‘packages’
[10:32:50.485]   - Field: ‘gc’
[10:32:50.485]   - Field: ‘conditions’
[10:32:50.485]   - Field: ‘expr’
[10:32:50.485]   - Field: ‘uuid’
[10:32:50.485]   - Field: ‘seed’
[10:32:50.485]   - Field: ‘version’
[10:32:50.486]   - Field: ‘result’
[10:32:50.486]   - Field: ‘asynchronous’
[10:32:50.486]   - Field: ‘calls’
[10:32:50.486]   - Field: ‘globals’
[10:32:50.486]   - Field: ‘stdout’
[10:32:50.486]   - Field: ‘earlySignal’
[10:32:50.486]   - Field: ‘lazy’
[10:32:50.486]   - Field: ‘state’
[10:32:50.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.486] - Launch lazy future ...
[10:32:50.487] Packages needed by the future expression (n = 0): <none>
[10:32:50.487] Packages needed by future strategies (n = 0): <none>
[10:32:50.487] {
[10:32:50.487]     {
[10:32:50.487]         {
[10:32:50.487]             ...future.startTime <- base::Sys.time()
[10:32:50.487]             {
[10:32:50.487]                 {
[10:32:50.487]                   {
[10:32:50.487]                     base::local({
[10:32:50.487]                       has_future <- base::requireNamespace("future", 
[10:32:50.487]                         quietly = TRUE)
[10:32:50.487]                       if (has_future) {
[10:32:50.487]                         ns <- base::getNamespace("future")
[10:32:50.487]                         version <- ns[[".package"]][["version"]]
[10:32:50.487]                         if (is.null(version)) 
[10:32:50.487]                           version <- utils::packageVersion("future")
[10:32:50.487]                       }
[10:32:50.487]                       else {
[10:32:50.487]                         version <- NULL
[10:32:50.487]                       }
[10:32:50.487]                       if (!has_future || version < "1.8.0") {
[10:32:50.487]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.487]                           "", base::R.version$version.string), 
[10:32:50.487]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.487]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.487]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.487]                             "release", "version")], collapse = " "), 
[10:32:50.487]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.487]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.487]                           info)
[10:32:50.487]                         info <- base::paste(info, collapse = "; ")
[10:32:50.487]                         if (!has_future) {
[10:32:50.487]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.487]                             info)
[10:32:50.487]                         }
[10:32:50.487]                         else {
[10:32:50.487]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.487]                             info, version)
[10:32:50.487]                         }
[10:32:50.487]                         base::stop(msg)
[10:32:50.487]                       }
[10:32:50.487]                     })
[10:32:50.487]                   }
[10:32:50.487]                   ...future.strategy.old <- future::plan("list")
[10:32:50.487]                   options(future.plan = NULL)
[10:32:50.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.487]                 }
[10:32:50.487]                 ...future.workdir <- getwd()
[10:32:50.487]             }
[10:32:50.487]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.487]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.487]         }
[10:32:50.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.487]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.487]             base::names(...future.oldOptions))
[10:32:50.487]     }
[10:32:50.487]     if (FALSE) {
[10:32:50.487]     }
[10:32:50.487]     else {
[10:32:50.487]         if (TRUE) {
[10:32:50.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.487]                 open = "w")
[10:32:50.487]         }
[10:32:50.487]         else {
[10:32:50.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.487]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.487]         }
[10:32:50.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.487]             base::sink(type = "output", split = FALSE)
[10:32:50.487]             base::close(...future.stdout)
[10:32:50.487]         }, add = TRUE)
[10:32:50.487]     }
[10:32:50.487]     ...future.frame <- base::sys.nframe()
[10:32:50.487]     ...future.conditions <- base::list()
[10:32:50.487]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.487]     if (FALSE) {
[10:32:50.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.487]     }
[10:32:50.487]     ...future.result <- base::tryCatch({
[10:32:50.487]         base::withCallingHandlers({
[10:32:50.487]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.487]             future::FutureResult(value = ...future.value$value, 
[10:32:50.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.487]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.487]                     ...future.globalenv.names))
[10:32:50.487]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.487]         }, condition = base::local({
[10:32:50.487]             c <- base::c
[10:32:50.487]             inherits <- base::inherits
[10:32:50.487]             invokeRestart <- base::invokeRestart
[10:32:50.487]             length <- base::length
[10:32:50.487]             list <- base::list
[10:32:50.487]             seq.int <- base::seq.int
[10:32:50.487]             signalCondition <- base::signalCondition
[10:32:50.487]             sys.calls <- base::sys.calls
[10:32:50.487]             `[[` <- base::`[[`
[10:32:50.487]             `+` <- base::`+`
[10:32:50.487]             `<<-` <- base::`<<-`
[10:32:50.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.487]                   3L)]
[10:32:50.487]             }
[10:32:50.487]             function(cond) {
[10:32:50.487]                 is_error <- inherits(cond, "error")
[10:32:50.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.487]                   NULL)
[10:32:50.487]                 if (is_error) {
[10:32:50.487]                   sessionInformation <- function() {
[10:32:50.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.487]                       search = base::search(), system = base::Sys.info())
[10:32:50.487]                   }
[10:32:50.487]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.487]                     cond$call), session = sessionInformation(), 
[10:32:50.487]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.487]                   signalCondition(cond)
[10:32:50.487]                 }
[10:32:50.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.487]                 "immediateCondition"))) {
[10:32:50.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.487]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.487]                   if (TRUE && !signal) {
[10:32:50.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.487]                     {
[10:32:50.487]                       inherits <- base::inherits
[10:32:50.487]                       invokeRestart <- base::invokeRestart
[10:32:50.487]                       is.null <- base::is.null
[10:32:50.487]                       muffled <- FALSE
[10:32:50.487]                       if (inherits(cond, "message")) {
[10:32:50.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.487]                         if (muffled) 
[10:32:50.487]                           invokeRestart("muffleMessage")
[10:32:50.487]                       }
[10:32:50.487]                       else if (inherits(cond, "warning")) {
[10:32:50.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.487]                         if (muffled) 
[10:32:50.487]                           invokeRestart("muffleWarning")
[10:32:50.487]                       }
[10:32:50.487]                       else if (inherits(cond, "condition")) {
[10:32:50.487]                         if (!is.null(pattern)) {
[10:32:50.487]                           computeRestarts <- base::computeRestarts
[10:32:50.487]                           grepl <- base::grepl
[10:32:50.487]                           restarts <- computeRestarts(cond)
[10:32:50.487]                           for (restart in restarts) {
[10:32:50.487]                             name <- restart$name
[10:32:50.487]                             if (is.null(name)) 
[10:32:50.487]                               next
[10:32:50.487]                             if (!grepl(pattern, name)) 
[10:32:50.487]                               next
[10:32:50.487]                             invokeRestart(restart)
[10:32:50.487]                             muffled <- TRUE
[10:32:50.487]                             break
[10:32:50.487]                           }
[10:32:50.487]                         }
[10:32:50.487]                       }
[10:32:50.487]                       invisible(muffled)
[10:32:50.487]                     }
[10:32:50.487]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.487]                   }
[10:32:50.487]                 }
[10:32:50.487]                 else {
[10:32:50.487]                   if (TRUE) {
[10:32:50.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.487]                     {
[10:32:50.487]                       inherits <- base::inherits
[10:32:50.487]                       invokeRestart <- base::invokeRestart
[10:32:50.487]                       is.null <- base::is.null
[10:32:50.487]                       muffled <- FALSE
[10:32:50.487]                       if (inherits(cond, "message")) {
[10:32:50.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.487]                         if (muffled) 
[10:32:50.487]                           invokeRestart("muffleMessage")
[10:32:50.487]                       }
[10:32:50.487]                       else if (inherits(cond, "warning")) {
[10:32:50.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.487]                         if (muffled) 
[10:32:50.487]                           invokeRestart("muffleWarning")
[10:32:50.487]                       }
[10:32:50.487]                       else if (inherits(cond, "condition")) {
[10:32:50.487]                         if (!is.null(pattern)) {
[10:32:50.487]                           computeRestarts <- base::computeRestarts
[10:32:50.487]                           grepl <- base::grepl
[10:32:50.487]                           restarts <- computeRestarts(cond)
[10:32:50.487]                           for (restart in restarts) {
[10:32:50.487]                             name <- restart$name
[10:32:50.487]                             if (is.null(name)) 
[10:32:50.487]                               next
[10:32:50.487]                             if (!grepl(pattern, name)) 
[10:32:50.487]                               next
[10:32:50.487]                             invokeRestart(restart)
[10:32:50.487]                             muffled <- TRUE
[10:32:50.487]                             break
[10:32:50.487]                           }
[10:32:50.487]                         }
[10:32:50.487]                       }
[10:32:50.487]                       invisible(muffled)
[10:32:50.487]                     }
[10:32:50.487]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.487]                   }
[10:32:50.487]                 }
[10:32:50.487]             }
[10:32:50.487]         }))
[10:32:50.487]     }, error = function(ex) {
[10:32:50.487]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.487]                 ...future.rng), started = ...future.startTime, 
[10:32:50.487]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.487]             version = "1.8"), class = "FutureResult")
[10:32:50.487]     }, finally = {
[10:32:50.487]         if (!identical(...future.workdir, getwd())) 
[10:32:50.487]             setwd(...future.workdir)
[10:32:50.487]         {
[10:32:50.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.487]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.487]             }
[10:32:50.487]             base::options(...future.oldOptions)
[10:32:50.487]             if (.Platform$OS.type == "windows") {
[10:32:50.487]                 old_names <- names(...future.oldEnvVars)
[10:32:50.487]                 envs <- base::Sys.getenv()
[10:32:50.487]                 names <- names(envs)
[10:32:50.487]                 common <- intersect(names, old_names)
[10:32:50.487]                 added <- setdiff(names, old_names)
[10:32:50.487]                 removed <- setdiff(old_names, names)
[10:32:50.487]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.487]                   envs[common]]
[10:32:50.487]                 NAMES <- toupper(changed)
[10:32:50.487]                 args <- list()
[10:32:50.487]                 for (kk in seq_along(NAMES)) {
[10:32:50.487]                   name <- changed[[kk]]
[10:32:50.487]                   NAME <- NAMES[[kk]]
[10:32:50.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.487]                     next
[10:32:50.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.487]                 }
[10:32:50.487]                 NAMES <- toupper(added)
[10:32:50.487]                 for (kk in seq_along(NAMES)) {
[10:32:50.487]                   name <- added[[kk]]
[10:32:50.487]                   NAME <- NAMES[[kk]]
[10:32:50.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.487]                     next
[10:32:50.487]                   args[[name]] <- ""
[10:32:50.487]                 }
[10:32:50.487]                 NAMES <- toupper(removed)
[10:32:50.487]                 for (kk in seq_along(NAMES)) {
[10:32:50.487]                   name <- removed[[kk]]
[10:32:50.487]                   NAME <- NAMES[[kk]]
[10:32:50.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.487]                     next
[10:32:50.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.487]                 }
[10:32:50.487]                 if (length(args) > 0) 
[10:32:50.487]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.487]             }
[10:32:50.487]             else {
[10:32:50.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.487]             }
[10:32:50.487]             {
[10:32:50.487]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.487]                   0L) {
[10:32:50.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.487]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.487]                   base::options(opts)
[10:32:50.487]                 }
[10:32:50.487]                 {
[10:32:50.487]                   {
[10:32:50.487]                     NULL
[10:32:50.487]                     RNGkind("Mersenne-Twister")
[10:32:50.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.487]                       inherits = FALSE)
[10:32:50.487]                   }
[10:32:50.487]                   options(future.plan = NULL)
[10:32:50.487]                   if (is.na(NA_character_)) 
[10:32:50.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.487]                     .init = FALSE)
[10:32:50.487]                 }
[10:32:50.487]             }
[10:32:50.487]         }
[10:32:50.487]     })
[10:32:50.487]     if (TRUE) {
[10:32:50.487]         base::sink(type = "output", split = FALSE)
[10:32:50.487]         if (TRUE) {
[10:32:50.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.487]         }
[10:32:50.487]         else {
[10:32:50.487]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.487]         }
[10:32:50.487]         base::close(...future.stdout)
[10:32:50.487]         ...future.stdout <- NULL
[10:32:50.487]     }
[10:32:50.487]     ...future.result$conditions <- ...future.conditions
[10:32:50.487]     ...future.result$finished <- base::Sys.time()
[10:32:50.487]     ...future.result
[10:32:50.487] }
[10:32:50.489] plan(): Setting new future strategy stack:
[10:32:50.489] List of future strategies:
[10:32:50.489] 1. sequential:
[10:32:50.489]    - args: function (..., envir = parent.frame())
[10:32:50.489]    - tweaked: FALSE
[10:32:50.489]    - call: NULL
[10:32:50.489] plan(): nbrOfWorkers() = 1
[10:32:50.490] plan(): Setting new future strategy stack:
[10:32:50.490] List of future strategies:
[10:32:50.490] 1. sequential:
[10:32:50.490]    - args: function (..., envir = parent.frame())
[10:32:50.490]    - tweaked: FALSE
[10:32:50.490]    - call: plan(strategy)
[10:32:50.490] plan(): nbrOfWorkers() = 1
[10:32:50.490] SequentialFuture started (and completed)
[10:32:50.490] - Launch lazy future ... done
[10:32:50.491] run() for ‘SequentialFuture’ ... done
[10:32:50.491] getGlobalsAndPackages() ...
[10:32:50.491] Searching for globals...
[10:32:50.491] 
[10:32:50.491] Searching for globals ... DONE
[10:32:50.491] - globals: [0] <none>
[10:32:50.491] getGlobalsAndPackages() ... DONE
[10:32:50.492] run() for ‘Future’ ...
[10:32:50.492] - state: ‘created’
[10:32:50.492] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.492] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.492]   - Field: ‘label’
[10:32:50.492]   - Field: ‘local’
[10:32:50.492]   - Field: ‘owner’
[10:32:50.492]   - Field: ‘envir’
[10:32:50.493]   - Field: ‘packages’
[10:32:50.493]   - Field: ‘gc’
[10:32:50.493]   - Field: ‘conditions’
[10:32:50.493]   - Field: ‘expr’
[10:32:50.493]   - Field: ‘uuid’
[10:32:50.493]   - Field: ‘seed’
[10:32:50.493]   - Field: ‘version’
[10:32:50.493]   - Field: ‘result’
[10:32:50.493]   - Field: ‘asynchronous’
[10:32:50.493]   - Field: ‘calls’
[10:32:50.493]   - Field: ‘globals’
[10:32:50.494]   - Field: ‘stdout’
[10:32:50.494]   - Field: ‘earlySignal’
[10:32:50.494]   - Field: ‘lazy’
[10:32:50.494]   - Field: ‘state’
[10:32:50.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.494] - Launch lazy future ...
[10:32:50.494] Packages needed by the future expression (n = 0): <none>
[10:32:50.494] Packages needed by future strategies (n = 0): <none>
[10:32:50.495] {
[10:32:50.495]     {
[10:32:50.495]         {
[10:32:50.495]             ...future.startTime <- base::Sys.time()
[10:32:50.495]             {
[10:32:50.495]                 {
[10:32:50.495]                   {
[10:32:50.495]                     base::local({
[10:32:50.495]                       has_future <- base::requireNamespace("future", 
[10:32:50.495]                         quietly = TRUE)
[10:32:50.495]                       if (has_future) {
[10:32:50.495]                         ns <- base::getNamespace("future")
[10:32:50.495]                         version <- ns[[".package"]][["version"]]
[10:32:50.495]                         if (is.null(version)) 
[10:32:50.495]                           version <- utils::packageVersion("future")
[10:32:50.495]                       }
[10:32:50.495]                       else {
[10:32:50.495]                         version <- NULL
[10:32:50.495]                       }
[10:32:50.495]                       if (!has_future || version < "1.8.0") {
[10:32:50.495]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.495]                           "", base::R.version$version.string), 
[10:32:50.495]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.495]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.495]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.495]                             "release", "version")], collapse = " "), 
[10:32:50.495]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.495]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.495]                           info)
[10:32:50.495]                         info <- base::paste(info, collapse = "; ")
[10:32:50.495]                         if (!has_future) {
[10:32:50.495]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.495]                             info)
[10:32:50.495]                         }
[10:32:50.495]                         else {
[10:32:50.495]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.495]                             info, version)
[10:32:50.495]                         }
[10:32:50.495]                         base::stop(msg)
[10:32:50.495]                       }
[10:32:50.495]                     })
[10:32:50.495]                   }
[10:32:50.495]                   ...future.strategy.old <- future::plan("list")
[10:32:50.495]                   options(future.plan = NULL)
[10:32:50.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.495]                 }
[10:32:50.495]                 ...future.workdir <- getwd()
[10:32:50.495]             }
[10:32:50.495]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.495]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.495]         }
[10:32:50.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.495]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.495]             base::names(...future.oldOptions))
[10:32:50.495]     }
[10:32:50.495]     if (FALSE) {
[10:32:50.495]     }
[10:32:50.495]     else {
[10:32:50.495]         if (TRUE) {
[10:32:50.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.495]                 open = "w")
[10:32:50.495]         }
[10:32:50.495]         else {
[10:32:50.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.495]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.495]         }
[10:32:50.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.495]             base::sink(type = "output", split = FALSE)
[10:32:50.495]             base::close(...future.stdout)
[10:32:50.495]         }, add = TRUE)
[10:32:50.495]     }
[10:32:50.495]     ...future.frame <- base::sys.nframe()
[10:32:50.495]     ...future.conditions <- base::list()
[10:32:50.495]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.495]     if (FALSE) {
[10:32:50.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.495]     }
[10:32:50.495]     ...future.result <- base::tryCatch({
[10:32:50.495]         base::withCallingHandlers({
[10:32:50.495]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.495]             future::FutureResult(value = ...future.value$value, 
[10:32:50.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.495]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.495]                     ...future.globalenv.names))
[10:32:50.495]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.495]         }, condition = base::local({
[10:32:50.495]             c <- base::c
[10:32:50.495]             inherits <- base::inherits
[10:32:50.495]             invokeRestart <- base::invokeRestart
[10:32:50.495]             length <- base::length
[10:32:50.495]             list <- base::list
[10:32:50.495]             seq.int <- base::seq.int
[10:32:50.495]             signalCondition <- base::signalCondition
[10:32:50.495]             sys.calls <- base::sys.calls
[10:32:50.495]             `[[` <- base::`[[`
[10:32:50.495]             `+` <- base::`+`
[10:32:50.495]             `<<-` <- base::`<<-`
[10:32:50.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.495]                   3L)]
[10:32:50.495]             }
[10:32:50.495]             function(cond) {
[10:32:50.495]                 is_error <- inherits(cond, "error")
[10:32:50.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.495]                   NULL)
[10:32:50.495]                 if (is_error) {
[10:32:50.495]                   sessionInformation <- function() {
[10:32:50.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.495]                       search = base::search(), system = base::Sys.info())
[10:32:50.495]                   }
[10:32:50.495]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.495]                     cond$call), session = sessionInformation(), 
[10:32:50.495]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.495]                   signalCondition(cond)
[10:32:50.495]                 }
[10:32:50.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.495]                 "immediateCondition"))) {
[10:32:50.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.495]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.495]                   if (TRUE && !signal) {
[10:32:50.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.495]                     {
[10:32:50.495]                       inherits <- base::inherits
[10:32:50.495]                       invokeRestart <- base::invokeRestart
[10:32:50.495]                       is.null <- base::is.null
[10:32:50.495]                       muffled <- FALSE
[10:32:50.495]                       if (inherits(cond, "message")) {
[10:32:50.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.495]                         if (muffled) 
[10:32:50.495]                           invokeRestart("muffleMessage")
[10:32:50.495]                       }
[10:32:50.495]                       else if (inherits(cond, "warning")) {
[10:32:50.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.495]                         if (muffled) 
[10:32:50.495]                           invokeRestart("muffleWarning")
[10:32:50.495]                       }
[10:32:50.495]                       else if (inherits(cond, "condition")) {
[10:32:50.495]                         if (!is.null(pattern)) {
[10:32:50.495]                           computeRestarts <- base::computeRestarts
[10:32:50.495]                           grepl <- base::grepl
[10:32:50.495]                           restarts <- computeRestarts(cond)
[10:32:50.495]                           for (restart in restarts) {
[10:32:50.495]                             name <- restart$name
[10:32:50.495]                             if (is.null(name)) 
[10:32:50.495]                               next
[10:32:50.495]                             if (!grepl(pattern, name)) 
[10:32:50.495]                               next
[10:32:50.495]                             invokeRestart(restart)
[10:32:50.495]                             muffled <- TRUE
[10:32:50.495]                             break
[10:32:50.495]                           }
[10:32:50.495]                         }
[10:32:50.495]                       }
[10:32:50.495]                       invisible(muffled)
[10:32:50.495]                     }
[10:32:50.495]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.495]                   }
[10:32:50.495]                 }
[10:32:50.495]                 else {
[10:32:50.495]                   if (TRUE) {
[10:32:50.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.495]                     {
[10:32:50.495]                       inherits <- base::inherits
[10:32:50.495]                       invokeRestart <- base::invokeRestart
[10:32:50.495]                       is.null <- base::is.null
[10:32:50.495]                       muffled <- FALSE
[10:32:50.495]                       if (inherits(cond, "message")) {
[10:32:50.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.495]                         if (muffled) 
[10:32:50.495]                           invokeRestart("muffleMessage")
[10:32:50.495]                       }
[10:32:50.495]                       else if (inherits(cond, "warning")) {
[10:32:50.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.495]                         if (muffled) 
[10:32:50.495]                           invokeRestart("muffleWarning")
[10:32:50.495]                       }
[10:32:50.495]                       else if (inherits(cond, "condition")) {
[10:32:50.495]                         if (!is.null(pattern)) {
[10:32:50.495]                           computeRestarts <- base::computeRestarts
[10:32:50.495]                           grepl <- base::grepl
[10:32:50.495]                           restarts <- computeRestarts(cond)
[10:32:50.495]                           for (restart in restarts) {
[10:32:50.495]                             name <- restart$name
[10:32:50.495]                             if (is.null(name)) 
[10:32:50.495]                               next
[10:32:50.495]                             if (!grepl(pattern, name)) 
[10:32:50.495]                               next
[10:32:50.495]                             invokeRestart(restart)
[10:32:50.495]                             muffled <- TRUE
[10:32:50.495]                             break
[10:32:50.495]                           }
[10:32:50.495]                         }
[10:32:50.495]                       }
[10:32:50.495]                       invisible(muffled)
[10:32:50.495]                     }
[10:32:50.495]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.495]                   }
[10:32:50.495]                 }
[10:32:50.495]             }
[10:32:50.495]         }))
[10:32:50.495]     }, error = function(ex) {
[10:32:50.495]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.495]                 ...future.rng), started = ...future.startTime, 
[10:32:50.495]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.495]             version = "1.8"), class = "FutureResult")
[10:32:50.495]     }, finally = {
[10:32:50.495]         if (!identical(...future.workdir, getwd())) 
[10:32:50.495]             setwd(...future.workdir)
[10:32:50.495]         {
[10:32:50.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.495]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.495]             }
[10:32:50.495]             base::options(...future.oldOptions)
[10:32:50.495]             if (.Platform$OS.type == "windows") {
[10:32:50.495]                 old_names <- names(...future.oldEnvVars)
[10:32:50.495]                 envs <- base::Sys.getenv()
[10:32:50.495]                 names <- names(envs)
[10:32:50.495]                 common <- intersect(names, old_names)
[10:32:50.495]                 added <- setdiff(names, old_names)
[10:32:50.495]                 removed <- setdiff(old_names, names)
[10:32:50.495]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.495]                   envs[common]]
[10:32:50.495]                 NAMES <- toupper(changed)
[10:32:50.495]                 args <- list()
[10:32:50.495]                 for (kk in seq_along(NAMES)) {
[10:32:50.495]                   name <- changed[[kk]]
[10:32:50.495]                   NAME <- NAMES[[kk]]
[10:32:50.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.495]                     next
[10:32:50.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.495]                 }
[10:32:50.495]                 NAMES <- toupper(added)
[10:32:50.495]                 for (kk in seq_along(NAMES)) {
[10:32:50.495]                   name <- added[[kk]]
[10:32:50.495]                   NAME <- NAMES[[kk]]
[10:32:50.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.495]                     next
[10:32:50.495]                   args[[name]] <- ""
[10:32:50.495]                 }
[10:32:50.495]                 NAMES <- toupper(removed)
[10:32:50.495]                 for (kk in seq_along(NAMES)) {
[10:32:50.495]                   name <- removed[[kk]]
[10:32:50.495]                   NAME <- NAMES[[kk]]
[10:32:50.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.495]                     next
[10:32:50.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.495]                 }
[10:32:50.495]                 if (length(args) > 0) 
[10:32:50.495]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.495]             }
[10:32:50.495]             else {
[10:32:50.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.495]             }
[10:32:50.495]             {
[10:32:50.495]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.495]                   0L) {
[10:32:50.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.495]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.495]                   base::options(opts)
[10:32:50.495]                 }
[10:32:50.495]                 {
[10:32:50.495]                   {
[10:32:50.495]                     NULL
[10:32:50.495]                     RNGkind("Mersenne-Twister")
[10:32:50.495]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.495]                       inherits = FALSE)
[10:32:50.495]                   }
[10:32:50.495]                   options(future.plan = NULL)
[10:32:50.495]                   if (is.na(NA_character_)) 
[10:32:50.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.495]                     .init = FALSE)
[10:32:50.495]                 }
[10:32:50.495]             }
[10:32:50.495]         }
[10:32:50.495]     })
[10:32:50.495]     if (TRUE) {
[10:32:50.495]         base::sink(type = "output", split = FALSE)
[10:32:50.495]         if (TRUE) {
[10:32:50.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.495]         }
[10:32:50.495]         else {
[10:32:50.495]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.495]         }
[10:32:50.495]         base::close(...future.stdout)
[10:32:50.495]         ...future.stdout <- NULL
[10:32:50.495]     }
[10:32:50.495]     ...future.result$conditions <- ...future.conditions
[10:32:50.495]     ...future.result$finished <- base::Sys.time()
[10:32:50.495]     ...future.result
[10:32:50.495] }
[10:32:50.496] plan(): Setting new future strategy stack:
[10:32:50.496] List of future strategies:
[10:32:50.496] 1. sequential:
[10:32:50.496]    - args: function (..., envir = parent.frame())
[10:32:50.496]    - tweaked: FALSE
[10:32:50.496]    - call: NULL
[10:32:50.497] plan(): nbrOfWorkers() = 1
[10:32:50.497] plan(): Setting new future strategy stack:
[10:32:50.498] List of future strategies:
[10:32:50.498] 1. sequential:
[10:32:50.498]    - args: function (..., envir = parent.frame())
[10:32:50.498]    - tweaked: FALSE
[10:32:50.498]    - call: plan(strategy)
[10:32:50.498] plan(): nbrOfWorkers() = 1
[10:32:50.498] SequentialFuture started (and completed)
[10:32:50.498] - Launch lazy future ... done
[10:32:50.498] run() for ‘SequentialFuture’ ... done
[10:32:50.499] getGlobalsAndPackages() ...
[10:32:50.499] Searching for globals...
[10:32:50.499] - globals found: [1] ‘{’
[10:32:50.499] Searching for globals ... DONE
[10:32:50.499] Resolving globals: FALSE
[10:32:50.500] 
[10:32:50.500] 
[10:32:50.500] getGlobalsAndPackages() ... DONE
[10:32:50.500] run() for ‘Future’ ...
[10:32:50.500] - state: ‘created’
[10:32:50.500] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.500] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.501]   - Field: ‘label’
[10:32:50.501]   - Field: ‘local’
[10:32:50.501]   - Field: ‘owner’
[10:32:50.501]   - Field: ‘envir’
[10:32:50.501]   - Field: ‘packages’
[10:32:50.501]   - Field: ‘gc’
[10:32:50.501]   - Field: ‘conditions’
[10:32:50.501]   - Field: ‘expr’
[10:32:50.501]   - Field: ‘uuid’
[10:32:50.502]   - Field: ‘seed’
[10:32:50.502]   - Field: ‘version’
[10:32:50.503]   - Field: ‘result’
[10:32:50.503]   - Field: ‘asynchronous’
[10:32:50.503]   - Field: ‘calls’
[10:32:50.503]   - Field: ‘globals’
[10:32:50.503]   - Field: ‘stdout’
[10:32:50.503]   - Field: ‘earlySignal’
[10:32:50.503]   - Field: ‘lazy’
[10:32:50.503]   - Field: ‘state’
[10:32:50.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.503] - Launch lazy future ...
[10:32:50.503] Packages needed by the future expression (n = 0): <none>
[10:32:50.504] Packages needed by future strategies (n = 0): <none>
[10:32:50.504] {
[10:32:50.504]     {
[10:32:50.504]         {
[10:32:50.504]             ...future.startTime <- base::Sys.time()
[10:32:50.504]             {
[10:32:50.504]                 {
[10:32:50.504]                   {
[10:32:50.504]                     base::local({
[10:32:50.504]                       has_future <- base::requireNamespace("future", 
[10:32:50.504]                         quietly = TRUE)
[10:32:50.504]                       if (has_future) {
[10:32:50.504]                         ns <- base::getNamespace("future")
[10:32:50.504]                         version <- ns[[".package"]][["version"]]
[10:32:50.504]                         if (is.null(version)) 
[10:32:50.504]                           version <- utils::packageVersion("future")
[10:32:50.504]                       }
[10:32:50.504]                       else {
[10:32:50.504]                         version <- NULL
[10:32:50.504]                       }
[10:32:50.504]                       if (!has_future || version < "1.8.0") {
[10:32:50.504]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.504]                           "", base::R.version$version.string), 
[10:32:50.504]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.504]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.504]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.504]                             "release", "version")], collapse = " "), 
[10:32:50.504]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.504]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.504]                           info)
[10:32:50.504]                         info <- base::paste(info, collapse = "; ")
[10:32:50.504]                         if (!has_future) {
[10:32:50.504]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.504]                             info)
[10:32:50.504]                         }
[10:32:50.504]                         else {
[10:32:50.504]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.504]                             info, version)
[10:32:50.504]                         }
[10:32:50.504]                         base::stop(msg)
[10:32:50.504]                       }
[10:32:50.504]                     })
[10:32:50.504]                   }
[10:32:50.504]                   ...future.strategy.old <- future::plan("list")
[10:32:50.504]                   options(future.plan = NULL)
[10:32:50.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.504]                 }
[10:32:50.504]                 ...future.workdir <- getwd()
[10:32:50.504]             }
[10:32:50.504]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.504]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.504]         }
[10:32:50.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.504]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.504]             base::names(...future.oldOptions))
[10:32:50.504]     }
[10:32:50.504]     if (FALSE) {
[10:32:50.504]     }
[10:32:50.504]     else {
[10:32:50.504]         if (TRUE) {
[10:32:50.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.504]                 open = "w")
[10:32:50.504]         }
[10:32:50.504]         else {
[10:32:50.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.504]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.504]         }
[10:32:50.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.504]             base::sink(type = "output", split = FALSE)
[10:32:50.504]             base::close(...future.stdout)
[10:32:50.504]         }, add = TRUE)
[10:32:50.504]     }
[10:32:50.504]     ...future.frame <- base::sys.nframe()
[10:32:50.504]     ...future.conditions <- base::list()
[10:32:50.504]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.504]     if (FALSE) {
[10:32:50.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.504]     }
[10:32:50.504]     ...future.result <- base::tryCatch({
[10:32:50.504]         base::withCallingHandlers({
[10:32:50.504]             ...future.value <- base::withVisible(base::local({
[10:32:50.504]                 4
[10:32:50.504]             }))
[10:32:50.504]             future::FutureResult(value = ...future.value$value, 
[10:32:50.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.504]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.504]                     ...future.globalenv.names))
[10:32:50.504]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.504]         }, condition = base::local({
[10:32:50.504]             c <- base::c
[10:32:50.504]             inherits <- base::inherits
[10:32:50.504]             invokeRestart <- base::invokeRestart
[10:32:50.504]             length <- base::length
[10:32:50.504]             list <- base::list
[10:32:50.504]             seq.int <- base::seq.int
[10:32:50.504]             signalCondition <- base::signalCondition
[10:32:50.504]             sys.calls <- base::sys.calls
[10:32:50.504]             `[[` <- base::`[[`
[10:32:50.504]             `+` <- base::`+`
[10:32:50.504]             `<<-` <- base::`<<-`
[10:32:50.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.504]                   3L)]
[10:32:50.504]             }
[10:32:50.504]             function(cond) {
[10:32:50.504]                 is_error <- inherits(cond, "error")
[10:32:50.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.504]                   NULL)
[10:32:50.504]                 if (is_error) {
[10:32:50.504]                   sessionInformation <- function() {
[10:32:50.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.504]                       search = base::search(), system = base::Sys.info())
[10:32:50.504]                   }
[10:32:50.504]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.504]                     cond$call), session = sessionInformation(), 
[10:32:50.504]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.504]                   signalCondition(cond)
[10:32:50.504]                 }
[10:32:50.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.504]                 "immediateCondition"))) {
[10:32:50.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.504]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.504]                   if (TRUE && !signal) {
[10:32:50.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.504]                     {
[10:32:50.504]                       inherits <- base::inherits
[10:32:50.504]                       invokeRestart <- base::invokeRestart
[10:32:50.504]                       is.null <- base::is.null
[10:32:50.504]                       muffled <- FALSE
[10:32:50.504]                       if (inherits(cond, "message")) {
[10:32:50.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.504]                         if (muffled) 
[10:32:50.504]                           invokeRestart("muffleMessage")
[10:32:50.504]                       }
[10:32:50.504]                       else if (inherits(cond, "warning")) {
[10:32:50.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.504]                         if (muffled) 
[10:32:50.504]                           invokeRestart("muffleWarning")
[10:32:50.504]                       }
[10:32:50.504]                       else if (inherits(cond, "condition")) {
[10:32:50.504]                         if (!is.null(pattern)) {
[10:32:50.504]                           computeRestarts <- base::computeRestarts
[10:32:50.504]                           grepl <- base::grepl
[10:32:50.504]                           restarts <- computeRestarts(cond)
[10:32:50.504]                           for (restart in restarts) {
[10:32:50.504]                             name <- restart$name
[10:32:50.504]                             if (is.null(name)) 
[10:32:50.504]                               next
[10:32:50.504]                             if (!grepl(pattern, name)) 
[10:32:50.504]                               next
[10:32:50.504]                             invokeRestart(restart)
[10:32:50.504]                             muffled <- TRUE
[10:32:50.504]                             break
[10:32:50.504]                           }
[10:32:50.504]                         }
[10:32:50.504]                       }
[10:32:50.504]                       invisible(muffled)
[10:32:50.504]                     }
[10:32:50.504]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.504]                   }
[10:32:50.504]                 }
[10:32:50.504]                 else {
[10:32:50.504]                   if (TRUE) {
[10:32:50.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.504]                     {
[10:32:50.504]                       inherits <- base::inherits
[10:32:50.504]                       invokeRestart <- base::invokeRestart
[10:32:50.504]                       is.null <- base::is.null
[10:32:50.504]                       muffled <- FALSE
[10:32:50.504]                       if (inherits(cond, "message")) {
[10:32:50.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.504]                         if (muffled) 
[10:32:50.504]                           invokeRestart("muffleMessage")
[10:32:50.504]                       }
[10:32:50.504]                       else if (inherits(cond, "warning")) {
[10:32:50.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.504]                         if (muffled) 
[10:32:50.504]                           invokeRestart("muffleWarning")
[10:32:50.504]                       }
[10:32:50.504]                       else if (inherits(cond, "condition")) {
[10:32:50.504]                         if (!is.null(pattern)) {
[10:32:50.504]                           computeRestarts <- base::computeRestarts
[10:32:50.504]                           grepl <- base::grepl
[10:32:50.504]                           restarts <- computeRestarts(cond)
[10:32:50.504]                           for (restart in restarts) {
[10:32:50.504]                             name <- restart$name
[10:32:50.504]                             if (is.null(name)) 
[10:32:50.504]                               next
[10:32:50.504]                             if (!grepl(pattern, name)) 
[10:32:50.504]                               next
[10:32:50.504]                             invokeRestart(restart)
[10:32:50.504]                             muffled <- TRUE
[10:32:50.504]                             break
[10:32:50.504]                           }
[10:32:50.504]                         }
[10:32:50.504]                       }
[10:32:50.504]                       invisible(muffled)
[10:32:50.504]                     }
[10:32:50.504]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.504]                   }
[10:32:50.504]                 }
[10:32:50.504]             }
[10:32:50.504]         }))
[10:32:50.504]     }, error = function(ex) {
[10:32:50.504]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.504]                 ...future.rng), started = ...future.startTime, 
[10:32:50.504]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.504]             version = "1.8"), class = "FutureResult")
[10:32:50.504]     }, finally = {
[10:32:50.504]         if (!identical(...future.workdir, getwd())) 
[10:32:50.504]             setwd(...future.workdir)
[10:32:50.504]         {
[10:32:50.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.504]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.504]             }
[10:32:50.504]             base::options(...future.oldOptions)
[10:32:50.504]             if (.Platform$OS.type == "windows") {
[10:32:50.504]                 old_names <- names(...future.oldEnvVars)
[10:32:50.504]                 envs <- base::Sys.getenv()
[10:32:50.504]                 names <- names(envs)
[10:32:50.504]                 common <- intersect(names, old_names)
[10:32:50.504]                 added <- setdiff(names, old_names)
[10:32:50.504]                 removed <- setdiff(old_names, names)
[10:32:50.504]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.504]                   envs[common]]
[10:32:50.504]                 NAMES <- toupper(changed)
[10:32:50.504]                 args <- list()
[10:32:50.504]                 for (kk in seq_along(NAMES)) {
[10:32:50.504]                   name <- changed[[kk]]
[10:32:50.504]                   NAME <- NAMES[[kk]]
[10:32:50.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.504]                     next
[10:32:50.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.504]                 }
[10:32:50.504]                 NAMES <- toupper(added)
[10:32:50.504]                 for (kk in seq_along(NAMES)) {
[10:32:50.504]                   name <- added[[kk]]
[10:32:50.504]                   NAME <- NAMES[[kk]]
[10:32:50.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.504]                     next
[10:32:50.504]                   args[[name]] <- ""
[10:32:50.504]                 }
[10:32:50.504]                 NAMES <- toupper(removed)
[10:32:50.504]                 for (kk in seq_along(NAMES)) {
[10:32:50.504]                   name <- removed[[kk]]
[10:32:50.504]                   NAME <- NAMES[[kk]]
[10:32:50.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.504]                     next
[10:32:50.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.504]                 }
[10:32:50.504]                 if (length(args) > 0) 
[10:32:50.504]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.504]             }
[10:32:50.504]             else {
[10:32:50.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.504]             }
[10:32:50.504]             {
[10:32:50.504]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.504]                   0L) {
[10:32:50.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.504]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.504]                   base::options(opts)
[10:32:50.504]                 }
[10:32:50.504]                 {
[10:32:50.504]                   {
[10:32:50.504]                     NULL
[10:32:50.504]                     RNGkind("Mersenne-Twister")
[10:32:50.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.504]                       inherits = FALSE)
[10:32:50.504]                   }
[10:32:50.504]                   options(future.plan = NULL)
[10:32:50.504]                   if (is.na(NA_character_)) 
[10:32:50.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.504]                     .init = FALSE)
[10:32:50.504]                 }
[10:32:50.504]             }
[10:32:50.504]         }
[10:32:50.504]     })
[10:32:50.504]     if (TRUE) {
[10:32:50.504]         base::sink(type = "output", split = FALSE)
[10:32:50.504]         if (TRUE) {
[10:32:50.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.504]         }
[10:32:50.504]         else {
[10:32:50.504]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.504]         }
[10:32:50.504]         base::close(...future.stdout)
[10:32:50.504]         ...future.stdout <- NULL
[10:32:50.504]     }
[10:32:50.504]     ...future.result$conditions <- ...future.conditions
[10:32:50.504]     ...future.result$finished <- base::Sys.time()
[10:32:50.504]     ...future.result
[10:32:50.504] }
[10:32:50.506] plan(): Setting new future strategy stack:
[10:32:50.506] List of future strategies:
[10:32:50.506] 1. sequential:
[10:32:50.506]    - args: function (..., envir = parent.frame())
[10:32:50.506]    - tweaked: FALSE
[10:32:50.506]    - call: NULL
[10:32:50.506] plan(): nbrOfWorkers() = 1
[10:32:50.507] plan(): Setting new future strategy stack:
[10:32:50.507] List of future strategies:
[10:32:50.507] 1. sequential:
[10:32:50.507]    - args: function (..., envir = parent.frame())
[10:32:50.507]    - tweaked: FALSE
[10:32:50.507]    - call: plan(strategy)
[10:32:50.507] plan(): nbrOfWorkers() = 1
[10:32:50.507] SequentialFuture started (and completed)
[10:32:50.507] - Launch lazy future ... done
[10:32:50.508] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652cf072ef8> 
Classes 'listenv', 'environment' <environment: 0x5652cf45f9e8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:32:50.511] resolved() for ‘SequentialFuture’ ...
[10:32:50.511] - state: ‘finished’
[10:32:50.511] - run: TRUE
[10:32:50.511] - result: ‘FutureResult’
[10:32:50.511] resolved() for ‘SequentialFuture’ ... done
[10:32:50.511] resolved() for ‘SequentialFuture’ ...
[10:32:50.511] - state: ‘finished’
[10:32:50.511] - run: TRUE
[10:32:50.512] - result: ‘FutureResult’
[10:32:50.512] resolved() for ‘SequentialFuture’ ... done
[10:32:50.512] resolved() for ‘SequentialFuture’ ...
[10:32:50.512] - state: ‘finished’
[10:32:50.512] - run: TRUE
[10:32:50.512] - result: ‘FutureResult’
[10:32:50.512] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:50.514] resolve() on list environment ...
[10:32:50.514]  recursive: 0
[10:32:50.515]  length: 6
[10:32:50.515]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:50.515] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.515] - nx: 6
[10:32:50.516] - relay: TRUE
[10:32:50.516] - stdout: TRUE
[10:32:50.516] - signal: TRUE
[10:32:50.516] - resignal: FALSE
[10:32:50.516] - force: TRUE
[10:32:50.516] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.516] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.516]  - until=2
[10:32:50.516]  - relaying element #2
[10:32:50.516] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.516] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.516] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.517]  length: 5 (resolved future 1)
[10:32:50.517] resolved() for ‘SequentialFuture’ ...
[10:32:50.517] - state: ‘finished’
[10:32:50.517] - run: TRUE
[10:32:50.517] - result: ‘FutureResult’
[10:32:50.517] resolved() for ‘SequentialFuture’ ... done
[10:32:50.517] Future #2
[10:32:50.517] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.517] - nx: 6
[10:32:50.517] - relay: TRUE
[10:32:50.518] - stdout: TRUE
[10:32:50.518] - signal: TRUE
[10:32:50.518] - resignal: FALSE
[10:32:50.518] - force: TRUE
[10:32:50.518] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.518] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.518]  - until=2
[10:32:50.518]  - relaying element #2
[10:32:50.518] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.518] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.518] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.519]  length: 4 (resolved future 2)
[10:32:50.519] resolved() for ‘SequentialFuture’ ...
[10:32:50.519] - state: ‘finished’
[10:32:50.519] - run: TRUE
[10:32:50.519] - result: ‘FutureResult’
[10:32:50.519] resolved() for ‘SequentialFuture’ ... done
[10:32:50.519] Future #3
[10:32:50.519] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.519] - nx: 6
[10:32:50.519] - relay: TRUE
[10:32:50.519] - stdout: TRUE
[10:32:50.520] - signal: TRUE
[10:32:50.520] - resignal: FALSE
[10:32:50.520] - force: TRUE
[10:32:50.520] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.520] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.520]  - until=3
[10:32:50.520]  - relaying element #3
[10:32:50.520] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.520] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.520]  length: 3 (resolved future 3)
[10:32:50.521] resolved() for ‘SequentialFuture’ ...
[10:32:50.521] - state: ‘finished’
[10:32:50.521] - run: TRUE
[10:32:50.521] - result: ‘FutureResult’
[10:32:50.521] resolved() for ‘SequentialFuture’ ... done
[10:32:50.521] Future #4
[10:32:50.521] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.521] - nx: 6
[10:32:50.521] - relay: TRUE
[10:32:50.521] - stdout: TRUE
[10:32:50.521] - signal: TRUE
[10:32:50.522] - resignal: FALSE
[10:32:50.522] - force: TRUE
[10:32:50.522] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.522]  - until=4
[10:32:50.522]  - relaying element #4
[10:32:50.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.522] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.522] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.522]  length: 2 (resolved future 4)
[10:32:50.523] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.523] - nx: 6
[10:32:50.523] - relay: TRUE
[10:32:50.523] - stdout: TRUE
[10:32:50.523] - signal: TRUE
[10:32:50.523] - resignal: FALSE
[10:32:50.523] - force: TRUE
[10:32:50.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.523] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.523]  - until=6
[10:32:50.523]  - relaying element #6
[10:32:50.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.523] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.524] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.524]  length: 1 (resolved future 5)
[10:32:50.524] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.524] - nx: 6
[10:32:50.524] - relay: TRUE
[10:32:50.524] - stdout: TRUE
[10:32:50.524] - signal: TRUE
[10:32:50.524] - resignal: FALSE
[10:32:50.524] - force: TRUE
[10:32:50.524] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.524] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.524]  - until=6
[10:32:50.525] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.525] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.525] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.525]  length: 0 (resolved future 6)
[10:32:50.525] Relaying remaining futures
[10:32:50.525] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.525] - nx: 6
[10:32:50.525] - relay: TRUE
[10:32:50.525] - stdout: TRUE
[10:32:50.525] - signal: TRUE
[10:32:50.525] - resignal: FALSE
[10:32:50.525] - force: TRUE
[10:32:50.526] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.526] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:50.527] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.527] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.527] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.527] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5652d0af4ba8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:32:50.529] getGlobalsAndPackages() ...
[10:32:50.529] Searching for globals...
[10:32:50.529] 
[10:32:50.529] Searching for globals ... DONE
[10:32:50.529] - globals: [0] <none>
[10:32:50.529] getGlobalsAndPackages() ... DONE
[10:32:50.529] run() for ‘Future’ ...
[10:32:50.530] - state: ‘created’
[10:32:50.530] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.530] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.530]   - Field: ‘label’
[10:32:50.530]   - Field: ‘local’
[10:32:50.530]   - Field: ‘owner’
[10:32:50.530]   - Field: ‘envir’
[10:32:50.531]   - Field: ‘packages’
[10:32:50.531]   - Field: ‘gc’
[10:32:50.531]   - Field: ‘conditions’
[10:32:50.531]   - Field: ‘expr’
[10:32:50.531]   - Field: ‘uuid’
[10:32:50.531]   - Field: ‘seed’
[10:32:50.531]   - Field: ‘version’
[10:32:50.531]   - Field: ‘result’
[10:32:50.531]   - Field: ‘asynchronous’
[10:32:50.531]   - Field: ‘calls’
[10:32:50.531]   - Field: ‘globals’
[10:32:50.531]   - Field: ‘stdout’
[10:32:50.532]   - Field: ‘earlySignal’
[10:32:50.532]   - Field: ‘lazy’
[10:32:50.532]   - Field: ‘state’
[10:32:50.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.532] - Launch lazy future ...
[10:32:50.532] Packages needed by the future expression (n = 0): <none>
[10:32:50.532] Packages needed by future strategies (n = 0): <none>
[10:32:50.533] {
[10:32:50.533]     {
[10:32:50.533]         {
[10:32:50.533]             ...future.startTime <- base::Sys.time()
[10:32:50.533]             {
[10:32:50.533]                 {
[10:32:50.533]                   {
[10:32:50.533]                     base::local({
[10:32:50.533]                       has_future <- base::requireNamespace("future", 
[10:32:50.533]                         quietly = TRUE)
[10:32:50.533]                       if (has_future) {
[10:32:50.533]                         ns <- base::getNamespace("future")
[10:32:50.533]                         version <- ns[[".package"]][["version"]]
[10:32:50.533]                         if (is.null(version)) 
[10:32:50.533]                           version <- utils::packageVersion("future")
[10:32:50.533]                       }
[10:32:50.533]                       else {
[10:32:50.533]                         version <- NULL
[10:32:50.533]                       }
[10:32:50.533]                       if (!has_future || version < "1.8.0") {
[10:32:50.533]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.533]                           "", base::R.version$version.string), 
[10:32:50.533]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.533]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.533]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.533]                             "release", "version")], collapse = " "), 
[10:32:50.533]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.533]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.533]                           info)
[10:32:50.533]                         info <- base::paste(info, collapse = "; ")
[10:32:50.533]                         if (!has_future) {
[10:32:50.533]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.533]                             info)
[10:32:50.533]                         }
[10:32:50.533]                         else {
[10:32:50.533]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.533]                             info, version)
[10:32:50.533]                         }
[10:32:50.533]                         base::stop(msg)
[10:32:50.533]                       }
[10:32:50.533]                     })
[10:32:50.533]                   }
[10:32:50.533]                   ...future.strategy.old <- future::plan("list")
[10:32:50.533]                   options(future.plan = NULL)
[10:32:50.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.533]                 }
[10:32:50.533]                 ...future.workdir <- getwd()
[10:32:50.533]             }
[10:32:50.533]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.533]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.533]         }
[10:32:50.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.533]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.533]             base::names(...future.oldOptions))
[10:32:50.533]     }
[10:32:50.533]     if (FALSE) {
[10:32:50.533]     }
[10:32:50.533]     else {
[10:32:50.533]         if (TRUE) {
[10:32:50.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.533]                 open = "w")
[10:32:50.533]         }
[10:32:50.533]         else {
[10:32:50.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.533]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.533]         }
[10:32:50.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.533]             base::sink(type = "output", split = FALSE)
[10:32:50.533]             base::close(...future.stdout)
[10:32:50.533]         }, add = TRUE)
[10:32:50.533]     }
[10:32:50.533]     ...future.frame <- base::sys.nframe()
[10:32:50.533]     ...future.conditions <- base::list()
[10:32:50.533]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.533]     if (FALSE) {
[10:32:50.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.533]     }
[10:32:50.533]     ...future.result <- base::tryCatch({
[10:32:50.533]         base::withCallingHandlers({
[10:32:50.533]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.533]             future::FutureResult(value = ...future.value$value, 
[10:32:50.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.533]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.533]                     ...future.globalenv.names))
[10:32:50.533]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.533]         }, condition = base::local({
[10:32:50.533]             c <- base::c
[10:32:50.533]             inherits <- base::inherits
[10:32:50.533]             invokeRestart <- base::invokeRestart
[10:32:50.533]             length <- base::length
[10:32:50.533]             list <- base::list
[10:32:50.533]             seq.int <- base::seq.int
[10:32:50.533]             signalCondition <- base::signalCondition
[10:32:50.533]             sys.calls <- base::sys.calls
[10:32:50.533]             `[[` <- base::`[[`
[10:32:50.533]             `+` <- base::`+`
[10:32:50.533]             `<<-` <- base::`<<-`
[10:32:50.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.533]                   3L)]
[10:32:50.533]             }
[10:32:50.533]             function(cond) {
[10:32:50.533]                 is_error <- inherits(cond, "error")
[10:32:50.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.533]                   NULL)
[10:32:50.533]                 if (is_error) {
[10:32:50.533]                   sessionInformation <- function() {
[10:32:50.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.533]                       search = base::search(), system = base::Sys.info())
[10:32:50.533]                   }
[10:32:50.533]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.533]                     cond$call), session = sessionInformation(), 
[10:32:50.533]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.533]                   signalCondition(cond)
[10:32:50.533]                 }
[10:32:50.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.533]                 "immediateCondition"))) {
[10:32:50.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.533]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.533]                   if (TRUE && !signal) {
[10:32:50.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.533]                     {
[10:32:50.533]                       inherits <- base::inherits
[10:32:50.533]                       invokeRestart <- base::invokeRestart
[10:32:50.533]                       is.null <- base::is.null
[10:32:50.533]                       muffled <- FALSE
[10:32:50.533]                       if (inherits(cond, "message")) {
[10:32:50.533]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.533]                         if (muffled) 
[10:32:50.533]                           invokeRestart("muffleMessage")
[10:32:50.533]                       }
[10:32:50.533]                       else if (inherits(cond, "warning")) {
[10:32:50.533]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.533]                         if (muffled) 
[10:32:50.533]                           invokeRestart("muffleWarning")
[10:32:50.533]                       }
[10:32:50.533]                       else if (inherits(cond, "condition")) {
[10:32:50.533]                         if (!is.null(pattern)) {
[10:32:50.533]                           computeRestarts <- base::computeRestarts
[10:32:50.533]                           grepl <- base::grepl
[10:32:50.533]                           restarts <- computeRestarts(cond)
[10:32:50.533]                           for (restart in restarts) {
[10:32:50.533]                             name <- restart$name
[10:32:50.533]                             if (is.null(name)) 
[10:32:50.533]                               next
[10:32:50.533]                             if (!grepl(pattern, name)) 
[10:32:50.533]                               next
[10:32:50.533]                             invokeRestart(restart)
[10:32:50.533]                             muffled <- TRUE
[10:32:50.533]                             break
[10:32:50.533]                           }
[10:32:50.533]                         }
[10:32:50.533]                       }
[10:32:50.533]                       invisible(muffled)
[10:32:50.533]                     }
[10:32:50.533]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.533]                   }
[10:32:50.533]                 }
[10:32:50.533]                 else {
[10:32:50.533]                   if (TRUE) {
[10:32:50.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.533]                     {
[10:32:50.533]                       inherits <- base::inherits
[10:32:50.533]                       invokeRestart <- base::invokeRestart
[10:32:50.533]                       is.null <- base::is.null
[10:32:50.533]                       muffled <- FALSE
[10:32:50.533]                       if (inherits(cond, "message")) {
[10:32:50.533]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.533]                         if (muffled) 
[10:32:50.533]                           invokeRestart("muffleMessage")
[10:32:50.533]                       }
[10:32:50.533]                       else if (inherits(cond, "warning")) {
[10:32:50.533]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.533]                         if (muffled) 
[10:32:50.533]                           invokeRestart("muffleWarning")
[10:32:50.533]                       }
[10:32:50.533]                       else if (inherits(cond, "condition")) {
[10:32:50.533]                         if (!is.null(pattern)) {
[10:32:50.533]                           computeRestarts <- base::computeRestarts
[10:32:50.533]                           grepl <- base::grepl
[10:32:50.533]                           restarts <- computeRestarts(cond)
[10:32:50.533]                           for (restart in restarts) {
[10:32:50.533]                             name <- restart$name
[10:32:50.533]                             if (is.null(name)) 
[10:32:50.533]                               next
[10:32:50.533]                             if (!grepl(pattern, name)) 
[10:32:50.533]                               next
[10:32:50.533]                             invokeRestart(restart)
[10:32:50.533]                             muffled <- TRUE
[10:32:50.533]                             break
[10:32:50.533]                           }
[10:32:50.533]                         }
[10:32:50.533]                       }
[10:32:50.533]                       invisible(muffled)
[10:32:50.533]                     }
[10:32:50.533]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.533]                   }
[10:32:50.533]                 }
[10:32:50.533]             }
[10:32:50.533]         }))
[10:32:50.533]     }, error = function(ex) {
[10:32:50.533]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.533]                 ...future.rng), started = ...future.startTime, 
[10:32:50.533]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.533]             version = "1.8"), class = "FutureResult")
[10:32:50.533]     }, finally = {
[10:32:50.533]         if (!identical(...future.workdir, getwd())) 
[10:32:50.533]             setwd(...future.workdir)
[10:32:50.533]         {
[10:32:50.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.533]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.533]             }
[10:32:50.533]             base::options(...future.oldOptions)
[10:32:50.533]             if (.Platform$OS.type == "windows") {
[10:32:50.533]                 old_names <- names(...future.oldEnvVars)
[10:32:50.533]                 envs <- base::Sys.getenv()
[10:32:50.533]                 names <- names(envs)
[10:32:50.533]                 common <- intersect(names, old_names)
[10:32:50.533]                 added <- setdiff(names, old_names)
[10:32:50.533]                 removed <- setdiff(old_names, names)
[10:32:50.533]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.533]                   envs[common]]
[10:32:50.533]                 NAMES <- toupper(changed)
[10:32:50.533]                 args <- list()
[10:32:50.533]                 for (kk in seq_along(NAMES)) {
[10:32:50.533]                   name <- changed[[kk]]
[10:32:50.533]                   NAME <- NAMES[[kk]]
[10:32:50.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.533]                     next
[10:32:50.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.533]                 }
[10:32:50.533]                 NAMES <- toupper(added)
[10:32:50.533]                 for (kk in seq_along(NAMES)) {
[10:32:50.533]                   name <- added[[kk]]
[10:32:50.533]                   NAME <- NAMES[[kk]]
[10:32:50.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.533]                     next
[10:32:50.533]                   args[[name]] <- ""
[10:32:50.533]                 }
[10:32:50.533]                 NAMES <- toupper(removed)
[10:32:50.533]                 for (kk in seq_along(NAMES)) {
[10:32:50.533]                   name <- removed[[kk]]
[10:32:50.533]                   NAME <- NAMES[[kk]]
[10:32:50.533]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.533]                     next
[10:32:50.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.533]                 }
[10:32:50.533]                 if (length(args) > 0) 
[10:32:50.533]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.533]             }
[10:32:50.533]             else {
[10:32:50.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.533]             }
[10:32:50.533]             {
[10:32:50.533]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.533]                   0L) {
[10:32:50.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.533]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.533]                   base::options(opts)
[10:32:50.533]                 }
[10:32:50.533]                 {
[10:32:50.533]                   {
[10:32:50.533]                     NULL
[10:32:50.533]                     RNGkind("Mersenne-Twister")
[10:32:50.533]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.533]                       inherits = FALSE)
[10:32:50.533]                   }
[10:32:50.533]                   options(future.plan = NULL)
[10:32:50.533]                   if (is.na(NA_character_)) 
[10:32:50.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.533]                     .init = FALSE)
[10:32:50.533]                 }
[10:32:50.533]             }
[10:32:50.533]         }
[10:32:50.533]     })
[10:32:50.533]     if (TRUE) {
[10:32:50.533]         base::sink(type = "output", split = FALSE)
[10:32:50.533]         if (TRUE) {
[10:32:50.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.533]         }
[10:32:50.533]         else {
[10:32:50.533]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.533]         }
[10:32:50.533]         base::close(...future.stdout)
[10:32:50.533]         ...future.stdout <- NULL
[10:32:50.533]     }
[10:32:50.533]     ...future.result$conditions <- ...future.conditions
[10:32:50.533]     ...future.result$finished <- base::Sys.time()
[10:32:50.533]     ...future.result
[10:32:50.533] }
[10:32:50.534] plan(): Setting new future strategy stack:
[10:32:50.534] List of future strategies:
[10:32:50.534] 1. sequential:
[10:32:50.534]    - args: function (..., envir = parent.frame())
[10:32:50.534]    - tweaked: FALSE
[10:32:50.534]    - call: NULL
[10:32:50.535] plan(): nbrOfWorkers() = 1
[10:32:50.535] plan(): Setting new future strategy stack:
[10:32:50.535] List of future strategies:
[10:32:50.535] 1. sequential:
[10:32:50.535]    - args: function (..., envir = parent.frame())
[10:32:50.535]    - tweaked: FALSE
[10:32:50.535]    - call: plan(strategy)
[10:32:50.536] plan(): nbrOfWorkers() = 1
[10:32:50.536] SequentialFuture started (and completed)
[10:32:50.536] - Launch lazy future ... done
[10:32:50.536] run() for ‘SequentialFuture’ ... done
[10:32:50.536] getGlobalsAndPackages() ...
[10:32:50.536] Searching for globals...
[10:32:50.537] 
[10:32:50.537] Searching for globals ... DONE
[10:32:50.537] - globals: [0] <none>
[10:32:50.537] getGlobalsAndPackages() ... DONE
[10:32:50.537] run() for ‘Future’ ...
[10:32:50.537] - state: ‘created’
[10:32:50.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.538] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.538] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.538]   - Field: ‘label’
[10:32:50.538]   - Field: ‘local’
[10:32:50.538]   - Field: ‘owner’
[10:32:50.538]   - Field: ‘envir’
[10:32:50.538]   - Field: ‘packages’
[10:32:50.538]   - Field: ‘gc’
[10:32:50.538]   - Field: ‘conditions’
[10:32:50.538]   - Field: ‘expr’
[10:32:50.539]   - Field: ‘uuid’
[10:32:50.539]   - Field: ‘seed’
[10:32:50.539]   - Field: ‘version’
[10:32:50.539]   - Field: ‘result’
[10:32:50.539]   - Field: ‘asynchronous’
[10:32:50.539]   - Field: ‘calls’
[10:32:50.539]   - Field: ‘globals’
[10:32:50.539]   - Field: ‘stdout’
[10:32:50.539]   - Field: ‘earlySignal’
[10:32:50.539]   - Field: ‘lazy’
[10:32:50.539]   - Field: ‘state’
[10:32:50.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.540] - Launch lazy future ...
[10:32:50.540] Packages needed by the future expression (n = 0): <none>
[10:32:50.540] Packages needed by future strategies (n = 0): <none>
[10:32:50.540] {
[10:32:50.540]     {
[10:32:50.540]         {
[10:32:50.540]             ...future.startTime <- base::Sys.time()
[10:32:50.540]             {
[10:32:50.540]                 {
[10:32:50.540]                   {
[10:32:50.540]                     base::local({
[10:32:50.540]                       has_future <- base::requireNamespace("future", 
[10:32:50.540]                         quietly = TRUE)
[10:32:50.540]                       if (has_future) {
[10:32:50.540]                         ns <- base::getNamespace("future")
[10:32:50.540]                         version <- ns[[".package"]][["version"]]
[10:32:50.540]                         if (is.null(version)) 
[10:32:50.540]                           version <- utils::packageVersion("future")
[10:32:50.540]                       }
[10:32:50.540]                       else {
[10:32:50.540]                         version <- NULL
[10:32:50.540]                       }
[10:32:50.540]                       if (!has_future || version < "1.8.0") {
[10:32:50.540]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.540]                           "", base::R.version$version.string), 
[10:32:50.540]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.540]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.540]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.540]                             "release", "version")], collapse = " "), 
[10:32:50.540]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.540]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.540]                           info)
[10:32:50.540]                         info <- base::paste(info, collapse = "; ")
[10:32:50.540]                         if (!has_future) {
[10:32:50.540]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.540]                             info)
[10:32:50.540]                         }
[10:32:50.540]                         else {
[10:32:50.540]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.540]                             info, version)
[10:32:50.540]                         }
[10:32:50.540]                         base::stop(msg)
[10:32:50.540]                       }
[10:32:50.540]                     })
[10:32:50.540]                   }
[10:32:50.540]                   ...future.strategy.old <- future::plan("list")
[10:32:50.540]                   options(future.plan = NULL)
[10:32:50.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.540]                 }
[10:32:50.540]                 ...future.workdir <- getwd()
[10:32:50.540]             }
[10:32:50.540]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.540]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.540]         }
[10:32:50.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.540]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.540]             base::names(...future.oldOptions))
[10:32:50.540]     }
[10:32:50.540]     if (FALSE) {
[10:32:50.540]     }
[10:32:50.540]     else {
[10:32:50.540]         if (TRUE) {
[10:32:50.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.540]                 open = "w")
[10:32:50.540]         }
[10:32:50.540]         else {
[10:32:50.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.540]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.540]         }
[10:32:50.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.540]             base::sink(type = "output", split = FALSE)
[10:32:50.540]             base::close(...future.stdout)
[10:32:50.540]         }, add = TRUE)
[10:32:50.540]     }
[10:32:50.540]     ...future.frame <- base::sys.nframe()
[10:32:50.540]     ...future.conditions <- base::list()
[10:32:50.540]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.540]     if (FALSE) {
[10:32:50.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.540]     }
[10:32:50.540]     ...future.result <- base::tryCatch({
[10:32:50.540]         base::withCallingHandlers({
[10:32:50.540]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.540]             future::FutureResult(value = ...future.value$value, 
[10:32:50.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.540]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.540]                     ...future.globalenv.names))
[10:32:50.540]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.540]         }, condition = base::local({
[10:32:50.540]             c <- base::c
[10:32:50.540]             inherits <- base::inherits
[10:32:50.540]             invokeRestart <- base::invokeRestart
[10:32:50.540]             length <- base::length
[10:32:50.540]             list <- base::list
[10:32:50.540]             seq.int <- base::seq.int
[10:32:50.540]             signalCondition <- base::signalCondition
[10:32:50.540]             sys.calls <- base::sys.calls
[10:32:50.540]             `[[` <- base::`[[`
[10:32:50.540]             `+` <- base::`+`
[10:32:50.540]             `<<-` <- base::`<<-`
[10:32:50.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.540]                   3L)]
[10:32:50.540]             }
[10:32:50.540]             function(cond) {
[10:32:50.540]                 is_error <- inherits(cond, "error")
[10:32:50.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.540]                   NULL)
[10:32:50.540]                 if (is_error) {
[10:32:50.540]                   sessionInformation <- function() {
[10:32:50.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.540]                       search = base::search(), system = base::Sys.info())
[10:32:50.540]                   }
[10:32:50.540]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.540]                     cond$call), session = sessionInformation(), 
[10:32:50.540]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.540]                   signalCondition(cond)
[10:32:50.540]                 }
[10:32:50.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.540]                 "immediateCondition"))) {
[10:32:50.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.540]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.540]                   if (TRUE && !signal) {
[10:32:50.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.540]                     {
[10:32:50.540]                       inherits <- base::inherits
[10:32:50.540]                       invokeRestart <- base::invokeRestart
[10:32:50.540]                       is.null <- base::is.null
[10:32:50.540]                       muffled <- FALSE
[10:32:50.540]                       if (inherits(cond, "message")) {
[10:32:50.540]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.540]                         if (muffled) 
[10:32:50.540]                           invokeRestart("muffleMessage")
[10:32:50.540]                       }
[10:32:50.540]                       else if (inherits(cond, "warning")) {
[10:32:50.540]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.540]                         if (muffled) 
[10:32:50.540]                           invokeRestart("muffleWarning")
[10:32:50.540]                       }
[10:32:50.540]                       else if (inherits(cond, "condition")) {
[10:32:50.540]                         if (!is.null(pattern)) {
[10:32:50.540]                           computeRestarts <- base::computeRestarts
[10:32:50.540]                           grepl <- base::grepl
[10:32:50.540]                           restarts <- computeRestarts(cond)
[10:32:50.540]                           for (restart in restarts) {
[10:32:50.540]                             name <- restart$name
[10:32:50.540]                             if (is.null(name)) 
[10:32:50.540]                               next
[10:32:50.540]                             if (!grepl(pattern, name)) 
[10:32:50.540]                               next
[10:32:50.540]                             invokeRestart(restart)
[10:32:50.540]                             muffled <- TRUE
[10:32:50.540]                             break
[10:32:50.540]                           }
[10:32:50.540]                         }
[10:32:50.540]                       }
[10:32:50.540]                       invisible(muffled)
[10:32:50.540]                     }
[10:32:50.540]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.540]                   }
[10:32:50.540]                 }
[10:32:50.540]                 else {
[10:32:50.540]                   if (TRUE) {
[10:32:50.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.540]                     {
[10:32:50.540]                       inherits <- base::inherits
[10:32:50.540]                       invokeRestart <- base::invokeRestart
[10:32:50.540]                       is.null <- base::is.null
[10:32:50.540]                       muffled <- FALSE
[10:32:50.540]                       if (inherits(cond, "message")) {
[10:32:50.540]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.540]                         if (muffled) 
[10:32:50.540]                           invokeRestart("muffleMessage")
[10:32:50.540]                       }
[10:32:50.540]                       else if (inherits(cond, "warning")) {
[10:32:50.540]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.540]                         if (muffled) 
[10:32:50.540]                           invokeRestart("muffleWarning")
[10:32:50.540]                       }
[10:32:50.540]                       else if (inherits(cond, "condition")) {
[10:32:50.540]                         if (!is.null(pattern)) {
[10:32:50.540]                           computeRestarts <- base::computeRestarts
[10:32:50.540]                           grepl <- base::grepl
[10:32:50.540]                           restarts <- computeRestarts(cond)
[10:32:50.540]                           for (restart in restarts) {
[10:32:50.540]                             name <- restart$name
[10:32:50.540]                             if (is.null(name)) 
[10:32:50.540]                               next
[10:32:50.540]                             if (!grepl(pattern, name)) 
[10:32:50.540]                               next
[10:32:50.540]                             invokeRestart(restart)
[10:32:50.540]                             muffled <- TRUE
[10:32:50.540]                             break
[10:32:50.540]                           }
[10:32:50.540]                         }
[10:32:50.540]                       }
[10:32:50.540]                       invisible(muffled)
[10:32:50.540]                     }
[10:32:50.540]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.540]                   }
[10:32:50.540]                 }
[10:32:50.540]             }
[10:32:50.540]         }))
[10:32:50.540]     }, error = function(ex) {
[10:32:50.540]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.540]                 ...future.rng), started = ...future.startTime, 
[10:32:50.540]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.540]             version = "1.8"), class = "FutureResult")
[10:32:50.540]     }, finally = {
[10:32:50.540]         if (!identical(...future.workdir, getwd())) 
[10:32:50.540]             setwd(...future.workdir)
[10:32:50.540]         {
[10:32:50.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.540]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.540]             }
[10:32:50.540]             base::options(...future.oldOptions)
[10:32:50.540]             if (.Platform$OS.type == "windows") {
[10:32:50.540]                 old_names <- names(...future.oldEnvVars)
[10:32:50.540]                 envs <- base::Sys.getenv()
[10:32:50.540]                 names <- names(envs)
[10:32:50.540]                 common <- intersect(names, old_names)
[10:32:50.540]                 added <- setdiff(names, old_names)
[10:32:50.540]                 removed <- setdiff(old_names, names)
[10:32:50.540]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.540]                   envs[common]]
[10:32:50.540]                 NAMES <- toupper(changed)
[10:32:50.540]                 args <- list()
[10:32:50.540]                 for (kk in seq_along(NAMES)) {
[10:32:50.540]                   name <- changed[[kk]]
[10:32:50.540]                   NAME <- NAMES[[kk]]
[10:32:50.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.540]                     next
[10:32:50.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.540]                 }
[10:32:50.540]                 NAMES <- toupper(added)
[10:32:50.540]                 for (kk in seq_along(NAMES)) {
[10:32:50.540]                   name <- added[[kk]]
[10:32:50.540]                   NAME <- NAMES[[kk]]
[10:32:50.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.540]                     next
[10:32:50.540]                   args[[name]] <- ""
[10:32:50.540]                 }
[10:32:50.540]                 NAMES <- toupper(removed)
[10:32:50.540]                 for (kk in seq_along(NAMES)) {
[10:32:50.540]                   name <- removed[[kk]]
[10:32:50.540]                   NAME <- NAMES[[kk]]
[10:32:50.540]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.540]                     next
[10:32:50.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.540]                 }
[10:32:50.540]                 if (length(args) > 0) 
[10:32:50.540]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.540]             }
[10:32:50.540]             else {
[10:32:50.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.540]             }
[10:32:50.540]             {
[10:32:50.540]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.540]                   0L) {
[10:32:50.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.540]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.540]                   base::options(opts)
[10:32:50.540]                 }
[10:32:50.540]                 {
[10:32:50.540]                   {
[10:32:50.540]                     NULL
[10:32:50.540]                     RNGkind("Mersenne-Twister")
[10:32:50.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.540]                       inherits = FALSE)
[10:32:50.540]                   }
[10:32:50.540]                   options(future.plan = NULL)
[10:32:50.540]                   if (is.na(NA_character_)) 
[10:32:50.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.540]                     .init = FALSE)
[10:32:50.540]                 }
[10:32:50.540]             }
[10:32:50.540]         }
[10:32:50.540]     })
[10:32:50.540]     if (TRUE) {
[10:32:50.540]         base::sink(type = "output", split = FALSE)
[10:32:50.540]         if (TRUE) {
[10:32:50.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.540]         }
[10:32:50.540]         else {
[10:32:50.540]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.540]         }
[10:32:50.540]         base::close(...future.stdout)
[10:32:50.540]         ...future.stdout <- NULL
[10:32:50.540]     }
[10:32:50.540]     ...future.result$conditions <- ...future.conditions
[10:32:50.540]     ...future.result$finished <- base::Sys.time()
[10:32:50.540]     ...future.result
[10:32:50.540] }
[10:32:50.542] plan(): Setting new future strategy stack:
[10:32:50.542] List of future strategies:
[10:32:50.542] 1. sequential:
[10:32:50.542]    - args: function (..., envir = parent.frame())
[10:32:50.542]    - tweaked: FALSE
[10:32:50.542]    - call: NULL
[10:32:50.542] plan(): nbrOfWorkers() = 1
[10:32:50.543] plan(): Setting new future strategy stack:
[10:32:50.543] List of future strategies:
[10:32:50.543] 1. sequential:
[10:32:50.543]    - args: function (..., envir = parent.frame())
[10:32:50.543]    - tweaked: FALSE
[10:32:50.543]    - call: plan(strategy)
[10:32:50.543] plan(): nbrOfWorkers() = 1
[10:32:50.544] SequentialFuture started (and completed)
[10:32:50.544] - Launch lazy future ... done
[10:32:50.544] run() for ‘SequentialFuture’ ... done
[10:32:50.544] getGlobalsAndPackages() ...
[10:32:50.544] Searching for globals...
[10:32:50.545] - globals found: [1] ‘{’
[10:32:50.545] Searching for globals ... DONE
[10:32:50.545] Resolving globals: FALSE
[10:32:50.545] 
[10:32:50.545] 
[10:32:50.545] getGlobalsAndPackages() ... DONE
[10:32:50.546] run() for ‘Future’ ...
[10:32:50.546] - state: ‘created’
[10:32:50.546] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.546] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.546]   - Field: ‘label’
[10:32:50.546]   - Field: ‘local’
[10:32:50.546]   - Field: ‘owner’
[10:32:50.546]   - Field: ‘envir’
[10:32:50.547]   - Field: ‘packages’
[10:32:50.547]   - Field: ‘gc’
[10:32:50.547]   - Field: ‘conditions’
[10:32:50.547]   - Field: ‘expr’
[10:32:50.547]   - Field: ‘uuid’
[10:32:50.547]   - Field: ‘seed’
[10:32:50.547]   - Field: ‘version’
[10:32:50.547]   - Field: ‘result’
[10:32:50.547]   - Field: ‘asynchronous’
[10:32:50.547]   - Field: ‘calls’
[10:32:50.547]   - Field: ‘globals’
[10:32:50.547]   - Field: ‘stdout’
[10:32:50.548]   - Field: ‘earlySignal’
[10:32:50.548]   - Field: ‘lazy’
[10:32:50.548]   - Field: ‘state’
[10:32:50.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.548] - Launch lazy future ...
[10:32:50.548] Packages needed by the future expression (n = 0): <none>
[10:32:50.548] Packages needed by future strategies (n = 0): <none>
[10:32:50.549] {
[10:32:50.549]     {
[10:32:50.549]         {
[10:32:50.549]             ...future.startTime <- base::Sys.time()
[10:32:50.549]             {
[10:32:50.549]                 {
[10:32:50.549]                   {
[10:32:50.549]                     base::local({
[10:32:50.549]                       has_future <- base::requireNamespace("future", 
[10:32:50.549]                         quietly = TRUE)
[10:32:50.549]                       if (has_future) {
[10:32:50.549]                         ns <- base::getNamespace("future")
[10:32:50.549]                         version <- ns[[".package"]][["version"]]
[10:32:50.549]                         if (is.null(version)) 
[10:32:50.549]                           version <- utils::packageVersion("future")
[10:32:50.549]                       }
[10:32:50.549]                       else {
[10:32:50.549]                         version <- NULL
[10:32:50.549]                       }
[10:32:50.549]                       if (!has_future || version < "1.8.0") {
[10:32:50.549]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.549]                           "", base::R.version$version.string), 
[10:32:50.549]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.549]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.549]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.549]                             "release", "version")], collapse = " "), 
[10:32:50.549]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.549]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.549]                           info)
[10:32:50.549]                         info <- base::paste(info, collapse = "; ")
[10:32:50.549]                         if (!has_future) {
[10:32:50.549]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.549]                             info)
[10:32:50.549]                         }
[10:32:50.549]                         else {
[10:32:50.549]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.549]                             info, version)
[10:32:50.549]                         }
[10:32:50.549]                         base::stop(msg)
[10:32:50.549]                       }
[10:32:50.549]                     })
[10:32:50.549]                   }
[10:32:50.549]                   ...future.strategy.old <- future::plan("list")
[10:32:50.549]                   options(future.plan = NULL)
[10:32:50.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.549]                 }
[10:32:50.549]                 ...future.workdir <- getwd()
[10:32:50.549]             }
[10:32:50.549]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.549]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.549]         }
[10:32:50.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.549]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.549]             base::names(...future.oldOptions))
[10:32:50.549]     }
[10:32:50.549]     if (FALSE) {
[10:32:50.549]     }
[10:32:50.549]     else {
[10:32:50.549]         if (TRUE) {
[10:32:50.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.549]                 open = "w")
[10:32:50.549]         }
[10:32:50.549]         else {
[10:32:50.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.549]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.549]         }
[10:32:50.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.549]             base::sink(type = "output", split = FALSE)
[10:32:50.549]             base::close(...future.stdout)
[10:32:50.549]         }, add = TRUE)
[10:32:50.549]     }
[10:32:50.549]     ...future.frame <- base::sys.nframe()
[10:32:50.549]     ...future.conditions <- base::list()
[10:32:50.549]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.549]     if (FALSE) {
[10:32:50.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.549]     }
[10:32:50.549]     ...future.result <- base::tryCatch({
[10:32:50.549]         base::withCallingHandlers({
[10:32:50.549]             ...future.value <- base::withVisible(base::local({
[10:32:50.549]                 4
[10:32:50.549]             }))
[10:32:50.549]             future::FutureResult(value = ...future.value$value, 
[10:32:50.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.549]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.549]                     ...future.globalenv.names))
[10:32:50.549]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.549]         }, condition = base::local({
[10:32:50.549]             c <- base::c
[10:32:50.549]             inherits <- base::inherits
[10:32:50.549]             invokeRestart <- base::invokeRestart
[10:32:50.549]             length <- base::length
[10:32:50.549]             list <- base::list
[10:32:50.549]             seq.int <- base::seq.int
[10:32:50.549]             signalCondition <- base::signalCondition
[10:32:50.549]             sys.calls <- base::sys.calls
[10:32:50.549]             `[[` <- base::`[[`
[10:32:50.549]             `+` <- base::`+`
[10:32:50.549]             `<<-` <- base::`<<-`
[10:32:50.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.549]                   3L)]
[10:32:50.549]             }
[10:32:50.549]             function(cond) {
[10:32:50.549]                 is_error <- inherits(cond, "error")
[10:32:50.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.549]                   NULL)
[10:32:50.549]                 if (is_error) {
[10:32:50.549]                   sessionInformation <- function() {
[10:32:50.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.549]                       search = base::search(), system = base::Sys.info())
[10:32:50.549]                   }
[10:32:50.549]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.549]                     cond$call), session = sessionInformation(), 
[10:32:50.549]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.549]                   signalCondition(cond)
[10:32:50.549]                 }
[10:32:50.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.549]                 "immediateCondition"))) {
[10:32:50.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.549]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.549]                   if (TRUE && !signal) {
[10:32:50.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.549]                     {
[10:32:50.549]                       inherits <- base::inherits
[10:32:50.549]                       invokeRestart <- base::invokeRestart
[10:32:50.549]                       is.null <- base::is.null
[10:32:50.549]                       muffled <- FALSE
[10:32:50.549]                       if (inherits(cond, "message")) {
[10:32:50.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.549]                         if (muffled) 
[10:32:50.549]                           invokeRestart("muffleMessage")
[10:32:50.549]                       }
[10:32:50.549]                       else if (inherits(cond, "warning")) {
[10:32:50.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.549]                         if (muffled) 
[10:32:50.549]                           invokeRestart("muffleWarning")
[10:32:50.549]                       }
[10:32:50.549]                       else if (inherits(cond, "condition")) {
[10:32:50.549]                         if (!is.null(pattern)) {
[10:32:50.549]                           computeRestarts <- base::computeRestarts
[10:32:50.549]                           grepl <- base::grepl
[10:32:50.549]                           restarts <- computeRestarts(cond)
[10:32:50.549]                           for (restart in restarts) {
[10:32:50.549]                             name <- restart$name
[10:32:50.549]                             if (is.null(name)) 
[10:32:50.549]                               next
[10:32:50.549]                             if (!grepl(pattern, name)) 
[10:32:50.549]                               next
[10:32:50.549]                             invokeRestart(restart)
[10:32:50.549]                             muffled <- TRUE
[10:32:50.549]                             break
[10:32:50.549]                           }
[10:32:50.549]                         }
[10:32:50.549]                       }
[10:32:50.549]                       invisible(muffled)
[10:32:50.549]                     }
[10:32:50.549]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.549]                   }
[10:32:50.549]                 }
[10:32:50.549]                 else {
[10:32:50.549]                   if (TRUE) {
[10:32:50.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.549]                     {
[10:32:50.549]                       inherits <- base::inherits
[10:32:50.549]                       invokeRestart <- base::invokeRestart
[10:32:50.549]                       is.null <- base::is.null
[10:32:50.549]                       muffled <- FALSE
[10:32:50.549]                       if (inherits(cond, "message")) {
[10:32:50.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.549]                         if (muffled) 
[10:32:50.549]                           invokeRestart("muffleMessage")
[10:32:50.549]                       }
[10:32:50.549]                       else if (inherits(cond, "warning")) {
[10:32:50.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.549]                         if (muffled) 
[10:32:50.549]                           invokeRestart("muffleWarning")
[10:32:50.549]                       }
[10:32:50.549]                       else if (inherits(cond, "condition")) {
[10:32:50.549]                         if (!is.null(pattern)) {
[10:32:50.549]                           computeRestarts <- base::computeRestarts
[10:32:50.549]                           grepl <- base::grepl
[10:32:50.549]                           restarts <- computeRestarts(cond)
[10:32:50.549]                           for (restart in restarts) {
[10:32:50.549]                             name <- restart$name
[10:32:50.549]                             if (is.null(name)) 
[10:32:50.549]                               next
[10:32:50.549]                             if (!grepl(pattern, name)) 
[10:32:50.549]                               next
[10:32:50.549]                             invokeRestart(restart)
[10:32:50.549]                             muffled <- TRUE
[10:32:50.549]                             break
[10:32:50.549]                           }
[10:32:50.549]                         }
[10:32:50.549]                       }
[10:32:50.549]                       invisible(muffled)
[10:32:50.549]                     }
[10:32:50.549]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.549]                   }
[10:32:50.549]                 }
[10:32:50.549]             }
[10:32:50.549]         }))
[10:32:50.549]     }, error = function(ex) {
[10:32:50.549]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.549]                 ...future.rng), started = ...future.startTime, 
[10:32:50.549]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.549]             version = "1.8"), class = "FutureResult")
[10:32:50.549]     }, finally = {
[10:32:50.549]         if (!identical(...future.workdir, getwd())) 
[10:32:50.549]             setwd(...future.workdir)
[10:32:50.549]         {
[10:32:50.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.549]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.549]             }
[10:32:50.549]             base::options(...future.oldOptions)
[10:32:50.549]             if (.Platform$OS.type == "windows") {
[10:32:50.549]                 old_names <- names(...future.oldEnvVars)
[10:32:50.549]                 envs <- base::Sys.getenv()
[10:32:50.549]                 names <- names(envs)
[10:32:50.549]                 common <- intersect(names, old_names)
[10:32:50.549]                 added <- setdiff(names, old_names)
[10:32:50.549]                 removed <- setdiff(old_names, names)
[10:32:50.549]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.549]                   envs[common]]
[10:32:50.549]                 NAMES <- toupper(changed)
[10:32:50.549]                 args <- list()
[10:32:50.549]                 for (kk in seq_along(NAMES)) {
[10:32:50.549]                   name <- changed[[kk]]
[10:32:50.549]                   NAME <- NAMES[[kk]]
[10:32:50.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.549]                     next
[10:32:50.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.549]                 }
[10:32:50.549]                 NAMES <- toupper(added)
[10:32:50.549]                 for (kk in seq_along(NAMES)) {
[10:32:50.549]                   name <- added[[kk]]
[10:32:50.549]                   NAME <- NAMES[[kk]]
[10:32:50.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.549]                     next
[10:32:50.549]                   args[[name]] <- ""
[10:32:50.549]                 }
[10:32:50.549]                 NAMES <- toupper(removed)
[10:32:50.549]                 for (kk in seq_along(NAMES)) {
[10:32:50.549]                   name <- removed[[kk]]
[10:32:50.549]                   NAME <- NAMES[[kk]]
[10:32:50.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.549]                     next
[10:32:50.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.549]                 }
[10:32:50.549]                 if (length(args) > 0) 
[10:32:50.549]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.549]             }
[10:32:50.549]             else {
[10:32:50.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.549]             }
[10:32:50.549]             {
[10:32:50.549]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.549]                   0L) {
[10:32:50.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.549]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.549]                   base::options(opts)
[10:32:50.549]                 }
[10:32:50.549]                 {
[10:32:50.549]                   {
[10:32:50.549]                     NULL
[10:32:50.549]                     RNGkind("Mersenne-Twister")
[10:32:50.549]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.549]                       inherits = FALSE)
[10:32:50.549]                   }
[10:32:50.549]                   options(future.plan = NULL)
[10:32:50.549]                   if (is.na(NA_character_)) 
[10:32:50.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.549]                     .init = FALSE)
[10:32:50.549]                 }
[10:32:50.549]             }
[10:32:50.549]         }
[10:32:50.549]     })
[10:32:50.549]     if (TRUE) {
[10:32:50.549]         base::sink(type = "output", split = FALSE)
[10:32:50.549]         if (TRUE) {
[10:32:50.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.549]         }
[10:32:50.549]         else {
[10:32:50.549]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.549]         }
[10:32:50.549]         base::close(...future.stdout)
[10:32:50.549]         ...future.stdout <- NULL
[10:32:50.549]     }
[10:32:50.549]     ...future.result$conditions <- ...future.conditions
[10:32:50.549]     ...future.result$finished <- base::Sys.time()
[10:32:50.549]     ...future.result
[10:32:50.549] }
[10:32:50.550] plan(): Setting new future strategy stack:
[10:32:50.550] List of future strategies:
[10:32:50.550] 1. sequential:
[10:32:50.550]    - args: function (..., envir = parent.frame())
[10:32:50.550]    - tweaked: FALSE
[10:32:50.550]    - call: NULL
[10:32:50.551] plan(): nbrOfWorkers() = 1
[10:32:50.551] plan(): Setting new future strategy stack:
[10:32:50.551] List of future strategies:
[10:32:50.551] 1. sequential:
[10:32:50.551]    - args: function (..., envir = parent.frame())
[10:32:50.551]    - tweaked: FALSE
[10:32:50.551]    - call: plan(strategy)
[10:32:50.552] plan(): nbrOfWorkers() = 1
[10:32:50.552] SequentialFuture started (and completed)
[10:32:50.552] - Launch lazy future ... done
[10:32:50.552] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652cfcc5100> 
Classes 'listenv', 'environment' <environment: 0x5652d14bbcf8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:50.557] resolved() for ‘SequentialFuture’ ...
[10:32:50.557] - state: ‘finished’
[10:32:50.557] - run: TRUE
[10:32:50.557] - result: ‘FutureResult’
[10:32:50.557] resolved() for ‘SequentialFuture’ ... done
[10:32:50.557] resolved() for ‘SequentialFuture’ ...
[10:32:50.557] - state: ‘finished’
[10:32:50.557] - run: TRUE
[10:32:50.557] - result: ‘FutureResult’
[10:32:50.557] resolved() for ‘SequentialFuture’ ... done
[10:32:50.558] resolved() for ‘SequentialFuture’ ...
[10:32:50.558] - state: ‘finished’
[10:32:50.558] - run: TRUE
[10:32:50.558] - result: ‘FutureResult’
[10:32:50.558] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:50.560] resolve() on list environment ...
[10:32:50.560]  recursive: 0
[10:32:50.561]  length: 6
[10:32:50.561]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:50.561] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.562] - nx: 6
[10:32:50.562] - relay: TRUE
[10:32:50.562] - stdout: TRUE
[10:32:50.562] - signal: TRUE
[10:32:50.562] - resignal: FALSE
[10:32:50.562] - force: TRUE
[10:32:50.562] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.562] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.562]  - until=2
[10:32:50.562]  - relaying element #2
[10:32:50.562] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.562] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.563] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.563]  length: 5 (resolved future 1)
[10:32:50.563] resolved() for ‘SequentialFuture’ ...
[10:32:50.563] - state: ‘finished’
[10:32:50.563] - run: TRUE
[10:32:50.563] - result: ‘FutureResult’
[10:32:50.563] resolved() for ‘SequentialFuture’ ... done
[10:32:50.563] Future #2
[10:32:50.563] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.563] - nx: 6
[10:32:50.563] - relay: TRUE
[10:32:50.564] - stdout: TRUE
[10:32:50.564] - signal: TRUE
[10:32:50.564] - resignal: FALSE
[10:32:50.564] - force: TRUE
[10:32:50.564] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.564] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.564]  - until=2
[10:32:50.564]  - relaying element #2
[10:32:50.564] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.564] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.564] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.565]  length: 4 (resolved future 2)
[10:32:50.565] resolved() for ‘SequentialFuture’ ...
[10:32:50.565] - state: ‘finished’
[10:32:50.565] - run: TRUE
[10:32:50.565] - result: ‘FutureResult’
[10:32:50.565] resolved() for ‘SequentialFuture’ ... done
[10:32:50.565] Future #3
[10:32:50.565] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.565] - nx: 6
[10:32:50.565] - relay: TRUE
[10:32:50.565] - stdout: TRUE
[10:32:50.566] - signal: TRUE
[10:32:50.566] - resignal: FALSE
[10:32:50.566] - force: TRUE
[10:32:50.566] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.566] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.566]  - until=3
[10:32:50.566]  - relaying element #3
[10:32:50.566] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.566] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.566] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.567]  length: 3 (resolved future 3)
[10:32:50.567] resolved() for ‘SequentialFuture’ ...
[10:32:50.567] - state: ‘finished’
[10:32:50.567] - run: TRUE
[10:32:50.567] - result: ‘FutureResult’
[10:32:50.567] resolved() for ‘SequentialFuture’ ... done
[10:32:50.567] Future #4
[10:32:50.567] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.567] - nx: 6
[10:32:50.567] - relay: TRUE
[10:32:50.567] - stdout: TRUE
[10:32:50.568] - signal: TRUE
[10:32:50.568] - resignal: FALSE
[10:32:50.568] - force: TRUE
[10:32:50.568] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.568] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.568]  - until=4
[10:32:50.568]  - relaying element #4
[10:32:50.568] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.568] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.568] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.568]  length: 2 (resolved future 4)
[10:32:50.569] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.569] - nx: 6
[10:32:50.569] - relay: TRUE
[10:32:50.569] - stdout: TRUE
[10:32:50.569] - signal: TRUE
[10:32:50.569] - resignal: FALSE
[10:32:50.569] - force: TRUE
[10:32:50.569] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.569] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.569]  - until=6
[10:32:50.569]  - relaying element #6
[10:32:50.569] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.570] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.570] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.570]  length: 1 (resolved future 5)
[10:32:50.570] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.570] - nx: 6
[10:32:50.570] - relay: TRUE
[10:32:50.570] - stdout: TRUE
[10:32:50.570] - signal: TRUE
[10:32:50.570] - resignal: FALSE
[10:32:50.570] - force: TRUE
[10:32:50.570] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.570] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.571]  - until=6
[10:32:50.571] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.571] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.571] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.571]  length: 0 (resolved future 6)
[10:32:50.571] Relaying remaining futures
[10:32:50.571] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.571] - nx: 6
[10:32:50.571] - relay: TRUE
[10:32:50.571] - stdout: TRUE
[10:32:50.571] - signal: TRUE
[10:32:50.571] - resignal: FALSE
[10:32:50.572] - force: TRUE
[10:32:50.572] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.572] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:50.572] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.572] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.572] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.572] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5652cf041670> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:32:50.574] getGlobalsAndPackages() ...
[10:32:50.575] Searching for globals...
[10:32:50.575] 
[10:32:50.575] Searching for globals ... DONE
[10:32:50.575] - globals: [0] <none>
[10:32:50.575] getGlobalsAndPackages() ... DONE
[10:32:50.575] run() for ‘Future’ ...
[10:32:50.575] - state: ‘created’
[10:32:50.576] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.576] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.576]   - Field: ‘label’
[10:32:50.576]   - Field: ‘local’
[10:32:50.576]   - Field: ‘owner’
[10:32:50.576]   - Field: ‘envir’
[10:32:50.578]   - Field: ‘packages’
[10:32:50.578]   - Field: ‘gc’
[10:32:50.578]   - Field: ‘conditions’
[10:32:50.578]   - Field: ‘expr’
[10:32:50.578]   - Field: ‘uuid’
[10:32:50.578]   - Field: ‘seed’
[10:32:50.578]   - Field: ‘version’
[10:32:50.578]   - Field: ‘result’
[10:32:50.579]   - Field: ‘asynchronous’
[10:32:50.579]   - Field: ‘calls’
[10:32:50.579]   - Field: ‘globals’
[10:32:50.579]   - Field: ‘stdout’
[10:32:50.579]   - Field: ‘earlySignal’
[10:32:50.579]   - Field: ‘lazy’
[10:32:50.579]   - Field: ‘state’
[10:32:50.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.579] - Launch lazy future ...
[10:32:50.580] Packages needed by the future expression (n = 0): <none>
[10:32:50.580] Packages needed by future strategies (n = 0): <none>
[10:32:50.580] {
[10:32:50.580]     {
[10:32:50.580]         {
[10:32:50.580]             ...future.startTime <- base::Sys.time()
[10:32:50.580]             {
[10:32:50.580]                 {
[10:32:50.580]                   {
[10:32:50.580]                     base::local({
[10:32:50.580]                       has_future <- base::requireNamespace("future", 
[10:32:50.580]                         quietly = TRUE)
[10:32:50.580]                       if (has_future) {
[10:32:50.580]                         ns <- base::getNamespace("future")
[10:32:50.580]                         version <- ns[[".package"]][["version"]]
[10:32:50.580]                         if (is.null(version)) 
[10:32:50.580]                           version <- utils::packageVersion("future")
[10:32:50.580]                       }
[10:32:50.580]                       else {
[10:32:50.580]                         version <- NULL
[10:32:50.580]                       }
[10:32:50.580]                       if (!has_future || version < "1.8.0") {
[10:32:50.580]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.580]                           "", base::R.version$version.string), 
[10:32:50.580]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.580]                             "release", "version")], collapse = " "), 
[10:32:50.580]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.580]                           info)
[10:32:50.580]                         info <- base::paste(info, collapse = "; ")
[10:32:50.580]                         if (!has_future) {
[10:32:50.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.580]                             info)
[10:32:50.580]                         }
[10:32:50.580]                         else {
[10:32:50.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.580]                             info, version)
[10:32:50.580]                         }
[10:32:50.580]                         base::stop(msg)
[10:32:50.580]                       }
[10:32:50.580]                     })
[10:32:50.580]                   }
[10:32:50.580]                   ...future.strategy.old <- future::plan("list")
[10:32:50.580]                   options(future.plan = NULL)
[10:32:50.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.580]                 }
[10:32:50.580]                 ...future.workdir <- getwd()
[10:32:50.580]             }
[10:32:50.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.580]         }
[10:32:50.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.580]             base::names(...future.oldOptions))
[10:32:50.580]     }
[10:32:50.580]     if (FALSE) {
[10:32:50.580]     }
[10:32:50.580]     else {
[10:32:50.580]         if (TRUE) {
[10:32:50.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.580]                 open = "w")
[10:32:50.580]         }
[10:32:50.580]         else {
[10:32:50.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.580]         }
[10:32:50.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.580]             base::sink(type = "output", split = FALSE)
[10:32:50.580]             base::close(...future.stdout)
[10:32:50.580]         }, add = TRUE)
[10:32:50.580]     }
[10:32:50.580]     ...future.frame <- base::sys.nframe()
[10:32:50.580]     ...future.conditions <- base::list()
[10:32:50.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.580]     if (FALSE) {
[10:32:50.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.580]     }
[10:32:50.580]     ...future.result <- base::tryCatch({
[10:32:50.580]         base::withCallingHandlers({
[10:32:50.580]             ...future.value <- base::withVisible(base::local(2))
[10:32:50.580]             future::FutureResult(value = ...future.value$value, 
[10:32:50.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.580]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.580]                     ...future.globalenv.names))
[10:32:50.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.580]         }, condition = base::local({
[10:32:50.580]             c <- base::c
[10:32:50.580]             inherits <- base::inherits
[10:32:50.580]             invokeRestart <- base::invokeRestart
[10:32:50.580]             length <- base::length
[10:32:50.580]             list <- base::list
[10:32:50.580]             seq.int <- base::seq.int
[10:32:50.580]             signalCondition <- base::signalCondition
[10:32:50.580]             sys.calls <- base::sys.calls
[10:32:50.580]             `[[` <- base::`[[`
[10:32:50.580]             `+` <- base::`+`
[10:32:50.580]             `<<-` <- base::`<<-`
[10:32:50.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.580]                   3L)]
[10:32:50.580]             }
[10:32:50.580]             function(cond) {
[10:32:50.580]                 is_error <- inherits(cond, "error")
[10:32:50.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.580]                   NULL)
[10:32:50.580]                 if (is_error) {
[10:32:50.580]                   sessionInformation <- function() {
[10:32:50.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.580]                       search = base::search(), system = base::Sys.info())
[10:32:50.580]                   }
[10:32:50.580]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.580]                     cond$call), session = sessionInformation(), 
[10:32:50.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.580]                   signalCondition(cond)
[10:32:50.580]                 }
[10:32:50.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.580]                 "immediateCondition"))) {
[10:32:50.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.580]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.580]                   if (TRUE && !signal) {
[10:32:50.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.580]                     {
[10:32:50.580]                       inherits <- base::inherits
[10:32:50.580]                       invokeRestart <- base::invokeRestart
[10:32:50.580]                       is.null <- base::is.null
[10:32:50.580]                       muffled <- FALSE
[10:32:50.580]                       if (inherits(cond, "message")) {
[10:32:50.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.580]                         if (muffled) 
[10:32:50.580]                           invokeRestart("muffleMessage")
[10:32:50.580]                       }
[10:32:50.580]                       else if (inherits(cond, "warning")) {
[10:32:50.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.580]                         if (muffled) 
[10:32:50.580]                           invokeRestart("muffleWarning")
[10:32:50.580]                       }
[10:32:50.580]                       else if (inherits(cond, "condition")) {
[10:32:50.580]                         if (!is.null(pattern)) {
[10:32:50.580]                           computeRestarts <- base::computeRestarts
[10:32:50.580]                           grepl <- base::grepl
[10:32:50.580]                           restarts <- computeRestarts(cond)
[10:32:50.580]                           for (restart in restarts) {
[10:32:50.580]                             name <- restart$name
[10:32:50.580]                             if (is.null(name)) 
[10:32:50.580]                               next
[10:32:50.580]                             if (!grepl(pattern, name)) 
[10:32:50.580]                               next
[10:32:50.580]                             invokeRestart(restart)
[10:32:50.580]                             muffled <- TRUE
[10:32:50.580]                             break
[10:32:50.580]                           }
[10:32:50.580]                         }
[10:32:50.580]                       }
[10:32:50.580]                       invisible(muffled)
[10:32:50.580]                     }
[10:32:50.580]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.580]                   }
[10:32:50.580]                 }
[10:32:50.580]                 else {
[10:32:50.580]                   if (TRUE) {
[10:32:50.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.580]                     {
[10:32:50.580]                       inherits <- base::inherits
[10:32:50.580]                       invokeRestart <- base::invokeRestart
[10:32:50.580]                       is.null <- base::is.null
[10:32:50.580]                       muffled <- FALSE
[10:32:50.580]                       if (inherits(cond, "message")) {
[10:32:50.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.580]                         if (muffled) 
[10:32:50.580]                           invokeRestart("muffleMessage")
[10:32:50.580]                       }
[10:32:50.580]                       else if (inherits(cond, "warning")) {
[10:32:50.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.580]                         if (muffled) 
[10:32:50.580]                           invokeRestart("muffleWarning")
[10:32:50.580]                       }
[10:32:50.580]                       else if (inherits(cond, "condition")) {
[10:32:50.580]                         if (!is.null(pattern)) {
[10:32:50.580]                           computeRestarts <- base::computeRestarts
[10:32:50.580]                           grepl <- base::grepl
[10:32:50.580]                           restarts <- computeRestarts(cond)
[10:32:50.580]                           for (restart in restarts) {
[10:32:50.580]                             name <- restart$name
[10:32:50.580]                             if (is.null(name)) 
[10:32:50.580]                               next
[10:32:50.580]                             if (!grepl(pattern, name)) 
[10:32:50.580]                               next
[10:32:50.580]                             invokeRestart(restart)
[10:32:50.580]                             muffled <- TRUE
[10:32:50.580]                             break
[10:32:50.580]                           }
[10:32:50.580]                         }
[10:32:50.580]                       }
[10:32:50.580]                       invisible(muffled)
[10:32:50.580]                     }
[10:32:50.580]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.580]                   }
[10:32:50.580]                 }
[10:32:50.580]             }
[10:32:50.580]         }))
[10:32:50.580]     }, error = function(ex) {
[10:32:50.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.580]                 ...future.rng), started = ...future.startTime, 
[10:32:50.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.580]             version = "1.8"), class = "FutureResult")
[10:32:50.580]     }, finally = {
[10:32:50.580]         if (!identical(...future.workdir, getwd())) 
[10:32:50.580]             setwd(...future.workdir)
[10:32:50.580]         {
[10:32:50.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.580]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.580]             }
[10:32:50.580]             base::options(...future.oldOptions)
[10:32:50.580]             if (.Platform$OS.type == "windows") {
[10:32:50.580]                 old_names <- names(...future.oldEnvVars)
[10:32:50.580]                 envs <- base::Sys.getenv()
[10:32:50.580]                 names <- names(envs)
[10:32:50.580]                 common <- intersect(names, old_names)
[10:32:50.580]                 added <- setdiff(names, old_names)
[10:32:50.580]                 removed <- setdiff(old_names, names)
[10:32:50.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.580]                   envs[common]]
[10:32:50.580]                 NAMES <- toupper(changed)
[10:32:50.580]                 args <- list()
[10:32:50.580]                 for (kk in seq_along(NAMES)) {
[10:32:50.580]                   name <- changed[[kk]]
[10:32:50.580]                   NAME <- NAMES[[kk]]
[10:32:50.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.580]                     next
[10:32:50.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.580]                 }
[10:32:50.580]                 NAMES <- toupper(added)
[10:32:50.580]                 for (kk in seq_along(NAMES)) {
[10:32:50.580]                   name <- added[[kk]]
[10:32:50.580]                   NAME <- NAMES[[kk]]
[10:32:50.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.580]                     next
[10:32:50.580]                   args[[name]] <- ""
[10:32:50.580]                 }
[10:32:50.580]                 NAMES <- toupper(removed)
[10:32:50.580]                 for (kk in seq_along(NAMES)) {
[10:32:50.580]                   name <- removed[[kk]]
[10:32:50.580]                   NAME <- NAMES[[kk]]
[10:32:50.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.580]                     next
[10:32:50.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.580]                 }
[10:32:50.580]                 if (length(args) > 0) 
[10:32:50.580]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.580]             }
[10:32:50.580]             else {
[10:32:50.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.580]             }
[10:32:50.580]             {
[10:32:50.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.580]                   0L) {
[10:32:50.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.580]                   base::options(opts)
[10:32:50.580]                 }
[10:32:50.580]                 {
[10:32:50.580]                   {
[10:32:50.580]                     NULL
[10:32:50.580]                     RNGkind("Mersenne-Twister")
[10:32:50.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.580]                       inherits = FALSE)
[10:32:50.580]                   }
[10:32:50.580]                   options(future.plan = NULL)
[10:32:50.580]                   if (is.na(NA_character_)) 
[10:32:50.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.580]                     .init = FALSE)
[10:32:50.580]                 }
[10:32:50.580]             }
[10:32:50.580]         }
[10:32:50.580]     })
[10:32:50.580]     if (TRUE) {
[10:32:50.580]         base::sink(type = "output", split = FALSE)
[10:32:50.580]         if (TRUE) {
[10:32:50.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.580]         }
[10:32:50.580]         else {
[10:32:50.580]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.580]         }
[10:32:50.580]         base::close(...future.stdout)
[10:32:50.580]         ...future.stdout <- NULL
[10:32:50.580]     }
[10:32:50.580]     ...future.result$conditions <- ...future.conditions
[10:32:50.580]     ...future.result$finished <- base::Sys.time()
[10:32:50.580]     ...future.result
[10:32:50.580] }
[10:32:50.582] plan(): Setting new future strategy stack:
[10:32:50.582] List of future strategies:
[10:32:50.582] 1. sequential:
[10:32:50.582]    - args: function (..., envir = parent.frame())
[10:32:50.582]    - tweaked: FALSE
[10:32:50.582]    - call: NULL
[10:32:50.582] plan(): nbrOfWorkers() = 1
[10:32:50.583] plan(): Setting new future strategy stack:
[10:32:50.583] List of future strategies:
[10:32:50.583] 1. sequential:
[10:32:50.583]    - args: function (..., envir = parent.frame())
[10:32:50.583]    - tweaked: FALSE
[10:32:50.583]    - call: plan(strategy)
[10:32:50.583] plan(): nbrOfWorkers() = 1
[10:32:50.584] SequentialFuture started (and completed)
[10:32:50.584] - Launch lazy future ... done
[10:32:50.584] run() for ‘SequentialFuture’ ... done
[10:32:50.584] getGlobalsAndPackages() ...
[10:32:50.584] Searching for globals...
[10:32:50.584] 
[10:32:50.585] Searching for globals ... DONE
[10:32:50.585] - globals: [0] <none>
[10:32:50.585] getGlobalsAndPackages() ... DONE
[10:32:50.585] run() for ‘Future’ ...
[10:32:50.585] - state: ‘created’
[10:32:50.585] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.586]   - Field: ‘label’
[10:32:50.586]   - Field: ‘local’
[10:32:50.586]   - Field: ‘owner’
[10:32:50.586]   - Field: ‘envir’
[10:32:50.586]   - Field: ‘packages’
[10:32:50.586]   - Field: ‘gc’
[10:32:50.586]   - Field: ‘conditions’
[10:32:50.586]   - Field: ‘expr’
[10:32:50.586]   - Field: ‘uuid’
[10:32:50.586]   - Field: ‘seed’
[10:32:50.587]   - Field: ‘version’
[10:32:50.587]   - Field: ‘result’
[10:32:50.587]   - Field: ‘asynchronous’
[10:32:50.587]   - Field: ‘calls’
[10:32:50.587]   - Field: ‘globals’
[10:32:50.587]   - Field: ‘stdout’
[10:32:50.587]   - Field: ‘earlySignal’
[10:32:50.587]   - Field: ‘lazy’
[10:32:50.587]   - Field: ‘state’
[10:32:50.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.587] - Launch lazy future ...
[10:32:50.588] Packages needed by the future expression (n = 0): <none>
[10:32:50.588] Packages needed by future strategies (n = 0): <none>
[10:32:50.588] {
[10:32:50.588]     {
[10:32:50.588]         {
[10:32:50.588]             ...future.startTime <- base::Sys.time()
[10:32:50.588]             {
[10:32:50.588]                 {
[10:32:50.588]                   {
[10:32:50.588]                     base::local({
[10:32:50.588]                       has_future <- base::requireNamespace("future", 
[10:32:50.588]                         quietly = TRUE)
[10:32:50.588]                       if (has_future) {
[10:32:50.588]                         ns <- base::getNamespace("future")
[10:32:50.588]                         version <- ns[[".package"]][["version"]]
[10:32:50.588]                         if (is.null(version)) 
[10:32:50.588]                           version <- utils::packageVersion("future")
[10:32:50.588]                       }
[10:32:50.588]                       else {
[10:32:50.588]                         version <- NULL
[10:32:50.588]                       }
[10:32:50.588]                       if (!has_future || version < "1.8.0") {
[10:32:50.588]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.588]                           "", base::R.version$version.string), 
[10:32:50.588]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.588]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.588]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.588]                             "release", "version")], collapse = " "), 
[10:32:50.588]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.588]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.588]                           info)
[10:32:50.588]                         info <- base::paste(info, collapse = "; ")
[10:32:50.588]                         if (!has_future) {
[10:32:50.588]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.588]                             info)
[10:32:50.588]                         }
[10:32:50.588]                         else {
[10:32:50.588]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.588]                             info, version)
[10:32:50.588]                         }
[10:32:50.588]                         base::stop(msg)
[10:32:50.588]                       }
[10:32:50.588]                     })
[10:32:50.588]                   }
[10:32:50.588]                   ...future.strategy.old <- future::plan("list")
[10:32:50.588]                   options(future.plan = NULL)
[10:32:50.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.588]                 }
[10:32:50.588]                 ...future.workdir <- getwd()
[10:32:50.588]             }
[10:32:50.588]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.588]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.588]         }
[10:32:50.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.588]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.588]             base::names(...future.oldOptions))
[10:32:50.588]     }
[10:32:50.588]     if (FALSE) {
[10:32:50.588]     }
[10:32:50.588]     else {
[10:32:50.588]         if (TRUE) {
[10:32:50.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.588]                 open = "w")
[10:32:50.588]         }
[10:32:50.588]         else {
[10:32:50.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.588]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.588]         }
[10:32:50.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.588]             base::sink(type = "output", split = FALSE)
[10:32:50.588]             base::close(...future.stdout)
[10:32:50.588]         }, add = TRUE)
[10:32:50.588]     }
[10:32:50.588]     ...future.frame <- base::sys.nframe()
[10:32:50.588]     ...future.conditions <- base::list()
[10:32:50.588]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.588]     if (FALSE) {
[10:32:50.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.588]     }
[10:32:50.588]     ...future.result <- base::tryCatch({
[10:32:50.588]         base::withCallingHandlers({
[10:32:50.588]             ...future.value <- base::withVisible(base::local(NULL))
[10:32:50.588]             future::FutureResult(value = ...future.value$value, 
[10:32:50.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.588]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.588]                     ...future.globalenv.names))
[10:32:50.588]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.588]         }, condition = base::local({
[10:32:50.588]             c <- base::c
[10:32:50.588]             inherits <- base::inherits
[10:32:50.588]             invokeRestart <- base::invokeRestart
[10:32:50.588]             length <- base::length
[10:32:50.588]             list <- base::list
[10:32:50.588]             seq.int <- base::seq.int
[10:32:50.588]             signalCondition <- base::signalCondition
[10:32:50.588]             sys.calls <- base::sys.calls
[10:32:50.588]             `[[` <- base::`[[`
[10:32:50.588]             `+` <- base::`+`
[10:32:50.588]             `<<-` <- base::`<<-`
[10:32:50.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.588]                   3L)]
[10:32:50.588]             }
[10:32:50.588]             function(cond) {
[10:32:50.588]                 is_error <- inherits(cond, "error")
[10:32:50.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.588]                   NULL)
[10:32:50.588]                 if (is_error) {
[10:32:50.588]                   sessionInformation <- function() {
[10:32:50.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.588]                       search = base::search(), system = base::Sys.info())
[10:32:50.588]                   }
[10:32:50.588]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.588]                     cond$call), session = sessionInformation(), 
[10:32:50.588]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.588]                   signalCondition(cond)
[10:32:50.588]                 }
[10:32:50.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.588]                 "immediateCondition"))) {
[10:32:50.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.588]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.588]                   if (TRUE && !signal) {
[10:32:50.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.588]                     {
[10:32:50.588]                       inherits <- base::inherits
[10:32:50.588]                       invokeRestart <- base::invokeRestart
[10:32:50.588]                       is.null <- base::is.null
[10:32:50.588]                       muffled <- FALSE
[10:32:50.588]                       if (inherits(cond, "message")) {
[10:32:50.588]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.588]                         if (muffled) 
[10:32:50.588]                           invokeRestart("muffleMessage")
[10:32:50.588]                       }
[10:32:50.588]                       else if (inherits(cond, "warning")) {
[10:32:50.588]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.588]                         if (muffled) 
[10:32:50.588]                           invokeRestart("muffleWarning")
[10:32:50.588]                       }
[10:32:50.588]                       else if (inherits(cond, "condition")) {
[10:32:50.588]                         if (!is.null(pattern)) {
[10:32:50.588]                           computeRestarts <- base::computeRestarts
[10:32:50.588]                           grepl <- base::grepl
[10:32:50.588]                           restarts <- computeRestarts(cond)
[10:32:50.588]                           for (restart in restarts) {
[10:32:50.588]                             name <- restart$name
[10:32:50.588]                             if (is.null(name)) 
[10:32:50.588]                               next
[10:32:50.588]                             if (!grepl(pattern, name)) 
[10:32:50.588]                               next
[10:32:50.588]                             invokeRestart(restart)
[10:32:50.588]                             muffled <- TRUE
[10:32:50.588]                             break
[10:32:50.588]                           }
[10:32:50.588]                         }
[10:32:50.588]                       }
[10:32:50.588]                       invisible(muffled)
[10:32:50.588]                     }
[10:32:50.588]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.588]                   }
[10:32:50.588]                 }
[10:32:50.588]                 else {
[10:32:50.588]                   if (TRUE) {
[10:32:50.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.588]                     {
[10:32:50.588]                       inherits <- base::inherits
[10:32:50.588]                       invokeRestart <- base::invokeRestart
[10:32:50.588]                       is.null <- base::is.null
[10:32:50.588]                       muffled <- FALSE
[10:32:50.588]                       if (inherits(cond, "message")) {
[10:32:50.588]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.588]                         if (muffled) 
[10:32:50.588]                           invokeRestart("muffleMessage")
[10:32:50.588]                       }
[10:32:50.588]                       else if (inherits(cond, "warning")) {
[10:32:50.588]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.588]                         if (muffled) 
[10:32:50.588]                           invokeRestart("muffleWarning")
[10:32:50.588]                       }
[10:32:50.588]                       else if (inherits(cond, "condition")) {
[10:32:50.588]                         if (!is.null(pattern)) {
[10:32:50.588]                           computeRestarts <- base::computeRestarts
[10:32:50.588]                           grepl <- base::grepl
[10:32:50.588]                           restarts <- computeRestarts(cond)
[10:32:50.588]                           for (restart in restarts) {
[10:32:50.588]                             name <- restart$name
[10:32:50.588]                             if (is.null(name)) 
[10:32:50.588]                               next
[10:32:50.588]                             if (!grepl(pattern, name)) 
[10:32:50.588]                               next
[10:32:50.588]                             invokeRestart(restart)
[10:32:50.588]                             muffled <- TRUE
[10:32:50.588]                             break
[10:32:50.588]                           }
[10:32:50.588]                         }
[10:32:50.588]                       }
[10:32:50.588]                       invisible(muffled)
[10:32:50.588]                     }
[10:32:50.588]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.588]                   }
[10:32:50.588]                 }
[10:32:50.588]             }
[10:32:50.588]         }))
[10:32:50.588]     }, error = function(ex) {
[10:32:50.588]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.588]                 ...future.rng), started = ...future.startTime, 
[10:32:50.588]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.588]             version = "1.8"), class = "FutureResult")
[10:32:50.588]     }, finally = {
[10:32:50.588]         if (!identical(...future.workdir, getwd())) 
[10:32:50.588]             setwd(...future.workdir)
[10:32:50.588]         {
[10:32:50.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.588]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.588]             }
[10:32:50.588]             base::options(...future.oldOptions)
[10:32:50.588]             if (.Platform$OS.type == "windows") {
[10:32:50.588]                 old_names <- names(...future.oldEnvVars)
[10:32:50.588]                 envs <- base::Sys.getenv()
[10:32:50.588]                 names <- names(envs)
[10:32:50.588]                 common <- intersect(names, old_names)
[10:32:50.588]                 added <- setdiff(names, old_names)
[10:32:50.588]                 removed <- setdiff(old_names, names)
[10:32:50.588]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.588]                   envs[common]]
[10:32:50.588]                 NAMES <- toupper(changed)
[10:32:50.588]                 args <- list()
[10:32:50.588]                 for (kk in seq_along(NAMES)) {
[10:32:50.588]                   name <- changed[[kk]]
[10:32:50.588]                   NAME <- NAMES[[kk]]
[10:32:50.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.588]                     next
[10:32:50.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.588]                 }
[10:32:50.588]                 NAMES <- toupper(added)
[10:32:50.588]                 for (kk in seq_along(NAMES)) {
[10:32:50.588]                   name <- added[[kk]]
[10:32:50.588]                   NAME <- NAMES[[kk]]
[10:32:50.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.588]                     next
[10:32:50.588]                   args[[name]] <- ""
[10:32:50.588]                 }
[10:32:50.588]                 NAMES <- toupper(removed)
[10:32:50.588]                 for (kk in seq_along(NAMES)) {
[10:32:50.588]                   name <- removed[[kk]]
[10:32:50.588]                   NAME <- NAMES[[kk]]
[10:32:50.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.588]                     next
[10:32:50.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.588]                 }
[10:32:50.588]                 if (length(args) > 0) 
[10:32:50.588]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.588]             }
[10:32:50.588]             else {
[10:32:50.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.588]             }
[10:32:50.588]             {
[10:32:50.588]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.588]                   0L) {
[10:32:50.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.588]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.588]                   base::options(opts)
[10:32:50.588]                 }
[10:32:50.588]                 {
[10:32:50.588]                   {
[10:32:50.588]                     NULL
[10:32:50.588]                     RNGkind("Mersenne-Twister")
[10:32:50.588]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.588]                       inherits = FALSE)
[10:32:50.588]                   }
[10:32:50.588]                   options(future.plan = NULL)
[10:32:50.588]                   if (is.na(NA_character_)) 
[10:32:50.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.588]                     .init = FALSE)
[10:32:50.588]                 }
[10:32:50.588]             }
[10:32:50.588]         }
[10:32:50.588]     })
[10:32:50.588]     if (TRUE) {
[10:32:50.588]         base::sink(type = "output", split = FALSE)
[10:32:50.588]         if (TRUE) {
[10:32:50.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.588]         }
[10:32:50.588]         else {
[10:32:50.588]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.588]         }
[10:32:50.588]         base::close(...future.stdout)
[10:32:50.588]         ...future.stdout <- NULL
[10:32:50.588]     }
[10:32:50.588]     ...future.result$conditions <- ...future.conditions
[10:32:50.588]     ...future.result$finished <- base::Sys.time()
[10:32:50.588]     ...future.result
[10:32:50.588] }
[10:32:50.590] plan(): Setting new future strategy stack:
[10:32:50.590] List of future strategies:
[10:32:50.590] 1. sequential:
[10:32:50.590]    - args: function (..., envir = parent.frame())
[10:32:50.590]    - tweaked: FALSE
[10:32:50.590]    - call: NULL
[10:32:50.590] plan(): nbrOfWorkers() = 1
[10:32:50.591] plan(): Setting new future strategy stack:
[10:32:50.591] List of future strategies:
[10:32:50.591] 1. sequential:
[10:32:50.591]    - args: function (..., envir = parent.frame())
[10:32:50.591]    - tweaked: FALSE
[10:32:50.591]    - call: plan(strategy)
[10:32:50.591] plan(): nbrOfWorkers() = 1
[10:32:50.592] SequentialFuture started (and completed)
[10:32:50.592] - Launch lazy future ... done
[10:32:50.592] run() for ‘SequentialFuture’ ... done
[10:32:50.592] getGlobalsAndPackages() ...
[10:32:50.592] Searching for globals...
[10:32:50.593] - globals found: [1] ‘{’
[10:32:50.593] Searching for globals ... DONE
[10:32:50.593] Resolving globals: FALSE
[10:32:50.593] 
[10:32:50.593] 
[10:32:50.593] getGlobalsAndPackages() ... DONE
[10:32:50.594] run() for ‘Future’ ...
[10:32:50.594] - state: ‘created’
[10:32:50.594] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:50.594] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:50.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:50.594]   - Field: ‘label’
[10:32:50.594]   - Field: ‘local’
[10:32:50.594]   - Field: ‘owner’
[10:32:50.595]   - Field: ‘envir’
[10:32:50.595]   - Field: ‘packages’
[10:32:50.595]   - Field: ‘gc’
[10:32:50.595]   - Field: ‘conditions’
[10:32:50.595]   - Field: ‘expr’
[10:32:50.595]   - Field: ‘uuid’
[10:32:50.595]   - Field: ‘seed’
[10:32:50.595]   - Field: ‘version’
[10:32:50.595]   - Field: ‘result’
[10:32:50.595]   - Field: ‘asynchronous’
[10:32:50.595]   - Field: ‘calls’
[10:32:50.596]   - Field: ‘globals’
[10:32:50.596]   - Field: ‘stdout’
[10:32:50.596]   - Field: ‘earlySignal’
[10:32:50.596]   - Field: ‘lazy’
[10:32:50.596]   - Field: ‘state’
[10:32:50.596] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:50.596] - Launch lazy future ...
[10:32:50.596] Packages needed by the future expression (n = 0): <none>
[10:32:50.596] Packages needed by future strategies (n = 0): <none>
[10:32:50.597] {
[10:32:50.597]     {
[10:32:50.597]         {
[10:32:50.597]             ...future.startTime <- base::Sys.time()
[10:32:50.597]             {
[10:32:50.597]                 {
[10:32:50.597]                   {
[10:32:50.597]                     base::local({
[10:32:50.597]                       has_future <- base::requireNamespace("future", 
[10:32:50.597]                         quietly = TRUE)
[10:32:50.597]                       if (has_future) {
[10:32:50.597]                         ns <- base::getNamespace("future")
[10:32:50.597]                         version <- ns[[".package"]][["version"]]
[10:32:50.597]                         if (is.null(version)) 
[10:32:50.597]                           version <- utils::packageVersion("future")
[10:32:50.597]                       }
[10:32:50.597]                       else {
[10:32:50.597]                         version <- NULL
[10:32:50.597]                       }
[10:32:50.597]                       if (!has_future || version < "1.8.0") {
[10:32:50.597]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.597]                           "", base::R.version$version.string), 
[10:32:50.597]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:50.597]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.597]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.597]                             "release", "version")], collapse = " "), 
[10:32:50.597]                           hostname = base::Sys.info()[["nodename"]])
[10:32:50.597]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.597]                           info)
[10:32:50.597]                         info <- base::paste(info, collapse = "; ")
[10:32:50.597]                         if (!has_future) {
[10:32:50.597]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.597]                             info)
[10:32:50.597]                         }
[10:32:50.597]                         else {
[10:32:50.597]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.597]                             info, version)
[10:32:50.597]                         }
[10:32:50.597]                         base::stop(msg)
[10:32:50.597]                       }
[10:32:50.597]                     })
[10:32:50.597]                   }
[10:32:50.597]                   ...future.strategy.old <- future::plan("list")
[10:32:50.597]                   options(future.plan = NULL)
[10:32:50.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.597]                 }
[10:32:50.597]                 ...future.workdir <- getwd()
[10:32:50.597]             }
[10:32:50.597]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.597]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.597]         }
[10:32:50.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.597]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.597]             base::names(...future.oldOptions))
[10:32:50.597]     }
[10:32:50.597]     if (FALSE) {
[10:32:50.597]     }
[10:32:50.597]     else {
[10:32:50.597]         if (TRUE) {
[10:32:50.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.597]                 open = "w")
[10:32:50.597]         }
[10:32:50.597]         else {
[10:32:50.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.597]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.597]         }
[10:32:50.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.597]             base::sink(type = "output", split = FALSE)
[10:32:50.597]             base::close(...future.stdout)
[10:32:50.597]         }, add = TRUE)
[10:32:50.597]     }
[10:32:50.597]     ...future.frame <- base::sys.nframe()
[10:32:50.597]     ...future.conditions <- base::list()
[10:32:50.597]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.597]     if (FALSE) {
[10:32:50.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.597]     }
[10:32:50.597]     ...future.result <- base::tryCatch({
[10:32:50.597]         base::withCallingHandlers({
[10:32:50.597]             ...future.value <- base::withVisible(base::local({
[10:32:50.597]                 4
[10:32:50.597]             }))
[10:32:50.597]             future::FutureResult(value = ...future.value$value, 
[10:32:50.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.597]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.597]                     ...future.globalenv.names))
[10:32:50.597]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.597]         }, condition = base::local({
[10:32:50.597]             c <- base::c
[10:32:50.597]             inherits <- base::inherits
[10:32:50.597]             invokeRestart <- base::invokeRestart
[10:32:50.597]             length <- base::length
[10:32:50.597]             list <- base::list
[10:32:50.597]             seq.int <- base::seq.int
[10:32:50.597]             signalCondition <- base::signalCondition
[10:32:50.597]             sys.calls <- base::sys.calls
[10:32:50.597]             `[[` <- base::`[[`
[10:32:50.597]             `+` <- base::`+`
[10:32:50.597]             `<<-` <- base::`<<-`
[10:32:50.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.597]                   3L)]
[10:32:50.597]             }
[10:32:50.597]             function(cond) {
[10:32:50.597]                 is_error <- inherits(cond, "error")
[10:32:50.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.597]                   NULL)
[10:32:50.597]                 if (is_error) {
[10:32:50.597]                   sessionInformation <- function() {
[10:32:50.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.597]                       search = base::search(), system = base::Sys.info())
[10:32:50.597]                   }
[10:32:50.597]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.597]                     cond$call), session = sessionInformation(), 
[10:32:50.597]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.597]                   signalCondition(cond)
[10:32:50.597]                 }
[10:32:50.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.597]                 "immediateCondition"))) {
[10:32:50.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.597]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.597]                   if (TRUE && !signal) {
[10:32:50.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.597]                     {
[10:32:50.597]                       inherits <- base::inherits
[10:32:50.597]                       invokeRestart <- base::invokeRestart
[10:32:50.597]                       is.null <- base::is.null
[10:32:50.597]                       muffled <- FALSE
[10:32:50.597]                       if (inherits(cond, "message")) {
[10:32:50.597]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.597]                         if (muffled) 
[10:32:50.597]                           invokeRestart("muffleMessage")
[10:32:50.597]                       }
[10:32:50.597]                       else if (inherits(cond, "warning")) {
[10:32:50.597]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.597]                         if (muffled) 
[10:32:50.597]                           invokeRestart("muffleWarning")
[10:32:50.597]                       }
[10:32:50.597]                       else if (inherits(cond, "condition")) {
[10:32:50.597]                         if (!is.null(pattern)) {
[10:32:50.597]                           computeRestarts <- base::computeRestarts
[10:32:50.597]                           grepl <- base::grepl
[10:32:50.597]                           restarts <- computeRestarts(cond)
[10:32:50.597]                           for (restart in restarts) {
[10:32:50.597]                             name <- restart$name
[10:32:50.597]                             if (is.null(name)) 
[10:32:50.597]                               next
[10:32:50.597]                             if (!grepl(pattern, name)) 
[10:32:50.597]                               next
[10:32:50.597]                             invokeRestart(restart)
[10:32:50.597]                             muffled <- TRUE
[10:32:50.597]                             break
[10:32:50.597]                           }
[10:32:50.597]                         }
[10:32:50.597]                       }
[10:32:50.597]                       invisible(muffled)
[10:32:50.597]                     }
[10:32:50.597]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.597]                   }
[10:32:50.597]                 }
[10:32:50.597]                 else {
[10:32:50.597]                   if (TRUE) {
[10:32:50.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.597]                     {
[10:32:50.597]                       inherits <- base::inherits
[10:32:50.597]                       invokeRestart <- base::invokeRestart
[10:32:50.597]                       is.null <- base::is.null
[10:32:50.597]                       muffled <- FALSE
[10:32:50.597]                       if (inherits(cond, "message")) {
[10:32:50.597]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.597]                         if (muffled) 
[10:32:50.597]                           invokeRestart("muffleMessage")
[10:32:50.597]                       }
[10:32:50.597]                       else if (inherits(cond, "warning")) {
[10:32:50.597]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.597]                         if (muffled) 
[10:32:50.597]                           invokeRestart("muffleWarning")
[10:32:50.597]                       }
[10:32:50.597]                       else if (inherits(cond, "condition")) {
[10:32:50.597]                         if (!is.null(pattern)) {
[10:32:50.597]                           computeRestarts <- base::computeRestarts
[10:32:50.597]                           grepl <- base::grepl
[10:32:50.597]                           restarts <- computeRestarts(cond)
[10:32:50.597]                           for (restart in restarts) {
[10:32:50.597]                             name <- restart$name
[10:32:50.597]                             if (is.null(name)) 
[10:32:50.597]                               next
[10:32:50.597]                             if (!grepl(pattern, name)) 
[10:32:50.597]                               next
[10:32:50.597]                             invokeRestart(restart)
[10:32:50.597]                             muffled <- TRUE
[10:32:50.597]                             break
[10:32:50.597]                           }
[10:32:50.597]                         }
[10:32:50.597]                       }
[10:32:50.597]                       invisible(muffled)
[10:32:50.597]                     }
[10:32:50.597]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.597]                   }
[10:32:50.597]                 }
[10:32:50.597]             }
[10:32:50.597]         }))
[10:32:50.597]     }, error = function(ex) {
[10:32:50.597]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.597]                 ...future.rng), started = ...future.startTime, 
[10:32:50.597]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.597]             version = "1.8"), class = "FutureResult")
[10:32:50.597]     }, finally = {
[10:32:50.597]         if (!identical(...future.workdir, getwd())) 
[10:32:50.597]             setwd(...future.workdir)
[10:32:50.597]         {
[10:32:50.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.597]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.597]             }
[10:32:50.597]             base::options(...future.oldOptions)
[10:32:50.597]             if (.Platform$OS.type == "windows") {
[10:32:50.597]                 old_names <- names(...future.oldEnvVars)
[10:32:50.597]                 envs <- base::Sys.getenv()
[10:32:50.597]                 names <- names(envs)
[10:32:50.597]                 common <- intersect(names, old_names)
[10:32:50.597]                 added <- setdiff(names, old_names)
[10:32:50.597]                 removed <- setdiff(old_names, names)
[10:32:50.597]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.597]                   envs[common]]
[10:32:50.597]                 NAMES <- toupper(changed)
[10:32:50.597]                 args <- list()
[10:32:50.597]                 for (kk in seq_along(NAMES)) {
[10:32:50.597]                   name <- changed[[kk]]
[10:32:50.597]                   NAME <- NAMES[[kk]]
[10:32:50.597]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.597]                     next
[10:32:50.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.597]                 }
[10:32:50.597]                 NAMES <- toupper(added)
[10:32:50.597]                 for (kk in seq_along(NAMES)) {
[10:32:50.597]                   name <- added[[kk]]
[10:32:50.597]                   NAME <- NAMES[[kk]]
[10:32:50.597]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.597]                     next
[10:32:50.597]                   args[[name]] <- ""
[10:32:50.597]                 }
[10:32:50.597]                 NAMES <- toupper(removed)
[10:32:50.597]                 for (kk in seq_along(NAMES)) {
[10:32:50.597]                   name <- removed[[kk]]
[10:32:50.597]                   NAME <- NAMES[[kk]]
[10:32:50.597]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.597]                     next
[10:32:50.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.597]                 }
[10:32:50.597]                 if (length(args) > 0) 
[10:32:50.597]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.597]             }
[10:32:50.597]             else {
[10:32:50.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.597]             }
[10:32:50.597]             {
[10:32:50.597]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.597]                   0L) {
[10:32:50.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.597]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.597]                   base::options(opts)
[10:32:50.597]                 }
[10:32:50.597]                 {
[10:32:50.597]                   {
[10:32:50.597]                     NULL
[10:32:50.597]                     RNGkind("Mersenne-Twister")
[10:32:50.597]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:50.597]                       inherits = FALSE)
[10:32:50.597]                   }
[10:32:50.597]                   options(future.plan = NULL)
[10:32:50.597]                   if (is.na(NA_character_)) 
[10:32:50.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.597]                     .init = FALSE)
[10:32:50.597]                 }
[10:32:50.597]             }
[10:32:50.597]         }
[10:32:50.597]     })
[10:32:50.597]     if (TRUE) {
[10:32:50.597]         base::sink(type = "output", split = FALSE)
[10:32:50.597]         if (TRUE) {
[10:32:50.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.597]         }
[10:32:50.597]         else {
[10:32:50.597]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.597]         }
[10:32:50.597]         base::close(...future.stdout)
[10:32:50.597]         ...future.stdout <- NULL
[10:32:50.597]     }
[10:32:50.597]     ...future.result$conditions <- ...future.conditions
[10:32:50.597]     ...future.result$finished <- base::Sys.time()
[10:32:50.597]     ...future.result
[10:32:50.597] }
[10:32:50.598] plan(): Setting new future strategy stack:
[10:32:50.599] List of future strategies:
[10:32:50.599] 1. sequential:
[10:32:50.599]    - args: function (..., envir = parent.frame())
[10:32:50.599]    - tweaked: FALSE
[10:32:50.599]    - call: NULL
[10:32:50.599] plan(): nbrOfWorkers() = 1
[10:32:50.600] plan(): Setting new future strategy stack:
[10:32:50.600] List of future strategies:
[10:32:50.600] 1. sequential:
[10:32:50.600]    - args: function (..., envir = parent.frame())
[10:32:50.600]    - tweaked: FALSE
[10:32:50.600]    - call: plan(strategy)
[10:32:50.600] plan(): nbrOfWorkers() = 1
[10:32:50.600] SequentialFuture started (and completed)
[10:32:50.600] - Launch lazy future ... done
[10:32:50.600] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d14111a0> 
Classes 'listenv', 'environment' <environment: 0x5652d10b6020> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:50.604] resolved() for ‘SequentialFuture’ ...
[10:32:50.604] - state: ‘finished’
[10:32:50.604] - run: TRUE
[10:32:50.604] - result: ‘FutureResult’
[10:32:50.605] resolved() for ‘SequentialFuture’ ... done
[10:32:50.605] resolved() for ‘SequentialFuture’ ...
[10:32:50.605] - state: ‘finished’
[10:32:50.605] - run: TRUE
[10:32:50.605] - result: ‘FutureResult’
[10:32:50.605] resolved() for ‘SequentialFuture’ ... done
[10:32:50.605] resolved() for ‘SequentialFuture’ ...
[10:32:50.605] - state: ‘finished’
[10:32:50.605] - run: TRUE
[10:32:50.605] - result: ‘FutureResult’
[10:32:50.605] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:50.609] resolve() on list environment ...
[10:32:50.609]  recursive: 0
[10:32:50.610]  length: 6
[10:32:50.610]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:50.611] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.611] - nx: 6
[10:32:50.611] - relay: TRUE
[10:32:50.611] - stdout: TRUE
[10:32:50.611] - signal: TRUE
[10:32:50.611] - resignal: FALSE
[10:32:50.611] - force: TRUE
[10:32:50.611] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.611] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.611]  - until=2
[10:32:50.611]  - relaying element #2
[10:32:50.611] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.612] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.612] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.612]  length: 5 (resolved future 1)
[10:32:50.612] resolved() for ‘SequentialFuture’ ...
[10:32:50.612] - state: ‘finished’
[10:32:50.612] - run: TRUE
[10:32:50.612] - result: ‘FutureResult’
[10:32:50.612] resolved() for ‘SequentialFuture’ ... done
[10:32:50.612] Future #2
[10:32:50.612] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:32:50.613] - nx: 6
[10:32:50.613] - relay: TRUE
[10:32:50.613] - stdout: TRUE
[10:32:50.613] - signal: TRUE
[10:32:50.613] - resignal: FALSE
[10:32:50.613] - force: TRUE
[10:32:50.613] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.613] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.613]  - until=2
[10:32:50.613]  - relaying element #2
[10:32:50.613] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.614] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.614] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:32:50.614]  length: 4 (resolved future 2)
[10:32:50.614] resolved() for ‘SequentialFuture’ ...
[10:32:50.614] - state: ‘finished’
[10:32:50.614] - run: TRUE
[10:32:50.614] - result: ‘FutureResult’
[10:32:50.614] resolved() for ‘SequentialFuture’ ... done
[10:32:50.614] Future #3
[10:32:50.614] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:32:50.615] - nx: 6
[10:32:50.615] - relay: TRUE
[10:32:50.615] - stdout: TRUE
[10:32:50.615] - signal: TRUE
[10:32:50.615] - resignal: FALSE
[10:32:50.615] - force: TRUE
[10:32:50.615] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.615] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.615]  - until=3
[10:32:50.615]  - relaying element #3
[10:32:50.615] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.616] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.616] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:32:50.616]  length: 3 (resolved future 3)
[10:32:50.616] resolved() for ‘SequentialFuture’ ...
[10:32:50.616] - state: ‘finished’
[10:32:50.616] - run: TRUE
[10:32:50.616] - result: ‘FutureResult’
[10:32:50.616] resolved() for ‘SequentialFuture’ ... done
[10:32:50.616] Future #4
[10:32:50.616] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:32:50.616] - nx: 6
[10:32:50.617] - relay: TRUE
[10:32:50.617] - stdout: TRUE
[10:32:50.617] - signal: TRUE
[10:32:50.617] - resignal: FALSE
[10:32:50.617] - force: TRUE
[10:32:50.617] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.617] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.617]  - until=4
[10:32:50.617]  - relaying element #4
[10:32:50.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.618] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:32:50.618]  length: 2 (resolved future 4)
[10:32:50.618] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.618] - nx: 6
[10:32:50.618] - relay: TRUE
[10:32:50.618] - stdout: TRUE
[10:32:50.618] - signal: TRUE
[10:32:50.618] - resignal: FALSE
[10:32:50.618] - force: TRUE
[10:32:50.618] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.618] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.618]  - until=6
[10:32:50.619]  - relaying element #6
[10:32:50.619] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.619] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.619] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.619]  length: 1 (resolved future 5)
[10:32:50.619] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.619] - nx: 6
[10:32:50.619] - relay: TRUE
[10:32:50.619] - stdout: TRUE
[10:32:50.619] - signal: TRUE
[10:32:50.619] - resignal: FALSE
[10:32:50.619] - force: TRUE
[10:32:50.620] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.620] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.620]  - until=6
[10:32:50.620] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.620] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.620] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.620]  length: 0 (resolved future 6)
[10:32:50.620] Relaying remaining futures
[10:32:50.620] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.620] - nx: 6
[10:32:50.620] - relay: TRUE
[10:32:50.620] - stdout: TRUE
[10:32:50.620] - signal: TRUE
[10:32:50.621] - resignal: FALSE
[10:32:50.621] - force: TRUE
[10:32:50.621] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.621] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:50.621] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.621] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.621] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.621] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5652cfbcc068> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[10:32:50.624] plan(): Setting new future strategy stack:
[10:32:50.624] List of future strategies:
[10:32:50.624] 1. multicore:
[10:32:50.624]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.624]    - tweaked: FALSE
[10:32:50.624]    - call: plan(strategy)
[10:32:50.628] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:32:50.628] getGlobalsAndPackages() ...
[10:32:50.628] Searching for globals...
[10:32:50.629] 
[10:32:50.629] Searching for globals ... DONE
[10:32:50.629] - globals: [0] <none>
[10:32:50.629] getGlobalsAndPackages() ... DONE
[10:32:50.629] run() for ‘Future’ ...
[10:32:50.629] - state: ‘created’
[10:32:50.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.633]   - Field: ‘label’
[10:32:50.633]   - Field: ‘local’
[10:32:50.633]   - Field: ‘owner’
[10:32:50.633]   - Field: ‘envir’
[10:32:50.634]   - Field: ‘workers’
[10:32:50.634]   - Field: ‘packages’
[10:32:50.635]   - Field: ‘gc’
[10:32:50.635]   - Field: ‘job’
[10:32:50.635]   - Field: ‘conditions’
[10:32:50.635]   - Field: ‘expr’
[10:32:50.635]   - Field: ‘uuid’
[10:32:50.635]   - Field: ‘seed’
[10:32:50.636]   - Field: ‘version’
[10:32:50.636]   - Field: ‘result’
[10:32:50.636]   - Field: ‘asynchronous’
[10:32:50.636]   - Field: ‘calls’
[10:32:50.636]   - Field: ‘globals’
[10:32:50.636]   - Field: ‘stdout’
[10:32:50.636]   - Field: ‘earlySignal’
[10:32:50.636]   - Field: ‘lazy’
[10:32:50.636]   - Field: ‘state’
[10:32:50.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.637] - Launch lazy future ...
[10:32:50.638] Packages needed by the future expression (n = 0): <none>
[10:32:50.638] Packages needed by future strategies (n = 0): <none>
[10:32:50.638] {
[10:32:50.638]     {
[10:32:50.638]         {
[10:32:50.638]             ...future.startTime <- base::Sys.time()
[10:32:50.638]             {
[10:32:50.638]                 {
[10:32:50.638]                   {
[10:32:50.638]                     {
[10:32:50.638]                       base::local({
[10:32:50.638]                         has_future <- base::requireNamespace("future", 
[10:32:50.638]                           quietly = TRUE)
[10:32:50.638]                         if (has_future) {
[10:32:50.638]                           ns <- base::getNamespace("future")
[10:32:50.638]                           version <- ns[[".package"]][["version"]]
[10:32:50.638]                           if (is.null(version)) 
[10:32:50.638]                             version <- utils::packageVersion("future")
[10:32:50.638]                         }
[10:32:50.638]                         else {
[10:32:50.638]                           version <- NULL
[10:32:50.638]                         }
[10:32:50.638]                         if (!has_future || version < "1.8.0") {
[10:32:50.638]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.638]                             "", base::R.version$version.string), 
[10:32:50.638]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.638]                               "release", "version")], collapse = " "), 
[10:32:50.638]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.638]                             info)
[10:32:50.638]                           info <- base::paste(info, collapse = "; ")
[10:32:50.638]                           if (!has_future) {
[10:32:50.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.638]                               info)
[10:32:50.638]                           }
[10:32:50.638]                           else {
[10:32:50.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.638]                               info, version)
[10:32:50.638]                           }
[10:32:50.638]                           base::stop(msg)
[10:32:50.638]                         }
[10:32:50.638]                       })
[10:32:50.638]                     }
[10:32:50.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.638]                     base::options(mc.cores = 1L)
[10:32:50.638]                   }
[10:32:50.638]                   ...future.strategy.old <- future::plan("list")
[10:32:50.638]                   options(future.plan = NULL)
[10:32:50.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.638]                 }
[10:32:50.638]                 ...future.workdir <- getwd()
[10:32:50.638]             }
[10:32:50.638]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.638]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.638]         }
[10:32:50.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.638]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.638]             base::names(...future.oldOptions))
[10:32:50.638]     }
[10:32:50.638]     if (FALSE) {
[10:32:50.638]     }
[10:32:50.638]     else {
[10:32:50.638]         if (TRUE) {
[10:32:50.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.638]                 open = "w")
[10:32:50.638]         }
[10:32:50.638]         else {
[10:32:50.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.638]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.638]         }
[10:32:50.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.638]             base::sink(type = "output", split = FALSE)
[10:32:50.638]             base::close(...future.stdout)
[10:32:50.638]         }, add = TRUE)
[10:32:50.638]     }
[10:32:50.638]     ...future.frame <- base::sys.nframe()
[10:32:50.638]     ...future.conditions <- base::list()
[10:32:50.638]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.638]     if (FALSE) {
[10:32:50.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.638]     }
[10:32:50.638]     ...future.result <- base::tryCatch({
[10:32:50.638]         base::withCallingHandlers({
[10:32:50.638]             ...future.value <- base::withVisible(base::local({
[10:32:50.638]                 withCallingHandlers({
[10:32:50.638]                   2
[10:32:50.638]                 }, immediateCondition = function(cond) {
[10:32:50.638]                   save_rds <- function (object, pathname, ...) 
[10:32:50.638]                   {
[10:32:50.638]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.638]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.638]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.638]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.638]                         fi_tmp[["mtime"]])
[10:32:50.638]                     }
[10:32:50.638]                     tryCatch({
[10:32:50.638]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.638]                     }, error = function(ex) {
[10:32:50.638]                       msg <- conditionMessage(ex)
[10:32:50.638]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.638]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.638]                         fi_tmp[["mtime"]], msg)
[10:32:50.638]                       ex$message <- msg
[10:32:50.638]                       stop(ex)
[10:32:50.638]                     })
[10:32:50.638]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.638]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.638]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.638]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.638]                       fi <- file.info(pathname)
[10:32:50.638]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.638]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.638]                         fi[["size"]], fi[["mtime"]])
[10:32:50.638]                       stop(msg)
[10:32:50.638]                     }
[10:32:50.638]                     invisible(pathname)
[10:32:50.638]                   }
[10:32:50.638]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.638]                     rootPath = tempdir()) 
[10:32:50.638]                   {
[10:32:50.638]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.638]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.638]                       tmpdir = path, fileext = ".rds")
[10:32:50.638]                     save_rds(obj, file)
[10:32:50.638]                   }
[10:32:50.638]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.638]                   {
[10:32:50.638]                     inherits <- base::inherits
[10:32:50.638]                     invokeRestart <- base::invokeRestart
[10:32:50.638]                     is.null <- base::is.null
[10:32:50.638]                     muffled <- FALSE
[10:32:50.638]                     if (inherits(cond, "message")) {
[10:32:50.638]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.638]                       if (muffled) 
[10:32:50.638]                         invokeRestart("muffleMessage")
[10:32:50.638]                     }
[10:32:50.638]                     else if (inherits(cond, "warning")) {
[10:32:50.638]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.638]                       if (muffled) 
[10:32:50.638]                         invokeRestart("muffleWarning")
[10:32:50.638]                     }
[10:32:50.638]                     else if (inherits(cond, "condition")) {
[10:32:50.638]                       if (!is.null(pattern)) {
[10:32:50.638]                         computeRestarts <- base::computeRestarts
[10:32:50.638]                         grepl <- base::grepl
[10:32:50.638]                         restarts <- computeRestarts(cond)
[10:32:50.638]                         for (restart in restarts) {
[10:32:50.638]                           name <- restart$name
[10:32:50.638]                           if (is.null(name)) 
[10:32:50.638]                             next
[10:32:50.638]                           if (!grepl(pattern, name)) 
[10:32:50.638]                             next
[10:32:50.638]                           invokeRestart(restart)
[10:32:50.638]                           muffled <- TRUE
[10:32:50.638]                           break
[10:32:50.638]                         }
[10:32:50.638]                       }
[10:32:50.638]                     }
[10:32:50.638]                     invisible(muffled)
[10:32:50.638]                   }
[10:32:50.638]                   muffleCondition(cond)
[10:32:50.638]                 })
[10:32:50.638]             }))
[10:32:50.638]             future::FutureResult(value = ...future.value$value, 
[10:32:50.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.638]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.638]                     ...future.globalenv.names))
[10:32:50.638]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.638]         }, condition = base::local({
[10:32:50.638]             c <- base::c
[10:32:50.638]             inherits <- base::inherits
[10:32:50.638]             invokeRestart <- base::invokeRestart
[10:32:50.638]             length <- base::length
[10:32:50.638]             list <- base::list
[10:32:50.638]             seq.int <- base::seq.int
[10:32:50.638]             signalCondition <- base::signalCondition
[10:32:50.638]             sys.calls <- base::sys.calls
[10:32:50.638]             `[[` <- base::`[[`
[10:32:50.638]             `+` <- base::`+`
[10:32:50.638]             `<<-` <- base::`<<-`
[10:32:50.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.638]                   3L)]
[10:32:50.638]             }
[10:32:50.638]             function(cond) {
[10:32:50.638]                 is_error <- inherits(cond, "error")
[10:32:50.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.638]                   NULL)
[10:32:50.638]                 if (is_error) {
[10:32:50.638]                   sessionInformation <- function() {
[10:32:50.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.638]                       search = base::search(), system = base::Sys.info())
[10:32:50.638]                   }
[10:32:50.638]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.638]                     cond$call), session = sessionInformation(), 
[10:32:50.638]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.638]                   signalCondition(cond)
[10:32:50.638]                 }
[10:32:50.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.638]                 "immediateCondition"))) {
[10:32:50.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.638]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.638]                   if (TRUE && !signal) {
[10:32:50.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.638]                     {
[10:32:50.638]                       inherits <- base::inherits
[10:32:50.638]                       invokeRestart <- base::invokeRestart
[10:32:50.638]                       is.null <- base::is.null
[10:32:50.638]                       muffled <- FALSE
[10:32:50.638]                       if (inherits(cond, "message")) {
[10:32:50.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.638]                         if (muffled) 
[10:32:50.638]                           invokeRestart("muffleMessage")
[10:32:50.638]                       }
[10:32:50.638]                       else if (inherits(cond, "warning")) {
[10:32:50.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.638]                         if (muffled) 
[10:32:50.638]                           invokeRestart("muffleWarning")
[10:32:50.638]                       }
[10:32:50.638]                       else if (inherits(cond, "condition")) {
[10:32:50.638]                         if (!is.null(pattern)) {
[10:32:50.638]                           computeRestarts <- base::computeRestarts
[10:32:50.638]                           grepl <- base::grepl
[10:32:50.638]                           restarts <- computeRestarts(cond)
[10:32:50.638]                           for (restart in restarts) {
[10:32:50.638]                             name <- restart$name
[10:32:50.638]                             if (is.null(name)) 
[10:32:50.638]                               next
[10:32:50.638]                             if (!grepl(pattern, name)) 
[10:32:50.638]                               next
[10:32:50.638]                             invokeRestart(restart)
[10:32:50.638]                             muffled <- TRUE
[10:32:50.638]                             break
[10:32:50.638]                           }
[10:32:50.638]                         }
[10:32:50.638]                       }
[10:32:50.638]                       invisible(muffled)
[10:32:50.638]                     }
[10:32:50.638]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.638]                   }
[10:32:50.638]                 }
[10:32:50.638]                 else {
[10:32:50.638]                   if (TRUE) {
[10:32:50.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.638]                     {
[10:32:50.638]                       inherits <- base::inherits
[10:32:50.638]                       invokeRestart <- base::invokeRestart
[10:32:50.638]                       is.null <- base::is.null
[10:32:50.638]                       muffled <- FALSE
[10:32:50.638]                       if (inherits(cond, "message")) {
[10:32:50.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.638]                         if (muffled) 
[10:32:50.638]                           invokeRestart("muffleMessage")
[10:32:50.638]                       }
[10:32:50.638]                       else if (inherits(cond, "warning")) {
[10:32:50.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.638]                         if (muffled) 
[10:32:50.638]                           invokeRestart("muffleWarning")
[10:32:50.638]                       }
[10:32:50.638]                       else if (inherits(cond, "condition")) {
[10:32:50.638]                         if (!is.null(pattern)) {
[10:32:50.638]                           computeRestarts <- base::computeRestarts
[10:32:50.638]                           grepl <- base::grepl
[10:32:50.638]                           restarts <- computeRestarts(cond)
[10:32:50.638]                           for (restart in restarts) {
[10:32:50.638]                             name <- restart$name
[10:32:50.638]                             if (is.null(name)) 
[10:32:50.638]                               next
[10:32:50.638]                             if (!grepl(pattern, name)) 
[10:32:50.638]                               next
[10:32:50.638]                             invokeRestart(restart)
[10:32:50.638]                             muffled <- TRUE
[10:32:50.638]                             break
[10:32:50.638]                           }
[10:32:50.638]                         }
[10:32:50.638]                       }
[10:32:50.638]                       invisible(muffled)
[10:32:50.638]                     }
[10:32:50.638]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.638]                   }
[10:32:50.638]                 }
[10:32:50.638]             }
[10:32:50.638]         }))
[10:32:50.638]     }, error = function(ex) {
[10:32:50.638]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.638]                 ...future.rng), started = ...future.startTime, 
[10:32:50.638]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.638]             version = "1.8"), class = "FutureResult")
[10:32:50.638]     }, finally = {
[10:32:50.638]         if (!identical(...future.workdir, getwd())) 
[10:32:50.638]             setwd(...future.workdir)
[10:32:50.638]         {
[10:32:50.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.638]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.638]             }
[10:32:50.638]             base::options(...future.oldOptions)
[10:32:50.638]             if (.Platform$OS.type == "windows") {
[10:32:50.638]                 old_names <- names(...future.oldEnvVars)
[10:32:50.638]                 envs <- base::Sys.getenv()
[10:32:50.638]                 names <- names(envs)
[10:32:50.638]                 common <- intersect(names, old_names)
[10:32:50.638]                 added <- setdiff(names, old_names)
[10:32:50.638]                 removed <- setdiff(old_names, names)
[10:32:50.638]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.638]                   envs[common]]
[10:32:50.638]                 NAMES <- toupper(changed)
[10:32:50.638]                 args <- list()
[10:32:50.638]                 for (kk in seq_along(NAMES)) {
[10:32:50.638]                   name <- changed[[kk]]
[10:32:50.638]                   NAME <- NAMES[[kk]]
[10:32:50.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.638]                     next
[10:32:50.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.638]                 }
[10:32:50.638]                 NAMES <- toupper(added)
[10:32:50.638]                 for (kk in seq_along(NAMES)) {
[10:32:50.638]                   name <- added[[kk]]
[10:32:50.638]                   NAME <- NAMES[[kk]]
[10:32:50.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.638]                     next
[10:32:50.638]                   args[[name]] <- ""
[10:32:50.638]                 }
[10:32:50.638]                 NAMES <- toupper(removed)
[10:32:50.638]                 for (kk in seq_along(NAMES)) {
[10:32:50.638]                   name <- removed[[kk]]
[10:32:50.638]                   NAME <- NAMES[[kk]]
[10:32:50.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.638]                     next
[10:32:50.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.638]                 }
[10:32:50.638]                 if (length(args) > 0) 
[10:32:50.638]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.638]             }
[10:32:50.638]             else {
[10:32:50.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.638]             }
[10:32:50.638]             {
[10:32:50.638]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.638]                   0L) {
[10:32:50.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.638]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.638]                   base::options(opts)
[10:32:50.638]                 }
[10:32:50.638]                 {
[10:32:50.638]                   {
[10:32:50.638]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.638]                     NULL
[10:32:50.638]                   }
[10:32:50.638]                   options(future.plan = NULL)
[10:32:50.638]                   if (is.na(NA_character_)) 
[10:32:50.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.638]                     .init = FALSE)
[10:32:50.638]                 }
[10:32:50.638]             }
[10:32:50.638]         }
[10:32:50.638]     })
[10:32:50.638]     if (TRUE) {
[10:32:50.638]         base::sink(type = "output", split = FALSE)
[10:32:50.638]         if (TRUE) {
[10:32:50.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.638]         }
[10:32:50.638]         else {
[10:32:50.638]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.638]         }
[10:32:50.638]         base::close(...future.stdout)
[10:32:50.638]         ...future.stdout <- NULL
[10:32:50.638]     }
[10:32:50.638]     ...future.result$conditions <- ...future.conditions
[10:32:50.638]     ...future.result$finished <- base::Sys.time()
[10:32:50.638]     ...future.result
[10:32:50.638] }
[10:32:50.640] requestCore(): workers = 2
[10:32:50.643] MulticoreFuture started
[10:32:50.644] - Launch lazy future ... done
[10:32:50.644] plan(): Setting new future strategy stack:
[10:32:50.644] run() for ‘MulticoreFuture’ ... done
[10:32:50.645] getGlobalsAndPackages() ...
[10:32:50.644] List of future strategies:
[10:32:50.644] 1. sequential:
[10:32:50.644]    - args: function (..., envir = parent.frame())
[10:32:50.644]    - tweaked: FALSE
[10:32:50.644]    - call: NULL
[10:32:50.645] Searching for globals...
[10:32:50.645] plan(): nbrOfWorkers() = 1
[10:32:50.646] 
[10:32:50.647] Searching for globals ... DONE
[10:32:50.647] - globals: [0] <none>
[10:32:50.647] getGlobalsAndPackages() ... DONE
[10:32:50.648] run() for ‘Future’ ...
[10:32:50.648] plan(): Setting new future strategy stack:
[10:32:50.648] - state: ‘created’
[10:32:50.648] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.648] List of future strategies:
[10:32:50.648] 1. multicore:
[10:32:50.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.648]    - tweaked: FALSE
[10:32:50.648]    - call: plan(strategy)
[10:32:50.653] plan(): nbrOfWorkers() = 2
[10:32:50.654] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.654]   - Field: ‘label’
[10:32:50.654]   - Field: ‘local’
[10:32:50.654]   - Field: ‘owner’
[10:32:50.655]   - Field: ‘envir’
[10:32:50.655]   - Field: ‘workers’
[10:32:50.655]   - Field: ‘packages’
[10:32:50.655]   - Field: ‘gc’
[10:32:50.655]   - Field: ‘job’
[10:32:50.655]   - Field: ‘conditions’
[10:32:50.656]   - Field: ‘expr’
[10:32:50.656]   - Field: ‘uuid’
[10:32:50.656]   - Field: ‘seed’
[10:32:50.656]   - Field: ‘version’
[10:32:50.656]   - Field: ‘result’
[10:32:50.656]   - Field: ‘asynchronous’
[10:32:50.656]   - Field: ‘calls’
[10:32:50.657]   - Field: ‘globals’
[10:32:50.657]   - Field: ‘stdout’
[10:32:50.657]   - Field: ‘earlySignal’
[10:32:50.657]   - Field: ‘lazy’
[10:32:50.657]   - Field: ‘state’
[10:32:50.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.658] - Launch lazy future ...
[10:32:50.658] Packages needed by the future expression (n = 0): <none>
[10:32:50.658] Packages needed by future strategies (n = 0): <none>
[10:32:50.659] {
[10:32:50.659]     {
[10:32:50.659]         {
[10:32:50.659]             ...future.startTime <- base::Sys.time()
[10:32:50.659]             {
[10:32:50.659]                 {
[10:32:50.659]                   {
[10:32:50.659]                     {
[10:32:50.659]                       base::local({
[10:32:50.659]                         has_future <- base::requireNamespace("future", 
[10:32:50.659]                           quietly = TRUE)
[10:32:50.659]                         if (has_future) {
[10:32:50.659]                           ns <- base::getNamespace("future")
[10:32:50.659]                           version <- ns[[".package"]][["version"]]
[10:32:50.659]                           if (is.null(version)) 
[10:32:50.659]                             version <- utils::packageVersion("future")
[10:32:50.659]                         }
[10:32:50.659]                         else {
[10:32:50.659]                           version <- NULL
[10:32:50.659]                         }
[10:32:50.659]                         if (!has_future || version < "1.8.0") {
[10:32:50.659]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.659]                             "", base::R.version$version.string), 
[10:32:50.659]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.659]                               "release", "version")], collapse = " "), 
[10:32:50.659]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.659]                             info)
[10:32:50.659]                           info <- base::paste(info, collapse = "; ")
[10:32:50.659]                           if (!has_future) {
[10:32:50.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.659]                               info)
[10:32:50.659]                           }
[10:32:50.659]                           else {
[10:32:50.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.659]                               info, version)
[10:32:50.659]                           }
[10:32:50.659]                           base::stop(msg)
[10:32:50.659]                         }
[10:32:50.659]                       })
[10:32:50.659]                     }
[10:32:50.659]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.659]                     base::options(mc.cores = 1L)
[10:32:50.659]                   }
[10:32:50.659]                   ...future.strategy.old <- future::plan("list")
[10:32:50.659]                   options(future.plan = NULL)
[10:32:50.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.659]                 }
[10:32:50.659]                 ...future.workdir <- getwd()
[10:32:50.659]             }
[10:32:50.659]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.659]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.659]         }
[10:32:50.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.659]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.659]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.659]             base::names(...future.oldOptions))
[10:32:50.659]     }
[10:32:50.659]     if (FALSE) {
[10:32:50.659]     }
[10:32:50.659]     else {
[10:32:50.659]         if (TRUE) {
[10:32:50.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.659]                 open = "w")
[10:32:50.659]         }
[10:32:50.659]         else {
[10:32:50.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.659]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.659]         }
[10:32:50.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.659]             base::sink(type = "output", split = FALSE)
[10:32:50.659]             base::close(...future.stdout)
[10:32:50.659]         }, add = TRUE)
[10:32:50.659]     }
[10:32:50.659]     ...future.frame <- base::sys.nframe()
[10:32:50.659]     ...future.conditions <- base::list()
[10:32:50.659]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.659]     if (FALSE) {
[10:32:50.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.659]     }
[10:32:50.659]     ...future.result <- base::tryCatch({
[10:32:50.659]         base::withCallingHandlers({
[10:32:50.659]             ...future.value <- base::withVisible(base::local({
[10:32:50.659]                 withCallingHandlers({
[10:32:50.659]                   NULL
[10:32:50.659]                 }, immediateCondition = function(cond) {
[10:32:50.659]                   save_rds <- function (object, pathname, ...) 
[10:32:50.659]                   {
[10:32:50.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.659]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.659]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.659]                         fi_tmp[["mtime"]])
[10:32:50.659]                     }
[10:32:50.659]                     tryCatch({
[10:32:50.659]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.659]                     }, error = function(ex) {
[10:32:50.659]                       msg <- conditionMessage(ex)
[10:32:50.659]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.659]                         fi_tmp[["mtime"]], msg)
[10:32:50.659]                       ex$message <- msg
[10:32:50.659]                       stop(ex)
[10:32:50.659]                     })
[10:32:50.659]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.659]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.659]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.659]                       fi <- file.info(pathname)
[10:32:50.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.659]                         fi[["size"]], fi[["mtime"]])
[10:32:50.659]                       stop(msg)
[10:32:50.659]                     }
[10:32:50.659]                     invisible(pathname)
[10:32:50.659]                   }
[10:32:50.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.659]                     rootPath = tempdir()) 
[10:32:50.659]                   {
[10:32:50.659]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.659]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.659]                       tmpdir = path, fileext = ".rds")
[10:32:50.659]                     save_rds(obj, file)
[10:32:50.659]                   }
[10:32:50.659]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.659]                   {
[10:32:50.659]                     inherits <- base::inherits
[10:32:50.659]                     invokeRestart <- base::invokeRestart
[10:32:50.659]                     is.null <- base::is.null
[10:32:50.659]                     muffled <- FALSE
[10:32:50.659]                     if (inherits(cond, "message")) {
[10:32:50.659]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.659]                       if (muffled) 
[10:32:50.659]                         invokeRestart("muffleMessage")
[10:32:50.659]                     }
[10:32:50.659]                     else if (inherits(cond, "warning")) {
[10:32:50.659]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.659]                       if (muffled) 
[10:32:50.659]                         invokeRestart("muffleWarning")
[10:32:50.659]                     }
[10:32:50.659]                     else if (inherits(cond, "condition")) {
[10:32:50.659]                       if (!is.null(pattern)) {
[10:32:50.659]                         computeRestarts <- base::computeRestarts
[10:32:50.659]                         grepl <- base::grepl
[10:32:50.659]                         restarts <- computeRestarts(cond)
[10:32:50.659]                         for (restart in restarts) {
[10:32:50.659]                           name <- restart$name
[10:32:50.659]                           if (is.null(name)) 
[10:32:50.659]                             next
[10:32:50.659]                           if (!grepl(pattern, name)) 
[10:32:50.659]                             next
[10:32:50.659]                           invokeRestart(restart)
[10:32:50.659]                           muffled <- TRUE
[10:32:50.659]                           break
[10:32:50.659]                         }
[10:32:50.659]                       }
[10:32:50.659]                     }
[10:32:50.659]                     invisible(muffled)
[10:32:50.659]                   }
[10:32:50.659]                   muffleCondition(cond)
[10:32:50.659]                 })
[10:32:50.659]             }))
[10:32:50.659]             future::FutureResult(value = ...future.value$value, 
[10:32:50.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.659]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.659]                     ...future.globalenv.names))
[10:32:50.659]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.659]         }, condition = base::local({
[10:32:50.659]             c <- base::c
[10:32:50.659]             inherits <- base::inherits
[10:32:50.659]             invokeRestart <- base::invokeRestart
[10:32:50.659]             length <- base::length
[10:32:50.659]             list <- base::list
[10:32:50.659]             seq.int <- base::seq.int
[10:32:50.659]             signalCondition <- base::signalCondition
[10:32:50.659]             sys.calls <- base::sys.calls
[10:32:50.659]             `[[` <- base::`[[`
[10:32:50.659]             `+` <- base::`+`
[10:32:50.659]             `<<-` <- base::`<<-`
[10:32:50.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.659]                   3L)]
[10:32:50.659]             }
[10:32:50.659]             function(cond) {
[10:32:50.659]                 is_error <- inherits(cond, "error")
[10:32:50.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.659]                   NULL)
[10:32:50.659]                 if (is_error) {
[10:32:50.659]                   sessionInformation <- function() {
[10:32:50.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.659]                       search = base::search(), system = base::Sys.info())
[10:32:50.659]                   }
[10:32:50.659]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.659]                     cond$call), session = sessionInformation(), 
[10:32:50.659]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.659]                   signalCondition(cond)
[10:32:50.659]                 }
[10:32:50.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.659]                 "immediateCondition"))) {
[10:32:50.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.659]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.659]                   if (TRUE && !signal) {
[10:32:50.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.659]                     {
[10:32:50.659]                       inherits <- base::inherits
[10:32:50.659]                       invokeRestart <- base::invokeRestart
[10:32:50.659]                       is.null <- base::is.null
[10:32:50.659]                       muffled <- FALSE
[10:32:50.659]                       if (inherits(cond, "message")) {
[10:32:50.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.659]                         if (muffled) 
[10:32:50.659]                           invokeRestart("muffleMessage")
[10:32:50.659]                       }
[10:32:50.659]                       else if (inherits(cond, "warning")) {
[10:32:50.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.659]                         if (muffled) 
[10:32:50.659]                           invokeRestart("muffleWarning")
[10:32:50.659]                       }
[10:32:50.659]                       else if (inherits(cond, "condition")) {
[10:32:50.659]                         if (!is.null(pattern)) {
[10:32:50.659]                           computeRestarts <- base::computeRestarts
[10:32:50.659]                           grepl <- base::grepl
[10:32:50.659]                           restarts <- computeRestarts(cond)
[10:32:50.659]                           for (restart in restarts) {
[10:32:50.659]                             name <- restart$name
[10:32:50.659]                             if (is.null(name)) 
[10:32:50.659]                               next
[10:32:50.659]                             if (!grepl(pattern, name)) 
[10:32:50.659]                               next
[10:32:50.659]                             invokeRestart(restart)
[10:32:50.659]                             muffled <- TRUE
[10:32:50.659]                             break
[10:32:50.659]                           }
[10:32:50.659]                         }
[10:32:50.659]                       }
[10:32:50.659]                       invisible(muffled)
[10:32:50.659]                     }
[10:32:50.659]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.659]                   }
[10:32:50.659]                 }
[10:32:50.659]                 else {
[10:32:50.659]                   if (TRUE) {
[10:32:50.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.659]                     {
[10:32:50.659]                       inherits <- base::inherits
[10:32:50.659]                       invokeRestart <- base::invokeRestart
[10:32:50.659]                       is.null <- base::is.null
[10:32:50.659]                       muffled <- FALSE
[10:32:50.659]                       if (inherits(cond, "message")) {
[10:32:50.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.659]                         if (muffled) 
[10:32:50.659]                           invokeRestart("muffleMessage")
[10:32:50.659]                       }
[10:32:50.659]                       else if (inherits(cond, "warning")) {
[10:32:50.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.659]                         if (muffled) 
[10:32:50.659]                           invokeRestart("muffleWarning")
[10:32:50.659]                       }
[10:32:50.659]                       else if (inherits(cond, "condition")) {
[10:32:50.659]                         if (!is.null(pattern)) {
[10:32:50.659]                           computeRestarts <- base::computeRestarts
[10:32:50.659]                           grepl <- base::grepl
[10:32:50.659]                           restarts <- computeRestarts(cond)
[10:32:50.659]                           for (restart in restarts) {
[10:32:50.659]                             name <- restart$name
[10:32:50.659]                             if (is.null(name)) 
[10:32:50.659]                               next
[10:32:50.659]                             if (!grepl(pattern, name)) 
[10:32:50.659]                               next
[10:32:50.659]                             invokeRestart(restart)
[10:32:50.659]                             muffled <- TRUE
[10:32:50.659]                             break
[10:32:50.659]                           }
[10:32:50.659]                         }
[10:32:50.659]                       }
[10:32:50.659]                       invisible(muffled)
[10:32:50.659]                     }
[10:32:50.659]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.659]                   }
[10:32:50.659]                 }
[10:32:50.659]             }
[10:32:50.659]         }))
[10:32:50.659]     }, error = function(ex) {
[10:32:50.659]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.659]                 ...future.rng), started = ...future.startTime, 
[10:32:50.659]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.659]             version = "1.8"), class = "FutureResult")
[10:32:50.659]     }, finally = {
[10:32:50.659]         if (!identical(...future.workdir, getwd())) 
[10:32:50.659]             setwd(...future.workdir)
[10:32:50.659]         {
[10:32:50.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.659]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.659]             }
[10:32:50.659]             base::options(...future.oldOptions)
[10:32:50.659]             if (.Platform$OS.type == "windows") {
[10:32:50.659]                 old_names <- names(...future.oldEnvVars)
[10:32:50.659]                 envs <- base::Sys.getenv()
[10:32:50.659]                 names <- names(envs)
[10:32:50.659]                 common <- intersect(names, old_names)
[10:32:50.659]                 added <- setdiff(names, old_names)
[10:32:50.659]                 removed <- setdiff(old_names, names)
[10:32:50.659]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.659]                   envs[common]]
[10:32:50.659]                 NAMES <- toupper(changed)
[10:32:50.659]                 args <- list()
[10:32:50.659]                 for (kk in seq_along(NAMES)) {
[10:32:50.659]                   name <- changed[[kk]]
[10:32:50.659]                   NAME <- NAMES[[kk]]
[10:32:50.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.659]                     next
[10:32:50.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.659]                 }
[10:32:50.659]                 NAMES <- toupper(added)
[10:32:50.659]                 for (kk in seq_along(NAMES)) {
[10:32:50.659]                   name <- added[[kk]]
[10:32:50.659]                   NAME <- NAMES[[kk]]
[10:32:50.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.659]                     next
[10:32:50.659]                   args[[name]] <- ""
[10:32:50.659]                 }
[10:32:50.659]                 NAMES <- toupper(removed)
[10:32:50.659]                 for (kk in seq_along(NAMES)) {
[10:32:50.659]                   name <- removed[[kk]]
[10:32:50.659]                   NAME <- NAMES[[kk]]
[10:32:50.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.659]                     next
[10:32:50.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.659]                 }
[10:32:50.659]                 if (length(args) > 0) 
[10:32:50.659]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.659]             }
[10:32:50.659]             else {
[10:32:50.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.659]             }
[10:32:50.659]             {
[10:32:50.659]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.659]                   0L) {
[10:32:50.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.659]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.659]                   base::options(opts)
[10:32:50.659]                 }
[10:32:50.659]                 {
[10:32:50.659]                   {
[10:32:50.659]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.659]                     NULL
[10:32:50.659]                   }
[10:32:50.659]                   options(future.plan = NULL)
[10:32:50.659]                   if (is.na(NA_character_)) 
[10:32:50.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.659]                     .init = FALSE)
[10:32:50.659]                 }
[10:32:50.659]             }
[10:32:50.659]         }
[10:32:50.659]     })
[10:32:50.659]     if (TRUE) {
[10:32:50.659]         base::sink(type = "output", split = FALSE)
[10:32:50.659]         if (TRUE) {
[10:32:50.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.659]         }
[10:32:50.659]         else {
[10:32:50.659]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.659]         }
[10:32:50.659]         base::close(...future.stdout)
[10:32:50.659]         ...future.stdout <- NULL
[10:32:50.659]     }
[10:32:50.659]     ...future.result$conditions <- ...future.conditions
[10:32:50.659]     ...future.result$finished <- base::Sys.time()
[10:32:50.659]     ...future.result
[10:32:50.659] }
[10:32:50.663] requestCore(): workers = 2
[10:32:50.669] MulticoreFuture started
[10:32:50.669] - Launch lazy future ... done
[10:32:50.669] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[10:32:50.670] plan(): Setting new future strategy stack:
[10:32:50.670] List of future strategies:
[10:32:50.670] 1. sequential:
[10:32:50.670]    - args: function (..., envir = parent.frame())
[10:32:50.670]    - tweaked: FALSE
[10:32:50.670]    - call: NULL
 num 1
 $ b:[10:32:50.671] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d13c9270> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652cf652a80> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:32:50.673] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:32:50.673] List of future strategies:
[10:32:50.673] 1. multicore:
[10:32:50.673]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.673]    - tweaked: FALSE
[10:32:50.673]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d13c9270> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652cf652a80> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:32:50.678] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.680] resolve() on list ...
[10:32:50.680]  recursive: 0
[10:32:50.680]  length: 6
[10:32:50.680]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.680] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.680] - nx: 6
[10:32:50.681] - relay: TRUE
[10:32:50.681] - stdout: TRUE
[10:32:50.681] - signal: TRUE
[10:32:50.681] - resignal: FALSE
[10:32:50.681] - force: TRUE
[10:32:50.681] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.681] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.682]  - until=2
[10:32:50.682]  - relaying element #2
[10:32:50.682] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.682] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.682] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.682]  length: 5 (resolved future 1)
[10:32:50.683] Future #2
[10:32:50.683] result() for MulticoreFuture ...
[10:32:50.685] result() for MulticoreFuture ...
[10:32:50.685] result() for MulticoreFuture ... done
[10:32:50.685] result() for MulticoreFuture ... done
[10:32:50.685] result() for MulticoreFuture ...
[10:32:50.686] result() for MulticoreFuture ... done
[10:32:50.686] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:50.686] - nx: 6
[10:32:50.686] - relay: TRUE
[10:32:50.686] - stdout: TRUE
[10:32:50.687] - signal: TRUE
[10:32:50.687] - resignal: FALSE
[10:32:50.687] - force: TRUE
[10:32:50.687] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.687] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.687]  - until=2
[10:32:50.688]  - relaying element #2
[10:32:50.688] result() for MulticoreFuture ...
[10:32:50.688] result() for MulticoreFuture ... done
[10:32:50.688] result() for MulticoreFuture ...
[10:32:50.688] result() for MulticoreFuture ... done
[10:32:50.688] result() for MulticoreFuture ...
[10:32:50.689] result() for MulticoreFuture ... done
[10:32:50.689] result() for MulticoreFuture ...
[10:32:50.689] result() for MulticoreFuture ... done
[10:32:50.689] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.689] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.689] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:50.690]  length: 4 (resolved future 2)
[10:32:50.690] Future #3
[10:32:50.690] result() for MulticoreFuture ...
[10:32:50.691] result() for MulticoreFuture ...
[10:32:50.691] result() for MulticoreFuture ... done
[10:32:50.691] result() for MulticoreFuture ... done
[10:32:50.691] result() for MulticoreFuture ...
[10:32:50.691] result() for MulticoreFuture ... done
[10:32:50.694] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:50.694] - nx: 6
[10:32:50.694] - relay: TRUE
[10:32:50.695] - stdout: TRUE
[10:32:50.695] - signal: TRUE
[10:32:50.695] - resignal: FALSE
[10:32:50.695] - force: TRUE
[10:32:50.695] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.695] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.696]  - until=3
[10:32:50.696]  - relaying element #3
[10:32:50.696] result() for MulticoreFuture ...
[10:32:50.696] result() for MulticoreFuture ... done
[10:32:50.696] result() for MulticoreFuture ...
[10:32:50.696] result() for MulticoreFuture ... done
[10:32:50.696] result() for MulticoreFuture ...
[10:32:50.697] result() for MulticoreFuture ... done
[10:32:50.697] result() for MulticoreFuture ...
[10:32:50.697] result() for MulticoreFuture ... done
[10:32:50.697] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.697] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.697] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:50.697]  length: 3 (resolved future 3)
[10:32:50.697] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.698] - nx: 6
[10:32:50.698] - relay: TRUE
[10:32:50.698] - stdout: TRUE
[10:32:50.698] - signal: TRUE
[10:32:50.698] - resignal: FALSE
[10:32:50.698] - force: TRUE
[10:32:50.698] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.698] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.698]  - until=5
[10:32:50.698]  - relaying element #5
[10:32:50.699] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.699] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.699] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.699]  length: 2 (resolved future 4)
[10:32:50.699] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.699] - nx: 6
[10:32:50.699] - relay: TRUE
[10:32:50.699] - stdout: TRUE
[10:32:50.700] - signal: TRUE
[10:32:50.700] - resignal: FALSE
[10:32:50.700] - force: TRUE
[10:32:50.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.700] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.700]  - until=6
[10:32:50.700]  - relaying element #6
[10:32:50.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.700] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.701] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.701]  length: 1 (resolved future 5)
[10:32:50.701] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.701] - nx: 6
[10:32:50.701] - relay: TRUE
[10:32:50.701] - stdout: TRUE
[10:32:50.701] - signal: TRUE
[10:32:50.701] - resignal: FALSE
[10:32:50.701] - force: TRUE
[10:32:50.702] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.702] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.702]  - until=6
[10:32:50.702] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.702] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.702] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.702]  length: 0 (resolved future 6)
[10:32:50.702] Relaying remaining futures
[10:32:50.702] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.702] - nx: 6
[10:32:50.702] - relay: TRUE
[10:32:50.703] - stdout: TRUE
[10:32:50.703] - signal: TRUE
[10:32:50.703] - resignal: FALSE
[10:32:50.703] - force: TRUE
[10:32:50.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.703] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.703] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.703] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.704] resolve() on list ... DONE
[10:32:50.704] result() for MulticoreFuture ...
[10:32:50.704] result() for MulticoreFuture ... done
[10:32:50.704] result() for MulticoreFuture ...
[10:32:50.704] result() for MulticoreFuture ... done
[10:32:50.704] result() for MulticoreFuture ...
[10:32:50.704] result() for MulticoreFuture ... done
[10:32:50.704] result() for MulticoreFuture ...
[10:32:50.704] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:32:50.707] getGlobalsAndPackages() ...
[10:32:50.707] Searching for globals...
[10:32:50.707] 
[10:32:50.707] Searching for globals ... DONE
[10:32:50.708] - globals: [0] <none>
[10:32:50.708] getGlobalsAndPackages() ... DONE
[10:32:50.708] run() for ‘Future’ ...
[10:32:50.708] - state: ‘created’
[10:32:50.708] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.712] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.712]   - Field: ‘label’
[10:32:50.712]   - Field: ‘local’
[10:32:50.712]   - Field: ‘owner’
[10:32:50.712]   - Field: ‘envir’
[10:32:50.712]   - Field: ‘workers’
[10:32:50.713]   - Field: ‘packages’
[10:32:50.713]   - Field: ‘gc’
[10:32:50.713]   - Field: ‘job’
[10:32:50.713]   - Field: ‘conditions’
[10:32:50.713]   - Field: ‘expr’
[10:32:50.713]   - Field: ‘uuid’
[10:32:50.713]   - Field: ‘seed’
[10:32:50.713]   - Field: ‘version’
[10:32:50.713]   - Field: ‘result’
[10:32:50.713]   - Field: ‘asynchronous’
[10:32:50.714]   - Field: ‘calls’
[10:32:50.714]   - Field: ‘globals’
[10:32:50.714]   - Field: ‘stdout’
[10:32:50.714]   - Field: ‘earlySignal’
[10:32:50.714]   - Field: ‘lazy’
[10:32:50.714]   - Field: ‘state’
[10:32:50.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.714] - Launch lazy future ...
[10:32:50.714] Packages needed by the future expression (n = 0): <none>
[10:32:50.715] Packages needed by future strategies (n = 0): <none>
[10:32:50.715] {
[10:32:50.715]     {
[10:32:50.715]         {
[10:32:50.715]             ...future.startTime <- base::Sys.time()
[10:32:50.715]             {
[10:32:50.715]                 {
[10:32:50.715]                   {
[10:32:50.715]                     {
[10:32:50.715]                       base::local({
[10:32:50.715]                         has_future <- base::requireNamespace("future", 
[10:32:50.715]                           quietly = TRUE)
[10:32:50.715]                         if (has_future) {
[10:32:50.715]                           ns <- base::getNamespace("future")
[10:32:50.715]                           version <- ns[[".package"]][["version"]]
[10:32:50.715]                           if (is.null(version)) 
[10:32:50.715]                             version <- utils::packageVersion("future")
[10:32:50.715]                         }
[10:32:50.715]                         else {
[10:32:50.715]                           version <- NULL
[10:32:50.715]                         }
[10:32:50.715]                         if (!has_future || version < "1.8.0") {
[10:32:50.715]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.715]                             "", base::R.version$version.string), 
[10:32:50.715]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.715]                               "release", "version")], collapse = " "), 
[10:32:50.715]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.715]                             info)
[10:32:50.715]                           info <- base::paste(info, collapse = "; ")
[10:32:50.715]                           if (!has_future) {
[10:32:50.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.715]                               info)
[10:32:50.715]                           }
[10:32:50.715]                           else {
[10:32:50.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.715]                               info, version)
[10:32:50.715]                           }
[10:32:50.715]                           base::stop(msg)
[10:32:50.715]                         }
[10:32:50.715]                       })
[10:32:50.715]                     }
[10:32:50.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.715]                     base::options(mc.cores = 1L)
[10:32:50.715]                   }
[10:32:50.715]                   ...future.strategy.old <- future::plan("list")
[10:32:50.715]                   options(future.plan = NULL)
[10:32:50.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.715]                 }
[10:32:50.715]                 ...future.workdir <- getwd()
[10:32:50.715]             }
[10:32:50.715]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.715]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.715]         }
[10:32:50.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.715]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.715]             base::names(...future.oldOptions))
[10:32:50.715]     }
[10:32:50.715]     if (FALSE) {
[10:32:50.715]     }
[10:32:50.715]     else {
[10:32:50.715]         if (TRUE) {
[10:32:50.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.715]                 open = "w")
[10:32:50.715]         }
[10:32:50.715]         else {
[10:32:50.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.715]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.715]         }
[10:32:50.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.715]             base::sink(type = "output", split = FALSE)
[10:32:50.715]             base::close(...future.stdout)
[10:32:50.715]         }, add = TRUE)
[10:32:50.715]     }
[10:32:50.715]     ...future.frame <- base::sys.nframe()
[10:32:50.715]     ...future.conditions <- base::list()
[10:32:50.715]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.715]     if (FALSE) {
[10:32:50.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.715]     }
[10:32:50.715]     ...future.result <- base::tryCatch({
[10:32:50.715]         base::withCallingHandlers({
[10:32:50.715]             ...future.value <- base::withVisible(base::local({
[10:32:50.715]                 withCallingHandlers({
[10:32:50.715]                   2
[10:32:50.715]                 }, immediateCondition = function(cond) {
[10:32:50.715]                   save_rds <- function (object, pathname, ...) 
[10:32:50.715]                   {
[10:32:50.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.715]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.715]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.715]                         fi_tmp[["mtime"]])
[10:32:50.715]                     }
[10:32:50.715]                     tryCatch({
[10:32:50.715]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.715]                     }, error = function(ex) {
[10:32:50.715]                       msg <- conditionMessage(ex)
[10:32:50.715]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.715]                         fi_tmp[["mtime"]], msg)
[10:32:50.715]                       ex$message <- msg
[10:32:50.715]                       stop(ex)
[10:32:50.715]                     })
[10:32:50.715]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.715]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.715]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.715]                       fi <- file.info(pathname)
[10:32:50.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.715]                         fi[["size"]], fi[["mtime"]])
[10:32:50.715]                       stop(msg)
[10:32:50.715]                     }
[10:32:50.715]                     invisible(pathname)
[10:32:50.715]                   }
[10:32:50.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.715]                     rootPath = tempdir()) 
[10:32:50.715]                   {
[10:32:50.715]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.715]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.715]                       tmpdir = path, fileext = ".rds")
[10:32:50.715]                     save_rds(obj, file)
[10:32:50.715]                   }
[10:32:50.715]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.715]                   {
[10:32:50.715]                     inherits <- base::inherits
[10:32:50.715]                     invokeRestart <- base::invokeRestart
[10:32:50.715]                     is.null <- base::is.null
[10:32:50.715]                     muffled <- FALSE
[10:32:50.715]                     if (inherits(cond, "message")) {
[10:32:50.715]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.715]                       if (muffled) 
[10:32:50.715]                         invokeRestart("muffleMessage")
[10:32:50.715]                     }
[10:32:50.715]                     else if (inherits(cond, "warning")) {
[10:32:50.715]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.715]                       if (muffled) 
[10:32:50.715]                         invokeRestart("muffleWarning")
[10:32:50.715]                     }
[10:32:50.715]                     else if (inherits(cond, "condition")) {
[10:32:50.715]                       if (!is.null(pattern)) {
[10:32:50.715]                         computeRestarts <- base::computeRestarts
[10:32:50.715]                         grepl <- base::grepl
[10:32:50.715]                         restarts <- computeRestarts(cond)
[10:32:50.715]                         for (restart in restarts) {
[10:32:50.715]                           name <- restart$name
[10:32:50.715]                           if (is.null(name)) 
[10:32:50.715]                             next
[10:32:50.715]                           if (!grepl(pattern, name)) 
[10:32:50.715]                             next
[10:32:50.715]                           invokeRestart(restart)
[10:32:50.715]                           muffled <- TRUE
[10:32:50.715]                           break
[10:32:50.715]                         }
[10:32:50.715]                       }
[10:32:50.715]                     }
[10:32:50.715]                     invisible(muffled)
[10:32:50.715]                   }
[10:32:50.715]                   muffleCondition(cond)
[10:32:50.715]                 })
[10:32:50.715]             }))
[10:32:50.715]             future::FutureResult(value = ...future.value$value, 
[10:32:50.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.715]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.715]                     ...future.globalenv.names))
[10:32:50.715]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.715]         }, condition = base::local({
[10:32:50.715]             c <- base::c
[10:32:50.715]             inherits <- base::inherits
[10:32:50.715]             invokeRestart <- base::invokeRestart
[10:32:50.715]             length <- base::length
[10:32:50.715]             list <- base::list
[10:32:50.715]             seq.int <- base::seq.int
[10:32:50.715]             signalCondition <- base::signalCondition
[10:32:50.715]             sys.calls <- base::sys.calls
[10:32:50.715]             `[[` <- base::`[[`
[10:32:50.715]             `+` <- base::`+`
[10:32:50.715]             `<<-` <- base::`<<-`
[10:32:50.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.715]                   3L)]
[10:32:50.715]             }
[10:32:50.715]             function(cond) {
[10:32:50.715]                 is_error <- inherits(cond, "error")
[10:32:50.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.715]                   NULL)
[10:32:50.715]                 if (is_error) {
[10:32:50.715]                   sessionInformation <- function() {
[10:32:50.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.715]                       search = base::search(), system = base::Sys.info())
[10:32:50.715]                   }
[10:32:50.715]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.715]                     cond$call), session = sessionInformation(), 
[10:32:50.715]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.715]                   signalCondition(cond)
[10:32:50.715]                 }
[10:32:50.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.715]                 "immediateCondition"))) {
[10:32:50.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.715]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.715]                   if (TRUE && !signal) {
[10:32:50.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.715]                     {
[10:32:50.715]                       inherits <- base::inherits
[10:32:50.715]                       invokeRestart <- base::invokeRestart
[10:32:50.715]                       is.null <- base::is.null
[10:32:50.715]                       muffled <- FALSE
[10:32:50.715]                       if (inherits(cond, "message")) {
[10:32:50.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.715]                         if (muffled) 
[10:32:50.715]                           invokeRestart("muffleMessage")
[10:32:50.715]                       }
[10:32:50.715]                       else if (inherits(cond, "warning")) {
[10:32:50.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.715]                         if (muffled) 
[10:32:50.715]                           invokeRestart("muffleWarning")
[10:32:50.715]                       }
[10:32:50.715]                       else if (inherits(cond, "condition")) {
[10:32:50.715]                         if (!is.null(pattern)) {
[10:32:50.715]                           computeRestarts <- base::computeRestarts
[10:32:50.715]                           grepl <- base::grepl
[10:32:50.715]                           restarts <- computeRestarts(cond)
[10:32:50.715]                           for (restart in restarts) {
[10:32:50.715]                             name <- restart$name
[10:32:50.715]                             if (is.null(name)) 
[10:32:50.715]                               next
[10:32:50.715]                             if (!grepl(pattern, name)) 
[10:32:50.715]                               next
[10:32:50.715]                             invokeRestart(restart)
[10:32:50.715]                             muffled <- TRUE
[10:32:50.715]                             break
[10:32:50.715]                           }
[10:32:50.715]                         }
[10:32:50.715]                       }
[10:32:50.715]                       invisible(muffled)
[10:32:50.715]                     }
[10:32:50.715]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.715]                   }
[10:32:50.715]                 }
[10:32:50.715]                 else {
[10:32:50.715]                   if (TRUE) {
[10:32:50.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.715]                     {
[10:32:50.715]                       inherits <- base::inherits
[10:32:50.715]                       invokeRestart <- base::invokeRestart
[10:32:50.715]                       is.null <- base::is.null
[10:32:50.715]                       muffled <- FALSE
[10:32:50.715]                       if (inherits(cond, "message")) {
[10:32:50.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.715]                         if (muffled) 
[10:32:50.715]                           invokeRestart("muffleMessage")
[10:32:50.715]                       }
[10:32:50.715]                       else if (inherits(cond, "warning")) {
[10:32:50.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.715]                         if (muffled) 
[10:32:50.715]                           invokeRestart("muffleWarning")
[10:32:50.715]                       }
[10:32:50.715]                       else if (inherits(cond, "condition")) {
[10:32:50.715]                         if (!is.null(pattern)) {
[10:32:50.715]                           computeRestarts <- base::computeRestarts
[10:32:50.715]                           grepl <- base::grepl
[10:32:50.715]                           restarts <- computeRestarts(cond)
[10:32:50.715]                           for (restart in restarts) {
[10:32:50.715]                             name <- restart$name
[10:32:50.715]                             if (is.null(name)) 
[10:32:50.715]                               next
[10:32:50.715]                             if (!grepl(pattern, name)) 
[10:32:50.715]                               next
[10:32:50.715]                             invokeRestart(restart)
[10:32:50.715]                             muffled <- TRUE
[10:32:50.715]                             break
[10:32:50.715]                           }
[10:32:50.715]                         }
[10:32:50.715]                       }
[10:32:50.715]                       invisible(muffled)
[10:32:50.715]                     }
[10:32:50.715]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.715]                   }
[10:32:50.715]                 }
[10:32:50.715]             }
[10:32:50.715]         }))
[10:32:50.715]     }, error = function(ex) {
[10:32:50.715]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.715]                 ...future.rng), started = ...future.startTime, 
[10:32:50.715]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.715]             version = "1.8"), class = "FutureResult")
[10:32:50.715]     }, finally = {
[10:32:50.715]         if (!identical(...future.workdir, getwd())) 
[10:32:50.715]             setwd(...future.workdir)
[10:32:50.715]         {
[10:32:50.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.715]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.715]             }
[10:32:50.715]             base::options(...future.oldOptions)
[10:32:50.715]             if (.Platform$OS.type == "windows") {
[10:32:50.715]                 old_names <- names(...future.oldEnvVars)
[10:32:50.715]                 envs <- base::Sys.getenv()
[10:32:50.715]                 names <- names(envs)
[10:32:50.715]                 common <- intersect(names, old_names)
[10:32:50.715]                 added <- setdiff(names, old_names)
[10:32:50.715]                 removed <- setdiff(old_names, names)
[10:32:50.715]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.715]                   envs[common]]
[10:32:50.715]                 NAMES <- toupper(changed)
[10:32:50.715]                 args <- list()
[10:32:50.715]                 for (kk in seq_along(NAMES)) {
[10:32:50.715]                   name <- changed[[kk]]
[10:32:50.715]                   NAME <- NAMES[[kk]]
[10:32:50.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.715]                     next
[10:32:50.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.715]                 }
[10:32:50.715]                 NAMES <- toupper(added)
[10:32:50.715]                 for (kk in seq_along(NAMES)) {
[10:32:50.715]                   name <- added[[kk]]
[10:32:50.715]                   NAME <- NAMES[[kk]]
[10:32:50.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.715]                     next
[10:32:50.715]                   args[[name]] <- ""
[10:32:50.715]                 }
[10:32:50.715]                 NAMES <- toupper(removed)
[10:32:50.715]                 for (kk in seq_along(NAMES)) {
[10:32:50.715]                   name <- removed[[kk]]
[10:32:50.715]                   NAME <- NAMES[[kk]]
[10:32:50.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.715]                     next
[10:32:50.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.715]                 }
[10:32:50.715]                 if (length(args) > 0) 
[10:32:50.715]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.715]             }
[10:32:50.715]             else {
[10:32:50.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.715]             }
[10:32:50.715]             {
[10:32:50.715]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.715]                   0L) {
[10:32:50.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.715]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.715]                   base::options(opts)
[10:32:50.715]                 }
[10:32:50.715]                 {
[10:32:50.715]                   {
[10:32:50.715]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.715]                     NULL
[10:32:50.715]                   }
[10:32:50.715]                   options(future.plan = NULL)
[10:32:50.715]                   if (is.na(NA_character_)) 
[10:32:50.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.715]                     .init = FALSE)
[10:32:50.715]                 }
[10:32:50.715]             }
[10:32:50.715]         }
[10:32:50.715]     })
[10:32:50.715]     if (TRUE) {
[10:32:50.715]         base::sink(type = "output", split = FALSE)
[10:32:50.715]         if (TRUE) {
[10:32:50.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.715]         }
[10:32:50.715]         else {
[10:32:50.715]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.715]         }
[10:32:50.715]         base::close(...future.stdout)
[10:32:50.715]         ...future.stdout <- NULL
[10:32:50.715]     }
[10:32:50.715]     ...future.result$conditions <- ...future.conditions
[10:32:50.715]     ...future.result$finished <- base::Sys.time()
[10:32:50.715]     ...future.result
[10:32:50.715] }
[10:32:50.717] requestCore(): workers = 2
[10:32:50.719] MulticoreFuture started
[10:32:50.719] - Launch lazy future ... done
[10:32:50.720] run() for ‘MulticoreFuture’ ... done
[10:32:50.720] getGlobalsAndPackages() ...
[10:32:50.720] Searching for globals...
[10:32:50.720] plan(): Setting new future strategy stack:
[10:32:50.721] 
[10:32:50.720] List of future strategies:
[10:32:50.720] 1. sequential:
[10:32:50.720]    - args: function (..., envir = parent.frame())
[10:32:50.720]    - tweaked: FALSE
[10:32:50.720]    - call: NULL
[10:32:50.721] Searching for globals ... DONE
[10:32:50.721] plan(): nbrOfWorkers() = 1
[10:32:50.721] - globals: [0] <none>
[10:32:50.722] getGlobalsAndPackages() ... DONE
[10:32:50.722] run() for ‘Future’ ...
[10:32:50.722] - state: ‘created’
[10:32:50.723] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.723] plan(): Setting new future strategy stack:
[10:32:50.723] List of future strategies:
[10:32:50.723] 1. multicore:
[10:32:50.723]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.723]    - tweaked: FALSE
[10:32:50.723]    - call: plan(strategy)
[10:32:50.727] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.728] plan(): nbrOfWorkers() = 2
[10:32:50.728]   - Field: ‘label’
[10:32:50.728]   - Field: ‘local’
[10:32:50.728]   - Field: ‘owner’
[10:32:50.728]   - Field: ‘envir’
[10:32:50.728]   - Field: ‘workers’
[10:32:50.729]   - Field: ‘packages’
[10:32:50.729]   - Field: ‘gc’
[10:32:50.729]   - Field: ‘job’
[10:32:50.729]   - Field: ‘conditions’
[10:32:50.729]   - Field: ‘expr’
[10:32:50.729]   - Field: ‘uuid’
[10:32:50.730]   - Field: ‘seed’
[10:32:50.730]   - Field: ‘version’
[10:32:50.730]   - Field: ‘result’
[10:32:50.730]   - Field: ‘asynchronous’
[10:32:50.730]   - Field: ‘calls’
[10:32:50.730]   - Field: ‘globals’
[10:32:50.730]   - Field: ‘stdout’
[10:32:50.731]   - Field: ‘earlySignal’
[10:32:50.731]   - Field: ‘lazy’
[10:32:50.731]   - Field: ‘state’
[10:32:50.731] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.731] - Launch lazy future ...
[10:32:50.732] Packages needed by the future expression (n = 0): <none>
[10:32:50.732] Packages needed by future strategies (n = 0): <none>
[10:32:50.733] {
[10:32:50.733]     {
[10:32:50.733]         {
[10:32:50.733]             ...future.startTime <- base::Sys.time()
[10:32:50.733]             {
[10:32:50.733]                 {
[10:32:50.733]                   {
[10:32:50.733]                     {
[10:32:50.733]                       base::local({
[10:32:50.733]                         has_future <- base::requireNamespace("future", 
[10:32:50.733]                           quietly = TRUE)
[10:32:50.733]                         if (has_future) {
[10:32:50.733]                           ns <- base::getNamespace("future")
[10:32:50.733]                           version <- ns[[".package"]][["version"]]
[10:32:50.733]                           if (is.null(version)) 
[10:32:50.733]                             version <- utils::packageVersion("future")
[10:32:50.733]                         }
[10:32:50.733]                         else {
[10:32:50.733]                           version <- NULL
[10:32:50.733]                         }
[10:32:50.733]                         if (!has_future || version < "1.8.0") {
[10:32:50.733]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.733]                             "", base::R.version$version.string), 
[10:32:50.733]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.733]                               "release", "version")], collapse = " "), 
[10:32:50.733]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.733]                             info)
[10:32:50.733]                           info <- base::paste(info, collapse = "; ")
[10:32:50.733]                           if (!has_future) {
[10:32:50.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.733]                               info)
[10:32:50.733]                           }
[10:32:50.733]                           else {
[10:32:50.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.733]                               info, version)
[10:32:50.733]                           }
[10:32:50.733]                           base::stop(msg)
[10:32:50.733]                         }
[10:32:50.733]                       })
[10:32:50.733]                     }
[10:32:50.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.733]                     base::options(mc.cores = 1L)
[10:32:50.733]                   }
[10:32:50.733]                   ...future.strategy.old <- future::plan("list")
[10:32:50.733]                   options(future.plan = NULL)
[10:32:50.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.733]                 }
[10:32:50.733]                 ...future.workdir <- getwd()
[10:32:50.733]             }
[10:32:50.733]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.733]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.733]         }
[10:32:50.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.733]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.733]             base::names(...future.oldOptions))
[10:32:50.733]     }
[10:32:50.733]     if (FALSE) {
[10:32:50.733]     }
[10:32:50.733]     else {
[10:32:50.733]         if (TRUE) {
[10:32:50.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.733]                 open = "w")
[10:32:50.733]         }
[10:32:50.733]         else {
[10:32:50.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.733]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.733]         }
[10:32:50.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.733]             base::sink(type = "output", split = FALSE)
[10:32:50.733]             base::close(...future.stdout)
[10:32:50.733]         }, add = TRUE)
[10:32:50.733]     }
[10:32:50.733]     ...future.frame <- base::sys.nframe()
[10:32:50.733]     ...future.conditions <- base::list()
[10:32:50.733]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.733]     if (FALSE) {
[10:32:50.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.733]     }
[10:32:50.733]     ...future.result <- base::tryCatch({
[10:32:50.733]         base::withCallingHandlers({
[10:32:50.733]             ...future.value <- base::withVisible(base::local({
[10:32:50.733]                 withCallingHandlers({
[10:32:50.733]                   NULL
[10:32:50.733]                 }, immediateCondition = function(cond) {
[10:32:50.733]                   save_rds <- function (object, pathname, ...) 
[10:32:50.733]                   {
[10:32:50.733]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.733]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.733]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.733]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.733]                         fi_tmp[["mtime"]])
[10:32:50.733]                     }
[10:32:50.733]                     tryCatch({
[10:32:50.733]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.733]                     }, error = function(ex) {
[10:32:50.733]                       msg <- conditionMessage(ex)
[10:32:50.733]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.733]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.733]                         fi_tmp[["mtime"]], msg)
[10:32:50.733]                       ex$message <- msg
[10:32:50.733]                       stop(ex)
[10:32:50.733]                     })
[10:32:50.733]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.733]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.733]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.733]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.733]                       fi <- file.info(pathname)
[10:32:50.733]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.733]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.733]                         fi[["size"]], fi[["mtime"]])
[10:32:50.733]                       stop(msg)
[10:32:50.733]                     }
[10:32:50.733]                     invisible(pathname)
[10:32:50.733]                   }
[10:32:50.733]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.733]                     rootPath = tempdir()) 
[10:32:50.733]                   {
[10:32:50.733]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.733]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.733]                       tmpdir = path, fileext = ".rds")
[10:32:50.733]                     save_rds(obj, file)
[10:32:50.733]                   }
[10:32:50.733]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.733]                   {
[10:32:50.733]                     inherits <- base::inherits
[10:32:50.733]                     invokeRestart <- base::invokeRestart
[10:32:50.733]                     is.null <- base::is.null
[10:32:50.733]                     muffled <- FALSE
[10:32:50.733]                     if (inherits(cond, "message")) {
[10:32:50.733]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.733]                       if (muffled) 
[10:32:50.733]                         invokeRestart("muffleMessage")
[10:32:50.733]                     }
[10:32:50.733]                     else if (inherits(cond, "warning")) {
[10:32:50.733]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.733]                       if (muffled) 
[10:32:50.733]                         invokeRestart("muffleWarning")
[10:32:50.733]                     }
[10:32:50.733]                     else if (inherits(cond, "condition")) {
[10:32:50.733]                       if (!is.null(pattern)) {
[10:32:50.733]                         computeRestarts <- base::computeRestarts
[10:32:50.733]                         grepl <- base::grepl
[10:32:50.733]                         restarts <- computeRestarts(cond)
[10:32:50.733]                         for (restart in restarts) {
[10:32:50.733]                           name <- restart$name
[10:32:50.733]                           if (is.null(name)) 
[10:32:50.733]                             next
[10:32:50.733]                           if (!grepl(pattern, name)) 
[10:32:50.733]                             next
[10:32:50.733]                           invokeRestart(restart)
[10:32:50.733]                           muffled <- TRUE
[10:32:50.733]                           break
[10:32:50.733]                         }
[10:32:50.733]                       }
[10:32:50.733]                     }
[10:32:50.733]                     invisible(muffled)
[10:32:50.733]                   }
[10:32:50.733]                   muffleCondition(cond)
[10:32:50.733]                 })
[10:32:50.733]             }))
[10:32:50.733]             future::FutureResult(value = ...future.value$value, 
[10:32:50.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.733]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.733]                     ...future.globalenv.names))
[10:32:50.733]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.733]         }, condition = base::local({
[10:32:50.733]             c <- base::c
[10:32:50.733]             inherits <- base::inherits
[10:32:50.733]             invokeRestart <- base::invokeRestart
[10:32:50.733]             length <- base::length
[10:32:50.733]             list <- base::list
[10:32:50.733]             seq.int <- base::seq.int
[10:32:50.733]             signalCondition <- base::signalCondition
[10:32:50.733]             sys.calls <- base::sys.calls
[10:32:50.733]             `[[` <- base::`[[`
[10:32:50.733]             `+` <- base::`+`
[10:32:50.733]             `<<-` <- base::`<<-`
[10:32:50.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.733]                   3L)]
[10:32:50.733]             }
[10:32:50.733]             function(cond) {
[10:32:50.733]                 is_error <- inherits(cond, "error")
[10:32:50.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.733]                   NULL)
[10:32:50.733]                 if (is_error) {
[10:32:50.733]                   sessionInformation <- function() {
[10:32:50.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.733]                       search = base::search(), system = base::Sys.info())
[10:32:50.733]                   }
[10:32:50.733]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.733]                     cond$call), session = sessionInformation(), 
[10:32:50.733]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.733]                   signalCondition(cond)
[10:32:50.733]                 }
[10:32:50.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.733]                 "immediateCondition"))) {
[10:32:50.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.733]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.733]                   if (TRUE && !signal) {
[10:32:50.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.733]                     {
[10:32:50.733]                       inherits <- base::inherits
[10:32:50.733]                       invokeRestart <- base::invokeRestart
[10:32:50.733]                       is.null <- base::is.null
[10:32:50.733]                       muffled <- FALSE
[10:32:50.733]                       if (inherits(cond, "message")) {
[10:32:50.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.733]                         if (muffled) 
[10:32:50.733]                           invokeRestart("muffleMessage")
[10:32:50.733]                       }
[10:32:50.733]                       else if (inherits(cond, "warning")) {
[10:32:50.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.733]                         if (muffled) 
[10:32:50.733]                           invokeRestart("muffleWarning")
[10:32:50.733]                       }
[10:32:50.733]                       else if (inherits(cond, "condition")) {
[10:32:50.733]                         if (!is.null(pattern)) {
[10:32:50.733]                           computeRestarts <- base::computeRestarts
[10:32:50.733]                           grepl <- base::grepl
[10:32:50.733]                           restarts <- computeRestarts(cond)
[10:32:50.733]                           for (restart in restarts) {
[10:32:50.733]                             name <- restart$name
[10:32:50.733]                             if (is.null(name)) 
[10:32:50.733]                               next
[10:32:50.733]                             if (!grepl(pattern, name)) 
[10:32:50.733]                               next
[10:32:50.733]                             invokeRestart(restart)
[10:32:50.733]                             muffled <- TRUE
[10:32:50.733]                             break
[10:32:50.733]                           }
[10:32:50.733]                         }
[10:32:50.733]                       }
[10:32:50.733]                       invisible(muffled)
[10:32:50.733]                     }
[10:32:50.733]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.733]                   }
[10:32:50.733]                 }
[10:32:50.733]                 else {
[10:32:50.733]                   if (TRUE) {
[10:32:50.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.733]                     {
[10:32:50.733]                       inherits <- base::inherits
[10:32:50.733]                       invokeRestart <- base::invokeRestart
[10:32:50.733]                       is.null <- base::is.null
[10:32:50.733]                       muffled <- FALSE
[10:32:50.733]                       if (inherits(cond, "message")) {
[10:32:50.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.733]                         if (muffled) 
[10:32:50.733]                           invokeRestart("muffleMessage")
[10:32:50.733]                       }
[10:32:50.733]                       else if (inherits(cond, "warning")) {
[10:32:50.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.733]                         if (muffled) 
[10:32:50.733]                           invokeRestart("muffleWarning")
[10:32:50.733]                       }
[10:32:50.733]                       else if (inherits(cond, "condition")) {
[10:32:50.733]                         if (!is.null(pattern)) {
[10:32:50.733]                           computeRestarts <- base::computeRestarts
[10:32:50.733]                           grepl <- base::grepl
[10:32:50.733]                           restarts <- computeRestarts(cond)
[10:32:50.733]                           for (restart in restarts) {
[10:32:50.733]                             name <- restart$name
[10:32:50.733]                             if (is.null(name)) 
[10:32:50.733]                               next
[10:32:50.733]                             if (!grepl(pattern, name)) 
[10:32:50.733]                               next
[10:32:50.733]                             invokeRestart(restart)
[10:32:50.733]                             muffled <- TRUE
[10:32:50.733]                             break
[10:32:50.733]                           }
[10:32:50.733]                         }
[10:32:50.733]                       }
[10:32:50.733]                       invisible(muffled)
[10:32:50.733]                     }
[10:32:50.733]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.733]                   }
[10:32:50.733]                 }
[10:32:50.733]             }
[10:32:50.733]         }))
[10:32:50.733]     }, error = function(ex) {
[10:32:50.733]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.733]                 ...future.rng), started = ...future.startTime, 
[10:32:50.733]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.733]             version = "1.8"), class = "FutureResult")
[10:32:50.733]     }, finally = {
[10:32:50.733]         if (!identical(...future.workdir, getwd())) 
[10:32:50.733]             setwd(...future.workdir)
[10:32:50.733]         {
[10:32:50.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.733]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.733]             }
[10:32:50.733]             base::options(...future.oldOptions)
[10:32:50.733]             if (.Platform$OS.type == "windows") {
[10:32:50.733]                 old_names <- names(...future.oldEnvVars)
[10:32:50.733]                 envs <- base::Sys.getenv()
[10:32:50.733]                 names <- names(envs)
[10:32:50.733]                 common <- intersect(names, old_names)
[10:32:50.733]                 added <- setdiff(names, old_names)
[10:32:50.733]                 removed <- setdiff(old_names, names)
[10:32:50.733]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.733]                   envs[common]]
[10:32:50.733]                 NAMES <- toupper(changed)
[10:32:50.733]                 args <- list()
[10:32:50.733]                 for (kk in seq_along(NAMES)) {
[10:32:50.733]                   name <- changed[[kk]]
[10:32:50.733]                   NAME <- NAMES[[kk]]
[10:32:50.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.733]                     next
[10:32:50.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.733]                 }
[10:32:50.733]                 NAMES <- toupper(added)
[10:32:50.733]                 for (kk in seq_along(NAMES)) {
[10:32:50.733]                   name <- added[[kk]]
[10:32:50.733]                   NAME <- NAMES[[kk]]
[10:32:50.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.733]                     next
[10:32:50.733]                   args[[name]] <- ""
[10:32:50.733]                 }
[10:32:50.733]                 NAMES <- toupper(removed)
[10:32:50.733]                 for (kk in seq_along(NAMES)) {
[10:32:50.733]                   name <- removed[[kk]]
[10:32:50.733]                   NAME <- NAMES[[kk]]
[10:32:50.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.733]                     next
[10:32:50.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.733]                 }
[10:32:50.733]                 if (length(args) > 0) 
[10:32:50.733]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.733]             }
[10:32:50.733]             else {
[10:32:50.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.733]             }
[10:32:50.733]             {
[10:32:50.733]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.733]                   0L) {
[10:32:50.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.733]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.733]                   base::options(opts)
[10:32:50.733]                 }
[10:32:50.733]                 {
[10:32:50.733]                   {
[10:32:50.733]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.733]                     NULL
[10:32:50.733]                   }
[10:32:50.733]                   options(future.plan = NULL)
[10:32:50.733]                   if (is.na(NA_character_)) 
[10:32:50.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.733]                     .init = FALSE)
[10:32:50.733]                 }
[10:32:50.733]             }
[10:32:50.733]         }
[10:32:50.733]     })
[10:32:50.733]     if (TRUE) {
[10:32:50.733]         base::sink(type = "output", split = FALSE)
[10:32:50.733]         if (TRUE) {
[10:32:50.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.733]         }
[10:32:50.733]         else {
[10:32:50.733]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.733]         }
[10:32:50.733]         base::close(...future.stdout)
[10:32:50.733]         ...future.stdout <- NULL
[10:32:50.733]     }
[10:32:50.733]     ...future.result$conditions <- ...future.conditions
[10:32:50.733]     ...future.result$finished <- base::Sys.time()
[10:32:50.733]     ...future.result
[10:32:50.733] }
[10:32:50.736] requestCore(): workers = 2
[10:32:50.738] MulticoreFuture started
[10:32:50.738] - Launch lazy future ... done
[10:32:50.743] plan(): Setting new future strategy stack:
[10:32:50.743] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[10:32:50.743] List of future strategies:
[10:32:50.743] 1. sequential:
[10:32:50.743]    - args: function (..., envir = parent.frame())
[10:32:50.743]    - tweaked: FALSE
[10:32:50.743]    - call: NULL
[10:32:50.745] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0bb7548> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1025748> 
 $  :[10:32:50.748] plan(): Setting new future strategy stack:
 NULL
 $  :[10:32:50.748] List of future strategies:
[10:32:50.748] 1. multicore:
[10:32:50.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.748]    - tweaked: FALSE
[10:32:50.748]    - call: plan(strategy)
 NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0bb7548> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1025748> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=[10:32:50.754] plan(): nbrOfWorkers() = 2
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.759] resolve() on list ...
[10:32:50.759]  recursive: 0
[10:32:50.759]  length: 6
[10:32:50.759]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.759] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.760] - nx: 6
[10:32:50.760] - relay: TRUE
[10:32:50.760] - stdout: TRUE
[10:32:50.760] - signal: TRUE
[10:32:50.760] - resignal: FALSE
[10:32:50.760] - force: TRUE
[10:32:50.760] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.760] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.761]  - until=2
[10:32:50.761]  - relaying element #2
[10:32:50.761] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.761] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.761] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.761]  length: 5 (resolved future 1)
[10:32:50.762] Future #2
[10:32:50.762] result() for MulticoreFuture ...
[10:32:50.763] result() for MulticoreFuture ...
[10:32:50.763] result() for MulticoreFuture ... done
[10:32:50.763] result() for MulticoreFuture ... done
[10:32:50.763] result() for MulticoreFuture ...
[10:32:50.763] result() for MulticoreFuture ... done
[10:32:50.763] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:50.763] - nx: 6
[10:32:50.763] - relay: TRUE
[10:32:50.764] - stdout: TRUE
[10:32:50.764] - signal: TRUE
[10:32:50.764] - resignal: FALSE
[10:32:50.764] - force: TRUE
[10:32:50.764] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.764] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.764]  - until=2
[10:32:50.764]  - relaying element #2
[10:32:50.765] result() for MulticoreFuture ...
[10:32:50.765] result() for MulticoreFuture ... done
[10:32:50.765] result() for MulticoreFuture ...
[10:32:50.765] result() for MulticoreFuture ... done
[10:32:50.765] result() for MulticoreFuture ...
[10:32:50.765] result() for MulticoreFuture ... done
[10:32:50.765] result() for MulticoreFuture ...
[10:32:50.766] result() for MulticoreFuture ... done
[10:32:50.766] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.766] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.766] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:50.766]  length: 4 (resolved future 2)
[10:32:50.766] Future #3
[10:32:50.766] result() for MulticoreFuture ...
[10:32:50.767] result() for MulticoreFuture ...
[10:32:50.767] result() for MulticoreFuture ... done
[10:32:50.767] result() for MulticoreFuture ... done
[10:32:50.768] result() for MulticoreFuture ...
[10:32:50.768] result() for MulticoreFuture ... done
[10:32:50.768] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:50.768] - nx: 6
[10:32:50.768] - relay: TRUE
[10:32:50.768] - stdout: TRUE
[10:32:50.768] - signal: TRUE
[10:32:50.769] - resignal: FALSE
[10:32:50.769] - force: TRUE
[10:32:50.769] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.769] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.769]  - until=3
[10:32:50.769]  - relaying element #3
[10:32:50.769] result() for MulticoreFuture ...
[10:32:50.770] result() for MulticoreFuture ... done
[10:32:50.770] result() for MulticoreFuture ...
[10:32:50.770] result() for MulticoreFuture ... done
[10:32:50.770] result() for MulticoreFuture ...
[10:32:50.770] result() for MulticoreFuture ... done
[10:32:50.770] result() for MulticoreFuture ...
[10:32:50.771] result() for MulticoreFuture ... done
[10:32:50.771] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.771] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.771] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:50.771]  length: 3 (resolved future 3)
[10:32:50.771] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.771] - nx: 6
[10:32:50.771] - relay: TRUE
[10:32:50.771] - stdout: TRUE
[10:32:50.772] - signal: TRUE
[10:32:50.772] - resignal: FALSE
[10:32:50.772] - force: TRUE
[10:32:50.772] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.772] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.772]  - until=5
[10:32:50.772]  - relaying element #5
[10:32:50.772] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.772] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.772] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.773]  length: 2 (resolved future 4)
[10:32:50.773] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.773] - nx: 6
[10:32:50.773] - relay: TRUE
[10:32:50.773] - stdout: TRUE
[10:32:50.773] - signal: TRUE
[10:32:50.773] - resignal: FALSE
[10:32:50.773] - force: TRUE
[10:32:50.773] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.773] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.773]  - until=6
[10:32:50.774]  - relaying element #6
[10:32:50.774] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.774] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.774] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.774]  length: 1 (resolved future 5)
[10:32:50.774] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.774] - nx: 6
[10:32:50.774] - relay: TRUE
[10:32:50.774] - stdout: TRUE
[10:32:50.774] - signal: TRUE
[10:32:50.775] - resignal: FALSE
[10:32:50.775] - force: TRUE
[10:32:50.775] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.775]  - until=6
[10:32:50.775] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.775] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.775]  length: 0 (resolved future 6)
[10:32:50.775] Relaying remaining futures
[10:32:50.775] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.776] - nx: 6
[10:32:50.776] - relay: TRUE
[10:32:50.776] - stdout: TRUE
[10:32:50.776] - signal: TRUE
[10:32:50.776] - resignal: FALSE
[10:32:50.776] - force: TRUE
[10:32:50.776] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.776] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.776] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.777] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.777] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.777] resolve() on list ... DONE
[10:32:50.777] result() for MulticoreFuture ...
[10:32:50.777] result() for MulticoreFuture ... done
[10:32:50.777] result() for MulticoreFuture ...
[10:32:50.777] result() for MulticoreFuture ... done
[10:32:50.777] result() for MulticoreFuture ...
[10:32:50.777] result() for MulticoreFuture ... done
[10:32:50.777] result() for MulticoreFuture ...
[10:32:50.778] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:32:50.783] getGlobalsAndPackages() ...
[10:32:50.783] Searching for globals...
[10:32:50.783] 
[10:32:50.783] Searching for globals ... DONE
[10:32:50.783] - globals: [0] <none>
[10:32:50.783] getGlobalsAndPackages() ... DONE
[10:32:50.784] run() for ‘Future’ ...
[10:32:50.784] - state: ‘created’
[10:32:50.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.789]   - Field: ‘label’
[10:32:50.789]   - Field: ‘local’
[10:32:50.789]   - Field: ‘owner’
[10:32:50.789]   - Field: ‘envir’
[10:32:50.789]   - Field: ‘workers’
[10:32:50.789]   - Field: ‘packages’
[10:32:50.789]   - Field: ‘gc’
[10:32:50.789]   - Field: ‘job’
[10:32:50.789]   - Field: ‘conditions’
[10:32:50.790]   - Field: ‘expr’
[10:32:50.790]   - Field: ‘uuid’
[10:32:50.790]   - Field: ‘seed’
[10:32:50.790]   - Field: ‘version’
[10:32:50.790]   - Field: ‘result’
[10:32:50.790]   - Field: ‘asynchronous’
[10:32:50.790]   - Field: ‘calls’
[10:32:50.790]   - Field: ‘globals’
[10:32:50.790]   - Field: ‘stdout’
[10:32:50.790]   - Field: ‘earlySignal’
[10:32:50.791]   - Field: ‘lazy’
[10:32:50.791]   - Field: ‘state’
[10:32:50.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.791] - Launch lazy future ...
[10:32:50.791] Packages needed by the future expression (n = 0): <none>
[10:32:50.791] Packages needed by future strategies (n = 0): <none>
[10:32:50.792] {
[10:32:50.792]     {
[10:32:50.792]         {
[10:32:50.792]             ...future.startTime <- base::Sys.time()
[10:32:50.792]             {
[10:32:50.792]                 {
[10:32:50.792]                   {
[10:32:50.792]                     {
[10:32:50.792]                       base::local({
[10:32:50.792]                         has_future <- base::requireNamespace("future", 
[10:32:50.792]                           quietly = TRUE)
[10:32:50.792]                         if (has_future) {
[10:32:50.792]                           ns <- base::getNamespace("future")
[10:32:50.792]                           version <- ns[[".package"]][["version"]]
[10:32:50.792]                           if (is.null(version)) 
[10:32:50.792]                             version <- utils::packageVersion("future")
[10:32:50.792]                         }
[10:32:50.792]                         else {
[10:32:50.792]                           version <- NULL
[10:32:50.792]                         }
[10:32:50.792]                         if (!has_future || version < "1.8.0") {
[10:32:50.792]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.792]                             "", base::R.version$version.string), 
[10:32:50.792]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.792]                               "release", "version")], collapse = " "), 
[10:32:50.792]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.792]                             info)
[10:32:50.792]                           info <- base::paste(info, collapse = "; ")
[10:32:50.792]                           if (!has_future) {
[10:32:50.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.792]                               info)
[10:32:50.792]                           }
[10:32:50.792]                           else {
[10:32:50.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.792]                               info, version)
[10:32:50.792]                           }
[10:32:50.792]                           base::stop(msg)
[10:32:50.792]                         }
[10:32:50.792]                       })
[10:32:50.792]                     }
[10:32:50.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.792]                     base::options(mc.cores = 1L)
[10:32:50.792]                   }
[10:32:50.792]                   ...future.strategy.old <- future::plan("list")
[10:32:50.792]                   options(future.plan = NULL)
[10:32:50.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.792]                 }
[10:32:50.792]                 ...future.workdir <- getwd()
[10:32:50.792]             }
[10:32:50.792]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.792]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.792]         }
[10:32:50.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.792]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.792]             base::names(...future.oldOptions))
[10:32:50.792]     }
[10:32:50.792]     if (FALSE) {
[10:32:50.792]     }
[10:32:50.792]     else {
[10:32:50.792]         if (TRUE) {
[10:32:50.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.792]                 open = "w")
[10:32:50.792]         }
[10:32:50.792]         else {
[10:32:50.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.792]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.792]         }
[10:32:50.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.792]             base::sink(type = "output", split = FALSE)
[10:32:50.792]             base::close(...future.stdout)
[10:32:50.792]         }, add = TRUE)
[10:32:50.792]     }
[10:32:50.792]     ...future.frame <- base::sys.nframe()
[10:32:50.792]     ...future.conditions <- base::list()
[10:32:50.792]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.792]     if (FALSE) {
[10:32:50.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.792]     }
[10:32:50.792]     ...future.result <- base::tryCatch({
[10:32:50.792]         base::withCallingHandlers({
[10:32:50.792]             ...future.value <- base::withVisible(base::local({
[10:32:50.792]                 withCallingHandlers({
[10:32:50.792]                   2
[10:32:50.792]                 }, immediateCondition = function(cond) {
[10:32:50.792]                   save_rds <- function (object, pathname, ...) 
[10:32:50.792]                   {
[10:32:50.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.792]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.792]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.792]                         fi_tmp[["mtime"]])
[10:32:50.792]                     }
[10:32:50.792]                     tryCatch({
[10:32:50.792]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.792]                     }, error = function(ex) {
[10:32:50.792]                       msg <- conditionMessage(ex)
[10:32:50.792]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.792]                         fi_tmp[["mtime"]], msg)
[10:32:50.792]                       ex$message <- msg
[10:32:50.792]                       stop(ex)
[10:32:50.792]                     })
[10:32:50.792]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.792]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.792]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.792]                       fi <- file.info(pathname)
[10:32:50.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.792]                         fi[["size"]], fi[["mtime"]])
[10:32:50.792]                       stop(msg)
[10:32:50.792]                     }
[10:32:50.792]                     invisible(pathname)
[10:32:50.792]                   }
[10:32:50.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.792]                     rootPath = tempdir()) 
[10:32:50.792]                   {
[10:32:50.792]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.792]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.792]                       tmpdir = path, fileext = ".rds")
[10:32:50.792]                     save_rds(obj, file)
[10:32:50.792]                   }
[10:32:50.792]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.792]                   {
[10:32:50.792]                     inherits <- base::inherits
[10:32:50.792]                     invokeRestart <- base::invokeRestart
[10:32:50.792]                     is.null <- base::is.null
[10:32:50.792]                     muffled <- FALSE
[10:32:50.792]                     if (inherits(cond, "message")) {
[10:32:50.792]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.792]                       if (muffled) 
[10:32:50.792]                         invokeRestart("muffleMessage")
[10:32:50.792]                     }
[10:32:50.792]                     else if (inherits(cond, "warning")) {
[10:32:50.792]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.792]                       if (muffled) 
[10:32:50.792]                         invokeRestart("muffleWarning")
[10:32:50.792]                     }
[10:32:50.792]                     else if (inherits(cond, "condition")) {
[10:32:50.792]                       if (!is.null(pattern)) {
[10:32:50.792]                         computeRestarts <- base::computeRestarts
[10:32:50.792]                         grepl <- base::grepl
[10:32:50.792]                         restarts <- computeRestarts(cond)
[10:32:50.792]                         for (restart in restarts) {
[10:32:50.792]                           name <- restart$name
[10:32:50.792]                           if (is.null(name)) 
[10:32:50.792]                             next
[10:32:50.792]                           if (!grepl(pattern, name)) 
[10:32:50.792]                             next
[10:32:50.792]                           invokeRestart(restart)
[10:32:50.792]                           muffled <- TRUE
[10:32:50.792]                           break
[10:32:50.792]                         }
[10:32:50.792]                       }
[10:32:50.792]                     }
[10:32:50.792]                     invisible(muffled)
[10:32:50.792]                   }
[10:32:50.792]                   muffleCondition(cond)
[10:32:50.792]                 })
[10:32:50.792]             }))
[10:32:50.792]             future::FutureResult(value = ...future.value$value, 
[10:32:50.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.792]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.792]                     ...future.globalenv.names))
[10:32:50.792]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.792]         }, condition = base::local({
[10:32:50.792]             c <- base::c
[10:32:50.792]             inherits <- base::inherits
[10:32:50.792]             invokeRestart <- base::invokeRestart
[10:32:50.792]             length <- base::length
[10:32:50.792]             list <- base::list
[10:32:50.792]             seq.int <- base::seq.int
[10:32:50.792]             signalCondition <- base::signalCondition
[10:32:50.792]             sys.calls <- base::sys.calls
[10:32:50.792]             `[[` <- base::`[[`
[10:32:50.792]             `+` <- base::`+`
[10:32:50.792]             `<<-` <- base::`<<-`
[10:32:50.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.792]                   3L)]
[10:32:50.792]             }
[10:32:50.792]             function(cond) {
[10:32:50.792]                 is_error <- inherits(cond, "error")
[10:32:50.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.792]                   NULL)
[10:32:50.792]                 if (is_error) {
[10:32:50.792]                   sessionInformation <- function() {
[10:32:50.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.792]                       search = base::search(), system = base::Sys.info())
[10:32:50.792]                   }
[10:32:50.792]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.792]                     cond$call), session = sessionInformation(), 
[10:32:50.792]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.792]                   signalCondition(cond)
[10:32:50.792]                 }
[10:32:50.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.792]                 "immediateCondition"))) {
[10:32:50.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.792]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.792]                   if (TRUE && !signal) {
[10:32:50.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.792]                     {
[10:32:50.792]                       inherits <- base::inherits
[10:32:50.792]                       invokeRestart <- base::invokeRestart
[10:32:50.792]                       is.null <- base::is.null
[10:32:50.792]                       muffled <- FALSE
[10:32:50.792]                       if (inherits(cond, "message")) {
[10:32:50.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.792]                         if (muffled) 
[10:32:50.792]                           invokeRestart("muffleMessage")
[10:32:50.792]                       }
[10:32:50.792]                       else if (inherits(cond, "warning")) {
[10:32:50.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.792]                         if (muffled) 
[10:32:50.792]                           invokeRestart("muffleWarning")
[10:32:50.792]                       }
[10:32:50.792]                       else if (inherits(cond, "condition")) {
[10:32:50.792]                         if (!is.null(pattern)) {
[10:32:50.792]                           computeRestarts <- base::computeRestarts
[10:32:50.792]                           grepl <- base::grepl
[10:32:50.792]                           restarts <- computeRestarts(cond)
[10:32:50.792]                           for (restart in restarts) {
[10:32:50.792]                             name <- restart$name
[10:32:50.792]                             if (is.null(name)) 
[10:32:50.792]                               next
[10:32:50.792]                             if (!grepl(pattern, name)) 
[10:32:50.792]                               next
[10:32:50.792]                             invokeRestart(restart)
[10:32:50.792]                             muffled <- TRUE
[10:32:50.792]                             break
[10:32:50.792]                           }
[10:32:50.792]                         }
[10:32:50.792]                       }
[10:32:50.792]                       invisible(muffled)
[10:32:50.792]                     }
[10:32:50.792]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.792]                   }
[10:32:50.792]                 }
[10:32:50.792]                 else {
[10:32:50.792]                   if (TRUE) {
[10:32:50.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.792]                     {
[10:32:50.792]                       inherits <- base::inherits
[10:32:50.792]                       invokeRestart <- base::invokeRestart
[10:32:50.792]                       is.null <- base::is.null
[10:32:50.792]                       muffled <- FALSE
[10:32:50.792]                       if (inherits(cond, "message")) {
[10:32:50.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.792]                         if (muffled) 
[10:32:50.792]                           invokeRestart("muffleMessage")
[10:32:50.792]                       }
[10:32:50.792]                       else if (inherits(cond, "warning")) {
[10:32:50.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.792]                         if (muffled) 
[10:32:50.792]                           invokeRestart("muffleWarning")
[10:32:50.792]                       }
[10:32:50.792]                       else if (inherits(cond, "condition")) {
[10:32:50.792]                         if (!is.null(pattern)) {
[10:32:50.792]                           computeRestarts <- base::computeRestarts
[10:32:50.792]                           grepl <- base::grepl
[10:32:50.792]                           restarts <- computeRestarts(cond)
[10:32:50.792]                           for (restart in restarts) {
[10:32:50.792]                             name <- restart$name
[10:32:50.792]                             if (is.null(name)) 
[10:32:50.792]                               next
[10:32:50.792]                             if (!grepl(pattern, name)) 
[10:32:50.792]                               next
[10:32:50.792]                             invokeRestart(restart)
[10:32:50.792]                             muffled <- TRUE
[10:32:50.792]                             break
[10:32:50.792]                           }
[10:32:50.792]                         }
[10:32:50.792]                       }
[10:32:50.792]                       invisible(muffled)
[10:32:50.792]                     }
[10:32:50.792]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.792]                   }
[10:32:50.792]                 }
[10:32:50.792]             }
[10:32:50.792]         }))
[10:32:50.792]     }, error = function(ex) {
[10:32:50.792]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.792]                 ...future.rng), started = ...future.startTime, 
[10:32:50.792]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.792]             version = "1.8"), class = "FutureResult")
[10:32:50.792]     }, finally = {
[10:32:50.792]         if (!identical(...future.workdir, getwd())) 
[10:32:50.792]             setwd(...future.workdir)
[10:32:50.792]         {
[10:32:50.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.792]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.792]             }
[10:32:50.792]             base::options(...future.oldOptions)
[10:32:50.792]             if (.Platform$OS.type == "windows") {
[10:32:50.792]                 old_names <- names(...future.oldEnvVars)
[10:32:50.792]                 envs <- base::Sys.getenv()
[10:32:50.792]                 names <- names(envs)
[10:32:50.792]                 common <- intersect(names, old_names)
[10:32:50.792]                 added <- setdiff(names, old_names)
[10:32:50.792]                 removed <- setdiff(old_names, names)
[10:32:50.792]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.792]                   envs[common]]
[10:32:50.792]                 NAMES <- toupper(changed)
[10:32:50.792]                 args <- list()
[10:32:50.792]                 for (kk in seq_along(NAMES)) {
[10:32:50.792]                   name <- changed[[kk]]
[10:32:50.792]                   NAME <- NAMES[[kk]]
[10:32:50.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.792]                     next
[10:32:50.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.792]                 }
[10:32:50.792]                 NAMES <- toupper(added)
[10:32:50.792]                 for (kk in seq_along(NAMES)) {
[10:32:50.792]                   name <- added[[kk]]
[10:32:50.792]                   NAME <- NAMES[[kk]]
[10:32:50.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.792]                     next
[10:32:50.792]                   args[[name]] <- ""
[10:32:50.792]                 }
[10:32:50.792]                 NAMES <- toupper(removed)
[10:32:50.792]                 for (kk in seq_along(NAMES)) {
[10:32:50.792]                   name <- removed[[kk]]
[10:32:50.792]                   NAME <- NAMES[[kk]]
[10:32:50.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.792]                     next
[10:32:50.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.792]                 }
[10:32:50.792]                 if (length(args) > 0) 
[10:32:50.792]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.792]             }
[10:32:50.792]             else {
[10:32:50.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.792]             }
[10:32:50.792]             {
[10:32:50.792]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.792]                   0L) {
[10:32:50.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.792]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.792]                   base::options(opts)
[10:32:50.792]                 }
[10:32:50.792]                 {
[10:32:50.792]                   {
[10:32:50.792]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.792]                     NULL
[10:32:50.792]                   }
[10:32:50.792]                   options(future.plan = NULL)
[10:32:50.792]                   if (is.na(NA_character_)) 
[10:32:50.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.792]                     .init = FALSE)
[10:32:50.792]                 }
[10:32:50.792]             }
[10:32:50.792]         }
[10:32:50.792]     })
[10:32:50.792]     if (TRUE) {
[10:32:50.792]         base::sink(type = "output", split = FALSE)
[10:32:50.792]         if (TRUE) {
[10:32:50.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.792]         }
[10:32:50.792]         else {
[10:32:50.792]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.792]         }
[10:32:50.792]         base::close(...future.stdout)
[10:32:50.792]         ...future.stdout <- NULL
[10:32:50.792]     }
[10:32:50.792]     ...future.result$conditions <- ...future.conditions
[10:32:50.792]     ...future.result$finished <- base::Sys.time()
[10:32:50.792]     ...future.result
[10:32:50.792] }
[10:32:50.794] requestCore(): workers = 2
[10:32:50.796] MulticoreFuture started
[10:32:50.796] - Launch lazy future ... done
[10:32:50.796] run() for ‘MulticoreFuture’ ... done
[10:32:50.797] getGlobalsAndPackages() ...
[10:32:50.797] Searching for globals...
[10:32:50.797] plan(): Setting new future strategy stack:
[10:32:50.798] 
[10:32:50.798] Searching for globals ... DONE
[10:32:50.798] List of future strategies:
[10:32:50.798] 1. sequential:
[10:32:50.798]    - args: function (..., envir = parent.frame())
[10:32:50.798]    - tweaked: FALSE
[10:32:50.798]    - call: NULL
[10:32:50.798] - globals: [0] <none>
[10:32:50.798] plan(): nbrOfWorkers() = 1
[10:32:50.798] getGlobalsAndPackages() ... DONE
[10:32:50.799] run() for ‘Future’ ...
[10:32:50.799] - state: ‘created’
[10:32:50.800] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.800] plan(): Setting new future strategy stack:
[10:32:50.801] List of future strategies:
[10:32:50.801] 1. multicore:
[10:32:50.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.801]    - tweaked: FALSE
[10:32:50.801]    - call: plan(strategy)
[10:32:50.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.805] plan(): nbrOfWorkers() = 2
[10:32:50.805]   - Field: ‘label’
[10:32:50.805]   - Field: ‘local’
[10:32:50.805]   - Field: ‘owner’
[10:32:50.805]   - Field: ‘envir’
[10:32:50.806]   - Field: ‘workers’
[10:32:50.806]   - Field: ‘packages’
[10:32:50.806]   - Field: ‘gc’
[10:32:50.806]   - Field: ‘job’
[10:32:50.806]   - Field: ‘conditions’
[10:32:50.806]   - Field: ‘expr’
[10:32:50.807]   - Field: ‘uuid’
[10:32:50.807]   - Field: ‘seed’
[10:32:50.807]   - Field: ‘version’
[10:32:50.807]   - Field: ‘result’
[10:32:50.807]   - Field: ‘asynchronous’
[10:32:50.807]   - Field: ‘calls’
[10:32:50.808]   - Field: ‘globals’
[10:32:50.808]   - Field: ‘stdout’
[10:32:50.808]   - Field: ‘earlySignal’
[10:32:50.808]   - Field: ‘lazy’
[10:32:50.808]   - Field: ‘state’
[10:32:50.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.808] - Launch lazy future ...
[10:32:50.809] Packages needed by the future expression (n = 0): <none>
[10:32:50.809] Packages needed by future strategies (n = 0): <none>
[10:32:50.810] {
[10:32:50.810]     {
[10:32:50.810]         {
[10:32:50.810]             ...future.startTime <- base::Sys.time()
[10:32:50.810]             {
[10:32:50.810]                 {
[10:32:50.810]                   {
[10:32:50.810]                     {
[10:32:50.810]                       base::local({
[10:32:50.810]                         has_future <- base::requireNamespace("future", 
[10:32:50.810]                           quietly = TRUE)
[10:32:50.810]                         if (has_future) {
[10:32:50.810]                           ns <- base::getNamespace("future")
[10:32:50.810]                           version <- ns[[".package"]][["version"]]
[10:32:50.810]                           if (is.null(version)) 
[10:32:50.810]                             version <- utils::packageVersion("future")
[10:32:50.810]                         }
[10:32:50.810]                         else {
[10:32:50.810]                           version <- NULL
[10:32:50.810]                         }
[10:32:50.810]                         if (!has_future || version < "1.8.0") {
[10:32:50.810]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.810]                             "", base::R.version$version.string), 
[10:32:50.810]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.810]                               "release", "version")], collapse = " "), 
[10:32:50.810]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.810]                             info)
[10:32:50.810]                           info <- base::paste(info, collapse = "; ")
[10:32:50.810]                           if (!has_future) {
[10:32:50.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.810]                               info)
[10:32:50.810]                           }
[10:32:50.810]                           else {
[10:32:50.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.810]                               info, version)
[10:32:50.810]                           }
[10:32:50.810]                           base::stop(msg)
[10:32:50.810]                         }
[10:32:50.810]                       })
[10:32:50.810]                     }
[10:32:50.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.810]                     base::options(mc.cores = 1L)
[10:32:50.810]                   }
[10:32:50.810]                   ...future.strategy.old <- future::plan("list")
[10:32:50.810]                   options(future.plan = NULL)
[10:32:50.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.810]                 }
[10:32:50.810]                 ...future.workdir <- getwd()
[10:32:50.810]             }
[10:32:50.810]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.810]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.810]         }
[10:32:50.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.810]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.810]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.810]             base::names(...future.oldOptions))
[10:32:50.810]     }
[10:32:50.810]     if (FALSE) {
[10:32:50.810]     }
[10:32:50.810]     else {
[10:32:50.810]         if (TRUE) {
[10:32:50.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.810]                 open = "w")
[10:32:50.810]         }
[10:32:50.810]         else {
[10:32:50.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.810]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.810]         }
[10:32:50.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.810]             base::sink(type = "output", split = FALSE)
[10:32:50.810]             base::close(...future.stdout)
[10:32:50.810]         }, add = TRUE)
[10:32:50.810]     }
[10:32:50.810]     ...future.frame <- base::sys.nframe()
[10:32:50.810]     ...future.conditions <- base::list()
[10:32:50.810]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.810]     if (FALSE) {
[10:32:50.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.810]     }
[10:32:50.810]     ...future.result <- base::tryCatch({
[10:32:50.810]         base::withCallingHandlers({
[10:32:50.810]             ...future.value <- base::withVisible(base::local({
[10:32:50.810]                 withCallingHandlers({
[10:32:50.810]                   NULL
[10:32:50.810]                 }, immediateCondition = function(cond) {
[10:32:50.810]                   save_rds <- function (object, pathname, ...) 
[10:32:50.810]                   {
[10:32:50.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.810]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.810]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.810]                         fi_tmp[["mtime"]])
[10:32:50.810]                     }
[10:32:50.810]                     tryCatch({
[10:32:50.810]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.810]                     }, error = function(ex) {
[10:32:50.810]                       msg <- conditionMessage(ex)
[10:32:50.810]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.810]                         fi_tmp[["mtime"]], msg)
[10:32:50.810]                       ex$message <- msg
[10:32:50.810]                       stop(ex)
[10:32:50.810]                     })
[10:32:50.810]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.810]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.810]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.810]                       fi <- file.info(pathname)
[10:32:50.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.810]                         fi[["size"]], fi[["mtime"]])
[10:32:50.810]                       stop(msg)
[10:32:50.810]                     }
[10:32:50.810]                     invisible(pathname)
[10:32:50.810]                   }
[10:32:50.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.810]                     rootPath = tempdir()) 
[10:32:50.810]                   {
[10:32:50.810]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.810]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.810]                       tmpdir = path, fileext = ".rds")
[10:32:50.810]                     save_rds(obj, file)
[10:32:50.810]                   }
[10:32:50.810]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.810]                   {
[10:32:50.810]                     inherits <- base::inherits
[10:32:50.810]                     invokeRestart <- base::invokeRestart
[10:32:50.810]                     is.null <- base::is.null
[10:32:50.810]                     muffled <- FALSE
[10:32:50.810]                     if (inherits(cond, "message")) {
[10:32:50.810]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.810]                       if (muffled) 
[10:32:50.810]                         invokeRestart("muffleMessage")
[10:32:50.810]                     }
[10:32:50.810]                     else if (inherits(cond, "warning")) {
[10:32:50.810]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.810]                       if (muffled) 
[10:32:50.810]                         invokeRestart("muffleWarning")
[10:32:50.810]                     }
[10:32:50.810]                     else if (inherits(cond, "condition")) {
[10:32:50.810]                       if (!is.null(pattern)) {
[10:32:50.810]                         computeRestarts <- base::computeRestarts
[10:32:50.810]                         grepl <- base::grepl
[10:32:50.810]                         restarts <- computeRestarts(cond)
[10:32:50.810]                         for (restart in restarts) {
[10:32:50.810]                           name <- restart$name
[10:32:50.810]                           if (is.null(name)) 
[10:32:50.810]                             next
[10:32:50.810]                           if (!grepl(pattern, name)) 
[10:32:50.810]                             next
[10:32:50.810]                           invokeRestart(restart)
[10:32:50.810]                           muffled <- TRUE
[10:32:50.810]                           break
[10:32:50.810]                         }
[10:32:50.810]                       }
[10:32:50.810]                     }
[10:32:50.810]                     invisible(muffled)
[10:32:50.810]                   }
[10:32:50.810]                   muffleCondition(cond)
[10:32:50.810]                 })
[10:32:50.810]             }))
[10:32:50.810]             future::FutureResult(value = ...future.value$value, 
[10:32:50.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.810]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.810]                     ...future.globalenv.names))
[10:32:50.810]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.810]         }, condition = base::local({
[10:32:50.810]             c <- base::c
[10:32:50.810]             inherits <- base::inherits
[10:32:50.810]             invokeRestart <- base::invokeRestart
[10:32:50.810]             length <- base::length
[10:32:50.810]             list <- base::list
[10:32:50.810]             seq.int <- base::seq.int
[10:32:50.810]             signalCondition <- base::signalCondition
[10:32:50.810]             sys.calls <- base::sys.calls
[10:32:50.810]             `[[` <- base::`[[`
[10:32:50.810]             `+` <- base::`+`
[10:32:50.810]             `<<-` <- base::`<<-`
[10:32:50.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.810]                   3L)]
[10:32:50.810]             }
[10:32:50.810]             function(cond) {
[10:32:50.810]                 is_error <- inherits(cond, "error")
[10:32:50.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.810]                   NULL)
[10:32:50.810]                 if (is_error) {
[10:32:50.810]                   sessionInformation <- function() {
[10:32:50.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.810]                       search = base::search(), system = base::Sys.info())
[10:32:50.810]                   }
[10:32:50.810]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.810]                     cond$call), session = sessionInformation(), 
[10:32:50.810]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.810]                   signalCondition(cond)
[10:32:50.810]                 }
[10:32:50.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.810]                 "immediateCondition"))) {
[10:32:50.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.810]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.810]                   if (TRUE && !signal) {
[10:32:50.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.810]                     {
[10:32:50.810]                       inherits <- base::inherits
[10:32:50.810]                       invokeRestart <- base::invokeRestart
[10:32:50.810]                       is.null <- base::is.null
[10:32:50.810]                       muffled <- FALSE
[10:32:50.810]                       if (inherits(cond, "message")) {
[10:32:50.810]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.810]                         if (muffled) 
[10:32:50.810]                           invokeRestart("muffleMessage")
[10:32:50.810]                       }
[10:32:50.810]                       else if (inherits(cond, "warning")) {
[10:32:50.810]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.810]                         if (muffled) 
[10:32:50.810]                           invokeRestart("muffleWarning")
[10:32:50.810]                       }
[10:32:50.810]                       else if (inherits(cond, "condition")) {
[10:32:50.810]                         if (!is.null(pattern)) {
[10:32:50.810]                           computeRestarts <- base::computeRestarts
[10:32:50.810]                           grepl <- base::grepl
[10:32:50.810]                           restarts <- computeRestarts(cond)
[10:32:50.810]                           for (restart in restarts) {
[10:32:50.810]                             name <- restart$name
[10:32:50.810]                             if (is.null(name)) 
[10:32:50.810]                               next
[10:32:50.810]                             if (!grepl(pattern, name)) 
[10:32:50.810]                               next
[10:32:50.810]                             invokeRestart(restart)
[10:32:50.810]                             muffled <- TRUE
[10:32:50.810]                             break
[10:32:50.810]                           }
[10:32:50.810]                         }
[10:32:50.810]                       }
[10:32:50.810]                       invisible(muffled)
[10:32:50.810]                     }
[10:32:50.810]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.810]                   }
[10:32:50.810]                 }
[10:32:50.810]                 else {
[10:32:50.810]                   if (TRUE) {
[10:32:50.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.810]                     {
[10:32:50.810]                       inherits <- base::inherits
[10:32:50.810]                       invokeRestart <- base::invokeRestart
[10:32:50.810]                       is.null <- base::is.null
[10:32:50.810]                       muffled <- FALSE
[10:32:50.810]                       if (inherits(cond, "message")) {
[10:32:50.810]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.810]                         if (muffled) 
[10:32:50.810]                           invokeRestart("muffleMessage")
[10:32:50.810]                       }
[10:32:50.810]                       else if (inherits(cond, "warning")) {
[10:32:50.810]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.810]                         if (muffled) 
[10:32:50.810]                           invokeRestart("muffleWarning")
[10:32:50.810]                       }
[10:32:50.810]                       else if (inherits(cond, "condition")) {
[10:32:50.810]                         if (!is.null(pattern)) {
[10:32:50.810]                           computeRestarts <- base::computeRestarts
[10:32:50.810]                           grepl <- base::grepl
[10:32:50.810]                           restarts <- computeRestarts(cond)
[10:32:50.810]                           for (restart in restarts) {
[10:32:50.810]                             name <- restart$name
[10:32:50.810]                             if (is.null(name)) 
[10:32:50.810]                               next
[10:32:50.810]                             if (!grepl(pattern, name)) 
[10:32:50.810]                               next
[10:32:50.810]                             invokeRestart(restart)
[10:32:50.810]                             muffled <- TRUE
[10:32:50.810]                             break
[10:32:50.810]                           }
[10:32:50.810]                         }
[10:32:50.810]                       }
[10:32:50.810]                       invisible(muffled)
[10:32:50.810]                     }
[10:32:50.810]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.810]                   }
[10:32:50.810]                 }
[10:32:50.810]             }
[10:32:50.810]         }))
[10:32:50.810]     }, error = function(ex) {
[10:32:50.810]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.810]                 ...future.rng), started = ...future.startTime, 
[10:32:50.810]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.810]             version = "1.8"), class = "FutureResult")
[10:32:50.810]     }, finally = {
[10:32:50.810]         if (!identical(...future.workdir, getwd())) 
[10:32:50.810]             setwd(...future.workdir)
[10:32:50.810]         {
[10:32:50.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.810]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.810]             }
[10:32:50.810]             base::options(...future.oldOptions)
[10:32:50.810]             if (.Platform$OS.type == "windows") {
[10:32:50.810]                 old_names <- names(...future.oldEnvVars)
[10:32:50.810]                 envs <- base::Sys.getenv()
[10:32:50.810]                 names <- names(envs)
[10:32:50.810]                 common <- intersect(names, old_names)
[10:32:50.810]                 added <- setdiff(names, old_names)
[10:32:50.810]                 removed <- setdiff(old_names, names)
[10:32:50.810]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.810]                   envs[common]]
[10:32:50.810]                 NAMES <- toupper(changed)
[10:32:50.810]                 args <- list()
[10:32:50.810]                 for (kk in seq_along(NAMES)) {
[10:32:50.810]                   name <- changed[[kk]]
[10:32:50.810]                   NAME <- NAMES[[kk]]
[10:32:50.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.810]                     next
[10:32:50.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.810]                 }
[10:32:50.810]                 NAMES <- toupper(added)
[10:32:50.810]                 for (kk in seq_along(NAMES)) {
[10:32:50.810]                   name <- added[[kk]]
[10:32:50.810]                   NAME <- NAMES[[kk]]
[10:32:50.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.810]                     next
[10:32:50.810]                   args[[name]] <- ""
[10:32:50.810]                 }
[10:32:50.810]                 NAMES <- toupper(removed)
[10:32:50.810]                 for (kk in seq_along(NAMES)) {
[10:32:50.810]                   name <- removed[[kk]]
[10:32:50.810]                   NAME <- NAMES[[kk]]
[10:32:50.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.810]                     next
[10:32:50.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.810]                 }
[10:32:50.810]                 if (length(args) > 0) 
[10:32:50.810]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.810]             }
[10:32:50.810]             else {
[10:32:50.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.810]             }
[10:32:50.810]             {
[10:32:50.810]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.810]                   0L) {
[10:32:50.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.810]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.810]                   base::options(opts)
[10:32:50.810]                 }
[10:32:50.810]                 {
[10:32:50.810]                   {
[10:32:50.810]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.810]                     NULL
[10:32:50.810]                   }
[10:32:50.810]                   options(future.plan = NULL)
[10:32:50.810]                   if (is.na(NA_character_)) 
[10:32:50.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.810]                     .init = FALSE)
[10:32:50.810]                 }
[10:32:50.810]             }
[10:32:50.810]         }
[10:32:50.810]     })
[10:32:50.810]     if (TRUE) {
[10:32:50.810]         base::sink(type = "output", split = FALSE)
[10:32:50.810]         if (TRUE) {
[10:32:50.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.810]         }
[10:32:50.810]         else {
[10:32:50.810]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.810]         }
[10:32:50.810]         base::close(...future.stdout)
[10:32:50.810]         ...future.stdout <- NULL
[10:32:50.810]     }
[10:32:50.810]     ...future.result$conditions <- ...future.conditions
[10:32:50.810]     ...future.result$finished <- base::Sys.time()
[10:32:50.810]     ...future.result
[10:32:50.810] }
[10:32:50.813] requestCore(): workers = 2
[10:32:50.815] MulticoreFuture started
[10:32:50.816] - Launch lazy future ... done
[10:32:50.816] run() for ‘MulticoreFuture’ ... done
List of 6
[10:32:50.817] plan(): Setting new future strategy stack:
 $ a:[10:32:50.817] List of future strategies:
[10:32:50.817] 1. sequential:
[10:32:50.817]    - args: function (..., envir = parent.frame())
[10:32:50.817]    - tweaked: FALSE
[10:32:50.817]    - call: NULL
 num 1
 $ b:[10:32:50.818] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d02123a8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d018b220> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:32:50.820] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:32:50.820] List of future strategies:
[10:32:50.820] 1. multicore:
[10:32:50.820]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.820]    - tweaked: FALSE
[10:32:50.820]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d02123a8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d018b220> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:32:50.825] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.828] resolve() on list ...
[10:32:50.828]  recursive: 0
[10:32:50.828]  length: 6
[10:32:50.828]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.828] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.829] - nx: 6
[10:32:50.829] - relay: TRUE
[10:32:50.829] - stdout: TRUE
[10:32:50.829] - signal: TRUE
[10:32:50.829] - resignal: FALSE
[10:32:50.829] - force: TRUE
[10:32:50.829] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.830] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.830]  - until=2
[10:32:50.830]  - relaying element #2
[10:32:50.830] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.830] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.830] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.831]  length: 5 (resolved future 1)
[10:32:50.831] Future #2
[10:32:50.831] result() for MulticoreFuture ...
[10:32:50.836] result() for MulticoreFuture ...
[10:32:50.836] result() for MulticoreFuture ... done
[10:32:50.836] result() for MulticoreFuture ... done
[10:32:50.836] result() for MulticoreFuture ...
[10:32:50.837] result() for MulticoreFuture ... done
[10:32:50.837] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:50.837] - nx: 6
[10:32:50.837] - relay: TRUE
[10:32:50.838] - stdout: TRUE
[10:32:50.838] - signal: TRUE
[10:32:50.838] - resignal: FALSE
[10:32:50.838] - force: TRUE
[10:32:50.839] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.839] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.839]  - until=2
[10:32:50.839]  - relaying element #2
[10:32:50.839] result() for MulticoreFuture ...
[10:32:50.840] result() for MulticoreFuture ... done
[10:32:50.840] result() for MulticoreFuture ...
[10:32:50.840] result() for MulticoreFuture ... done
[10:32:50.840] result() for MulticoreFuture ...
[10:32:50.840] result() for MulticoreFuture ... done
[10:32:50.840] result() for MulticoreFuture ...
[10:32:50.841] result() for MulticoreFuture ... done
[10:32:50.841] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.841] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.841] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:50.841]  length: 4 (resolved future 2)
[10:32:50.842] Future #3
[10:32:50.842] result() for MulticoreFuture ...
[10:32:50.843] result() for MulticoreFuture ...
[10:32:50.843] result() for MulticoreFuture ... done
[10:32:50.843] result() for MulticoreFuture ... done
[10:32:50.843] result() for MulticoreFuture ...
[10:32:50.843] result() for MulticoreFuture ... done
[10:32:50.843] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:50.844] - nx: 6
[10:32:50.844] - relay: TRUE
[10:32:50.844] - stdout: TRUE
[10:32:50.844] - signal: TRUE
[10:32:50.844] - resignal: FALSE
[10:32:50.844] - force: TRUE
[10:32:50.844] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.844] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.845]  - until=3
[10:32:50.845]  - relaying element #3
[10:32:50.845] result() for MulticoreFuture ...
[10:32:50.845] result() for MulticoreFuture ... done
[10:32:50.845] result() for MulticoreFuture ...
[10:32:50.845] result() for MulticoreFuture ... done
[10:32:50.845] result() for MulticoreFuture ...
[10:32:50.845] result() for MulticoreFuture ... done
[10:32:50.846] result() for MulticoreFuture ...
[10:32:50.846] result() for MulticoreFuture ... done
[10:32:50.846] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.846] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.846] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:50.846]  length: 3 (resolved future 3)
[10:32:50.846] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.846] - nx: 6
[10:32:50.846] - relay: TRUE
[10:32:50.847] - stdout: TRUE
[10:32:50.847] - signal: TRUE
[10:32:50.847] - resignal: FALSE
[10:32:50.847] - force: TRUE
[10:32:50.847] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.847] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.847]  - until=5
[10:32:50.847]  - relaying element #5
[10:32:50.847] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.847] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.848] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.848]  length: 2 (resolved future 4)
[10:32:50.848] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.848] - nx: 6
[10:32:50.848] - relay: TRUE
[10:32:50.848] - stdout: TRUE
[10:32:50.848] - signal: TRUE
[10:32:50.848] - resignal: FALSE
[10:32:50.848] - force: TRUE
[10:32:50.848] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.848] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.849]  - until=6
[10:32:50.849]  - relaying element #6
[10:32:50.849] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.849] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.849] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.849]  length: 1 (resolved future 5)
[10:32:50.849] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.849] - nx: 6
[10:32:50.849] - relay: TRUE
[10:32:50.850] - stdout: TRUE
[10:32:50.850] - signal: TRUE
[10:32:50.850] - resignal: FALSE
[10:32:50.850] - force: TRUE
[10:32:50.850] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.850] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.850]  - until=6
[10:32:50.850] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.850] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.850] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.851]  length: 0 (resolved future 6)
[10:32:50.851] Relaying remaining futures
[10:32:50.851] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.851] - nx: 6
[10:32:50.851] - relay: TRUE
[10:32:50.851] - stdout: TRUE
[10:32:50.851] - signal: TRUE
[10:32:50.851] - resignal: FALSE
[10:32:50.851] - force: TRUE
[10:32:50.851] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.851] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.852] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.852] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.852] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.852] resolve() on list ... DONE
[10:32:50.852] result() for MulticoreFuture ...
[10:32:50.852] result() for MulticoreFuture ... done
[10:32:50.852] result() for MulticoreFuture ...
[10:32:50.852] result() for MulticoreFuture ... done
[10:32:50.852] result() for MulticoreFuture ...
[10:32:50.853] result() for MulticoreFuture ... done
[10:32:50.853] result() for MulticoreFuture ...
[10:32:50.853] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:32:50.856] getGlobalsAndPackages() ...
[10:32:50.856] Searching for globals...
[10:32:50.857] 
[10:32:50.857] Searching for globals ... DONE
[10:32:50.857] - globals: [0] <none>
[10:32:50.857] getGlobalsAndPackages() ... DONE
[10:32:50.857] run() for ‘Future’ ...
[10:32:50.857] - state: ‘created’
[10:32:50.857] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.862] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.862]   - Field: ‘label’
[10:32:50.862]   - Field: ‘local’
[10:32:50.862]   - Field: ‘owner’
[10:32:50.862]   - Field: ‘envir’
[10:32:50.862]   - Field: ‘workers’
[10:32:50.862]   - Field: ‘packages’
[10:32:50.862]   - Field: ‘gc’
[10:32:50.862]   - Field: ‘job’
[10:32:50.863]   - Field: ‘conditions’
[10:32:50.863]   - Field: ‘expr’
[10:32:50.863]   - Field: ‘uuid’
[10:32:50.863]   - Field: ‘seed’
[10:32:50.863]   - Field: ‘version’
[10:32:50.863]   - Field: ‘result’
[10:32:50.863]   - Field: ‘asynchronous’
[10:32:50.863]   - Field: ‘calls’
[10:32:50.863]   - Field: ‘globals’
[10:32:50.863]   - Field: ‘stdout’
[10:32:50.864]   - Field: ‘earlySignal’
[10:32:50.864]   - Field: ‘lazy’
[10:32:50.864]   - Field: ‘state’
[10:32:50.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.864] - Launch lazy future ...
[10:32:50.864] Packages needed by the future expression (n = 0): <none>
[10:32:50.864] Packages needed by future strategies (n = 0): <none>
[10:32:50.865] {
[10:32:50.865]     {
[10:32:50.865]         {
[10:32:50.865]             ...future.startTime <- base::Sys.time()
[10:32:50.865]             {
[10:32:50.865]                 {
[10:32:50.865]                   {
[10:32:50.865]                     {
[10:32:50.865]                       base::local({
[10:32:50.865]                         has_future <- base::requireNamespace("future", 
[10:32:50.865]                           quietly = TRUE)
[10:32:50.865]                         if (has_future) {
[10:32:50.865]                           ns <- base::getNamespace("future")
[10:32:50.865]                           version <- ns[[".package"]][["version"]]
[10:32:50.865]                           if (is.null(version)) 
[10:32:50.865]                             version <- utils::packageVersion("future")
[10:32:50.865]                         }
[10:32:50.865]                         else {
[10:32:50.865]                           version <- NULL
[10:32:50.865]                         }
[10:32:50.865]                         if (!has_future || version < "1.8.0") {
[10:32:50.865]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.865]                             "", base::R.version$version.string), 
[10:32:50.865]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.865]                               "release", "version")], collapse = " "), 
[10:32:50.865]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.865]                             info)
[10:32:50.865]                           info <- base::paste(info, collapse = "; ")
[10:32:50.865]                           if (!has_future) {
[10:32:50.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.865]                               info)
[10:32:50.865]                           }
[10:32:50.865]                           else {
[10:32:50.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.865]                               info, version)
[10:32:50.865]                           }
[10:32:50.865]                           base::stop(msg)
[10:32:50.865]                         }
[10:32:50.865]                       })
[10:32:50.865]                     }
[10:32:50.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.865]                     base::options(mc.cores = 1L)
[10:32:50.865]                   }
[10:32:50.865]                   ...future.strategy.old <- future::plan("list")
[10:32:50.865]                   options(future.plan = NULL)
[10:32:50.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.865]                 }
[10:32:50.865]                 ...future.workdir <- getwd()
[10:32:50.865]             }
[10:32:50.865]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.865]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.865]         }
[10:32:50.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.865]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.865]             base::names(...future.oldOptions))
[10:32:50.865]     }
[10:32:50.865]     if (FALSE) {
[10:32:50.865]     }
[10:32:50.865]     else {
[10:32:50.865]         if (TRUE) {
[10:32:50.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.865]                 open = "w")
[10:32:50.865]         }
[10:32:50.865]         else {
[10:32:50.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.865]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.865]         }
[10:32:50.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.865]             base::sink(type = "output", split = FALSE)
[10:32:50.865]             base::close(...future.stdout)
[10:32:50.865]         }, add = TRUE)
[10:32:50.865]     }
[10:32:50.865]     ...future.frame <- base::sys.nframe()
[10:32:50.865]     ...future.conditions <- base::list()
[10:32:50.865]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.865]     if (FALSE) {
[10:32:50.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.865]     }
[10:32:50.865]     ...future.result <- base::tryCatch({
[10:32:50.865]         base::withCallingHandlers({
[10:32:50.865]             ...future.value <- base::withVisible(base::local({
[10:32:50.865]                 withCallingHandlers({
[10:32:50.865]                   2
[10:32:50.865]                 }, immediateCondition = function(cond) {
[10:32:50.865]                   save_rds <- function (object, pathname, ...) 
[10:32:50.865]                   {
[10:32:50.865]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.865]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.865]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.865]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.865]                         fi_tmp[["mtime"]])
[10:32:50.865]                     }
[10:32:50.865]                     tryCatch({
[10:32:50.865]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.865]                     }, error = function(ex) {
[10:32:50.865]                       msg <- conditionMessage(ex)
[10:32:50.865]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.865]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.865]                         fi_tmp[["mtime"]], msg)
[10:32:50.865]                       ex$message <- msg
[10:32:50.865]                       stop(ex)
[10:32:50.865]                     })
[10:32:50.865]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.865]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.865]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.865]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.865]                       fi <- file.info(pathname)
[10:32:50.865]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.865]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.865]                         fi[["size"]], fi[["mtime"]])
[10:32:50.865]                       stop(msg)
[10:32:50.865]                     }
[10:32:50.865]                     invisible(pathname)
[10:32:50.865]                   }
[10:32:50.865]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.865]                     rootPath = tempdir()) 
[10:32:50.865]                   {
[10:32:50.865]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.865]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.865]                       tmpdir = path, fileext = ".rds")
[10:32:50.865]                     save_rds(obj, file)
[10:32:50.865]                   }
[10:32:50.865]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.865]                   {
[10:32:50.865]                     inherits <- base::inherits
[10:32:50.865]                     invokeRestart <- base::invokeRestart
[10:32:50.865]                     is.null <- base::is.null
[10:32:50.865]                     muffled <- FALSE
[10:32:50.865]                     if (inherits(cond, "message")) {
[10:32:50.865]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.865]                       if (muffled) 
[10:32:50.865]                         invokeRestart("muffleMessage")
[10:32:50.865]                     }
[10:32:50.865]                     else if (inherits(cond, "warning")) {
[10:32:50.865]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.865]                       if (muffled) 
[10:32:50.865]                         invokeRestart("muffleWarning")
[10:32:50.865]                     }
[10:32:50.865]                     else if (inherits(cond, "condition")) {
[10:32:50.865]                       if (!is.null(pattern)) {
[10:32:50.865]                         computeRestarts <- base::computeRestarts
[10:32:50.865]                         grepl <- base::grepl
[10:32:50.865]                         restarts <- computeRestarts(cond)
[10:32:50.865]                         for (restart in restarts) {
[10:32:50.865]                           name <- restart$name
[10:32:50.865]                           if (is.null(name)) 
[10:32:50.865]                             next
[10:32:50.865]                           if (!grepl(pattern, name)) 
[10:32:50.865]                             next
[10:32:50.865]                           invokeRestart(restart)
[10:32:50.865]                           muffled <- TRUE
[10:32:50.865]                           break
[10:32:50.865]                         }
[10:32:50.865]                       }
[10:32:50.865]                     }
[10:32:50.865]                     invisible(muffled)
[10:32:50.865]                   }
[10:32:50.865]                   muffleCondition(cond)
[10:32:50.865]                 })
[10:32:50.865]             }))
[10:32:50.865]             future::FutureResult(value = ...future.value$value, 
[10:32:50.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.865]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.865]                     ...future.globalenv.names))
[10:32:50.865]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.865]         }, condition = base::local({
[10:32:50.865]             c <- base::c
[10:32:50.865]             inherits <- base::inherits
[10:32:50.865]             invokeRestart <- base::invokeRestart
[10:32:50.865]             length <- base::length
[10:32:50.865]             list <- base::list
[10:32:50.865]             seq.int <- base::seq.int
[10:32:50.865]             signalCondition <- base::signalCondition
[10:32:50.865]             sys.calls <- base::sys.calls
[10:32:50.865]             `[[` <- base::`[[`
[10:32:50.865]             `+` <- base::`+`
[10:32:50.865]             `<<-` <- base::`<<-`
[10:32:50.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.865]                   3L)]
[10:32:50.865]             }
[10:32:50.865]             function(cond) {
[10:32:50.865]                 is_error <- inherits(cond, "error")
[10:32:50.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.865]                   NULL)
[10:32:50.865]                 if (is_error) {
[10:32:50.865]                   sessionInformation <- function() {
[10:32:50.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.865]                       search = base::search(), system = base::Sys.info())
[10:32:50.865]                   }
[10:32:50.865]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.865]                     cond$call), session = sessionInformation(), 
[10:32:50.865]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.865]                   signalCondition(cond)
[10:32:50.865]                 }
[10:32:50.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.865]                 "immediateCondition"))) {
[10:32:50.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.865]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.865]                   if (TRUE && !signal) {
[10:32:50.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.865]                     {
[10:32:50.865]                       inherits <- base::inherits
[10:32:50.865]                       invokeRestart <- base::invokeRestart
[10:32:50.865]                       is.null <- base::is.null
[10:32:50.865]                       muffled <- FALSE
[10:32:50.865]                       if (inherits(cond, "message")) {
[10:32:50.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.865]                         if (muffled) 
[10:32:50.865]                           invokeRestart("muffleMessage")
[10:32:50.865]                       }
[10:32:50.865]                       else if (inherits(cond, "warning")) {
[10:32:50.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.865]                         if (muffled) 
[10:32:50.865]                           invokeRestart("muffleWarning")
[10:32:50.865]                       }
[10:32:50.865]                       else if (inherits(cond, "condition")) {
[10:32:50.865]                         if (!is.null(pattern)) {
[10:32:50.865]                           computeRestarts <- base::computeRestarts
[10:32:50.865]                           grepl <- base::grepl
[10:32:50.865]                           restarts <- computeRestarts(cond)
[10:32:50.865]                           for (restart in restarts) {
[10:32:50.865]                             name <- restart$name
[10:32:50.865]                             if (is.null(name)) 
[10:32:50.865]                               next
[10:32:50.865]                             if (!grepl(pattern, name)) 
[10:32:50.865]                               next
[10:32:50.865]                             invokeRestart(restart)
[10:32:50.865]                             muffled <- TRUE
[10:32:50.865]                             break
[10:32:50.865]                           }
[10:32:50.865]                         }
[10:32:50.865]                       }
[10:32:50.865]                       invisible(muffled)
[10:32:50.865]                     }
[10:32:50.865]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.865]                   }
[10:32:50.865]                 }
[10:32:50.865]                 else {
[10:32:50.865]                   if (TRUE) {
[10:32:50.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.865]                     {
[10:32:50.865]                       inherits <- base::inherits
[10:32:50.865]                       invokeRestart <- base::invokeRestart
[10:32:50.865]                       is.null <- base::is.null
[10:32:50.865]                       muffled <- FALSE
[10:32:50.865]                       if (inherits(cond, "message")) {
[10:32:50.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.865]                         if (muffled) 
[10:32:50.865]                           invokeRestart("muffleMessage")
[10:32:50.865]                       }
[10:32:50.865]                       else if (inherits(cond, "warning")) {
[10:32:50.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.865]                         if (muffled) 
[10:32:50.865]                           invokeRestart("muffleWarning")
[10:32:50.865]                       }
[10:32:50.865]                       else if (inherits(cond, "condition")) {
[10:32:50.865]                         if (!is.null(pattern)) {
[10:32:50.865]                           computeRestarts <- base::computeRestarts
[10:32:50.865]                           grepl <- base::grepl
[10:32:50.865]                           restarts <- computeRestarts(cond)
[10:32:50.865]                           for (restart in restarts) {
[10:32:50.865]                             name <- restart$name
[10:32:50.865]                             if (is.null(name)) 
[10:32:50.865]                               next
[10:32:50.865]                             if (!grepl(pattern, name)) 
[10:32:50.865]                               next
[10:32:50.865]                             invokeRestart(restart)
[10:32:50.865]                             muffled <- TRUE
[10:32:50.865]                             break
[10:32:50.865]                           }
[10:32:50.865]                         }
[10:32:50.865]                       }
[10:32:50.865]                       invisible(muffled)
[10:32:50.865]                     }
[10:32:50.865]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.865]                   }
[10:32:50.865]                 }
[10:32:50.865]             }
[10:32:50.865]         }))
[10:32:50.865]     }, error = function(ex) {
[10:32:50.865]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.865]                 ...future.rng), started = ...future.startTime, 
[10:32:50.865]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.865]             version = "1.8"), class = "FutureResult")
[10:32:50.865]     }, finally = {
[10:32:50.865]         if (!identical(...future.workdir, getwd())) 
[10:32:50.865]             setwd(...future.workdir)
[10:32:50.865]         {
[10:32:50.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.865]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.865]             }
[10:32:50.865]             base::options(...future.oldOptions)
[10:32:50.865]             if (.Platform$OS.type == "windows") {
[10:32:50.865]                 old_names <- names(...future.oldEnvVars)
[10:32:50.865]                 envs <- base::Sys.getenv()
[10:32:50.865]                 names <- names(envs)
[10:32:50.865]                 common <- intersect(names, old_names)
[10:32:50.865]                 added <- setdiff(names, old_names)
[10:32:50.865]                 removed <- setdiff(old_names, names)
[10:32:50.865]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.865]                   envs[common]]
[10:32:50.865]                 NAMES <- toupper(changed)
[10:32:50.865]                 args <- list()
[10:32:50.865]                 for (kk in seq_along(NAMES)) {
[10:32:50.865]                   name <- changed[[kk]]
[10:32:50.865]                   NAME <- NAMES[[kk]]
[10:32:50.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.865]                     next
[10:32:50.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.865]                 }
[10:32:50.865]                 NAMES <- toupper(added)
[10:32:50.865]                 for (kk in seq_along(NAMES)) {
[10:32:50.865]                   name <- added[[kk]]
[10:32:50.865]                   NAME <- NAMES[[kk]]
[10:32:50.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.865]                     next
[10:32:50.865]                   args[[name]] <- ""
[10:32:50.865]                 }
[10:32:50.865]                 NAMES <- toupper(removed)
[10:32:50.865]                 for (kk in seq_along(NAMES)) {
[10:32:50.865]                   name <- removed[[kk]]
[10:32:50.865]                   NAME <- NAMES[[kk]]
[10:32:50.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.865]                     next
[10:32:50.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.865]                 }
[10:32:50.865]                 if (length(args) > 0) 
[10:32:50.865]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.865]             }
[10:32:50.865]             else {
[10:32:50.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.865]             }
[10:32:50.865]             {
[10:32:50.865]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.865]                   0L) {
[10:32:50.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.865]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.865]                   base::options(opts)
[10:32:50.865]                 }
[10:32:50.865]                 {
[10:32:50.865]                   {
[10:32:50.865]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.865]                     NULL
[10:32:50.865]                   }
[10:32:50.865]                   options(future.plan = NULL)
[10:32:50.865]                   if (is.na(NA_character_)) 
[10:32:50.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.865]                     .init = FALSE)
[10:32:50.865]                 }
[10:32:50.865]             }
[10:32:50.865]         }
[10:32:50.865]     })
[10:32:50.865]     if (TRUE) {
[10:32:50.865]         base::sink(type = "output", split = FALSE)
[10:32:50.865]         if (TRUE) {
[10:32:50.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.865]         }
[10:32:50.865]         else {
[10:32:50.865]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.865]         }
[10:32:50.865]         base::close(...future.stdout)
[10:32:50.865]         ...future.stdout <- NULL
[10:32:50.865]     }
[10:32:50.865]     ...future.result$conditions <- ...future.conditions
[10:32:50.865]     ...future.result$finished <- base::Sys.time()
[10:32:50.865]     ...future.result
[10:32:50.865] }
[10:32:50.867] requestCore(): workers = 2
[10:32:50.869] MulticoreFuture started
[10:32:50.870] - Launch lazy future ... done
[10:32:50.870] run() for ‘MulticoreFuture’ ... done
[10:32:50.870] getGlobalsAndPackages() ...
[10:32:50.871] Searching for globals...
[10:32:50.870] plan(): Setting new future strategy stack:
[10:32:50.871] List of future strategies:
[10:32:50.871] 1. sequential:
[10:32:50.871]    - args: function (..., envir = parent.frame())
[10:32:50.871]    - tweaked: FALSE
[10:32:50.871]    - call: NULL
[10:32:50.872] 
[10:32:50.872] plan(): nbrOfWorkers() = 1
[10:32:50.872] Searching for globals ... DONE
[10:32:50.872] - globals: [0] <none>
[10:32:50.872] getGlobalsAndPackages() ... DONE
[10:32:50.878] plan(): Setting new future strategy stack:
[10:32:50.878] run() for ‘Future’ ...
[10:32:50.879] - state: ‘created’
[10:32:50.879] List of future strategies:
[10:32:50.879] 1. multicore:
[10:32:50.879]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.879]    - tweaked: FALSE
[10:32:50.879]    - call: plan(strategy)
[10:32:50.880] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.886] plan(): nbrOfWorkers() = 2
[10:32:50.887] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.888]   - Field: ‘label’
[10:32:50.888]   - Field: ‘local’
[10:32:50.888]   - Field: ‘owner’
[10:32:50.888]   - Field: ‘envir’
[10:32:50.888]   - Field: ‘workers’
[10:32:50.889]   - Field: ‘packages’
[10:32:50.889]   - Field: ‘gc’
[10:32:50.889]   - Field: ‘job’
[10:32:50.889]   - Field: ‘conditions’
[10:32:50.889]   - Field: ‘expr’
[10:32:50.890]   - Field: ‘uuid’
[10:32:50.890]   - Field: ‘seed’
[10:32:50.890]   - Field: ‘version’
[10:32:50.890]   - Field: ‘result’
[10:32:50.890]   - Field: ‘asynchronous’
[10:32:50.890]   - Field: ‘calls’
[10:32:50.891]   - Field: ‘globals’
[10:32:50.891]   - Field: ‘stdout’
[10:32:50.891]   - Field: ‘earlySignal’
[10:32:50.891]   - Field: ‘lazy’
[10:32:50.891]   - Field: ‘state’
[10:32:50.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.892] - Launch lazy future ...
[10:32:50.892] Packages needed by the future expression (n = 0): <none>
[10:32:50.892] Packages needed by future strategies (n = 0): <none>
[10:32:50.893] {
[10:32:50.893]     {
[10:32:50.893]         {
[10:32:50.893]             ...future.startTime <- base::Sys.time()
[10:32:50.893]             {
[10:32:50.893]                 {
[10:32:50.893]                   {
[10:32:50.893]                     {
[10:32:50.893]                       base::local({
[10:32:50.893]                         has_future <- base::requireNamespace("future", 
[10:32:50.893]                           quietly = TRUE)
[10:32:50.893]                         if (has_future) {
[10:32:50.893]                           ns <- base::getNamespace("future")
[10:32:50.893]                           version <- ns[[".package"]][["version"]]
[10:32:50.893]                           if (is.null(version)) 
[10:32:50.893]                             version <- utils::packageVersion("future")
[10:32:50.893]                         }
[10:32:50.893]                         else {
[10:32:50.893]                           version <- NULL
[10:32:50.893]                         }
[10:32:50.893]                         if (!has_future || version < "1.8.0") {
[10:32:50.893]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.893]                             "", base::R.version$version.string), 
[10:32:50.893]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.893]                               "release", "version")], collapse = " "), 
[10:32:50.893]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.893]                             info)
[10:32:50.893]                           info <- base::paste(info, collapse = "; ")
[10:32:50.893]                           if (!has_future) {
[10:32:50.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.893]                               info)
[10:32:50.893]                           }
[10:32:50.893]                           else {
[10:32:50.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.893]                               info, version)
[10:32:50.893]                           }
[10:32:50.893]                           base::stop(msg)
[10:32:50.893]                         }
[10:32:50.893]                       })
[10:32:50.893]                     }
[10:32:50.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.893]                     base::options(mc.cores = 1L)
[10:32:50.893]                   }
[10:32:50.893]                   ...future.strategy.old <- future::plan("list")
[10:32:50.893]                   options(future.plan = NULL)
[10:32:50.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.893]                 }
[10:32:50.893]                 ...future.workdir <- getwd()
[10:32:50.893]             }
[10:32:50.893]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.893]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.893]         }
[10:32:50.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.893]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.893]             base::names(...future.oldOptions))
[10:32:50.893]     }
[10:32:50.893]     if (FALSE) {
[10:32:50.893]     }
[10:32:50.893]     else {
[10:32:50.893]         if (TRUE) {
[10:32:50.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.893]                 open = "w")
[10:32:50.893]         }
[10:32:50.893]         else {
[10:32:50.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.893]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.893]         }
[10:32:50.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.893]             base::sink(type = "output", split = FALSE)
[10:32:50.893]             base::close(...future.stdout)
[10:32:50.893]         }, add = TRUE)
[10:32:50.893]     }
[10:32:50.893]     ...future.frame <- base::sys.nframe()
[10:32:50.893]     ...future.conditions <- base::list()
[10:32:50.893]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.893]     if (FALSE) {
[10:32:50.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.893]     }
[10:32:50.893]     ...future.result <- base::tryCatch({
[10:32:50.893]         base::withCallingHandlers({
[10:32:50.893]             ...future.value <- base::withVisible(base::local({
[10:32:50.893]                 withCallingHandlers({
[10:32:50.893]                   NULL
[10:32:50.893]                 }, immediateCondition = function(cond) {
[10:32:50.893]                   save_rds <- function (object, pathname, ...) 
[10:32:50.893]                   {
[10:32:50.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.893]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.893]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.893]                         fi_tmp[["mtime"]])
[10:32:50.893]                     }
[10:32:50.893]                     tryCatch({
[10:32:50.893]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.893]                     }, error = function(ex) {
[10:32:50.893]                       msg <- conditionMessage(ex)
[10:32:50.893]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.893]                         fi_tmp[["mtime"]], msg)
[10:32:50.893]                       ex$message <- msg
[10:32:50.893]                       stop(ex)
[10:32:50.893]                     })
[10:32:50.893]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.893]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.893]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.893]                       fi <- file.info(pathname)
[10:32:50.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.893]                         fi[["size"]], fi[["mtime"]])
[10:32:50.893]                       stop(msg)
[10:32:50.893]                     }
[10:32:50.893]                     invisible(pathname)
[10:32:50.893]                   }
[10:32:50.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.893]                     rootPath = tempdir()) 
[10:32:50.893]                   {
[10:32:50.893]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.893]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.893]                       tmpdir = path, fileext = ".rds")
[10:32:50.893]                     save_rds(obj, file)
[10:32:50.893]                   }
[10:32:50.893]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.893]                   {
[10:32:50.893]                     inherits <- base::inherits
[10:32:50.893]                     invokeRestart <- base::invokeRestart
[10:32:50.893]                     is.null <- base::is.null
[10:32:50.893]                     muffled <- FALSE
[10:32:50.893]                     if (inherits(cond, "message")) {
[10:32:50.893]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.893]                       if (muffled) 
[10:32:50.893]                         invokeRestart("muffleMessage")
[10:32:50.893]                     }
[10:32:50.893]                     else if (inherits(cond, "warning")) {
[10:32:50.893]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.893]                       if (muffled) 
[10:32:50.893]                         invokeRestart("muffleWarning")
[10:32:50.893]                     }
[10:32:50.893]                     else if (inherits(cond, "condition")) {
[10:32:50.893]                       if (!is.null(pattern)) {
[10:32:50.893]                         computeRestarts <- base::computeRestarts
[10:32:50.893]                         grepl <- base::grepl
[10:32:50.893]                         restarts <- computeRestarts(cond)
[10:32:50.893]                         for (restart in restarts) {
[10:32:50.893]                           name <- restart$name
[10:32:50.893]                           if (is.null(name)) 
[10:32:50.893]                             next
[10:32:50.893]                           if (!grepl(pattern, name)) 
[10:32:50.893]                             next
[10:32:50.893]                           invokeRestart(restart)
[10:32:50.893]                           muffled <- TRUE
[10:32:50.893]                           break
[10:32:50.893]                         }
[10:32:50.893]                       }
[10:32:50.893]                     }
[10:32:50.893]                     invisible(muffled)
[10:32:50.893]                   }
[10:32:50.893]                   muffleCondition(cond)
[10:32:50.893]                 })
[10:32:50.893]             }))
[10:32:50.893]             future::FutureResult(value = ...future.value$value, 
[10:32:50.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.893]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.893]                     ...future.globalenv.names))
[10:32:50.893]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.893]         }, condition = base::local({
[10:32:50.893]             c <- base::c
[10:32:50.893]             inherits <- base::inherits
[10:32:50.893]             invokeRestart <- base::invokeRestart
[10:32:50.893]             length <- base::length
[10:32:50.893]             list <- base::list
[10:32:50.893]             seq.int <- base::seq.int
[10:32:50.893]             signalCondition <- base::signalCondition
[10:32:50.893]             sys.calls <- base::sys.calls
[10:32:50.893]             `[[` <- base::`[[`
[10:32:50.893]             `+` <- base::`+`
[10:32:50.893]             `<<-` <- base::`<<-`
[10:32:50.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.893]                   3L)]
[10:32:50.893]             }
[10:32:50.893]             function(cond) {
[10:32:50.893]                 is_error <- inherits(cond, "error")
[10:32:50.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.893]                   NULL)
[10:32:50.893]                 if (is_error) {
[10:32:50.893]                   sessionInformation <- function() {
[10:32:50.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.893]                       search = base::search(), system = base::Sys.info())
[10:32:50.893]                   }
[10:32:50.893]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.893]                     cond$call), session = sessionInformation(), 
[10:32:50.893]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.893]                   signalCondition(cond)
[10:32:50.893]                 }
[10:32:50.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.893]                 "immediateCondition"))) {
[10:32:50.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.893]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.893]                   if (TRUE && !signal) {
[10:32:50.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.893]                     {
[10:32:50.893]                       inherits <- base::inherits
[10:32:50.893]                       invokeRestart <- base::invokeRestart
[10:32:50.893]                       is.null <- base::is.null
[10:32:50.893]                       muffled <- FALSE
[10:32:50.893]                       if (inherits(cond, "message")) {
[10:32:50.893]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.893]                         if (muffled) 
[10:32:50.893]                           invokeRestart("muffleMessage")
[10:32:50.893]                       }
[10:32:50.893]                       else if (inherits(cond, "warning")) {
[10:32:50.893]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.893]                         if (muffled) 
[10:32:50.893]                           invokeRestart("muffleWarning")
[10:32:50.893]                       }
[10:32:50.893]                       else if (inherits(cond, "condition")) {
[10:32:50.893]                         if (!is.null(pattern)) {
[10:32:50.893]                           computeRestarts <- base::computeRestarts
[10:32:50.893]                           grepl <- base::grepl
[10:32:50.893]                           restarts <- computeRestarts(cond)
[10:32:50.893]                           for (restart in restarts) {
[10:32:50.893]                             name <- restart$name
[10:32:50.893]                             if (is.null(name)) 
[10:32:50.893]                               next
[10:32:50.893]                             if (!grepl(pattern, name)) 
[10:32:50.893]                               next
[10:32:50.893]                             invokeRestart(restart)
[10:32:50.893]                             muffled <- TRUE
[10:32:50.893]                             break
[10:32:50.893]                           }
[10:32:50.893]                         }
[10:32:50.893]                       }
[10:32:50.893]                       invisible(muffled)
[10:32:50.893]                     }
[10:32:50.893]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.893]                   }
[10:32:50.893]                 }
[10:32:50.893]                 else {
[10:32:50.893]                   if (TRUE) {
[10:32:50.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.893]                     {
[10:32:50.893]                       inherits <- base::inherits
[10:32:50.893]                       invokeRestart <- base::invokeRestart
[10:32:50.893]                       is.null <- base::is.null
[10:32:50.893]                       muffled <- FALSE
[10:32:50.893]                       if (inherits(cond, "message")) {
[10:32:50.893]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.893]                         if (muffled) 
[10:32:50.893]                           invokeRestart("muffleMessage")
[10:32:50.893]                       }
[10:32:50.893]                       else if (inherits(cond, "warning")) {
[10:32:50.893]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.893]                         if (muffled) 
[10:32:50.893]                           invokeRestart("muffleWarning")
[10:32:50.893]                       }
[10:32:50.893]                       else if (inherits(cond, "condition")) {
[10:32:50.893]                         if (!is.null(pattern)) {
[10:32:50.893]                           computeRestarts <- base::computeRestarts
[10:32:50.893]                           grepl <- base::grepl
[10:32:50.893]                           restarts <- computeRestarts(cond)
[10:32:50.893]                           for (restart in restarts) {
[10:32:50.893]                             name <- restart$name
[10:32:50.893]                             if (is.null(name)) 
[10:32:50.893]                               next
[10:32:50.893]                             if (!grepl(pattern, name)) 
[10:32:50.893]                               next
[10:32:50.893]                             invokeRestart(restart)
[10:32:50.893]                             muffled <- TRUE
[10:32:50.893]                             break
[10:32:50.893]                           }
[10:32:50.893]                         }
[10:32:50.893]                       }
[10:32:50.893]                       invisible(muffled)
[10:32:50.893]                     }
[10:32:50.893]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.893]                   }
[10:32:50.893]                 }
[10:32:50.893]             }
[10:32:50.893]         }))
[10:32:50.893]     }, error = function(ex) {
[10:32:50.893]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.893]                 ...future.rng), started = ...future.startTime, 
[10:32:50.893]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.893]             version = "1.8"), class = "FutureResult")
[10:32:50.893]     }, finally = {
[10:32:50.893]         if (!identical(...future.workdir, getwd())) 
[10:32:50.893]             setwd(...future.workdir)
[10:32:50.893]         {
[10:32:50.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.893]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.893]             }
[10:32:50.893]             base::options(...future.oldOptions)
[10:32:50.893]             if (.Platform$OS.type == "windows") {
[10:32:50.893]                 old_names <- names(...future.oldEnvVars)
[10:32:50.893]                 envs <- base::Sys.getenv()
[10:32:50.893]                 names <- names(envs)
[10:32:50.893]                 common <- intersect(names, old_names)
[10:32:50.893]                 added <- setdiff(names, old_names)
[10:32:50.893]                 removed <- setdiff(old_names, names)
[10:32:50.893]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.893]                   envs[common]]
[10:32:50.893]                 NAMES <- toupper(changed)
[10:32:50.893]                 args <- list()
[10:32:50.893]                 for (kk in seq_along(NAMES)) {
[10:32:50.893]                   name <- changed[[kk]]
[10:32:50.893]                   NAME <- NAMES[[kk]]
[10:32:50.893]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.893]                     next
[10:32:50.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.893]                 }
[10:32:50.893]                 NAMES <- toupper(added)
[10:32:50.893]                 for (kk in seq_along(NAMES)) {
[10:32:50.893]                   name <- added[[kk]]
[10:32:50.893]                   NAME <- NAMES[[kk]]
[10:32:50.893]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.893]                     next
[10:32:50.893]                   args[[name]] <- ""
[10:32:50.893]                 }
[10:32:50.893]                 NAMES <- toupper(removed)
[10:32:50.893]                 for (kk in seq_along(NAMES)) {
[10:32:50.893]                   name <- removed[[kk]]
[10:32:50.893]                   NAME <- NAMES[[kk]]
[10:32:50.893]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.893]                     next
[10:32:50.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.893]                 }
[10:32:50.893]                 if (length(args) > 0) 
[10:32:50.893]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.893]             }
[10:32:50.893]             else {
[10:32:50.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.893]             }
[10:32:50.893]             {
[10:32:50.893]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.893]                   0L) {
[10:32:50.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.893]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.893]                   base::options(opts)
[10:32:50.893]                 }
[10:32:50.893]                 {
[10:32:50.893]                   {
[10:32:50.893]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.893]                     NULL
[10:32:50.893]                   }
[10:32:50.893]                   options(future.plan = NULL)
[10:32:50.893]                   if (is.na(NA_character_)) 
[10:32:50.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.893]                     .init = FALSE)
[10:32:50.893]                 }
[10:32:50.893]             }
[10:32:50.893]         }
[10:32:50.893]     })
[10:32:50.893]     if (TRUE) {
[10:32:50.893]         base::sink(type = "output", split = FALSE)
[10:32:50.893]         if (TRUE) {
[10:32:50.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.893]         }
[10:32:50.893]         else {
[10:32:50.893]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.893]         }
[10:32:50.893]         base::close(...future.stdout)
[10:32:50.893]         ...future.stdout <- NULL
[10:32:50.893]     }
[10:32:50.893]     ...future.result$conditions <- ...future.conditions
[10:32:50.893]     ...future.result$finished <- base::Sys.time()
[10:32:50.893]     ...future.result
[10:32:50.893] }
[10:32:50.896] requestCore(): workers = 2
[10:32:50.898] MulticoreFuture started
[10:32:50.899] - Launch lazy future ... done
[10:32:50.899] run() for ‘MulticoreFuture’ ... done
List of 6
[10:32:50.899] plan(): Setting new future strategy stack:
 $ a:[10:32:50.900] List of future strategies:
[10:32:50.900] 1. sequential:
[10:32:50.900]    - args: function (..., envir = parent.frame())
[10:32:50.900]    - tweaked: FALSE
[10:32:50.900]    - call: NULL
 num 1
 $ b:[10:32:50.901] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0eed3f8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652ceedc228> 
 $  : NULL
 $  : NULL
 $  :[10:32:50.903] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[10:32:50.903] List of future strategies:
[10:32:50.903] 1. multicore:
[10:32:50.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.903]    - tweaked: FALSE
[10:32:50.903]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0eed3f8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652ceedc228> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ :[10:32:50.908] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.912] resolve() on list ...
[10:32:50.912]  recursive: 0
[10:32:50.912]  length: 6
[10:32:50.912]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.912] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.913] - nx: 6
[10:32:50.913] - relay: TRUE
[10:32:50.913] - stdout: TRUE
[10:32:50.913] - signal: TRUE
[10:32:50.913] - resignal: FALSE
[10:32:50.913] - force: TRUE
[10:32:50.913] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.914] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.914]  - until=2
[10:32:50.914]  - relaying element #2
[10:32:50.914] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.914] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.914] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.914]  length: 5 (resolved future 1)
[10:32:50.915] Future #2
[10:32:50.915] result() for MulticoreFuture ...
[10:32:50.916] result() for MulticoreFuture ...
[10:32:50.916] result() for MulticoreFuture ... done
[10:32:50.916] result() for MulticoreFuture ... done
[10:32:50.916] result() for MulticoreFuture ...
[10:32:50.916] result() for MulticoreFuture ... done
[10:32:50.917] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:50.917] - nx: 6
[10:32:50.917] - relay: TRUE
[10:32:50.917] - stdout: TRUE
[10:32:50.917] - signal: TRUE
[10:32:50.918] - resignal: FALSE
[10:32:50.918] - force: TRUE
[10:32:50.918] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.918] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.918]  - until=2
[10:32:50.918]  - relaying element #2
[10:32:50.919] result() for MulticoreFuture ...
[10:32:50.919] result() for MulticoreFuture ... done
[10:32:50.919] result() for MulticoreFuture ...
[10:32:50.919] result() for MulticoreFuture ... done
[10:32:50.919] result() for MulticoreFuture ...
[10:32:50.920] result() for MulticoreFuture ... done
[10:32:50.920] result() for MulticoreFuture ...
[10:32:50.920] result() for MulticoreFuture ... done
[10:32:50.920] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.920] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.920] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:50.920]  length: 4 (resolved future 2)
[10:32:50.921] Future #3
[10:32:50.921] result() for MulticoreFuture ...
[10:32:50.922] result() for MulticoreFuture ...
[10:32:50.922] result() for MulticoreFuture ... done
[10:32:50.922] result() for MulticoreFuture ... done
[10:32:50.922] result() for MulticoreFuture ...
[10:32:50.922] result() for MulticoreFuture ... done
[10:32:50.922] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:50.922] - nx: 6
[10:32:50.923] - relay: TRUE
[10:32:50.923] - stdout: TRUE
[10:32:50.923] - signal: TRUE
[10:32:50.923] - resignal: FALSE
[10:32:50.923] - force: TRUE
[10:32:50.923] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.923] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.923]  - until=3
[10:32:50.924]  - relaying element #3
[10:32:50.924] result() for MulticoreFuture ...
[10:32:50.924] result() for MulticoreFuture ... done
[10:32:50.924] result() for MulticoreFuture ...
[10:32:50.924] result() for MulticoreFuture ... done
[10:32:50.924] result() for MulticoreFuture ...
[10:32:50.924] result() for MulticoreFuture ... done
[10:32:50.924] result() for MulticoreFuture ...
[10:32:50.925] result() for MulticoreFuture ... done
[10:32:50.925] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.925] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.925] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:50.925]  length: 3 (resolved future 3)
[10:32:50.925] signalConditionsASAP(NULL, pos=4) ...
[10:32:50.925] - nx: 6
[10:32:50.925] - relay: TRUE
[10:32:50.925] - stdout: TRUE
[10:32:50.926] - signal: TRUE
[10:32:50.926] - resignal: FALSE
[10:32:50.926] - force: TRUE
[10:32:50.926] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.926]  - until=5
[10:32:50.926]  - relaying element #5
[10:32:50.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.927] signalConditionsASAP(NULL, pos=4) ... done
[10:32:50.927]  length: 2 (resolved future 4)
[10:32:50.927] signalConditionsASAP(NULL, pos=5) ...
[10:32:50.927] - nx: 6
[10:32:50.927] - relay: TRUE
[10:32:50.929] - stdout: TRUE
[10:32:50.929] - signal: TRUE
[10:32:50.930] - resignal: FALSE
[10:32:50.930] - force: TRUE
[10:32:50.930] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:50.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.930]  - until=6
[10:32:50.930]  - relaying element #6
[10:32:50.930] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.931] signalConditionsASAP(NULL, pos=5) ... done
[10:32:50.931]  length: 1 (resolved future 5)
[10:32:50.931] signalConditionsASAP(numeric, pos=6) ...
[10:32:50.931] - nx: 6
[10:32:50.931] - relay: TRUE
[10:32:50.931] - stdout: TRUE
[10:32:50.932] - signal: TRUE
[10:32:50.932] - resignal: FALSE
[10:32:50.932] - force: TRUE
[10:32:50.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:50.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.932]  - until=6
[10:32:50.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.932] signalConditionsASAP(numeric, pos=6) ... done
[10:32:50.933]  length: 0 (resolved future 6)
[10:32:50.933] Relaying remaining futures
[10:32:50.933] signalConditionsASAP(NULL, pos=0) ...
[10:32:50.933] - nx: 6
[10:32:50.933] - relay: TRUE
[10:32:50.933] - stdout: TRUE
[10:32:50.933] - signal: TRUE
[10:32:50.933] - resignal: FALSE
[10:32:50.933] - force: TRUE
[10:32:50.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.934] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:50.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:50.934] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:50.934] signalConditionsASAP(NULL, pos=0) ... done
[10:32:50.934] resolve() on list ... DONE
[10:32:50.934] result() for MulticoreFuture ...
[10:32:50.934] result() for MulticoreFuture ... done
[10:32:50.935] result() for MulticoreFuture ...
[10:32:50.935] result() for MulticoreFuture ... done
[10:32:50.935] result() for MulticoreFuture ...
[10:32:50.935] result() for MulticoreFuture ... done
[10:32:50.935] result() for MulticoreFuture ...
[10:32:50.935] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:32:50.939] getGlobalsAndPackages() ...
[10:32:50.939] Searching for globals...
[10:32:50.939] 
[10:32:50.940] Searching for globals ... DONE
[10:32:50.940] - globals: [0] <none>
[10:32:50.940] getGlobalsAndPackages() ... DONE
[10:32:50.940] run() for ‘Future’ ...
[10:32:50.940] - state: ‘created’
[10:32:50.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.944]   - Field: ‘label’
[10:32:50.944]   - Field: ‘local’
[10:32:50.944]   - Field: ‘owner’
[10:32:50.945]   - Field: ‘envir’
[10:32:50.945]   - Field: ‘workers’
[10:32:50.945]   - Field: ‘packages’
[10:32:50.945]   - Field: ‘gc’
[10:32:50.945]   - Field: ‘job’
[10:32:50.945]   - Field: ‘conditions’
[10:32:50.945]   - Field: ‘expr’
[10:32:50.945]   - Field: ‘uuid’
[10:32:50.945]   - Field: ‘seed’
[10:32:50.945]   - Field: ‘version’
[10:32:50.945]   - Field: ‘result’
[10:32:50.946]   - Field: ‘asynchronous’
[10:32:50.946]   - Field: ‘calls’
[10:32:50.946]   - Field: ‘globals’
[10:32:50.946]   - Field: ‘stdout’
[10:32:50.946]   - Field: ‘earlySignal’
[10:32:50.946]   - Field: ‘lazy’
[10:32:50.946]   - Field: ‘state’
[10:32:50.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.946] - Launch lazy future ...
[10:32:50.947] Packages needed by the future expression (n = 0): <none>
[10:32:50.947] Packages needed by future strategies (n = 0): <none>
[10:32:50.947] {
[10:32:50.947]     {
[10:32:50.947]         {
[10:32:50.947]             ...future.startTime <- base::Sys.time()
[10:32:50.947]             {
[10:32:50.947]                 {
[10:32:50.947]                   {
[10:32:50.947]                     {
[10:32:50.947]                       base::local({
[10:32:50.947]                         has_future <- base::requireNamespace("future", 
[10:32:50.947]                           quietly = TRUE)
[10:32:50.947]                         if (has_future) {
[10:32:50.947]                           ns <- base::getNamespace("future")
[10:32:50.947]                           version <- ns[[".package"]][["version"]]
[10:32:50.947]                           if (is.null(version)) 
[10:32:50.947]                             version <- utils::packageVersion("future")
[10:32:50.947]                         }
[10:32:50.947]                         else {
[10:32:50.947]                           version <- NULL
[10:32:50.947]                         }
[10:32:50.947]                         if (!has_future || version < "1.8.0") {
[10:32:50.947]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.947]                             "", base::R.version$version.string), 
[10:32:50.947]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.947]                               "release", "version")], collapse = " "), 
[10:32:50.947]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.947]                             info)
[10:32:50.947]                           info <- base::paste(info, collapse = "; ")
[10:32:50.947]                           if (!has_future) {
[10:32:50.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.947]                               info)
[10:32:50.947]                           }
[10:32:50.947]                           else {
[10:32:50.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.947]                               info, version)
[10:32:50.947]                           }
[10:32:50.947]                           base::stop(msg)
[10:32:50.947]                         }
[10:32:50.947]                       })
[10:32:50.947]                     }
[10:32:50.947]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.947]                     base::options(mc.cores = 1L)
[10:32:50.947]                   }
[10:32:50.947]                   ...future.strategy.old <- future::plan("list")
[10:32:50.947]                   options(future.plan = NULL)
[10:32:50.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.947]                 }
[10:32:50.947]                 ...future.workdir <- getwd()
[10:32:50.947]             }
[10:32:50.947]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.947]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.947]         }
[10:32:50.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.947]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.947]             base::names(...future.oldOptions))
[10:32:50.947]     }
[10:32:50.947]     if (FALSE) {
[10:32:50.947]     }
[10:32:50.947]     else {
[10:32:50.947]         if (TRUE) {
[10:32:50.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.947]                 open = "w")
[10:32:50.947]         }
[10:32:50.947]         else {
[10:32:50.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.947]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.947]         }
[10:32:50.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.947]             base::sink(type = "output", split = FALSE)
[10:32:50.947]             base::close(...future.stdout)
[10:32:50.947]         }, add = TRUE)
[10:32:50.947]     }
[10:32:50.947]     ...future.frame <- base::sys.nframe()
[10:32:50.947]     ...future.conditions <- base::list()
[10:32:50.947]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.947]     if (FALSE) {
[10:32:50.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.947]     }
[10:32:50.947]     ...future.result <- base::tryCatch({
[10:32:50.947]         base::withCallingHandlers({
[10:32:50.947]             ...future.value <- base::withVisible(base::local({
[10:32:50.947]                 withCallingHandlers({
[10:32:50.947]                   2
[10:32:50.947]                 }, immediateCondition = function(cond) {
[10:32:50.947]                   save_rds <- function (object, pathname, ...) 
[10:32:50.947]                   {
[10:32:50.947]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.947]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.947]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.947]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.947]                         fi_tmp[["mtime"]])
[10:32:50.947]                     }
[10:32:50.947]                     tryCatch({
[10:32:50.947]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.947]                     }, error = function(ex) {
[10:32:50.947]                       msg <- conditionMessage(ex)
[10:32:50.947]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.947]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.947]                         fi_tmp[["mtime"]], msg)
[10:32:50.947]                       ex$message <- msg
[10:32:50.947]                       stop(ex)
[10:32:50.947]                     })
[10:32:50.947]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.947]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.947]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.947]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.947]                       fi <- file.info(pathname)
[10:32:50.947]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.947]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.947]                         fi[["size"]], fi[["mtime"]])
[10:32:50.947]                       stop(msg)
[10:32:50.947]                     }
[10:32:50.947]                     invisible(pathname)
[10:32:50.947]                   }
[10:32:50.947]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.947]                     rootPath = tempdir()) 
[10:32:50.947]                   {
[10:32:50.947]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.947]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.947]                       tmpdir = path, fileext = ".rds")
[10:32:50.947]                     save_rds(obj, file)
[10:32:50.947]                   }
[10:32:50.947]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.947]                   {
[10:32:50.947]                     inherits <- base::inherits
[10:32:50.947]                     invokeRestart <- base::invokeRestart
[10:32:50.947]                     is.null <- base::is.null
[10:32:50.947]                     muffled <- FALSE
[10:32:50.947]                     if (inherits(cond, "message")) {
[10:32:50.947]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.947]                       if (muffled) 
[10:32:50.947]                         invokeRestart("muffleMessage")
[10:32:50.947]                     }
[10:32:50.947]                     else if (inherits(cond, "warning")) {
[10:32:50.947]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.947]                       if (muffled) 
[10:32:50.947]                         invokeRestart("muffleWarning")
[10:32:50.947]                     }
[10:32:50.947]                     else if (inherits(cond, "condition")) {
[10:32:50.947]                       if (!is.null(pattern)) {
[10:32:50.947]                         computeRestarts <- base::computeRestarts
[10:32:50.947]                         grepl <- base::grepl
[10:32:50.947]                         restarts <- computeRestarts(cond)
[10:32:50.947]                         for (restart in restarts) {
[10:32:50.947]                           name <- restart$name
[10:32:50.947]                           if (is.null(name)) 
[10:32:50.947]                             next
[10:32:50.947]                           if (!grepl(pattern, name)) 
[10:32:50.947]                             next
[10:32:50.947]                           invokeRestart(restart)
[10:32:50.947]                           muffled <- TRUE
[10:32:50.947]                           break
[10:32:50.947]                         }
[10:32:50.947]                       }
[10:32:50.947]                     }
[10:32:50.947]                     invisible(muffled)
[10:32:50.947]                   }
[10:32:50.947]                   muffleCondition(cond)
[10:32:50.947]                 })
[10:32:50.947]             }))
[10:32:50.947]             future::FutureResult(value = ...future.value$value, 
[10:32:50.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.947]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.947]                     ...future.globalenv.names))
[10:32:50.947]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.947]         }, condition = base::local({
[10:32:50.947]             c <- base::c
[10:32:50.947]             inherits <- base::inherits
[10:32:50.947]             invokeRestart <- base::invokeRestart
[10:32:50.947]             length <- base::length
[10:32:50.947]             list <- base::list
[10:32:50.947]             seq.int <- base::seq.int
[10:32:50.947]             signalCondition <- base::signalCondition
[10:32:50.947]             sys.calls <- base::sys.calls
[10:32:50.947]             `[[` <- base::`[[`
[10:32:50.947]             `+` <- base::`+`
[10:32:50.947]             `<<-` <- base::`<<-`
[10:32:50.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.947]                   3L)]
[10:32:50.947]             }
[10:32:50.947]             function(cond) {
[10:32:50.947]                 is_error <- inherits(cond, "error")
[10:32:50.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.947]                   NULL)
[10:32:50.947]                 if (is_error) {
[10:32:50.947]                   sessionInformation <- function() {
[10:32:50.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.947]                       search = base::search(), system = base::Sys.info())
[10:32:50.947]                   }
[10:32:50.947]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.947]                     cond$call), session = sessionInformation(), 
[10:32:50.947]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.947]                   signalCondition(cond)
[10:32:50.947]                 }
[10:32:50.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.947]                 "immediateCondition"))) {
[10:32:50.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.947]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.947]                   if (TRUE && !signal) {
[10:32:50.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.947]                     {
[10:32:50.947]                       inherits <- base::inherits
[10:32:50.947]                       invokeRestart <- base::invokeRestart
[10:32:50.947]                       is.null <- base::is.null
[10:32:50.947]                       muffled <- FALSE
[10:32:50.947]                       if (inherits(cond, "message")) {
[10:32:50.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.947]                         if (muffled) 
[10:32:50.947]                           invokeRestart("muffleMessage")
[10:32:50.947]                       }
[10:32:50.947]                       else if (inherits(cond, "warning")) {
[10:32:50.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.947]                         if (muffled) 
[10:32:50.947]                           invokeRestart("muffleWarning")
[10:32:50.947]                       }
[10:32:50.947]                       else if (inherits(cond, "condition")) {
[10:32:50.947]                         if (!is.null(pattern)) {
[10:32:50.947]                           computeRestarts <- base::computeRestarts
[10:32:50.947]                           grepl <- base::grepl
[10:32:50.947]                           restarts <- computeRestarts(cond)
[10:32:50.947]                           for (restart in restarts) {
[10:32:50.947]                             name <- restart$name
[10:32:50.947]                             if (is.null(name)) 
[10:32:50.947]                               next
[10:32:50.947]                             if (!grepl(pattern, name)) 
[10:32:50.947]                               next
[10:32:50.947]                             invokeRestart(restart)
[10:32:50.947]                             muffled <- TRUE
[10:32:50.947]                             break
[10:32:50.947]                           }
[10:32:50.947]                         }
[10:32:50.947]                       }
[10:32:50.947]                       invisible(muffled)
[10:32:50.947]                     }
[10:32:50.947]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.947]                   }
[10:32:50.947]                 }
[10:32:50.947]                 else {
[10:32:50.947]                   if (TRUE) {
[10:32:50.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.947]                     {
[10:32:50.947]                       inherits <- base::inherits
[10:32:50.947]                       invokeRestart <- base::invokeRestart
[10:32:50.947]                       is.null <- base::is.null
[10:32:50.947]                       muffled <- FALSE
[10:32:50.947]                       if (inherits(cond, "message")) {
[10:32:50.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.947]                         if (muffled) 
[10:32:50.947]                           invokeRestart("muffleMessage")
[10:32:50.947]                       }
[10:32:50.947]                       else if (inherits(cond, "warning")) {
[10:32:50.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.947]                         if (muffled) 
[10:32:50.947]                           invokeRestart("muffleWarning")
[10:32:50.947]                       }
[10:32:50.947]                       else if (inherits(cond, "condition")) {
[10:32:50.947]                         if (!is.null(pattern)) {
[10:32:50.947]                           computeRestarts <- base::computeRestarts
[10:32:50.947]                           grepl <- base::grepl
[10:32:50.947]                           restarts <- computeRestarts(cond)
[10:32:50.947]                           for (restart in restarts) {
[10:32:50.947]                             name <- restart$name
[10:32:50.947]                             if (is.null(name)) 
[10:32:50.947]                               next
[10:32:50.947]                             if (!grepl(pattern, name)) 
[10:32:50.947]                               next
[10:32:50.947]                             invokeRestart(restart)
[10:32:50.947]                             muffled <- TRUE
[10:32:50.947]                             break
[10:32:50.947]                           }
[10:32:50.947]                         }
[10:32:50.947]                       }
[10:32:50.947]                       invisible(muffled)
[10:32:50.947]                     }
[10:32:50.947]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.947]                   }
[10:32:50.947]                 }
[10:32:50.947]             }
[10:32:50.947]         }))
[10:32:50.947]     }, error = function(ex) {
[10:32:50.947]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.947]                 ...future.rng), started = ...future.startTime, 
[10:32:50.947]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.947]             version = "1.8"), class = "FutureResult")
[10:32:50.947]     }, finally = {
[10:32:50.947]         if (!identical(...future.workdir, getwd())) 
[10:32:50.947]             setwd(...future.workdir)
[10:32:50.947]         {
[10:32:50.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.947]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.947]             }
[10:32:50.947]             base::options(...future.oldOptions)
[10:32:50.947]             if (.Platform$OS.type == "windows") {
[10:32:50.947]                 old_names <- names(...future.oldEnvVars)
[10:32:50.947]                 envs <- base::Sys.getenv()
[10:32:50.947]                 names <- names(envs)
[10:32:50.947]                 common <- intersect(names, old_names)
[10:32:50.947]                 added <- setdiff(names, old_names)
[10:32:50.947]                 removed <- setdiff(old_names, names)
[10:32:50.947]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.947]                   envs[common]]
[10:32:50.947]                 NAMES <- toupper(changed)
[10:32:50.947]                 args <- list()
[10:32:50.947]                 for (kk in seq_along(NAMES)) {
[10:32:50.947]                   name <- changed[[kk]]
[10:32:50.947]                   NAME <- NAMES[[kk]]
[10:32:50.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.947]                     next
[10:32:50.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.947]                 }
[10:32:50.947]                 NAMES <- toupper(added)
[10:32:50.947]                 for (kk in seq_along(NAMES)) {
[10:32:50.947]                   name <- added[[kk]]
[10:32:50.947]                   NAME <- NAMES[[kk]]
[10:32:50.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.947]                     next
[10:32:50.947]                   args[[name]] <- ""
[10:32:50.947]                 }
[10:32:50.947]                 NAMES <- toupper(removed)
[10:32:50.947]                 for (kk in seq_along(NAMES)) {
[10:32:50.947]                   name <- removed[[kk]]
[10:32:50.947]                   NAME <- NAMES[[kk]]
[10:32:50.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.947]                     next
[10:32:50.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.947]                 }
[10:32:50.947]                 if (length(args) > 0) 
[10:32:50.947]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.947]             }
[10:32:50.947]             else {
[10:32:50.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.947]             }
[10:32:50.947]             {
[10:32:50.947]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.947]                   0L) {
[10:32:50.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.947]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.947]                   base::options(opts)
[10:32:50.947]                 }
[10:32:50.947]                 {
[10:32:50.947]                   {
[10:32:50.947]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.947]                     NULL
[10:32:50.947]                   }
[10:32:50.947]                   options(future.plan = NULL)
[10:32:50.947]                   if (is.na(NA_character_)) 
[10:32:50.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.947]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.947]                     .init = FALSE)
[10:32:50.947]                 }
[10:32:50.947]             }
[10:32:50.947]         }
[10:32:50.947]     })
[10:32:50.947]     if (TRUE) {
[10:32:50.947]         base::sink(type = "output", split = FALSE)
[10:32:50.947]         if (TRUE) {
[10:32:50.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.947]         }
[10:32:50.947]         else {
[10:32:50.947]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.947]         }
[10:32:50.947]         base::close(...future.stdout)
[10:32:50.947]         ...future.stdout <- NULL
[10:32:50.947]     }
[10:32:50.947]     ...future.result$conditions <- ...future.conditions
[10:32:50.947]     ...future.result$finished <- base::Sys.time()
[10:32:50.947]     ...future.result
[10:32:50.947] }
[10:32:50.949] requestCore(): workers = 2
[10:32:50.951] MulticoreFuture started
[10:32:50.952] - Launch lazy future ... done
[10:32:50.952] run() for ‘MulticoreFuture’ ... done
[10:32:50.952] getGlobalsAndPackages() ...
[10:32:50.952] Searching for globals...
[10:32:50.952] plan(): Setting new future strategy stack:
[10:32:50.953] 
[10:32:50.953] List of future strategies:
[10:32:50.953] 1. sequential:
[10:32:50.953]    - args: function (..., envir = parent.frame())
[10:32:50.953]    - tweaked: FALSE
[10:32:50.953]    - call: NULL
[10:32:50.953] Searching for globals ... DONE
[10:32:50.953] - globals: [0] <none>
[10:32:50.953] plan(): nbrOfWorkers() = 1
[10:32:50.954] getGlobalsAndPackages() ... DONE
[10:32:50.954] run() for ‘Future’ ...
[10:32:50.954] - state: ‘created’
[10:32:50.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:50.955] plan(): Setting new future strategy stack:
[10:32:50.956] List of future strategies:
[10:32:50.956] 1. multicore:
[10:32:50.956]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.956]    - tweaked: FALSE
[10:32:50.956]    - call: plan(strategy)
[10:32:50.960] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:50.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:50.960] plan(): nbrOfWorkers() = 2
[10:32:50.960]   - Field: ‘label’
[10:32:50.960]   - Field: ‘local’
[10:32:50.960]   - Field: ‘owner’
[10:32:50.961]   - Field: ‘envir’
[10:32:50.961]   - Field: ‘workers’
[10:32:50.961]   - Field: ‘packages’
[10:32:50.961]   - Field: ‘gc’
[10:32:50.961]   - Field: ‘job’
[10:32:50.961]   - Field: ‘conditions’
[10:32:50.962]   - Field: ‘expr’
[10:32:50.962]   - Field: ‘uuid’
[10:32:50.962]   - Field: ‘seed’
[10:32:50.962]   - Field: ‘version’
[10:32:50.962]   - Field: ‘result’
[10:32:50.962]   - Field: ‘asynchronous’
[10:32:50.962]   - Field: ‘calls’
[10:32:50.963]   - Field: ‘globals’
[10:32:50.963]   - Field: ‘stdout’
[10:32:50.963]   - Field: ‘earlySignal’
[10:32:50.963]   - Field: ‘lazy’
[10:32:50.963]   - Field: ‘state’
[10:32:50.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:50.963] - Launch lazy future ...
[10:32:50.964] Packages needed by the future expression (n = 0): <none>
[10:32:50.964] Packages needed by future strategies (n = 0): <none>
[10:32:50.965] {
[10:32:50.965]     {
[10:32:50.965]         {
[10:32:50.965]             ...future.startTime <- base::Sys.time()
[10:32:50.965]             {
[10:32:50.965]                 {
[10:32:50.965]                   {
[10:32:50.965]                     {
[10:32:50.965]                       base::local({
[10:32:50.965]                         has_future <- base::requireNamespace("future", 
[10:32:50.965]                           quietly = TRUE)
[10:32:50.965]                         if (has_future) {
[10:32:50.965]                           ns <- base::getNamespace("future")
[10:32:50.965]                           version <- ns[[".package"]][["version"]]
[10:32:50.965]                           if (is.null(version)) 
[10:32:50.965]                             version <- utils::packageVersion("future")
[10:32:50.965]                         }
[10:32:50.965]                         else {
[10:32:50.965]                           version <- NULL
[10:32:50.965]                         }
[10:32:50.965]                         if (!has_future || version < "1.8.0") {
[10:32:50.965]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:50.965]                             "", base::R.version$version.string), 
[10:32:50.965]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:50.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:50.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:50.965]                               "release", "version")], collapse = " "), 
[10:32:50.965]                             hostname = base::Sys.info()[["nodename"]])
[10:32:50.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:50.965]                             info)
[10:32:50.965]                           info <- base::paste(info, collapse = "; ")
[10:32:50.965]                           if (!has_future) {
[10:32:50.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:50.965]                               info)
[10:32:50.965]                           }
[10:32:50.965]                           else {
[10:32:50.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:50.965]                               info, version)
[10:32:50.965]                           }
[10:32:50.965]                           base::stop(msg)
[10:32:50.965]                         }
[10:32:50.965]                       })
[10:32:50.965]                     }
[10:32:50.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:50.965]                     base::options(mc.cores = 1L)
[10:32:50.965]                   }
[10:32:50.965]                   ...future.strategy.old <- future::plan("list")
[10:32:50.965]                   options(future.plan = NULL)
[10:32:50.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:50.965]                 }
[10:32:50.965]                 ...future.workdir <- getwd()
[10:32:50.965]             }
[10:32:50.965]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:50.965]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:50.965]         }
[10:32:50.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:50.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:50.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:50.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:50.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:50.965]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:50.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:50.965]             base::names(...future.oldOptions))
[10:32:50.965]     }
[10:32:50.965]     if (FALSE) {
[10:32:50.965]     }
[10:32:50.965]     else {
[10:32:50.965]         if (TRUE) {
[10:32:50.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:50.965]                 open = "w")
[10:32:50.965]         }
[10:32:50.965]         else {
[10:32:50.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:50.965]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:50.965]         }
[10:32:50.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:50.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:50.965]             base::sink(type = "output", split = FALSE)
[10:32:50.965]             base::close(...future.stdout)
[10:32:50.965]         }, add = TRUE)
[10:32:50.965]     }
[10:32:50.965]     ...future.frame <- base::sys.nframe()
[10:32:50.965]     ...future.conditions <- base::list()
[10:32:50.965]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:50.965]     if (FALSE) {
[10:32:50.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:50.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:50.965]     }
[10:32:50.965]     ...future.result <- base::tryCatch({
[10:32:50.965]         base::withCallingHandlers({
[10:32:50.965]             ...future.value <- base::withVisible(base::local({
[10:32:50.965]                 withCallingHandlers({
[10:32:50.965]                   NULL
[10:32:50.965]                 }, immediateCondition = function(cond) {
[10:32:50.965]                   save_rds <- function (object, pathname, ...) 
[10:32:50.965]                   {
[10:32:50.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:50.965]                     if (file_test("-f", pathname_tmp)) {
[10:32:50.965]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:50.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.965]                         fi_tmp[["mtime"]])
[10:32:50.965]                     }
[10:32:50.965]                     tryCatch({
[10:32:50.965]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:50.965]                     }, error = function(ex) {
[10:32:50.965]                       msg <- conditionMessage(ex)
[10:32:50.965]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:50.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.965]                         fi_tmp[["mtime"]], msg)
[10:32:50.965]                       ex$message <- msg
[10:32:50.965]                       stop(ex)
[10:32:50.965]                     })
[10:32:50.965]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:50.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:50.965]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:50.965]                       fi_tmp <- file.info(pathname_tmp)
[10:32:50.965]                       fi <- file.info(pathname)
[10:32:50.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:50.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:50.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:50.965]                         fi[["size"]], fi[["mtime"]])
[10:32:50.965]                       stop(msg)
[10:32:50.965]                     }
[10:32:50.965]                     invisible(pathname)
[10:32:50.965]                   }
[10:32:50.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:50.965]                     rootPath = tempdir()) 
[10:32:50.965]                   {
[10:32:50.965]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:50.965]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:50.965]                       tmpdir = path, fileext = ".rds")
[10:32:50.965]                     save_rds(obj, file)
[10:32:50.965]                   }
[10:32:50.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:50.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.965]                   {
[10:32:50.965]                     inherits <- base::inherits
[10:32:50.965]                     invokeRestart <- base::invokeRestart
[10:32:50.965]                     is.null <- base::is.null
[10:32:50.965]                     muffled <- FALSE
[10:32:50.965]                     if (inherits(cond, "message")) {
[10:32:50.965]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:50.965]                       if (muffled) 
[10:32:50.965]                         invokeRestart("muffleMessage")
[10:32:50.965]                     }
[10:32:50.965]                     else if (inherits(cond, "warning")) {
[10:32:50.965]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:50.965]                       if (muffled) 
[10:32:50.965]                         invokeRestart("muffleWarning")
[10:32:50.965]                     }
[10:32:50.965]                     else if (inherits(cond, "condition")) {
[10:32:50.965]                       if (!is.null(pattern)) {
[10:32:50.965]                         computeRestarts <- base::computeRestarts
[10:32:50.965]                         grepl <- base::grepl
[10:32:50.965]                         restarts <- computeRestarts(cond)
[10:32:50.965]                         for (restart in restarts) {
[10:32:50.965]                           name <- restart$name
[10:32:50.965]                           if (is.null(name)) 
[10:32:50.965]                             next
[10:32:50.965]                           if (!grepl(pattern, name)) 
[10:32:50.965]                             next
[10:32:50.965]                           invokeRestart(restart)
[10:32:50.965]                           muffled <- TRUE
[10:32:50.965]                           break
[10:32:50.965]                         }
[10:32:50.965]                       }
[10:32:50.965]                     }
[10:32:50.965]                     invisible(muffled)
[10:32:50.965]                   }
[10:32:50.965]                   muffleCondition(cond)
[10:32:50.965]                 })
[10:32:50.965]             }))
[10:32:50.965]             future::FutureResult(value = ...future.value$value, 
[10:32:50.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.965]                   ...future.rng), globalenv = if (FALSE) 
[10:32:50.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:50.965]                     ...future.globalenv.names))
[10:32:50.965]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:50.965]         }, condition = base::local({
[10:32:50.965]             c <- base::c
[10:32:50.965]             inherits <- base::inherits
[10:32:50.965]             invokeRestart <- base::invokeRestart
[10:32:50.965]             length <- base::length
[10:32:50.965]             list <- base::list
[10:32:50.965]             seq.int <- base::seq.int
[10:32:50.965]             signalCondition <- base::signalCondition
[10:32:50.965]             sys.calls <- base::sys.calls
[10:32:50.965]             `[[` <- base::`[[`
[10:32:50.965]             `+` <- base::`+`
[10:32:50.965]             `<<-` <- base::`<<-`
[10:32:50.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:50.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:50.965]                   3L)]
[10:32:50.965]             }
[10:32:50.965]             function(cond) {
[10:32:50.965]                 is_error <- inherits(cond, "error")
[10:32:50.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:50.965]                   NULL)
[10:32:50.965]                 if (is_error) {
[10:32:50.965]                   sessionInformation <- function() {
[10:32:50.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:50.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:50.965]                       search = base::search(), system = base::Sys.info())
[10:32:50.965]                   }
[10:32:50.965]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:50.965]                     cond$call), session = sessionInformation(), 
[10:32:50.965]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:50.965]                   signalCondition(cond)
[10:32:50.965]                 }
[10:32:50.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:50.965]                 "immediateCondition"))) {
[10:32:50.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:50.965]                   ...future.conditions[[length(...future.conditions) + 
[10:32:50.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:50.965]                   if (TRUE && !signal) {
[10:32:50.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.965]                     {
[10:32:50.965]                       inherits <- base::inherits
[10:32:50.965]                       invokeRestart <- base::invokeRestart
[10:32:50.965]                       is.null <- base::is.null
[10:32:50.965]                       muffled <- FALSE
[10:32:50.965]                       if (inherits(cond, "message")) {
[10:32:50.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.965]                         if (muffled) 
[10:32:50.965]                           invokeRestart("muffleMessage")
[10:32:50.965]                       }
[10:32:50.965]                       else if (inherits(cond, "warning")) {
[10:32:50.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.965]                         if (muffled) 
[10:32:50.965]                           invokeRestart("muffleWarning")
[10:32:50.965]                       }
[10:32:50.965]                       else if (inherits(cond, "condition")) {
[10:32:50.965]                         if (!is.null(pattern)) {
[10:32:50.965]                           computeRestarts <- base::computeRestarts
[10:32:50.965]                           grepl <- base::grepl
[10:32:50.965]                           restarts <- computeRestarts(cond)
[10:32:50.965]                           for (restart in restarts) {
[10:32:50.965]                             name <- restart$name
[10:32:50.965]                             if (is.null(name)) 
[10:32:50.965]                               next
[10:32:50.965]                             if (!grepl(pattern, name)) 
[10:32:50.965]                               next
[10:32:50.965]                             invokeRestart(restart)
[10:32:50.965]                             muffled <- TRUE
[10:32:50.965]                             break
[10:32:50.965]                           }
[10:32:50.965]                         }
[10:32:50.965]                       }
[10:32:50.965]                       invisible(muffled)
[10:32:50.965]                     }
[10:32:50.965]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.965]                   }
[10:32:50.965]                 }
[10:32:50.965]                 else {
[10:32:50.965]                   if (TRUE) {
[10:32:50.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:50.965]                     {
[10:32:50.965]                       inherits <- base::inherits
[10:32:50.965]                       invokeRestart <- base::invokeRestart
[10:32:50.965]                       is.null <- base::is.null
[10:32:50.965]                       muffled <- FALSE
[10:32:50.965]                       if (inherits(cond, "message")) {
[10:32:50.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:50.965]                         if (muffled) 
[10:32:50.965]                           invokeRestart("muffleMessage")
[10:32:50.965]                       }
[10:32:50.965]                       else if (inherits(cond, "warning")) {
[10:32:50.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:50.965]                         if (muffled) 
[10:32:50.965]                           invokeRestart("muffleWarning")
[10:32:50.965]                       }
[10:32:50.965]                       else if (inherits(cond, "condition")) {
[10:32:50.965]                         if (!is.null(pattern)) {
[10:32:50.965]                           computeRestarts <- base::computeRestarts
[10:32:50.965]                           grepl <- base::grepl
[10:32:50.965]                           restarts <- computeRestarts(cond)
[10:32:50.965]                           for (restart in restarts) {
[10:32:50.965]                             name <- restart$name
[10:32:50.965]                             if (is.null(name)) 
[10:32:50.965]                               next
[10:32:50.965]                             if (!grepl(pattern, name)) 
[10:32:50.965]                               next
[10:32:50.965]                             invokeRestart(restart)
[10:32:50.965]                             muffled <- TRUE
[10:32:50.965]                             break
[10:32:50.965]                           }
[10:32:50.965]                         }
[10:32:50.965]                       }
[10:32:50.965]                       invisible(muffled)
[10:32:50.965]                     }
[10:32:50.965]                     muffleCondition(cond, pattern = "^muffle")
[10:32:50.965]                   }
[10:32:50.965]                 }
[10:32:50.965]             }
[10:32:50.965]         }))
[10:32:50.965]     }, error = function(ex) {
[10:32:50.965]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:50.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:50.965]                 ...future.rng), started = ...future.startTime, 
[10:32:50.965]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:50.965]             version = "1.8"), class = "FutureResult")
[10:32:50.965]     }, finally = {
[10:32:50.965]         if (!identical(...future.workdir, getwd())) 
[10:32:50.965]             setwd(...future.workdir)
[10:32:50.965]         {
[10:32:50.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:50.965]                 ...future.oldOptions$nwarnings <- NULL
[10:32:50.965]             }
[10:32:50.965]             base::options(...future.oldOptions)
[10:32:50.965]             if (.Platform$OS.type == "windows") {
[10:32:50.965]                 old_names <- names(...future.oldEnvVars)
[10:32:50.965]                 envs <- base::Sys.getenv()
[10:32:50.965]                 names <- names(envs)
[10:32:50.965]                 common <- intersect(names, old_names)
[10:32:50.965]                 added <- setdiff(names, old_names)
[10:32:50.965]                 removed <- setdiff(old_names, names)
[10:32:50.965]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:50.965]                   envs[common]]
[10:32:50.965]                 NAMES <- toupper(changed)
[10:32:50.965]                 args <- list()
[10:32:50.965]                 for (kk in seq_along(NAMES)) {
[10:32:50.965]                   name <- changed[[kk]]
[10:32:50.965]                   NAME <- NAMES[[kk]]
[10:32:50.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.965]                     next
[10:32:50.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.965]                 }
[10:32:50.965]                 NAMES <- toupper(added)
[10:32:50.965]                 for (kk in seq_along(NAMES)) {
[10:32:50.965]                   name <- added[[kk]]
[10:32:50.965]                   NAME <- NAMES[[kk]]
[10:32:50.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.965]                     next
[10:32:50.965]                   args[[name]] <- ""
[10:32:50.965]                 }
[10:32:50.965]                 NAMES <- toupper(removed)
[10:32:50.965]                 for (kk in seq_along(NAMES)) {
[10:32:50.965]                   name <- removed[[kk]]
[10:32:50.965]                   NAME <- NAMES[[kk]]
[10:32:50.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:50.965]                     next
[10:32:50.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:50.965]                 }
[10:32:50.965]                 if (length(args) > 0) 
[10:32:50.965]                   base::do.call(base::Sys.setenv, args = args)
[10:32:50.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:50.965]             }
[10:32:50.965]             else {
[10:32:50.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:50.965]             }
[10:32:50.965]             {
[10:32:50.965]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:50.965]                   0L) {
[10:32:50.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:50.965]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:50.965]                   base::options(opts)
[10:32:50.965]                 }
[10:32:50.965]                 {
[10:32:50.965]                   {
[10:32:50.965]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:50.965]                     NULL
[10:32:50.965]                   }
[10:32:50.965]                   options(future.plan = NULL)
[10:32:50.965]                   if (is.na(NA_character_)) 
[10:32:50.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:50.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:50.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:50.965]                     .init = FALSE)
[10:32:50.965]                 }
[10:32:50.965]             }
[10:32:50.965]         }
[10:32:50.965]     })
[10:32:50.965]     if (TRUE) {
[10:32:50.965]         base::sink(type = "output", split = FALSE)
[10:32:50.965]         if (TRUE) {
[10:32:50.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:50.965]         }
[10:32:50.965]         else {
[10:32:50.965]             ...future.result["stdout"] <- base::list(NULL)
[10:32:50.965]         }
[10:32:50.965]         base::close(...future.stdout)
[10:32:50.965]         ...future.stdout <- NULL
[10:32:50.965]     }
[10:32:50.965]     ...future.result$conditions <- ...future.conditions
[10:32:50.965]     ...future.result$finished <- base::Sys.time()
[10:32:50.965]     ...future.result
[10:32:50.965] }
[10:32:50.969] requestCore(): workers = 2
[10:32:50.971] MulticoreFuture started
[10:32:50.971] - Launch lazy future ... done
[10:32:50.971] run() for ‘MulticoreFuture’ ... done
List of 6
[10:32:50.972] plan(): Setting new future strategy stack:
 $ a:[10:32:50.972] List of future strategies:
[10:32:50.972] 1. sequential:
[10:32:50.972]    - args: function (..., envir = parent.frame())
[10:32:50.972]    - tweaked: FALSE
[10:32:50.972]    - call: NULL
 num 1
 $ b:[10:32:50.973] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d08f3898> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0df0000> 
 $  : NULL
 $  : NULL
 $  :[10:32:50.975] plan(): Setting new future strategy stack:
[10:32:50.975] List of future strategies:
[10:32:50.975] 1. multicore:
[10:32:50.975]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:50.975]    - tweaked: FALSE
[10:32:50.975]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d08f3898> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0df0000> 
 $  : NULL
 $  : NULL
 $  :[10:32:50.985] plan(): nbrOfWorkers() = 2
 num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:50.992] resolve() on list ...
[10:32:50.992]  recursive: 0
[10:32:50.992]  length: 6
[10:32:50.993]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:50.993] signalConditionsASAP(numeric, pos=1) ...
[10:32:50.993] - nx: 6
[10:32:50.993] - relay: TRUE
[10:32:50.993] - stdout: TRUE
[10:32:50.993] - signal: TRUE
[10:32:50.994] - resignal: FALSE
[10:32:50.994] - force: TRUE
[10:32:50.994] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.994] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.994]  - until=2
[10:32:50.994]  - relaying element #2
[10:32:50.994] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.994] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.995] signalConditionsASAP(NULL, pos=1) ... done
[10:32:50.995]  length: 5 (resolved future 1)
[10:32:50.995] Future #2
[10:32:50.995] result() for MulticoreFuture ...
[10:32:50.996] result() for MulticoreFuture ...
[10:32:50.996] result() for MulticoreFuture ... done
[10:32:50.996] result() for MulticoreFuture ... done
[10:32:50.996] result() for MulticoreFuture ...
[10:32:50.997] result() for MulticoreFuture ... done
[10:32:50.997] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:50.997] - nx: 6
[10:32:50.997] - relay: TRUE
[10:32:50.997] - stdout: TRUE
[10:32:50.997] - signal: TRUE
[10:32:50.997] - resignal: FALSE
[10:32:50.997] - force: TRUE
[10:32:50.998] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.998] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:50.998]  - until=2
[10:32:50.998]  - relaying element #2
[10:32:50.998] result() for MulticoreFuture ...
[10:32:50.998] result() for MulticoreFuture ... done
[10:32:50.998] result() for MulticoreFuture ...
[10:32:50.999] result() for MulticoreFuture ... done
[10:32:50.999] result() for MulticoreFuture ...
[10:32:50.999] result() for MulticoreFuture ... done
[10:32:50.999] result() for MulticoreFuture ...
[10:32:50.999] result() for MulticoreFuture ... done
[10:32:50.999] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.999] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:50.999] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:51.000]  length: 4 (resolved future 2)
[10:32:51.000] Future #3
[10:32:51.000] result() for MulticoreFuture ...
[10:32:51.001] result() for MulticoreFuture ...
[10:32:51.001] result() for MulticoreFuture ... done
[10:32:51.001] result() for MulticoreFuture ... done
[10:32:51.001] result() for MulticoreFuture ...
[10:32:51.001] result() for MulticoreFuture ... done
[10:32:51.001] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:51.001] - nx: 6
[10:32:51.001] - relay: TRUE
[10:32:51.002] - stdout: TRUE
[10:32:51.002] - signal: TRUE
[10:32:51.002] - resignal: FALSE
[10:32:51.002] - force: TRUE
[10:32:51.002] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.002] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.002]  - until=3
[10:32:51.002]  - relaying element #3
[10:32:51.002] result() for MulticoreFuture ...
[10:32:51.002] result() for MulticoreFuture ... done
[10:32:51.003] result() for MulticoreFuture ...
[10:32:51.003] result() for MulticoreFuture ... done
[10:32:51.003] result() for MulticoreFuture ...
[10:32:51.003] result() for MulticoreFuture ... done
[10:32:51.003] result() for MulticoreFuture ...
[10:32:51.003] result() for MulticoreFuture ... done
[10:32:51.003] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.004] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:51.004]  length: 3 (resolved future 3)
[10:32:51.004] signalConditionsASAP(NULL, pos=4) ...
[10:32:51.004] - nx: 6
[10:32:51.004] - relay: TRUE
[10:32:51.004] - stdout: TRUE
[10:32:51.004] - signal: TRUE
[10:32:51.004] - resignal: FALSE
[10:32:51.004] - force: TRUE
[10:32:51.004] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.004] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.005]  - until=5
[10:32:51.005]  - relaying element #5
[10:32:51.005] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.005] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.005] signalConditionsASAP(NULL, pos=4) ... done
[10:32:51.005]  length: 2 (resolved future 4)
[10:32:51.005] signalConditionsASAP(NULL, pos=5) ...
[10:32:51.005] - nx: 6
[10:32:51.005] - relay: TRUE
[10:32:51.006] - stdout: TRUE
[10:32:51.006] - signal: TRUE
[10:32:51.006] - resignal: FALSE
[10:32:51.006] - force: TRUE
[10:32:51.006] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.006] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.006]  - until=6
[10:32:51.006]  - relaying element #6
[10:32:51.006] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.006] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.007] signalConditionsASAP(NULL, pos=5) ... done
[10:32:51.007]  length: 1 (resolved future 5)
[10:32:51.007] signalConditionsASAP(numeric, pos=6) ...
[10:32:51.007] - nx: 6
[10:32:51.007] - relay: TRUE
[10:32:51.007] - stdout: TRUE
[10:32:51.007] - signal: TRUE
[10:32:51.007] - resignal: FALSE
[10:32:51.007] - force: TRUE
[10:32:51.007] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.007] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.008]  - until=6
[10:32:51.008] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.008] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.008] signalConditionsASAP(numeric, pos=6) ... done
[10:32:51.008]  length: 0 (resolved future 6)
[10:32:51.008] Relaying remaining futures
[10:32:51.008] signalConditionsASAP(NULL, pos=0) ...
[10:32:51.008] - nx: 6
[10:32:51.008] - relay: TRUE
[10:32:51.008] - stdout: TRUE
[10:32:51.009] - signal: TRUE
[10:32:51.009] - resignal: FALSE
[10:32:51.009] - force: TRUE
[10:32:51.009] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.009] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:51.009] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.009] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.009] signalConditionsASAP(NULL, pos=0) ... done
[10:32:51.009] resolve() on list ... DONE
[10:32:51.010] result() for MulticoreFuture ...
[10:32:51.010] result() for MulticoreFuture ... done
[10:32:51.010] result() for MulticoreFuture ...
[10:32:51.010] result() for MulticoreFuture ... done
[10:32:51.010] result() for MulticoreFuture ...
[10:32:51.010] result() for MulticoreFuture ... done
[10:32:51.010] result() for MulticoreFuture ...
[10:32:51.010] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[10:32:51.016] plan(): Setting new future strategy stack:
[10:32:51.016] List of future strategies:
[10:32:51.016] 1. multisession:
[10:32:51.016]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:51.016]    - tweaked: FALSE
[10:32:51.016]    - call: plan(strategy)
[10:32:51.017] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:32:51.017] multisession:
[10:32:51.017] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:51.017] - tweaked: FALSE
[10:32:51.017] - call: plan(strategy)
[10:32:51.024] getGlobalsAndPackages() ...
[10:32:51.024] Not searching for globals
[10:32:51.024] - globals: [0] <none>
[10:32:51.024] getGlobalsAndPackages() ... DONE
[10:32:51.025] [local output] makeClusterPSOCK() ...
[10:32:51.064] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:32:51.066] [local output] Base port: 11412
[10:32:51.066] [local output] Getting setup options for 2 cluster nodes ...
[10:32:51.066] [local output]  - Node 1 of 2 ...
[10:32:51.066] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:51.067] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6952c71a3e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6952c71a3e.pid")'’
[10:32:51.254] - Possible to infer worker's PID: TRUE
[10:32:51.255] [local output] Rscript port: 11412

[10:32:51.255] [local output]  - Node 2 of 2 ...
[10:32:51.255] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:51.256] [local output] Rscript port: 11412

[10:32:51.256] [local output] Getting setup options for 2 cluster nodes ... done
[10:32:51.256] [local output]  - Parallel setup requested for some PSOCK nodes
[10:32:51.257] [local output] Setting up PSOCK nodes in parallel
[10:32:51.257] List of 36
[10:32:51.257]  $ worker          : chr "localhost"
[10:32:51.257]   ..- attr(*, "localhost")= logi TRUE
[10:32:51.257]  $ master          : chr "localhost"
[10:32:51.257]  $ port            : int 11412
[10:32:51.257]  $ connectTimeout  : num 120
[10:32:51.257]  $ timeout         : num 2592000
[10:32:51.257]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:32:51.257]  $ homogeneous     : logi TRUE
[10:32:51.257]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:32:51.257]  $ rscript_envs    : NULL
[10:32:51.257]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:51.257]  $ rscript_startup : NULL
[10:32:51.257]  $ rscript_sh      : chr "sh"
[10:32:51.257]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:51.257]  $ methods         : logi TRUE
[10:32:51.257]  $ socketOptions   : chr "no-delay"
[10:32:51.257]  $ useXDR          : logi FALSE
[10:32:51.257]  $ outfile         : chr "/dev/null"
[10:32:51.257]  $ renice          : int NA
[10:32:51.257]  $ rshcmd          : NULL
[10:32:51.257]  $ user            : chr(0) 
[10:32:51.257]  $ revtunnel       : logi FALSE
[10:32:51.257]  $ rshlogfile      : NULL
[10:32:51.257]  $ rshopts         : chr(0) 
[10:32:51.257]  $ rank            : int 1
[10:32:51.257]  $ manual          : logi FALSE
[10:32:51.257]  $ dryrun          : logi FALSE
[10:32:51.257]  $ quiet           : logi FALSE
[10:32:51.257]  $ setup_strategy  : chr "parallel"
[10:32:51.257]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:51.257]  $ pidfile         : chr "/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6952c71a3e.pid"
[10:32:51.257]  $ rshcmd_label    : NULL
[10:32:51.257]  $ rsh_call        : NULL
[10:32:51.257]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:51.257]  $ localMachine    : logi TRUE
[10:32:51.257]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:32:51.257]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:32:51.257]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:32:51.257]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:32:51.257]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:32:51.257]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:32:51.257]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:32:51.257]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:32:51.257]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:32:51.257]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:32:51.257]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:32:51.257]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:32:51.257]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:32:51.257]  $ arguments       :List of 28
[10:32:51.257]   ..$ worker          : chr "localhost"
[10:32:51.257]   ..$ master          : NULL
[10:32:51.257]   ..$ port            : int 11412
[10:32:51.257]   ..$ connectTimeout  : num 120
[10:32:51.257]   ..$ timeout         : num 2592000
[10:32:51.257]   ..$ rscript         : NULL
[10:32:51.257]   ..$ homogeneous     : NULL
[10:32:51.257]   ..$ rscript_args    : NULL
[10:32:51.257]   ..$ rscript_envs    : NULL
[10:32:51.257]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:51.257]   ..$ rscript_startup : NULL
[10:32:51.257]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:32:51.257]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:51.257]   ..$ methods         : logi TRUE
[10:32:51.257]   ..$ socketOptions   : chr "no-delay"
[10:32:51.257]   ..$ useXDR          : logi FALSE
[10:32:51.257]   ..$ outfile         : chr "/dev/null"
[10:32:51.257]   ..$ renice          : int NA
[10:32:51.257]   ..$ rshcmd          : NULL
[10:32:51.257]   ..$ user            : NULL
[10:32:51.257]   ..$ revtunnel       : logi NA
[10:32:51.257]   ..$ rshlogfile      : NULL
[10:32:51.257]   ..$ rshopts         : NULL
[10:32:51.257]   ..$ rank            : int 1
[10:32:51.257]   ..$ manual          : logi FALSE
[10:32:51.257]   ..$ dryrun          : logi FALSE
[10:32:51.257]   ..$ quiet           : logi FALSE
[10:32:51.257]   ..$ setup_strategy  : chr "parallel"
[10:32:51.257]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:32:51.274] [local output] System call to launch all workers:
[10:32:51.274] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6952c71a3e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11412 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:32:51.274] [local output] Starting PSOCK main server
[10:32:51.280] [local output] Workers launched
[10:32:51.280] [local output] Waiting for workers to connect back
[10:32:51.280]  - [local output] 0 workers out of 2 ready
[10:32:51.522]  - [local output] 0 workers out of 2 ready
[10:32:51.523]  - [local output] 1 workers out of 2 ready
[10:32:51.523]  - [local output] 2 workers out of 2 ready
[10:32:51.523] [local output] Launching of workers completed
[10:32:51.523] [local output] Collecting session information from workers
[10:32:51.524] [local output]  - Worker #1 of 2
[10:32:51.525] [local output]  - Worker #2 of 2
[10:32:51.525] [local output] makeClusterPSOCK() ... done
[10:32:51.536] Packages needed by the future expression (n = 0): <none>
[10:32:51.536] Packages needed by future strategies (n = 0): <none>
[10:32:51.537] {
[10:32:51.537]     {
[10:32:51.537]         {
[10:32:51.537]             ...future.startTime <- base::Sys.time()
[10:32:51.537]             {
[10:32:51.537]                 {
[10:32:51.537]                   {
[10:32:51.537]                     {
[10:32:51.537]                       base::local({
[10:32:51.537]                         has_future <- base::requireNamespace("future", 
[10:32:51.537]                           quietly = TRUE)
[10:32:51.537]                         if (has_future) {
[10:32:51.537]                           ns <- base::getNamespace("future")
[10:32:51.537]                           version <- ns[[".package"]][["version"]]
[10:32:51.537]                           if (is.null(version)) 
[10:32:51.537]                             version <- utils::packageVersion("future")
[10:32:51.537]                         }
[10:32:51.537]                         else {
[10:32:51.537]                           version <- NULL
[10:32:51.537]                         }
[10:32:51.537]                         if (!has_future || version < "1.8.0") {
[10:32:51.537]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.537]                             "", base::R.version$version.string), 
[10:32:51.537]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.537]                               "release", "version")], collapse = " "), 
[10:32:51.537]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.537]                             info)
[10:32:51.537]                           info <- base::paste(info, collapse = "; ")
[10:32:51.537]                           if (!has_future) {
[10:32:51.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.537]                               info)
[10:32:51.537]                           }
[10:32:51.537]                           else {
[10:32:51.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.537]                               info, version)
[10:32:51.537]                           }
[10:32:51.537]                           base::stop(msg)
[10:32:51.537]                         }
[10:32:51.537]                       })
[10:32:51.537]                     }
[10:32:51.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.537]                     base::options(mc.cores = 1L)
[10:32:51.537]                   }
[10:32:51.537]                   ...future.strategy.old <- future::plan("list")
[10:32:51.537]                   options(future.plan = NULL)
[10:32:51.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.537]                 }
[10:32:51.537]                 ...future.workdir <- getwd()
[10:32:51.537]             }
[10:32:51.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.537]         }
[10:32:51.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.537]             base::names(...future.oldOptions))
[10:32:51.537]     }
[10:32:51.537]     if (FALSE) {
[10:32:51.537]     }
[10:32:51.537]     else {
[10:32:51.537]         if (TRUE) {
[10:32:51.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.537]                 open = "w")
[10:32:51.537]         }
[10:32:51.537]         else {
[10:32:51.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.537]         }
[10:32:51.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.537]             base::sink(type = "output", split = FALSE)
[10:32:51.537]             base::close(...future.stdout)
[10:32:51.537]         }, add = TRUE)
[10:32:51.537]     }
[10:32:51.537]     ...future.frame <- base::sys.nframe()
[10:32:51.537]     ...future.conditions <- base::list()
[10:32:51.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.537]     if (FALSE) {
[10:32:51.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.537]     }
[10:32:51.537]     ...future.result <- base::tryCatch({
[10:32:51.537]         base::withCallingHandlers({
[10:32:51.537]             ...future.value <- base::withVisible(base::local({
[10:32:51.537]                 ...future.makeSendCondition <- base::local({
[10:32:51.537]                   sendCondition <- NULL
[10:32:51.537]                   function(frame = 1L) {
[10:32:51.537]                     if (is.function(sendCondition)) 
[10:32:51.537]                       return(sendCondition)
[10:32:51.537]                     ns <- getNamespace("parallel")
[10:32:51.537]                     if (exists("sendData", mode = "function", 
[10:32:51.537]                       envir = ns)) {
[10:32:51.537]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.537]                         envir = ns)
[10:32:51.537]                       envir <- sys.frame(frame)
[10:32:51.537]                       master <- NULL
[10:32:51.537]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.537]                         !identical(envir, emptyenv())) {
[10:32:51.537]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.537]                           inherits = FALSE)) {
[10:32:51.537]                           master <- get("master", mode = "list", 
[10:32:51.537]                             envir = envir, inherits = FALSE)
[10:32:51.537]                           if (inherits(master, c("SOCKnode", 
[10:32:51.537]                             "SOCK0node"))) {
[10:32:51.537]                             sendCondition <<- function(cond) {
[10:32:51.537]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.537]                                 success = TRUE)
[10:32:51.537]                               parallel_sendData(master, data)
[10:32:51.537]                             }
[10:32:51.537]                             return(sendCondition)
[10:32:51.537]                           }
[10:32:51.537]                         }
[10:32:51.537]                         frame <- frame + 1L
[10:32:51.537]                         envir <- sys.frame(frame)
[10:32:51.537]                       }
[10:32:51.537]                     }
[10:32:51.537]                     sendCondition <<- function(cond) NULL
[10:32:51.537]                   }
[10:32:51.537]                 })
[10:32:51.537]                 withCallingHandlers({
[10:32:51.537]                   NA
[10:32:51.537]                 }, immediateCondition = function(cond) {
[10:32:51.537]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.537]                   sendCondition(cond)
[10:32:51.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.537]                   {
[10:32:51.537]                     inherits <- base::inherits
[10:32:51.537]                     invokeRestart <- base::invokeRestart
[10:32:51.537]                     is.null <- base::is.null
[10:32:51.537]                     muffled <- FALSE
[10:32:51.537]                     if (inherits(cond, "message")) {
[10:32:51.537]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.537]                       if (muffled) 
[10:32:51.537]                         invokeRestart("muffleMessage")
[10:32:51.537]                     }
[10:32:51.537]                     else if (inherits(cond, "warning")) {
[10:32:51.537]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.537]                       if (muffled) 
[10:32:51.537]                         invokeRestart("muffleWarning")
[10:32:51.537]                     }
[10:32:51.537]                     else if (inherits(cond, "condition")) {
[10:32:51.537]                       if (!is.null(pattern)) {
[10:32:51.537]                         computeRestarts <- base::computeRestarts
[10:32:51.537]                         grepl <- base::grepl
[10:32:51.537]                         restarts <- computeRestarts(cond)
[10:32:51.537]                         for (restart in restarts) {
[10:32:51.537]                           name <- restart$name
[10:32:51.537]                           if (is.null(name)) 
[10:32:51.537]                             next
[10:32:51.537]                           if (!grepl(pattern, name)) 
[10:32:51.537]                             next
[10:32:51.537]                           invokeRestart(restart)
[10:32:51.537]                           muffled <- TRUE
[10:32:51.537]                           break
[10:32:51.537]                         }
[10:32:51.537]                       }
[10:32:51.537]                     }
[10:32:51.537]                     invisible(muffled)
[10:32:51.537]                   }
[10:32:51.537]                   muffleCondition(cond)
[10:32:51.537]                 })
[10:32:51.537]             }))
[10:32:51.537]             future::FutureResult(value = ...future.value$value, 
[10:32:51.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.537]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.537]                     ...future.globalenv.names))
[10:32:51.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.537]         }, condition = base::local({
[10:32:51.537]             c <- base::c
[10:32:51.537]             inherits <- base::inherits
[10:32:51.537]             invokeRestart <- base::invokeRestart
[10:32:51.537]             length <- base::length
[10:32:51.537]             list <- base::list
[10:32:51.537]             seq.int <- base::seq.int
[10:32:51.537]             signalCondition <- base::signalCondition
[10:32:51.537]             sys.calls <- base::sys.calls
[10:32:51.537]             `[[` <- base::`[[`
[10:32:51.537]             `+` <- base::`+`
[10:32:51.537]             `<<-` <- base::`<<-`
[10:32:51.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.537]                   3L)]
[10:32:51.537]             }
[10:32:51.537]             function(cond) {
[10:32:51.537]                 is_error <- inherits(cond, "error")
[10:32:51.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.537]                   NULL)
[10:32:51.537]                 if (is_error) {
[10:32:51.537]                   sessionInformation <- function() {
[10:32:51.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.537]                       search = base::search(), system = base::Sys.info())
[10:32:51.537]                   }
[10:32:51.537]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.537]                     cond$call), session = sessionInformation(), 
[10:32:51.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.537]                   signalCondition(cond)
[10:32:51.537]                 }
[10:32:51.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.537]                 "immediateCondition"))) {
[10:32:51.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.537]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.537]                   if (TRUE && !signal) {
[10:32:51.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.537]                     {
[10:32:51.537]                       inherits <- base::inherits
[10:32:51.537]                       invokeRestart <- base::invokeRestart
[10:32:51.537]                       is.null <- base::is.null
[10:32:51.537]                       muffled <- FALSE
[10:32:51.537]                       if (inherits(cond, "message")) {
[10:32:51.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.537]                         if (muffled) 
[10:32:51.537]                           invokeRestart("muffleMessage")
[10:32:51.537]                       }
[10:32:51.537]                       else if (inherits(cond, "warning")) {
[10:32:51.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.537]                         if (muffled) 
[10:32:51.537]                           invokeRestart("muffleWarning")
[10:32:51.537]                       }
[10:32:51.537]                       else if (inherits(cond, "condition")) {
[10:32:51.537]                         if (!is.null(pattern)) {
[10:32:51.537]                           computeRestarts <- base::computeRestarts
[10:32:51.537]                           grepl <- base::grepl
[10:32:51.537]                           restarts <- computeRestarts(cond)
[10:32:51.537]                           for (restart in restarts) {
[10:32:51.537]                             name <- restart$name
[10:32:51.537]                             if (is.null(name)) 
[10:32:51.537]                               next
[10:32:51.537]                             if (!grepl(pattern, name)) 
[10:32:51.537]                               next
[10:32:51.537]                             invokeRestart(restart)
[10:32:51.537]                             muffled <- TRUE
[10:32:51.537]                             break
[10:32:51.537]                           }
[10:32:51.537]                         }
[10:32:51.537]                       }
[10:32:51.537]                       invisible(muffled)
[10:32:51.537]                     }
[10:32:51.537]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.537]                   }
[10:32:51.537]                 }
[10:32:51.537]                 else {
[10:32:51.537]                   if (TRUE) {
[10:32:51.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.537]                     {
[10:32:51.537]                       inherits <- base::inherits
[10:32:51.537]                       invokeRestart <- base::invokeRestart
[10:32:51.537]                       is.null <- base::is.null
[10:32:51.537]                       muffled <- FALSE
[10:32:51.537]                       if (inherits(cond, "message")) {
[10:32:51.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.537]                         if (muffled) 
[10:32:51.537]                           invokeRestart("muffleMessage")
[10:32:51.537]                       }
[10:32:51.537]                       else if (inherits(cond, "warning")) {
[10:32:51.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.537]                         if (muffled) 
[10:32:51.537]                           invokeRestart("muffleWarning")
[10:32:51.537]                       }
[10:32:51.537]                       else if (inherits(cond, "condition")) {
[10:32:51.537]                         if (!is.null(pattern)) {
[10:32:51.537]                           computeRestarts <- base::computeRestarts
[10:32:51.537]                           grepl <- base::grepl
[10:32:51.537]                           restarts <- computeRestarts(cond)
[10:32:51.537]                           for (restart in restarts) {
[10:32:51.537]                             name <- restart$name
[10:32:51.537]                             if (is.null(name)) 
[10:32:51.537]                               next
[10:32:51.537]                             if (!grepl(pattern, name)) 
[10:32:51.537]                               next
[10:32:51.537]                             invokeRestart(restart)
[10:32:51.537]                             muffled <- TRUE
[10:32:51.537]                             break
[10:32:51.537]                           }
[10:32:51.537]                         }
[10:32:51.537]                       }
[10:32:51.537]                       invisible(muffled)
[10:32:51.537]                     }
[10:32:51.537]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.537]                   }
[10:32:51.537]                 }
[10:32:51.537]             }
[10:32:51.537]         }))
[10:32:51.537]     }, error = function(ex) {
[10:32:51.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.537]                 ...future.rng), started = ...future.startTime, 
[10:32:51.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.537]             version = "1.8"), class = "FutureResult")
[10:32:51.537]     }, finally = {
[10:32:51.537]         if (!identical(...future.workdir, getwd())) 
[10:32:51.537]             setwd(...future.workdir)
[10:32:51.537]         {
[10:32:51.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.537]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.537]             }
[10:32:51.537]             base::options(...future.oldOptions)
[10:32:51.537]             if (.Platform$OS.type == "windows") {
[10:32:51.537]                 old_names <- names(...future.oldEnvVars)
[10:32:51.537]                 envs <- base::Sys.getenv()
[10:32:51.537]                 names <- names(envs)
[10:32:51.537]                 common <- intersect(names, old_names)
[10:32:51.537]                 added <- setdiff(names, old_names)
[10:32:51.537]                 removed <- setdiff(old_names, names)
[10:32:51.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.537]                   envs[common]]
[10:32:51.537]                 NAMES <- toupper(changed)
[10:32:51.537]                 args <- list()
[10:32:51.537]                 for (kk in seq_along(NAMES)) {
[10:32:51.537]                   name <- changed[[kk]]
[10:32:51.537]                   NAME <- NAMES[[kk]]
[10:32:51.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.537]                     next
[10:32:51.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.537]                 }
[10:32:51.537]                 NAMES <- toupper(added)
[10:32:51.537]                 for (kk in seq_along(NAMES)) {
[10:32:51.537]                   name <- added[[kk]]
[10:32:51.537]                   NAME <- NAMES[[kk]]
[10:32:51.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.537]                     next
[10:32:51.537]                   args[[name]] <- ""
[10:32:51.537]                 }
[10:32:51.537]                 NAMES <- toupper(removed)
[10:32:51.537]                 for (kk in seq_along(NAMES)) {
[10:32:51.537]                   name <- removed[[kk]]
[10:32:51.537]                   NAME <- NAMES[[kk]]
[10:32:51.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.537]                     next
[10:32:51.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.537]                 }
[10:32:51.537]                 if (length(args) > 0) 
[10:32:51.537]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.537]             }
[10:32:51.537]             else {
[10:32:51.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.537]             }
[10:32:51.537]             {
[10:32:51.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.537]                   0L) {
[10:32:51.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.537]                   base::options(opts)
[10:32:51.537]                 }
[10:32:51.537]                 {
[10:32:51.537]                   {
[10:32:51.537]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.537]                     NULL
[10:32:51.537]                   }
[10:32:51.537]                   options(future.plan = NULL)
[10:32:51.537]                   if (is.na(NA_character_)) 
[10:32:51.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.537]                     .init = FALSE)
[10:32:51.537]                 }
[10:32:51.537]             }
[10:32:51.537]         }
[10:32:51.537]     })
[10:32:51.537]     if (TRUE) {
[10:32:51.537]         base::sink(type = "output", split = FALSE)
[10:32:51.537]         if (TRUE) {
[10:32:51.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.537]         }
[10:32:51.537]         else {
[10:32:51.537]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.537]         }
[10:32:51.537]         base::close(...future.stdout)
[10:32:51.537]         ...future.stdout <- NULL
[10:32:51.537]     }
[10:32:51.537]     ...future.result$conditions <- ...future.conditions
[10:32:51.537]     ...future.result$finished <- base::Sys.time()
[10:32:51.537]     ...future.result
[10:32:51.537] }
[10:32:51.588] MultisessionFuture started
[10:32:51.589] result() for ClusterFuture ...
[10:32:51.589] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.589] - Validating connection of MultisessionFuture
[10:32:51.622] - received message: FutureResult
[10:32:51.622] - Received FutureResult
[10:32:51.622] - Erased future from FutureRegistry
[10:32:51.622] result() for ClusterFuture ...
[10:32:51.622] - result already collected: FutureResult
[10:32:51.622] result() for ClusterFuture ... done
[10:32:51.622] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:51.622] result() for ClusterFuture ... done
[10:32:51.623] result() for ClusterFuture ...
[10:32:51.623] - result already collected: FutureResult
[10:32:51.623] result() for ClusterFuture ... done
[10:32:51.623] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:32:51.627] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:32:51.627] getGlobalsAndPackages() ...
[10:32:51.627] Searching for globals...
[10:32:51.628] 
[10:32:51.628] Searching for globals ... DONE
[10:32:51.628] - globals: [0] <none>
[10:32:51.628] getGlobalsAndPackages() ... DONE
[10:32:51.628] run() for ‘Future’ ...
[10:32:51.629] - state: ‘created’
[10:32:51.629] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.643] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.643]   - Field: ‘node’
[10:32:51.643]   - Field: ‘label’
[10:32:51.643]   - Field: ‘local’
[10:32:51.643]   - Field: ‘owner’
[10:32:51.644]   - Field: ‘envir’
[10:32:51.644]   - Field: ‘workers’
[10:32:51.644]   - Field: ‘packages’
[10:32:51.644]   - Field: ‘gc’
[10:32:51.644]   - Field: ‘conditions’
[10:32:51.644]   - Field: ‘persistent’
[10:32:51.644]   - Field: ‘expr’
[10:32:51.644]   - Field: ‘uuid’
[10:32:51.644]   - Field: ‘seed’
[10:32:51.644]   - Field: ‘version’
[10:32:51.645]   - Field: ‘result’
[10:32:51.645]   - Field: ‘asynchronous’
[10:32:51.645]   - Field: ‘calls’
[10:32:51.645]   - Field: ‘globals’
[10:32:51.645]   - Field: ‘stdout’
[10:32:51.645]   - Field: ‘earlySignal’
[10:32:51.645]   - Field: ‘lazy’
[10:32:51.645]   - Field: ‘state’
[10:32:51.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.646] - Launch lazy future ...
[10:32:51.646] Packages needed by the future expression (n = 0): <none>
[10:32:51.646] Packages needed by future strategies (n = 0): <none>
[10:32:51.647] {
[10:32:51.647]     {
[10:32:51.647]         {
[10:32:51.647]             ...future.startTime <- base::Sys.time()
[10:32:51.647]             {
[10:32:51.647]                 {
[10:32:51.647]                   {
[10:32:51.647]                     {
[10:32:51.647]                       base::local({
[10:32:51.647]                         has_future <- base::requireNamespace("future", 
[10:32:51.647]                           quietly = TRUE)
[10:32:51.647]                         if (has_future) {
[10:32:51.647]                           ns <- base::getNamespace("future")
[10:32:51.647]                           version <- ns[[".package"]][["version"]]
[10:32:51.647]                           if (is.null(version)) 
[10:32:51.647]                             version <- utils::packageVersion("future")
[10:32:51.647]                         }
[10:32:51.647]                         else {
[10:32:51.647]                           version <- NULL
[10:32:51.647]                         }
[10:32:51.647]                         if (!has_future || version < "1.8.0") {
[10:32:51.647]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.647]                             "", base::R.version$version.string), 
[10:32:51.647]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.647]                               "release", "version")], collapse = " "), 
[10:32:51.647]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.647]                             info)
[10:32:51.647]                           info <- base::paste(info, collapse = "; ")
[10:32:51.647]                           if (!has_future) {
[10:32:51.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.647]                               info)
[10:32:51.647]                           }
[10:32:51.647]                           else {
[10:32:51.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.647]                               info, version)
[10:32:51.647]                           }
[10:32:51.647]                           base::stop(msg)
[10:32:51.647]                         }
[10:32:51.647]                       })
[10:32:51.647]                     }
[10:32:51.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.647]                     base::options(mc.cores = 1L)
[10:32:51.647]                   }
[10:32:51.647]                   ...future.strategy.old <- future::plan("list")
[10:32:51.647]                   options(future.plan = NULL)
[10:32:51.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.647]                 }
[10:32:51.647]                 ...future.workdir <- getwd()
[10:32:51.647]             }
[10:32:51.647]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.647]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.647]         }
[10:32:51.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.647]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.647]             base::names(...future.oldOptions))
[10:32:51.647]     }
[10:32:51.647]     if (FALSE) {
[10:32:51.647]     }
[10:32:51.647]     else {
[10:32:51.647]         if (TRUE) {
[10:32:51.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.647]                 open = "w")
[10:32:51.647]         }
[10:32:51.647]         else {
[10:32:51.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.647]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.647]         }
[10:32:51.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.647]             base::sink(type = "output", split = FALSE)
[10:32:51.647]             base::close(...future.stdout)
[10:32:51.647]         }, add = TRUE)
[10:32:51.647]     }
[10:32:51.647]     ...future.frame <- base::sys.nframe()
[10:32:51.647]     ...future.conditions <- base::list()
[10:32:51.647]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.647]     if (FALSE) {
[10:32:51.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.647]     }
[10:32:51.647]     ...future.result <- base::tryCatch({
[10:32:51.647]         base::withCallingHandlers({
[10:32:51.647]             ...future.value <- base::withVisible(base::local({
[10:32:51.647]                 ...future.makeSendCondition <- base::local({
[10:32:51.647]                   sendCondition <- NULL
[10:32:51.647]                   function(frame = 1L) {
[10:32:51.647]                     if (is.function(sendCondition)) 
[10:32:51.647]                       return(sendCondition)
[10:32:51.647]                     ns <- getNamespace("parallel")
[10:32:51.647]                     if (exists("sendData", mode = "function", 
[10:32:51.647]                       envir = ns)) {
[10:32:51.647]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.647]                         envir = ns)
[10:32:51.647]                       envir <- sys.frame(frame)
[10:32:51.647]                       master <- NULL
[10:32:51.647]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.647]                         !identical(envir, emptyenv())) {
[10:32:51.647]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.647]                           inherits = FALSE)) {
[10:32:51.647]                           master <- get("master", mode = "list", 
[10:32:51.647]                             envir = envir, inherits = FALSE)
[10:32:51.647]                           if (inherits(master, c("SOCKnode", 
[10:32:51.647]                             "SOCK0node"))) {
[10:32:51.647]                             sendCondition <<- function(cond) {
[10:32:51.647]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.647]                                 success = TRUE)
[10:32:51.647]                               parallel_sendData(master, data)
[10:32:51.647]                             }
[10:32:51.647]                             return(sendCondition)
[10:32:51.647]                           }
[10:32:51.647]                         }
[10:32:51.647]                         frame <- frame + 1L
[10:32:51.647]                         envir <- sys.frame(frame)
[10:32:51.647]                       }
[10:32:51.647]                     }
[10:32:51.647]                     sendCondition <<- function(cond) NULL
[10:32:51.647]                   }
[10:32:51.647]                 })
[10:32:51.647]                 withCallingHandlers({
[10:32:51.647]                   2
[10:32:51.647]                 }, immediateCondition = function(cond) {
[10:32:51.647]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.647]                   sendCondition(cond)
[10:32:51.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.647]                   {
[10:32:51.647]                     inherits <- base::inherits
[10:32:51.647]                     invokeRestart <- base::invokeRestart
[10:32:51.647]                     is.null <- base::is.null
[10:32:51.647]                     muffled <- FALSE
[10:32:51.647]                     if (inherits(cond, "message")) {
[10:32:51.647]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.647]                       if (muffled) 
[10:32:51.647]                         invokeRestart("muffleMessage")
[10:32:51.647]                     }
[10:32:51.647]                     else if (inherits(cond, "warning")) {
[10:32:51.647]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.647]                       if (muffled) 
[10:32:51.647]                         invokeRestart("muffleWarning")
[10:32:51.647]                     }
[10:32:51.647]                     else if (inherits(cond, "condition")) {
[10:32:51.647]                       if (!is.null(pattern)) {
[10:32:51.647]                         computeRestarts <- base::computeRestarts
[10:32:51.647]                         grepl <- base::grepl
[10:32:51.647]                         restarts <- computeRestarts(cond)
[10:32:51.647]                         for (restart in restarts) {
[10:32:51.647]                           name <- restart$name
[10:32:51.647]                           if (is.null(name)) 
[10:32:51.647]                             next
[10:32:51.647]                           if (!grepl(pattern, name)) 
[10:32:51.647]                             next
[10:32:51.647]                           invokeRestart(restart)
[10:32:51.647]                           muffled <- TRUE
[10:32:51.647]                           break
[10:32:51.647]                         }
[10:32:51.647]                       }
[10:32:51.647]                     }
[10:32:51.647]                     invisible(muffled)
[10:32:51.647]                   }
[10:32:51.647]                   muffleCondition(cond)
[10:32:51.647]                 })
[10:32:51.647]             }))
[10:32:51.647]             future::FutureResult(value = ...future.value$value, 
[10:32:51.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.647]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.647]                     ...future.globalenv.names))
[10:32:51.647]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.647]         }, condition = base::local({
[10:32:51.647]             c <- base::c
[10:32:51.647]             inherits <- base::inherits
[10:32:51.647]             invokeRestart <- base::invokeRestart
[10:32:51.647]             length <- base::length
[10:32:51.647]             list <- base::list
[10:32:51.647]             seq.int <- base::seq.int
[10:32:51.647]             signalCondition <- base::signalCondition
[10:32:51.647]             sys.calls <- base::sys.calls
[10:32:51.647]             `[[` <- base::`[[`
[10:32:51.647]             `+` <- base::`+`
[10:32:51.647]             `<<-` <- base::`<<-`
[10:32:51.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.647]                   3L)]
[10:32:51.647]             }
[10:32:51.647]             function(cond) {
[10:32:51.647]                 is_error <- inherits(cond, "error")
[10:32:51.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.647]                   NULL)
[10:32:51.647]                 if (is_error) {
[10:32:51.647]                   sessionInformation <- function() {
[10:32:51.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.647]                       search = base::search(), system = base::Sys.info())
[10:32:51.647]                   }
[10:32:51.647]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.647]                     cond$call), session = sessionInformation(), 
[10:32:51.647]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.647]                   signalCondition(cond)
[10:32:51.647]                 }
[10:32:51.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.647]                 "immediateCondition"))) {
[10:32:51.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.647]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.647]                   if (TRUE && !signal) {
[10:32:51.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.647]                     {
[10:32:51.647]                       inherits <- base::inherits
[10:32:51.647]                       invokeRestart <- base::invokeRestart
[10:32:51.647]                       is.null <- base::is.null
[10:32:51.647]                       muffled <- FALSE
[10:32:51.647]                       if (inherits(cond, "message")) {
[10:32:51.647]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.647]                         if (muffled) 
[10:32:51.647]                           invokeRestart("muffleMessage")
[10:32:51.647]                       }
[10:32:51.647]                       else if (inherits(cond, "warning")) {
[10:32:51.647]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.647]                         if (muffled) 
[10:32:51.647]                           invokeRestart("muffleWarning")
[10:32:51.647]                       }
[10:32:51.647]                       else if (inherits(cond, "condition")) {
[10:32:51.647]                         if (!is.null(pattern)) {
[10:32:51.647]                           computeRestarts <- base::computeRestarts
[10:32:51.647]                           grepl <- base::grepl
[10:32:51.647]                           restarts <- computeRestarts(cond)
[10:32:51.647]                           for (restart in restarts) {
[10:32:51.647]                             name <- restart$name
[10:32:51.647]                             if (is.null(name)) 
[10:32:51.647]                               next
[10:32:51.647]                             if (!grepl(pattern, name)) 
[10:32:51.647]                               next
[10:32:51.647]                             invokeRestart(restart)
[10:32:51.647]                             muffled <- TRUE
[10:32:51.647]                             break
[10:32:51.647]                           }
[10:32:51.647]                         }
[10:32:51.647]                       }
[10:32:51.647]                       invisible(muffled)
[10:32:51.647]                     }
[10:32:51.647]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.647]                   }
[10:32:51.647]                 }
[10:32:51.647]                 else {
[10:32:51.647]                   if (TRUE) {
[10:32:51.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.647]                     {
[10:32:51.647]                       inherits <- base::inherits
[10:32:51.647]                       invokeRestart <- base::invokeRestart
[10:32:51.647]                       is.null <- base::is.null
[10:32:51.647]                       muffled <- FALSE
[10:32:51.647]                       if (inherits(cond, "message")) {
[10:32:51.647]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.647]                         if (muffled) 
[10:32:51.647]                           invokeRestart("muffleMessage")
[10:32:51.647]                       }
[10:32:51.647]                       else if (inherits(cond, "warning")) {
[10:32:51.647]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.647]                         if (muffled) 
[10:32:51.647]                           invokeRestart("muffleWarning")
[10:32:51.647]                       }
[10:32:51.647]                       else if (inherits(cond, "condition")) {
[10:32:51.647]                         if (!is.null(pattern)) {
[10:32:51.647]                           computeRestarts <- base::computeRestarts
[10:32:51.647]                           grepl <- base::grepl
[10:32:51.647]                           restarts <- computeRestarts(cond)
[10:32:51.647]                           for (restart in restarts) {
[10:32:51.647]                             name <- restart$name
[10:32:51.647]                             if (is.null(name)) 
[10:32:51.647]                               next
[10:32:51.647]                             if (!grepl(pattern, name)) 
[10:32:51.647]                               next
[10:32:51.647]                             invokeRestart(restart)
[10:32:51.647]                             muffled <- TRUE
[10:32:51.647]                             break
[10:32:51.647]                           }
[10:32:51.647]                         }
[10:32:51.647]                       }
[10:32:51.647]                       invisible(muffled)
[10:32:51.647]                     }
[10:32:51.647]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.647]                   }
[10:32:51.647]                 }
[10:32:51.647]             }
[10:32:51.647]         }))
[10:32:51.647]     }, error = function(ex) {
[10:32:51.647]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.647]                 ...future.rng), started = ...future.startTime, 
[10:32:51.647]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.647]             version = "1.8"), class = "FutureResult")
[10:32:51.647]     }, finally = {
[10:32:51.647]         if (!identical(...future.workdir, getwd())) 
[10:32:51.647]             setwd(...future.workdir)
[10:32:51.647]         {
[10:32:51.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.647]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.647]             }
[10:32:51.647]             base::options(...future.oldOptions)
[10:32:51.647]             if (.Platform$OS.type == "windows") {
[10:32:51.647]                 old_names <- names(...future.oldEnvVars)
[10:32:51.647]                 envs <- base::Sys.getenv()
[10:32:51.647]                 names <- names(envs)
[10:32:51.647]                 common <- intersect(names, old_names)
[10:32:51.647]                 added <- setdiff(names, old_names)
[10:32:51.647]                 removed <- setdiff(old_names, names)
[10:32:51.647]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.647]                   envs[common]]
[10:32:51.647]                 NAMES <- toupper(changed)
[10:32:51.647]                 args <- list()
[10:32:51.647]                 for (kk in seq_along(NAMES)) {
[10:32:51.647]                   name <- changed[[kk]]
[10:32:51.647]                   NAME <- NAMES[[kk]]
[10:32:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.647]                     next
[10:32:51.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.647]                 }
[10:32:51.647]                 NAMES <- toupper(added)
[10:32:51.647]                 for (kk in seq_along(NAMES)) {
[10:32:51.647]                   name <- added[[kk]]
[10:32:51.647]                   NAME <- NAMES[[kk]]
[10:32:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.647]                     next
[10:32:51.647]                   args[[name]] <- ""
[10:32:51.647]                 }
[10:32:51.647]                 NAMES <- toupper(removed)
[10:32:51.647]                 for (kk in seq_along(NAMES)) {
[10:32:51.647]                   name <- removed[[kk]]
[10:32:51.647]                   NAME <- NAMES[[kk]]
[10:32:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.647]                     next
[10:32:51.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.647]                 }
[10:32:51.647]                 if (length(args) > 0) 
[10:32:51.647]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.647]             }
[10:32:51.647]             else {
[10:32:51.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.647]             }
[10:32:51.647]             {
[10:32:51.647]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.647]                   0L) {
[10:32:51.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.647]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.647]                   base::options(opts)
[10:32:51.647]                 }
[10:32:51.647]                 {
[10:32:51.647]                   {
[10:32:51.647]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.647]                     NULL
[10:32:51.647]                   }
[10:32:51.647]                   options(future.plan = NULL)
[10:32:51.647]                   if (is.na(NA_character_)) 
[10:32:51.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.647]                     .init = FALSE)
[10:32:51.647]                 }
[10:32:51.647]             }
[10:32:51.647]         }
[10:32:51.647]     })
[10:32:51.647]     if (TRUE) {
[10:32:51.647]         base::sink(type = "output", split = FALSE)
[10:32:51.647]         if (TRUE) {
[10:32:51.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.647]         }
[10:32:51.647]         else {
[10:32:51.647]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.647]         }
[10:32:51.647]         base::close(...future.stdout)
[10:32:51.647]         ...future.stdout <- NULL
[10:32:51.647]     }
[10:32:51.647]     ...future.result$conditions <- ...future.conditions
[10:32:51.647]     ...future.result$finished <- base::Sys.time()
[10:32:51.647]     ...future.result
[10:32:51.647] }
[10:32:51.650] MultisessionFuture started
[10:32:51.650] - Launch lazy future ... done
[10:32:51.650] run() for ‘MultisessionFuture’ ... done
[10:32:51.650] getGlobalsAndPackages() ...
[10:32:51.651] Searching for globals...
[10:32:51.651] 
[10:32:51.651] Searching for globals ... DONE
[10:32:51.651] - globals: [0] <none>
[10:32:51.651] getGlobalsAndPackages() ... DONE
[10:32:51.651] run() for ‘Future’ ...
[10:32:51.652] - state: ‘created’
[10:32:51.652] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.666] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.666]   - Field: ‘node’
[10:32:51.666]   - Field: ‘label’
[10:32:51.666]   - Field: ‘local’
[10:32:51.667]   - Field: ‘owner’
[10:32:51.667]   - Field: ‘envir’
[10:32:51.667]   - Field: ‘workers’
[10:32:51.667]   - Field: ‘packages’
[10:32:51.667]   - Field: ‘gc’
[10:32:51.667]   - Field: ‘conditions’
[10:32:51.667]   - Field: ‘persistent’
[10:32:51.667]   - Field: ‘expr’
[10:32:51.667]   - Field: ‘uuid’
[10:32:51.667]   - Field: ‘seed’
[10:32:51.668]   - Field: ‘version’
[10:32:51.668]   - Field: ‘result’
[10:32:51.668]   - Field: ‘asynchronous’
[10:32:51.668]   - Field: ‘calls’
[10:32:51.668]   - Field: ‘globals’
[10:32:51.668]   - Field: ‘stdout’
[10:32:51.668]   - Field: ‘earlySignal’
[10:32:51.668]   - Field: ‘lazy’
[10:32:51.669]   - Field: ‘state’
[10:32:51.669] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.669] - Launch lazy future ...
[10:32:51.669] Packages needed by the future expression (n = 0): <none>
[10:32:51.669] Packages needed by future strategies (n = 0): <none>
[10:32:51.670] {
[10:32:51.670]     {
[10:32:51.670]         {
[10:32:51.670]             ...future.startTime <- base::Sys.time()
[10:32:51.670]             {
[10:32:51.670]                 {
[10:32:51.670]                   {
[10:32:51.670]                     {
[10:32:51.670]                       base::local({
[10:32:51.670]                         has_future <- base::requireNamespace("future", 
[10:32:51.670]                           quietly = TRUE)
[10:32:51.670]                         if (has_future) {
[10:32:51.670]                           ns <- base::getNamespace("future")
[10:32:51.670]                           version <- ns[[".package"]][["version"]]
[10:32:51.670]                           if (is.null(version)) 
[10:32:51.670]                             version <- utils::packageVersion("future")
[10:32:51.670]                         }
[10:32:51.670]                         else {
[10:32:51.670]                           version <- NULL
[10:32:51.670]                         }
[10:32:51.670]                         if (!has_future || version < "1.8.0") {
[10:32:51.670]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.670]                             "", base::R.version$version.string), 
[10:32:51.670]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.670]                               "release", "version")], collapse = " "), 
[10:32:51.670]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.670]                             info)
[10:32:51.670]                           info <- base::paste(info, collapse = "; ")
[10:32:51.670]                           if (!has_future) {
[10:32:51.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.670]                               info)
[10:32:51.670]                           }
[10:32:51.670]                           else {
[10:32:51.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.670]                               info, version)
[10:32:51.670]                           }
[10:32:51.670]                           base::stop(msg)
[10:32:51.670]                         }
[10:32:51.670]                       })
[10:32:51.670]                     }
[10:32:51.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.670]                     base::options(mc.cores = 1L)
[10:32:51.670]                   }
[10:32:51.670]                   ...future.strategy.old <- future::plan("list")
[10:32:51.670]                   options(future.plan = NULL)
[10:32:51.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.670]                 }
[10:32:51.670]                 ...future.workdir <- getwd()
[10:32:51.670]             }
[10:32:51.670]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.670]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.670]         }
[10:32:51.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.670]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.670]             base::names(...future.oldOptions))
[10:32:51.670]     }
[10:32:51.670]     if (FALSE) {
[10:32:51.670]     }
[10:32:51.670]     else {
[10:32:51.670]         if (TRUE) {
[10:32:51.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.670]                 open = "w")
[10:32:51.670]         }
[10:32:51.670]         else {
[10:32:51.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.670]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.670]         }
[10:32:51.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.670]             base::sink(type = "output", split = FALSE)
[10:32:51.670]             base::close(...future.stdout)
[10:32:51.670]         }, add = TRUE)
[10:32:51.670]     }
[10:32:51.670]     ...future.frame <- base::sys.nframe()
[10:32:51.670]     ...future.conditions <- base::list()
[10:32:51.670]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.670]     if (FALSE) {
[10:32:51.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.670]     }
[10:32:51.670]     ...future.result <- base::tryCatch({
[10:32:51.670]         base::withCallingHandlers({
[10:32:51.670]             ...future.value <- base::withVisible(base::local({
[10:32:51.670]                 ...future.makeSendCondition <- base::local({
[10:32:51.670]                   sendCondition <- NULL
[10:32:51.670]                   function(frame = 1L) {
[10:32:51.670]                     if (is.function(sendCondition)) 
[10:32:51.670]                       return(sendCondition)
[10:32:51.670]                     ns <- getNamespace("parallel")
[10:32:51.670]                     if (exists("sendData", mode = "function", 
[10:32:51.670]                       envir = ns)) {
[10:32:51.670]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.670]                         envir = ns)
[10:32:51.670]                       envir <- sys.frame(frame)
[10:32:51.670]                       master <- NULL
[10:32:51.670]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.670]                         !identical(envir, emptyenv())) {
[10:32:51.670]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.670]                           inherits = FALSE)) {
[10:32:51.670]                           master <- get("master", mode = "list", 
[10:32:51.670]                             envir = envir, inherits = FALSE)
[10:32:51.670]                           if (inherits(master, c("SOCKnode", 
[10:32:51.670]                             "SOCK0node"))) {
[10:32:51.670]                             sendCondition <<- function(cond) {
[10:32:51.670]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.670]                                 success = TRUE)
[10:32:51.670]                               parallel_sendData(master, data)
[10:32:51.670]                             }
[10:32:51.670]                             return(sendCondition)
[10:32:51.670]                           }
[10:32:51.670]                         }
[10:32:51.670]                         frame <- frame + 1L
[10:32:51.670]                         envir <- sys.frame(frame)
[10:32:51.670]                       }
[10:32:51.670]                     }
[10:32:51.670]                     sendCondition <<- function(cond) NULL
[10:32:51.670]                   }
[10:32:51.670]                 })
[10:32:51.670]                 withCallingHandlers({
[10:32:51.670]                   NULL
[10:32:51.670]                 }, immediateCondition = function(cond) {
[10:32:51.670]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.670]                   sendCondition(cond)
[10:32:51.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.670]                   {
[10:32:51.670]                     inherits <- base::inherits
[10:32:51.670]                     invokeRestart <- base::invokeRestart
[10:32:51.670]                     is.null <- base::is.null
[10:32:51.670]                     muffled <- FALSE
[10:32:51.670]                     if (inherits(cond, "message")) {
[10:32:51.670]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.670]                       if (muffled) 
[10:32:51.670]                         invokeRestart("muffleMessage")
[10:32:51.670]                     }
[10:32:51.670]                     else if (inherits(cond, "warning")) {
[10:32:51.670]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.670]                       if (muffled) 
[10:32:51.670]                         invokeRestart("muffleWarning")
[10:32:51.670]                     }
[10:32:51.670]                     else if (inherits(cond, "condition")) {
[10:32:51.670]                       if (!is.null(pattern)) {
[10:32:51.670]                         computeRestarts <- base::computeRestarts
[10:32:51.670]                         grepl <- base::grepl
[10:32:51.670]                         restarts <- computeRestarts(cond)
[10:32:51.670]                         for (restart in restarts) {
[10:32:51.670]                           name <- restart$name
[10:32:51.670]                           if (is.null(name)) 
[10:32:51.670]                             next
[10:32:51.670]                           if (!grepl(pattern, name)) 
[10:32:51.670]                             next
[10:32:51.670]                           invokeRestart(restart)
[10:32:51.670]                           muffled <- TRUE
[10:32:51.670]                           break
[10:32:51.670]                         }
[10:32:51.670]                       }
[10:32:51.670]                     }
[10:32:51.670]                     invisible(muffled)
[10:32:51.670]                   }
[10:32:51.670]                   muffleCondition(cond)
[10:32:51.670]                 })
[10:32:51.670]             }))
[10:32:51.670]             future::FutureResult(value = ...future.value$value, 
[10:32:51.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.670]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.670]                     ...future.globalenv.names))
[10:32:51.670]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.670]         }, condition = base::local({
[10:32:51.670]             c <- base::c
[10:32:51.670]             inherits <- base::inherits
[10:32:51.670]             invokeRestart <- base::invokeRestart
[10:32:51.670]             length <- base::length
[10:32:51.670]             list <- base::list
[10:32:51.670]             seq.int <- base::seq.int
[10:32:51.670]             signalCondition <- base::signalCondition
[10:32:51.670]             sys.calls <- base::sys.calls
[10:32:51.670]             `[[` <- base::`[[`
[10:32:51.670]             `+` <- base::`+`
[10:32:51.670]             `<<-` <- base::`<<-`
[10:32:51.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.670]                   3L)]
[10:32:51.670]             }
[10:32:51.670]             function(cond) {
[10:32:51.670]                 is_error <- inherits(cond, "error")
[10:32:51.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.670]                   NULL)
[10:32:51.670]                 if (is_error) {
[10:32:51.670]                   sessionInformation <- function() {
[10:32:51.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.670]                       search = base::search(), system = base::Sys.info())
[10:32:51.670]                   }
[10:32:51.670]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.670]                     cond$call), session = sessionInformation(), 
[10:32:51.670]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.670]                   signalCondition(cond)
[10:32:51.670]                 }
[10:32:51.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.670]                 "immediateCondition"))) {
[10:32:51.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.670]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.670]                   if (TRUE && !signal) {
[10:32:51.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.670]                     {
[10:32:51.670]                       inherits <- base::inherits
[10:32:51.670]                       invokeRestart <- base::invokeRestart
[10:32:51.670]                       is.null <- base::is.null
[10:32:51.670]                       muffled <- FALSE
[10:32:51.670]                       if (inherits(cond, "message")) {
[10:32:51.670]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.670]                         if (muffled) 
[10:32:51.670]                           invokeRestart("muffleMessage")
[10:32:51.670]                       }
[10:32:51.670]                       else if (inherits(cond, "warning")) {
[10:32:51.670]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.670]                         if (muffled) 
[10:32:51.670]                           invokeRestart("muffleWarning")
[10:32:51.670]                       }
[10:32:51.670]                       else if (inherits(cond, "condition")) {
[10:32:51.670]                         if (!is.null(pattern)) {
[10:32:51.670]                           computeRestarts <- base::computeRestarts
[10:32:51.670]                           grepl <- base::grepl
[10:32:51.670]                           restarts <- computeRestarts(cond)
[10:32:51.670]                           for (restart in restarts) {
[10:32:51.670]                             name <- restart$name
[10:32:51.670]                             if (is.null(name)) 
[10:32:51.670]                               next
[10:32:51.670]                             if (!grepl(pattern, name)) 
[10:32:51.670]                               next
[10:32:51.670]                             invokeRestart(restart)
[10:32:51.670]                             muffled <- TRUE
[10:32:51.670]                             break
[10:32:51.670]                           }
[10:32:51.670]                         }
[10:32:51.670]                       }
[10:32:51.670]                       invisible(muffled)
[10:32:51.670]                     }
[10:32:51.670]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.670]                   }
[10:32:51.670]                 }
[10:32:51.670]                 else {
[10:32:51.670]                   if (TRUE) {
[10:32:51.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.670]                     {
[10:32:51.670]                       inherits <- base::inherits
[10:32:51.670]                       invokeRestart <- base::invokeRestart
[10:32:51.670]                       is.null <- base::is.null
[10:32:51.670]                       muffled <- FALSE
[10:32:51.670]                       if (inherits(cond, "message")) {
[10:32:51.670]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.670]                         if (muffled) 
[10:32:51.670]                           invokeRestart("muffleMessage")
[10:32:51.670]                       }
[10:32:51.670]                       else if (inherits(cond, "warning")) {
[10:32:51.670]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.670]                         if (muffled) 
[10:32:51.670]                           invokeRestart("muffleWarning")
[10:32:51.670]                       }
[10:32:51.670]                       else if (inherits(cond, "condition")) {
[10:32:51.670]                         if (!is.null(pattern)) {
[10:32:51.670]                           computeRestarts <- base::computeRestarts
[10:32:51.670]                           grepl <- base::grepl
[10:32:51.670]                           restarts <- computeRestarts(cond)
[10:32:51.670]                           for (restart in restarts) {
[10:32:51.670]                             name <- restart$name
[10:32:51.670]                             if (is.null(name)) 
[10:32:51.670]                               next
[10:32:51.670]                             if (!grepl(pattern, name)) 
[10:32:51.670]                               next
[10:32:51.670]                             invokeRestart(restart)
[10:32:51.670]                             muffled <- TRUE
[10:32:51.670]                             break
[10:32:51.670]                           }
[10:32:51.670]                         }
[10:32:51.670]                       }
[10:32:51.670]                       invisible(muffled)
[10:32:51.670]                     }
[10:32:51.670]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.670]                   }
[10:32:51.670]                 }
[10:32:51.670]             }
[10:32:51.670]         }))
[10:32:51.670]     }, error = function(ex) {
[10:32:51.670]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.670]                 ...future.rng), started = ...future.startTime, 
[10:32:51.670]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.670]             version = "1.8"), class = "FutureResult")
[10:32:51.670]     }, finally = {
[10:32:51.670]         if (!identical(...future.workdir, getwd())) 
[10:32:51.670]             setwd(...future.workdir)
[10:32:51.670]         {
[10:32:51.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.670]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.670]             }
[10:32:51.670]             base::options(...future.oldOptions)
[10:32:51.670]             if (.Platform$OS.type == "windows") {
[10:32:51.670]                 old_names <- names(...future.oldEnvVars)
[10:32:51.670]                 envs <- base::Sys.getenv()
[10:32:51.670]                 names <- names(envs)
[10:32:51.670]                 common <- intersect(names, old_names)
[10:32:51.670]                 added <- setdiff(names, old_names)
[10:32:51.670]                 removed <- setdiff(old_names, names)
[10:32:51.670]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.670]                   envs[common]]
[10:32:51.670]                 NAMES <- toupper(changed)
[10:32:51.670]                 args <- list()
[10:32:51.670]                 for (kk in seq_along(NAMES)) {
[10:32:51.670]                   name <- changed[[kk]]
[10:32:51.670]                   NAME <- NAMES[[kk]]
[10:32:51.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.670]                     next
[10:32:51.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.670]                 }
[10:32:51.670]                 NAMES <- toupper(added)
[10:32:51.670]                 for (kk in seq_along(NAMES)) {
[10:32:51.670]                   name <- added[[kk]]
[10:32:51.670]                   NAME <- NAMES[[kk]]
[10:32:51.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.670]                     next
[10:32:51.670]                   args[[name]] <- ""
[10:32:51.670]                 }
[10:32:51.670]                 NAMES <- toupper(removed)
[10:32:51.670]                 for (kk in seq_along(NAMES)) {
[10:32:51.670]                   name <- removed[[kk]]
[10:32:51.670]                   NAME <- NAMES[[kk]]
[10:32:51.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.670]                     next
[10:32:51.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.670]                 }
[10:32:51.670]                 if (length(args) > 0) 
[10:32:51.670]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.670]             }
[10:32:51.670]             else {
[10:32:51.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.670]             }
[10:32:51.670]             {
[10:32:51.670]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.670]                   0L) {
[10:32:51.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.670]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.670]                   base::options(opts)
[10:32:51.670]                 }
[10:32:51.670]                 {
[10:32:51.670]                   {
[10:32:51.670]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.670]                     NULL
[10:32:51.670]                   }
[10:32:51.670]                   options(future.plan = NULL)
[10:32:51.670]                   if (is.na(NA_character_)) 
[10:32:51.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.670]                     .init = FALSE)
[10:32:51.670]                 }
[10:32:51.670]             }
[10:32:51.670]         }
[10:32:51.670]     })
[10:32:51.670]     if (TRUE) {
[10:32:51.670]         base::sink(type = "output", split = FALSE)
[10:32:51.670]         if (TRUE) {
[10:32:51.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.670]         }
[10:32:51.670]         else {
[10:32:51.670]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.670]         }
[10:32:51.670]         base::close(...future.stdout)
[10:32:51.670]         ...future.stdout <- NULL
[10:32:51.670]     }
[10:32:51.670]     ...future.result$conditions <- ...future.conditions
[10:32:51.670]     ...future.result$finished <- base::Sys.time()
[10:32:51.670]     ...future.result
[10:32:51.670] }
[10:32:51.723] MultisessionFuture started
[10:32:51.723] - Launch lazy future ... done
[10:32:51.723] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1f7aea0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d23d7450> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1f7aea0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d23d7450> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:32:51.732] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.732] - Validating connection of MultisessionFuture
[10:32:51.733] - received message: FutureResult
[10:32:51.733] - Received FutureResult
[10:32:51.733] - Erased future from FutureRegistry
[10:32:51.733] result() for ClusterFuture ...
[10:32:51.733] - result already collected: FutureResult
[10:32:51.734] result() for ClusterFuture ... done
[10:32:51.734] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:51.745] resolve() on list ...
[10:32:51.746]  recursive: 0
[10:32:51.746]  length: 6
[10:32:51.746]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:51.746] signalConditionsASAP(numeric, pos=1) ...
[10:32:51.746] - nx: 6
[10:32:51.746] - relay: TRUE
[10:32:51.746] - stdout: TRUE
[10:32:51.746] - signal: TRUE
[10:32:51.746] - resignal: FALSE
[10:32:51.747] - force: TRUE
[10:32:51.747] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.747] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.747]  - until=2
[10:32:51.747]  - relaying element #2
[10:32:51.747] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.747] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.747] signalConditionsASAP(NULL, pos=1) ... done
[10:32:51.747]  length: 5 (resolved future 1)
[10:32:51.748] Future #2
[10:32:51.748] result() for ClusterFuture ...
[10:32:51.748] - result already collected: FutureResult
[10:32:51.748] result() for ClusterFuture ... done
[10:32:51.748] result() for ClusterFuture ...
[10:32:51.748] - result already collected: FutureResult
[10:32:51.748] result() for ClusterFuture ... done
[10:32:51.748] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:51.749] - nx: 6
[10:32:51.749] - relay: TRUE
[10:32:51.749] - stdout: TRUE
[10:32:51.749] - signal: TRUE
[10:32:51.749] - resignal: FALSE
[10:32:51.749] - force: TRUE
[10:32:51.749] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.749] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.749]  - until=2
[10:32:51.750]  - relaying element #2
[10:32:51.750] result() for ClusterFuture ...
[10:32:51.750] - result already collected: FutureResult
[10:32:51.750] result() for ClusterFuture ... done
[10:32:51.750] result() for ClusterFuture ...
[10:32:51.750] - result already collected: FutureResult
[10:32:51.750] result() for ClusterFuture ... done
[10:32:51.750] result() for ClusterFuture ...
[10:32:51.750] - result already collected: FutureResult
[10:32:51.751] result() for ClusterFuture ... done
[10:32:51.751] result() for ClusterFuture ...
[10:32:51.751] - result already collected: FutureResult
[10:32:51.751] result() for ClusterFuture ... done
[10:32:51.751] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.751] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.751] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:51.751]  length: 4 (resolved future 2)
[10:32:51.761] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.761] - Validating connection of MultisessionFuture
[10:32:51.762] - received message: FutureResult
[10:32:51.762] - Received FutureResult
[10:32:51.762] - Erased future from FutureRegistry
[10:32:51.762] result() for ClusterFuture ...
[10:32:51.762] - result already collected: FutureResult
[10:32:51.762] result() for ClusterFuture ... done
[10:32:51.762] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:51.763] Future #3
[10:32:51.763] result() for ClusterFuture ...
[10:32:51.763] - result already collected: FutureResult
[10:32:51.763] result() for ClusterFuture ... done
[10:32:51.763] result() for ClusterFuture ...
[10:32:51.763] - result already collected: FutureResult
[10:32:51.763] result() for ClusterFuture ... done
[10:32:51.763] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:51.763] - nx: 6
[10:32:51.764] - relay: TRUE
[10:32:51.764] - stdout: TRUE
[10:32:51.764] - signal: TRUE
[10:32:51.764] - resignal: FALSE
[10:32:51.764] - force: TRUE
[10:32:51.764] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.764] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.764]  - until=3
[10:32:51.764]  - relaying element #3
[10:32:51.765] result() for ClusterFuture ...
[10:32:51.765] - result already collected: FutureResult
[10:32:51.765] result() for ClusterFuture ... done
[10:32:51.765] result() for ClusterFuture ...
[10:32:51.765] - result already collected: FutureResult
[10:32:51.765] result() for ClusterFuture ... done
[10:32:51.765] result() for ClusterFuture ...
[10:32:51.765] - result already collected: FutureResult
[10:32:51.766] result() for ClusterFuture ... done
[10:32:51.766] result() for ClusterFuture ...
[10:32:51.766] - result already collected: FutureResult
[10:32:51.766] result() for ClusterFuture ... done
[10:32:51.766] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.766] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.766] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:51.766]  length: 3 (resolved future 3)
[10:32:51.766] signalConditionsASAP(NULL, pos=4) ...
[10:32:51.767] - nx: 6
[10:32:51.767] - relay: TRUE
[10:32:51.767] - stdout: TRUE
[10:32:51.767] - signal: TRUE
[10:32:51.767] - resignal: FALSE
[10:32:51.767] - force: TRUE
[10:32:51.767] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.767] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.767]  - until=5
[10:32:51.767]  - relaying element #5
[10:32:51.768] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.768] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.768] signalConditionsASAP(NULL, pos=4) ... done
[10:32:51.768]  length: 2 (resolved future 4)
[10:32:51.768] signalConditionsASAP(NULL, pos=5) ...
[10:32:51.768] - nx: 6
[10:32:51.768] - relay: TRUE
[10:32:51.768] - stdout: TRUE
[10:32:51.768] - signal: TRUE
[10:32:51.769] - resignal: FALSE
[10:32:51.769] - force: TRUE
[10:32:51.769] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.769] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.769]  - until=6
[10:32:51.769]  - relaying element #6
[10:32:51.769] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.769] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.769] signalConditionsASAP(NULL, pos=5) ... done
[10:32:51.770]  length: 1 (resolved future 5)
[10:32:51.770] signalConditionsASAP(numeric, pos=6) ...
[10:32:51.770] - nx: 6
[10:32:51.770] - relay: TRUE
[10:32:51.770] - stdout: TRUE
[10:32:51.770] - signal: TRUE
[10:32:51.770] - resignal: FALSE
[10:32:51.770] - force: TRUE
[10:32:51.770] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.770] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.771]  - until=6
[10:32:51.771] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.771] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.771] signalConditionsASAP(numeric, pos=6) ... done
[10:32:51.771]  length: 0 (resolved future 6)
[10:32:51.771] Relaying remaining futures
[10:32:51.771] signalConditionsASAP(NULL, pos=0) ...
[10:32:51.771] - nx: 6
[10:32:51.771] - relay: TRUE
[10:32:51.772] - stdout: TRUE
[10:32:51.772] - signal: TRUE
[10:32:51.772] - resignal: FALSE
[10:32:51.772] - force: TRUE
[10:32:51.772] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.772] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:51.774] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.774] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.775] signalConditionsASAP(NULL, pos=0) ... done
[10:32:51.775] resolve() on list ... DONE
[10:32:51.775] result() for ClusterFuture ...
[10:32:51.775] - result already collected: FutureResult
[10:32:51.775] result() for ClusterFuture ... done
[10:32:51.775] result() for ClusterFuture ...
[10:32:51.775] - result already collected: FutureResult
[10:32:51.775] result() for ClusterFuture ... done
[10:32:51.775] result() for ClusterFuture ...
[10:32:51.775] - result already collected: FutureResult
[10:32:51.775] result() for ClusterFuture ... done
[10:32:51.775] result() for ClusterFuture ...
[10:32:51.776] - result already collected: FutureResult
[10:32:51.776] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:32:51.778] getGlobalsAndPackages() ...
[10:32:51.778] Searching for globals...
[10:32:51.778] 
[10:32:51.778] Searching for globals ... DONE
[10:32:51.778] - globals: [0] <none>
[10:32:51.778] getGlobalsAndPackages() ... DONE
[10:32:51.779] run() for ‘Future’ ...
[10:32:51.779] - state: ‘created’
[10:32:51.779] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.793]   - Field: ‘node’
[10:32:51.793]   - Field: ‘label’
[10:32:51.794]   - Field: ‘local’
[10:32:51.794]   - Field: ‘owner’
[10:32:51.794]   - Field: ‘envir’
[10:32:51.794]   - Field: ‘workers’
[10:32:51.794]   - Field: ‘packages’
[10:32:51.794]   - Field: ‘gc’
[10:32:51.794]   - Field: ‘conditions’
[10:32:51.794]   - Field: ‘persistent’
[10:32:51.794]   - Field: ‘expr’
[10:32:51.794]   - Field: ‘uuid’
[10:32:51.794]   - Field: ‘seed’
[10:32:51.795]   - Field: ‘version’
[10:32:51.795]   - Field: ‘result’
[10:32:51.795]   - Field: ‘asynchronous’
[10:32:51.795]   - Field: ‘calls’
[10:32:51.795]   - Field: ‘globals’
[10:32:51.795]   - Field: ‘stdout’
[10:32:51.795]   - Field: ‘earlySignal’
[10:32:51.795]   - Field: ‘lazy’
[10:32:51.795]   - Field: ‘state’
[10:32:51.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.795] - Launch lazy future ...
[10:32:51.796] Packages needed by the future expression (n = 0): <none>
[10:32:51.796] Packages needed by future strategies (n = 0): <none>
[10:32:51.796] {
[10:32:51.796]     {
[10:32:51.796]         {
[10:32:51.796]             ...future.startTime <- base::Sys.time()
[10:32:51.796]             {
[10:32:51.796]                 {
[10:32:51.796]                   {
[10:32:51.796]                     {
[10:32:51.796]                       base::local({
[10:32:51.796]                         has_future <- base::requireNamespace("future", 
[10:32:51.796]                           quietly = TRUE)
[10:32:51.796]                         if (has_future) {
[10:32:51.796]                           ns <- base::getNamespace("future")
[10:32:51.796]                           version <- ns[[".package"]][["version"]]
[10:32:51.796]                           if (is.null(version)) 
[10:32:51.796]                             version <- utils::packageVersion("future")
[10:32:51.796]                         }
[10:32:51.796]                         else {
[10:32:51.796]                           version <- NULL
[10:32:51.796]                         }
[10:32:51.796]                         if (!has_future || version < "1.8.0") {
[10:32:51.796]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.796]                             "", base::R.version$version.string), 
[10:32:51.796]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.796]                               "release", "version")], collapse = " "), 
[10:32:51.796]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.796]                             info)
[10:32:51.796]                           info <- base::paste(info, collapse = "; ")
[10:32:51.796]                           if (!has_future) {
[10:32:51.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.796]                               info)
[10:32:51.796]                           }
[10:32:51.796]                           else {
[10:32:51.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.796]                               info, version)
[10:32:51.796]                           }
[10:32:51.796]                           base::stop(msg)
[10:32:51.796]                         }
[10:32:51.796]                       })
[10:32:51.796]                     }
[10:32:51.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.796]                     base::options(mc.cores = 1L)
[10:32:51.796]                   }
[10:32:51.796]                   ...future.strategy.old <- future::plan("list")
[10:32:51.796]                   options(future.plan = NULL)
[10:32:51.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.796]                 }
[10:32:51.796]                 ...future.workdir <- getwd()
[10:32:51.796]             }
[10:32:51.796]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.796]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.796]         }
[10:32:51.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.796]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.796]             base::names(...future.oldOptions))
[10:32:51.796]     }
[10:32:51.796]     if (FALSE) {
[10:32:51.796]     }
[10:32:51.796]     else {
[10:32:51.796]         if (TRUE) {
[10:32:51.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.796]                 open = "w")
[10:32:51.796]         }
[10:32:51.796]         else {
[10:32:51.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.796]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.796]         }
[10:32:51.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.796]             base::sink(type = "output", split = FALSE)
[10:32:51.796]             base::close(...future.stdout)
[10:32:51.796]         }, add = TRUE)
[10:32:51.796]     }
[10:32:51.796]     ...future.frame <- base::sys.nframe()
[10:32:51.796]     ...future.conditions <- base::list()
[10:32:51.796]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.796]     if (FALSE) {
[10:32:51.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.796]     }
[10:32:51.796]     ...future.result <- base::tryCatch({
[10:32:51.796]         base::withCallingHandlers({
[10:32:51.796]             ...future.value <- base::withVisible(base::local({
[10:32:51.796]                 ...future.makeSendCondition <- base::local({
[10:32:51.796]                   sendCondition <- NULL
[10:32:51.796]                   function(frame = 1L) {
[10:32:51.796]                     if (is.function(sendCondition)) 
[10:32:51.796]                       return(sendCondition)
[10:32:51.796]                     ns <- getNamespace("parallel")
[10:32:51.796]                     if (exists("sendData", mode = "function", 
[10:32:51.796]                       envir = ns)) {
[10:32:51.796]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.796]                         envir = ns)
[10:32:51.796]                       envir <- sys.frame(frame)
[10:32:51.796]                       master <- NULL
[10:32:51.796]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.796]                         !identical(envir, emptyenv())) {
[10:32:51.796]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.796]                           inherits = FALSE)) {
[10:32:51.796]                           master <- get("master", mode = "list", 
[10:32:51.796]                             envir = envir, inherits = FALSE)
[10:32:51.796]                           if (inherits(master, c("SOCKnode", 
[10:32:51.796]                             "SOCK0node"))) {
[10:32:51.796]                             sendCondition <<- function(cond) {
[10:32:51.796]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.796]                                 success = TRUE)
[10:32:51.796]                               parallel_sendData(master, data)
[10:32:51.796]                             }
[10:32:51.796]                             return(sendCondition)
[10:32:51.796]                           }
[10:32:51.796]                         }
[10:32:51.796]                         frame <- frame + 1L
[10:32:51.796]                         envir <- sys.frame(frame)
[10:32:51.796]                       }
[10:32:51.796]                     }
[10:32:51.796]                     sendCondition <<- function(cond) NULL
[10:32:51.796]                   }
[10:32:51.796]                 })
[10:32:51.796]                 withCallingHandlers({
[10:32:51.796]                   2
[10:32:51.796]                 }, immediateCondition = function(cond) {
[10:32:51.796]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.796]                   sendCondition(cond)
[10:32:51.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.796]                   {
[10:32:51.796]                     inherits <- base::inherits
[10:32:51.796]                     invokeRestart <- base::invokeRestart
[10:32:51.796]                     is.null <- base::is.null
[10:32:51.796]                     muffled <- FALSE
[10:32:51.796]                     if (inherits(cond, "message")) {
[10:32:51.796]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.796]                       if (muffled) 
[10:32:51.796]                         invokeRestart("muffleMessage")
[10:32:51.796]                     }
[10:32:51.796]                     else if (inherits(cond, "warning")) {
[10:32:51.796]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.796]                       if (muffled) 
[10:32:51.796]                         invokeRestart("muffleWarning")
[10:32:51.796]                     }
[10:32:51.796]                     else if (inherits(cond, "condition")) {
[10:32:51.796]                       if (!is.null(pattern)) {
[10:32:51.796]                         computeRestarts <- base::computeRestarts
[10:32:51.796]                         grepl <- base::grepl
[10:32:51.796]                         restarts <- computeRestarts(cond)
[10:32:51.796]                         for (restart in restarts) {
[10:32:51.796]                           name <- restart$name
[10:32:51.796]                           if (is.null(name)) 
[10:32:51.796]                             next
[10:32:51.796]                           if (!grepl(pattern, name)) 
[10:32:51.796]                             next
[10:32:51.796]                           invokeRestart(restart)
[10:32:51.796]                           muffled <- TRUE
[10:32:51.796]                           break
[10:32:51.796]                         }
[10:32:51.796]                       }
[10:32:51.796]                     }
[10:32:51.796]                     invisible(muffled)
[10:32:51.796]                   }
[10:32:51.796]                   muffleCondition(cond)
[10:32:51.796]                 })
[10:32:51.796]             }))
[10:32:51.796]             future::FutureResult(value = ...future.value$value, 
[10:32:51.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.796]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.796]                     ...future.globalenv.names))
[10:32:51.796]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.796]         }, condition = base::local({
[10:32:51.796]             c <- base::c
[10:32:51.796]             inherits <- base::inherits
[10:32:51.796]             invokeRestart <- base::invokeRestart
[10:32:51.796]             length <- base::length
[10:32:51.796]             list <- base::list
[10:32:51.796]             seq.int <- base::seq.int
[10:32:51.796]             signalCondition <- base::signalCondition
[10:32:51.796]             sys.calls <- base::sys.calls
[10:32:51.796]             `[[` <- base::`[[`
[10:32:51.796]             `+` <- base::`+`
[10:32:51.796]             `<<-` <- base::`<<-`
[10:32:51.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.796]                   3L)]
[10:32:51.796]             }
[10:32:51.796]             function(cond) {
[10:32:51.796]                 is_error <- inherits(cond, "error")
[10:32:51.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.796]                   NULL)
[10:32:51.796]                 if (is_error) {
[10:32:51.796]                   sessionInformation <- function() {
[10:32:51.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.796]                       search = base::search(), system = base::Sys.info())
[10:32:51.796]                   }
[10:32:51.796]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.796]                     cond$call), session = sessionInformation(), 
[10:32:51.796]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.796]                   signalCondition(cond)
[10:32:51.796]                 }
[10:32:51.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.796]                 "immediateCondition"))) {
[10:32:51.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.796]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.796]                   if (TRUE && !signal) {
[10:32:51.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.796]                     {
[10:32:51.796]                       inherits <- base::inherits
[10:32:51.796]                       invokeRestart <- base::invokeRestart
[10:32:51.796]                       is.null <- base::is.null
[10:32:51.796]                       muffled <- FALSE
[10:32:51.796]                       if (inherits(cond, "message")) {
[10:32:51.796]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.796]                         if (muffled) 
[10:32:51.796]                           invokeRestart("muffleMessage")
[10:32:51.796]                       }
[10:32:51.796]                       else if (inherits(cond, "warning")) {
[10:32:51.796]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.796]                         if (muffled) 
[10:32:51.796]                           invokeRestart("muffleWarning")
[10:32:51.796]                       }
[10:32:51.796]                       else if (inherits(cond, "condition")) {
[10:32:51.796]                         if (!is.null(pattern)) {
[10:32:51.796]                           computeRestarts <- base::computeRestarts
[10:32:51.796]                           grepl <- base::grepl
[10:32:51.796]                           restarts <- computeRestarts(cond)
[10:32:51.796]                           for (restart in restarts) {
[10:32:51.796]                             name <- restart$name
[10:32:51.796]                             if (is.null(name)) 
[10:32:51.796]                               next
[10:32:51.796]                             if (!grepl(pattern, name)) 
[10:32:51.796]                               next
[10:32:51.796]                             invokeRestart(restart)
[10:32:51.796]                             muffled <- TRUE
[10:32:51.796]                             break
[10:32:51.796]                           }
[10:32:51.796]                         }
[10:32:51.796]                       }
[10:32:51.796]                       invisible(muffled)
[10:32:51.796]                     }
[10:32:51.796]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.796]                   }
[10:32:51.796]                 }
[10:32:51.796]                 else {
[10:32:51.796]                   if (TRUE) {
[10:32:51.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.796]                     {
[10:32:51.796]                       inherits <- base::inherits
[10:32:51.796]                       invokeRestart <- base::invokeRestart
[10:32:51.796]                       is.null <- base::is.null
[10:32:51.796]                       muffled <- FALSE
[10:32:51.796]                       if (inherits(cond, "message")) {
[10:32:51.796]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.796]                         if (muffled) 
[10:32:51.796]                           invokeRestart("muffleMessage")
[10:32:51.796]                       }
[10:32:51.796]                       else if (inherits(cond, "warning")) {
[10:32:51.796]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.796]                         if (muffled) 
[10:32:51.796]                           invokeRestart("muffleWarning")
[10:32:51.796]                       }
[10:32:51.796]                       else if (inherits(cond, "condition")) {
[10:32:51.796]                         if (!is.null(pattern)) {
[10:32:51.796]                           computeRestarts <- base::computeRestarts
[10:32:51.796]                           grepl <- base::grepl
[10:32:51.796]                           restarts <- computeRestarts(cond)
[10:32:51.796]                           for (restart in restarts) {
[10:32:51.796]                             name <- restart$name
[10:32:51.796]                             if (is.null(name)) 
[10:32:51.796]                               next
[10:32:51.796]                             if (!grepl(pattern, name)) 
[10:32:51.796]                               next
[10:32:51.796]                             invokeRestart(restart)
[10:32:51.796]                             muffled <- TRUE
[10:32:51.796]                             break
[10:32:51.796]                           }
[10:32:51.796]                         }
[10:32:51.796]                       }
[10:32:51.796]                       invisible(muffled)
[10:32:51.796]                     }
[10:32:51.796]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.796]                   }
[10:32:51.796]                 }
[10:32:51.796]             }
[10:32:51.796]         }))
[10:32:51.796]     }, error = function(ex) {
[10:32:51.796]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.796]                 ...future.rng), started = ...future.startTime, 
[10:32:51.796]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.796]             version = "1.8"), class = "FutureResult")
[10:32:51.796]     }, finally = {
[10:32:51.796]         if (!identical(...future.workdir, getwd())) 
[10:32:51.796]             setwd(...future.workdir)
[10:32:51.796]         {
[10:32:51.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.796]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.796]             }
[10:32:51.796]             base::options(...future.oldOptions)
[10:32:51.796]             if (.Platform$OS.type == "windows") {
[10:32:51.796]                 old_names <- names(...future.oldEnvVars)
[10:32:51.796]                 envs <- base::Sys.getenv()
[10:32:51.796]                 names <- names(envs)
[10:32:51.796]                 common <- intersect(names, old_names)
[10:32:51.796]                 added <- setdiff(names, old_names)
[10:32:51.796]                 removed <- setdiff(old_names, names)
[10:32:51.796]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.796]                   envs[common]]
[10:32:51.796]                 NAMES <- toupper(changed)
[10:32:51.796]                 args <- list()
[10:32:51.796]                 for (kk in seq_along(NAMES)) {
[10:32:51.796]                   name <- changed[[kk]]
[10:32:51.796]                   NAME <- NAMES[[kk]]
[10:32:51.796]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.796]                     next
[10:32:51.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.796]                 }
[10:32:51.796]                 NAMES <- toupper(added)
[10:32:51.796]                 for (kk in seq_along(NAMES)) {
[10:32:51.796]                   name <- added[[kk]]
[10:32:51.796]                   NAME <- NAMES[[kk]]
[10:32:51.796]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.796]                     next
[10:32:51.796]                   args[[name]] <- ""
[10:32:51.796]                 }
[10:32:51.796]                 NAMES <- toupper(removed)
[10:32:51.796]                 for (kk in seq_along(NAMES)) {
[10:32:51.796]                   name <- removed[[kk]]
[10:32:51.796]                   NAME <- NAMES[[kk]]
[10:32:51.796]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.796]                     next
[10:32:51.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.796]                 }
[10:32:51.796]                 if (length(args) > 0) 
[10:32:51.796]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.796]             }
[10:32:51.796]             else {
[10:32:51.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.796]             }
[10:32:51.796]             {
[10:32:51.796]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.796]                   0L) {
[10:32:51.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.796]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.796]                   base::options(opts)
[10:32:51.796]                 }
[10:32:51.796]                 {
[10:32:51.796]                   {
[10:32:51.796]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.796]                     NULL
[10:32:51.796]                   }
[10:32:51.796]                   options(future.plan = NULL)
[10:32:51.796]                   if (is.na(NA_character_)) 
[10:32:51.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.796]                     .init = FALSE)
[10:32:51.796]                 }
[10:32:51.796]             }
[10:32:51.796]         }
[10:32:51.796]     })
[10:32:51.796]     if (TRUE) {
[10:32:51.796]         base::sink(type = "output", split = FALSE)
[10:32:51.796]         if (TRUE) {
[10:32:51.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.796]         }
[10:32:51.796]         else {
[10:32:51.796]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.796]         }
[10:32:51.796]         base::close(...future.stdout)
[10:32:51.796]         ...future.stdout <- NULL
[10:32:51.796]     }
[10:32:51.796]     ...future.result$conditions <- ...future.conditions
[10:32:51.796]     ...future.result$finished <- base::Sys.time()
[10:32:51.796]     ...future.result
[10:32:51.796] }
[10:32:51.799] MultisessionFuture started
[10:32:51.799] - Launch lazy future ... done
[10:32:51.799] run() for ‘MultisessionFuture’ ... done
[10:32:51.799] getGlobalsAndPackages() ...
[10:32:51.800] Searching for globals...
[10:32:51.800] 
[10:32:51.800] Searching for globals ... DONE
[10:32:51.800] - globals: [0] <none>
[10:32:51.800] getGlobalsAndPackages() ... DONE
[10:32:51.800] run() for ‘Future’ ...
[10:32:51.800] - state: ‘created’
[10:32:51.801] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.814] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.814]   - Field: ‘node’
[10:32:51.815]   - Field: ‘label’
[10:32:51.815]   - Field: ‘local’
[10:32:51.815]   - Field: ‘owner’
[10:32:51.815]   - Field: ‘envir’
[10:32:51.815]   - Field: ‘workers’
[10:32:51.815]   - Field: ‘packages’
[10:32:51.815]   - Field: ‘gc’
[10:32:51.815]   - Field: ‘conditions’
[10:32:51.815]   - Field: ‘persistent’
[10:32:51.815]   - Field: ‘expr’
[10:32:51.815]   - Field: ‘uuid’
[10:32:51.816]   - Field: ‘seed’
[10:32:51.816]   - Field: ‘version’
[10:32:51.816]   - Field: ‘result’
[10:32:51.816]   - Field: ‘asynchronous’
[10:32:51.816]   - Field: ‘calls’
[10:32:51.816]   - Field: ‘globals’
[10:32:51.816]   - Field: ‘stdout’
[10:32:51.816]   - Field: ‘earlySignal’
[10:32:51.816]   - Field: ‘lazy’
[10:32:51.816]   - Field: ‘state’
[10:32:51.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.817] - Launch lazy future ...
[10:32:51.817] Packages needed by the future expression (n = 0): <none>
[10:32:51.817] Packages needed by future strategies (n = 0): <none>
[10:32:51.817] {
[10:32:51.817]     {
[10:32:51.817]         {
[10:32:51.817]             ...future.startTime <- base::Sys.time()
[10:32:51.817]             {
[10:32:51.817]                 {
[10:32:51.817]                   {
[10:32:51.817]                     {
[10:32:51.817]                       base::local({
[10:32:51.817]                         has_future <- base::requireNamespace("future", 
[10:32:51.817]                           quietly = TRUE)
[10:32:51.817]                         if (has_future) {
[10:32:51.817]                           ns <- base::getNamespace("future")
[10:32:51.817]                           version <- ns[[".package"]][["version"]]
[10:32:51.817]                           if (is.null(version)) 
[10:32:51.817]                             version <- utils::packageVersion("future")
[10:32:51.817]                         }
[10:32:51.817]                         else {
[10:32:51.817]                           version <- NULL
[10:32:51.817]                         }
[10:32:51.817]                         if (!has_future || version < "1.8.0") {
[10:32:51.817]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.817]                             "", base::R.version$version.string), 
[10:32:51.817]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.817]                               "release", "version")], collapse = " "), 
[10:32:51.817]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.817]                             info)
[10:32:51.817]                           info <- base::paste(info, collapse = "; ")
[10:32:51.817]                           if (!has_future) {
[10:32:51.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.817]                               info)
[10:32:51.817]                           }
[10:32:51.817]                           else {
[10:32:51.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.817]                               info, version)
[10:32:51.817]                           }
[10:32:51.817]                           base::stop(msg)
[10:32:51.817]                         }
[10:32:51.817]                       })
[10:32:51.817]                     }
[10:32:51.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.817]                     base::options(mc.cores = 1L)
[10:32:51.817]                   }
[10:32:51.817]                   ...future.strategy.old <- future::plan("list")
[10:32:51.817]                   options(future.plan = NULL)
[10:32:51.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.817]                 }
[10:32:51.817]                 ...future.workdir <- getwd()
[10:32:51.817]             }
[10:32:51.817]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.817]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.817]         }
[10:32:51.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.817]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.817]             base::names(...future.oldOptions))
[10:32:51.817]     }
[10:32:51.817]     if (FALSE) {
[10:32:51.817]     }
[10:32:51.817]     else {
[10:32:51.817]         if (TRUE) {
[10:32:51.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.817]                 open = "w")
[10:32:51.817]         }
[10:32:51.817]         else {
[10:32:51.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.817]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.817]         }
[10:32:51.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.817]             base::sink(type = "output", split = FALSE)
[10:32:51.817]             base::close(...future.stdout)
[10:32:51.817]         }, add = TRUE)
[10:32:51.817]     }
[10:32:51.817]     ...future.frame <- base::sys.nframe()
[10:32:51.817]     ...future.conditions <- base::list()
[10:32:51.817]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.817]     if (FALSE) {
[10:32:51.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.817]     }
[10:32:51.817]     ...future.result <- base::tryCatch({
[10:32:51.817]         base::withCallingHandlers({
[10:32:51.817]             ...future.value <- base::withVisible(base::local({
[10:32:51.817]                 ...future.makeSendCondition <- base::local({
[10:32:51.817]                   sendCondition <- NULL
[10:32:51.817]                   function(frame = 1L) {
[10:32:51.817]                     if (is.function(sendCondition)) 
[10:32:51.817]                       return(sendCondition)
[10:32:51.817]                     ns <- getNamespace("parallel")
[10:32:51.817]                     if (exists("sendData", mode = "function", 
[10:32:51.817]                       envir = ns)) {
[10:32:51.817]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.817]                         envir = ns)
[10:32:51.817]                       envir <- sys.frame(frame)
[10:32:51.817]                       master <- NULL
[10:32:51.817]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.817]                         !identical(envir, emptyenv())) {
[10:32:51.817]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.817]                           inherits = FALSE)) {
[10:32:51.817]                           master <- get("master", mode = "list", 
[10:32:51.817]                             envir = envir, inherits = FALSE)
[10:32:51.817]                           if (inherits(master, c("SOCKnode", 
[10:32:51.817]                             "SOCK0node"))) {
[10:32:51.817]                             sendCondition <<- function(cond) {
[10:32:51.817]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.817]                                 success = TRUE)
[10:32:51.817]                               parallel_sendData(master, data)
[10:32:51.817]                             }
[10:32:51.817]                             return(sendCondition)
[10:32:51.817]                           }
[10:32:51.817]                         }
[10:32:51.817]                         frame <- frame + 1L
[10:32:51.817]                         envir <- sys.frame(frame)
[10:32:51.817]                       }
[10:32:51.817]                     }
[10:32:51.817]                     sendCondition <<- function(cond) NULL
[10:32:51.817]                   }
[10:32:51.817]                 })
[10:32:51.817]                 withCallingHandlers({
[10:32:51.817]                   NULL
[10:32:51.817]                 }, immediateCondition = function(cond) {
[10:32:51.817]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.817]                   sendCondition(cond)
[10:32:51.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.817]                   {
[10:32:51.817]                     inherits <- base::inherits
[10:32:51.817]                     invokeRestart <- base::invokeRestart
[10:32:51.817]                     is.null <- base::is.null
[10:32:51.817]                     muffled <- FALSE
[10:32:51.817]                     if (inherits(cond, "message")) {
[10:32:51.817]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.817]                       if (muffled) 
[10:32:51.817]                         invokeRestart("muffleMessage")
[10:32:51.817]                     }
[10:32:51.817]                     else if (inherits(cond, "warning")) {
[10:32:51.817]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.817]                       if (muffled) 
[10:32:51.817]                         invokeRestart("muffleWarning")
[10:32:51.817]                     }
[10:32:51.817]                     else if (inherits(cond, "condition")) {
[10:32:51.817]                       if (!is.null(pattern)) {
[10:32:51.817]                         computeRestarts <- base::computeRestarts
[10:32:51.817]                         grepl <- base::grepl
[10:32:51.817]                         restarts <- computeRestarts(cond)
[10:32:51.817]                         for (restart in restarts) {
[10:32:51.817]                           name <- restart$name
[10:32:51.817]                           if (is.null(name)) 
[10:32:51.817]                             next
[10:32:51.817]                           if (!grepl(pattern, name)) 
[10:32:51.817]                             next
[10:32:51.817]                           invokeRestart(restart)
[10:32:51.817]                           muffled <- TRUE
[10:32:51.817]                           break
[10:32:51.817]                         }
[10:32:51.817]                       }
[10:32:51.817]                     }
[10:32:51.817]                     invisible(muffled)
[10:32:51.817]                   }
[10:32:51.817]                   muffleCondition(cond)
[10:32:51.817]                 })
[10:32:51.817]             }))
[10:32:51.817]             future::FutureResult(value = ...future.value$value, 
[10:32:51.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.817]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.817]                     ...future.globalenv.names))
[10:32:51.817]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.817]         }, condition = base::local({
[10:32:51.817]             c <- base::c
[10:32:51.817]             inherits <- base::inherits
[10:32:51.817]             invokeRestart <- base::invokeRestart
[10:32:51.817]             length <- base::length
[10:32:51.817]             list <- base::list
[10:32:51.817]             seq.int <- base::seq.int
[10:32:51.817]             signalCondition <- base::signalCondition
[10:32:51.817]             sys.calls <- base::sys.calls
[10:32:51.817]             `[[` <- base::`[[`
[10:32:51.817]             `+` <- base::`+`
[10:32:51.817]             `<<-` <- base::`<<-`
[10:32:51.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.817]                   3L)]
[10:32:51.817]             }
[10:32:51.817]             function(cond) {
[10:32:51.817]                 is_error <- inherits(cond, "error")
[10:32:51.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.817]                   NULL)
[10:32:51.817]                 if (is_error) {
[10:32:51.817]                   sessionInformation <- function() {
[10:32:51.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.817]                       search = base::search(), system = base::Sys.info())
[10:32:51.817]                   }
[10:32:51.817]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.817]                     cond$call), session = sessionInformation(), 
[10:32:51.817]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.817]                   signalCondition(cond)
[10:32:51.817]                 }
[10:32:51.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.817]                 "immediateCondition"))) {
[10:32:51.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.817]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.817]                   if (TRUE && !signal) {
[10:32:51.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.817]                     {
[10:32:51.817]                       inherits <- base::inherits
[10:32:51.817]                       invokeRestart <- base::invokeRestart
[10:32:51.817]                       is.null <- base::is.null
[10:32:51.817]                       muffled <- FALSE
[10:32:51.817]                       if (inherits(cond, "message")) {
[10:32:51.817]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.817]                         if (muffled) 
[10:32:51.817]                           invokeRestart("muffleMessage")
[10:32:51.817]                       }
[10:32:51.817]                       else if (inherits(cond, "warning")) {
[10:32:51.817]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.817]                         if (muffled) 
[10:32:51.817]                           invokeRestart("muffleWarning")
[10:32:51.817]                       }
[10:32:51.817]                       else if (inherits(cond, "condition")) {
[10:32:51.817]                         if (!is.null(pattern)) {
[10:32:51.817]                           computeRestarts <- base::computeRestarts
[10:32:51.817]                           grepl <- base::grepl
[10:32:51.817]                           restarts <- computeRestarts(cond)
[10:32:51.817]                           for (restart in restarts) {
[10:32:51.817]                             name <- restart$name
[10:32:51.817]                             if (is.null(name)) 
[10:32:51.817]                               next
[10:32:51.817]                             if (!grepl(pattern, name)) 
[10:32:51.817]                               next
[10:32:51.817]                             invokeRestart(restart)
[10:32:51.817]                             muffled <- TRUE
[10:32:51.817]                             break
[10:32:51.817]                           }
[10:32:51.817]                         }
[10:32:51.817]                       }
[10:32:51.817]                       invisible(muffled)
[10:32:51.817]                     }
[10:32:51.817]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.817]                   }
[10:32:51.817]                 }
[10:32:51.817]                 else {
[10:32:51.817]                   if (TRUE) {
[10:32:51.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.817]                     {
[10:32:51.817]                       inherits <- base::inherits
[10:32:51.817]                       invokeRestart <- base::invokeRestart
[10:32:51.817]                       is.null <- base::is.null
[10:32:51.817]                       muffled <- FALSE
[10:32:51.817]                       if (inherits(cond, "message")) {
[10:32:51.817]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.817]                         if (muffled) 
[10:32:51.817]                           invokeRestart("muffleMessage")
[10:32:51.817]                       }
[10:32:51.817]                       else if (inherits(cond, "warning")) {
[10:32:51.817]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.817]                         if (muffled) 
[10:32:51.817]                           invokeRestart("muffleWarning")
[10:32:51.817]                       }
[10:32:51.817]                       else if (inherits(cond, "condition")) {
[10:32:51.817]                         if (!is.null(pattern)) {
[10:32:51.817]                           computeRestarts <- base::computeRestarts
[10:32:51.817]                           grepl <- base::grepl
[10:32:51.817]                           restarts <- computeRestarts(cond)
[10:32:51.817]                           for (restart in restarts) {
[10:32:51.817]                             name <- restart$name
[10:32:51.817]                             if (is.null(name)) 
[10:32:51.817]                               next
[10:32:51.817]                             if (!grepl(pattern, name)) 
[10:32:51.817]                               next
[10:32:51.817]                             invokeRestart(restart)
[10:32:51.817]                             muffled <- TRUE
[10:32:51.817]                             break
[10:32:51.817]                           }
[10:32:51.817]                         }
[10:32:51.817]                       }
[10:32:51.817]                       invisible(muffled)
[10:32:51.817]                     }
[10:32:51.817]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.817]                   }
[10:32:51.817]                 }
[10:32:51.817]             }
[10:32:51.817]         }))
[10:32:51.817]     }, error = function(ex) {
[10:32:51.817]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.817]                 ...future.rng), started = ...future.startTime, 
[10:32:51.817]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.817]             version = "1.8"), class = "FutureResult")
[10:32:51.817]     }, finally = {
[10:32:51.817]         if (!identical(...future.workdir, getwd())) 
[10:32:51.817]             setwd(...future.workdir)
[10:32:51.817]         {
[10:32:51.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.817]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.817]             }
[10:32:51.817]             base::options(...future.oldOptions)
[10:32:51.817]             if (.Platform$OS.type == "windows") {
[10:32:51.817]                 old_names <- names(...future.oldEnvVars)
[10:32:51.817]                 envs <- base::Sys.getenv()
[10:32:51.817]                 names <- names(envs)
[10:32:51.817]                 common <- intersect(names, old_names)
[10:32:51.817]                 added <- setdiff(names, old_names)
[10:32:51.817]                 removed <- setdiff(old_names, names)
[10:32:51.817]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.817]                   envs[common]]
[10:32:51.817]                 NAMES <- toupper(changed)
[10:32:51.817]                 args <- list()
[10:32:51.817]                 for (kk in seq_along(NAMES)) {
[10:32:51.817]                   name <- changed[[kk]]
[10:32:51.817]                   NAME <- NAMES[[kk]]
[10:32:51.817]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.817]                     next
[10:32:51.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.817]                 }
[10:32:51.817]                 NAMES <- toupper(added)
[10:32:51.817]                 for (kk in seq_along(NAMES)) {
[10:32:51.817]                   name <- added[[kk]]
[10:32:51.817]                   NAME <- NAMES[[kk]]
[10:32:51.817]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.817]                     next
[10:32:51.817]                   args[[name]] <- ""
[10:32:51.817]                 }
[10:32:51.817]                 NAMES <- toupper(removed)
[10:32:51.817]                 for (kk in seq_along(NAMES)) {
[10:32:51.817]                   name <- removed[[kk]]
[10:32:51.817]                   NAME <- NAMES[[kk]]
[10:32:51.817]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.817]                     next
[10:32:51.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.817]                 }
[10:32:51.817]                 if (length(args) > 0) 
[10:32:51.817]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.817]             }
[10:32:51.817]             else {
[10:32:51.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.817]             }
[10:32:51.817]             {
[10:32:51.817]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.817]                   0L) {
[10:32:51.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.817]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.817]                   base::options(opts)
[10:32:51.817]                 }
[10:32:51.817]                 {
[10:32:51.817]                   {
[10:32:51.817]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.817]                     NULL
[10:32:51.817]                   }
[10:32:51.817]                   options(future.plan = NULL)
[10:32:51.817]                   if (is.na(NA_character_)) 
[10:32:51.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.817]                     .init = FALSE)
[10:32:51.817]                 }
[10:32:51.817]             }
[10:32:51.817]         }
[10:32:51.817]     })
[10:32:51.817]     if (TRUE) {
[10:32:51.817]         base::sink(type = "output", split = FALSE)
[10:32:51.817]         if (TRUE) {
[10:32:51.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.817]         }
[10:32:51.817]         else {
[10:32:51.817]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.817]         }
[10:32:51.817]         base::close(...future.stdout)
[10:32:51.817]         ...future.stdout <- NULL
[10:32:51.817]     }
[10:32:51.817]     ...future.result$conditions <- ...future.conditions
[10:32:51.817]     ...future.result$finished <- base::Sys.time()
[10:32:51.817]     ...future.result
[10:32:51.817] }
[10:32:51.820] MultisessionFuture started
[10:32:51.820] - Launch lazy future ... done
[10:32:51.820] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1418f38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0d70cf0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1418f38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d0d70cf0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:32:51.826] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.826] - Validating connection of MultisessionFuture
[10:32:51.826] - received message: FutureResult
[10:32:51.826] - Received FutureResult
[10:32:51.826] - Erased future from FutureRegistry
[10:32:51.827] result() for ClusterFuture ...
[10:32:51.827] - result already collected: FutureResult
[10:32:51.827] result() for ClusterFuture ... done
[10:32:51.827] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:51.827] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.827] - Validating connection of MultisessionFuture
[10:32:51.827] - received message: FutureResult
[10:32:51.828] - Received FutureResult
[10:32:51.828] - Erased future from FutureRegistry
[10:32:51.828] result() for ClusterFuture ...
[10:32:51.828] - result already collected: FutureResult
[10:32:51.828] result() for ClusterFuture ... done
[10:32:51.828] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:51.830] resolve() on list ...
[10:32:51.830]  recursive: 0
[10:32:51.830]  length: 6
[10:32:51.830]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:51.830] signalConditionsASAP(numeric, pos=1) ...
[10:32:51.830] - nx: 6
[10:32:51.830] - relay: TRUE
[10:32:51.830] - stdout: TRUE
[10:32:51.830] - signal: TRUE
[10:32:51.830] - resignal: FALSE
[10:32:51.830] - force: TRUE
[10:32:51.831] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.831] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.831]  - until=2
[10:32:51.831]  - relaying element #2
[10:32:51.831] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.831] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.831] signalConditionsASAP(NULL, pos=1) ... done
[10:32:51.831]  length: 5 (resolved future 1)
[10:32:51.831] Future #2
[10:32:51.831] result() for ClusterFuture ...
[10:32:51.832] - result already collected: FutureResult
[10:32:51.832] result() for ClusterFuture ... done
[10:32:51.832] result() for ClusterFuture ...
[10:32:51.832] - result already collected: FutureResult
[10:32:51.832] result() for ClusterFuture ... done
[10:32:51.832] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:51.832] - nx: 6
[10:32:51.832] - relay: TRUE
[10:32:51.832] - stdout: TRUE
[10:32:51.832] - signal: TRUE
[10:32:51.832] - resignal: FALSE
[10:32:51.832] - force: TRUE
[10:32:51.833] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.833] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.833]  - until=2
[10:32:51.833]  - relaying element #2
[10:32:51.833] result() for ClusterFuture ...
[10:32:51.833] - result already collected: FutureResult
[10:32:51.833] result() for ClusterFuture ... done
[10:32:51.833] result() for ClusterFuture ...
[10:32:51.833] - result already collected: FutureResult
[10:32:51.833] result() for ClusterFuture ... done
[10:32:51.833] result() for ClusterFuture ...
[10:32:51.834] - result already collected: FutureResult
[10:32:51.834] result() for ClusterFuture ... done
[10:32:51.834] result() for ClusterFuture ...
[10:32:51.834] - result already collected: FutureResult
[10:32:51.834] result() for ClusterFuture ... done
[10:32:51.834] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.834] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.834] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:51.834]  length: 4 (resolved future 2)
[10:32:51.834] Future #3
[10:32:51.834] result() for ClusterFuture ...
[10:32:51.835] - result already collected: FutureResult
[10:32:51.835] result() for ClusterFuture ... done
[10:32:51.835] result() for ClusterFuture ...
[10:32:51.835] - result already collected: FutureResult
[10:32:51.835] result() for ClusterFuture ... done
[10:32:51.835] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:51.835] - nx: 6
[10:32:51.835] - relay: TRUE
[10:32:51.835] - stdout: TRUE
[10:32:51.835] - signal: TRUE
[10:32:51.835] - resignal: FALSE
[10:32:51.835] - force: TRUE
[10:32:51.836] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.836] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.836]  - until=3
[10:32:51.836]  - relaying element #3
[10:32:51.836] result() for ClusterFuture ...
[10:32:51.836] - result already collected: FutureResult
[10:32:51.836] result() for ClusterFuture ... done
[10:32:51.836] result() for ClusterFuture ...
[10:32:51.836] - result already collected: FutureResult
[10:32:51.836] result() for ClusterFuture ... done
[10:32:51.836] result() for ClusterFuture ...
[10:32:51.837] - result already collected: FutureResult
[10:32:51.837] result() for ClusterFuture ... done
[10:32:51.837] result() for ClusterFuture ...
[10:32:51.837] - result already collected: FutureResult
[10:32:51.837] result() for ClusterFuture ... done
[10:32:51.837] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.837] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.837] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:51.837]  length: 3 (resolved future 3)
[10:32:51.837] signalConditionsASAP(NULL, pos=4) ...
[10:32:51.837] - nx: 6
[10:32:51.838] - relay: TRUE
[10:32:51.838] - stdout: TRUE
[10:32:51.838] - signal: TRUE
[10:32:51.838] - resignal: FALSE
[10:32:51.838] - force: TRUE
[10:32:51.838] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.838] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.838]  - until=5
[10:32:51.838]  - relaying element #5
[10:32:51.838] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.838] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.838] signalConditionsASAP(NULL, pos=4) ... done
[10:32:51.839]  length: 2 (resolved future 4)
[10:32:51.839] signalConditionsASAP(NULL, pos=5) ...
[10:32:51.839] - nx: 6
[10:32:51.839] - relay: TRUE
[10:32:51.839] - stdout: TRUE
[10:32:51.839] - signal: TRUE
[10:32:51.839] - resignal: FALSE
[10:32:51.839] - force: TRUE
[10:32:51.839] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.839] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.839]  - until=6
[10:32:51.839]  - relaying element #6
[10:32:51.840] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.840] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.840] signalConditionsASAP(NULL, pos=5) ... done
[10:32:51.840]  length: 1 (resolved future 5)
[10:32:51.840] signalConditionsASAP(numeric, pos=6) ...
[10:32:51.840] - nx: 6
[10:32:51.840] - relay: TRUE
[10:32:51.840] - stdout: TRUE
[10:32:51.840] - signal: TRUE
[10:32:51.840] - resignal: FALSE
[10:32:51.840] - force: TRUE
[10:32:51.840] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.841] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.841]  - until=6
[10:32:51.841] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.841] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.841] signalConditionsASAP(numeric, pos=6) ... done
[10:32:51.841]  length: 0 (resolved future 6)
[10:32:51.841] Relaying remaining futures
[10:32:51.841] signalConditionsASAP(NULL, pos=0) ...
[10:32:51.841] - nx: 6
[10:32:51.841] - relay: TRUE
[10:32:51.841] - stdout: TRUE
[10:32:51.842] - signal: TRUE
[10:32:51.842] - resignal: FALSE
[10:32:51.842] - force: TRUE
[10:32:51.842] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.842] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:51.842] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.842] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.842] signalConditionsASAP(NULL, pos=0) ... done
[10:32:51.842] resolve() on list ... DONE
[10:32:51.842] result() for ClusterFuture ...
[10:32:51.842] - result already collected: FutureResult
[10:32:51.843] result() for ClusterFuture ... done
[10:32:51.843] result() for ClusterFuture ...
[10:32:51.843] - result already collected: FutureResult
[10:32:51.843] result() for ClusterFuture ... done
[10:32:51.843] result() for ClusterFuture ...
[10:32:51.843] - result already collected: FutureResult
[10:32:51.843] result() for ClusterFuture ... done
[10:32:51.843] result() for ClusterFuture ...
[10:32:51.843] - result already collected: FutureResult
[10:32:51.843] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:32:51.846] getGlobalsAndPackages() ...
[10:32:51.847] Searching for globals...
[10:32:51.847] 
[10:32:51.847] Searching for globals ... DONE
[10:32:51.847] - globals: [0] <none>
[10:32:51.847] getGlobalsAndPackages() ... DONE
[10:32:51.847] run() for ‘Future’ ...
[10:32:51.847] - state: ‘created’
[10:32:51.848] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.861] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.862]   - Field: ‘node’
[10:32:51.862]   - Field: ‘label’
[10:32:51.862]   - Field: ‘local’
[10:32:51.862]   - Field: ‘owner’
[10:32:51.862]   - Field: ‘envir’
[10:32:51.862]   - Field: ‘workers’
[10:32:51.862]   - Field: ‘packages’
[10:32:51.862]   - Field: ‘gc’
[10:32:51.862]   - Field: ‘conditions’
[10:32:51.862]   - Field: ‘persistent’
[10:32:51.863]   - Field: ‘expr’
[10:32:51.863]   - Field: ‘uuid’
[10:32:51.863]   - Field: ‘seed’
[10:32:51.863]   - Field: ‘version’
[10:32:51.863]   - Field: ‘result’
[10:32:51.863]   - Field: ‘asynchronous’
[10:32:51.863]   - Field: ‘calls’
[10:32:51.863]   - Field: ‘globals’
[10:32:51.863]   - Field: ‘stdout’
[10:32:51.863]   - Field: ‘earlySignal’
[10:32:51.863]   - Field: ‘lazy’
[10:32:51.864]   - Field: ‘state’
[10:32:51.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.864] - Launch lazy future ...
[10:32:51.864] Packages needed by the future expression (n = 0): <none>
[10:32:51.864] Packages needed by future strategies (n = 0): <none>
[10:32:51.865] {
[10:32:51.865]     {
[10:32:51.865]         {
[10:32:51.865]             ...future.startTime <- base::Sys.time()
[10:32:51.865]             {
[10:32:51.865]                 {
[10:32:51.865]                   {
[10:32:51.865]                     {
[10:32:51.865]                       base::local({
[10:32:51.865]                         has_future <- base::requireNamespace("future", 
[10:32:51.865]                           quietly = TRUE)
[10:32:51.865]                         if (has_future) {
[10:32:51.865]                           ns <- base::getNamespace("future")
[10:32:51.865]                           version <- ns[[".package"]][["version"]]
[10:32:51.865]                           if (is.null(version)) 
[10:32:51.865]                             version <- utils::packageVersion("future")
[10:32:51.865]                         }
[10:32:51.865]                         else {
[10:32:51.865]                           version <- NULL
[10:32:51.865]                         }
[10:32:51.865]                         if (!has_future || version < "1.8.0") {
[10:32:51.865]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.865]                             "", base::R.version$version.string), 
[10:32:51.865]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.865]                               "release", "version")], collapse = " "), 
[10:32:51.865]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.865]                             info)
[10:32:51.865]                           info <- base::paste(info, collapse = "; ")
[10:32:51.865]                           if (!has_future) {
[10:32:51.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.865]                               info)
[10:32:51.865]                           }
[10:32:51.865]                           else {
[10:32:51.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.865]                               info, version)
[10:32:51.865]                           }
[10:32:51.865]                           base::stop(msg)
[10:32:51.865]                         }
[10:32:51.865]                       })
[10:32:51.865]                     }
[10:32:51.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.865]                     base::options(mc.cores = 1L)
[10:32:51.865]                   }
[10:32:51.865]                   ...future.strategy.old <- future::plan("list")
[10:32:51.865]                   options(future.plan = NULL)
[10:32:51.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.865]                 }
[10:32:51.865]                 ...future.workdir <- getwd()
[10:32:51.865]             }
[10:32:51.865]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.865]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.865]         }
[10:32:51.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.865]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.865]             base::names(...future.oldOptions))
[10:32:51.865]     }
[10:32:51.865]     if (FALSE) {
[10:32:51.865]     }
[10:32:51.865]     else {
[10:32:51.865]         if (TRUE) {
[10:32:51.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.865]                 open = "w")
[10:32:51.865]         }
[10:32:51.865]         else {
[10:32:51.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.865]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.865]         }
[10:32:51.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.865]             base::sink(type = "output", split = FALSE)
[10:32:51.865]             base::close(...future.stdout)
[10:32:51.865]         }, add = TRUE)
[10:32:51.865]     }
[10:32:51.865]     ...future.frame <- base::sys.nframe()
[10:32:51.865]     ...future.conditions <- base::list()
[10:32:51.865]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.865]     if (FALSE) {
[10:32:51.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.865]     }
[10:32:51.865]     ...future.result <- base::tryCatch({
[10:32:51.865]         base::withCallingHandlers({
[10:32:51.865]             ...future.value <- base::withVisible(base::local({
[10:32:51.865]                 ...future.makeSendCondition <- base::local({
[10:32:51.865]                   sendCondition <- NULL
[10:32:51.865]                   function(frame = 1L) {
[10:32:51.865]                     if (is.function(sendCondition)) 
[10:32:51.865]                       return(sendCondition)
[10:32:51.865]                     ns <- getNamespace("parallel")
[10:32:51.865]                     if (exists("sendData", mode = "function", 
[10:32:51.865]                       envir = ns)) {
[10:32:51.865]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.865]                         envir = ns)
[10:32:51.865]                       envir <- sys.frame(frame)
[10:32:51.865]                       master <- NULL
[10:32:51.865]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.865]                         !identical(envir, emptyenv())) {
[10:32:51.865]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.865]                           inherits = FALSE)) {
[10:32:51.865]                           master <- get("master", mode = "list", 
[10:32:51.865]                             envir = envir, inherits = FALSE)
[10:32:51.865]                           if (inherits(master, c("SOCKnode", 
[10:32:51.865]                             "SOCK0node"))) {
[10:32:51.865]                             sendCondition <<- function(cond) {
[10:32:51.865]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.865]                                 success = TRUE)
[10:32:51.865]                               parallel_sendData(master, data)
[10:32:51.865]                             }
[10:32:51.865]                             return(sendCondition)
[10:32:51.865]                           }
[10:32:51.865]                         }
[10:32:51.865]                         frame <- frame + 1L
[10:32:51.865]                         envir <- sys.frame(frame)
[10:32:51.865]                       }
[10:32:51.865]                     }
[10:32:51.865]                     sendCondition <<- function(cond) NULL
[10:32:51.865]                   }
[10:32:51.865]                 })
[10:32:51.865]                 withCallingHandlers({
[10:32:51.865]                   2
[10:32:51.865]                 }, immediateCondition = function(cond) {
[10:32:51.865]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.865]                   sendCondition(cond)
[10:32:51.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.865]                   {
[10:32:51.865]                     inherits <- base::inherits
[10:32:51.865]                     invokeRestart <- base::invokeRestart
[10:32:51.865]                     is.null <- base::is.null
[10:32:51.865]                     muffled <- FALSE
[10:32:51.865]                     if (inherits(cond, "message")) {
[10:32:51.865]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.865]                       if (muffled) 
[10:32:51.865]                         invokeRestart("muffleMessage")
[10:32:51.865]                     }
[10:32:51.865]                     else if (inherits(cond, "warning")) {
[10:32:51.865]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.865]                       if (muffled) 
[10:32:51.865]                         invokeRestart("muffleWarning")
[10:32:51.865]                     }
[10:32:51.865]                     else if (inherits(cond, "condition")) {
[10:32:51.865]                       if (!is.null(pattern)) {
[10:32:51.865]                         computeRestarts <- base::computeRestarts
[10:32:51.865]                         grepl <- base::grepl
[10:32:51.865]                         restarts <- computeRestarts(cond)
[10:32:51.865]                         for (restart in restarts) {
[10:32:51.865]                           name <- restart$name
[10:32:51.865]                           if (is.null(name)) 
[10:32:51.865]                             next
[10:32:51.865]                           if (!grepl(pattern, name)) 
[10:32:51.865]                             next
[10:32:51.865]                           invokeRestart(restart)
[10:32:51.865]                           muffled <- TRUE
[10:32:51.865]                           break
[10:32:51.865]                         }
[10:32:51.865]                       }
[10:32:51.865]                     }
[10:32:51.865]                     invisible(muffled)
[10:32:51.865]                   }
[10:32:51.865]                   muffleCondition(cond)
[10:32:51.865]                 })
[10:32:51.865]             }))
[10:32:51.865]             future::FutureResult(value = ...future.value$value, 
[10:32:51.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.865]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.865]                     ...future.globalenv.names))
[10:32:51.865]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.865]         }, condition = base::local({
[10:32:51.865]             c <- base::c
[10:32:51.865]             inherits <- base::inherits
[10:32:51.865]             invokeRestart <- base::invokeRestart
[10:32:51.865]             length <- base::length
[10:32:51.865]             list <- base::list
[10:32:51.865]             seq.int <- base::seq.int
[10:32:51.865]             signalCondition <- base::signalCondition
[10:32:51.865]             sys.calls <- base::sys.calls
[10:32:51.865]             `[[` <- base::`[[`
[10:32:51.865]             `+` <- base::`+`
[10:32:51.865]             `<<-` <- base::`<<-`
[10:32:51.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.865]                   3L)]
[10:32:51.865]             }
[10:32:51.865]             function(cond) {
[10:32:51.865]                 is_error <- inherits(cond, "error")
[10:32:51.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.865]                   NULL)
[10:32:51.865]                 if (is_error) {
[10:32:51.865]                   sessionInformation <- function() {
[10:32:51.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.865]                       search = base::search(), system = base::Sys.info())
[10:32:51.865]                   }
[10:32:51.865]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.865]                     cond$call), session = sessionInformation(), 
[10:32:51.865]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.865]                   signalCondition(cond)
[10:32:51.865]                 }
[10:32:51.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.865]                 "immediateCondition"))) {
[10:32:51.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.865]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.865]                   if (TRUE && !signal) {
[10:32:51.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.865]                     {
[10:32:51.865]                       inherits <- base::inherits
[10:32:51.865]                       invokeRestart <- base::invokeRestart
[10:32:51.865]                       is.null <- base::is.null
[10:32:51.865]                       muffled <- FALSE
[10:32:51.865]                       if (inherits(cond, "message")) {
[10:32:51.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.865]                         if (muffled) 
[10:32:51.865]                           invokeRestart("muffleMessage")
[10:32:51.865]                       }
[10:32:51.865]                       else if (inherits(cond, "warning")) {
[10:32:51.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.865]                         if (muffled) 
[10:32:51.865]                           invokeRestart("muffleWarning")
[10:32:51.865]                       }
[10:32:51.865]                       else if (inherits(cond, "condition")) {
[10:32:51.865]                         if (!is.null(pattern)) {
[10:32:51.865]                           computeRestarts <- base::computeRestarts
[10:32:51.865]                           grepl <- base::grepl
[10:32:51.865]                           restarts <- computeRestarts(cond)
[10:32:51.865]                           for (restart in restarts) {
[10:32:51.865]                             name <- restart$name
[10:32:51.865]                             if (is.null(name)) 
[10:32:51.865]                               next
[10:32:51.865]                             if (!grepl(pattern, name)) 
[10:32:51.865]                               next
[10:32:51.865]                             invokeRestart(restart)
[10:32:51.865]                             muffled <- TRUE
[10:32:51.865]                             break
[10:32:51.865]                           }
[10:32:51.865]                         }
[10:32:51.865]                       }
[10:32:51.865]                       invisible(muffled)
[10:32:51.865]                     }
[10:32:51.865]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.865]                   }
[10:32:51.865]                 }
[10:32:51.865]                 else {
[10:32:51.865]                   if (TRUE) {
[10:32:51.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.865]                     {
[10:32:51.865]                       inherits <- base::inherits
[10:32:51.865]                       invokeRestart <- base::invokeRestart
[10:32:51.865]                       is.null <- base::is.null
[10:32:51.865]                       muffled <- FALSE
[10:32:51.865]                       if (inherits(cond, "message")) {
[10:32:51.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.865]                         if (muffled) 
[10:32:51.865]                           invokeRestart("muffleMessage")
[10:32:51.865]                       }
[10:32:51.865]                       else if (inherits(cond, "warning")) {
[10:32:51.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.865]                         if (muffled) 
[10:32:51.865]                           invokeRestart("muffleWarning")
[10:32:51.865]                       }
[10:32:51.865]                       else if (inherits(cond, "condition")) {
[10:32:51.865]                         if (!is.null(pattern)) {
[10:32:51.865]                           computeRestarts <- base::computeRestarts
[10:32:51.865]                           grepl <- base::grepl
[10:32:51.865]                           restarts <- computeRestarts(cond)
[10:32:51.865]                           for (restart in restarts) {
[10:32:51.865]                             name <- restart$name
[10:32:51.865]                             if (is.null(name)) 
[10:32:51.865]                               next
[10:32:51.865]                             if (!grepl(pattern, name)) 
[10:32:51.865]                               next
[10:32:51.865]                             invokeRestart(restart)
[10:32:51.865]                             muffled <- TRUE
[10:32:51.865]                             break
[10:32:51.865]                           }
[10:32:51.865]                         }
[10:32:51.865]                       }
[10:32:51.865]                       invisible(muffled)
[10:32:51.865]                     }
[10:32:51.865]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.865]                   }
[10:32:51.865]                 }
[10:32:51.865]             }
[10:32:51.865]         }))
[10:32:51.865]     }, error = function(ex) {
[10:32:51.865]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.865]                 ...future.rng), started = ...future.startTime, 
[10:32:51.865]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.865]             version = "1.8"), class = "FutureResult")
[10:32:51.865]     }, finally = {
[10:32:51.865]         if (!identical(...future.workdir, getwd())) 
[10:32:51.865]             setwd(...future.workdir)
[10:32:51.865]         {
[10:32:51.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.865]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.865]             }
[10:32:51.865]             base::options(...future.oldOptions)
[10:32:51.865]             if (.Platform$OS.type == "windows") {
[10:32:51.865]                 old_names <- names(...future.oldEnvVars)
[10:32:51.865]                 envs <- base::Sys.getenv()
[10:32:51.865]                 names <- names(envs)
[10:32:51.865]                 common <- intersect(names, old_names)
[10:32:51.865]                 added <- setdiff(names, old_names)
[10:32:51.865]                 removed <- setdiff(old_names, names)
[10:32:51.865]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.865]                   envs[common]]
[10:32:51.865]                 NAMES <- toupper(changed)
[10:32:51.865]                 args <- list()
[10:32:51.865]                 for (kk in seq_along(NAMES)) {
[10:32:51.865]                   name <- changed[[kk]]
[10:32:51.865]                   NAME <- NAMES[[kk]]
[10:32:51.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.865]                     next
[10:32:51.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.865]                 }
[10:32:51.865]                 NAMES <- toupper(added)
[10:32:51.865]                 for (kk in seq_along(NAMES)) {
[10:32:51.865]                   name <- added[[kk]]
[10:32:51.865]                   NAME <- NAMES[[kk]]
[10:32:51.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.865]                     next
[10:32:51.865]                   args[[name]] <- ""
[10:32:51.865]                 }
[10:32:51.865]                 NAMES <- toupper(removed)
[10:32:51.865]                 for (kk in seq_along(NAMES)) {
[10:32:51.865]                   name <- removed[[kk]]
[10:32:51.865]                   NAME <- NAMES[[kk]]
[10:32:51.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.865]                     next
[10:32:51.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.865]                 }
[10:32:51.865]                 if (length(args) > 0) 
[10:32:51.865]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.865]             }
[10:32:51.865]             else {
[10:32:51.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.865]             }
[10:32:51.865]             {
[10:32:51.865]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.865]                   0L) {
[10:32:51.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.865]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.865]                   base::options(opts)
[10:32:51.865]                 }
[10:32:51.865]                 {
[10:32:51.865]                   {
[10:32:51.865]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.865]                     NULL
[10:32:51.865]                   }
[10:32:51.865]                   options(future.plan = NULL)
[10:32:51.865]                   if (is.na(NA_character_)) 
[10:32:51.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.865]                     .init = FALSE)
[10:32:51.865]                 }
[10:32:51.865]             }
[10:32:51.865]         }
[10:32:51.865]     })
[10:32:51.865]     if (TRUE) {
[10:32:51.865]         base::sink(type = "output", split = FALSE)
[10:32:51.865]         if (TRUE) {
[10:32:51.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.865]         }
[10:32:51.865]         else {
[10:32:51.865]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.865]         }
[10:32:51.865]         base::close(...future.stdout)
[10:32:51.865]         ...future.stdout <- NULL
[10:32:51.865]     }
[10:32:51.865]     ...future.result$conditions <- ...future.conditions
[10:32:51.865]     ...future.result$finished <- base::Sys.time()
[10:32:51.865]     ...future.result
[10:32:51.865] }
[10:32:51.867] MultisessionFuture started
[10:32:51.868] - Launch lazy future ... done
[10:32:51.868] run() for ‘MultisessionFuture’ ... done
[10:32:51.868] getGlobalsAndPackages() ...
[10:32:51.868] Searching for globals...
[10:32:51.868] 
[10:32:51.868] Searching for globals ... DONE
[10:32:51.868] - globals: [0] <none>
[10:32:51.868] getGlobalsAndPackages() ... DONE
[10:32:51.869] run() for ‘Future’ ...
[10:32:51.869] - state: ‘created’
[10:32:51.869] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.883] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.883]   - Field: ‘node’
[10:32:51.883]   - Field: ‘label’
[10:32:51.883]   - Field: ‘local’
[10:32:51.883]   - Field: ‘owner’
[10:32:51.883]   - Field: ‘envir’
[10:32:51.883]   - Field: ‘workers’
[10:32:51.883]   - Field: ‘packages’
[10:32:51.884]   - Field: ‘gc’
[10:32:51.884]   - Field: ‘conditions’
[10:32:51.884]   - Field: ‘persistent’
[10:32:51.884]   - Field: ‘expr’
[10:32:51.884]   - Field: ‘uuid’
[10:32:51.884]   - Field: ‘seed’
[10:32:51.884]   - Field: ‘version’
[10:32:51.884]   - Field: ‘result’
[10:32:51.884]   - Field: ‘asynchronous’
[10:32:51.884]   - Field: ‘calls’
[10:32:51.884]   - Field: ‘globals’
[10:32:51.885]   - Field: ‘stdout’
[10:32:51.885]   - Field: ‘earlySignal’
[10:32:51.885]   - Field: ‘lazy’
[10:32:51.885]   - Field: ‘state’
[10:32:51.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.885] - Launch lazy future ...
[10:32:51.885] Packages needed by the future expression (n = 0): <none>
[10:32:51.885] Packages needed by future strategies (n = 0): <none>
[10:32:51.886] {
[10:32:51.886]     {
[10:32:51.886]         {
[10:32:51.886]             ...future.startTime <- base::Sys.time()
[10:32:51.886]             {
[10:32:51.886]                 {
[10:32:51.886]                   {
[10:32:51.886]                     {
[10:32:51.886]                       base::local({
[10:32:51.886]                         has_future <- base::requireNamespace("future", 
[10:32:51.886]                           quietly = TRUE)
[10:32:51.886]                         if (has_future) {
[10:32:51.886]                           ns <- base::getNamespace("future")
[10:32:51.886]                           version <- ns[[".package"]][["version"]]
[10:32:51.886]                           if (is.null(version)) 
[10:32:51.886]                             version <- utils::packageVersion("future")
[10:32:51.886]                         }
[10:32:51.886]                         else {
[10:32:51.886]                           version <- NULL
[10:32:51.886]                         }
[10:32:51.886]                         if (!has_future || version < "1.8.0") {
[10:32:51.886]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.886]                             "", base::R.version$version.string), 
[10:32:51.886]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.886]                               "release", "version")], collapse = " "), 
[10:32:51.886]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.886]                             info)
[10:32:51.886]                           info <- base::paste(info, collapse = "; ")
[10:32:51.886]                           if (!has_future) {
[10:32:51.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.886]                               info)
[10:32:51.886]                           }
[10:32:51.886]                           else {
[10:32:51.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.886]                               info, version)
[10:32:51.886]                           }
[10:32:51.886]                           base::stop(msg)
[10:32:51.886]                         }
[10:32:51.886]                       })
[10:32:51.886]                     }
[10:32:51.886]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.886]                     base::options(mc.cores = 1L)
[10:32:51.886]                   }
[10:32:51.886]                   ...future.strategy.old <- future::plan("list")
[10:32:51.886]                   options(future.plan = NULL)
[10:32:51.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.886]                 }
[10:32:51.886]                 ...future.workdir <- getwd()
[10:32:51.886]             }
[10:32:51.886]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.886]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.886]         }
[10:32:51.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.886]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.886]             base::names(...future.oldOptions))
[10:32:51.886]     }
[10:32:51.886]     if (FALSE) {
[10:32:51.886]     }
[10:32:51.886]     else {
[10:32:51.886]         if (TRUE) {
[10:32:51.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.886]                 open = "w")
[10:32:51.886]         }
[10:32:51.886]         else {
[10:32:51.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.886]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.886]         }
[10:32:51.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.886]             base::sink(type = "output", split = FALSE)
[10:32:51.886]             base::close(...future.stdout)
[10:32:51.886]         }, add = TRUE)
[10:32:51.886]     }
[10:32:51.886]     ...future.frame <- base::sys.nframe()
[10:32:51.886]     ...future.conditions <- base::list()
[10:32:51.886]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.886]     if (FALSE) {
[10:32:51.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.886]     }
[10:32:51.886]     ...future.result <- base::tryCatch({
[10:32:51.886]         base::withCallingHandlers({
[10:32:51.886]             ...future.value <- base::withVisible(base::local({
[10:32:51.886]                 ...future.makeSendCondition <- base::local({
[10:32:51.886]                   sendCondition <- NULL
[10:32:51.886]                   function(frame = 1L) {
[10:32:51.886]                     if (is.function(sendCondition)) 
[10:32:51.886]                       return(sendCondition)
[10:32:51.886]                     ns <- getNamespace("parallel")
[10:32:51.886]                     if (exists("sendData", mode = "function", 
[10:32:51.886]                       envir = ns)) {
[10:32:51.886]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.886]                         envir = ns)
[10:32:51.886]                       envir <- sys.frame(frame)
[10:32:51.886]                       master <- NULL
[10:32:51.886]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.886]                         !identical(envir, emptyenv())) {
[10:32:51.886]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.886]                           inherits = FALSE)) {
[10:32:51.886]                           master <- get("master", mode = "list", 
[10:32:51.886]                             envir = envir, inherits = FALSE)
[10:32:51.886]                           if (inherits(master, c("SOCKnode", 
[10:32:51.886]                             "SOCK0node"))) {
[10:32:51.886]                             sendCondition <<- function(cond) {
[10:32:51.886]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.886]                                 success = TRUE)
[10:32:51.886]                               parallel_sendData(master, data)
[10:32:51.886]                             }
[10:32:51.886]                             return(sendCondition)
[10:32:51.886]                           }
[10:32:51.886]                         }
[10:32:51.886]                         frame <- frame + 1L
[10:32:51.886]                         envir <- sys.frame(frame)
[10:32:51.886]                       }
[10:32:51.886]                     }
[10:32:51.886]                     sendCondition <<- function(cond) NULL
[10:32:51.886]                   }
[10:32:51.886]                 })
[10:32:51.886]                 withCallingHandlers({
[10:32:51.886]                   NULL
[10:32:51.886]                 }, immediateCondition = function(cond) {
[10:32:51.886]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.886]                   sendCondition(cond)
[10:32:51.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.886]                   {
[10:32:51.886]                     inherits <- base::inherits
[10:32:51.886]                     invokeRestart <- base::invokeRestart
[10:32:51.886]                     is.null <- base::is.null
[10:32:51.886]                     muffled <- FALSE
[10:32:51.886]                     if (inherits(cond, "message")) {
[10:32:51.886]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.886]                       if (muffled) 
[10:32:51.886]                         invokeRestart("muffleMessage")
[10:32:51.886]                     }
[10:32:51.886]                     else if (inherits(cond, "warning")) {
[10:32:51.886]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.886]                       if (muffled) 
[10:32:51.886]                         invokeRestart("muffleWarning")
[10:32:51.886]                     }
[10:32:51.886]                     else if (inherits(cond, "condition")) {
[10:32:51.886]                       if (!is.null(pattern)) {
[10:32:51.886]                         computeRestarts <- base::computeRestarts
[10:32:51.886]                         grepl <- base::grepl
[10:32:51.886]                         restarts <- computeRestarts(cond)
[10:32:51.886]                         for (restart in restarts) {
[10:32:51.886]                           name <- restart$name
[10:32:51.886]                           if (is.null(name)) 
[10:32:51.886]                             next
[10:32:51.886]                           if (!grepl(pattern, name)) 
[10:32:51.886]                             next
[10:32:51.886]                           invokeRestart(restart)
[10:32:51.886]                           muffled <- TRUE
[10:32:51.886]                           break
[10:32:51.886]                         }
[10:32:51.886]                       }
[10:32:51.886]                     }
[10:32:51.886]                     invisible(muffled)
[10:32:51.886]                   }
[10:32:51.886]                   muffleCondition(cond)
[10:32:51.886]                 })
[10:32:51.886]             }))
[10:32:51.886]             future::FutureResult(value = ...future.value$value, 
[10:32:51.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.886]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.886]                     ...future.globalenv.names))
[10:32:51.886]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.886]         }, condition = base::local({
[10:32:51.886]             c <- base::c
[10:32:51.886]             inherits <- base::inherits
[10:32:51.886]             invokeRestart <- base::invokeRestart
[10:32:51.886]             length <- base::length
[10:32:51.886]             list <- base::list
[10:32:51.886]             seq.int <- base::seq.int
[10:32:51.886]             signalCondition <- base::signalCondition
[10:32:51.886]             sys.calls <- base::sys.calls
[10:32:51.886]             `[[` <- base::`[[`
[10:32:51.886]             `+` <- base::`+`
[10:32:51.886]             `<<-` <- base::`<<-`
[10:32:51.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.886]                   3L)]
[10:32:51.886]             }
[10:32:51.886]             function(cond) {
[10:32:51.886]                 is_error <- inherits(cond, "error")
[10:32:51.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.886]                   NULL)
[10:32:51.886]                 if (is_error) {
[10:32:51.886]                   sessionInformation <- function() {
[10:32:51.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.886]                       search = base::search(), system = base::Sys.info())
[10:32:51.886]                   }
[10:32:51.886]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.886]                     cond$call), session = sessionInformation(), 
[10:32:51.886]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.886]                   signalCondition(cond)
[10:32:51.886]                 }
[10:32:51.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.886]                 "immediateCondition"))) {
[10:32:51.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.886]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.886]                   if (TRUE && !signal) {
[10:32:51.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.886]                     {
[10:32:51.886]                       inherits <- base::inherits
[10:32:51.886]                       invokeRestart <- base::invokeRestart
[10:32:51.886]                       is.null <- base::is.null
[10:32:51.886]                       muffled <- FALSE
[10:32:51.886]                       if (inherits(cond, "message")) {
[10:32:51.886]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.886]                         if (muffled) 
[10:32:51.886]                           invokeRestart("muffleMessage")
[10:32:51.886]                       }
[10:32:51.886]                       else if (inherits(cond, "warning")) {
[10:32:51.886]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.886]                         if (muffled) 
[10:32:51.886]                           invokeRestart("muffleWarning")
[10:32:51.886]                       }
[10:32:51.886]                       else if (inherits(cond, "condition")) {
[10:32:51.886]                         if (!is.null(pattern)) {
[10:32:51.886]                           computeRestarts <- base::computeRestarts
[10:32:51.886]                           grepl <- base::grepl
[10:32:51.886]                           restarts <- computeRestarts(cond)
[10:32:51.886]                           for (restart in restarts) {
[10:32:51.886]                             name <- restart$name
[10:32:51.886]                             if (is.null(name)) 
[10:32:51.886]                               next
[10:32:51.886]                             if (!grepl(pattern, name)) 
[10:32:51.886]                               next
[10:32:51.886]                             invokeRestart(restart)
[10:32:51.886]                             muffled <- TRUE
[10:32:51.886]                             break
[10:32:51.886]                           }
[10:32:51.886]                         }
[10:32:51.886]                       }
[10:32:51.886]                       invisible(muffled)
[10:32:51.886]                     }
[10:32:51.886]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.886]                   }
[10:32:51.886]                 }
[10:32:51.886]                 else {
[10:32:51.886]                   if (TRUE) {
[10:32:51.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.886]                     {
[10:32:51.886]                       inherits <- base::inherits
[10:32:51.886]                       invokeRestart <- base::invokeRestart
[10:32:51.886]                       is.null <- base::is.null
[10:32:51.886]                       muffled <- FALSE
[10:32:51.886]                       if (inherits(cond, "message")) {
[10:32:51.886]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.886]                         if (muffled) 
[10:32:51.886]                           invokeRestart("muffleMessage")
[10:32:51.886]                       }
[10:32:51.886]                       else if (inherits(cond, "warning")) {
[10:32:51.886]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.886]                         if (muffled) 
[10:32:51.886]                           invokeRestart("muffleWarning")
[10:32:51.886]                       }
[10:32:51.886]                       else if (inherits(cond, "condition")) {
[10:32:51.886]                         if (!is.null(pattern)) {
[10:32:51.886]                           computeRestarts <- base::computeRestarts
[10:32:51.886]                           grepl <- base::grepl
[10:32:51.886]                           restarts <- computeRestarts(cond)
[10:32:51.886]                           for (restart in restarts) {
[10:32:51.886]                             name <- restart$name
[10:32:51.886]                             if (is.null(name)) 
[10:32:51.886]                               next
[10:32:51.886]                             if (!grepl(pattern, name)) 
[10:32:51.886]                               next
[10:32:51.886]                             invokeRestart(restart)
[10:32:51.886]                             muffled <- TRUE
[10:32:51.886]                             break
[10:32:51.886]                           }
[10:32:51.886]                         }
[10:32:51.886]                       }
[10:32:51.886]                       invisible(muffled)
[10:32:51.886]                     }
[10:32:51.886]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.886]                   }
[10:32:51.886]                 }
[10:32:51.886]             }
[10:32:51.886]         }))
[10:32:51.886]     }, error = function(ex) {
[10:32:51.886]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.886]                 ...future.rng), started = ...future.startTime, 
[10:32:51.886]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.886]             version = "1.8"), class = "FutureResult")
[10:32:51.886]     }, finally = {
[10:32:51.886]         if (!identical(...future.workdir, getwd())) 
[10:32:51.886]             setwd(...future.workdir)
[10:32:51.886]         {
[10:32:51.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.886]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.886]             }
[10:32:51.886]             base::options(...future.oldOptions)
[10:32:51.886]             if (.Platform$OS.type == "windows") {
[10:32:51.886]                 old_names <- names(...future.oldEnvVars)
[10:32:51.886]                 envs <- base::Sys.getenv()
[10:32:51.886]                 names <- names(envs)
[10:32:51.886]                 common <- intersect(names, old_names)
[10:32:51.886]                 added <- setdiff(names, old_names)
[10:32:51.886]                 removed <- setdiff(old_names, names)
[10:32:51.886]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.886]                   envs[common]]
[10:32:51.886]                 NAMES <- toupper(changed)
[10:32:51.886]                 args <- list()
[10:32:51.886]                 for (kk in seq_along(NAMES)) {
[10:32:51.886]                   name <- changed[[kk]]
[10:32:51.886]                   NAME <- NAMES[[kk]]
[10:32:51.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.886]                     next
[10:32:51.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.886]                 }
[10:32:51.886]                 NAMES <- toupper(added)
[10:32:51.886]                 for (kk in seq_along(NAMES)) {
[10:32:51.886]                   name <- added[[kk]]
[10:32:51.886]                   NAME <- NAMES[[kk]]
[10:32:51.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.886]                     next
[10:32:51.886]                   args[[name]] <- ""
[10:32:51.886]                 }
[10:32:51.886]                 NAMES <- toupper(removed)
[10:32:51.886]                 for (kk in seq_along(NAMES)) {
[10:32:51.886]                   name <- removed[[kk]]
[10:32:51.886]                   NAME <- NAMES[[kk]]
[10:32:51.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.886]                     next
[10:32:51.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.886]                 }
[10:32:51.886]                 if (length(args) > 0) 
[10:32:51.886]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.886]             }
[10:32:51.886]             else {
[10:32:51.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.886]             }
[10:32:51.886]             {
[10:32:51.886]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.886]                   0L) {
[10:32:51.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.886]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.886]                   base::options(opts)
[10:32:51.886]                 }
[10:32:51.886]                 {
[10:32:51.886]                   {
[10:32:51.886]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.886]                     NULL
[10:32:51.886]                   }
[10:32:51.886]                   options(future.plan = NULL)
[10:32:51.886]                   if (is.na(NA_character_)) 
[10:32:51.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.886]                     .init = FALSE)
[10:32:51.886]                 }
[10:32:51.886]             }
[10:32:51.886]         }
[10:32:51.886]     })
[10:32:51.886]     if (TRUE) {
[10:32:51.886]         base::sink(type = "output", split = FALSE)
[10:32:51.886]         if (TRUE) {
[10:32:51.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.886]         }
[10:32:51.886]         else {
[10:32:51.886]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.886]         }
[10:32:51.886]         base::close(...future.stdout)
[10:32:51.886]         ...future.stdout <- NULL
[10:32:51.886]     }
[10:32:51.886]     ...future.result$conditions <- ...future.conditions
[10:32:51.886]     ...future.result$finished <- base::Sys.time()
[10:32:51.886]     ...future.result
[10:32:51.886] }
[10:32:51.889] MultisessionFuture started
[10:32:51.889] - Launch lazy future ... done
[10:32:51.889] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d26c1460> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d2ac5e40> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d26c1460> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d2ac5e40> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:32:51.895] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.895] - Validating connection of MultisessionFuture
[10:32:51.895] - received message: FutureResult
[10:32:51.895] - Received FutureResult
[10:32:51.895] - Erased future from FutureRegistry
[10:32:51.895] result() for ClusterFuture ...
[10:32:51.895] - result already collected: FutureResult
[10:32:51.897] result() for ClusterFuture ... done
[10:32:51.898] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:51.898] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.898] - Validating connection of MultisessionFuture
[10:32:51.898] - received message: FutureResult
[10:32:51.899] - Received FutureResult
[10:32:51.899] - Erased future from FutureRegistry
[10:32:51.899] result() for ClusterFuture ...
[10:32:51.899] - result already collected: FutureResult
[10:32:51.899] result() for ClusterFuture ... done
[10:32:51.899] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:51.900] resolve() on list ...
[10:32:51.901]  recursive: 0
[10:32:51.901]  length: 6
[10:32:51.901]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:51.901] signalConditionsASAP(numeric, pos=1) ...
[10:32:51.901] - nx: 6
[10:32:51.901] - relay: TRUE
[10:32:51.901] - stdout: TRUE
[10:32:51.901] - signal: TRUE
[10:32:51.901] - resignal: FALSE
[10:32:51.901] - force: TRUE
[10:32:51.901] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.902] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.902]  - until=2
[10:32:51.902]  - relaying element #2
[10:32:51.902] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.902] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.902] signalConditionsASAP(NULL, pos=1) ... done
[10:32:51.902]  length: 5 (resolved future 1)
[10:32:51.902] Future #2
[10:32:51.902] result() for ClusterFuture ...
[10:32:51.902] - result already collected: FutureResult
[10:32:51.902] result() for ClusterFuture ... done
[10:32:51.903] result() for ClusterFuture ...
[10:32:51.903] - result already collected: FutureResult
[10:32:51.903] result() for ClusterFuture ... done
[10:32:51.903] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:51.903] - nx: 6
[10:32:51.903] - relay: TRUE
[10:32:51.903] - stdout: TRUE
[10:32:51.903] - signal: TRUE
[10:32:51.903] - resignal: FALSE
[10:32:51.903] - force: TRUE
[10:32:51.903] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.903] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.904]  - until=2
[10:32:51.904]  - relaying element #2
[10:32:51.904] result() for ClusterFuture ...
[10:32:51.904] - result already collected: FutureResult
[10:32:51.904] result() for ClusterFuture ... done
[10:32:51.904] result() for ClusterFuture ...
[10:32:51.904] - result already collected: FutureResult
[10:32:51.904] result() for ClusterFuture ... done
[10:32:51.904] result() for ClusterFuture ...
[10:32:51.904] - result already collected: FutureResult
[10:32:51.904] result() for ClusterFuture ... done
[10:32:51.905] result() for ClusterFuture ...
[10:32:51.905] - result already collected: FutureResult
[10:32:51.905] result() for ClusterFuture ... done
[10:32:51.905] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.905] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.905] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:51.905]  length: 4 (resolved future 2)
[10:32:51.905] Future #3
[10:32:51.905] result() for ClusterFuture ...
[10:32:51.905] - result already collected: FutureResult
[10:32:51.905] result() for ClusterFuture ... done
[10:32:51.906] result() for ClusterFuture ...
[10:32:51.906] - result already collected: FutureResult
[10:32:51.906] result() for ClusterFuture ... done
[10:32:51.906] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:51.906] - nx: 6
[10:32:51.906] - relay: TRUE
[10:32:51.906] - stdout: TRUE
[10:32:51.906] - signal: TRUE
[10:32:51.906] - resignal: FALSE
[10:32:51.906] - force: TRUE
[10:32:51.906] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.906] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.907]  - until=3
[10:32:51.907]  - relaying element #3
[10:32:51.907] result() for ClusterFuture ...
[10:32:51.907] - result already collected: FutureResult
[10:32:51.907] result() for ClusterFuture ... done
[10:32:51.907] result() for ClusterFuture ...
[10:32:51.907] - result already collected: FutureResult
[10:32:51.907] result() for ClusterFuture ... done
[10:32:51.907] result() for ClusterFuture ...
[10:32:51.907] - result already collected: FutureResult
[10:32:51.907] result() for ClusterFuture ... done
[10:32:51.907] result() for ClusterFuture ...
[10:32:51.908] - result already collected: FutureResult
[10:32:51.908] result() for ClusterFuture ... done
[10:32:51.908] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.908] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.908] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:51.908]  length: 3 (resolved future 3)
[10:32:51.908] signalConditionsASAP(NULL, pos=4) ...
[10:32:51.908] - nx: 6
[10:32:51.908] - relay: TRUE
[10:32:51.908] - stdout: TRUE
[10:32:51.908] - signal: TRUE
[10:32:51.908] - resignal: FALSE
[10:32:51.909] - force: TRUE
[10:32:51.909] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.909] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.909]  - until=5
[10:32:51.909]  - relaying element #5
[10:32:51.909] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.909] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.909] signalConditionsASAP(NULL, pos=4) ... done
[10:32:51.909]  length: 2 (resolved future 4)
[10:32:51.909] signalConditionsASAP(NULL, pos=5) ...
[10:32:51.909] - nx: 6
[10:32:51.909] - relay: TRUE
[10:32:51.910] - stdout: TRUE
[10:32:51.910] - signal: TRUE
[10:32:51.910] - resignal: FALSE
[10:32:51.910] - force: TRUE
[10:32:51.910] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.910] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.910]  - until=6
[10:32:51.910]  - relaying element #6
[10:32:51.910] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.910] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.910] signalConditionsASAP(NULL, pos=5) ... done
[10:32:51.910]  length: 1 (resolved future 5)
[10:32:51.911] signalConditionsASAP(numeric, pos=6) ...
[10:32:51.911] - nx: 6
[10:32:51.911] - relay: TRUE
[10:32:51.911] - stdout: TRUE
[10:32:51.911] - signal: TRUE
[10:32:51.911] - resignal: FALSE
[10:32:51.911] - force: TRUE
[10:32:51.911] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.911] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.911]  - until=6
[10:32:51.911] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.911] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.912] signalConditionsASAP(numeric, pos=6) ... done
[10:32:51.912]  length: 0 (resolved future 6)
[10:32:51.912] Relaying remaining futures
[10:32:51.912] signalConditionsASAP(NULL, pos=0) ...
[10:32:51.912] - nx: 6
[10:32:51.912] - relay: TRUE
[10:32:51.912] - stdout: TRUE
[10:32:51.912] - signal: TRUE
[10:32:51.912] - resignal: FALSE
[10:32:51.912] - force: TRUE
[10:32:51.912] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.912] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:51.913] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.913] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.913] signalConditionsASAP(NULL, pos=0) ... done
[10:32:51.913] resolve() on list ... DONE
[10:32:51.913] result() for ClusterFuture ...
[10:32:51.913] - result already collected: FutureResult
[10:32:51.913] result() for ClusterFuture ... done
[10:32:51.913] result() for ClusterFuture ...
[10:32:51.913] - result already collected: FutureResult
[10:32:51.913] result() for ClusterFuture ... done
[10:32:51.913] result() for ClusterFuture ...
[10:32:51.914] - result already collected: FutureResult
[10:32:51.914] result() for ClusterFuture ... done
[10:32:51.914] result() for ClusterFuture ...
[10:32:51.914] - result already collected: FutureResult
[10:32:51.914] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:32:51.917] getGlobalsAndPackages() ...
[10:32:51.917] Searching for globals...
[10:32:51.917] 
[10:32:51.917] Searching for globals ... DONE
[10:32:51.918] - globals: [0] <none>
[10:32:51.918] getGlobalsAndPackages() ... DONE
[10:32:51.918] run() for ‘Future’ ...
[10:32:51.918] - state: ‘created’
[10:32:51.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.934] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.934]   - Field: ‘node’
[10:32:51.935]   - Field: ‘label’
[10:32:51.935]   - Field: ‘local’
[10:32:51.935]   - Field: ‘owner’
[10:32:51.935]   - Field: ‘envir’
[10:32:51.935]   - Field: ‘workers’
[10:32:51.935]   - Field: ‘packages’
[10:32:51.935]   - Field: ‘gc’
[10:32:51.935]   - Field: ‘conditions’
[10:32:51.935]   - Field: ‘persistent’
[10:32:51.935]   - Field: ‘expr’
[10:32:51.935]   - Field: ‘uuid’
[10:32:51.936]   - Field: ‘seed’
[10:32:51.936]   - Field: ‘version’
[10:32:51.936]   - Field: ‘result’
[10:32:51.936]   - Field: ‘asynchronous’
[10:32:51.936]   - Field: ‘calls’
[10:32:51.936]   - Field: ‘globals’
[10:32:51.936]   - Field: ‘stdout’
[10:32:51.936]   - Field: ‘earlySignal’
[10:32:51.936]   - Field: ‘lazy’
[10:32:51.936]   - Field: ‘state’
[10:32:51.936] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.937] - Launch lazy future ...
[10:32:51.937] Packages needed by the future expression (n = 0): <none>
[10:32:51.937] Packages needed by future strategies (n = 0): <none>
[10:32:51.937] {
[10:32:51.937]     {
[10:32:51.937]         {
[10:32:51.937]             ...future.startTime <- base::Sys.time()
[10:32:51.937]             {
[10:32:51.937]                 {
[10:32:51.937]                   {
[10:32:51.937]                     {
[10:32:51.937]                       base::local({
[10:32:51.937]                         has_future <- base::requireNamespace("future", 
[10:32:51.937]                           quietly = TRUE)
[10:32:51.937]                         if (has_future) {
[10:32:51.937]                           ns <- base::getNamespace("future")
[10:32:51.937]                           version <- ns[[".package"]][["version"]]
[10:32:51.937]                           if (is.null(version)) 
[10:32:51.937]                             version <- utils::packageVersion("future")
[10:32:51.937]                         }
[10:32:51.937]                         else {
[10:32:51.937]                           version <- NULL
[10:32:51.937]                         }
[10:32:51.937]                         if (!has_future || version < "1.8.0") {
[10:32:51.937]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.937]                             "", base::R.version$version.string), 
[10:32:51.937]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.937]                               "release", "version")], collapse = " "), 
[10:32:51.937]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.937]                             info)
[10:32:51.937]                           info <- base::paste(info, collapse = "; ")
[10:32:51.937]                           if (!has_future) {
[10:32:51.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.937]                               info)
[10:32:51.937]                           }
[10:32:51.937]                           else {
[10:32:51.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.937]                               info, version)
[10:32:51.937]                           }
[10:32:51.937]                           base::stop(msg)
[10:32:51.937]                         }
[10:32:51.937]                       })
[10:32:51.937]                     }
[10:32:51.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.937]                     base::options(mc.cores = 1L)
[10:32:51.937]                   }
[10:32:51.937]                   ...future.strategy.old <- future::plan("list")
[10:32:51.937]                   options(future.plan = NULL)
[10:32:51.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.937]                 }
[10:32:51.937]                 ...future.workdir <- getwd()
[10:32:51.937]             }
[10:32:51.937]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.937]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.937]         }
[10:32:51.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.937]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.937]             base::names(...future.oldOptions))
[10:32:51.937]     }
[10:32:51.937]     if (FALSE) {
[10:32:51.937]     }
[10:32:51.937]     else {
[10:32:51.937]         if (TRUE) {
[10:32:51.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.937]                 open = "w")
[10:32:51.937]         }
[10:32:51.937]         else {
[10:32:51.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.937]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.937]         }
[10:32:51.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.937]             base::sink(type = "output", split = FALSE)
[10:32:51.937]             base::close(...future.stdout)
[10:32:51.937]         }, add = TRUE)
[10:32:51.937]     }
[10:32:51.937]     ...future.frame <- base::sys.nframe()
[10:32:51.937]     ...future.conditions <- base::list()
[10:32:51.937]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.937]     if (FALSE) {
[10:32:51.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.937]     }
[10:32:51.937]     ...future.result <- base::tryCatch({
[10:32:51.937]         base::withCallingHandlers({
[10:32:51.937]             ...future.value <- base::withVisible(base::local({
[10:32:51.937]                 ...future.makeSendCondition <- base::local({
[10:32:51.937]                   sendCondition <- NULL
[10:32:51.937]                   function(frame = 1L) {
[10:32:51.937]                     if (is.function(sendCondition)) 
[10:32:51.937]                       return(sendCondition)
[10:32:51.937]                     ns <- getNamespace("parallel")
[10:32:51.937]                     if (exists("sendData", mode = "function", 
[10:32:51.937]                       envir = ns)) {
[10:32:51.937]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.937]                         envir = ns)
[10:32:51.937]                       envir <- sys.frame(frame)
[10:32:51.937]                       master <- NULL
[10:32:51.937]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.937]                         !identical(envir, emptyenv())) {
[10:32:51.937]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.937]                           inherits = FALSE)) {
[10:32:51.937]                           master <- get("master", mode = "list", 
[10:32:51.937]                             envir = envir, inherits = FALSE)
[10:32:51.937]                           if (inherits(master, c("SOCKnode", 
[10:32:51.937]                             "SOCK0node"))) {
[10:32:51.937]                             sendCondition <<- function(cond) {
[10:32:51.937]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.937]                                 success = TRUE)
[10:32:51.937]                               parallel_sendData(master, data)
[10:32:51.937]                             }
[10:32:51.937]                             return(sendCondition)
[10:32:51.937]                           }
[10:32:51.937]                         }
[10:32:51.937]                         frame <- frame + 1L
[10:32:51.937]                         envir <- sys.frame(frame)
[10:32:51.937]                       }
[10:32:51.937]                     }
[10:32:51.937]                     sendCondition <<- function(cond) NULL
[10:32:51.937]                   }
[10:32:51.937]                 })
[10:32:51.937]                 withCallingHandlers({
[10:32:51.937]                   2
[10:32:51.937]                 }, immediateCondition = function(cond) {
[10:32:51.937]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.937]                   sendCondition(cond)
[10:32:51.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.937]                   {
[10:32:51.937]                     inherits <- base::inherits
[10:32:51.937]                     invokeRestart <- base::invokeRestart
[10:32:51.937]                     is.null <- base::is.null
[10:32:51.937]                     muffled <- FALSE
[10:32:51.937]                     if (inherits(cond, "message")) {
[10:32:51.937]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.937]                       if (muffled) 
[10:32:51.937]                         invokeRestart("muffleMessage")
[10:32:51.937]                     }
[10:32:51.937]                     else if (inherits(cond, "warning")) {
[10:32:51.937]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.937]                       if (muffled) 
[10:32:51.937]                         invokeRestart("muffleWarning")
[10:32:51.937]                     }
[10:32:51.937]                     else if (inherits(cond, "condition")) {
[10:32:51.937]                       if (!is.null(pattern)) {
[10:32:51.937]                         computeRestarts <- base::computeRestarts
[10:32:51.937]                         grepl <- base::grepl
[10:32:51.937]                         restarts <- computeRestarts(cond)
[10:32:51.937]                         for (restart in restarts) {
[10:32:51.937]                           name <- restart$name
[10:32:51.937]                           if (is.null(name)) 
[10:32:51.937]                             next
[10:32:51.937]                           if (!grepl(pattern, name)) 
[10:32:51.937]                             next
[10:32:51.937]                           invokeRestart(restart)
[10:32:51.937]                           muffled <- TRUE
[10:32:51.937]                           break
[10:32:51.937]                         }
[10:32:51.937]                       }
[10:32:51.937]                     }
[10:32:51.937]                     invisible(muffled)
[10:32:51.937]                   }
[10:32:51.937]                   muffleCondition(cond)
[10:32:51.937]                 })
[10:32:51.937]             }))
[10:32:51.937]             future::FutureResult(value = ...future.value$value, 
[10:32:51.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.937]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.937]                     ...future.globalenv.names))
[10:32:51.937]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.937]         }, condition = base::local({
[10:32:51.937]             c <- base::c
[10:32:51.937]             inherits <- base::inherits
[10:32:51.937]             invokeRestart <- base::invokeRestart
[10:32:51.937]             length <- base::length
[10:32:51.937]             list <- base::list
[10:32:51.937]             seq.int <- base::seq.int
[10:32:51.937]             signalCondition <- base::signalCondition
[10:32:51.937]             sys.calls <- base::sys.calls
[10:32:51.937]             `[[` <- base::`[[`
[10:32:51.937]             `+` <- base::`+`
[10:32:51.937]             `<<-` <- base::`<<-`
[10:32:51.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.937]                   3L)]
[10:32:51.937]             }
[10:32:51.937]             function(cond) {
[10:32:51.937]                 is_error <- inherits(cond, "error")
[10:32:51.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.937]                   NULL)
[10:32:51.937]                 if (is_error) {
[10:32:51.937]                   sessionInformation <- function() {
[10:32:51.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.937]                       search = base::search(), system = base::Sys.info())
[10:32:51.937]                   }
[10:32:51.937]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.937]                     cond$call), session = sessionInformation(), 
[10:32:51.937]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.937]                   signalCondition(cond)
[10:32:51.937]                 }
[10:32:51.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.937]                 "immediateCondition"))) {
[10:32:51.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.937]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.937]                   if (TRUE && !signal) {
[10:32:51.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.937]                     {
[10:32:51.937]                       inherits <- base::inherits
[10:32:51.937]                       invokeRestart <- base::invokeRestart
[10:32:51.937]                       is.null <- base::is.null
[10:32:51.937]                       muffled <- FALSE
[10:32:51.937]                       if (inherits(cond, "message")) {
[10:32:51.937]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.937]                         if (muffled) 
[10:32:51.937]                           invokeRestart("muffleMessage")
[10:32:51.937]                       }
[10:32:51.937]                       else if (inherits(cond, "warning")) {
[10:32:51.937]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.937]                         if (muffled) 
[10:32:51.937]                           invokeRestart("muffleWarning")
[10:32:51.937]                       }
[10:32:51.937]                       else if (inherits(cond, "condition")) {
[10:32:51.937]                         if (!is.null(pattern)) {
[10:32:51.937]                           computeRestarts <- base::computeRestarts
[10:32:51.937]                           grepl <- base::grepl
[10:32:51.937]                           restarts <- computeRestarts(cond)
[10:32:51.937]                           for (restart in restarts) {
[10:32:51.937]                             name <- restart$name
[10:32:51.937]                             if (is.null(name)) 
[10:32:51.937]                               next
[10:32:51.937]                             if (!grepl(pattern, name)) 
[10:32:51.937]                               next
[10:32:51.937]                             invokeRestart(restart)
[10:32:51.937]                             muffled <- TRUE
[10:32:51.937]                             break
[10:32:51.937]                           }
[10:32:51.937]                         }
[10:32:51.937]                       }
[10:32:51.937]                       invisible(muffled)
[10:32:51.937]                     }
[10:32:51.937]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.937]                   }
[10:32:51.937]                 }
[10:32:51.937]                 else {
[10:32:51.937]                   if (TRUE) {
[10:32:51.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.937]                     {
[10:32:51.937]                       inherits <- base::inherits
[10:32:51.937]                       invokeRestart <- base::invokeRestart
[10:32:51.937]                       is.null <- base::is.null
[10:32:51.937]                       muffled <- FALSE
[10:32:51.937]                       if (inherits(cond, "message")) {
[10:32:51.937]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.937]                         if (muffled) 
[10:32:51.937]                           invokeRestart("muffleMessage")
[10:32:51.937]                       }
[10:32:51.937]                       else if (inherits(cond, "warning")) {
[10:32:51.937]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.937]                         if (muffled) 
[10:32:51.937]                           invokeRestart("muffleWarning")
[10:32:51.937]                       }
[10:32:51.937]                       else if (inherits(cond, "condition")) {
[10:32:51.937]                         if (!is.null(pattern)) {
[10:32:51.937]                           computeRestarts <- base::computeRestarts
[10:32:51.937]                           grepl <- base::grepl
[10:32:51.937]                           restarts <- computeRestarts(cond)
[10:32:51.937]                           for (restart in restarts) {
[10:32:51.937]                             name <- restart$name
[10:32:51.937]                             if (is.null(name)) 
[10:32:51.937]                               next
[10:32:51.937]                             if (!grepl(pattern, name)) 
[10:32:51.937]                               next
[10:32:51.937]                             invokeRestart(restart)
[10:32:51.937]                             muffled <- TRUE
[10:32:51.937]                             break
[10:32:51.937]                           }
[10:32:51.937]                         }
[10:32:51.937]                       }
[10:32:51.937]                       invisible(muffled)
[10:32:51.937]                     }
[10:32:51.937]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.937]                   }
[10:32:51.937]                 }
[10:32:51.937]             }
[10:32:51.937]         }))
[10:32:51.937]     }, error = function(ex) {
[10:32:51.937]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.937]                 ...future.rng), started = ...future.startTime, 
[10:32:51.937]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.937]             version = "1.8"), class = "FutureResult")
[10:32:51.937]     }, finally = {
[10:32:51.937]         if (!identical(...future.workdir, getwd())) 
[10:32:51.937]             setwd(...future.workdir)
[10:32:51.937]         {
[10:32:51.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.937]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.937]             }
[10:32:51.937]             base::options(...future.oldOptions)
[10:32:51.937]             if (.Platform$OS.type == "windows") {
[10:32:51.937]                 old_names <- names(...future.oldEnvVars)
[10:32:51.937]                 envs <- base::Sys.getenv()
[10:32:51.937]                 names <- names(envs)
[10:32:51.937]                 common <- intersect(names, old_names)
[10:32:51.937]                 added <- setdiff(names, old_names)
[10:32:51.937]                 removed <- setdiff(old_names, names)
[10:32:51.937]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.937]                   envs[common]]
[10:32:51.937]                 NAMES <- toupper(changed)
[10:32:51.937]                 args <- list()
[10:32:51.937]                 for (kk in seq_along(NAMES)) {
[10:32:51.937]                   name <- changed[[kk]]
[10:32:51.937]                   NAME <- NAMES[[kk]]
[10:32:51.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.937]                     next
[10:32:51.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.937]                 }
[10:32:51.937]                 NAMES <- toupper(added)
[10:32:51.937]                 for (kk in seq_along(NAMES)) {
[10:32:51.937]                   name <- added[[kk]]
[10:32:51.937]                   NAME <- NAMES[[kk]]
[10:32:51.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.937]                     next
[10:32:51.937]                   args[[name]] <- ""
[10:32:51.937]                 }
[10:32:51.937]                 NAMES <- toupper(removed)
[10:32:51.937]                 for (kk in seq_along(NAMES)) {
[10:32:51.937]                   name <- removed[[kk]]
[10:32:51.937]                   NAME <- NAMES[[kk]]
[10:32:51.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.937]                     next
[10:32:51.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.937]                 }
[10:32:51.937]                 if (length(args) > 0) 
[10:32:51.937]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.937]             }
[10:32:51.937]             else {
[10:32:51.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.937]             }
[10:32:51.937]             {
[10:32:51.937]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.937]                   0L) {
[10:32:51.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.937]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.937]                   base::options(opts)
[10:32:51.937]                 }
[10:32:51.937]                 {
[10:32:51.937]                   {
[10:32:51.937]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.937]                     NULL
[10:32:51.937]                   }
[10:32:51.937]                   options(future.plan = NULL)
[10:32:51.937]                   if (is.na(NA_character_)) 
[10:32:51.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.937]                     .init = FALSE)
[10:32:51.937]                 }
[10:32:51.937]             }
[10:32:51.937]         }
[10:32:51.937]     })
[10:32:51.937]     if (TRUE) {
[10:32:51.937]         base::sink(type = "output", split = FALSE)
[10:32:51.937]         if (TRUE) {
[10:32:51.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.937]         }
[10:32:51.937]         else {
[10:32:51.937]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.937]         }
[10:32:51.937]         base::close(...future.stdout)
[10:32:51.937]         ...future.stdout <- NULL
[10:32:51.937]     }
[10:32:51.937]     ...future.result$conditions <- ...future.conditions
[10:32:51.937]     ...future.result$finished <- base::Sys.time()
[10:32:51.937]     ...future.result
[10:32:51.937] }
[10:32:51.940] MultisessionFuture started
[10:32:51.940] - Launch lazy future ... done
[10:32:51.940] run() for ‘MultisessionFuture’ ... done
[10:32:51.941] getGlobalsAndPackages() ...
[10:32:51.941] Searching for globals...
[10:32:51.941] 
[10:32:51.941] Searching for globals ... DONE
[10:32:51.941] - globals: [0] <none>
[10:32:51.941] getGlobalsAndPackages() ... DONE
[10:32:51.941] run() for ‘Future’ ...
[10:32:51.942] - state: ‘created’
[10:32:51.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:51.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:51.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:51.955]   - Field: ‘node’
[10:32:51.955]   - Field: ‘label’
[10:32:51.955]   - Field: ‘local’
[10:32:51.955]   - Field: ‘owner’
[10:32:51.956]   - Field: ‘envir’
[10:32:51.956]   - Field: ‘workers’
[10:32:51.956]   - Field: ‘packages’
[10:32:51.956]   - Field: ‘gc’
[10:32:51.956]   - Field: ‘conditions’
[10:32:51.956]   - Field: ‘persistent’
[10:32:51.956]   - Field: ‘expr’
[10:32:51.956]   - Field: ‘uuid’
[10:32:51.956]   - Field: ‘seed’
[10:32:51.956]   - Field: ‘version’
[10:32:51.957]   - Field: ‘result’
[10:32:51.957]   - Field: ‘asynchronous’
[10:32:51.957]   - Field: ‘calls’
[10:32:51.957]   - Field: ‘globals’
[10:32:51.957]   - Field: ‘stdout’
[10:32:51.957]   - Field: ‘earlySignal’
[10:32:51.957]   - Field: ‘lazy’
[10:32:51.957]   - Field: ‘state’
[10:32:51.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:51.957] - Launch lazy future ...
[10:32:51.958] Packages needed by the future expression (n = 0): <none>
[10:32:51.958] Packages needed by future strategies (n = 0): <none>
[10:32:51.958] {
[10:32:51.958]     {
[10:32:51.958]         {
[10:32:51.958]             ...future.startTime <- base::Sys.time()
[10:32:51.958]             {
[10:32:51.958]                 {
[10:32:51.958]                   {
[10:32:51.958]                     {
[10:32:51.958]                       base::local({
[10:32:51.958]                         has_future <- base::requireNamespace("future", 
[10:32:51.958]                           quietly = TRUE)
[10:32:51.958]                         if (has_future) {
[10:32:51.958]                           ns <- base::getNamespace("future")
[10:32:51.958]                           version <- ns[[".package"]][["version"]]
[10:32:51.958]                           if (is.null(version)) 
[10:32:51.958]                             version <- utils::packageVersion("future")
[10:32:51.958]                         }
[10:32:51.958]                         else {
[10:32:51.958]                           version <- NULL
[10:32:51.958]                         }
[10:32:51.958]                         if (!has_future || version < "1.8.0") {
[10:32:51.958]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:51.958]                             "", base::R.version$version.string), 
[10:32:51.958]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:51.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:51.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:51.958]                               "release", "version")], collapse = " "), 
[10:32:51.958]                             hostname = base::Sys.info()[["nodename"]])
[10:32:51.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:51.958]                             info)
[10:32:51.958]                           info <- base::paste(info, collapse = "; ")
[10:32:51.958]                           if (!has_future) {
[10:32:51.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:51.958]                               info)
[10:32:51.958]                           }
[10:32:51.958]                           else {
[10:32:51.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:51.958]                               info, version)
[10:32:51.958]                           }
[10:32:51.958]                           base::stop(msg)
[10:32:51.958]                         }
[10:32:51.958]                       })
[10:32:51.958]                     }
[10:32:51.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:51.958]                     base::options(mc.cores = 1L)
[10:32:51.958]                   }
[10:32:51.958]                   ...future.strategy.old <- future::plan("list")
[10:32:51.958]                   options(future.plan = NULL)
[10:32:51.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:51.958]                 }
[10:32:51.958]                 ...future.workdir <- getwd()
[10:32:51.958]             }
[10:32:51.958]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:51.958]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:51.958]         }
[10:32:51.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:51.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:51.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:51.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:51.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:51.958]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:51.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:51.958]             base::names(...future.oldOptions))
[10:32:51.958]     }
[10:32:51.958]     if (FALSE) {
[10:32:51.958]     }
[10:32:51.958]     else {
[10:32:51.958]         if (TRUE) {
[10:32:51.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:51.958]                 open = "w")
[10:32:51.958]         }
[10:32:51.958]         else {
[10:32:51.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:51.958]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:51.958]         }
[10:32:51.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:51.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:51.958]             base::sink(type = "output", split = FALSE)
[10:32:51.958]             base::close(...future.stdout)
[10:32:51.958]         }, add = TRUE)
[10:32:51.958]     }
[10:32:51.958]     ...future.frame <- base::sys.nframe()
[10:32:51.958]     ...future.conditions <- base::list()
[10:32:51.958]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:51.958]     if (FALSE) {
[10:32:51.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:51.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:51.958]     }
[10:32:51.958]     ...future.result <- base::tryCatch({
[10:32:51.958]         base::withCallingHandlers({
[10:32:51.958]             ...future.value <- base::withVisible(base::local({
[10:32:51.958]                 ...future.makeSendCondition <- base::local({
[10:32:51.958]                   sendCondition <- NULL
[10:32:51.958]                   function(frame = 1L) {
[10:32:51.958]                     if (is.function(sendCondition)) 
[10:32:51.958]                       return(sendCondition)
[10:32:51.958]                     ns <- getNamespace("parallel")
[10:32:51.958]                     if (exists("sendData", mode = "function", 
[10:32:51.958]                       envir = ns)) {
[10:32:51.958]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:51.958]                         envir = ns)
[10:32:51.958]                       envir <- sys.frame(frame)
[10:32:51.958]                       master <- NULL
[10:32:51.958]                       while (!identical(envir, .GlobalEnv) && 
[10:32:51.958]                         !identical(envir, emptyenv())) {
[10:32:51.958]                         if (exists("master", mode = "list", envir = envir, 
[10:32:51.958]                           inherits = FALSE)) {
[10:32:51.958]                           master <- get("master", mode = "list", 
[10:32:51.958]                             envir = envir, inherits = FALSE)
[10:32:51.958]                           if (inherits(master, c("SOCKnode", 
[10:32:51.958]                             "SOCK0node"))) {
[10:32:51.958]                             sendCondition <<- function(cond) {
[10:32:51.958]                               data <- list(type = "VALUE", value = cond, 
[10:32:51.958]                                 success = TRUE)
[10:32:51.958]                               parallel_sendData(master, data)
[10:32:51.958]                             }
[10:32:51.958]                             return(sendCondition)
[10:32:51.958]                           }
[10:32:51.958]                         }
[10:32:51.958]                         frame <- frame + 1L
[10:32:51.958]                         envir <- sys.frame(frame)
[10:32:51.958]                       }
[10:32:51.958]                     }
[10:32:51.958]                     sendCondition <<- function(cond) NULL
[10:32:51.958]                   }
[10:32:51.958]                 })
[10:32:51.958]                 withCallingHandlers({
[10:32:51.958]                   NULL
[10:32:51.958]                 }, immediateCondition = function(cond) {
[10:32:51.958]                   sendCondition <- ...future.makeSendCondition()
[10:32:51.958]                   sendCondition(cond)
[10:32:51.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.958]                   {
[10:32:51.958]                     inherits <- base::inherits
[10:32:51.958]                     invokeRestart <- base::invokeRestart
[10:32:51.958]                     is.null <- base::is.null
[10:32:51.958]                     muffled <- FALSE
[10:32:51.958]                     if (inherits(cond, "message")) {
[10:32:51.958]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:51.958]                       if (muffled) 
[10:32:51.958]                         invokeRestart("muffleMessage")
[10:32:51.958]                     }
[10:32:51.958]                     else if (inherits(cond, "warning")) {
[10:32:51.958]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:51.958]                       if (muffled) 
[10:32:51.958]                         invokeRestart("muffleWarning")
[10:32:51.958]                     }
[10:32:51.958]                     else if (inherits(cond, "condition")) {
[10:32:51.958]                       if (!is.null(pattern)) {
[10:32:51.958]                         computeRestarts <- base::computeRestarts
[10:32:51.958]                         grepl <- base::grepl
[10:32:51.958]                         restarts <- computeRestarts(cond)
[10:32:51.958]                         for (restart in restarts) {
[10:32:51.958]                           name <- restart$name
[10:32:51.958]                           if (is.null(name)) 
[10:32:51.958]                             next
[10:32:51.958]                           if (!grepl(pattern, name)) 
[10:32:51.958]                             next
[10:32:51.958]                           invokeRestart(restart)
[10:32:51.958]                           muffled <- TRUE
[10:32:51.958]                           break
[10:32:51.958]                         }
[10:32:51.958]                       }
[10:32:51.958]                     }
[10:32:51.958]                     invisible(muffled)
[10:32:51.958]                   }
[10:32:51.958]                   muffleCondition(cond)
[10:32:51.958]                 })
[10:32:51.958]             }))
[10:32:51.958]             future::FutureResult(value = ...future.value$value, 
[10:32:51.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.958]                   ...future.rng), globalenv = if (FALSE) 
[10:32:51.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:51.958]                     ...future.globalenv.names))
[10:32:51.958]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:51.958]         }, condition = base::local({
[10:32:51.958]             c <- base::c
[10:32:51.958]             inherits <- base::inherits
[10:32:51.958]             invokeRestart <- base::invokeRestart
[10:32:51.958]             length <- base::length
[10:32:51.958]             list <- base::list
[10:32:51.958]             seq.int <- base::seq.int
[10:32:51.958]             signalCondition <- base::signalCondition
[10:32:51.958]             sys.calls <- base::sys.calls
[10:32:51.958]             `[[` <- base::`[[`
[10:32:51.958]             `+` <- base::`+`
[10:32:51.958]             `<<-` <- base::`<<-`
[10:32:51.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:51.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:51.958]                   3L)]
[10:32:51.958]             }
[10:32:51.958]             function(cond) {
[10:32:51.958]                 is_error <- inherits(cond, "error")
[10:32:51.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:51.958]                   NULL)
[10:32:51.958]                 if (is_error) {
[10:32:51.958]                   sessionInformation <- function() {
[10:32:51.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:51.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:51.958]                       search = base::search(), system = base::Sys.info())
[10:32:51.958]                   }
[10:32:51.958]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:51.958]                     cond$call), session = sessionInformation(), 
[10:32:51.958]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:51.958]                   signalCondition(cond)
[10:32:51.958]                 }
[10:32:51.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:51.958]                 "immediateCondition"))) {
[10:32:51.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:51.958]                   ...future.conditions[[length(...future.conditions) + 
[10:32:51.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:51.958]                   if (TRUE && !signal) {
[10:32:51.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.958]                     {
[10:32:51.958]                       inherits <- base::inherits
[10:32:51.958]                       invokeRestart <- base::invokeRestart
[10:32:51.958]                       is.null <- base::is.null
[10:32:51.958]                       muffled <- FALSE
[10:32:51.958]                       if (inherits(cond, "message")) {
[10:32:51.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.958]                         if (muffled) 
[10:32:51.958]                           invokeRestart("muffleMessage")
[10:32:51.958]                       }
[10:32:51.958]                       else if (inherits(cond, "warning")) {
[10:32:51.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.958]                         if (muffled) 
[10:32:51.958]                           invokeRestart("muffleWarning")
[10:32:51.958]                       }
[10:32:51.958]                       else if (inherits(cond, "condition")) {
[10:32:51.958]                         if (!is.null(pattern)) {
[10:32:51.958]                           computeRestarts <- base::computeRestarts
[10:32:51.958]                           grepl <- base::grepl
[10:32:51.958]                           restarts <- computeRestarts(cond)
[10:32:51.958]                           for (restart in restarts) {
[10:32:51.958]                             name <- restart$name
[10:32:51.958]                             if (is.null(name)) 
[10:32:51.958]                               next
[10:32:51.958]                             if (!grepl(pattern, name)) 
[10:32:51.958]                               next
[10:32:51.958]                             invokeRestart(restart)
[10:32:51.958]                             muffled <- TRUE
[10:32:51.958]                             break
[10:32:51.958]                           }
[10:32:51.958]                         }
[10:32:51.958]                       }
[10:32:51.958]                       invisible(muffled)
[10:32:51.958]                     }
[10:32:51.958]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.958]                   }
[10:32:51.958]                 }
[10:32:51.958]                 else {
[10:32:51.958]                   if (TRUE) {
[10:32:51.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:51.958]                     {
[10:32:51.958]                       inherits <- base::inherits
[10:32:51.958]                       invokeRestart <- base::invokeRestart
[10:32:51.958]                       is.null <- base::is.null
[10:32:51.958]                       muffled <- FALSE
[10:32:51.958]                       if (inherits(cond, "message")) {
[10:32:51.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:51.958]                         if (muffled) 
[10:32:51.958]                           invokeRestart("muffleMessage")
[10:32:51.958]                       }
[10:32:51.958]                       else if (inherits(cond, "warning")) {
[10:32:51.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:51.958]                         if (muffled) 
[10:32:51.958]                           invokeRestart("muffleWarning")
[10:32:51.958]                       }
[10:32:51.958]                       else if (inherits(cond, "condition")) {
[10:32:51.958]                         if (!is.null(pattern)) {
[10:32:51.958]                           computeRestarts <- base::computeRestarts
[10:32:51.958]                           grepl <- base::grepl
[10:32:51.958]                           restarts <- computeRestarts(cond)
[10:32:51.958]                           for (restart in restarts) {
[10:32:51.958]                             name <- restart$name
[10:32:51.958]                             if (is.null(name)) 
[10:32:51.958]                               next
[10:32:51.958]                             if (!grepl(pattern, name)) 
[10:32:51.958]                               next
[10:32:51.958]                             invokeRestart(restart)
[10:32:51.958]                             muffled <- TRUE
[10:32:51.958]                             break
[10:32:51.958]                           }
[10:32:51.958]                         }
[10:32:51.958]                       }
[10:32:51.958]                       invisible(muffled)
[10:32:51.958]                     }
[10:32:51.958]                     muffleCondition(cond, pattern = "^muffle")
[10:32:51.958]                   }
[10:32:51.958]                 }
[10:32:51.958]             }
[10:32:51.958]         }))
[10:32:51.958]     }, error = function(ex) {
[10:32:51.958]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:51.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:51.958]                 ...future.rng), started = ...future.startTime, 
[10:32:51.958]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:51.958]             version = "1.8"), class = "FutureResult")
[10:32:51.958]     }, finally = {
[10:32:51.958]         if (!identical(...future.workdir, getwd())) 
[10:32:51.958]             setwd(...future.workdir)
[10:32:51.958]         {
[10:32:51.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:51.958]                 ...future.oldOptions$nwarnings <- NULL
[10:32:51.958]             }
[10:32:51.958]             base::options(...future.oldOptions)
[10:32:51.958]             if (.Platform$OS.type == "windows") {
[10:32:51.958]                 old_names <- names(...future.oldEnvVars)
[10:32:51.958]                 envs <- base::Sys.getenv()
[10:32:51.958]                 names <- names(envs)
[10:32:51.958]                 common <- intersect(names, old_names)
[10:32:51.958]                 added <- setdiff(names, old_names)
[10:32:51.958]                 removed <- setdiff(old_names, names)
[10:32:51.958]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:51.958]                   envs[common]]
[10:32:51.958]                 NAMES <- toupper(changed)
[10:32:51.958]                 args <- list()
[10:32:51.958]                 for (kk in seq_along(NAMES)) {
[10:32:51.958]                   name <- changed[[kk]]
[10:32:51.958]                   NAME <- NAMES[[kk]]
[10:32:51.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.958]                     next
[10:32:51.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.958]                 }
[10:32:51.958]                 NAMES <- toupper(added)
[10:32:51.958]                 for (kk in seq_along(NAMES)) {
[10:32:51.958]                   name <- added[[kk]]
[10:32:51.958]                   NAME <- NAMES[[kk]]
[10:32:51.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.958]                     next
[10:32:51.958]                   args[[name]] <- ""
[10:32:51.958]                 }
[10:32:51.958]                 NAMES <- toupper(removed)
[10:32:51.958]                 for (kk in seq_along(NAMES)) {
[10:32:51.958]                   name <- removed[[kk]]
[10:32:51.958]                   NAME <- NAMES[[kk]]
[10:32:51.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:51.958]                     next
[10:32:51.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:51.958]                 }
[10:32:51.958]                 if (length(args) > 0) 
[10:32:51.958]                   base::do.call(base::Sys.setenv, args = args)
[10:32:51.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:51.958]             }
[10:32:51.958]             else {
[10:32:51.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:51.958]             }
[10:32:51.958]             {
[10:32:51.958]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:51.958]                   0L) {
[10:32:51.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:51.958]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:51.958]                   base::options(opts)
[10:32:51.958]                 }
[10:32:51.958]                 {
[10:32:51.958]                   {
[10:32:51.958]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:51.958]                     NULL
[10:32:51.958]                   }
[10:32:51.958]                   options(future.plan = NULL)
[10:32:51.958]                   if (is.na(NA_character_)) 
[10:32:51.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:51.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:51.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:51.958]                     .init = FALSE)
[10:32:51.958]                 }
[10:32:51.958]             }
[10:32:51.958]         }
[10:32:51.958]     })
[10:32:51.958]     if (TRUE) {
[10:32:51.958]         base::sink(type = "output", split = FALSE)
[10:32:51.958]         if (TRUE) {
[10:32:51.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:51.958]         }
[10:32:51.958]         else {
[10:32:51.958]             ...future.result["stdout"] <- base::list(NULL)
[10:32:51.958]         }
[10:32:51.958]         base::close(...future.stdout)
[10:32:51.958]         ...future.stdout <- NULL
[10:32:51.958]     }
[10:32:51.958]     ...future.result$conditions <- ...future.conditions
[10:32:51.958]     ...future.result$finished <- base::Sys.time()
[10:32:51.958]     ...future.result
[10:32:51.958] }
[10:32:51.961] MultisessionFuture started
[10:32:51.961] - Launch lazy future ... done
[10:32:51.961] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d03a60e0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1cdf480> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d03a60e0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1cdf480> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:51.966] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.967] - Validating connection of MultisessionFuture
[10:32:51.967] - received message: FutureResult
[10:32:51.967] - Received FutureResult
[10:32:51.967] - Erased future from FutureRegistry
[10:32:51.967] result() for ClusterFuture ...
[10:32:51.967] - result already collected: FutureResult
[10:32:51.967] result() for ClusterFuture ... done
[10:32:51.967] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:51.968] receiveMessageFromWorker() for ClusterFuture ...
[10:32:51.968] - Validating connection of MultisessionFuture
[10:32:51.968] - received message: FutureResult
[10:32:51.968] - Received FutureResult
[10:32:51.968] - Erased future from FutureRegistry
[10:32:51.968] result() for ClusterFuture ...
[10:32:51.968] - result already collected: FutureResult
[10:32:51.969] result() for ClusterFuture ... done
[10:32:51.969] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:51.970] resolve() on list ...
[10:32:51.970]  recursive: 0
[10:32:51.971]  length: 6
[10:32:51.971]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:51.971] signalConditionsASAP(numeric, pos=1) ...
[10:32:51.971] - nx: 6
[10:32:51.971] - relay: TRUE
[10:32:51.971] - stdout: TRUE
[10:32:51.971] - signal: TRUE
[10:32:51.971] - resignal: FALSE
[10:32:51.971] - force: TRUE
[10:32:51.971] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.971] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.972]  - until=2
[10:32:51.972]  - relaying element #2
[10:32:51.972] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.972] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.972] signalConditionsASAP(NULL, pos=1) ... done
[10:32:51.972]  length: 5 (resolved future 1)
[10:32:51.972] Future #2
[10:32:51.972] result() for ClusterFuture ...
[10:32:51.972] - result already collected: FutureResult
[10:32:51.972] result() for ClusterFuture ... done
[10:32:51.972] result() for ClusterFuture ...
[10:32:51.973] - result already collected: FutureResult
[10:32:51.973] result() for ClusterFuture ... done
[10:32:51.973] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:51.973] - nx: 6
[10:32:51.973] - relay: TRUE
[10:32:51.973] - stdout: TRUE
[10:32:51.973] - signal: TRUE
[10:32:51.973] - resignal: FALSE
[10:32:51.973] - force: TRUE
[10:32:51.973] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.973] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:51.974]  - until=2
[10:32:51.974]  - relaying element #2
[10:32:51.974] result() for ClusterFuture ...
[10:32:51.974] - result already collected: FutureResult
[10:32:51.974] result() for ClusterFuture ... done
[10:32:51.974] result() for ClusterFuture ...
[10:32:51.974] - result already collected: FutureResult
[10:32:51.974] result() for ClusterFuture ... done
[10:32:51.974] result() for ClusterFuture ...
[10:32:51.974] - result already collected: FutureResult
[10:32:51.974] result() for ClusterFuture ... done
[10:32:51.975] result() for ClusterFuture ...
[10:32:51.975] - result already collected: FutureResult
[10:32:51.975] result() for ClusterFuture ... done
[10:32:51.975] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.975] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.975] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:51.975]  length: 4 (resolved future 2)
[10:32:51.975] Future #3
[10:32:51.975] result() for ClusterFuture ...
[10:32:51.975] - result already collected: FutureResult
[10:32:51.975] result() for ClusterFuture ... done
[10:32:51.976] result() for ClusterFuture ...
[10:32:51.976] - result already collected: FutureResult
[10:32:51.976] result() for ClusterFuture ... done
[10:32:51.976] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:51.976] - nx: 6
[10:32:51.976] - relay: TRUE
[10:32:51.976] - stdout: TRUE
[10:32:51.976] - signal: TRUE
[10:32:51.976] - resignal: FALSE
[10:32:51.976] - force: TRUE
[10:32:51.976] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.976] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:51.977]  - until=3
[10:32:51.977]  - relaying element #3
[10:32:51.977] result() for ClusterFuture ...
[10:32:51.977] - result already collected: FutureResult
[10:32:51.977] result() for ClusterFuture ... done
[10:32:51.977] result() for ClusterFuture ...
[10:32:51.977] - result already collected: FutureResult
[10:32:51.977] result() for ClusterFuture ... done
[10:32:51.977] result() for ClusterFuture ...
[10:32:51.977] - result already collected: FutureResult
[10:32:51.977] result() for ClusterFuture ... done
[10:32:51.978] result() for ClusterFuture ...
[10:32:51.978] - result already collected: FutureResult
[10:32:51.978] result() for ClusterFuture ... done
[10:32:51.978] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.978] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.978] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:51.978]  length: 3 (resolved future 3)
[10:32:51.978] signalConditionsASAP(NULL, pos=4) ...
[10:32:51.978] - nx: 6
[10:32:51.978] - relay: TRUE
[10:32:51.978] - stdout: TRUE
[10:32:51.978] - signal: TRUE
[10:32:51.979] - resignal: FALSE
[10:32:51.979] - force: TRUE
[10:32:51.979] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.979] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.979]  - until=5
[10:32:51.979]  - relaying element #5
[10:32:51.979] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.979] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.979] signalConditionsASAP(NULL, pos=4) ... done
[10:32:51.979]  length: 2 (resolved future 4)
[10:32:51.979] signalConditionsASAP(NULL, pos=5) ...
[10:32:51.979] - nx: 6
[10:32:51.980] - relay: TRUE
[10:32:51.980] - stdout: TRUE
[10:32:51.980] - signal: TRUE
[10:32:51.980] - resignal: FALSE
[10:32:51.980] - force: TRUE
[10:32:51.980] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:51.980] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.980]  - until=6
[10:32:51.980]  - relaying element #6
[10:32:51.980] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.980] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.980] signalConditionsASAP(NULL, pos=5) ... done
[10:32:51.981]  length: 1 (resolved future 5)
[10:32:51.981] signalConditionsASAP(numeric, pos=6) ...
[10:32:51.981] - nx: 6
[10:32:51.981] - relay: TRUE
[10:32:51.981] - stdout: TRUE
[10:32:51.981] - signal: TRUE
[10:32:51.981] - resignal: FALSE
[10:32:51.981] - force: TRUE
[10:32:51.981] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:51.981] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.981]  - until=6
[10:32:51.982] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.982] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.982] signalConditionsASAP(numeric, pos=6) ... done
[10:32:51.982]  length: 0 (resolved future 6)
[10:32:51.982] Relaying remaining futures
[10:32:51.982] signalConditionsASAP(NULL, pos=0) ...
[10:32:51.982] - nx: 6
[10:32:51.982] - relay: TRUE
[10:32:51.982] - stdout: TRUE
[10:32:51.982] - signal: TRUE
[10:32:51.982] - resignal: FALSE
[10:32:51.983] - force: TRUE
[10:32:51.983] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.983] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:51.983] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:51.983] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:51.983] signalConditionsASAP(NULL, pos=0) ... done
[10:32:51.983] resolve() on list ... DONE
[10:32:51.983] result() for ClusterFuture ...
[10:32:51.983] - result already collected: FutureResult
[10:32:51.983] result() for ClusterFuture ... done
[10:32:51.983] result() for ClusterFuture ...
[10:32:51.984] - result already collected: FutureResult
[10:32:51.984] result() for ClusterFuture ... done
[10:32:51.984] result() for ClusterFuture ...
[10:32:51.984] - result already collected: FutureResult
[10:32:51.984] result() for ClusterFuture ... done
[10:32:51.984] result() for ClusterFuture ...
[10:32:51.984] - result already collected: FutureResult
[10:32:51.984] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:32:51.987] getGlobalsAndPackages() ...
[10:32:51.987] Searching for globals...
[10:32:51.988] 
[10:32:51.988] Searching for globals ... DONE
[10:32:51.988] - globals: [0] <none>
[10:32:51.988] getGlobalsAndPackages() ... DONE
[10:32:51.988] run() for ‘Future’ ...
[10:32:51.988] - state: ‘created’
[10:32:51.989] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.004] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:52.004]   - Field: ‘node’
[10:32:52.004]   - Field: ‘label’
[10:32:52.004]   - Field: ‘local’
[10:32:52.004]   - Field: ‘owner’
[10:32:52.004]   - Field: ‘envir’
[10:32:52.004]   - Field: ‘workers’
[10:32:52.005]   - Field: ‘packages’
[10:32:52.005]   - Field: ‘gc’
[10:32:52.005]   - Field: ‘conditions’
[10:32:52.005]   - Field: ‘persistent’
[10:32:52.005]   - Field: ‘expr’
[10:32:52.005]   - Field: ‘uuid’
[10:32:52.005]   - Field: ‘seed’
[10:32:52.005]   - Field: ‘version’
[10:32:52.005]   - Field: ‘result’
[10:32:52.005]   - Field: ‘asynchronous’
[10:32:52.006]   - Field: ‘calls’
[10:32:52.006]   - Field: ‘globals’
[10:32:52.006]   - Field: ‘stdout’
[10:32:52.006]   - Field: ‘earlySignal’
[10:32:52.006]   - Field: ‘lazy’
[10:32:52.006]   - Field: ‘state’
[10:32:52.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:52.006] - Launch lazy future ...
[10:32:52.006] Packages needed by the future expression (n = 0): <none>
[10:32:52.007] Packages needed by future strategies (n = 0): <none>
[10:32:52.007] {
[10:32:52.007]     {
[10:32:52.007]         {
[10:32:52.007]             ...future.startTime <- base::Sys.time()
[10:32:52.007]             {
[10:32:52.007]                 {
[10:32:52.007]                   {
[10:32:52.007]                     {
[10:32:52.007]                       base::local({
[10:32:52.007]                         has_future <- base::requireNamespace("future", 
[10:32:52.007]                           quietly = TRUE)
[10:32:52.007]                         if (has_future) {
[10:32:52.007]                           ns <- base::getNamespace("future")
[10:32:52.007]                           version <- ns[[".package"]][["version"]]
[10:32:52.007]                           if (is.null(version)) 
[10:32:52.007]                             version <- utils::packageVersion("future")
[10:32:52.007]                         }
[10:32:52.007]                         else {
[10:32:52.007]                           version <- NULL
[10:32:52.007]                         }
[10:32:52.007]                         if (!has_future || version < "1.8.0") {
[10:32:52.007]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.007]                             "", base::R.version$version.string), 
[10:32:52.007]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.007]                               "release", "version")], collapse = " "), 
[10:32:52.007]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.007]                             info)
[10:32:52.007]                           info <- base::paste(info, collapse = "; ")
[10:32:52.007]                           if (!has_future) {
[10:32:52.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.007]                               info)
[10:32:52.007]                           }
[10:32:52.007]                           else {
[10:32:52.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.007]                               info, version)
[10:32:52.007]                           }
[10:32:52.007]                           base::stop(msg)
[10:32:52.007]                         }
[10:32:52.007]                       })
[10:32:52.007]                     }
[10:32:52.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.007]                     base::options(mc.cores = 1L)
[10:32:52.007]                   }
[10:32:52.007]                   ...future.strategy.old <- future::plan("list")
[10:32:52.007]                   options(future.plan = NULL)
[10:32:52.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.007]                 }
[10:32:52.007]                 ...future.workdir <- getwd()
[10:32:52.007]             }
[10:32:52.007]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.007]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.007]         }
[10:32:52.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.007]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.007]             base::names(...future.oldOptions))
[10:32:52.007]     }
[10:32:52.007]     if (FALSE) {
[10:32:52.007]     }
[10:32:52.007]     else {
[10:32:52.007]         if (TRUE) {
[10:32:52.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.007]                 open = "w")
[10:32:52.007]         }
[10:32:52.007]         else {
[10:32:52.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.007]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.007]         }
[10:32:52.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.007]             base::sink(type = "output", split = FALSE)
[10:32:52.007]             base::close(...future.stdout)
[10:32:52.007]         }, add = TRUE)
[10:32:52.007]     }
[10:32:52.007]     ...future.frame <- base::sys.nframe()
[10:32:52.007]     ...future.conditions <- base::list()
[10:32:52.007]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.007]     if (FALSE) {
[10:32:52.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.007]     }
[10:32:52.007]     ...future.result <- base::tryCatch({
[10:32:52.007]         base::withCallingHandlers({
[10:32:52.007]             ...future.value <- base::withVisible(base::local({
[10:32:52.007]                 ...future.makeSendCondition <- base::local({
[10:32:52.007]                   sendCondition <- NULL
[10:32:52.007]                   function(frame = 1L) {
[10:32:52.007]                     if (is.function(sendCondition)) 
[10:32:52.007]                       return(sendCondition)
[10:32:52.007]                     ns <- getNamespace("parallel")
[10:32:52.007]                     if (exists("sendData", mode = "function", 
[10:32:52.007]                       envir = ns)) {
[10:32:52.007]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:52.007]                         envir = ns)
[10:32:52.007]                       envir <- sys.frame(frame)
[10:32:52.007]                       master <- NULL
[10:32:52.007]                       while (!identical(envir, .GlobalEnv) && 
[10:32:52.007]                         !identical(envir, emptyenv())) {
[10:32:52.007]                         if (exists("master", mode = "list", envir = envir, 
[10:32:52.007]                           inherits = FALSE)) {
[10:32:52.007]                           master <- get("master", mode = "list", 
[10:32:52.007]                             envir = envir, inherits = FALSE)
[10:32:52.007]                           if (inherits(master, c("SOCKnode", 
[10:32:52.007]                             "SOCK0node"))) {
[10:32:52.007]                             sendCondition <<- function(cond) {
[10:32:52.007]                               data <- list(type = "VALUE", value = cond, 
[10:32:52.007]                                 success = TRUE)
[10:32:52.007]                               parallel_sendData(master, data)
[10:32:52.007]                             }
[10:32:52.007]                             return(sendCondition)
[10:32:52.007]                           }
[10:32:52.007]                         }
[10:32:52.007]                         frame <- frame + 1L
[10:32:52.007]                         envir <- sys.frame(frame)
[10:32:52.007]                       }
[10:32:52.007]                     }
[10:32:52.007]                     sendCondition <<- function(cond) NULL
[10:32:52.007]                   }
[10:32:52.007]                 })
[10:32:52.007]                 withCallingHandlers({
[10:32:52.007]                   2
[10:32:52.007]                 }, immediateCondition = function(cond) {
[10:32:52.007]                   sendCondition <- ...future.makeSendCondition()
[10:32:52.007]                   sendCondition(cond)
[10:32:52.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.007]                   {
[10:32:52.007]                     inherits <- base::inherits
[10:32:52.007]                     invokeRestart <- base::invokeRestart
[10:32:52.007]                     is.null <- base::is.null
[10:32:52.007]                     muffled <- FALSE
[10:32:52.007]                     if (inherits(cond, "message")) {
[10:32:52.007]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.007]                       if (muffled) 
[10:32:52.007]                         invokeRestart("muffleMessage")
[10:32:52.007]                     }
[10:32:52.007]                     else if (inherits(cond, "warning")) {
[10:32:52.007]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.007]                       if (muffled) 
[10:32:52.007]                         invokeRestart("muffleWarning")
[10:32:52.007]                     }
[10:32:52.007]                     else if (inherits(cond, "condition")) {
[10:32:52.007]                       if (!is.null(pattern)) {
[10:32:52.007]                         computeRestarts <- base::computeRestarts
[10:32:52.007]                         grepl <- base::grepl
[10:32:52.007]                         restarts <- computeRestarts(cond)
[10:32:52.007]                         for (restart in restarts) {
[10:32:52.007]                           name <- restart$name
[10:32:52.007]                           if (is.null(name)) 
[10:32:52.007]                             next
[10:32:52.007]                           if (!grepl(pattern, name)) 
[10:32:52.007]                             next
[10:32:52.007]                           invokeRestart(restart)
[10:32:52.007]                           muffled <- TRUE
[10:32:52.007]                           break
[10:32:52.007]                         }
[10:32:52.007]                       }
[10:32:52.007]                     }
[10:32:52.007]                     invisible(muffled)
[10:32:52.007]                   }
[10:32:52.007]                   muffleCondition(cond)
[10:32:52.007]                 })
[10:32:52.007]             }))
[10:32:52.007]             future::FutureResult(value = ...future.value$value, 
[10:32:52.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.007]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.007]                     ...future.globalenv.names))
[10:32:52.007]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.007]         }, condition = base::local({
[10:32:52.007]             c <- base::c
[10:32:52.007]             inherits <- base::inherits
[10:32:52.007]             invokeRestart <- base::invokeRestart
[10:32:52.007]             length <- base::length
[10:32:52.007]             list <- base::list
[10:32:52.007]             seq.int <- base::seq.int
[10:32:52.007]             signalCondition <- base::signalCondition
[10:32:52.007]             sys.calls <- base::sys.calls
[10:32:52.007]             `[[` <- base::`[[`
[10:32:52.007]             `+` <- base::`+`
[10:32:52.007]             `<<-` <- base::`<<-`
[10:32:52.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.007]                   3L)]
[10:32:52.007]             }
[10:32:52.007]             function(cond) {
[10:32:52.007]                 is_error <- inherits(cond, "error")
[10:32:52.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.007]                   NULL)
[10:32:52.007]                 if (is_error) {
[10:32:52.007]                   sessionInformation <- function() {
[10:32:52.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.007]                       search = base::search(), system = base::Sys.info())
[10:32:52.007]                   }
[10:32:52.007]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.007]                     cond$call), session = sessionInformation(), 
[10:32:52.007]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.007]                   signalCondition(cond)
[10:32:52.007]                 }
[10:32:52.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.007]                 "immediateCondition"))) {
[10:32:52.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.007]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.007]                   if (TRUE && !signal) {
[10:32:52.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.007]                     {
[10:32:52.007]                       inherits <- base::inherits
[10:32:52.007]                       invokeRestart <- base::invokeRestart
[10:32:52.007]                       is.null <- base::is.null
[10:32:52.007]                       muffled <- FALSE
[10:32:52.007]                       if (inherits(cond, "message")) {
[10:32:52.007]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.007]                         if (muffled) 
[10:32:52.007]                           invokeRestart("muffleMessage")
[10:32:52.007]                       }
[10:32:52.007]                       else if (inherits(cond, "warning")) {
[10:32:52.007]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.007]                         if (muffled) 
[10:32:52.007]                           invokeRestart("muffleWarning")
[10:32:52.007]                       }
[10:32:52.007]                       else if (inherits(cond, "condition")) {
[10:32:52.007]                         if (!is.null(pattern)) {
[10:32:52.007]                           computeRestarts <- base::computeRestarts
[10:32:52.007]                           grepl <- base::grepl
[10:32:52.007]                           restarts <- computeRestarts(cond)
[10:32:52.007]                           for (restart in restarts) {
[10:32:52.007]                             name <- restart$name
[10:32:52.007]                             if (is.null(name)) 
[10:32:52.007]                               next
[10:32:52.007]                             if (!grepl(pattern, name)) 
[10:32:52.007]                               next
[10:32:52.007]                             invokeRestart(restart)
[10:32:52.007]                             muffled <- TRUE
[10:32:52.007]                             break
[10:32:52.007]                           }
[10:32:52.007]                         }
[10:32:52.007]                       }
[10:32:52.007]                       invisible(muffled)
[10:32:52.007]                     }
[10:32:52.007]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.007]                   }
[10:32:52.007]                 }
[10:32:52.007]                 else {
[10:32:52.007]                   if (TRUE) {
[10:32:52.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.007]                     {
[10:32:52.007]                       inherits <- base::inherits
[10:32:52.007]                       invokeRestart <- base::invokeRestart
[10:32:52.007]                       is.null <- base::is.null
[10:32:52.007]                       muffled <- FALSE
[10:32:52.007]                       if (inherits(cond, "message")) {
[10:32:52.007]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.007]                         if (muffled) 
[10:32:52.007]                           invokeRestart("muffleMessage")
[10:32:52.007]                       }
[10:32:52.007]                       else if (inherits(cond, "warning")) {
[10:32:52.007]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.007]                         if (muffled) 
[10:32:52.007]                           invokeRestart("muffleWarning")
[10:32:52.007]                       }
[10:32:52.007]                       else if (inherits(cond, "condition")) {
[10:32:52.007]                         if (!is.null(pattern)) {
[10:32:52.007]                           computeRestarts <- base::computeRestarts
[10:32:52.007]                           grepl <- base::grepl
[10:32:52.007]                           restarts <- computeRestarts(cond)
[10:32:52.007]                           for (restart in restarts) {
[10:32:52.007]                             name <- restart$name
[10:32:52.007]                             if (is.null(name)) 
[10:32:52.007]                               next
[10:32:52.007]                             if (!grepl(pattern, name)) 
[10:32:52.007]                               next
[10:32:52.007]                             invokeRestart(restart)
[10:32:52.007]                             muffled <- TRUE
[10:32:52.007]                             break
[10:32:52.007]                           }
[10:32:52.007]                         }
[10:32:52.007]                       }
[10:32:52.007]                       invisible(muffled)
[10:32:52.007]                     }
[10:32:52.007]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.007]                   }
[10:32:52.007]                 }
[10:32:52.007]             }
[10:32:52.007]         }))
[10:32:52.007]     }, error = function(ex) {
[10:32:52.007]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.007]                 ...future.rng), started = ...future.startTime, 
[10:32:52.007]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.007]             version = "1.8"), class = "FutureResult")
[10:32:52.007]     }, finally = {
[10:32:52.007]         if (!identical(...future.workdir, getwd())) 
[10:32:52.007]             setwd(...future.workdir)
[10:32:52.007]         {
[10:32:52.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.007]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.007]             }
[10:32:52.007]             base::options(...future.oldOptions)
[10:32:52.007]             if (.Platform$OS.type == "windows") {
[10:32:52.007]                 old_names <- names(...future.oldEnvVars)
[10:32:52.007]                 envs <- base::Sys.getenv()
[10:32:52.007]                 names <- names(envs)
[10:32:52.007]                 common <- intersect(names, old_names)
[10:32:52.007]                 added <- setdiff(names, old_names)
[10:32:52.007]                 removed <- setdiff(old_names, names)
[10:32:52.007]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.007]                   envs[common]]
[10:32:52.007]                 NAMES <- toupper(changed)
[10:32:52.007]                 args <- list()
[10:32:52.007]                 for (kk in seq_along(NAMES)) {
[10:32:52.007]                   name <- changed[[kk]]
[10:32:52.007]                   NAME <- NAMES[[kk]]
[10:32:52.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.007]                     next
[10:32:52.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.007]                 }
[10:32:52.007]                 NAMES <- toupper(added)
[10:32:52.007]                 for (kk in seq_along(NAMES)) {
[10:32:52.007]                   name <- added[[kk]]
[10:32:52.007]                   NAME <- NAMES[[kk]]
[10:32:52.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.007]                     next
[10:32:52.007]                   args[[name]] <- ""
[10:32:52.007]                 }
[10:32:52.007]                 NAMES <- toupper(removed)
[10:32:52.007]                 for (kk in seq_along(NAMES)) {
[10:32:52.007]                   name <- removed[[kk]]
[10:32:52.007]                   NAME <- NAMES[[kk]]
[10:32:52.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.007]                     next
[10:32:52.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.007]                 }
[10:32:52.007]                 if (length(args) > 0) 
[10:32:52.007]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.007]             }
[10:32:52.007]             else {
[10:32:52.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.007]             }
[10:32:52.007]             {
[10:32:52.007]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.007]                   0L) {
[10:32:52.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.007]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.007]                   base::options(opts)
[10:32:52.007]                 }
[10:32:52.007]                 {
[10:32:52.007]                   {
[10:32:52.007]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.007]                     NULL
[10:32:52.007]                   }
[10:32:52.007]                   options(future.plan = NULL)
[10:32:52.007]                   if (is.na(NA_character_)) 
[10:32:52.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.007]                     .init = FALSE)
[10:32:52.007]                 }
[10:32:52.007]             }
[10:32:52.007]         }
[10:32:52.007]     })
[10:32:52.007]     if (TRUE) {
[10:32:52.007]         base::sink(type = "output", split = FALSE)
[10:32:52.007]         if (TRUE) {
[10:32:52.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.007]         }
[10:32:52.007]         else {
[10:32:52.007]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.007]         }
[10:32:52.007]         base::close(...future.stdout)
[10:32:52.007]         ...future.stdout <- NULL
[10:32:52.007]     }
[10:32:52.007]     ...future.result$conditions <- ...future.conditions
[10:32:52.007]     ...future.result$finished <- base::Sys.time()
[10:32:52.007]     ...future.result
[10:32:52.007] }
[10:32:52.010] MultisessionFuture started
[10:32:52.010] - Launch lazy future ... done
[10:32:52.010] run() for ‘MultisessionFuture’ ... done
[10:32:52.010] getGlobalsAndPackages() ...
[10:32:52.010] Searching for globals...
[10:32:52.010] 
[10:32:52.011] Searching for globals ... DONE
[10:32:52.011] - globals: [0] <none>
[10:32:52.011] getGlobalsAndPackages() ... DONE
[10:32:52.011] run() for ‘Future’ ...
[10:32:52.011] - state: ‘created’
[10:32:52.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:52.024]   - Field: ‘node’
[10:32:52.025]   - Field: ‘label’
[10:32:52.025]   - Field: ‘local’
[10:32:52.025]   - Field: ‘owner’
[10:32:52.025]   - Field: ‘envir’
[10:32:52.025]   - Field: ‘workers’
[10:32:52.025]   - Field: ‘packages’
[10:32:52.025]   - Field: ‘gc’
[10:32:52.025]   - Field: ‘conditions’
[10:32:52.025]   - Field: ‘persistent’
[10:32:52.025]   - Field: ‘expr’
[10:32:52.025]   - Field: ‘uuid’
[10:32:52.026]   - Field: ‘seed’
[10:32:52.026]   - Field: ‘version’
[10:32:52.026]   - Field: ‘result’
[10:32:52.026]   - Field: ‘asynchronous’
[10:32:52.026]   - Field: ‘calls’
[10:32:52.026]   - Field: ‘globals’
[10:32:52.026]   - Field: ‘stdout’
[10:32:52.026]   - Field: ‘earlySignal’
[10:32:52.026]   - Field: ‘lazy’
[10:32:52.026]   - Field: ‘state’
[10:32:52.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:52.027] - Launch lazy future ...
[10:32:52.027] Packages needed by the future expression (n = 0): <none>
[10:32:52.027] Packages needed by future strategies (n = 0): <none>
[10:32:52.027] {
[10:32:52.027]     {
[10:32:52.027]         {
[10:32:52.027]             ...future.startTime <- base::Sys.time()
[10:32:52.027]             {
[10:32:52.027]                 {
[10:32:52.027]                   {
[10:32:52.027]                     {
[10:32:52.027]                       base::local({
[10:32:52.027]                         has_future <- base::requireNamespace("future", 
[10:32:52.027]                           quietly = TRUE)
[10:32:52.027]                         if (has_future) {
[10:32:52.027]                           ns <- base::getNamespace("future")
[10:32:52.027]                           version <- ns[[".package"]][["version"]]
[10:32:52.027]                           if (is.null(version)) 
[10:32:52.027]                             version <- utils::packageVersion("future")
[10:32:52.027]                         }
[10:32:52.027]                         else {
[10:32:52.027]                           version <- NULL
[10:32:52.027]                         }
[10:32:52.027]                         if (!has_future || version < "1.8.0") {
[10:32:52.027]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.027]                             "", base::R.version$version.string), 
[10:32:52.027]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.027]                               "release", "version")], collapse = " "), 
[10:32:52.027]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.027]                             info)
[10:32:52.027]                           info <- base::paste(info, collapse = "; ")
[10:32:52.027]                           if (!has_future) {
[10:32:52.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.027]                               info)
[10:32:52.027]                           }
[10:32:52.027]                           else {
[10:32:52.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.027]                               info, version)
[10:32:52.027]                           }
[10:32:52.027]                           base::stop(msg)
[10:32:52.027]                         }
[10:32:52.027]                       })
[10:32:52.027]                     }
[10:32:52.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.027]                     base::options(mc.cores = 1L)
[10:32:52.027]                   }
[10:32:52.027]                   ...future.strategy.old <- future::plan("list")
[10:32:52.027]                   options(future.plan = NULL)
[10:32:52.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.027]                 }
[10:32:52.027]                 ...future.workdir <- getwd()
[10:32:52.027]             }
[10:32:52.027]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.027]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.027]         }
[10:32:52.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.027]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.027]             base::names(...future.oldOptions))
[10:32:52.027]     }
[10:32:52.027]     if (FALSE) {
[10:32:52.027]     }
[10:32:52.027]     else {
[10:32:52.027]         if (TRUE) {
[10:32:52.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.027]                 open = "w")
[10:32:52.027]         }
[10:32:52.027]         else {
[10:32:52.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.027]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.027]         }
[10:32:52.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.027]             base::sink(type = "output", split = FALSE)
[10:32:52.027]             base::close(...future.stdout)
[10:32:52.027]         }, add = TRUE)
[10:32:52.027]     }
[10:32:52.027]     ...future.frame <- base::sys.nframe()
[10:32:52.027]     ...future.conditions <- base::list()
[10:32:52.027]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.027]     if (FALSE) {
[10:32:52.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.027]     }
[10:32:52.027]     ...future.result <- base::tryCatch({
[10:32:52.027]         base::withCallingHandlers({
[10:32:52.027]             ...future.value <- base::withVisible(base::local({
[10:32:52.027]                 ...future.makeSendCondition <- base::local({
[10:32:52.027]                   sendCondition <- NULL
[10:32:52.027]                   function(frame = 1L) {
[10:32:52.027]                     if (is.function(sendCondition)) 
[10:32:52.027]                       return(sendCondition)
[10:32:52.027]                     ns <- getNamespace("parallel")
[10:32:52.027]                     if (exists("sendData", mode = "function", 
[10:32:52.027]                       envir = ns)) {
[10:32:52.027]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:52.027]                         envir = ns)
[10:32:52.027]                       envir <- sys.frame(frame)
[10:32:52.027]                       master <- NULL
[10:32:52.027]                       while (!identical(envir, .GlobalEnv) && 
[10:32:52.027]                         !identical(envir, emptyenv())) {
[10:32:52.027]                         if (exists("master", mode = "list", envir = envir, 
[10:32:52.027]                           inherits = FALSE)) {
[10:32:52.027]                           master <- get("master", mode = "list", 
[10:32:52.027]                             envir = envir, inherits = FALSE)
[10:32:52.027]                           if (inherits(master, c("SOCKnode", 
[10:32:52.027]                             "SOCK0node"))) {
[10:32:52.027]                             sendCondition <<- function(cond) {
[10:32:52.027]                               data <- list(type = "VALUE", value = cond, 
[10:32:52.027]                                 success = TRUE)
[10:32:52.027]                               parallel_sendData(master, data)
[10:32:52.027]                             }
[10:32:52.027]                             return(sendCondition)
[10:32:52.027]                           }
[10:32:52.027]                         }
[10:32:52.027]                         frame <- frame + 1L
[10:32:52.027]                         envir <- sys.frame(frame)
[10:32:52.027]                       }
[10:32:52.027]                     }
[10:32:52.027]                     sendCondition <<- function(cond) NULL
[10:32:52.027]                   }
[10:32:52.027]                 })
[10:32:52.027]                 withCallingHandlers({
[10:32:52.027]                   NULL
[10:32:52.027]                 }, immediateCondition = function(cond) {
[10:32:52.027]                   sendCondition <- ...future.makeSendCondition()
[10:32:52.027]                   sendCondition(cond)
[10:32:52.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.027]                   {
[10:32:52.027]                     inherits <- base::inherits
[10:32:52.027]                     invokeRestart <- base::invokeRestart
[10:32:52.027]                     is.null <- base::is.null
[10:32:52.027]                     muffled <- FALSE
[10:32:52.027]                     if (inherits(cond, "message")) {
[10:32:52.027]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.027]                       if (muffled) 
[10:32:52.027]                         invokeRestart("muffleMessage")
[10:32:52.027]                     }
[10:32:52.027]                     else if (inherits(cond, "warning")) {
[10:32:52.027]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.027]                       if (muffled) 
[10:32:52.027]                         invokeRestart("muffleWarning")
[10:32:52.027]                     }
[10:32:52.027]                     else if (inherits(cond, "condition")) {
[10:32:52.027]                       if (!is.null(pattern)) {
[10:32:52.027]                         computeRestarts <- base::computeRestarts
[10:32:52.027]                         grepl <- base::grepl
[10:32:52.027]                         restarts <- computeRestarts(cond)
[10:32:52.027]                         for (restart in restarts) {
[10:32:52.027]                           name <- restart$name
[10:32:52.027]                           if (is.null(name)) 
[10:32:52.027]                             next
[10:32:52.027]                           if (!grepl(pattern, name)) 
[10:32:52.027]                             next
[10:32:52.027]                           invokeRestart(restart)
[10:32:52.027]                           muffled <- TRUE
[10:32:52.027]                           break
[10:32:52.027]                         }
[10:32:52.027]                       }
[10:32:52.027]                     }
[10:32:52.027]                     invisible(muffled)
[10:32:52.027]                   }
[10:32:52.027]                   muffleCondition(cond)
[10:32:52.027]                 })
[10:32:52.027]             }))
[10:32:52.027]             future::FutureResult(value = ...future.value$value, 
[10:32:52.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.027]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.027]                     ...future.globalenv.names))
[10:32:52.027]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.027]         }, condition = base::local({
[10:32:52.027]             c <- base::c
[10:32:52.027]             inherits <- base::inherits
[10:32:52.027]             invokeRestart <- base::invokeRestart
[10:32:52.027]             length <- base::length
[10:32:52.027]             list <- base::list
[10:32:52.027]             seq.int <- base::seq.int
[10:32:52.027]             signalCondition <- base::signalCondition
[10:32:52.027]             sys.calls <- base::sys.calls
[10:32:52.027]             `[[` <- base::`[[`
[10:32:52.027]             `+` <- base::`+`
[10:32:52.027]             `<<-` <- base::`<<-`
[10:32:52.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.027]                   3L)]
[10:32:52.027]             }
[10:32:52.027]             function(cond) {
[10:32:52.027]                 is_error <- inherits(cond, "error")
[10:32:52.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.027]                   NULL)
[10:32:52.027]                 if (is_error) {
[10:32:52.027]                   sessionInformation <- function() {
[10:32:52.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.027]                       search = base::search(), system = base::Sys.info())
[10:32:52.027]                   }
[10:32:52.027]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.027]                     cond$call), session = sessionInformation(), 
[10:32:52.027]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.027]                   signalCondition(cond)
[10:32:52.027]                 }
[10:32:52.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.027]                 "immediateCondition"))) {
[10:32:52.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.027]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.027]                   if (TRUE && !signal) {
[10:32:52.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.027]                     {
[10:32:52.027]                       inherits <- base::inherits
[10:32:52.027]                       invokeRestart <- base::invokeRestart
[10:32:52.027]                       is.null <- base::is.null
[10:32:52.027]                       muffled <- FALSE
[10:32:52.027]                       if (inherits(cond, "message")) {
[10:32:52.027]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.027]                         if (muffled) 
[10:32:52.027]                           invokeRestart("muffleMessage")
[10:32:52.027]                       }
[10:32:52.027]                       else if (inherits(cond, "warning")) {
[10:32:52.027]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.027]                         if (muffled) 
[10:32:52.027]                           invokeRestart("muffleWarning")
[10:32:52.027]                       }
[10:32:52.027]                       else if (inherits(cond, "condition")) {
[10:32:52.027]                         if (!is.null(pattern)) {
[10:32:52.027]                           computeRestarts <- base::computeRestarts
[10:32:52.027]                           grepl <- base::grepl
[10:32:52.027]                           restarts <- computeRestarts(cond)
[10:32:52.027]                           for (restart in restarts) {
[10:32:52.027]                             name <- restart$name
[10:32:52.027]                             if (is.null(name)) 
[10:32:52.027]                               next
[10:32:52.027]                             if (!grepl(pattern, name)) 
[10:32:52.027]                               next
[10:32:52.027]                             invokeRestart(restart)
[10:32:52.027]                             muffled <- TRUE
[10:32:52.027]                             break
[10:32:52.027]                           }
[10:32:52.027]                         }
[10:32:52.027]                       }
[10:32:52.027]                       invisible(muffled)
[10:32:52.027]                     }
[10:32:52.027]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.027]                   }
[10:32:52.027]                 }
[10:32:52.027]                 else {
[10:32:52.027]                   if (TRUE) {
[10:32:52.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.027]                     {
[10:32:52.027]                       inherits <- base::inherits
[10:32:52.027]                       invokeRestart <- base::invokeRestart
[10:32:52.027]                       is.null <- base::is.null
[10:32:52.027]                       muffled <- FALSE
[10:32:52.027]                       if (inherits(cond, "message")) {
[10:32:52.027]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.027]                         if (muffled) 
[10:32:52.027]                           invokeRestart("muffleMessage")
[10:32:52.027]                       }
[10:32:52.027]                       else if (inherits(cond, "warning")) {
[10:32:52.027]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.027]                         if (muffled) 
[10:32:52.027]                           invokeRestart("muffleWarning")
[10:32:52.027]                       }
[10:32:52.027]                       else if (inherits(cond, "condition")) {
[10:32:52.027]                         if (!is.null(pattern)) {
[10:32:52.027]                           computeRestarts <- base::computeRestarts
[10:32:52.027]                           grepl <- base::grepl
[10:32:52.027]                           restarts <- computeRestarts(cond)
[10:32:52.027]                           for (restart in restarts) {
[10:32:52.027]                             name <- restart$name
[10:32:52.027]                             if (is.null(name)) 
[10:32:52.027]                               next
[10:32:52.027]                             if (!grepl(pattern, name)) 
[10:32:52.027]                               next
[10:32:52.027]                             invokeRestart(restart)
[10:32:52.027]                             muffled <- TRUE
[10:32:52.027]                             break
[10:32:52.027]                           }
[10:32:52.027]                         }
[10:32:52.027]                       }
[10:32:52.027]                       invisible(muffled)
[10:32:52.027]                     }
[10:32:52.027]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.027]                   }
[10:32:52.027]                 }
[10:32:52.027]             }
[10:32:52.027]         }))
[10:32:52.027]     }, error = function(ex) {
[10:32:52.027]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.027]                 ...future.rng), started = ...future.startTime, 
[10:32:52.027]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.027]             version = "1.8"), class = "FutureResult")
[10:32:52.027]     }, finally = {
[10:32:52.027]         if (!identical(...future.workdir, getwd())) 
[10:32:52.027]             setwd(...future.workdir)
[10:32:52.027]         {
[10:32:52.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.027]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.027]             }
[10:32:52.027]             base::options(...future.oldOptions)
[10:32:52.027]             if (.Platform$OS.type == "windows") {
[10:32:52.027]                 old_names <- names(...future.oldEnvVars)
[10:32:52.027]                 envs <- base::Sys.getenv()
[10:32:52.027]                 names <- names(envs)
[10:32:52.027]                 common <- intersect(names, old_names)
[10:32:52.027]                 added <- setdiff(names, old_names)
[10:32:52.027]                 removed <- setdiff(old_names, names)
[10:32:52.027]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.027]                   envs[common]]
[10:32:52.027]                 NAMES <- toupper(changed)
[10:32:52.027]                 args <- list()
[10:32:52.027]                 for (kk in seq_along(NAMES)) {
[10:32:52.027]                   name <- changed[[kk]]
[10:32:52.027]                   NAME <- NAMES[[kk]]
[10:32:52.027]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.027]                     next
[10:32:52.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.027]                 }
[10:32:52.027]                 NAMES <- toupper(added)
[10:32:52.027]                 for (kk in seq_along(NAMES)) {
[10:32:52.027]                   name <- added[[kk]]
[10:32:52.027]                   NAME <- NAMES[[kk]]
[10:32:52.027]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.027]                     next
[10:32:52.027]                   args[[name]] <- ""
[10:32:52.027]                 }
[10:32:52.027]                 NAMES <- toupper(removed)
[10:32:52.027]                 for (kk in seq_along(NAMES)) {
[10:32:52.027]                   name <- removed[[kk]]
[10:32:52.027]                   NAME <- NAMES[[kk]]
[10:32:52.027]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.027]                     next
[10:32:52.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.027]                 }
[10:32:52.027]                 if (length(args) > 0) 
[10:32:52.027]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.027]             }
[10:32:52.027]             else {
[10:32:52.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.027]             }
[10:32:52.027]             {
[10:32:52.027]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.027]                   0L) {
[10:32:52.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.027]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.027]                   base::options(opts)
[10:32:52.027]                 }
[10:32:52.027]                 {
[10:32:52.027]                   {
[10:32:52.027]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.027]                     NULL
[10:32:52.027]                   }
[10:32:52.027]                   options(future.plan = NULL)
[10:32:52.027]                   if (is.na(NA_character_)) 
[10:32:52.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.027]                     .init = FALSE)
[10:32:52.027]                 }
[10:32:52.027]             }
[10:32:52.027]         }
[10:32:52.027]     })
[10:32:52.027]     if (TRUE) {
[10:32:52.027]         base::sink(type = "output", split = FALSE)
[10:32:52.027]         if (TRUE) {
[10:32:52.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.027]         }
[10:32:52.027]         else {
[10:32:52.027]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.027]         }
[10:32:52.027]         base::close(...future.stdout)
[10:32:52.027]         ...future.stdout <- NULL
[10:32:52.027]     }
[10:32:52.027]     ...future.result$conditions <- ...future.conditions
[10:32:52.027]     ...future.result$finished <- base::Sys.time()
[10:32:52.027]     ...future.result
[10:32:52.027] }
[10:32:52.030] MultisessionFuture started
[10:32:52.030] - Launch lazy future ... done
[10:32:52.030] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d2f44c50> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1396a80> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d2f44c50> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5652d1396a80> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:52.036] receiveMessageFromWorker() for ClusterFuture ...
[10:32:52.036] - Validating connection of MultisessionFuture
[10:32:52.036] - received message: FutureResult
[10:32:52.036] - Received FutureResult
[10:32:52.036] - Erased future from FutureRegistry
[10:32:52.037] result() for ClusterFuture ...
[10:32:52.037] - result already collected: FutureResult
[10:32:52.037] result() for ClusterFuture ... done
[10:32:52.037] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:52.037] receiveMessageFromWorker() for ClusterFuture ...
[10:32:52.037] - Validating connection of MultisessionFuture
[10:32:52.038] - received message: FutureResult
[10:32:52.038] - Received FutureResult
[10:32:52.038] - Erased future from FutureRegistry
[10:32:52.038] result() for ClusterFuture ...
[10:32:52.038] - result already collected: FutureResult
[10:32:52.038] result() for ClusterFuture ... done
[10:32:52.038] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:32:52.040] resolve() on list ...
[10:32:52.040]  recursive: 0
[10:32:52.040]  length: 6
[10:32:52.040]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:32:52.040] signalConditionsASAP(numeric, pos=1) ...
[10:32:52.041] - nx: 6
[10:32:52.041] - relay: TRUE
[10:32:52.041] - stdout: TRUE
[10:32:52.041] - signal: TRUE
[10:32:52.041] - resignal: FALSE
[10:32:52.041] - force: TRUE
[10:32:52.041] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:52.041] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:52.041]  - until=2
[10:32:52.041]  - relaying element #2
[10:32:52.042] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:52.042] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:52.042] signalConditionsASAP(NULL, pos=1) ... done
[10:32:52.042]  length: 5 (resolved future 1)
[10:32:52.042] Future #2
[10:32:52.042] result() for ClusterFuture ...
[10:32:52.042] - result already collected: FutureResult
[10:32:52.042] result() for ClusterFuture ... done
[10:32:52.042] result() for ClusterFuture ...
[10:32:52.042] - result already collected: FutureResult
[10:32:52.042] result() for ClusterFuture ... done
[10:32:52.043] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:52.043] - nx: 6
[10:32:52.043] - relay: TRUE
[10:32:52.043] - stdout: TRUE
[10:32:52.043] - signal: TRUE
[10:32:52.043] - resignal: FALSE
[10:32:52.043] - force: TRUE
[10:32:52.043] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:52.043] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:52.043]  - until=2
[10:32:52.043]  - relaying element #2
[10:32:52.044] result() for ClusterFuture ...
[10:32:52.044] - result already collected: FutureResult
[10:32:52.044] result() for ClusterFuture ... done
[10:32:52.044] result() for ClusterFuture ...
[10:32:52.044] - result already collected: FutureResult
[10:32:52.044] result() for ClusterFuture ... done
[10:32:52.044] result() for ClusterFuture ...
[10:32:52.044] - result already collected: FutureResult
[10:32:52.044] result() for ClusterFuture ... done
[10:32:52.044] result() for ClusterFuture ...
[10:32:52.044] - result already collected: FutureResult
[10:32:52.044] result() for ClusterFuture ... done
[10:32:52.045] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:52.045] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:52.045] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:52.045]  length: 4 (resolved future 2)
[10:32:52.045] Future #3
[10:32:52.045] result() for ClusterFuture ...
[10:32:52.045] - result already collected: FutureResult
[10:32:52.045] result() for ClusterFuture ... done
[10:32:52.045] result() for ClusterFuture ...
[10:32:52.045] - result already collected: FutureResult
[10:32:52.046] result() for ClusterFuture ... done
[10:32:52.046] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:52.046] - nx: 6
[10:32:52.046] - relay: TRUE
[10:32:52.046] - stdout: TRUE
[10:32:52.046] - signal: TRUE
[10:32:52.046] - resignal: FALSE
[10:32:52.046] - force: TRUE
[10:32:52.046] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:52.046] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:52.046]  - until=3
[10:32:52.046]  - relaying element #3
[10:32:52.047] result() for ClusterFuture ...
[10:32:52.047] - result already collected: FutureResult
[10:32:52.047] result() for ClusterFuture ... done
[10:32:52.047] result() for ClusterFuture ...
[10:32:52.047] - result already collected: FutureResult
[10:32:52.047] result() for ClusterFuture ... done
[10:32:52.047] result() for ClusterFuture ...
[10:32:52.047] - result already collected: FutureResult
[10:32:52.047] result() for ClusterFuture ... done
[10:32:52.047] result() for ClusterFuture ...
[10:32:52.047] - result already collected: FutureResult
[10:32:52.048] result() for ClusterFuture ... done
[10:32:52.048] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.048] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.048] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:52.048]  length: 3 (resolved future 3)
[10:32:52.048] signalConditionsASAP(NULL, pos=4) ...
[10:32:52.048] - nx: 6
[10:32:52.048] - relay: TRUE
[10:32:52.048] - stdout: TRUE
[10:32:52.048] - signal: TRUE
[10:32:52.048] - resignal: FALSE
[10:32:52.048] - force: TRUE
[10:32:52.049] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.049] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.049]  - until=5
[10:32:52.049]  - relaying element #5
[10:32:52.049] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:52.049] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.049] signalConditionsASAP(NULL, pos=4) ... done
[10:32:52.049]  length: 2 (resolved future 4)
[10:32:52.049] signalConditionsASAP(NULL, pos=5) ...
[10:32:52.049] - nx: 6
[10:32:52.049] - relay: TRUE
[10:32:52.050] - stdout: TRUE
[10:32:52.050] - signal: TRUE
[10:32:52.050] - resignal: FALSE
[10:32:52.050] - force: TRUE
[10:32:52.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:52.050] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.050]  - until=6
[10:32:52.050]  - relaying element #6
[10:32:52.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:52.050] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.050] signalConditionsASAP(NULL, pos=5) ... done
[10:32:52.050]  length: 1 (resolved future 5)
[10:32:52.051] signalConditionsASAP(numeric, pos=6) ...
[10:32:52.051] - nx: 6
[10:32:52.051] - relay: TRUE
[10:32:52.051] - stdout: TRUE
[10:32:52.051] - signal: TRUE
[10:32:52.051] - resignal: FALSE
[10:32:52.051] - force: TRUE
[10:32:52.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:52.051] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.051]  - until=6
[10:32:52.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:52.051] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.052] signalConditionsASAP(numeric, pos=6) ... done
[10:32:52.052]  length: 0 (resolved future 6)
[10:32:52.052] Relaying remaining futures
[10:32:52.052] signalConditionsASAP(NULL, pos=0) ...
[10:32:52.052] - nx: 6
[10:32:52.052] - relay: TRUE
[10:32:52.052] - stdout: TRUE
[10:32:52.052] - signal: TRUE
[10:32:52.052] - resignal: FALSE
[10:32:52.052] - force: TRUE
[10:32:52.052] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:52.052] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:32:52.053] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:52.053] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:52.053] signalConditionsASAP(NULL, pos=0) ... done
[10:32:52.053] resolve() on list ... DONE
[10:32:52.053] result() for ClusterFuture ...
[10:32:52.053] - result already collected: FutureResult
[10:32:52.053] result() for ClusterFuture ... done
[10:32:52.053] result() for ClusterFuture ...
[10:32:52.053] - result already collected: FutureResult
[10:32:52.053] result() for ClusterFuture ... done
[10:32:52.054] result() for ClusterFuture ...
[10:32:52.054] - result already collected: FutureResult
[10:32:52.054] result() for ClusterFuture ... done
[10:32:52.054] result() for ClusterFuture ...
[10:32:52.054] - result already collected: FutureResult
[10:32:52.054] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[10:32:52.058] plan(): Setting new future strategy stack:
[10:32:52.058] List of future strategies:
[10:32:52.058] 1. multicore:
[10:32:52.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.058]    - tweaked: FALSE
[10:32:52.058]    - call: plan(strategy)
[10:32:52.062] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:32:52.062] getGlobalsAndPackages() ...
[10:32:52.062] Searching for globals...
[10:32:52.063] 
[10:32:52.063] Searching for globals ... DONE
[10:32:52.063] - globals: [0] <none>
[10:32:52.063] getGlobalsAndPackages() ... DONE
[10:32:52.063] run() for ‘Future’ ...
[10:32:52.063] - state: ‘created’
[10:32:52.064] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.067] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.067]   - Field: ‘label’
[10:32:52.067]   - Field: ‘local’
[10:32:52.068]   - Field: ‘owner’
[10:32:52.068]   - Field: ‘envir’
[10:32:52.068]   - Field: ‘workers’
[10:32:52.068]   - Field: ‘packages’
[10:32:52.068]   - Field: ‘gc’
[10:32:52.068]   - Field: ‘job’
[10:32:52.068]   - Field: ‘conditions’
[10:32:52.068]   - Field: ‘expr’
[10:32:52.068]   - Field: ‘uuid’
[10:32:52.068]   - Field: ‘seed’
[10:32:52.069]   - Field: ‘version’
[10:32:52.069]   - Field: ‘result’
[10:32:52.069]   - Field: ‘asynchronous’
[10:32:52.069]   - Field: ‘calls’
[10:32:52.069]   - Field: ‘globals’
[10:32:52.069]   - Field: ‘stdout’
[10:32:52.069]   - Field: ‘earlySignal’
[10:32:52.069]   - Field: ‘lazy’
[10:32:52.069]   - Field: ‘state’
[10:32:52.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.070] - Launch lazy future ...
[10:32:52.070] Packages needed by the future expression (n = 0): <none>
[10:32:52.070] Packages needed by future strategies (n = 0): <none>
[10:32:52.070] {
[10:32:52.070]     {
[10:32:52.070]         {
[10:32:52.070]             ...future.startTime <- base::Sys.time()
[10:32:52.070]             {
[10:32:52.070]                 {
[10:32:52.070]                   {
[10:32:52.070]                     {
[10:32:52.070]                       base::local({
[10:32:52.070]                         has_future <- base::requireNamespace("future", 
[10:32:52.070]                           quietly = TRUE)
[10:32:52.070]                         if (has_future) {
[10:32:52.070]                           ns <- base::getNamespace("future")
[10:32:52.070]                           version <- ns[[".package"]][["version"]]
[10:32:52.070]                           if (is.null(version)) 
[10:32:52.070]                             version <- utils::packageVersion("future")
[10:32:52.070]                         }
[10:32:52.070]                         else {
[10:32:52.070]                           version <- NULL
[10:32:52.070]                         }
[10:32:52.070]                         if (!has_future || version < "1.8.0") {
[10:32:52.070]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.070]                             "", base::R.version$version.string), 
[10:32:52.070]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.070]                               "release", "version")], collapse = " "), 
[10:32:52.070]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.070]                             info)
[10:32:52.070]                           info <- base::paste(info, collapse = "; ")
[10:32:52.070]                           if (!has_future) {
[10:32:52.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.070]                               info)
[10:32:52.070]                           }
[10:32:52.070]                           else {
[10:32:52.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.070]                               info, version)
[10:32:52.070]                           }
[10:32:52.070]                           base::stop(msg)
[10:32:52.070]                         }
[10:32:52.070]                       })
[10:32:52.070]                     }
[10:32:52.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.070]                     base::options(mc.cores = 1L)
[10:32:52.070]                   }
[10:32:52.070]                   ...future.strategy.old <- future::plan("list")
[10:32:52.070]                   options(future.plan = NULL)
[10:32:52.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.070]                 }
[10:32:52.070]                 ...future.workdir <- getwd()
[10:32:52.070]             }
[10:32:52.070]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.070]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.070]         }
[10:32:52.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.070]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.070]             base::names(...future.oldOptions))
[10:32:52.070]     }
[10:32:52.070]     if (FALSE) {
[10:32:52.070]     }
[10:32:52.070]     else {
[10:32:52.070]         if (TRUE) {
[10:32:52.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.070]                 open = "w")
[10:32:52.070]         }
[10:32:52.070]         else {
[10:32:52.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.070]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.070]         }
[10:32:52.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.070]             base::sink(type = "output", split = FALSE)
[10:32:52.070]             base::close(...future.stdout)
[10:32:52.070]         }, add = TRUE)
[10:32:52.070]     }
[10:32:52.070]     ...future.frame <- base::sys.nframe()
[10:32:52.070]     ...future.conditions <- base::list()
[10:32:52.070]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.070]     if (FALSE) {
[10:32:52.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.070]     }
[10:32:52.070]     ...future.result <- base::tryCatch({
[10:32:52.070]         base::withCallingHandlers({
[10:32:52.070]             ...future.value <- base::withVisible(base::local({
[10:32:52.070]                 withCallingHandlers({
[10:32:52.070]                   2
[10:32:52.070]                 }, immediateCondition = function(cond) {
[10:32:52.070]                   save_rds <- function (object, pathname, ...) 
[10:32:52.070]                   {
[10:32:52.070]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.070]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.070]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.070]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.070]                         fi_tmp[["mtime"]])
[10:32:52.070]                     }
[10:32:52.070]                     tryCatch({
[10:32:52.070]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.070]                     }, error = function(ex) {
[10:32:52.070]                       msg <- conditionMessage(ex)
[10:32:52.070]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.070]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.070]                         fi_tmp[["mtime"]], msg)
[10:32:52.070]                       ex$message <- msg
[10:32:52.070]                       stop(ex)
[10:32:52.070]                     })
[10:32:52.070]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.070]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.070]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.070]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.070]                       fi <- file.info(pathname)
[10:32:52.070]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.070]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.070]                         fi[["size"]], fi[["mtime"]])
[10:32:52.070]                       stop(msg)
[10:32:52.070]                     }
[10:32:52.070]                     invisible(pathname)
[10:32:52.070]                   }
[10:32:52.070]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.070]                     rootPath = tempdir()) 
[10:32:52.070]                   {
[10:32:52.070]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.070]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.070]                       tmpdir = path, fileext = ".rds")
[10:32:52.070]                     save_rds(obj, file)
[10:32:52.070]                   }
[10:32:52.070]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.070]                   {
[10:32:52.070]                     inherits <- base::inherits
[10:32:52.070]                     invokeRestart <- base::invokeRestart
[10:32:52.070]                     is.null <- base::is.null
[10:32:52.070]                     muffled <- FALSE
[10:32:52.070]                     if (inherits(cond, "message")) {
[10:32:52.070]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.070]                       if (muffled) 
[10:32:52.070]                         invokeRestart("muffleMessage")
[10:32:52.070]                     }
[10:32:52.070]                     else if (inherits(cond, "warning")) {
[10:32:52.070]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.070]                       if (muffled) 
[10:32:52.070]                         invokeRestart("muffleWarning")
[10:32:52.070]                     }
[10:32:52.070]                     else if (inherits(cond, "condition")) {
[10:32:52.070]                       if (!is.null(pattern)) {
[10:32:52.070]                         computeRestarts <- base::computeRestarts
[10:32:52.070]                         grepl <- base::grepl
[10:32:52.070]                         restarts <- computeRestarts(cond)
[10:32:52.070]                         for (restart in restarts) {
[10:32:52.070]                           name <- restart$name
[10:32:52.070]                           if (is.null(name)) 
[10:32:52.070]                             next
[10:32:52.070]                           if (!grepl(pattern, name)) 
[10:32:52.070]                             next
[10:32:52.070]                           invokeRestart(restart)
[10:32:52.070]                           muffled <- TRUE
[10:32:52.070]                           break
[10:32:52.070]                         }
[10:32:52.070]                       }
[10:32:52.070]                     }
[10:32:52.070]                     invisible(muffled)
[10:32:52.070]                   }
[10:32:52.070]                   muffleCondition(cond)
[10:32:52.070]                 })
[10:32:52.070]             }))
[10:32:52.070]             future::FutureResult(value = ...future.value$value, 
[10:32:52.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.070]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.070]                     ...future.globalenv.names))
[10:32:52.070]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.070]         }, condition = base::local({
[10:32:52.070]             c <- base::c
[10:32:52.070]             inherits <- base::inherits
[10:32:52.070]             invokeRestart <- base::invokeRestart
[10:32:52.070]             length <- base::length
[10:32:52.070]             list <- base::list
[10:32:52.070]             seq.int <- base::seq.int
[10:32:52.070]             signalCondition <- base::signalCondition
[10:32:52.070]             sys.calls <- base::sys.calls
[10:32:52.070]             `[[` <- base::`[[`
[10:32:52.070]             `+` <- base::`+`
[10:32:52.070]             `<<-` <- base::`<<-`
[10:32:52.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.070]                   3L)]
[10:32:52.070]             }
[10:32:52.070]             function(cond) {
[10:32:52.070]                 is_error <- inherits(cond, "error")
[10:32:52.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.070]                   NULL)
[10:32:52.070]                 if (is_error) {
[10:32:52.070]                   sessionInformation <- function() {
[10:32:52.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.070]                       search = base::search(), system = base::Sys.info())
[10:32:52.070]                   }
[10:32:52.070]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.070]                     cond$call), session = sessionInformation(), 
[10:32:52.070]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.070]                   signalCondition(cond)
[10:32:52.070]                 }
[10:32:52.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.070]                 "immediateCondition"))) {
[10:32:52.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.070]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.070]                   if (TRUE && !signal) {
[10:32:52.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.070]                     {
[10:32:52.070]                       inherits <- base::inherits
[10:32:52.070]                       invokeRestart <- base::invokeRestart
[10:32:52.070]                       is.null <- base::is.null
[10:32:52.070]                       muffled <- FALSE
[10:32:52.070]                       if (inherits(cond, "message")) {
[10:32:52.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.070]                         if (muffled) 
[10:32:52.070]                           invokeRestart("muffleMessage")
[10:32:52.070]                       }
[10:32:52.070]                       else if (inherits(cond, "warning")) {
[10:32:52.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.070]                         if (muffled) 
[10:32:52.070]                           invokeRestart("muffleWarning")
[10:32:52.070]                       }
[10:32:52.070]                       else if (inherits(cond, "condition")) {
[10:32:52.070]                         if (!is.null(pattern)) {
[10:32:52.070]                           computeRestarts <- base::computeRestarts
[10:32:52.070]                           grepl <- base::grepl
[10:32:52.070]                           restarts <- computeRestarts(cond)
[10:32:52.070]                           for (restart in restarts) {
[10:32:52.070]                             name <- restart$name
[10:32:52.070]                             if (is.null(name)) 
[10:32:52.070]                               next
[10:32:52.070]                             if (!grepl(pattern, name)) 
[10:32:52.070]                               next
[10:32:52.070]                             invokeRestart(restart)
[10:32:52.070]                             muffled <- TRUE
[10:32:52.070]                             break
[10:32:52.070]                           }
[10:32:52.070]                         }
[10:32:52.070]                       }
[10:32:52.070]                       invisible(muffled)
[10:32:52.070]                     }
[10:32:52.070]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.070]                   }
[10:32:52.070]                 }
[10:32:52.070]                 else {
[10:32:52.070]                   if (TRUE) {
[10:32:52.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.070]                     {
[10:32:52.070]                       inherits <- base::inherits
[10:32:52.070]                       invokeRestart <- base::invokeRestart
[10:32:52.070]                       is.null <- base::is.null
[10:32:52.070]                       muffled <- FALSE
[10:32:52.070]                       if (inherits(cond, "message")) {
[10:32:52.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.070]                         if (muffled) 
[10:32:52.070]                           invokeRestart("muffleMessage")
[10:32:52.070]                       }
[10:32:52.070]                       else if (inherits(cond, "warning")) {
[10:32:52.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.070]                         if (muffled) 
[10:32:52.070]                           invokeRestart("muffleWarning")
[10:32:52.070]                       }
[10:32:52.070]                       else if (inherits(cond, "condition")) {
[10:32:52.070]                         if (!is.null(pattern)) {
[10:32:52.070]                           computeRestarts <- base::computeRestarts
[10:32:52.070]                           grepl <- base::grepl
[10:32:52.070]                           restarts <- computeRestarts(cond)
[10:32:52.070]                           for (restart in restarts) {
[10:32:52.070]                             name <- restart$name
[10:32:52.070]                             if (is.null(name)) 
[10:32:52.070]                               next
[10:32:52.070]                             if (!grepl(pattern, name)) 
[10:32:52.070]                               next
[10:32:52.070]                             invokeRestart(restart)
[10:32:52.070]                             muffled <- TRUE
[10:32:52.070]                             break
[10:32:52.070]                           }
[10:32:52.070]                         }
[10:32:52.070]                       }
[10:32:52.070]                       invisible(muffled)
[10:32:52.070]                     }
[10:32:52.070]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.070]                   }
[10:32:52.070]                 }
[10:32:52.070]             }
[10:32:52.070]         }))
[10:32:52.070]     }, error = function(ex) {
[10:32:52.070]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.070]                 ...future.rng), started = ...future.startTime, 
[10:32:52.070]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.070]             version = "1.8"), class = "FutureResult")
[10:32:52.070]     }, finally = {
[10:32:52.070]         if (!identical(...future.workdir, getwd())) 
[10:32:52.070]             setwd(...future.workdir)
[10:32:52.070]         {
[10:32:52.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.070]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.070]             }
[10:32:52.070]             base::options(...future.oldOptions)
[10:32:52.070]             if (.Platform$OS.type == "windows") {
[10:32:52.070]                 old_names <- names(...future.oldEnvVars)
[10:32:52.070]                 envs <- base::Sys.getenv()
[10:32:52.070]                 names <- names(envs)
[10:32:52.070]                 common <- intersect(names, old_names)
[10:32:52.070]                 added <- setdiff(names, old_names)
[10:32:52.070]                 removed <- setdiff(old_names, names)
[10:32:52.070]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.070]                   envs[common]]
[10:32:52.070]                 NAMES <- toupper(changed)
[10:32:52.070]                 args <- list()
[10:32:52.070]                 for (kk in seq_along(NAMES)) {
[10:32:52.070]                   name <- changed[[kk]]
[10:32:52.070]                   NAME <- NAMES[[kk]]
[10:32:52.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.070]                     next
[10:32:52.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.070]                 }
[10:32:52.070]                 NAMES <- toupper(added)
[10:32:52.070]                 for (kk in seq_along(NAMES)) {
[10:32:52.070]                   name <- added[[kk]]
[10:32:52.070]                   NAME <- NAMES[[kk]]
[10:32:52.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.070]                     next
[10:32:52.070]                   args[[name]] <- ""
[10:32:52.070]                 }
[10:32:52.070]                 NAMES <- toupper(removed)
[10:32:52.070]                 for (kk in seq_along(NAMES)) {
[10:32:52.070]                   name <- removed[[kk]]
[10:32:52.070]                   NAME <- NAMES[[kk]]
[10:32:52.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.070]                     next
[10:32:52.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.070]                 }
[10:32:52.070]                 if (length(args) > 0) 
[10:32:52.070]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.070]             }
[10:32:52.070]             else {
[10:32:52.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.070]             }
[10:32:52.070]             {
[10:32:52.070]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.070]                   0L) {
[10:32:52.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.070]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.070]                   base::options(opts)
[10:32:52.070]                 }
[10:32:52.070]                 {
[10:32:52.070]                   {
[10:32:52.070]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.070]                     NULL
[10:32:52.070]                   }
[10:32:52.070]                   options(future.plan = NULL)
[10:32:52.070]                   if (is.na(NA_character_)) 
[10:32:52.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.070]                     .init = FALSE)
[10:32:52.070]                 }
[10:32:52.070]             }
[10:32:52.070]         }
[10:32:52.070]     })
[10:32:52.070]     if (TRUE) {
[10:32:52.070]         base::sink(type = "output", split = FALSE)
[10:32:52.070]         if (TRUE) {
[10:32:52.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.070]         }
[10:32:52.070]         else {
[10:32:52.070]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.070]         }
[10:32:52.070]         base::close(...future.stdout)
[10:32:52.070]         ...future.stdout <- NULL
[10:32:52.070]     }
[10:32:52.070]     ...future.result$conditions <- ...future.conditions
[10:32:52.070]     ...future.result$finished <- base::Sys.time()
[10:32:52.070]     ...future.result
[10:32:52.070] }
[10:32:52.073] requestCore(): workers = 2
[10:32:52.075] MulticoreFuture started
[10:32:52.075] - Launch lazy future ... done
[10:32:52.076] run() for ‘MulticoreFuture’ ... done
[10:32:52.076] getGlobalsAndPackages() ...
[10:32:52.076] Searching for globals...
[10:32:52.076] plan(): Setting new future strategy stack:
[10:32:52.077] 
[10:32:52.077] Searching for globals ... DONE
[10:32:52.077] List of future strategies:
[10:32:52.077] 1. sequential:
[10:32:52.077]    - args: function (..., envir = parent.frame())
[10:32:52.077]    - tweaked: FALSE
[10:32:52.077]    - call: NULL
[10:32:52.077] - globals: [0] <none>
[10:32:52.077] getGlobalsAndPackages() ... DONE
[10:32:52.078] plan(): nbrOfWorkers() = 1
[10:32:52.078] run() for ‘Future’ ...
[10:32:52.078] - state: ‘created’
[10:32:52.078] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.079] plan(): Setting new future strategy stack:
[10:32:52.079] List of future strategies:
[10:32:52.079] 1. multicore:
[10:32:52.079]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.079]    - tweaked: FALSE
[10:32:52.079]    - call: plan(strategy)
[10:32:52.084] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.084] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.084] plan(): nbrOfWorkers() = 2
[10:32:52.084]   - Field: ‘label’
[10:32:52.084]   - Field: ‘local’
[10:32:52.084]   - Field: ‘owner’
[10:32:52.084]   - Field: ‘envir’
[10:32:52.084]   - Field: ‘workers’
[10:32:52.085]   - Field: ‘packages’
[10:32:52.085]   - Field: ‘gc’
[10:32:52.085]   - Field: ‘job’
[10:32:52.085]   - Field: ‘conditions’
[10:32:52.085]   - Field: ‘expr’
[10:32:52.085]   - Field: ‘uuid’
[10:32:52.086]   - Field: ‘seed’
[10:32:52.086]   - Field: ‘version’
[10:32:52.086]   - Field: ‘result’
[10:32:52.086]   - Field: ‘asynchronous’
[10:32:52.086]   - Field: ‘calls’
[10:32:52.086]   - Field: ‘globals’
[10:32:52.086]   - Field: ‘stdout’
[10:32:52.087]   - Field: ‘earlySignal’
[10:32:52.087]   - Field: ‘lazy’
[10:32:52.087]   - Field: ‘state’
[10:32:52.087] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.087] - Launch lazy future ...
[10:32:52.088] Packages needed by the future expression (n = 0): <none>
[10:32:52.088] Packages needed by future strategies (n = 0): <none>
[10:32:52.088] {
[10:32:52.088]     {
[10:32:52.088]         {
[10:32:52.088]             ...future.startTime <- base::Sys.time()
[10:32:52.088]             {
[10:32:52.088]                 {
[10:32:52.088]                   {
[10:32:52.088]                     {
[10:32:52.088]                       base::local({
[10:32:52.088]                         has_future <- base::requireNamespace("future", 
[10:32:52.088]                           quietly = TRUE)
[10:32:52.088]                         if (has_future) {
[10:32:52.088]                           ns <- base::getNamespace("future")
[10:32:52.088]                           version <- ns[[".package"]][["version"]]
[10:32:52.088]                           if (is.null(version)) 
[10:32:52.088]                             version <- utils::packageVersion("future")
[10:32:52.088]                         }
[10:32:52.088]                         else {
[10:32:52.088]                           version <- NULL
[10:32:52.088]                         }
[10:32:52.088]                         if (!has_future || version < "1.8.0") {
[10:32:52.088]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.088]                             "", base::R.version$version.string), 
[10:32:52.088]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.088]                               "release", "version")], collapse = " "), 
[10:32:52.088]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.088]                             info)
[10:32:52.088]                           info <- base::paste(info, collapse = "; ")
[10:32:52.088]                           if (!has_future) {
[10:32:52.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.088]                               info)
[10:32:52.088]                           }
[10:32:52.088]                           else {
[10:32:52.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.088]                               info, version)
[10:32:52.088]                           }
[10:32:52.088]                           base::stop(msg)
[10:32:52.088]                         }
[10:32:52.088]                       })
[10:32:52.088]                     }
[10:32:52.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.088]                     base::options(mc.cores = 1L)
[10:32:52.088]                   }
[10:32:52.088]                   ...future.strategy.old <- future::plan("list")
[10:32:52.088]                   options(future.plan = NULL)
[10:32:52.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.088]                 }
[10:32:52.088]                 ...future.workdir <- getwd()
[10:32:52.088]             }
[10:32:52.088]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.088]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.088]         }
[10:32:52.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.088]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.088]             base::names(...future.oldOptions))
[10:32:52.088]     }
[10:32:52.088]     if (FALSE) {
[10:32:52.088]     }
[10:32:52.088]     else {
[10:32:52.088]         if (TRUE) {
[10:32:52.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.088]                 open = "w")
[10:32:52.088]         }
[10:32:52.088]         else {
[10:32:52.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.088]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.088]         }
[10:32:52.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.088]             base::sink(type = "output", split = FALSE)
[10:32:52.088]             base::close(...future.stdout)
[10:32:52.088]         }, add = TRUE)
[10:32:52.088]     }
[10:32:52.088]     ...future.frame <- base::sys.nframe()
[10:32:52.088]     ...future.conditions <- base::list()
[10:32:52.088]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.088]     if (FALSE) {
[10:32:52.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.088]     }
[10:32:52.088]     ...future.result <- base::tryCatch({
[10:32:52.088]         base::withCallingHandlers({
[10:32:52.088]             ...future.value <- base::withVisible(base::local({
[10:32:52.088]                 withCallingHandlers({
[10:32:52.088]                   NULL
[10:32:52.088]                 }, immediateCondition = function(cond) {
[10:32:52.088]                   save_rds <- function (object, pathname, ...) 
[10:32:52.088]                   {
[10:32:52.088]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.088]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.088]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.088]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.088]                         fi_tmp[["mtime"]])
[10:32:52.088]                     }
[10:32:52.088]                     tryCatch({
[10:32:52.088]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.088]                     }, error = function(ex) {
[10:32:52.088]                       msg <- conditionMessage(ex)
[10:32:52.088]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.088]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.088]                         fi_tmp[["mtime"]], msg)
[10:32:52.088]                       ex$message <- msg
[10:32:52.088]                       stop(ex)
[10:32:52.088]                     })
[10:32:52.088]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.088]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.088]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.088]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.088]                       fi <- file.info(pathname)
[10:32:52.088]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.088]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.088]                         fi[["size"]], fi[["mtime"]])
[10:32:52.088]                       stop(msg)
[10:32:52.088]                     }
[10:32:52.088]                     invisible(pathname)
[10:32:52.088]                   }
[10:32:52.088]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.088]                     rootPath = tempdir()) 
[10:32:52.088]                   {
[10:32:52.088]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.088]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.088]                       tmpdir = path, fileext = ".rds")
[10:32:52.088]                     save_rds(obj, file)
[10:32:52.088]                   }
[10:32:52.088]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.088]                   {
[10:32:52.088]                     inherits <- base::inherits
[10:32:52.088]                     invokeRestart <- base::invokeRestart
[10:32:52.088]                     is.null <- base::is.null
[10:32:52.088]                     muffled <- FALSE
[10:32:52.088]                     if (inherits(cond, "message")) {
[10:32:52.088]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.088]                       if (muffled) 
[10:32:52.088]                         invokeRestart("muffleMessage")
[10:32:52.088]                     }
[10:32:52.088]                     else if (inherits(cond, "warning")) {
[10:32:52.088]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.088]                       if (muffled) 
[10:32:52.088]                         invokeRestart("muffleWarning")
[10:32:52.088]                     }
[10:32:52.088]                     else if (inherits(cond, "condition")) {
[10:32:52.088]                       if (!is.null(pattern)) {
[10:32:52.088]                         computeRestarts <- base::computeRestarts
[10:32:52.088]                         grepl <- base::grepl
[10:32:52.088]                         restarts <- computeRestarts(cond)
[10:32:52.088]                         for (restart in restarts) {
[10:32:52.088]                           name <- restart$name
[10:32:52.088]                           if (is.null(name)) 
[10:32:52.088]                             next
[10:32:52.088]                           if (!grepl(pattern, name)) 
[10:32:52.088]                             next
[10:32:52.088]                           invokeRestart(restart)
[10:32:52.088]                           muffled <- TRUE
[10:32:52.088]                           break
[10:32:52.088]                         }
[10:32:52.088]                       }
[10:32:52.088]                     }
[10:32:52.088]                     invisible(muffled)
[10:32:52.088]                   }
[10:32:52.088]                   muffleCondition(cond)
[10:32:52.088]                 })
[10:32:52.088]             }))
[10:32:52.088]             future::FutureResult(value = ...future.value$value, 
[10:32:52.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.088]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.088]                     ...future.globalenv.names))
[10:32:52.088]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.088]         }, condition = base::local({
[10:32:52.088]             c <- base::c
[10:32:52.088]             inherits <- base::inherits
[10:32:52.088]             invokeRestart <- base::invokeRestart
[10:32:52.088]             length <- base::length
[10:32:52.088]             list <- base::list
[10:32:52.088]             seq.int <- base::seq.int
[10:32:52.088]             signalCondition <- base::signalCondition
[10:32:52.088]             sys.calls <- base::sys.calls
[10:32:52.088]             `[[` <- base::`[[`
[10:32:52.088]             `+` <- base::`+`
[10:32:52.088]             `<<-` <- base::`<<-`
[10:32:52.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.088]                   3L)]
[10:32:52.088]             }
[10:32:52.088]             function(cond) {
[10:32:52.088]                 is_error <- inherits(cond, "error")
[10:32:52.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.088]                   NULL)
[10:32:52.088]                 if (is_error) {
[10:32:52.088]                   sessionInformation <- function() {
[10:32:52.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.088]                       search = base::search(), system = base::Sys.info())
[10:32:52.088]                   }
[10:32:52.088]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.088]                     cond$call), session = sessionInformation(), 
[10:32:52.088]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.088]                   signalCondition(cond)
[10:32:52.088]                 }
[10:32:52.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.088]                 "immediateCondition"))) {
[10:32:52.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.088]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.088]                   if (TRUE && !signal) {
[10:32:52.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.088]                     {
[10:32:52.088]                       inherits <- base::inherits
[10:32:52.088]                       invokeRestart <- base::invokeRestart
[10:32:52.088]                       is.null <- base::is.null
[10:32:52.088]                       muffled <- FALSE
[10:32:52.088]                       if (inherits(cond, "message")) {
[10:32:52.088]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.088]                         if (muffled) 
[10:32:52.088]                           invokeRestart("muffleMessage")
[10:32:52.088]                       }
[10:32:52.088]                       else if (inherits(cond, "warning")) {
[10:32:52.088]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.088]                         if (muffled) 
[10:32:52.088]                           invokeRestart("muffleWarning")
[10:32:52.088]                       }
[10:32:52.088]                       else if (inherits(cond, "condition")) {
[10:32:52.088]                         if (!is.null(pattern)) {
[10:32:52.088]                           computeRestarts <- base::computeRestarts
[10:32:52.088]                           grepl <- base::grepl
[10:32:52.088]                           restarts <- computeRestarts(cond)
[10:32:52.088]                           for (restart in restarts) {
[10:32:52.088]                             name <- restart$name
[10:32:52.088]                             if (is.null(name)) 
[10:32:52.088]                               next
[10:32:52.088]                             if (!grepl(pattern, name)) 
[10:32:52.088]                               next
[10:32:52.088]                             invokeRestart(restart)
[10:32:52.088]                             muffled <- TRUE
[10:32:52.088]                             break
[10:32:52.088]                           }
[10:32:52.088]                         }
[10:32:52.088]                       }
[10:32:52.088]                       invisible(muffled)
[10:32:52.088]                     }
[10:32:52.088]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.088]                   }
[10:32:52.088]                 }
[10:32:52.088]                 else {
[10:32:52.088]                   if (TRUE) {
[10:32:52.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.088]                     {
[10:32:52.088]                       inherits <- base::inherits
[10:32:52.088]                       invokeRestart <- base::invokeRestart
[10:32:52.088]                       is.null <- base::is.null
[10:32:52.088]                       muffled <- FALSE
[10:32:52.088]                       if (inherits(cond, "message")) {
[10:32:52.088]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.088]                         if (muffled) 
[10:32:52.088]                           invokeRestart("muffleMessage")
[10:32:52.088]                       }
[10:32:52.088]                       else if (inherits(cond, "warning")) {
[10:32:52.088]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.088]                         if (muffled) 
[10:32:52.088]                           invokeRestart("muffleWarning")
[10:32:52.088]                       }
[10:32:52.088]                       else if (inherits(cond, "condition")) {
[10:32:52.088]                         if (!is.null(pattern)) {
[10:32:52.088]                           computeRestarts <- base::computeRestarts
[10:32:52.088]                           grepl <- base::grepl
[10:32:52.088]                           restarts <- computeRestarts(cond)
[10:32:52.088]                           for (restart in restarts) {
[10:32:52.088]                             name <- restart$name
[10:32:52.088]                             if (is.null(name)) 
[10:32:52.088]                               next
[10:32:52.088]                             if (!grepl(pattern, name)) 
[10:32:52.088]                               next
[10:32:52.088]                             invokeRestart(restart)
[10:32:52.088]                             muffled <- TRUE
[10:32:52.088]                             break
[10:32:52.088]                           }
[10:32:52.088]                         }
[10:32:52.088]                       }
[10:32:52.088]                       invisible(muffled)
[10:32:52.088]                     }
[10:32:52.088]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.088]                   }
[10:32:52.088]                 }
[10:32:52.088]             }
[10:32:52.088]         }))
[10:32:52.088]     }, error = function(ex) {
[10:32:52.088]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.088]                 ...future.rng), started = ...future.startTime, 
[10:32:52.088]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.088]             version = "1.8"), class = "FutureResult")
[10:32:52.088]     }, finally = {
[10:32:52.088]         if (!identical(...future.workdir, getwd())) 
[10:32:52.088]             setwd(...future.workdir)
[10:32:52.088]         {
[10:32:52.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.088]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.088]             }
[10:32:52.088]             base::options(...future.oldOptions)
[10:32:52.088]             if (.Platform$OS.type == "windows") {
[10:32:52.088]                 old_names <- names(...future.oldEnvVars)
[10:32:52.088]                 envs <- base::Sys.getenv()
[10:32:52.088]                 names <- names(envs)
[10:32:52.088]                 common <- intersect(names, old_names)
[10:32:52.088]                 added <- setdiff(names, old_names)
[10:32:52.088]                 removed <- setdiff(old_names, names)
[10:32:52.088]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.088]                   envs[common]]
[10:32:52.088]                 NAMES <- toupper(changed)
[10:32:52.088]                 args <- list()
[10:32:52.088]                 for (kk in seq_along(NAMES)) {
[10:32:52.088]                   name <- changed[[kk]]
[10:32:52.088]                   NAME <- NAMES[[kk]]
[10:32:52.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.088]                     next
[10:32:52.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.088]                 }
[10:32:52.088]                 NAMES <- toupper(added)
[10:32:52.088]                 for (kk in seq_along(NAMES)) {
[10:32:52.088]                   name <- added[[kk]]
[10:32:52.088]                   NAME <- NAMES[[kk]]
[10:32:52.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.088]                     next
[10:32:52.088]                   args[[name]] <- ""
[10:32:52.088]                 }
[10:32:52.088]                 NAMES <- toupper(removed)
[10:32:52.088]                 for (kk in seq_along(NAMES)) {
[10:32:52.088]                   name <- removed[[kk]]
[10:32:52.088]                   NAME <- NAMES[[kk]]
[10:32:52.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.088]                     next
[10:32:52.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.088]                 }
[10:32:52.088]                 if (length(args) > 0) 
[10:32:52.088]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.088]             }
[10:32:52.088]             else {
[10:32:52.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.088]             }
[10:32:52.088]             {
[10:32:52.088]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.088]                   0L) {
[10:32:52.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.088]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.088]                   base::options(opts)
[10:32:52.088]                 }
[10:32:52.088]                 {
[10:32:52.088]                   {
[10:32:52.088]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.088]                     NULL
[10:32:52.088]                   }
[10:32:52.088]                   options(future.plan = NULL)
[10:32:52.088]                   if (is.na(NA_character_)) 
[10:32:52.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.088]                     .init = FALSE)
[10:32:52.088]                 }
[10:32:52.088]             }
[10:32:52.088]         }
[10:32:52.088]     })
[10:32:52.088]     if (TRUE) {
[10:32:52.088]         base::sink(type = "output", split = FALSE)
[10:32:52.088]         if (TRUE) {
[10:32:52.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.088]         }
[10:32:52.088]         else {
[10:32:52.088]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.088]         }
[10:32:52.088]         base::close(...future.stdout)
[10:32:52.088]         ...future.stdout <- NULL
[10:32:52.088]     }
[10:32:52.088]     ...future.result$conditions <- ...future.conditions
[10:32:52.088]     ...future.result$finished <- base::Sys.time()
[10:32:52.088]     ...future.result
[10:32:52.088] }
[10:32:52.092] requestCore(): workers = 2
[10:32:52.094] MulticoreFuture started
[10:32:52.095] - Launch lazy future ... done
[10:32:52.095] run() for ‘MulticoreFuture’ ... done
[10:32:52.095] plan(): Setting new future strategy stack:
[10:32:52.096] getGlobalsAndPackages() ...
[10:32:52.096] Searching for globals...
[10:32:52.096] List of future strategies:
[10:32:52.096] 1. sequential:
[10:32:52.096]    - args: function (..., envir = parent.frame())
[10:32:52.096]    - tweaked: FALSE
[10:32:52.096]    - call: NULL
[10:32:52.096] plan(): nbrOfWorkers() = 1
[10:32:52.097] - globals found: [1] ‘{’
[10:32:52.097] Searching for globals ... DONE
[10:32:52.097] Resolving globals: FALSE
[10:32:52.098] 
[10:32:52.098] 
[10:32:52.098] getGlobalsAndPackages() ... DONE
[10:32:52.098] plan(): Setting new future strategy stack:
[10:32:52.099] run() for ‘Future’ ...
[10:32:52.098] List of future strategies:
[10:32:52.098] 1. multicore:
[10:32:52.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.098]    - tweaked: FALSE
[10:32:52.098]    - call: plan(strategy)
[10:32:52.099] - state: ‘created’
[10:32:52.099] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.104] plan(): nbrOfWorkers() = 2
[10:32:52.104] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.104]   - Field: ‘label’
[10:32:52.104]   - Field: ‘local’
[10:32:52.105]   - Field: ‘owner’
[10:32:52.105]   - Field: ‘envir’
[10:32:52.105]   - Field: ‘workers’
[10:32:52.105]   - Field: ‘packages’
[10:32:52.105]   - Field: ‘gc’
[10:32:52.105]   - Field: ‘job’
[10:32:52.105]   - Field: ‘conditions’
[10:32:52.106]   - Field: ‘expr’
[10:32:52.106]   - Field: ‘uuid’
[10:32:52.106]   - Field: ‘seed’
[10:32:52.106]   - Field: ‘version’
[10:32:52.106]   - Field: ‘result’
[10:32:52.106]   - Field: ‘asynchronous’
[10:32:52.106]   - Field: ‘calls’
[10:32:52.107]   - Field: ‘globals’
[10:32:52.107]   - Field: ‘stdout’
[10:32:52.107]   - Field: ‘earlySignal’
[10:32:52.107]   - Field: ‘lazy’
[10:32:52.107]   - Field: ‘state’
[10:32:52.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.107] - Launch lazy future ...
[10:32:52.108] Packages needed by the future expression (n = 0): <none>
[10:32:52.108] Packages needed by future strategies (n = 0): <none>
[10:32:52.109] {
[10:32:52.109]     {
[10:32:52.109]         {
[10:32:52.109]             ...future.startTime <- base::Sys.time()
[10:32:52.109]             {
[10:32:52.109]                 {
[10:32:52.109]                   {
[10:32:52.109]                     {
[10:32:52.109]                       base::local({
[10:32:52.109]                         has_future <- base::requireNamespace("future", 
[10:32:52.109]                           quietly = TRUE)
[10:32:52.109]                         if (has_future) {
[10:32:52.109]                           ns <- base::getNamespace("future")
[10:32:52.109]                           version <- ns[[".package"]][["version"]]
[10:32:52.109]                           if (is.null(version)) 
[10:32:52.109]                             version <- utils::packageVersion("future")
[10:32:52.109]                         }
[10:32:52.109]                         else {
[10:32:52.109]                           version <- NULL
[10:32:52.109]                         }
[10:32:52.109]                         if (!has_future || version < "1.8.0") {
[10:32:52.109]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.109]                             "", base::R.version$version.string), 
[10:32:52.109]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.109]                               "release", "version")], collapse = " "), 
[10:32:52.109]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.109]                             info)
[10:32:52.109]                           info <- base::paste(info, collapse = "; ")
[10:32:52.109]                           if (!has_future) {
[10:32:52.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.109]                               info)
[10:32:52.109]                           }
[10:32:52.109]                           else {
[10:32:52.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.109]                               info, version)
[10:32:52.109]                           }
[10:32:52.109]                           base::stop(msg)
[10:32:52.109]                         }
[10:32:52.109]                       })
[10:32:52.109]                     }
[10:32:52.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.109]                     base::options(mc.cores = 1L)
[10:32:52.109]                   }
[10:32:52.109]                   ...future.strategy.old <- future::plan("list")
[10:32:52.109]                   options(future.plan = NULL)
[10:32:52.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.109]                 }
[10:32:52.109]                 ...future.workdir <- getwd()
[10:32:52.109]             }
[10:32:52.109]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.109]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.109]         }
[10:32:52.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.109]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.109]             base::names(...future.oldOptions))
[10:32:52.109]     }
[10:32:52.109]     if (FALSE) {
[10:32:52.109]     }
[10:32:52.109]     else {
[10:32:52.109]         if (TRUE) {
[10:32:52.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.109]                 open = "w")
[10:32:52.109]         }
[10:32:52.109]         else {
[10:32:52.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.109]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.109]         }
[10:32:52.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.109]             base::sink(type = "output", split = FALSE)
[10:32:52.109]             base::close(...future.stdout)
[10:32:52.109]         }, add = TRUE)
[10:32:52.109]     }
[10:32:52.109]     ...future.frame <- base::sys.nframe()
[10:32:52.109]     ...future.conditions <- base::list()
[10:32:52.109]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.109]     if (FALSE) {
[10:32:52.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.109]     }
[10:32:52.109]     ...future.result <- base::tryCatch({
[10:32:52.109]         base::withCallingHandlers({
[10:32:52.109]             ...future.value <- base::withVisible(base::local({
[10:32:52.109]                 withCallingHandlers({
[10:32:52.109]                   {
[10:32:52.109]                     4
[10:32:52.109]                   }
[10:32:52.109]                 }, immediateCondition = function(cond) {
[10:32:52.109]                   save_rds <- function (object, pathname, ...) 
[10:32:52.109]                   {
[10:32:52.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.109]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.109]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.109]                         fi_tmp[["mtime"]])
[10:32:52.109]                     }
[10:32:52.109]                     tryCatch({
[10:32:52.109]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.109]                     }, error = function(ex) {
[10:32:52.109]                       msg <- conditionMessage(ex)
[10:32:52.109]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.109]                         fi_tmp[["mtime"]], msg)
[10:32:52.109]                       ex$message <- msg
[10:32:52.109]                       stop(ex)
[10:32:52.109]                     })
[10:32:52.109]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.109]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.109]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.109]                       fi <- file.info(pathname)
[10:32:52.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.109]                         fi[["size"]], fi[["mtime"]])
[10:32:52.109]                       stop(msg)
[10:32:52.109]                     }
[10:32:52.109]                     invisible(pathname)
[10:32:52.109]                   }
[10:32:52.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.109]                     rootPath = tempdir()) 
[10:32:52.109]                   {
[10:32:52.109]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.109]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.109]                       tmpdir = path, fileext = ".rds")
[10:32:52.109]                     save_rds(obj, file)
[10:32:52.109]                   }
[10:32:52.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.109]                   {
[10:32:52.109]                     inherits <- base::inherits
[10:32:52.109]                     invokeRestart <- base::invokeRestart
[10:32:52.109]                     is.null <- base::is.null
[10:32:52.109]                     muffled <- FALSE
[10:32:52.109]                     if (inherits(cond, "message")) {
[10:32:52.109]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.109]                       if (muffled) 
[10:32:52.109]                         invokeRestart("muffleMessage")
[10:32:52.109]                     }
[10:32:52.109]                     else if (inherits(cond, "warning")) {
[10:32:52.109]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.109]                       if (muffled) 
[10:32:52.109]                         invokeRestart("muffleWarning")
[10:32:52.109]                     }
[10:32:52.109]                     else if (inherits(cond, "condition")) {
[10:32:52.109]                       if (!is.null(pattern)) {
[10:32:52.109]                         computeRestarts <- base::computeRestarts
[10:32:52.109]                         grepl <- base::grepl
[10:32:52.109]                         restarts <- computeRestarts(cond)
[10:32:52.109]                         for (restart in restarts) {
[10:32:52.109]                           name <- restart$name
[10:32:52.109]                           if (is.null(name)) 
[10:32:52.109]                             next
[10:32:52.109]                           if (!grepl(pattern, name)) 
[10:32:52.109]                             next
[10:32:52.109]                           invokeRestart(restart)
[10:32:52.109]                           muffled <- TRUE
[10:32:52.109]                           break
[10:32:52.109]                         }
[10:32:52.109]                       }
[10:32:52.109]                     }
[10:32:52.109]                     invisible(muffled)
[10:32:52.109]                   }
[10:32:52.109]                   muffleCondition(cond)
[10:32:52.109]                 })
[10:32:52.109]             }))
[10:32:52.109]             future::FutureResult(value = ...future.value$value, 
[10:32:52.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.109]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.109]                     ...future.globalenv.names))
[10:32:52.109]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.109]         }, condition = base::local({
[10:32:52.109]             c <- base::c
[10:32:52.109]             inherits <- base::inherits
[10:32:52.109]             invokeRestart <- base::invokeRestart
[10:32:52.109]             length <- base::length
[10:32:52.109]             list <- base::list
[10:32:52.109]             seq.int <- base::seq.int
[10:32:52.109]             signalCondition <- base::signalCondition
[10:32:52.109]             sys.calls <- base::sys.calls
[10:32:52.109]             `[[` <- base::`[[`
[10:32:52.109]             `+` <- base::`+`
[10:32:52.109]             `<<-` <- base::`<<-`
[10:32:52.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.109]                   3L)]
[10:32:52.109]             }
[10:32:52.109]             function(cond) {
[10:32:52.109]                 is_error <- inherits(cond, "error")
[10:32:52.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.109]                   NULL)
[10:32:52.109]                 if (is_error) {
[10:32:52.109]                   sessionInformation <- function() {
[10:32:52.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.109]                       search = base::search(), system = base::Sys.info())
[10:32:52.109]                   }
[10:32:52.109]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.109]                     cond$call), session = sessionInformation(), 
[10:32:52.109]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.109]                   signalCondition(cond)
[10:32:52.109]                 }
[10:32:52.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.109]                 "immediateCondition"))) {
[10:32:52.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.109]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.109]                   if (TRUE && !signal) {
[10:32:52.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.109]                     {
[10:32:52.109]                       inherits <- base::inherits
[10:32:52.109]                       invokeRestart <- base::invokeRestart
[10:32:52.109]                       is.null <- base::is.null
[10:32:52.109]                       muffled <- FALSE
[10:32:52.109]                       if (inherits(cond, "message")) {
[10:32:52.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.109]                         if (muffled) 
[10:32:52.109]                           invokeRestart("muffleMessage")
[10:32:52.109]                       }
[10:32:52.109]                       else if (inherits(cond, "warning")) {
[10:32:52.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.109]                         if (muffled) 
[10:32:52.109]                           invokeRestart("muffleWarning")
[10:32:52.109]                       }
[10:32:52.109]                       else if (inherits(cond, "condition")) {
[10:32:52.109]                         if (!is.null(pattern)) {
[10:32:52.109]                           computeRestarts <- base::computeRestarts
[10:32:52.109]                           grepl <- base::grepl
[10:32:52.109]                           restarts <- computeRestarts(cond)
[10:32:52.109]                           for (restart in restarts) {
[10:32:52.109]                             name <- restart$name
[10:32:52.109]                             if (is.null(name)) 
[10:32:52.109]                               next
[10:32:52.109]                             if (!grepl(pattern, name)) 
[10:32:52.109]                               next
[10:32:52.109]                             invokeRestart(restart)
[10:32:52.109]                             muffled <- TRUE
[10:32:52.109]                             break
[10:32:52.109]                           }
[10:32:52.109]                         }
[10:32:52.109]                       }
[10:32:52.109]                       invisible(muffled)
[10:32:52.109]                     }
[10:32:52.109]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.109]                   }
[10:32:52.109]                 }
[10:32:52.109]                 else {
[10:32:52.109]                   if (TRUE) {
[10:32:52.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.109]                     {
[10:32:52.109]                       inherits <- base::inherits
[10:32:52.109]                       invokeRestart <- base::invokeRestart
[10:32:52.109]                       is.null <- base::is.null
[10:32:52.109]                       muffled <- FALSE
[10:32:52.109]                       if (inherits(cond, "message")) {
[10:32:52.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.109]                         if (muffled) 
[10:32:52.109]                           invokeRestart("muffleMessage")
[10:32:52.109]                       }
[10:32:52.109]                       else if (inherits(cond, "warning")) {
[10:32:52.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.109]                         if (muffled) 
[10:32:52.109]                           invokeRestart("muffleWarning")
[10:32:52.109]                       }
[10:32:52.109]                       else if (inherits(cond, "condition")) {
[10:32:52.109]                         if (!is.null(pattern)) {
[10:32:52.109]                           computeRestarts <- base::computeRestarts
[10:32:52.109]                           grepl <- base::grepl
[10:32:52.109]                           restarts <- computeRestarts(cond)
[10:32:52.109]                           for (restart in restarts) {
[10:32:52.109]                             name <- restart$name
[10:32:52.109]                             if (is.null(name)) 
[10:32:52.109]                               next
[10:32:52.109]                             if (!grepl(pattern, name)) 
[10:32:52.109]                               next
[10:32:52.109]                             invokeRestart(restart)
[10:32:52.109]                             muffled <- TRUE
[10:32:52.109]                             break
[10:32:52.109]                           }
[10:32:52.109]                         }
[10:32:52.109]                       }
[10:32:52.109]                       invisible(muffled)
[10:32:52.109]                     }
[10:32:52.109]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.109]                   }
[10:32:52.109]                 }
[10:32:52.109]             }
[10:32:52.109]         }))
[10:32:52.109]     }, error = function(ex) {
[10:32:52.109]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.109]                 ...future.rng), started = ...future.startTime, 
[10:32:52.109]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.109]             version = "1.8"), class = "FutureResult")
[10:32:52.109]     }, finally = {
[10:32:52.109]         if (!identical(...future.workdir, getwd())) 
[10:32:52.109]             setwd(...future.workdir)
[10:32:52.109]         {
[10:32:52.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.109]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.109]             }
[10:32:52.109]             base::options(...future.oldOptions)
[10:32:52.109]             if (.Platform$OS.type == "windows") {
[10:32:52.109]                 old_names <- names(...future.oldEnvVars)
[10:32:52.109]                 envs <- base::Sys.getenv()
[10:32:52.109]                 names <- names(envs)
[10:32:52.109]                 common <- intersect(names, old_names)
[10:32:52.109]                 added <- setdiff(names, old_names)
[10:32:52.109]                 removed <- setdiff(old_names, names)
[10:32:52.109]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.109]                   envs[common]]
[10:32:52.109]                 NAMES <- toupper(changed)
[10:32:52.109]                 args <- list()
[10:32:52.109]                 for (kk in seq_along(NAMES)) {
[10:32:52.109]                   name <- changed[[kk]]
[10:32:52.109]                   NAME <- NAMES[[kk]]
[10:32:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.109]                     next
[10:32:52.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.109]                 }
[10:32:52.109]                 NAMES <- toupper(added)
[10:32:52.109]                 for (kk in seq_along(NAMES)) {
[10:32:52.109]                   name <- added[[kk]]
[10:32:52.109]                   NAME <- NAMES[[kk]]
[10:32:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.109]                     next
[10:32:52.109]                   args[[name]] <- ""
[10:32:52.109]                 }
[10:32:52.109]                 NAMES <- toupper(removed)
[10:32:52.109]                 for (kk in seq_along(NAMES)) {
[10:32:52.109]                   name <- removed[[kk]]
[10:32:52.109]                   NAME <- NAMES[[kk]]
[10:32:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.109]                     next
[10:32:52.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.109]                 }
[10:32:52.109]                 if (length(args) > 0) 
[10:32:52.109]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.109]             }
[10:32:52.109]             else {
[10:32:52.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.109]             }
[10:32:52.109]             {
[10:32:52.109]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.109]                   0L) {
[10:32:52.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.109]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.109]                   base::options(opts)
[10:32:52.109]                 }
[10:32:52.109]                 {
[10:32:52.109]                   {
[10:32:52.109]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.109]                     NULL
[10:32:52.109]                   }
[10:32:52.109]                   options(future.plan = NULL)
[10:32:52.109]                   if (is.na(NA_character_)) 
[10:32:52.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.109]                     .init = FALSE)
[10:32:52.109]                 }
[10:32:52.109]             }
[10:32:52.109]         }
[10:32:52.109]     })
[10:32:52.109]     if (TRUE) {
[10:32:52.109]         base::sink(type = "output", split = FALSE)
[10:32:52.109]         if (TRUE) {
[10:32:52.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.109]         }
[10:32:52.109]         else {
[10:32:52.109]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.109]         }
[10:32:52.109]         base::close(...future.stdout)
[10:32:52.109]         ...future.stdout <- NULL
[10:32:52.109]     }
[10:32:52.109]     ...future.result$conditions <- ...future.conditions
[10:32:52.109]     ...future.result$finished <- base::Sys.time()
[10:32:52.109]     ...future.result
[10:32:52.109] }
[10:32:52.112] requestCore(): workers = 2
[10:32:52.112] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:52.123] result() for MulticoreFuture ...
[10:32:52.124] result() for MulticoreFuture ...
[10:32:52.124] result() for MulticoreFuture ... done
[10:32:52.124] result() for MulticoreFuture ... done
[10:32:52.124] result() for MulticoreFuture ...
[10:32:52.124] result() for MulticoreFuture ... done
[10:32:52.127] MulticoreFuture started
[10:32:52.127] - Launch lazy future ... done
[10:32:52.127] run() for ‘MulticoreFuture’ ... done
[10:32:52.128] plan(): Setting new future strategy stack:
<environment: 0x5652d246df00> 
[10:32:52.128] List of future strategies:
[10:32:52.128] 1. sequential:
[10:32:52.128]    - args: function (..., envir = parent.frame())
[10:32:52.128]    - tweaked: FALSE
[10:32:52.128]    - call: NULL
[10:32:52.130] plan(): nbrOfWorkers() = 1
<environment: 0x5652d2eecdf0> 
[10:32:52.132] plan(): Setting new future strategy stack:
[10:32:52.132] List of future strategies:
[10:32:52.132] 1. multicore:
[10:32:52.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.132]    - tweaked: FALSE
[10:32:52.132]    - call: plan(strategy)
[10:32:52.137] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:52.139] resolve() on environment ...
[10:32:52.139]  recursive: 0
[10:32:52.147]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:52.147] signalConditionsASAP(numeric, pos=1) ...
[10:32:52.147] - nx: 4
[10:32:52.147] - relay: TRUE
[10:32:52.147] - stdout: TRUE
[10:32:52.147] - signal: TRUE
[10:32:52.147] - resignal: FALSE
[10:32:52.148] - force: TRUE
[10:32:52.148] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.148] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.148]  - until=2
[10:32:52.148]  - relaying element #2
[10:32:52.148] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.148] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.149] signalConditionsASAP(NULL, pos=1) ... done
[10:32:52.149]  length: 3 (resolved future 1)
[10:32:52.149] Future #2
[10:32:52.149] result() for MulticoreFuture ...
[10:32:52.149] result() for MulticoreFuture ... done
[10:32:52.149] result() for MulticoreFuture ...
[10:32:52.149] result() for MulticoreFuture ... done
[10:32:52.150] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:52.150] - nx: 4
[10:32:52.150] - relay: TRUE
[10:32:52.150] - stdout: TRUE
[10:32:52.150] - signal: TRUE
[10:32:52.150] - resignal: FALSE
[10:32:52.150] - force: TRUE
[10:32:52.150] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.151] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.151]  - until=2
[10:32:52.151]  - relaying element #2
[10:32:52.151] result() for MulticoreFuture ...
[10:32:52.151] result() for MulticoreFuture ... done
[10:32:52.151] result() for MulticoreFuture ...
[10:32:52.151] result() for MulticoreFuture ... done
[10:32:52.152] result() for MulticoreFuture ...
[10:32:52.152] result() for MulticoreFuture ... done
[10:32:52.152] result() for MulticoreFuture ...
[10:32:52.152] result() for MulticoreFuture ... done
[10:32:52.152] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.152] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.152] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:52.153]  length: 2 (resolved future 2)
[10:32:52.153] Future #3
[10:32:52.153] result() for MulticoreFuture ...
[10:32:52.154] result() for MulticoreFuture ...
[10:32:52.154] result() for MulticoreFuture ... done
[10:32:52.154] result() for MulticoreFuture ... done
[10:32:52.154] result() for MulticoreFuture ...
[10:32:52.154] result() for MulticoreFuture ... done
[10:32:52.155] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:52.155] - nx: 4
[10:32:52.155] - relay: TRUE
[10:32:52.155] - stdout: TRUE
[10:32:52.155] - signal: TRUE
[10:32:52.155] - resignal: FALSE
[10:32:52.155] - force: TRUE
[10:32:52.155] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.156] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.156]  - until=3
[10:32:52.156]  - relaying element #3
[10:32:52.156] result() for MulticoreFuture ...
[10:32:52.156] result() for MulticoreFuture ... done
[10:32:52.156] result() for MulticoreFuture ...
[10:32:52.156] result() for MulticoreFuture ... done
[10:32:52.157] result() for MulticoreFuture ...
[10:32:52.157] result() for MulticoreFuture ... done
[10:32:52.157] result() for MulticoreFuture ...
[10:32:52.157] result() for MulticoreFuture ... done
[10:32:52.157] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.157] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.158] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:52.158]  length: 1 (resolved future 3)
[10:32:52.158] Future #4
[10:32:52.158] result() for MulticoreFuture ...
[10:32:52.159] result() for MulticoreFuture ...
[10:32:52.159] result() for MulticoreFuture ... done
[10:32:52.159] result() for MulticoreFuture ... done
[10:32:52.159] result() for MulticoreFuture ...
[10:32:52.160] result() for MulticoreFuture ... done
[10:32:52.160] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:52.160] - nx: 4
[10:32:52.160] - relay: TRUE
[10:32:52.160] - stdout: TRUE
[10:32:52.160] - signal: TRUE
[10:32:52.160] - resignal: FALSE
[10:32:52.161] - force: TRUE
[10:32:52.161] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.161] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.161]  - until=4
[10:32:52.161]  - relaying element #4
[10:32:52.161] result() for MulticoreFuture ...
[10:32:52.162] result() for MulticoreFuture ... done
[10:32:52.162] result() for MulticoreFuture ...
[10:32:52.162] result() for MulticoreFuture ... done
[10:32:52.162] result() for MulticoreFuture ...
[10:32:52.162] result() for MulticoreFuture ... done
[10:32:52.162] result() for MulticoreFuture ...
[10:32:52.162] result() for MulticoreFuture ... done
[10:32:52.163] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.163] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.163] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:52.163]  length: 0 (resolved future 4)
[10:32:52.163] Relaying remaining futures
[10:32:52.163] signalConditionsASAP(NULL, pos=0) ...
[10:32:52.163] - nx: 4
[10:32:52.163] - relay: TRUE
[10:32:52.163] - stdout: TRUE
[10:32:52.164] - signal: TRUE
[10:32:52.164] - resignal: FALSE
[10:32:52.164] - force: TRUE
[10:32:52.164] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.164] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:52.164] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.164] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.164] signalConditionsASAP(NULL, pos=0) ... done
[10:32:52.164] resolve() on environment ... DONE
[10:32:52.165] result() for MulticoreFuture ...
[10:32:52.165] result() for MulticoreFuture ... done
[10:32:52.165] result() for MulticoreFuture ...
[10:32:52.165] result() for MulticoreFuture ... done
[10:32:52.165] result() for MulticoreFuture ...
[10:32:52.165] result() for MulticoreFuture ... done
[10:32:52.165] result() for MulticoreFuture ...
[10:32:52.165] result() for MulticoreFuture ... done
[10:32:52.165] result() for MulticoreFuture ...
[10:32:52.166] result() for MulticoreFuture ... done
[10:32:52.166] result() for MulticoreFuture ...
[10:32:52.166] result() for MulticoreFuture ... done
<environment: 0x5652d2fa62c0> 
Dimensions: c(1, 6)
[10:32:52.166] getGlobalsAndPackages() ...
[10:32:52.166] Searching for globals...
[10:32:52.167] 
[10:32:52.167] Searching for globals ... DONE
[10:32:52.167] - globals: [0] <none>
[10:32:52.167] getGlobalsAndPackages() ... DONE
[10:32:52.167] run() for ‘Future’ ...
[10:32:52.168] - state: ‘created’
[10:32:52.168] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.172] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.172]   - Field: ‘label’
[10:32:52.172]   - Field: ‘local’
[10:32:52.172]   - Field: ‘owner’
[10:32:52.172]   - Field: ‘envir’
[10:32:52.172]   - Field: ‘workers’
[10:32:52.173]   - Field: ‘packages’
[10:32:52.173]   - Field: ‘gc’
[10:32:52.173]   - Field: ‘job’
[10:32:52.173]   - Field: ‘conditions’
[10:32:52.173]   - Field: ‘expr’
[10:32:52.173]   - Field: ‘uuid’
[10:32:52.173]   - Field: ‘seed’
[10:32:52.173]   - Field: ‘version’
[10:32:52.174]   - Field: ‘result’
[10:32:52.174]   - Field: ‘asynchronous’
[10:32:52.174]   - Field: ‘calls’
[10:32:52.174]   - Field: ‘globals’
[10:32:52.174]   - Field: ‘stdout’
[10:32:52.174]   - Field: ‘earlySignal’
[10:32:52.174]   - Field: ‘lazy’
[10:32:52.174]   - Field: ‘state’
[10:32:52.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.175] - Launch lazy future ...
[10:32:52.175] Packages needed by the future expression (n = 0): <none>
[10:32:52.175] Packages needed by future strategies (n = 0): <none>
[10:32:52.176] {
[10:32:52.176]     {
[10:32:52.176]         {
[10:32:52.176]             ...future.startTime <- base::Sys.time()
[10:32:52.176]             {
[10:32:52.176]                 {
[10:32:52.176]                   {
[10:32:52.176]                     {
[10:32:52.176]                       base::local({
[10:32:52.176]                         has_future <- base::requireNamespace("future", 
[10:32:52.176]                           quietly = TRUE)
[10:32:52.176]                         if (has_future) {
[10:32:52.176]                           ns <- base::getNamespace("future")
[10:32:52.176]                           version <- ns[[".package"]][["version"]]
[10:32:52.176]                           if (is.null(version)) 
[10:32:52.176]                             version <- utils::packageVersion("future")
[10:32:52.176]                         }
[10:32:52.176]                         else {
[10:32:52.176]                           version <- NULL
[10:32:52.176]                         }
[10:32:52.176]                         if (!has_future || version < "1.8.0") {
[10:32:52.176]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.176]                             "", base::R.version$version.string), 
[10:32:52.176]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.176]                               "release", "version")], collapse = " "), 
[10:32:52.176]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.176]                             info)
[10:32:52.176]                           info <- base::paste(info, collapse = "; ")
[10:32:52.176]                           if (!has_future) {
[10:32:52.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.176]                               info)
[10:32:52.176]                           }
[10:32:52.176]                           else {
[10:32:52.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.176]                               info, version)
[10:32:52.176]                           }
[10:32:52.176]                           base::stop(msg)
[10:32:52.176]                         }
[10:32:52.176]                       })
[10:32:52.176]                     }
[10:32:52.176]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.176]                     base::options(mc.cores = 1L)
[10:32:52.176]                   }
[10:32:52.176]                   ...future.strategy.old <- future::plan("list")
[10:32:52.176]                   options(future.plan = NULL)
[10:32:52.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.176]                 }
[10:32:52.176]                 ...future.workdir <- getwd()
[10:32:52.176]             }
[10:32:52.176]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.176]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.176]         }
[10:32:52.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.176]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.176]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.176]             base::names(...future.oldOptions))
[10:32:52.176]     }
[10:32:52.176]     if (FALSE) {
[10:32:52.176]     }
[10:32:52.176]     else {
[10:32:52.176]         if (TRUE) {
[10:32:52.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.176]                 open = "w")
[10:32:52.176]         }
[10:32:52.176]         else {
[10:32:52.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.176]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.176]         }
[10:32:52.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.176]             base::sink(type = "output", split = FALSE)
[10:32:52.176]             base::close(...future.stdout)
[10:32:52.176]         }, add = TRUE)
[10:32:52.176]     }
[10:32:52.176]     ...future.frame <- base::sys.nframe()
[10:32:52.176]     ...future.conditions <- base::list()
[10:32:52.176]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.176]     if (FALSE) {
[10:32:52.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.176]     }
[10:32:52.176]     ...future.result <- base::tryCatch({
[10:32:52.176]         base::withCallingHandlers({
[10:32:52.176]             ...future.value <- base::withVisible(base::local({
[10:32:52.176]                 withCallingHandlers({
[10:32:52.176]                   2
[10:32:52.176]                 }, immediateCondition = function(cond) {
[10:32:52.176]                   save_rds <- function (object, pathname, ...) 
[10:32:52.176]                   {
[10:32:52.176]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.176]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.176]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.176]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.176]                         fi_tmp[["mtime"]])
[10:32:52.176]                     }
[10:32:52.176]                     tryCatch({
[10:32:52.176]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.176]                     }, error = function(ex) {
[10:32:52.176]                       msg <- conditionMessage(ex)
[10:32:52.176]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.176]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.176]                         fi_tmp[["mtime"]], msg)
[10:32:52.176]                       ex$message <- msg
[10:32:52.176]                       stop(ex)
[10:32:52.176]                     })
[10:32:52.176]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.176]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.176]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.176]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.176]                       fi <- file.info(pathname)
[10:32:52.176]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.176]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.176]                         fi[["size"]], fi[["mtime"]])
[10:32:52.176]                       stop(msg)
[10:32:52.176]                     }
[10:32:52.176]                     invisible(pathname)
[10:32:52.176]                   }
[10:32:52.176]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.176]                     rootPath = tempdir()) 
[10:32:52.176]                   {
[10:32:52.176]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.176]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.176]                       tmpdir = path, fileext = ".rds")
[10:32:52.176]                     save_rds(obj, file)
[10:32:52.176]                   }
[10:32:52.176]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.176]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.176]                   {
[10:32:52.176]                     inherits <- base::inherits
[10:32:52.176]                     invokeRestart <- base::invokeRestart
[10:32:52.176]                     is.null <- base::is.null
[10:32:52.176]                     muffled <- FALSE
[10:32:52.176]                     if (inherits(cond, "message")) {
[10:32:52.176]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.176]                       if (muffled) 
[10:32:52.176]                         invokeRestart("muffleMessage")
[10:32:52.176]                     }
[10:32:52.176]                     else if (inherits(cond, "warning")) {
[10:32:52.176]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.176]                       if (muffled) 
[10:32:52.176]                         invokeRestart("muffleWarning")
[10:32:52.176]                     }
[10:32:52.176]                     else if (inherits(cond, "condition")) {
[10:32:52.176]                       if (!is.null(pattern)) {
[10:32:52.176]                         computeRestarts <- base::computeRestarts
[10:32:52.176]                         grepl <- base::grepl
[10:32:52.176]                         restarts <- computeRestarts(cond)
[10:32:52.176]                         for (restart in restarts) {
[10:32:52.176]                           name <- restart$name
[10:32:52.176]                           if (is.null(name)) 
[10:32:52.176]                             next
[10:32:52.176]                           if (!grepl(pattern, name)) 
[10:32:52.176]                             next
[10:32:52.176]                           invokeRestart(restart)
[10:32:52.176]                           muffled <- TRUE
[10:32:52.176]                           break
[10:32:52.176]                         }
[10:32:52.176]                       }
[10:32:52.176]                     }
[10:32:52.176]                     invisible(muffled)
[10:32:52.176]                   }
[10:32:52.176]                   muffleCondition(cond)
[10:32:52.176]                 })
[10:32:52.176]             }))
[10:32:52.176]             future::FutureResult(value = ...future.value$value, 
[10:32:52.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.176]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.176]                     ...future.globalenv.names))
[10:32:52.176]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.176]         }, condition = base::local({
[10:32:52.176]             c <- base::c
[10:32:52.176]             inherits <- base::inherits
[10:32:52.176]             invokeRestart <- base::invokeRestart
[10:32:52.176]             length <- base::length
[10:32:52.176]             list <- base::list
[10:32:52.176]             seq.int <- base::seq.int
[10:32:52.176]             signalCondition <- base::signalCondition
[10:32:52.176]             sys.calls <- base::sys.calls
[10:32:52.176]             `[[` <- base::`[[`
[10:32:52.176]             `+` <- base::`+`
[10:32:52.176]             `<<-` <- base::`<<-`
[10:32:52.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.176]                   3L)]
[10:32:52.176]             }
[10:32:52.176]             function(cond) {
[10:32:52.176]                 is_error <- inherits(cond, "error")
[10:32:52.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.176]                   NULL)
[10:32:52.176]                 if (is_error) {
[10:32:52.176]                   sessionInformation <- function() {
[10:32:52.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.176]                       search = base::search(), system = base::Sys.info())
[10:32:52.176]                   }
[10:32:52.176]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.176]                     cond$call), session = sessionInformation(), 
[10:32:52.176]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.176]                   signalCondition(cond)
[10:32:52.176]                 }
[10:32:52.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.176]                 "immediateCondition"))) {
[10:32:52.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.176]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.176]                   if (TRUE && !signal) {
[10:32:52.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.176]                     {
[10:32:52.176]                       inherits <- base::inherits
[10:32:52.176]                       invokeRestart <- base::invokeRestart
[10:32:52.176]                       is.null <- base::is.null
[10:32:52.176]                       muffled <- FALSE
[10:32:52.176]                       if (inherits(cond, "message")) {
[10:32:52.176]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.176]                         if (muffled) 
[10:32:52.176]                           invokeRestart("muffleMessage")
[10:32:52.176]                       }
[10:32:52.176]                       else if (inherits(cond, "warning")) {
[10:32:52.176]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.176]                         if (muffled) 
[10:32:52.176]                           invokeRestart("muffleWarning")
[10:32:52.176]                       }
[10:32:52.176]                       else if (inherits(cond, "condition")) {
[10:32:52.176]                         if (!is.null(pattern)) {
[10:32:52.176]                           computeRestarts <- base::computeRestarts
[10:32:52.176]                           grepl <- base::grepl
[10:32:52.176]                           restarts <- computeRestarts(cond)
[10:32:52.176]                           for (restart in restarts) {
[10:32:52.176]                             name <- restart$name
[10:32:52.176]                             if (is.null(name)) 
[10:32:52.176]                               next
[10:32:52.176]                             if (!grepl(pattern, name)) 
[10:32:52.176]                               next
[10:32:52.176]                             invokeRestart(restart)
[10:32:52.176]                             muffled <- TRUE
[10:32:52.176]                             break
[10:32:52.176]                           }
[10:32:52.176]                         }
[10:32:52.176]                       }
[10:32:52.176]                       invisible(muffled)
[10:32:52.176]                     }
[10:32:52.176]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.176]                   }
[10:32:52.176]                 }
[10:32:52.176]                 else {
[10:32:52.176]                   if (TRUE) {
[10:32:52.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.176]                     {
[10:32:52.176]                       inherits <- base::inherits
[10:32:52.176]                       invokeRestart <- base::invokeRestart
[10:32:52.176]                       is.null <- base::is.null
[10:32:52.176]                       muffled <- FALSE
[10:32:52.176]                       if (inherits(cond, "message")) {
[10:32:52.176]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.176]                         if (muffled) 
[10:32:52.176]                           invokeRestart("muffleMessage")
[10:32:52.176]                       }
[10:32:52.176]                       else if (inherits(cond, "warning")) {
[10:32:52.176]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.176]                         if (muffled) 
[10:32:52.176]                           invokeRestart("muffleWarning")
[10:32:52.176]                       }
[10:32:52.176]                       else if (inherits(cond, "condition")) {
[10:32:52.176]                         if (!is.null(pattern)) {
[10:32:52.176]                           computeRestarts <- base::computeRestarts
[10:32:52.176]                           grepl <- base::grepl
[10:32:52.176]                           restarts <- computeRestarts(cond)
[10:32:52.176]                           for (restart in restarts) {
[10:32:52.176]                             name <- restart$name
[10:32:52.176]                             if (is.null(name)) 
[10:32:52.176]                               next
[10:32:52.176]                             if (!grepl(pattern, name)) 
[10:32:52.176]                               next
[10:32:52.176]                             invokeRestart(restart)
[10:32:52.176]                             muffled <- TRUE
[10:32:52.176]                             break
[10:32:52.176]                           }
[10:32:52.176]                         }
[10:32:52.176]                       }
[10:32:52.176]                       invisible(muffled)
[10:32:52.176]                     }
[10:32:52.176]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.176]                   }
[10:32:52.176]                 }
[10:32:52.176]             }
[10:32:52.176]         }))
[10:32:52.176]     }, error = function(ex) {
[10:32:52.176]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.176]                 ...future.rng), started = ...future.startTime, 
[10:32:52.176]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.176]             version = "1.8"), class = "FutureResult")
[10:32:52.176]     }, finally = {
[10:32:52.176]         if (!identical(...future.workdir, getwd())) 
[10:32:52.176]             setwd(...future.workdir)
[10:32:52.176]         {
[10:32:52.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.176]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.176]             }
[10:32:52.176]             base::options(...future.oldOptions)
[10:32:52.176]             if (.Platform$OS.type == "windows") {
[10:32:52.176]                 old_names <- names(...future.oldEnvVars)
[10:32:52.176]                 envs <- base::Sys.getenv()
[10:32:52.176]                 names <- names(envs)
[10:32:52.176]                 common <- intersect(names, old_names)
[10:32:52.176]                 added <- setdiff(names, old_names)
[10:32:52.176]                 removed <- setdiff(old_names, names)
[10:32:52.176]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.176]                   envs[common]]
[10:32:52.176]                 NAMES <- toupper(changed)
[10:32:52.176]                 args <- list()
[10:32:52.176]                 for (kk in seq_along(NAMES)) {
[10:32:52.176]                   name <- changed[[kk]]
[10:32:52.176]                   NAME <- NAMES[[kk]]
[10:32:52.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.176]                     next
[10:32:52.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.176]                 }
[10:32:52.176]                 NAMES <- toupper(added)
[10:32:52.176]                 for (kk in seq_along(NAMES)) {
[10:32:52.176]                   name <- added[[kk]]
[10:32:52.176]                   NAME <- NAMES[[kk]]
[10:32:52.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.176]                     next
[10:32:52.176]                   args[[name]] <- ""
[10:32:52.176]                 }
[10:32:52.176]                 NAMES <- toupper(removed)
[10:32:52.176]                 for (kk in seq_along(NAMES)) {
[10:32:52.176]                   name <- removed[[kk]]
[10:32:52.176]                   NAME <- NAMES[[kk]]
[10:32:52.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.176]                     next
[10:32:52.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.176]                 }
[10:32:52.176]                 if (length(args) > 0) 
[10:32:52.176]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.176]             }
[10:32:52.176]             else {
[10:32:52.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.176]             }
[10:32:52.176]             {
[10:32:52.176]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.176]                   0L) {
[10:32:52.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.176]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.176]                   base::options(opts)
[10:32:52.176]                 }
[10:32:52.176]                 {
[10:32:52.176]                   {
[10:32:52.176]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.176]                     NULL
[10:32:52.176]                   }
[10:32:52.176]                   options(future.plan = NULL)
[10:32:52.176]                   if (is.na(NA_character_)) 
[10:32:52.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.176]                     .init = FALSE)
[10:32:52.176]                 }
[10:32:52.176]             }
[10:32:52.176]         }
[10:32:52.176]     })
[10:32:52.176]     if (TRUE) {
[10:32:52.176]         base::sink(type = "output", split = FALSE)
[10:32:52.176]         if (TRUE) {
[10:32:52.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.176]         }
[10:32:52.176]         else {
[10:32:52.176]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.176]         }
[10:32:52.176]         base::close(...future.stdout)
[10:32:52.176]         ...future.stdout <- NULL
[10:32:52.176]     }
[10:32:52.176]     ...future.result$conditions <- ...future.conditions
[10:32:52.176]     ...future.result$finished <- base::Sys.time()
[10:32:52.176]     ...future.result
[10:32:52.176] }
[10:32:52.178] requestCore(): workers = 2
[10:32:52.180] MulticoreFuture started
[10:32:52.180] - Launch lazy future ... done
[10:32:52.181] run() for ‘MulticoreFuture’ ... done
[10:32:52.181] getGlobalsAndPackages() ...
[10:32:52.181] Searching for globals...
[10:32:52.181] plan(): Setting new future strategy stack:
[10:32:52.181] List of future strategies:
[10:32:52.181] 1. sequential:
[10:32:52.181]    - args: function (..., envir = parent.frame())
[10:32:52.181]    - tweaked: FALSE
[10:32:52.181]    - call: NULL
[10:32:52.182] 
[10:32:52.182] Searching for globals ... DONE
[10:32:52.182] plan(): nbrOfWorkers() = 1
[10:32:52.182] - globals: [0] <none>
[10:32:52.183] getGlobalsAndPackages() ... DONE
[10:32:52.183] run() for ‘Future’ ...
[10:32:52.183] - state: ‘created’
[10:32:52.184] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.184] plan(): Setting new future strategy stack:
[10:32:52.184] List of future strategies:
[10:32:52.184] 1. multicore:
[10:32:52.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.184]    - tweaked: FALSE
[10:32:52.184]    - call: plan(strategy)
[10:32:52.189] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.189] plan(): nbrOfWorkers() = 2
[10:32:52.189]   - Field: ‘label’
[10:32:52.189]   - Field: ‘local’
[10:32:52.190]   - Field: ‘owner’
[10:32:52.190]   - Field: ‘envir’
[10:32:52.190]   - Field: ‘workers’
[10:32:52.190]   - Field: ‘packages’
[10:32:52.190]   - Field: ‘gc’
[10:32:52.190]   - Field: ‘job’
[10:32:52.191]   - Field: ‘conditions’
[10:32:52.191]   - Field: ‘expr’
[10:32:52.191]   - Field: ‘uuid’
[10:32:52.191]   - Field: ‘seed’
[10:32:52.191]   - Field: ‘version’
[10:32:52.192]   - Field: ‘result’
[10:32:52.192]   - Field: ‘asynchronous’
[10:32:52.192]   - Field: ‘calls’
[10:32:52.192]   - Field: ‘globals’
[10:32:52.192]   - Field: ‘stdout’
[10:32:52.192]   - Field: ‘earlySignal’
[10:32:52.193]   - Field: ‘lazy’
[10:32:52.193]   - Field: ‘state’
[10:32:52.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.193] - Launch lazy future ...
[10:32:52.194] Packages needed by the future expression (n = 0): <none>
[10:32:52.194] Packages needed by future strategies (n = 0): <none>
[10:32:52.195] {
[10:32:52.195]     {
[10:32:52.195]         {
[10:32:52.195]             ...future.startTime <- base::Sys.time()
[10:32:52.195]             {
[10:32:52.195]                 {
[10:32:52.195]                   {
[10:32:52.195]                     {
[10:32:52.195]                       base::local({
[10:32:52.195]                         has_future <- base::requireNamespace("future", 
[10:32:52.195]                           quietly = TRUE)
[10:32:52.195]                         if (has_future) {
[10:32:52.195]                           ns <- base::getNamespace("future")
[10:32:52.195]                           version <- ns[[".package"]][["version"]]
[10:32:52.195]                           if (is.null(version)) 
[10:32:52.195]                             version <- utils::packageVersion("future")
[10:32:52.195]                         }
[10:32:52.195]                         else {
[10:32:52.195]                           version <- NULL
[10:32:52.195]                         }
[10:32:52.195]                         if (!has_future || version < "1.8.0") {
[10:32:52.195]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.195]                             "", base::R.version$version.string), 
[10:32:52.195]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.195]                               "release", "version")], collapse = " "), 
[10:32:52.195]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.195]                             info)
[10:32:52.195]                           info <- base::paste(info, collapse = "; ")
[10:32:52.195]                           if (!has_future) {
[10:32:52.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.195]                               info)
[10:32:52.195]                           }
[10:32:52.195]                           else {
[10:32:52.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.195]                               info, version)
[10:32:52.195]                           }
[10:32:52.195]                           base::stop(msg)
[10:32:52.195]                         }
[10:32:52.195]                       })
[10:32:52.195]                     }
[10:32:52.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.195]                     base::options(mc.cores = 1L)
[10:32:52.195]                   }
[10:32:52.195]                   ...future.strategy.old <- future::plan("list")
[10:32:52.195]                   options(future.plan = NULL)
[10:32:52.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.195]                 }
[10:32:52.195]                 ...future.workdir <- getwd()
[10:32:52.195]             }
[10:32:52.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.195]         }
[10:32:52.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.195]             base::names(...future.oldOptions))
[10:32:52.195]     }
[10:32:52.195]     if (FALSE) {
[10:32:52.195]     }
[10:32:52.195]     else {
[10:32:52.195]         if (TRUE) {
[10:32:52.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.195]                 open = "w")
[10:32:52.195]         }
[10:32:52.195]         else {
[10:32:52.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.195]         }
[10:32:52.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.195]             base::sink(type = "output", split = FALSE)
[10:32:52.195]             base::close(...future.stdout)
[10:32:52.195]         }, add = TRUE)
[10:32:52.195]     }
[10:32:52.195]     ...future.frame <- base::sys.nframe()
[10:32:52.195]     ...future.conditions <- base::list()
[10:32:52.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.195]     if (FALSE) {
[10:32:52.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.195]     }
[10:32:52.195]     ...future.result <- base::tryCatch({
[10:32:52.195]         base::withCallingHandlers({
[10:32:52.195]             ...future.value <- base::withVisible(base::local({
[10:32:52.195]                 withCallingHandlers({
[10:32:52.195]                   NULL
[10:32:52.195]                 }, immediateCondition = function(cond) {
[10:32:52.195]                   save_rds <- function (object, pathname, ...) 
[10:32:52.195]                   {
[10:32:52.195]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.195]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.195]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.195]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.195]                         fi_tmp[["mtime"]])
[10:32:52.195]                     }
[10:32:52.195]                     tryCatch({
[10:32:52.195]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.195]                     }, error = function(ex) {
[10:32:52.195]                       msg <- conditionMessage(ex)
[10:32:52.195]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.195]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.195]                         fi_tmp[["mtime"]], msg)
[10:32:52.195]                       ex$message <- msg
[10:32:52.195]                       stop(ex)
[10:32:52.195]                     })
[10:32:52.195]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.195]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.195]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.195]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.195]                       fi <- file.info(pathname)
[10:32:52.195]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.195]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.195]                         fi[["size"]], fi[["mtime"]])
[10:32:52.195]                       stop(msg)
[10:32:52.195]                     }
[10:32:52.195]                     invisible(pathname)
[10:32:52.195]                   }
[10:32:52.195]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.195]                     rootPath = tempdir()) 
[10:32:52.195]                   {
[10:32:52.195]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.195]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.195]                       tmpdir = path, fileext = ".rds")
[10:32:52.195]                     save_rds(obj, file)
[10:32:52.195]                   }
[10:32:52.195]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.195]                   {
[10:32:52.195]                     inherits <- base::inherits
[10:32:52.195]                     invokeRestart <- base::invokeRestart
[10:32:52.195]                     is.null <- base::is.null
[10:32:52.195]                     muffled <- FALSE
[10:32:52.195]                     if (inherits(cond, "message")) {
[10:32:52.195]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.195]                       if (muffled) 
[10:32:52.195]                         invokeRestart("muffleMessage")
[10:32:52.195]                     }
[10:32:52.195]                     else if (inherits(cond, "warning")) {
[10:32:52.195]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.195]                       if (muffled) 
[10:32:52.195]                         invokeRestart("muffleWarning")
[10:32:52.195]                     }
[10:32:52.195]                     else if (inherits(cond, "condition")) {
[10:32:52.195]                       if (!is.null(pattern)) {
[10:32:52.195]                         computeRestarts <- base::computeRestarts
[10:32:52.195]                         grepl <- base::grepl
[10:32:52.195]                         restarts <- computeRestarts(cond)
[10:32:52.195]                         for (restart in restarts) {
[10:32:52.195]                           name <- restart$name
[10:32:52.195]                           if (is.null(name)) 
[10:32:52.195]                             next
[10:32:52.195]                           if (!grepl(pattern, name)) 
[10:32:52.195]                             next
[10:32:52.195]                           invokeRestart(restart)
[10:32:52.195]                           muffled <- TRUE
[10:32:52.195]                           break
[10:32:52.195]                         }
[10:32:52.195]                       }
[10:32:52.195]                     }
[10:32:52.195]                     invisible(muffled)
[10:32:52.195]                   }
[10:32:52.195]                   muffleCondition(cond)
[10:32:52.195]                 })
[10:32:52.195]             }))
[10:32:52.195]             future::FutureResult(value = ...future.value$value, 
[10:32:52.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.195]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.195]                     ...future.globalenv.names))
[10:32:52.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.195]         }, condition = base::local({
[10:32:52.195]             c <- base::c
[10:32:52.195]             inherits <- base::inherits
[10:32:52.195]             invokeRestart <- base::invokeRestart
[10:32:52.195]             length <- base::length
[10:32:52.195]             list <- base::list
[10:32:52.195]             seq.int <- base::seq.int
[10:32:52.195]             signalCondition <- base::signalCondition
[10:32:52.195]             sys.calls <- base::sys.calls
[10:32:52.195]             `[[` <- base::`[[`
[10:32:52.195]             `+` <- base::`+`
[10:32:52.195]             `<<-` <- base::`<<-`
[10:32:52.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.195]                   3L)]
[10:32:52.195]             }
[10:32:52.195]             function(cond) {
[10:32:52.195]                 is_error <- inherits(cond, "error")
[10:32:52.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.195]                   NULL)
[10:32:52.195]                 if (is_error) {
[10:32:52.195]                   sessionInformation <- function() {
[10:32:52.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.195]                       search = base::search(), system = base::Sys.info())
[10:32:52.195]                   }
[10:32:52.195]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.195]                     cond$call), session = sessionInformation(), 
[10:32:52.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.195]                   signalCondition(cond)
[10:32:52.195]                 }
[10:32:52.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.195]                 "immediateCondition"))) {
[10:32:52.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.195]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.195]                   if (TRUE && !signal) {
[10:32:52.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.195]                     {
[10:32:52.195]                       inherits <- base::inherits
[10:32:52.195]                       invokeRestart <- base::invokeRestart
[10:32:52.195]                       is.null <- base::is.null
[10:32:52.195]                       muffled <- FALSE
[10:32:52.195]                       if (inherits(cond, "message")) {
[10:32:52.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.195]                         if (muffled) 
[10:32:52.195]                           invokeRestart("muffleMessage")
[10:32:52.195]                       }
[10:32:52.195]                       else if (inherits(cond, "warning")) {
[10:32:52.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.195]                         if (muffled) 
[10:32:52.195]                           invokeRestart("muffleWarning")
[10:32:52.195]                       }
[10:32:52.195]                       else if (inherits(cond, "condition")) {
[10:32:52.195]                         if (!is.null(pattern)) {
[10:32:52.195]                           computeRestarts <- base::computeRestarts
[10:32:52.195]                           grepl <- base::grepl
[10:32:52.195]                           restarts <- computeRestarts(cond)
[10:32:52.195]                           for (restart in restarts) {
[10:32:52.195]                             name <- restart$name
[10:32:52.195]                             if (is.null(name)) 
[10:32:52.195]                               next
[10:32:52.195]                             if (!grepl(pattern, name)) 
[10:32:52.195]                               next
[10:32:52.195]                             invokeRestart(restart)
[10:32:52.195]                             muffled <- TRUE
[10:32:52.195]                             break
[10:32:52.195]                           }
[10:32:52.195]                         }
[10:32:52.195]                       }
[10:32:52.195]                       invisible(muffled)
[10:32:52.195]                     }
[10:32:52.195]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.195]                   }
[10:32:52.195]                 }
[10:32:52.195]                 else {
[10:32:52.195]                   if (TRUE) {
[10:32:52.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.195]                     {
[10:32:52.195]                       inherits <- base::inherits
[10:32:52.195]                       invokeRestart <- base::invokeRestart
[10:32:52.195]                       is.null <- base::is.null
[10:32:52.195]                       muffled <- FALSE
[10:32:52.195]                       if (inherits(cond, "message")) {
[10:32:52.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.195]                         if (muffled) 
[10:32:52.195]                           invokeRestart("muffleMessage")
[10:32:52.195]                       }
[10:32:52.195]                       else if (inherits(cond, "warning")) {
[10:32:52.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.195]                         if (muffled) 
[10:32:52.195]                           invokeRestart("muffleWarning")
[10:32:52.195]                       }
[10:32:52.195]                       else if (inherits(cond, "condition")) {
[10:32:52.195]                         if (!is.null(pattern)) {
[10:32:52.195]                           computeRestarts <- base::computeRestarts
[10:32:52.195]                           grepl <- base::grepl
[10:32:52.195]                           restarts <- computeRestarts(cond)
[10:32:52.195]                           for (restart in restarts) {
[10:32:52.195]                             name <- restart$name
[10:32:52.195]                             if (is.null(name)) 
[10:32:52.195]                               next
[10:32:52.195]                             if (!grepl(pattern, name)) 
[10:32:52.195]                               next
[10:32:52.195]                             invokeRestart(restart)
[10:32:52.195]                             muffled <- TRUE
[10:32:52.195]                             break
[10:32:52.195]                           }
[10:32:52.195]                         }
[10:32:52.195]                       }
[10:32:52.195]                       invisible(muffled)
[10:32:52.195]                     }
[10:32:52.195]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.195]                   }
[10:32:52.195]                 }
[10:32:52.195]             }
[10:32:52.195]         }))
[10:32:52.195]     }, error = function(ex) {
[10:32:52.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.195]                 ...future.rng), started = ...future.startTime, 
[10:32:52.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.195]             version = "1.8"), class = "FutureResult")
[10:32:52.195]     }, finally = {
[10:32:52.195]         if (!identical(...future.workdir, getwd())) 
[10:32:52.195]             setwd(...future.workdir)
[10:32:52.195]         {
[10:32:52.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.195]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.195]             }
[10:32:52.195]             base::options(...future.oldOptions)
[10:32:52.195]             if (.Platform$OS.type == "windows") {
[10:32:52.195]                 old_names <- names(...future.oldEnvVars)
[10:32:52.195]                 envs <- base::Sys.getenv()
[10:32:52.195]                 names <- names(envs)
[10:32:52.195]                 common <- intersect(names, old_names)
[10:32:52.195]                 added <- setdiff(names, old_names)
[10:32:52.195]                 removed <- setdiff(old_names, names)
[10:32:52.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.195]                   envs[common]]
[10:32:52.195]                 NAMES <- toupper(changed)
[10:32:52.195]                 args <- list()
[10:32:52.195]                 for (kk in seq_along(NAMES)) {
[10:32:52.195]                   name <- changed[[kk]]
[10:32:52.195]                   NAME <- NAMES[[kk]]
[10:32:52.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.195]                     next
[10:32:52.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.195]                 }
[10:32:52.195]                 NAMES <- toupper(added)
[10:32:52.195]                 for (kk in seq_along(NAMES)) {
[10:32:52.195]                   name <- added[[kk]]
[10:32:52.195]                   NAME <- NAMES[[kk]]
[10:32:52.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.195]                     next
[10:32:52.195]                   args[[name]] <- ""
[10:32:52.195]                 }
[10:32:52.195]                 NAMES <- toupper(removed)
[10:32:52.195]                 for (kk in seq_along(NAMES)) {
[10:32:52.195]                   name <- removed[[kk]]
[10:32:52.195]                   NAME <- NAMES[[kk]]
[10:32:52.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.195]                     next
[10:32:52.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.195]                 }
[10:32:52.195]                 if (length(args) > 0) 
[10:32:52.195]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.195]             }
[10:32:52.195]             else {
[10:32:52.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.195]             }
[10:32:52.195]             {
[10:32:52.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.195]                   0L) {
[10:32:52.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.195]                   base::options(opts)
[10:32:52.195]                 }
[10:32:52.195]                 {
[10:32:52.195]                   {
[10:32:52.195]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.195]                     NULL
[10:32:52.195]                   }
[10:32:52.195]                   options(future.plan = NULL)
[10:32:52.195]                   if (is.na(NA_character_)) 
[10:32:52.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.195]                     .init = FALSE)
[10:32:52.195]                 }
[10:32:52.195]             }
[10:32:52.195]         }
[10:32:52.195]     })
[10:32:52.195]     if (TRUE) {
[10:32:52.195]         base::sink(type = "output", split = FALSE)
[10:32:52.195]         if (TRUE) {
[10:32:52.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.195]         }
[10:32:52.195]         else {
[10:32:52.195]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.195]         }
[10:32:52.195]         base::close(...future.stdout)
[10:32:52.195]         ...future.stdout <- NULL
[10:32:52.195]     }
[10:32:52.195]     ...future.result$conditions <- ...future.conditions
[10:32:52.195]     ...future.result$finished <- base::Sys.time()
[10:32:52.195]     ...future.result
[10:32:52.195] }
[10:32:52.198] requestCore(): workers = 2
[10:32:52.201] MulticoreFuture started
[10:32:52.201] - Launch lazy future ... done
[10:32:52.201] run() for ‘MulticoreFuture’ ... done
[10:32:52.202] plan(): Setting new future strategy stack:
[10:32:52.202] getGlobalsAndPackages() ...
[10:32:52.203] Searching for globals...
[10:32:52.202] List of future strategies:
[10:32:52.202] 1. sequential:
[10:32:52.202]    - args: function (..., envir = parent.frame())
[10:32:52.202]    - tweaked: FALSE
[10:32:52.202]    - call: NULL
[10:32:52.204] plan(): nbrOfWorkers() = 1
[10:32:52.205] - globals found: [1] ‘{’
[10:32:52.205] Searching for globals ... DONE
[10:32:52.205] Resolving globals: FALSE
[10:32:52.206] 
[10:32:52.206] 
[10:32:52.206] plan(): Setting new future strategy stack:
[10:32:52.206] getGlobalsAndPackages() ... DONE
[10:32:52.206] List of future strategies:
[10:32:52.206] 1. multicore:
[10:32:52.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.206]    - tweaked: FALSE
[10:32:52.206]    - call: plan(strategy)
[10:32:52.207] run() for ‘Future’ ...
[10:32:52.207] - state: ‘created’
[10:32:52.208] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.212] plan(): nbrOfWorkers() = 2
[10:32:52.213] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.213]   - Field: ‘label’
[10:32:52.213]   - Field: ‘local’
[10:32:52.214]   - Field: ‘owner’
[10:32:52.214]   - Field: ‘envir’
[10:32:52.214]   - Field: ‘workers’
[10:32:52.214]   - Field: ‘packages’
[10:32:52.214]   - Field: ‘gc’
[10:32:52.214]   - Field: ‘job’
[10:32:52.214]   - Field: ‘conditions’
[10:32:52.215]   - Field: ‘expr’
[10:32:52.215]   - Field: ‘uuid’
[10:32:52.215]   - Field: ‘seed’
[10:32:52.215]   - Field: ‘version’
[10:32:52.215]   - Field: ‘result’
[10:32:52.215]   - Field: ‘asynchronous’
[10:32:52.215]   - Field: ‘calls’
[10:32:52.216]   - Field: ‘globals’
[10:32:52.216]   - Field: ‘stdout’
[10:32:52.216]   - Field: ‘earlySignal’
[10:32:52.216]   - Field: ‘lazy’
[10:32:52.216]   - Field: ‘state’
[10:32:52.216] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.216] - Launch lazy future ...
[10:32:52.217] Packages needed by the future expression (n = 0): <none>
[10:32:52.217] Packages needed by future strategies (n = 0): <none>
[10:32:52.218] {
[10:32:52.218]     {
[10:32:52.218]         {
[10:32:52.218]             ...future.startTime <- base::Sys.time()
[10:32:52.218]             {
[10:32:52.218]                 {
[10:32:52.218]                   {
[10:32:52.218]                     {
[10:32:52.218]                       base::local({
[10:32:52.218]                         has_future <- base::requireNamespace("future", 
[10:32:52.218]                           quietly = TRUE)
[10:32:52.218]                         if (has_future) {
[10:32:52.218]                           ns <- base::getNamespace("future")
[10:32:52.218]                           version <- ns[[".package"]][["version"]]
[10:32:52.218]                           if (is.null(version)) 
[10:32:52.218]                             version <- utils::packageVersion("future")
[10:32:52.218]                         }
[10:32:52.218]                         else {
[10:32:52.218]                           version <- NULL
[10:32:52.218]                         }
[10:32:52.218]                         if (!has_future || version < "1.8.0") {
[10:32:52.218]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.218]                             "", base::R.version$version.string), 
[10:32:52.218]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.218]                               "release", "version")], collapse = " "), 
[10:32:52.218]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.218]                             info)
[10:32:52.218]                           info <- base::paste(info, collapse = "; ")
[10:32:52.218]                           if (!has_future) {
[10:32:52.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.218]                               info)
[10:32:52.218]                           }
[10:32:52.218]                           else {
[10:32:52.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.218]                               info, version)
[10:32:52.218]                           }
[10:32:52.218]                           base::stop(msg)
[10:32:52.218]                         }
[10:32:52.218]                       })
[10:32:52.218]                     }
[10:32:52.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.218]                     base::options(mc.cores = 1L)
[10:32:52.218]                   }
[10:32:52.218]                   ...future.strategy.old <- future::plan("list")
[10:32:52.218]                   options(future.plan = NULL)
[10:32:52.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.218]                 }
[10:32:52.218]                 ...future.workdir <- getwd()
[10:32:52.218]             }
[10:32:52.218]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.218]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.218]         }
[10:32:52.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.218]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.218]             base::names(...future.oldOptions))
[10:32:52.218]     }
[10:32:52.218]     if (FALSE) {
[10:32:52.218]     }
[10:32:52.218]     else {
[10:32:52.218]         if (TRUE) {
[10:32:52.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.218]                 open = "w")
[10:32:52.218]         }
[10:32:52.218]         else {
[10:32:52.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.218]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.218]         }
[10:32:52.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.218]             base::sink(type = "output", split = FALSE)
[10:32:52.218]             base::close(...future.stdout)
[10:32:52.218]         }, add = TRUE)
[10:32:52.218]     }
[10:32:52.218]     ...future.frame <- base::sys.nframe()
[10:32:52.218]     ...future.conditions <- base::list()
[10:32:52.218]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.218]     if (FALSE) {
[10:32:52.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.218]     }
[10:32:52.218]     ...future.result <- base::tryCatch({
[10:32:52.218]         base::withCallingHandlers({
[10:32:52.218]             ...future.value <- base::withVisible(base::local({
[10:32:52.218]                 withCallingHandlers({
[10:32:52.218]                   {
[10:32:52.218]                     4
[10:32:52.218]                   }
[10:32:52.218]                 }, immediateCondition = function(cond) {
[10:32:52.218]                   save_rds <- function (object, pathname, ...) 
[10:32:52.218]                   {
[10:32:52.218]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.218]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.218]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.218]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.218]                         fi_tmp[["mtime"]])
[10:32:52.218]                     }
[10:32:52.218]                     tryCatch({
[10:32:52.218]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.218]                     }, error = function(ex) {
[10:32:52.218]                       msg <- conditionMessage(ex)
[10:32:52.218]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.218]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.218]                         fi_tmp[["mtime"]], msg)
[10:32:52.218]                       ex$message <- msg
[10:32:52.218]                       stop(ex)
[10:32:52.218]                     })
[10:32:52.218]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.218]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.218]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.218]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.218]                       fi <- file.info(pathname)
[10:32:52.218]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.218]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.218]                         fi[["size"]], fi[["mtime"]])
[10:32:52.218]                       stop(msg)
[10:32:52.218]                     }
[10:32:52.218]                     invisible(pathname)
[10:32:52.218]                   }
[10:32:52.218]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.218]                     rootPath = tempdir()) 
[10:32:52.218]                   {
[10:32:52.218]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.218]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.218]                       tmpdir = path, fileext = ".rds")
[10:32:52.218]                     save_rds(obj, file)
[10:32:52.218]                   }
[10:32:52.218]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.218]                   {
[10:32:52.218]                     inherits <- base::inherits
[10:32:52.218]                     invokeRestart <- base::invokeRestart
[10:32:52.218]                     is.null <- base::is.null
[10:32:52.218]                     muffled <- FALSE
[10:32:52.218]                     if (inherits(cond, "message")) {
[10:32:52.218]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.218]                       if (muffled) 
[10:32:52.218]                         invokeRestart("muffleMessage")
[10:32:52.218]                     }
[10:32:52.218]                     else if (inherits(cond, "warning")) {
[10:32:52.218]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.218]                       if (muffled) 
[10:32:52.218]                         invokeRestart("muffleWarning")
[10:32:52.218]                     }
[10:32:52.218]                     else if (inherits(cond, "condition")) {
[10:32:52.218]                       if (!is.null(pattern)) {
[10:32:52.218]                         computeRestarts <- base::computeRestarts
[10:32:52.218]                         grepl <- base::grepl
[10:32:52.218]                         restarts <- computeRestarts(cond)
[10:32:52.218]                         for (restart in restarts) {
[10:32:52.218]                           name <- restart$name
[10:32:52.218]                           if (is.null(name)) 
[10:32:52.218]                             next
[10:32:52.218]                           if (!grepl(pattern, name)) 
[10:32:52.218]                             next
[10:32:52.218]                           invokeRestart(restart)
[10:32:52.218]                           muffled <- TRUE
[10:32:52.218]                           break
[10:32:52.218]                         }
[10:32:52.218]                       }
[10:32:52.218]                     }
[10:32:52.218]                     invisible(muffled)
[10:32:52.218]                   }
[10:32:52.218]                   muffleCondition(cond)
[10:32:52.218]                 })
[10:32:52.218]             }))
[10:32:52.218]             future::FutureResult(value = ...future.value$value, 
[10:32:52.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.218]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.218]                     ...future.globalenv.names))
[10:32:52.218]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.218]         }, condition = base::local({
[10:32:52.218]             c <- base::c
[10:32:52.218]             inherits <- base::inherits
[10:32:52.218]             invokeRestart <- base::invokeRestart
[10:32:52.218]             length <- base::length
[10:32:52.218]             list <- base::list
[10:32:52.218]             seq.int <- base::seq.int
[10:32:52.218]             signalCondition <- base::signalCondition
[10:32:52.218]             sys.calls <- base::sys.calls
[10:32:52.218]             `[[` <- base::`[[`
[10:32:52.218]             `+` <- base::`+`
[10:32:52.218]             `<<-` <- base::`<<-`
[10:32:52.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.218]                   3L)]
[10:32:52.218]             }
[10:32:52.218]             function(cond) {
[10:32:52.218]                 is_error <- inherits(cond, "error")
[10:32:52.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.218]                   NULL)
[10:32:52.218]                 if (is_error) {
[10:32:52.218]                   sessionInformation <- function() {
[10:32:52.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.218]                       search = base::search(), system = base::Sys.info())
[10:32:52.218]                   }
[10:32:52.218]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.218]                     cond$call), session = sessionInformation(), 
[10:32:52.218]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.218]                   signalCondition(cond)
[10:32:52.218]                 }
[10:32:52.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.218]                 "immediateCondition"))) {
[10:32:52.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.218]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.218]                   if (TRUE && !signal) {
[10:32:52.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.218]                     {
[10:32:52.218]                       inherits <- base::inherits
[10:32:52.218]                       invokeRestart <- base::invokeRestart
[10:32:52.218]                       is.null <- base::is.null
[10:32:52.218]                       muffled <- FALSE
[10:32:52.218]                       if (inherits(cond, "message")) {
[10:32:52.218]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.218]                         if (muffled) 
[10:32:52.218]                           invokeRestart("muffleMessage")
[10:32:52.218]                       }
[10:32:52.218]                       else if (inherits(cond, "warning")) {
[10:32:52.218]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.218]                         if (muffled) 
[10:32:52.218]                           invokeRestart("muffleWarning")
[10:32:52.218]                       }
[10:32:52.218]                       else if (inherits(cond, "condition")) {
[10:32:52.218]                         if (!is.null(pattern)) {
[10:32:52.218]                           computeRestarts <- base::computeRestarts
[10:32:52.218]                           grepl <- base::grepl
[10:32:52.218]                           restarts <- computeRestarts(cond)
[10:32:52.218]                           for (restart in restarts) {
[10:32:52.218]                             name <- restart$name
[10:32:52.218]                             if (is.null(name)) 
[10:32:52.218]                               next
[10:32:52.218]                             if (!grepl(pattern, name)) 
[10:32:52.218]                               next
[10:32:52.218]                             invokeRestart(restart)
[10:32:52.218]                             muffled <- TRUE
[10:32:52.218]                             break
[10:32:52.218]                           }
[10:32:52.218]                         }
[10:32:52.218]                       }
[10:32:52.218]                       invisible(muffled)
[10:32:52.218]                     }
[10:32:52.218]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.218]                   }
[10:32:52.218]                 }
[10:32:52.218]                 else {
[10:32:52.218]                   if (TRUE) {
[10:32:52.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.218]                     {
[10:32:52.218]                       inherits <- base::inherits
[10:32:52.218]                       invokeRestart <- base::invokeRestart
[10:32:52.218]                       is.null <- base::is.null
[10:32:52.218]                       muffled <- FALSE
[10:32:52.218]                       if (inherits(cond, "message")) {
[10:32:52.218]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.218]                         if (muffled) 
[10:32:52.218]                           invokeRestart("muffleMessage")
[10:32:52.218]                       }
[10:32:52.218]                       else if (inherits(cond, "warning")) {
[10:32:52.218]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.218]                         if (muffled) 
[10:32:52.218]                           invokeRestart("muffleWarning")
[10:32:52.218]                       }
[10:32:52.218]                       else if (inherits(cond, "condition")) {
[10:32:52.218]                         if (!is.null(pattern)) {
[10:32:52.218]                           computeRestarts <- base::computeRestarts
[10:32:52.218]                           grepl <- base::grepl
[10:32:52.218]                           restarts <- computeRestarts(cond)
[10:32:52.218]                           for (restart in restarts) {
[10:32:52.218]                             name <- restart$name
[10:32:52.218]                             if (is.null(name)) 
[10:32:52.218]                               next
[10:32:52.218]                             if (!grepl(pattern, name)) 
[10:32:52.218]                               next
[10:32:52.218]                             invokeRestart(restart)
[10:32:52.218]                             muffled <- TRUE
[10:32:52.218]                             break
[10:32:52.218]                           }
[10:32:52.218]                         }
[10:32:52.218]                       }
[10:32:52.218]                       invisible(muffled)
[10:32:52.218]                     }
[10:32:52.218]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.218]                   }
[10:32:52.218]                 }
[10:32:52.218]             }
[10:32:52.218]         }))
[10:32:52.218]     }, error = function(ex) {
[10:32:52.218]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.218]                 ...future.rng), started = ...future.startTime, 
[10:32:52.218]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.218]             version = "1.8"), class = "FutureResult")
[10:32:52.218]     }, finally = {
[10:32:52.218]         if (!identical(...future.workdir, getwd())) 
[10:32:52.218]             setwd(...future.workdir)
[10:32:52.218]         {
[10:32:52.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.218]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.218]             }
[10:32:52.218]             base::options(...future.oldOptions)
[10:32:52.218]             if (.Platform$OS.type == "windows") {
[10:32:52.218]                 old_names <- names(...future.oldEnvVars)
[10:32:52.218]                 envs <- base::Sys.getenv()
[10:32:52.218]                 names <- names(envs)
[10:32:52.218]                 common <- intersect(names, old_names)
[10:32:52.218]                 added <- setdiff(names, old_names)
[10:32:52.218]                 removed <- setdiff(old_names, names)
[10:32:52.218]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.218]                   envs[common]]
[10:32:52.218]                 NAMES <- toupper(changed)
[10:32:52.218]                 args <- list()
[10:32:52.218]                 for (kk in seq_along(NAMES)) {
[10:32:52.218]                   name <- changed[[kk]]
[10:32:52.218]                   NAME <- NAMES[[kk]]
[10:32:52.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.218]                     next
[10:32:52.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.218]                 }
[10:32:52.218]                 NAMES <- toupper(added)
[10:32:52.218]                 for (kk in seq_along(NAMES)) {
[10:32:52.218]                   name <- added[[kk]]
[10:32:52.218]                   NAME <- NAMES[[kk]]
[10:32:52.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.218]                     next
[10:32:52.218]                   args[[name]] <- ""
[10:32:52.218]                 }
[10:32:52.218]                 NAMES <- toupper(removed)
[10:32:52.218]                 for (kk in seq_along(NAMES)) {
[10:32:52.218]                   name <- removed[[kk]]
[10:32:52.218]                   NAME <- NAMES[[kk]]
[10:32:52.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.218]                     next
[10:32:52.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.218]                 }
[10:32:52.218]                 if (length(args) > 0) 
[10:32:52.218]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.218]             }
[10:32:52.218]             else {
[10:32:52.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.218]             }
[10:32:52.218]             {
[10:32:52.218]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.218]                   0L) {
[10:32:52.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.218]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.218]                   base::options(opts)
[10:32:52.218]                 }
[10:32:52.218]                 {
[10:32:52.218]                   {
[10:32:52.218]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.218]                     NULL
[10:32:52.218]                   }
[10:32:52.218]                   options(future.plan = NULL)
[10:32:52.218]                   if (is.na(NA_character_)) 
[10:32:52.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.218]                     .init = FALSE)
[10:32:52.218]                 }
[10:32:52.218]             }
[10:32:52.218]         }
[10:32:52.218]     })
[10:32:52.218]     if (TRUE) {
[10:32:52.218]         base::sink(type = "output", split = FALSE)
[10:32:52.218]         if (TRUE) {
[10:32:52.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.218]         }
[10:32:52.218]         else {
[10:32:52.218]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.218]         }
[10:32:52.218]         base::close(...future.stdout)
[10:32:52.218]         ...future.stdout <- NULL
[10:32:52.218]     }
[10:32:52.218]     ...future.result$conditions <- ...future.conditions
[10:32:52.218]     ...future.result$finished <- base::Sys.time()
[10:32:52.218]     ...future.result
[10:32:52.218] }
[10:32:52.221] requestCore(): workers = 2
[10:32:52.221] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:52.244] result() for MulticoreFuture ...
[10:32:52.245] result() for MulticoreFuture ...
[10:32:52.245] result() for MulticoreFuture ... done
[10:32:52.245] result() for MulticoreFuture ... done
[10:32:52.245] result() for MulticoreFuture ...
[10:32:52.245] result() for MulticoreFuture ... done
[10:32:52.248] MulticoreFuture started
[10:32:52.249] - Launch lazy future ... done
[10:32:52.249] run() for ‘MulticoreFuture’ ... done
[10:32:52.250] plan(): Setting new future strategy stack:
<environment: 0x5652d0c8f8c0> 
[10:32:52.250] List of future strategies:
[10:32:52.250] 1. sequential:
[10:32:52.250]    - args: function (..., envir = parent.frame())
[10:32:52.250]    - tweaked: FALSE
[10:32:52.250]    - call: NULL
[10:32:52.251] plan(): nbrOfWorkers() = 1
<environment: 0x5652d2631718> 
[10:32:52.254] plan(): Setting new future strategy stack:
[10:32:52.254] List of future strategies:
[10:32:52.254] 1. multicore:
[10:32:52.254]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.254]    - tweaked: FALSE
[10:32:52.254]    - call: plan(strategy)
[10:32:52.259] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:52.261] resolve() on environment ...
[10:32:52.262]  recursive: 0
[10:32:52.262]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:52.263] signalConditionsASAP(numeric, pos=1) ...
[10:32:52.263] - nx: 4
[10:32:52.263] - relay: TRUE
[10:32:52.263] - stdout: TRUE
[10:32:52.263] - signal: TRUE
[10:32:52.263] - resignal: FALSE
[10:32:52.263] - force: TRUE
[10:32:52.264] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.264] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.264]  - until=2
[10:32:52.264]  - relaying element #2
[10:32:52.264] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.264] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.264] signalConditionsASAP(NULL, pos=1) ... done
[10:32:52.265]  length: 3 (resolved future 1)
[10:32:52.265] Future #2
[10:32:52.265] result() for MulticoreFuture ...
[10:32:52.265] result() for MulticoreFuture ... done
[10:32:52.265] result() for MulticoreFuture ...
[10:32:52.265] result() for MulticoreFuture ... done
[10:32:52.266] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:52.266] - nx: 4
[10:32:52.266] - relay: TRUE
[10:32:52.266] - stdout: TRUE
[10:32:52.266] - signal: TRUE
[10:32:52.266] - resignal: FALSE
[10:32:52.266] - force: TRUE
[10:32:52.266] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.266] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.267]  - until=2
[10:32:52.267]  - relaying element #2
[10:32:52.267] result() for MulticoreFuture ...
[10:32:52.267] result() for MulticoreFuture ... done
[10:32:52.267] result() for MulticoreFuture ...
[10:32:52.267] result() for MulticoreFuture ... done
[10:32:52.267] result() for MulticoreFuture ...
[10:32:52.268] result() for MulticoreFuture ... done
[10:32:52.268] result() for MulticoreFuture ...
[10:32:52.268] result() for MulticoreFuture ... done
[10:32:52.268] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.268] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.268] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:52.268]  length: 2 (resolved future 2)
[10:32:52.269] Future #3
[10:32:52.269] result() for MulticoreFuture ...
[10:32:52.270] result() for MulticoreFuture ...
[10:32:52.270] result() for MulticoreFuture ... done
[10:32:52.270] result() for MulticoreFuture ... done
[10:32:52.270] result() for MulticoreFuture ...
[10:32:52.270] result() for MulticoreFuture ... done
[10:32:52.271] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:52.271] - nx: 4
[10:32:52.271] - relay: TRUE
[10:32:52.271] - stdout: TRUE
[10:32:52.271] - signal: TRUE
[10:32:52.271] - resignal: FALSE
[10:32:52.271] - force: TRUE
[10:32:52.271] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.272] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.272]  - until=3
[10:32:52.272]  - relaying element #3
[10:32:52.272] result() for MulticoreFuture ...
[10:32:52.272] result() for MulticoreFuture ... done
[10:32:52.272] result() for MulticoreFuture ...
[10:32:52.272] result() for MulticoreFuture ... done
[10:32:52.273] result() for MulticoreFuture ...
[10:32:52.273] result() for MulticoreFuture ... done
[10:32:52.273] result() for MulticoreFuture ...
[10:32:52.273] result() for MulticoreFuture ... done
[10:32:52.273] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.273] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.273] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:52.274]  length: 1 (resolved future 3)
[10:32:52.274] Future #4
[10:32:52.274] result() for MulticoreFuture ...
[10:32:52.275] result() for MulticoreFuture ...
[10:32:52.275] result() for MulticoreFuture ... done
[10:32:52.275] result() for MulticoreFuture ... done
[10:32:52.275] result() for MulticoreFuture ...
[10:32:52.275] result() for MulticoreFuture ... done
[10:32:52.276] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:52.276] - nx: 4
[10:32:52.276] - relay: TRUE
[10:32:52.276] - stdout: TRUE
[10:32:52.276] - signal: TRUE
[10:32:52.276] - resignal: FALSE
[10:32:52.277] - force: TRUE
[10:32:52.277] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.277] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.277]  - until=4
[10:32:52.277]  - relaying element #4
[10:32:52.277] result() for MulticoreFuture ...
[10:32:52.278] result() for MulticoreFuture ... done
[10:32:52.278] result() for MulticoreFuture ...
[10:32:52.278] result() for MulticoreFuture ... done
[10:32:52.278] result() for MulticoreFuture ...
[10:32:52.278] result() for MulticoreFuture ... done
[10:32:52.278] result() for MulticoreFuture ...
[10:32:52.279] result() for MulticoreFuture ... done
[10:32:52.279] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.279] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.279] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:52.279]  length: 0 (resolved future 4)
[10:32:52.279] Relaying remaining futures
[10:32:52.279] signalConditionsASAP(NULL, pos=0) ...
[10:32:52.279] - nx: 4
[10:32:52.279] - relay: TRUE
[10:32:52.280] - stdout: TRUE
[10:32:52.280] - signal: TRUE
[10:32:52.280] - resignal: FALSE
[10:32:52.280] - force: TRUE
[10:32:52.280] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.280] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:52.280] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.280] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.280] signalConditionsASAP(NULL, pos=0) ... done
[10:32:52.281] resolve() on environment ... DONE
[10:32:52.281] result() for MulticoreFuture ...
[10:32:52.281] result() for MulticoreFuture ... done
[10:32:52.281] result() for MulticoreFuture ...
[10:32:52.281] result() for MulticoreFuture ... done
[10:32:52.281] result() for MulticoreFuture ...
[10:32:52.281] result() for MulticoreFuture ... done
[10:32:52.281] result() for MulticoreFuture ...
[10:32:52.281] result() for MulticoreFuture ... done
[10:32:52.282] result() for MulticoreFuture ...
[10:32:52.282] result() for MulticoreFuture ... done
[10:32:52.282] result() for MulticoreFuture ...
[10:32:52.282] result() for MulticoreFuture ... done
<environment: 0x5652d26e8820> 
Dimensions: c(2, 3)
[10:32:52.282] getGlobalsAndPackages() ...
[10:32:52.283] Searching for globals...
[10:32:52.283] 
[10:32:52.283] Searching for globals ... DONE
[10:32:52.283] - globals: [0] <none>
[10:32:52.283] getGlobalsAndPackages() ... DONE
[10:32:52.284] run() for ‘Future’ ...
[10:32:52.284] - state: ‘created’
[10:32:52.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.288]   - Field: ‘label’
[10:32:52.289]   - Field: ‘local’
[10:32:52.289]   - Field: ‘owner’
[10:32:52.289]   - Field: ‘envir’
[10:32:52.289]   - Field: ‘workers’
[10:32:52.289]   - Field: ‘packages’
[10:32:52.289]   - Field: ‘gc’
[10:32:52.289]   - Field: ‘job’
[10:32:52.289]   - Field: ‘conditions’
[10:32:52.290]   - Field: ‘expr’
[10:32:52.290]   - Field: ‘uuid’
[10:32:52.290]   - Field: ‘seed’
[10:32:52.290]   - Field: ‘version’
[10:32:52.290]   - Field: ‘result’
[10:32:52.290]   - Field: ‘asynchronous’
[10:32:52.290]   - Field: ‘calls’
[10:32:52.290]   - Field: ‘globals’
[10:32:52.290]   - Field: ‘stdout’
[10:32:52.290]   - Field: ‘earlySignal’
[10:32:52.291]   - Field: ‘lazy’
[10:32:52.291]   - Field: ‘state’
[10:32:52.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.294] - Launch lazy future ...
[10:32:52.294] Packages needed by the future expression (n = 0): <none>
[10:32:52.294] Packages needed by future strategies (n = 0): <none>
[10:32:52.295] {
[10:32:52.295]     {
[10:32:52.295]         {
[10:32:52.295]             ...future.startTime <- base::Sys.time()
[10:32:52.295]             {
[10:32:52.295]                 {
[10:32:52.295]                   {
[10:32:52.295]                     {
[10:32:52.295]                       base::local({
[10:32:52.295]                         has_future <- base::requireNamespace("future", 
[10:32:52.295]                           quietly = TRUE)
[10:32:52.295]                         if (has_future) {
[10:32:52.295]                           ns <- base::getNamespace("future")
[10:32:52.295]                           version <- ns[[".package"]][["version"]]
[10:32:52.295]                           if (is.null(version)) 
[10:32:52.295]                             version <- utils::packageVersion("future")
[10:32:52.295]                         }
[10:32:52.295]                         else {
[10:32:52.295]                           version <- NULL
[10:32:52.295]                         }
[10:32:52.295]                         if (!has_future || version < "1.8.0") {
[10:32:52.295]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.295]                             "", base::R.version$version.string), 
[10:32:52.295]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.295]                               "release", "version")], collapse = " "), 
[10:32:52.295]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.295]                             info)
[10:32:52.295]                           info <- base::paste(info, collapse = "; ")
[10:32:52.295]                           if (!has_future) {
[10:32:52.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.295]                               info)
[10:32:52.295]                           }
[10:32:52.295]                           else {
[10:32:52.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.295]                               info, version)
[10:32:52.295]                           }
[10:32:52.295]                           base::stop(msg)
[10:32:52.295]                         }
[10:32:52.295]                       })
[10:32:52.295]                     }
[10:32:52.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.295]                     base::options(mc.cores = 1L)
[10:32:52.295]                   }
[10:32:52.295]                   ...future.strategy.old <- future::plan("list")
[10:32:52.295]                   options(future.plan = NULL)
[10:32:52.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.295]                 }
[10:32:52.295]                 ...future.workdir <- getwd()
[10:32:52.295]             }
[10:32:52.295]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.295]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.295]         }
[10:32:52.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.295]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.295]             base::names(...future.oldOptions))
[10:32:52.295]     }
[10:32:52.295]     if (FALSE) {
[10:32:52.295]     }
[10:32:52.295]     else {
[10:32:52.295]         if (TRUE) {
[10:32:52.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.295]                 open = "w")
[10:32:52.295]         }
[10:32:52.295]         else {
[10:32:52.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.295]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.295]         }
[10:32:52.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.295]             base::sink(type = "output", split = FALSE)
[10:32:52.295]             base::close(...future.stdout)
[10:32:52.295]         }, add = TRUE)
[10:32:52.295]     }
[10:32:52.295]     ...future.frame <- base::sys.nframe()
[10:32:52.295]     ...future.conditions <- base::list()
[10:32:52.295]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.295]     if (FALSE) {
[10:32:52.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.295]     }
[10:32:52.295]     ...future.result <- base::tryCatch({
[10:32:52.295]         base::withCallingHandlers({
[10:32:52.295]             ...future.value <- base::withVisible(base::local({
[10:32:52.295]                 withCallingHandlers({
[10:32:52.295]                   2
[10:32:52.295]                 }, immediateCondition = function(cond) {
[10:32:52.295]                   save_rds <- function (object, pathname, ...) 
[10:32:52.295]                   {
[10:32:52.295]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.295]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.295]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.295]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.295]                         fi_tmp[["mtime"]])
[10:32:52.295]                     }
[10:32:52.295]                     tryCatch({
[10:32:52.295]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.295]                     }, error = function(ex) {
[10:32:52.295]                       msg <- conditionMessage(ex)
[10:32:52.295]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.295]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.295]                         fi_tmp[["mtime"]], msg)
[10:32:52.295]                       ex$message <- msg
[10:32:52.295]                       stop(ex)
[10:32:52.295]                     })
[10:32:52.295]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.295]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.295]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.295]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.295]                       fi <- file.info(pathname)
[10:32:52.295]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.295]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.295]                         fi[["size"]], fi[["mtime"]])
[10:32:52.295]                       stop(msg)
[10:32:52.295]                     }
[10:32:52.295]                     invisible(pathname)
[10:32:52.295]                   }
[10:32:52.295]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.295]                     rootPath = tempdir()) 
[10:32:52.295]                   {
[10:32:52.295]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.295]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.295]                       tmpdir = path, fileext = ".rds")
[10:32:52.295]                     save_rds(obj, file)
[10:32:52.295]                   }
[10:32:52.295]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.295]                   {
[10:32:52.295]                     inherits <- base::inherits
[10:32:52.295]                     invokeRestart <- base::invokeRestart
[10:32:52.295]                     is.null <- base::is.null
[10:32:52.295]                     muffled <- FALSE
[10:32:52.295]                     if (inherits(cond, "message")) {
[10:32:52.295]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.295]                       if (muffled) 
[10:32:52.295]                         invokeRestart("muffleMessage")
[10:32:52.295]                     }
[10:32:52.295]                     else if (inherits(cond, "warning")) {
[10:32:52.295]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.295]                       if (muffled) 
[10:32:52.295]                         invokeRestart("muffleWarning")
[10:32:52.295]                     }
[10:32:52.295]                     else if (inherits(cond, "condition")) {
[10:32:52.295]                       if (!is.null(pattern)) {
[10:32:52.295]                         computeRestarts <- base::computeRestarts
[10:32:52.295]                         grepl <- base::grepl
[10:32:52.295]                         restarts <- computeRestarts(cond)
[10:32:52.295]                         for (restart in restarts) {
[10:32:52.295]                           name <- restart$name
[10:32:52.295]                           if (is.null(name)) 
[10:32:52.295]                             next
[10:32:52.295]                           if (!grepl(pattern, name)) 
[10:32:52.295]                             next
[10:32:52.295]                           invokeRestart(restart)
[10:32:52.295]                           muffled <- TRUE
[10:32:52.295]                           break
[10:32:52.295]                         }
[10:32:52.295]                       }
[10:32:52.295]                     }
[10:32:52.295]                     invisible(muffled)
[10:32:52.295]                   }
[10:32:52.295]                   muffleCondition(cond)
[10:32:52.295]                 })
[10:32:52.295]             }))
[10:32:52.295]             future::FutureResult(value = ...future.value$value, 
[10:32:52.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.295]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.295]                     ...future.globalenv.names))
[10:32:52.295]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.295]         }, condition = base::local({
[10:32:52.295]             c <- base::c
[10:32:52.295]             inherits <- base::inherits
[10:32:52.295]             invokeRestart <- base::invokeRestart
[10:32:52.295]             length <- base::length
[10:32:52.295]             list <- base::list
[10:32:52.295]             seq.int <- base::seq.int
[10:32:52.295]             signalCondition <- base::signalCondition
[10:32:52.295]             sys.calls <- base::sys.calls
[10:32:52.295]             `[[` <- base::`[[`
[10:32:52.295]             `+` <- base::`+`
[10:32:52.295]             `<<-` <- base::`<<-`
[10:32:52.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.295]                   3L)]
[10:32:52.295]             }
[10:32:52.295]             function(cond) {
[10:32:52.295]                 is_error <- inherits(cond, "error")
[10:32:52.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.295]                   NULL)
[10:32:52.295]                 if (is_error) {
[10:32:52.295]                   sessionInformation <- function() {
[10:32:52.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.295]                       search = base::search(), system = base::Sys.info())
[10:32:52.295]                   }
[10:32:52.295]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.295]                     cond$call), session = sessionInformation(), 
[10:32:52.295]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.295]                   signalCondition(cond)
[10:32:52.295]                 }
[10:32:52.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.295]                 "immediateCondition"))) {
[10:32:52.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.295]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.295]                   if (TRUE && !signal) {
[10:32:52.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.295]                     {
[10:32:52.295]                       inherits <- base::inherits
[10:32:52.295]                       invokeRestart <- base::invokeRestart
[10:32:52.295]                       is.null <- base::is.null
[10:32:52.295]                       muffled <- FALSE
[10:32:52.295]                       if (inherits(cond, "message")) {
[10:32:52.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.295]                         if (muffled) 
[10:32:52.295]                           invokeRestart("muffleMessage")
[10:32:52.295]                       }
[10:32:52.295]                       else if (inherits(cond, "warning")) {
[10:32:52.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.295]                         if (muffled) 
[10:32:52.295]                           invokeRestart("muffleWarning")
[10:32:52.295]                       }
[10:32:52.295]                       else if (inherits(cond, "condition")) {
[10:32:52.295]                         if (!is.null(pattern)) {
[10:32:52.295]                           computeRestarts <- base::computeRestarts
[10:32:52.295]                           grepl <- base::grepl
[10:32:52.295]                           restarts <- computeRestarts(cond)
[10:32:52.295]                           for (restart in restarts) {
[10:32:52.295]                             name <- restart$name
[10:32:52.295]                             if (is.null(name)) 
[10:32:52.295]                               next
[10:32:52.295]                             if (!grepl(pattern, name)) 
[10:32:52.295]                               next
[10:32:52.295]                             invokeRestart(restart)
[10:32:52.295]                             muffled <- TRUE
[10:32:52.295]                             break
[10:32:52.295]                           }
[10:32:52.295]                         }
[10:32:52.295]                       }
[10:32:52.295]                       invisible(muffled)
[10:32:52.295]                     }
[10:32:52.295]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.295]                   }
[10:32:52.295]                 }
[10:32:52.295]                 else {
[10:32:52.295]                   if (TRUE) {
[10:32:52.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.295]                     {
[10:32:52.295]                       inherits <- base::inherits
[10:32:52.295]                       invokeRestart <- base::invokeRestart
[10:32:52.295]                       is.null <- base::is.null
[10:32:52.295]                       muffled <- FALSE
[10:32:52.295]                       if (inherits(cond, "message")) {
[10:32:52.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.295]                         if (muffled) 
[10:32:52.295]                           invokeRestart("muffleMessage")
[10:32:52.295]                       }
[10:32:52.295]                       else if (inherits(cond, "warning")) {
[10:32:52.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.295]                         if (muffled) 
[10:32:52.295]                           invokeRestart("muffleWarning")
[10:32:52.295]                       }
[10:32:52.295]                       else if (inherits(cond, "condition")) {
[10:32:52.295]                         if (!is.null(pattern)) {
[10:32:52.295]                           computeRestarts <- base::computeRestarts
[10:32:52.295]                           grepl <- base::grepl
[10:32:52.295]                           restarts <- computeRestarts(cond)
[10:32:52.295]                           for (restart in restarts) {
[10:32:52.295]                             name <- restart$name
[10:32:52.295]                             if (is.null(name)) 
[10:32:52.295]                               next
[10:32:52.295]                             if (!grepl(pattern, name)) 
[10:32:52.295]                               next
[10:32:52.295]                             invokeRestart(restart)
[10:32:52.295]                             muffled <- TRUE
[10:32:52.295]                             break
[10:32:52.295]                           }
[10:32:52.295]                         }
[10:32:52.295]                       }
[10:32:52.295]                       invisible(muffled)
[10:32:52.295]                     }
[10:32:52.295]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.295]                   }
[10:32:52.295]                 }
[10:32:52.295]             }
[10:32:52.295]         }))
[10:32:52.295]     }, error = function(ex) {
[10:32:52.295]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.295]                 ...future.rng), started = ...future.startTime, 
[10:32:52.295]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.295]             version = "1.8"), class = "FutureResult")
[10:32:52.295]     }, finally = {
[10:32:52.295]         if (!identical(...future.workdir, getwd())) 
[10:32:52.295]             setwd(...future.workdir)
[10:32:52.295]         {
[10:32:52.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.295]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.295]             }
[10:32:52.295]             base::options(...future.oldOptions)
[10:32:52.295]             if (.Platform$OS.type == "windows") {
[10:32:52.295]                 old_names <- names(...future.oldEnvVars)
[10:32:52.295]                 envs <- base::Sys.getenv()
[10:32:52.295]                 names <- names(envs)
[10:32:52.295]                 common <- intersect(names, old_names)
[10:32:52.295]                 added <- setdiff(names, old_names)
[10:32:52.295]                 removed <- setdiff(old_names, names)
[10:32:52.295]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.295]                   envs[common]]
[10:32:52.295]                 NAMES <- toupper(changed)
[10:32:52.295]                 args <- list()
[10:32:52.295]                 for (kk in seq_along(NAMES)) {
[10:32:52.295]                   name <- changed[[kk]]
[10:32:52.295]                   NAME <- NAMES[[kk]]
[10:32:52.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.295]                     next
[10:32:52.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.295]                 }
[10:32:52.295]                 NAMES <- toupper(added)
[10:32:52.295]                 for (kk in seq_along(NAMES)) {
[10:32:52.295]                   name <- added[[kk]]
[10:32:52.295]                   NAME <- NAMES[[kk]]
[10:32:52.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.295]                     next
[10:32:52.295]                   args[[name]] <- ""
[10:32:52.295]                 }
[10:32:52.295]                 NAMES <- toupper(removed)
[10:32:52.295]                 for (kk in seq_along(NAMES)) {
[10:32:52.295]                   name <- removed[[kk]]
[10:32:52.295]                   NAME <- NAMES[[kk]]
[10:32:52.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.295]                     next
[10:32:52.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.295]                 }
[10:32:52.295]                 if (length(args) > 0) 
[10:32:52.295]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.295]             }
[10:32:52.295]             else {
[10:32:52.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.295]             }
[10:32:52.295]             {
[10:32:52.295]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.295]                   0L) {
[10:32:52.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.295]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.295]                   base::options(opts)
[10:32:52.295]                 }
[10:32:52.295]                 {
[10:32:52.295]                   {
[10:32:52.295]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.295]                     NULL
[10:32:52.295]                   }
[10:32:52.295]                   options(future.plan = NULL)
[10:32:52.295]                   if (is.na(NA_character_)) 
[10:32:52.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.295]                     .init = FALSE)
[10:32:52.295]                 }
[10:32:52.295]             }
[10:32:52.295]         }
[10:32:52.295]     })
[10:32:52.295]     if (TRUE) {
[10:32:52.295]         base::sink(type = "output", split = FALSE)
[10:32:52.295]         if (TRUE) {
[10:32:52.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.295]         }
[10:32:52.295]         else {
[10:32:52.295]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.295]         }
[10:32:52.295]         base::close(...future.stdout)
[10:32:52.295]         ...future.stdout <- NULL
[10:32:52.295]     }
[10:32:52.295]     ...future.result$conditions <- ...future.conditions
[10:32:52.295]     ...future.result$finished <- base::Sys.time()
[10:32:52.295]     ...future.result
[10:32:52.295] }
[10:32:52.297] requestCore(): workers = 2
[10:32:52.300] MulticoreFuture started
[10:32:52.300] - Launch lazy future ... done
[10:32:52.300] run() for ‘MulticoreFuture’ ... done
[10:32:52.300] getGlobalsAndPackages() ...
[10:32:52.301] Searching for globals...
[10:32:52.301] plan(): Setting new future strategy stack:
[10:32:52.301] 
[10:32:52.302] Searching for globals ... DONE
[10:32:52.301] List of future strategies:
[10:32:52.301] 1. sequential:
[10:32:52.301]    - args: function (..., envir = parent.frame())
[10:32:52.301]    - tweaked: FALSE
[10:32:52.301]    - call: NULL
[10:32:52.302] - globals: [0] <none>
[10:32:52.302] getGlobalsAndPackages() ... DONE
[10:32:52.302] plan(): nbrOfWorkers() = 1
[10:32:52.302] run() for ‘Future’ ...
[10:32:52.303] - state: ‘created’
[10:32:52.303] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.304] plan(): Setting new future strategy stack:
[10:32:52.304] List of future strategies:
[10:32:52.304] 1. multicore:
[10:32:52.304]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.304]    - tweaked: FALSE
[10:32:52.304]    - call: plan(strategy)
[10:32:52.308] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.308]   - Field: ‘label’
[10:32:52.308]   - Field: ‘local’
[10:32:52.309]   - Field: ‘owner’
[10:32:52.309] plan(): nbrOfWorkers() = 2
[10:32:52.309]   - Field: ‘envir’
[10:32:52.309]   - Field: ‘workers’
[10:32:52.309]   - Field: ‘packages’
[10:32:52.309]   - Field: ‘gc’
[10:32:52.309]   - Field: ‘job’
[10:32:52.309]   - Field: ‘conditions’
[10:32:52.310]   - Field: ‘expr’
[10:32:52.310]   - Field: ‘uuid’
[10:32:52.310]   - Field: ‘seed’
[10:32:52.310]   - Field: ‘version’
[10:32:52.310]   - Field: ‘result’
[10:32:52.310]   - Field: ‘asynchronous’
[10:32:52.311]   - Field: ‘calls’
[10:32:52.311]   - Field: ‘globals’
[10:32:52.311]   - Field: ‘stdout’
[10:32:52.311]   - Field: ‘earlySignal’
[10:32:52.311]   - Field: ‘lazy’
[10:32:52.311]   - Field: ‘state’
[10:32:52.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.312] - Launch lazy future ...
[10:32:52.312] Packages needed by the future expression (n = 0): <none>
[10:32:52.312] Packages needed by future strategies (n = 0): <none>
[10:32:52.313] {
[10:32:52.313]     {
[10:32:52.313]         {
[10:32:52.313]             ...future.startTime <- base::Sys.time()
[10:32:52.313]             {
[10:32:52.313]                 {
[10:32:52.313]                   {
[10:32:52.313]                     {
[10:32:52.313]                       base::local({
[10:32:52.313]                         has_future <- base::requireNamespace("future", 
[10:32:52.313]                           quietly = TRUE)
[10:32:52.313]                         if (has_future) {
[10:32:52.313]                           ns <- base::getNamespace("future")
[10:32:52.313]                           version <- ns[[".package"]][["version"]]
[10:32:52.313]                           if (is.null(version)) 
[10:32:52.313]                             version <- utils::packageVersion("future")
[10:32:52.313]                         }
[10:32:52.313]                         else {
[10:32:52.313]                           version <- NULL
[10:32:52.313]                         }
[10:32:52.313]                         if (!has_future || version < "1.8.0") {
[10:32:52.313]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.313]                             "", base::R.version$version.string), 
[10:32:52.313]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.313]                               "release", "version")], collapse = " "), 
[10:32:52.313]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.313]                             info)
[10:32:52.313]                           info <- base::paste(info, collapse = "; ")
[10:32:52.313]                           if (!has_future) {
[10:32:52.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.313]                               info)
[10:32:52.313]                           }
[10:32:52.313]                           else {
[10:32:52.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.313]                               info, version)
[10:32:52.313]                           }
[10:32:52.313]                           base::stop(msg)
[10:32:52.313]                         }
[10:32:52.313]                       })
[10:32:52.313]                     }
[10:32:52.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.313]                     base::options(mc.cores = 1L)
[10:32:52.313]                   }
[10:32:52.313]                   ...future.strategy.old <- future::plan("list")
[10:32:52.313]                   options(future.plan = NULL)
[10:32:52.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.313]                 }
[10:32:52.313]                 ...future.workdir <- getwd()
[10:32:52.313]             }
[10:32:52.313]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.313]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.313]         }
[10:32:52.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.313]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.313]             base::names(...future.oldOptions))
[10:32:52.313]     }
[10:32:52.313]     if (FALSE) {
[10:32:52.313]     }
[10:32:52.313]     else {
[10:32:52.313]         if (TRUE) {
[10:32:52.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.313]                 open = "w")
[10:32:52.313]         }
[10:32:52.313]         else {
[10:32:52.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.313]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.313]         }
[10:32:52.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.313]             base::sink(type = "output", split = FALSE)
[10:32:52.313]             base::close(...future.stdout)
[10:32:52.313]         }, add = TRUE)
[10:32:52.313]     }
[10:32:52.313]     ...future.frame <- base::sys.nframe()
[10:32:52.313]     ...future.conditions <- base::list()
[10:32:52.313]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.313]     if (FALSE) {
[10:32:52.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.313]     }
[10:32:52.313]     ...future.result <- base::tryCatch({
[10:32:52.313]         base::withCallingHandlers({
[10:32:52.313]             ...future.value <- base::withVisible(base::local({
[10:32:52.313]                 withCallingHandlers({
[10:32:52.313]                   NULL
[10:32:52.313]                 }, immediateCondition = function(cond) {
[10:32:52.313]                   save_rds <- function (object, pathname, ...) 
[10:32:52.313]                   {
[10:32:52.313]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.313]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.313]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.313]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.313]                         fi_tmp[["mtime"]])
[10:32:52.313]                     }
[10:32:52.313]                     tryCatch({
[10:32:52.313]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.313]                     }, error = function(ex) {
[10:32:52.313]                       msg <- conditionMessage(ex)
[10:32:52.313]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.313]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.313]                         fi_tmp[["mtime"]], msg)
[10:32:52.313]                       ex$message <- msg
[10:32:52.313]                       stop(ex)
[10:32:52.313]                     })
[10:32:52.313]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.313]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.313]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.313]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.313]                       fi <- file.info(pathname)
[10:32:52.313]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.313]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.313]                         fi[["size"]], fi[["mtime"]])
[10:32:52.313]                       stop(msg)
[10:32:52.313]                     }
[10:32:52.313]                     invisible(pathname)
[10:32:52.313]                   }
[10:32:52.313]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.313]                     rootPath = tempdir()) 
[10:32:52.313]                   {
[10:32:52.313]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.313]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.313]                       tmpdir = path, fileext = ".rds")
[10:32:52.313]                     save_rds(obj, file)
[10:32:52.313]                   }
[10:32:52.313]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.313]                   {
[10:32:52.313]                     inherits <- base::inherits
[10:32:52.313]                     invokeRestart <- base::invokeRestart
[10:32:52.313]                     is.null <- base::is.null
[10:32:52.313]                     muffled <- FALSE
[10:32:52.313]                     if (inherits(cond, "message")) {
[10:32:52.313]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.313]                       if (muffled) 
[10:32:52.313]                         invokeRestart("muffleMessage")
[10:32:52.313]                     }
[10:32:52.313]                     else if (inherits(cond, "warning")) {
[10:32:52.313]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.313]                       if (muffled) 
[10:32:52.313]                         invokeRestart("muffleWarning")
[10:32:52.313]                     }
[10:32:52.313]                     else if (inherits(cond, "condition")) {
[10:32:52.313]                       if (!is.null(pattern)) {
[10:32:52.313]                         computeRestarts <- base::computeRestarts
[10:32:52.313]                         grepl <- base::grepl
[10:32:52.313]                         restarts <- computeRestarts(cond)
[10:32:52.313]                         for (restart in restarts) {
[10:32:52.313]                           name <- restart$name
[10:32:52.313]                           if (is.null(name)) 
[10:32:52.313]                             next
[10:32:52.313]                           if (!grepl(pattern, name)) 
[10:32:52.313]                             next
[10:32:52.313]                           invokeRestart(restart)
[10:32:52.313]                           muffled <- TRUE
[10:32:52.313]                           break
[10:32:52.313]                         }
[10:32:52.313]                       }
[10:32:52.313]                     }
[10:32:52.313]                     invisible(muffled)
[10:32:52.313]                   }
[10:32:52.313]                   muffleCondition(cond)
[10:32:52.313]                 })
[10:32:52.313]             }))
[10:32:52.313]             future::FutureResult(value = ...future.value$value, 
[10:32:52.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.313]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.313]                     ...future.globalenv.names))
[10:32:52.313]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.313]         }, condition = base::local({
[10:32:52.313]             c <- base::c
[10:32:52.313]             inherits <- base::inherits
[10:32:52.313]             invokeRestart <- base::invokeRestart
[10:32:52.313]             length <- base::length
[10:32:52.313]             list <- base::list
[10:32:52.313]             seq.int <- base::seq.int
[10:32:52.313]             signalCondition <- base::signalCondition
[10:32:52.313]             sys.calls <- base::sys.calls
[10:32:52.313]             `[[` <- base::`[[`
[10:32:52.313]             `+` <- base::`+`
[10:32:52.313]             `<<-` <- base::`<<-`
[10:32:52.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.313]                   3L)]
[10:32:52.313]             }
[10:32:52.313]             function(cond) {
[10:32:52.313]                 is_error <- inherits(cond, "error")
[10:32:52.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.313]                   NULL)
[10:32:52.313]                 if (is_error) {
[10:32:52.313]                   sessionInformation <- function() {
[10:32:52.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.313]                       search = base::search(), system = base::Sys.info())
[10:32:52.313]                   }
[10:32:52.313]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.313]                     cond$call), session = sessionInformation(), 
[10:32:52.313]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.313]                   signalCondition(cond)
[10:32:52.313]                 }
[10:32:52.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.313]                 "immediateCondition"))) {
[10:32:52.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.313]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.313]                   if (TRUE && !signal) {
[10:32:52.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.313]                     {
[10:32:52.313]                       inherits <- base::inherits
[10:32:52.313]                       invokeRestart <- base::invokeRestart
[10:32:52.313]                       is.null <- base::is.null
[10:32:52.313]                       muffled <- FALSE
[10:32:52.313]                       if (inherits(cond, "message")) {
[10:32:52.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.313]                         if (muffled) 
[10:32:52.313]                           invokeRestart("muffleMessage")
[10:32:52.313]                       }
[10:32:52.313]                       else if (inherits(cond, "warning")) {
[10:32:52.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.313]                         if (muffled) 
[10:32:52.313]                           invokeRestart("muffleWarning")
[10:32:52.313]                       }
[10:32:52.313]                       else if (inherits(cond, "condition")) {
[10:32:52.313]                         if (!is.null(pattern)) {
[10:32:52.313]                           computeRestarts <- base::computeRestarts
[10:32:52.313]                           grepl <- base::grepl
[10:32:52.313]                           restarts <- computeRestarts(cond)
[10:32:52.313]                           for (restart in restarts) {
[10:32:52.313]                             name <- restart$name
[10:32:52.313]                             if (is.null(name)) 
[10:32:52.313]                               next
[10:32:52.313]                             if (!grepl(pattern, name)) 
[10:32:52.313]                               next
[10:32:52.313]                             invokeRestart(restart)
[10:32:52.313]                             muffled <- TRUE
[10:32:52.313]                             break
[10:32:52.313]                           }
[10:32:52.313]                         }
[10:32:52.313]                       }
[10:32:52.313]                       invisible(muffled)
[10:32:52.313]                     }
[10:32:52.313]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.313]                   }
[10:32:52.313]                 }
[10:32:52.313]                 else {
[10:32:52.313]                   if (TRUE) {
[10:32:52.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.313]                     {
[10:32:52.313]                       inherits <- base::inherits
[10:32:52.313]                       invokeRestart <- base::invokeRestart
[10:32:52.313]                       is.null <- base::is.null
[10:32:52.313]                       muffled <- FALSE
[10:32:52.313]                       if (inherits(cond, "message")) {
[10:32:52.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.313]                         if (muffled) 
[10:32:52.313]                           invokeRestart("muffleMessage")
[10:32:52.313]                       }
[10:32:52.313]                       else if (inherits(cond, "warning")) {
[10:32:52.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.313]                         if (muffled) 
[10:32:52.313]                           invokeRestart("muffleWarning")
[10:32:52.313]                       }
[10:32:52.313]                       else if (inherits(cond, "condition")) {
[10:32:52.313]                         if (!is.null(pattern)) {
[10:32:52.313]                           computeRestarts <- base::computeRestarts
[10:32:52.313]                           grepl <- base::grepl
[10:32:52.313]                           restarts <- computeRestarts(cond)
[10:32:52.313]                           for (restart in restarts) {
[10:32:52.313]                             name <- restart$name
[10:32:52.313]                             if (is.null(name)) 
[10:32:52.313]                               next
[10:32:52.313]                             if (!grepl(pattern, name)) 
[10:32:52.313]                               next
[10:32:52.313]                             invokeRestart(restart)
[10:32:52.313]                             muffled <- TRUE
[10:32:52.313]                             break
[10:32:52.313]                           }
[10:32:52.313]                         }
[10:32:52.313]                       }
[10:32:52.313]                       invisible(muffled)
[10:32:52.313]                     }
[10:32:52.313]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.313]                   }
[10:32:52.313]                 }
[10:32:52.313]             }
[10:32:52.313]         }))
[10:32:52.313]     }, error = function(ex) {
[10:32:52.313]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.313]                 ...future.rng), started = ...future.startTime, 
[10:32:52.313]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.313]             version = "1.8"), class = "FutureResult")
[10:32:52.313]     }, finally = {
[10:32:52.313]         if (!identical(...future.workdir, getwd())) 
[10:32:52.313]             setwd(...future.workdir)
[10:32:52.313]         {
[10:32:52.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.313]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.313]             }
[10:32:52.313]             base::options(...future.oldOptions)
[10:32:52.313]             if (.Platform$OS.type == "windows") {
[10:32:52.313]                 old_names <- names(...future.oldEnvVars)
[10:32:52.313]                 envs <- base::Sys.getenv()
[10:32:52.313]                 names <- names(envs)
[10:32:52.313]                 common <- intersect(names, old_names)
[10:32:52.313]                 added <- setdiff(names, old_names)
[10:32:52.313]                 removed <- setdiff(old_names, names)
[10:32:52.313]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.313]                   envs[common]]
[10:32:52.313]                 NAMES <- toupper(changed)
[10:32:52.313]                 args <- list()
[10:32:52.313]                 for (kk in seq_along(NAMES)) {
[10:32:52.313]                   name <- changed[[kk]]
[10:32:52.313]                   NAME <- NAMES[[kk]]
[10:32:52.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.313]                     next
[10:32:52.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.313]                 }
[10:32:52.313]                 NAMES <- toupper(added)
[10:32:52.313]                 for (kk in seq_along(NAMES)) {
[10:32:52.313]                   name <- added[[kk]]
[10:32:52.313]                   NAME <- NAMES[[kk]]
[10:32:52.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.313]                     next
[10:32:52.313]                   args[[name]] <- ""
[10:32:52.313]                 }
[10:32:52.313]                 NAMES <- toupper(removed)
[10:32:52.313]                 for (kk in seq_along(NAMES)) {
[10:32:52.313]                   name <- removed[[kk]]
[10:32:52.313]                   NAME <- NAMES[[kk]]
[10:32:52.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.313]                     next
[10:32:52.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.313]                 }
[10:32:52.313]                 if (length(args) > 0) 
[10:32:52.313]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.313]             }
[10:32:52.313]             else {
[10:32:52.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.313]             }
[10:32:52.313]             {
[10:32:52.313]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.313]                   0L) {
[10:32:52.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.313]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.313]                   base::options(opts)
[10:32:52.313]                 }
[10:32:52.313]                 {
[10:32:52.313]                   {
[10:32:52.313]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.313]                     NULL
[10:32:52.313]                   }
[10:32:52.313]                   options(future.plan = NULL)
[10:32:52.313]                   if (is.na(NA_character_)) 
[10:32:52.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.313]                     .init = FALSE)
[10:32:52.313]                 }
[10:32:52.313]             }
[10:32:52.313]         }
[10:32:52.313]     })
[10:32:52.313]     if (TRUE) {
[10:32:52.313]         base::sink(type = "output", split = FALSE)
[10:32:52.313]         if (TRUE) {
[10:32:52.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.313]         }
[10:32:52.313]         else {
[10:32:52.313]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.313]         }
[10:32:52.313]         base::close(...future.stdout)
[10:32:52.313]         ...future.stdout <- NULL
[10:32:52.313]     }
[10:32:52.313]     ...future.result$conditions <- ...future.conditions
[10:32:52.313]     ...future.result$finished <- base::Sys.time()
[10:32:52.313]     ...future.result
[10:32:52.313] }
[10:32:52.317] requestCore(): workers = 2
[10:32:52.319] MulticoreFuture started
[10:32:52.320] - Launch lazy future ... done
[10:32:52.320] run() for ‘MulticoreFuture’ ... done
[10:32:52.321] plan(): Setting new future strategy stack:
[10:32:52.321] getGlobalsAndPackages() ...
[10:32:52.321] Searching for globals...
[10:32:52.321] List of future strategies:
[10:32:52.321] 1. sequential:
[10:32:52.321]    - args: function (..., envir = parent.frame())
[10:32:52.321]    - tweaked: FALSE
[10:32:52.321]    - call: NULL
[10:32:52.322] plan(): nbrOfWorkers() = 1
[10:32:52.322] - globals found: [1] ‘{’
[10:32:52.322] Searching for globals ... DONE
[10:32:52.323] Resolving globals: FALSE
[10:32:52.323] 
[10:32:52.323] 
[10:32:52.323] getGlobalsAndPackages() ... DONE
[10:32:52.324] plan(): Setting new future strategy stack:
[10:32:52.324] run() for ‘Future’ ...
[10:32:52.324] - state: ‘created’
[10:32:52.324] List of future strategies:
[10:32:52.324] 1. multicore:
[10:32:52.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.324]    - tweaked: FALSE
[10:32:52.324]    - call: plan(strategy)
[10:32:52.324] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.329] plan(): nbrOfWorkers() = 2
[10:32:52.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.330]   - Field: ‘label’
[10:32:52.330]   - Field: ‘local’
[10:32:52.330]   - Field: ‘owner’
[10:32:52.330]   - Field: ‘envir’
[10:32:52.330]   - Field: ‘workers’
[10:32:52.330]   - Field: ‘packages’
[10:32:52.330]   - Field: ‘gc’
[10:32:52.331]   - Field: ‘job’
[10:32:52.331]   - Field: ‘conditions’
[10:32:52.331]   - Field: ‘expr’
[10:32:52.331]   - Field: ‘uuid’
[10:32:52.331]   - Field: ‘seed’
[10:32:52.331]   - Field: ‘version’
[10:32:52.331]   - Field: ‘result’
[10:32:52.332]   - Field: ‘asynchronous’
[10:32:52.332]   - Field: ‘calls’
[10:32:52.332]   - Field: ‘globals’
[10:32:52.332]   - Field: ‘stdout’
[10:32:52.332]   - Field: ‘earlySignal’
[10:32:52.332]   - Field: ‘lazy’
[10:32:52.332]   - Field: ‘state’
[10:32:52.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.333] - Launch lazy future ...
[10:32:52.333] Packages needed by the future expression (n = 0): <none>
[10:32:52.333] Packages needed by future strategies (n = 0): <none>
[10:32:52.334] {
[10:32:52.334]     {
[10:32:52.334]         {
[10:32:52.334]             ...future.startTime <- base::Sys.time()
[10:32:52.334]             {
[10:32:52.334]                 {
[10:32:52.334]                   {
[10:32:52.334]                     {
[10:32:52.334]                       base::local({
[10:32:52.334]                         has_future <- base::requireNamespace("future", 
[10:32:52.334]                           quietly = TRUE)
[10:32:52.334]                         if (has_future) {
[10:32:52.334]                           ns <- base::getNamespace("future")
[10:32:52.334]                           version <- ns[[".package"]][["version"]]
[10:32:52.334]                           if (is.null(version)) 
[10:32:52.334]                             version <- utils::packageVersion("future")
[10:32:52.334]                         }
[10:32:52.334]                         else {
[10:32:52.334]                           version <- NULL
[10:32:52.334]                         }
[10:32:52.334]                         if (!has_future || version < "1.8.0") {
[10:32:52.334]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.334]                             "", base::R.version$version.string), 
[10:32:52.334]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.334]                               "release", "version")], collapse = " "), 
[10:32:52.334]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.334]                             info)
[10:32:52.334]                           info <- base::paste(info, collapse = "; ")
[10:32:52.334]                           if (!has_future) {
[10:32:52.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.334]                               info)
[10:32:52.334]                           }
[10:32:52.334]                           else {
[10:32:52.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.334]                               info, version)
[10:32:52.334]                           }
[10:32:52.334]                           base::stop(msg)
[10:32:52.334]                         }
[10:32:52.334]                       })
[10:32:52.334]                     }
[10:32:52.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.334]                     base::options(mc.cores = 1L)
[10:32:52.334]                   }
[10:32:52.334]                   ...future.strategy.old <- future::plan("list")
[10:32:52.334]                   options(future.plan = NULL)
[10:32:52.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.334]                 }
[10:32:52.334]                 ...future.workdir <- getwd()
[10:32:52.334]             }
[10:32:52.334]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.334]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.334]         }
[10:32:52.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.334]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.334]             base::names(...future.oldOptions))
[10:32:52.334]     }
[10:32:52.334]     if (FALSE) {
[10:32:52.334]     }
[10:32:52.334]     else {
[10:32:52.334]         if (TRUE) {
[10:32:52.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.334]                 open = "w")
[10:32:52.334]         }
[10:32:52.334]         else {
[10:32:52.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.334]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.334]         }
[10:32:52.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.334]             base::sink(type = "output", split = FALSE)
[10:32:52.334]             base::close(...future.stdout)
[10:32:52.334]         }, add = TRUE)
[10:32:52.334]     }
[10:32:52.334]     ...future.frame <- base::sys.nframe()
[10:32:52.334]     ...future.conditions <- base::list()
[10:32:52.334]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.334]     if (FALSE) {
[10:32:52.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.334]     }
[10:32:52.334]     ...future.result <- base::tryCatch({
[10:32:52.334]         base::withCallingHandlers({
[10:32:52.334]             ...future.value <- base::withVisible(base::local({
[10:32:52.334]                 withCallingHandlers({
[10:32:52.334]                   {
[10:32:52.334]                     4
[10:32:52.334]                   }
[10:32:52.334]                 }, immediateCondition = function(cond) {
[10:32:52.334]                   save_rds <- function (object, pathname, ...) 
[10:32:52.334]                   {
[10:32:52.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.334]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.334]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.334]                         fi_tmp[["mtime"]])
[10:32:52.334]                     }
[10:32:52.334]                     tryCatch({
[10:32:52.334]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.334]                     }, error = function(ex) {
[10:32:52.334]                       msg <- conditionMessage(ex)
[10:32:52.334]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.334]                         fi_tmp[["mtime"]], msg)
[10:32:52.334]                       ex$message <- msg
[10:32:52.334]                       stop(ex)
[10:32:52.334]                     })
[10:32:52.334]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.334]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.334]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.334]                       fi <- file.info(pathname)
[10:32:52.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.334]                         fi[["size"]], fi[["mtime"]])
[10:32:52.334]                       stop(msg)
[10:32:52.334]                     }
[10:32:52.334]                     invisible(pathname)
[10:32:52.334]                   }
[10:32:52.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.334]                     rootPath = tempdir()) 
[10:32:52.334]                   {
[10:32:52.334]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.334]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.334]                       tmpdir = path, fileext = ".rds")
[10:32:52.334]                     save_rds(obj, file)
[10:32:52.334]                   }
[10:32:52.334]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.334]                   {
[10:32:52.334]                     inherits <- base::inherits
[10:32:52.334]                     invokeRestart <- base::invokeRestart
[10:32:52.334]                     is.null <- base::is.null
[10:32:52.334]                     muffled <- FALSE
[10:32:52.334]                     if (inherits(cond, "message")) {
[10:32:52.334]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.334]                       if (muffled) 
[10:32:52.334]                         invokeRestart("muffleMessage")
[10:32:52.334]                     }
[10:32:52.334]                     else if (inherits(cond, "warning")) {
[10:32:52.334]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.334]                       if (muffled) 
[10:32:52.334]                         invokeRestart("muffleWarning")
[10:32:52.334]                     }
[10:32:52.334]                     else if (inherits(cond, "condition")) {
[10:32:52.334]                       if (!is.null(pattern)) {
[10:32:52.334]                         computeRestarts <- base::computeRestarts
[10:32:52.334]                         grepl <- base::grepl
[10:32:52.334]                         restarts <- computeRestarts(cond)
[10:32:52.334]                         for (restart in restarts) {
[10:32:52.334]                           name <- restart$name
[10:32:52.334]                           if (is.null(name)) 
[10:32:52.334]                             next
[10:32:52.334]                           if (!grepl(pattern, name)) 
[10:32:52.334]                             next
[10:32:52.334]                           invokeRestart(restart)
[10:32:52.334]                           muffled <- TRUE
[10:32:52.334]                           break
[10:32:52.334]                         }
[10:32:52.334]                       }
[10:32:52.334]                     }
[10:32:52.334]                     invisible(muffled)
[10:32:52.334]                   }
[10:32:52.334]                   muffleCondition(cond)
[10:32:52.334]                 })
[10:32:52.334]             }))
[10:32:52.334]             future::FutureResult(value = ...future.value$value, 
[10:32:52.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.334]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.334]                     ...future.globalenv.names))
[10:32:52.334]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.334]         }, condition = base::local({
[10:32:52.334]             c <- base::c
[10:32:52.334]             inherits <- base::inherits
[10:32:52.334]             invokeRestart <- base::invokeRestart
[10:32:52.334]             length <- base::length
[10:32:52.334]             list <- base::list
[10:32:52.334]             seq.int <- base::seq.int
[10:32:52.334]             signalCondition <- base::signalCondition
[10:32:52.334]             sys.calls <- base::sys.calls
[10:32:52.334]             `[[` <- base::`[[`
[10:32:52.334]             `+` <- base::`+`
[10:32:52.334]             `<<-` <- base::`<<-`
[10:32:52.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.334]                   3L)]
[10:32:52.334]             }
[10:32:52.334]             function(cond) {
[10:32:52.334]                 is_error <- inherits(cond, "error")
[10:32:52.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.334]                   NULL)
[10:32:52.334]                 if (is_error) {
[10:32:52.334]                   sessionInformation <- function() {
[10:32:52.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.334]                       search = base::search(), system = base::Sys.info())
[10:32:52.334]                   }
[10:32:52.334]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.334]                     cond$call), session = sessionInformation(), 
[10:32:52.334]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.334]                   signalCondition(cond)
[10:32:52.334]                 }
[10:32:52.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.334]                 "immediateCondition"))) {
[10:32:52.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.334]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.334]                   if (TRUE && !signal) {
[10:32:52.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.334]                     {
[10:32:52.334]                       inherits <- base::inherits
[10:32:52.334]                       invokeRestart <- base::invokeRestart
[10:32:52.334]                       is.null <- base::is.null
[10:32:52.334]                       muffled <- FALSE
[10:32:52.334]                       if (inherits(cond, "message")) {
[10:32:52.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.334]                         if (muffled) 
[10:32:52.334]                           invokeRestart("muffleMessage")
[10:32:52.334]                       }
[10:32:52.334]                       else if (inherits(cond, "warning")) {
[10:32:52.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.334]                         if (muffled) 
[10:32:52.334]                           invokeRestart("muffleWarning")
[10:32:52.334]                       }
[10:32:52.334]                       else if (inherits(cond, "condition")) {
[10:32:52.334]                         if (!is.null(pattern)) {
[10:32:52.334]                           computeRestarts <- base::computeRestarts
[10:32:52.334]                           grepl <- base::grepl
[10:32:52.334]                           restarts <- computeRestarts(cond)
[10:32:52.334]                           for (restart in restarts) {
[10:32:52.334]                             name <- restart$name
[10:32:52.334]                             if (is.null(name)) 
[10:32:52.334]                               next
[10:32:52.334]                             if (!grepl(pattern, name)) 
[10:32:52.334]                               next
[10:32:52.334]                             invokeRestart(restart)
[10:32:52.334]                             muffled <- TRUE
[10:32:52.334]                             break
[10:32:52.334]                           }
[10:32:52.334]                         }
[10:32:52.334]                       }
[10:32:52.334]                       invisible(muffled)
[10:32:52.334]                     }
[10:32:52.334]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.334]                   }
[10:32:52.334]                 }
[10:32:52.334]                 else {
[10:32:52.334]                   if (TRUE) {
[10:32:52.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.334]                     {
[10:32:52.334]                       inherits <- base::inherits
[10:32:52.334]                       invokeRestart <- base::invokeRestart
[10:32:52.334]                       is.null <- base::is.null
[10:32:52.334]                       muffled <- FALSE
[10:32:52.334]                       if (inherits(cond, "message")) {
[10:32:52.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.334]                         if (muffled) 
[10:32:52.334]                           invokeRestart("muffleMessage")
[10:32:52.334]                       }
[10:32:52.334]                       else if (inherits(cond, "warning")) {
[10:32:52.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.334]                         if (muffled) 
[10:32:52.334]                           invokeRestart("muffleWarning")
[10:32:52.334]                       }
[10:32:52.334]                       else if (inherits(cond, "condition")) {
[10:32:52.334]                         if (!is.null(pattern)) {
[10:32:52.334]                           computeRestarts <- base::computeRestarts
[10:32:52.334]                           grepl <- base::grepl
[10:32:52.334]                           restarts <- computeRestarts(cond)
[10:32:52.334]                           for (restart in restarts) {
[10:32:52.334]                             name <- restart$name
[10:32:52.334]                             if (is.null(name)) 
[10:32:52.334]                               next
[10:32:52.334]                             if (!grepl(pattern, name)) 
[10:32:52.334]                               next
[10:32:52.334]                             invokeRestart(restart)
[10:32:52.334]                             muffled <- TRUE
[10:32:52.334]                             break
[10:32:52.334]                           }
[10:32:52.334]                         }
[10:32:52.334]                       }
[10:32:52.334]                       invisible(muffled)
[10:32:52.334]                     }
[10:32:52.334]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.334]                   }
[10:32:52.334]                 }
[10:32:52.334]             }
[10:32:52.334]         }))
[10:32:52.334]     }, error = function(ex) {
[10:32:52.334]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.334]                 ...future.rng), started = ...future.startTime, 
[10:32:52.334]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.334]             version = "1.8"), class = "FutureResult")
[10:32:52.334]     }, finally = {
[10:32:52.334]         if (!identical(...future.workdir, getwd())) 
[10:32:52.334]             setwd(...future.workdir)
[10:32:52.334]         {
[10:32:52.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.334]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.334]             }
[10:32:52.334]             base::options(...future.oldOptions)
[10:32:52.334]             if (.Platform$OS.type == "windows") {
[10:32:52.334]                 old_names <- names(...future.oldEnvVars)
[10:32:52.334]                 envs <- base::Sys.getenv()
[10:32:52.334]                 names <- names(envs)
[10:32:52.334]                 common <- intersect(names, old_names)
[10:32:52.334]                 added <- setdiff(names, old_names)
[10:32:52.334]                 removed <- setdiff(old_names, names)
[10:32:52.334]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.334]                   envs[common]]
[10:32:52.334]                 NAMES <- toupper(changed)
[10:32:52.334]                 args <- list()
[10:32:52.334]                 for (kk in seq_along(NAMES)) {
[10:32:52.334]                   name <- changed[[kk]]
[10:32:52.334]                   NAME <- NAMES[[kk]]
[10:32:52.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.334]                     next
[10:32:52.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.334]                 }
[10:32:52.334]                 NAMES <- toupper(added)
[10:32:52.334]                 for (kk in seq_along(NAMES)) {
[10:32:52.334]                   name <- added[[kk]]
[10:32:52.334]                   NAME <- NAMES[[kk]]
[10:32:52.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.334]                     next
[10:32:52.334]                   args[[name]] <- ""
[10:32:52.334]                 }
[10:32:52.334]                 NAMES <- toupper(removed)
[10:32:52.334]                 for (kk in seq_along(NAMES)) {
[10:32:52.334]                   name <- removed[[kk]]
[10:32:52.334]                   NAME <- NAMES[[kk]]
[10:32:52.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.334]                     next
[10:32:52.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.334]                 }
[10:32:52.334]                 if (length(args) > 0) 
[10:32:52.334]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.334]             }
[10:32:52.334]             else {
[10:32:52.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.334]             }
[10:32:52.334]             {
[10:32:52.334]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.334]                   0L) {
[10:32:52.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.334]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.334]                   base::options(opts)
[10:32:52.334]                 }
[10:32:52.334]                 {
[10:32:52.334]                   {
[10:32:52.334]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.334]                     NULL
[10:32:52.334]                   }
[10:32:52.334]                   options(future.plan = NULL)
[10:32:52.334]                   if (is.na(NA_character_)) 
[10:32:52.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.334]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.334]                     .init = FALSE)
[10:32:52.334]                 }
[10:32:52.334]             }
[10:32:52.334]         }
[10:32:52.334]     })
[10:32:52.334]     if (TRUE) {
[10:32:52.334]         base::sink(type = "output", split = FALSE)
[10:32:52.334]         if (TRUE) {
[10:32:52.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.334]         }
[10:32:52.334]         else {
[10:32:52.334]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.334]         }
[10:32:52.334]         base::close(...future.stdout)
[10:32:52.334]         ...future.stdout <- NULL
[10:32:52.334]     }
[10:32:52.334]     ...future.result$conditions <- ...future.conditions
[10:32:52.334]     ...future.result$finished <- base::Sys.time()
[10:32:52.334]     ...future.result
[10:32:52.334] }
[10:32:52.338] requestCore(): workers = 2
[10:32:52.338] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:52.349] result() for MulticoreFuture ...
[10:32:52.350] result() for MulticoreFuture ...
[10:32:52.350] result() for MulticoreFuture ... done
[10:32:52.350] result() for MulticoreFuture ... done
[10:32:52.351] result() for MulticoreFuture ...
[10:32:52.351] result() for MulticoreFuture ... done
[10:32:52.354] MulticoreFuture started
[10:32:52.354] - Launch lazy future ... done
[10:32:52.355] run() for ‘MulticoreFuture’ ... done
[10:32:52.355] plan(): Setting new future strategy stack:
<environment: 0x5652d2dc6db0> 
[10:32:52.356] List of future strategies:
[10:32:52.356] 1. sequential:
[10:32:52.356]    - args: function (..., envir = parent.frame())
[10:32:52.356]    - tweaked: FALSE
[10:32:52.356]    - call: NULL
[10:32:52.357] plan(): nbrOfWorkers() = 1
<environment: 0x5652d0971720> 
[10:32:52.359] plan(): Setting new future strategy stack:
[10:32:52.360] List of future strategies:
[10:32:52.360] 1. multicore:
[10:32:52.360]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.360]    - tweaked: FALSE
[10:32:52.360]    - call: plan(strategy)
[10:32:52.365] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:52.367] resolve() on environment ...
[10:32:52.367]  recursive: 0
[10:32:52.368]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:52.368] signalConditionsASAP(numeric, pos=1) ...
[10:32:52.368] - nx: 4
[10:32:52.368] - relay: TRUE
[10:32:52.369] - stdout: TRUE
[10:32:52.369] - signal: TRUE
[10:32:52.369] - resignal: FALSE
[10:32:52.369] - force: TRUE
[10:32:52.369] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.370] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.370]  - until=2
[10:32:52.370]  - relaying element #2
[10:32:52.370] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.370] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.370] signalConditionsASAP(NULL, pos=1) ... done
[10:32:52.370]  length: 3 (resolved future 1)
[10:32:52.371] Future #2
[10:32:52.371] result() for MulticoreFuture ...
[10:32:52.371] result() for MulticoreFuture ... done
[10:32:52.371] result() for MulticoreFuture ...
[10:32:52.371] result() for MulticoreFuture ... done
[10:32:52.371] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:52.372] - nx: 4
[10:32:52.372] - relay: TRUE
[10:32:52.372] - stdout: TRUE
[10:32:52.372] - signal: TRUE
[10:32:52.372] - resignal: FALSE
[10:32:52.372] - force: TRUE
[10:32:52.373] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.373] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.373]  - until=2
[10:32:52.373]  - relaying element #2
[10:32:52.373] result() for MulticoreFuture ...
[10:32:52.374] result() for MulticoreFuture ... done
[10:32:52.374] result() for MulticoreFuture ...
[10:32:52.374] result() for MulticoreFuture ... done
[10:32:52.374] result() for MulticoreFuture ...
[10:32:52.375] result() for MulticoreFuture ... done
[10:32:52.375] result() for MulticoreFuture ...
[10:32:52.375] result() for MulticoreFuture ... done
[10:32:52.375] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.375] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.375] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:52.376]  length: 2 (resolved future 2)
[10:32:52.376] Future #3
[10:32:52.376] result() for MulticoreFuture ...
[10:32:52.378] result() for MulticoreFuture ...
[10:32:52.378] result() for MulticoreFuture ... done
[10:32:52.378] result() for MulticoreFuture ... done
[10:32:52.378] result() for MulticoreFuture ...
[10:32:52.378] result() for MulticoreFuture ... done
[10:32:52.379] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:52.379] - nx: 4
[10:32:52.379] - relay: TRUE
[10:32:52.379] - stdout: TRUE
[10:32:52.379] - signal: TRUE
[10:32:52.380] - resignal: FALSE
[10:32:52.380] - force: TRUE
[10:32:52.380] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.380] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.380]  - until=3
[10:32:52.381]  - relaying element #3
[10:32:52.381] result() for MulticoreFuture ...
[10:32:52.381] result() for MulticoreFuture ... done
[10:32:52.381] result() for MulticoreFuture ...
[10:32:52.381] result() for MulticoreFuture ... done
[10:32:52.382] result() for MulticoreFuture ...
[10:32:52.382] result() for MulticoreFuture ... done
[10:32:52.382] result() for MulticoreFuture ...
[10:32:52.382] result() for MulticoreFuture ... done
[10:32:52.382] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.383] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.383] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:52.383]  length: 1 (resolved future 3)
[10:32:52.384] Future #4
[10:32:52.384] result() for MulticoreFuture ...
[10:32:52.385] result() for MulticoreFuture ...
[10:32:52.385] result() for MulticoreFuture ... done
[10:32:52.386] result() for MulticoreFuture ... done
[10:32:52.386] result() for MulticoreFuture ...
[10:32:52.386] result() for MulticoreFuture ... done
[10:32:52.386] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:52.387] - nx: 4
[10:32:52.387] - relay: TRUE
[10:32:52.387] - stdout: TRUE
[10:32:52.387] - signal: TRUE
[10:32:52.387] - resignal: FALSE
[10:32:52.388] - force: TRUE
[10:32:52.388] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.388] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.388]  - until=4
[10:32:52.388]  - relaying element #4
[10:32:52.389] result() for MulticoreFuture ...
[10:32:52.389] result() for MulticoreFuture ... done
[10:32:52.389] result() for MulticoreFuture ...
[10:32:52.389] result() for MulticoreFuture ... done
[10:32:52.389] result() for MulticoreFuture ...
[10:32:52.390] result() for MulticoreFuture ... done
[10:32:52.390] result() for MulticoreFuture ...
[10:32:52.390] result() for MulticoreFuture ... done
[10:32:52.390] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.390] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.391] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:52.391]  length: 0 (resolved future 4)
[10:32:52.391] Relaying remaining futures
[10:32:52.391] signalConditionsASAP(NULL, pos=0) ...
[10:32:52.391] - nx: 4
[10:32:52.392] - relay: TRUE
[10:32:52.392] - stdout: TRUE
[10:32:52.392] - signal: TRUE
[10:32:52.392] - resignal: FALSE
[10:32:52.392] - force: TRUE
[10:32:52.392] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.393] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:52.393] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.393] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.393] signalConditionsASAP(NULL, pos=0) ... done
[10:32:52.394] resolve() on environment ... DONE
[10:32:52.394] result() for MulticoreFuture ...
[10:32:52.394] result() for MulticoreFuture ... done
[10:32:52.394] result() for MulticoreFuture ...
[10:32:52.394] result() for MulticoreFuture ... done
[10:32:52.395] result() for MulticoreFuture ...
[10:32:52.395] result() for MulticoreFuture ... done
[10:32:52.395] result() for MulticoreFuture ...
[10:32:52.395] result() for MulticoreFuture ... done
[10:32:52.396] result() for MulticoreFuture ...
[10:32:52.396] result() for MulticoreFuture ... done
[10:32:52.396] result() for MulticoreFuture ...
[10:32:52.396] result() for MulticoreFuture ... done
<environment: 0x5652cf073a58> 
Dimensions: c(2, 3, 1)
[10:32:52.397] getGlobalsAndPackages() ...
[10:32:52.397] Searching for globals...
[10:32:52.398] 
[10:32:52.398] Searching for globals ... DONE
[10:32:52.398] - globals: [0] <none>
[10:32:52.399] getGlobalsAndPackages() ... DONE
[10:32:52.399] run() for ‘Future’ ...
[10:32:52.399] - state: ‘created’
[10:32:52.400] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.405] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.405] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.406]   - Field: ‘label’
[10:32:52.406]   - Field: ‘local’
[10:32:52.406]   - Field: ‘owner’
[10:32:52.406]   - Field: ‘envir’
[10:32:52.407]   - Field: ‘workers’
[10:32:52.407]   - Field: ‘packages’
[10:32:52.407]   - Field: ‘gc’
[10:32:52.407]   - Field: ‘job’
[10:32:52.407]   - Field: ‘conditions’
[10:32:52.408]   - Field: ‘expr’
[10:32:52.408]   - Field: ‘uuid’
[10:32:52.408]   - Field: ‘seed’
[10:32:52.408]   - Field: ‘version’
[10:32:52.408]   - Field: ‘result’
[10:32:52.409]   - Field: ‘asynchronous’
[10:32:52.409]   - Field: ‘calls’
[10:32:52.409]   - Field: ‘globals’
[10:32:52.409]   - Field: ‘stdout’
[10:32:52.409]   - Field: ‘earlySignal’
[10:32:52.410]   - Field: ‘lazy’
[10:32:52.410]   - Field: ‘state’
[10:32:52.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.410] - Launch lazy future ...
[10:32:52.411] Packages needed by the future expression (n = 0): <none>
[10:32:52.411] Packages needed by future strategies (n = 0): <none>
[10:32:52.412] {
[10:32:52.412]     {
[10:32:52.412]         {
[10:32:52.412]             ...future.startTime <- base::Sys.time()
[10:32:52.412]             {
[10:32:52.412]                 {
[10:32:52.412]                   {
[10:32:52.412]                     {
[10:32:52.412]                       base::local({
[10:32:52.412]                         has_future <- base::requireNamespace("future", 
[10:32:52.412]                           quietly = TRUE)
[10:32:52.412]                         if (has_future) {
[10:32:52.412]                           ns <- base::getNamespace("future")
[10:32:52.412]                           version <- ns[[".package"]][["version"]]
[10:32:52.412]                           if (is.null(version)) 
[10:32:52.412]                             version <- utils::packageVersion("future")
[10:32:52.412]                         }
[10:32:52.412]                         else {
[10:32:52.412]                           version <- NULL
[10:32:52.412]                         }
[10:32:52.412]                         if (!has_future || version < "1.8.0") {
[10:32:52.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.412]                             "", base::R.version$version.string), 
[10:32:52.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.412]                               "release", "version")], collapse = " "), 
[10:32:52.412]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.412]                             info)
[10:32:52.412]                           info <- base::paste(info, collapse = "; ")
[10:32:52.412]                           if (!has_future) {
[10:32:52.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.412]                               info)
[10:32:52.412]                           }
[10:32:52.412]                           else {
[10:32:52.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.412]                               info, version)
[10:32:52.412]                           }
[10:32:52.412]                           base::stop(msg)
[10:32:52.412]                         }
[10:32:52.412]                       })
[10:32:52.412]                     }
[10:32:52.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.412]                     base::options(mc.cores = 1L)
[10:32:52.412]                   }
[10:32:52.412]                   ...future.strategy.old <- future::plan("list")
[10:32:52.412]                   options(future.plan = NULL)
[10:32:52.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.412]                 }
[10:32:52.412]                 ...future.workdir <- getwd()
[10:32:52.412]             }
[10:32:52.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.412]         }
[10:32:52.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.412]             base::names(...future.oldOptions))
[10:32:52.412]     }
[10:32:52.412]     if (FALSE) {
[10:32:52.412]     }
[10:32:52.412]     else {
[10:32:52.412]         if (TRUE) {
[10:32:52.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.412]                 open = "w")
[10:32:52.412]         }
[10:32:52.412]         else {
[10:32:52.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.412]         }
[10:32:52.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.412]             base::sink(type = "output", split = FALSE)
[10:32:52.412]             base::close(...future.stdout)
[10:32:52.412]         }, add = TRUE)
[10:32:52.412]     }
[10:32:52.412]     ...future.frame <- base::sys.nframe()
[10:32:52.412]     ...future.conditions <- base::list()
[10:32:52.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.412]     if (FALSE) {
[10:32:52.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.412]     }
[10:32:52.412]     ...future.result <- base::tryCatch({
[10:32:52.412]         base::withCallingHandlers({
[10:32:52.412]             ...future.value <- base::withVisible(base::local({
[10:32:52.412]                 withCallingHandlers({
[10:32:52.412]                   2
[10:32:52.412]                 }, immediateCondition = function(cond) {
[10:32:52.412]                   save_rds <- function (object, pathname, ...) 
[10:32:52.412]                   {
[10:32:52.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.412]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.412]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.412]                         fi_tmp[["mtime"]])
[10:32:52.412]                     }
[10:32:52.412]                     tryCatch({
[10:32:52.412]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.412]                     }, error = function(ex) {
[10:32:52.412]                       msg <- conditionMessage(ex)
[10:32:52.412]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.412]                         fi_tmp[["mtime"]], msg)
[10:32:52.412]                       ex$message <- msg
[10:32:52.412]                       stop(ex)
[10:32:52.412]                     })
[10:32:52.412]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.412]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.412]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.412]                       fi <- file.info(pathname)
[10:32:52.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.412]                         fi[["size"]], fi[["mtime"]])
[10:32:52.412]                       stop(msg)
[10:32:52.412]                     }
[10:32:52.412]                     invisible(pathname)
[10:32:52.412]                   }
[10:32:52.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.412]                     rootPath = tempdir()) 
[10:32:52.412]                   {
[10:32:52.412]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.412]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.412]                       tmpdir = path, fileext = ".rds")
[10:32:52.412]                     save_rds(obj, file)
[10:32:52.412]                   }
[10:32:52.412]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.412]                   {
[10:32:52.412]                     inherits <- base::inherits
[10:32:52.412]                     invokeRestart <- base::invokeRestart
[10:32:52.412]                     is.null <- base::is.null
[10:32:52.412]                     muffled <- FALSE
[10:32:52.412]                     if (inherits(cond, "message")) {
[10:32:52.412]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.412]                       if (muffled) 
[10:32:52.412]                         invokeRestart("muffleMessage")
[10:32:52.412]                     }
[10:32:52.412]                     else if (inherits(cond, "warning")) {
[10:32:52.412]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.412]                       if (muffled) 
[10:32:52.412]                         invokeRestart("muffleWarning")
[10:32:52.412]                     }
[10:32:52.412]                     else if (inherits(cond, "condition")) {
[10:32:52.412]                       if (!is.null(pattern)) {
[10:32:52.412]                         computeRestarts <- base::computeRestarts
[10:32:52.412]                         grepl <- base::grepl
[10:32:52.412]                         restarts <- computeRestarts(cond)
[10:32:52.412]                         for (restart in restarts) {
[10:32:52.412]                           name <- restart$name
[10:32:52.412]                           if (is.null(name)) 
[10:32:52.412]                             next
[10:32:52.412]                           if (!grepl(pattern, name)) 
[10:32:52.412]                             next
[10:32:52.412]                           invokeRestart(restart)
[10:32:52.412]                           muffled <- TRUE
[10:32:52.412]                           break
[10:32:52.412]                         }
[10:32:52.412]                       }
[10:32:52.412]                     }
[10:32:52.412]                     invisible(muffled)
[10:32:52.412]                   }
[10:32:52.412]                   muffleCondition(cond)
[10:32:52.412]                 })
[10:32:52.412]             }))
[10:32:52.412]             future::FutureResult(value = ...future.value$value, 
[10:32:52.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.412]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.412]                     ...future.globalenv.names))
[10:32:52.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.412]         }, condition = base::local({
[10:32:52.412]             c <- base::c
[10:32:52.412]             inherits <- base::inherits
[10:32:52.412]             invokeRestart <- base::invokeRestart
[10:32:52.412]             length <- base::length
[10:32:52.412]             list <- base::list
[10:32:52.412]             seq.int <- base::seq.int
[10:32:52.412]             signalCondition <- base::signalCondition
[10:32:52.412]             sys.calls <- base::sys.calls
[10:32:52.412]             `[[` <- base::`[[`
[10:32:52.412]             `+` <- base::`+`
[10:32:52.412]             `<<-` <- base::`<<-`
[10:32:52.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.412]                   3L)]
[10:32:52.412]             }
[10:32:52.412]             function(cond) {
[10:32:52.412]                 is_error <- inherits(cond, "error")
[10:32:52.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.412]                   NULL)
[10:32:52.412]                 if (is_error) {
[10:32:52.412]                   sessionInformation <- function() {
[10:32:52.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.412]                       search = base::search(), system = base::Sys.info())
[10:32:52.412]                   }
[10:32:52.412]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.412]                     cond$call), session = sessionInformation(), 
[10:32:52.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.412]                   signalCondition(cond)
[10:32:52.412]                 }
[10:32:52.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.412]                 "immediateCondition"))) {
[10:32:52.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.412]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.412]                   if (TRUE && !signal) {
[10:32:52.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.412]                     {
[10:32:52.412]                       inherits <- base::inherits
[10:32:52.412]                       invokeRestart <- base::invokeRestart
[10:32:52.412]                       is.null <- base::is.null
[10:32:52.412]                       muffled <- FALSE
[10:32:52.412]                       if (inherits(cond, "message")) {
[10:32:52.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.412]                         if (muffled) 
[10:32:52.412]                           invokeRestart("muffleMessage")
[10:32:52.412]                       }
[10:32:52.412]                       else if (inherits(cond, "warning")) {
[10:32:52.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.412]                         if (muffled) 
[10:32:52.412]                           invokeRestart("muffleWarning")
[10:32:52.412]                       }
[10:32:52.412]                       else if (inherits(cond, "condition")) {
[10:32:52.412]                         if (!is.null(pattern)) {
[10:32:52.412]                           computeRestarts <- base::computeRestarts
[10:32:52.412]                           grepl <- base::grepl
[10:32:52.412]                           restarts <- computeRestarts(cond)
[10:32:52.412]                           for (restart in restarts) {
[10:32:52.412]                             name <- restart$name
[10:32:52.412]                             if (is.null(name)) 
[10:32:52.412]                               next
[10:32:52.412]                             if (!grepl(pattern, name)) 
[10:32:52.412]                               next
[10:32:52.412]                             invokeRestart(restart)
[10:32:52.412]                             muffled <- TRUE
[10:32:52.412]                             break
[10:32:52.412]                           }
[10:32:52.412]                         }
[10:32:52.412]                       }
[10:32:52.412]                       invisible(muffled)
[10:32:52.412]                     }
[10:32:52.412]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.412]                   }
[10:32:52.412]                 }
[10:32:52.412]                 else {
[10:32:52.412]                   if (TRUE) {
[10:32:52.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.412]                     {
[10:32:52.412]                       inherits <- base::inherits
[10:32:52.412]                       invokeRestart <- base::invokeRestart
[10:32:52.412]                       is.null <- base::is.null
[10:32:52.412]                       muffled <- FALSE
[10:32:52.412]                       if (inherits(cond, "message")) {
[10:32:52.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.412]                         if (muffled) 
[10:32:52.412]                           invokeRestart("muffleMessage")
[10:32:52.412]                       }
[10:32:52.412]                       else if (inherits(cond, "warning")) {
[10:32:52.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.412]                         if (muffled) 
[10:32:52.412]                           invokeRestart("muffleWarning")
[10:32:52.412]                       }
[10:32:52.412]                       else if (inherits(cond, "condition")) {
[10:32:52.412]                         if (!is.null(pattern)) {
[10:32:52.412]                           computeRestarts <- base::computeRestarts
[10:32:52.412]                           grepl <- base::grepl
[10:32:52.412]                           restarts <- computeRestarts(cond)
[10:32:52.412]                           for (restart in restarts) {
[10:32:52.412]                             name <- restart$name
[10:32:52.412]                             if (is.null(name)) 
[10:32:52.412]                               next
[10:32:52.412]                             if (!grepl(pattern, name)) 
[10:32:52.412]                               next
[10:32:52.412]                             invokeRestart(restart)
[10:32:52.412]                             muffled <- TRUE
[10:32:52.412]                             break
[10:32:52.412]                           }
[10:32:52.412]                         }
[10:32:52.412]                       }
[10:32:52.412]                       invisible(muffled)
[10:32:52.412]                     }
[10:32:52.412]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.412]                   }
[10:32:52.412]                 }
[10:32:52.412]             }
[10:32:52.412]         }))
[10:32:52.412]     }, error = function(ex) {
[10:32:52.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.412]                 ...future.rng), started = ...future.startTime, 
[10:32:52.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.412]             version = "1.8"), class = "FutureResult")
[10:32:52.412]     }, finally = {
[10:32:52.412]         if (!identical(...future.workdir, getwd())) 
[10:32:52.412]             setwd(...future.workdir)
[10:32:52.412]         {
[10:32:52.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.412]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.412]             }
[10:32:52.412]             base::options(...future.oldOptions)
[10:32:52.412]             if (.Platform$OS.type == "windows") {
[10:32:52.412]                 old_names <- names(...future.oldEnvVars)
[10:32:52.412]                 envs <- base::Sys.getenv()
[10:32:52.412]                 names <- names(envs)
[10:32:52.412]                 common <- intersect(names, old_names)
[10:32:52.412]                 added <- setdiff(names, old_names)
[10:32:52.412]                 removed <- setdiff(old_names, names)
[10:32:52.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.412]                   envs[common]]
[10:32:52.412]                 NAMES <- toupper(changed)
[10:32:52.412]                 args <- list()
[10:32:52.412]                 for (kk in seq_along(NAMES)) {
[10:32:52.412]                   name <- changed[[kk]]
[10:32:52.412]                   NAME <- NAMES[[kk]]
[10:32:52.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.412]                     next
[10:32:52.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.412]                 }
[10:32:52.412]                 NAMES <- toupper(added)
[10:32:52.412]                 for (kk in seq_along(NAMES)) {
[10:32:52.412]                   name <- added[[kk]]
[10:32:52.412]                   NAME <- NAMES[[kk]]
[10:32:52.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.412]                     next
[10:32:52.412]                   args[[name]] <- ""
[10:32:52.412]                 }
[10:32:52.412]                 NAMES <- toupper(removed)
[10:32:52.412]                 for (kk in seq_along(NAMES)) {
[10:32:52.412]                   name <- removed[[kk]]
[10:32:52.412]                   NAME <- NAMES[[kk]]
[10:32:52.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.412]                     next
[10:32:52.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.412]                 }
[10:32:52.412]                 if (length(args) > 0) 
[10:32:52.412]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.412]             }
[10:32:52.412]             else {
[10:32:52.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.412]             }
[10:32:52.412]             {
[10:32:52.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.412]                   0L) {
[10:32:52.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.412]                   base::options(opts)
[10:32:52.412]                 }
[10:32:52.412]                 {
[10:32:52.412]                   {
[10:32:52.412]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.412]                     NULL
[10:32:52.412]                   }
[10:32:52.412]                   options(future.plan = NULL)
[10:32:52.412]                   if (is.na(NA_character_)) 
[10:32:52.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.412]                     .init = FALSE)
[10:32:52.412]                 }
[10:32:52.412]             }
[10:32:52.412]         }
[10:32:52.412]     })
[10:32:52.412]     if (TRUE) {
[10:32:52.412]         base::sink(type = "output", split = FALSE)
[10:32:52.412]         if (TRUE) {
[10:32:52.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.412]         }
[10:32:52.412]         else {
[10:32:52.412]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.412]         }
[10:32:52.412]         base::close(...future.stdout)
[10:32:52.412]         ...future.stdout <- NULL
[10:32:52.412]     }
[10:32:52.412]     ...future.result$conditions <- ...future.conditions
[10:32:52.412]     ...future.result$finished <- base::Sys.time()
[10:32:52.412]     ...future.result
[10:32:52.412] }
[10:32:52.414] requestCore(): workers = 2
[10:32:52.417] MulticoreFuture started
[10:32:52.417] - Launch lazy future ... done
[10:32:52.417] run() for ‘MulticoreFuture’ ... done
[10:32:52.418] getGlobalsAndPackages() ...
[10:32:52.418] Searching for globals...
[10:32:52.418] plan(): Setting new future strategy stack:
[10:32:52.418] List of future strategies:
[10:32:52.418] 1. sequential:
[10:32:52.418]    - args: function (..., envir = parent.frame())
[10:32:52.418]    - tweaked: FALSE
[10:32:52.418]    - call: NULL
[10:32:52.419] 
[10:32:52.419] Searching for globals ... DONE
[10:32:52.419] plan(): nbrOfWorkers() = 1
[10:32:52.420] - globals: [0] <none>
[10:32:52.420] getGlobalsAndPackages() ... DONE
[10:32:52.420] run() for ‘Future’ ...
[10:32:52.421] - state: ‘created’
[10:32:52.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.422] plan(): Setting new future strategy stack:
[10:32:52.422] List of future strategies:
[10:32:52.422] 1. multicore:
[10:32:52.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.422]    - tweaked: FALSE
[10:32:52.422]    - call: plan(strategy)
[10:32:52.428] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.428] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.428]   - Field: ‘label’
[10:32:52.428]   - Field: ‘local’
[10:32:52.429]   - Field: ‘owner’
[10:32:52.429]   - Field: ‘envir’
[10:32:52.429]   - Field: ‘workers’
[10:32:52.429]   - Field: ‘packages’
[10:32:52.430]   - Field: ‘gc’
[10:32:52.430]   - Field: ‘job’
[10:32:52.430]   - Field: ‘conditions’
[10:32:52.430]   - Field: ‘expr’
[10:32:52.430] plan(): nbrOfWorkers() = 2
[10:32:52.430]   - Field: ‘uuid’
[10:32:52.431]   - Field: ‘seed’
[10:32:52.431]   - Field: ‘version’
[10:32:52.431]   - Field: ‘result’
[10:32:52.431]   - Field: ‘asynchronous’
[10:32:52.431]   - Field: ‘calls’
[10:32:52.432]   - Field: ‘globals’
[10:32:52.432]   - Field: ‘stdout’
[10:32:52.433]   - Field: ‘earlySignal’
[10:32:52.433]   - Field: ‘lazy’
[10:32:52.433]   - Field: ‘state’
[10:32:52.433] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.434] - Launch lazy future ...
[10:32:52.434] Packages needed by the future expression (n = 0): <none>
[10:32:52.435] Packages needed by future strategies (n = 0): <none>
[10:32:52.436] {
[10:32:52.436]     {
[10:32:52.436]         {
[10:32:52.436]             ...future.startTime <- base::Sys.time()
[10:32:52.436]             {
[10:32:52.436]                 {
[10:32:52.436]                   {
[10:32:52.436]                     {
[10:32:52.436]                       base::local({
[10:32:52.436]                         has_future <- base::requireNamespace("future", 
[10:32:52.436]                           quietly = TRUE)
[10:32:52.436]                         if (has_future) {
[10:32:52.436]                           ns <- base::getNamespace("future")
[10:32:52.436]                           version <- ns[[".package"]][["version"]]
[10:32:52.436]                           if (is.null(version)) 
[10:32:52.436]                             version <- utils::packageVersion("future")
[10:32:52.436]                         }
[10:32:52.436]                         else {
[10:32:52.436]                           version <- NULL
[10:32:52.436]                         }
[10:32:52.436]                         if (!has_future || version < "1.8.0") {
[10:32:52.436]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.436]                             "", base::R.version$version.string), 
[10:32:52.436]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.436]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.436]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.436]                               "release", "version")], collapse = " "), 
[10:32:52.436]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.436]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.436]                             info)
[10:32:52.436]                           info <- base::paste(info, collapse = "; ")
[10:32:52.436]                           if (!has_future) {
[10:32:52.436]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.436]                               info)
[10:32:52.436]                           }
[10:32:52.436]                           else {
[10:32:52.436]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.436]                               info, version)
[10:32:52.436]                           }
[10:32:52.436]                           base::stop(msg)
[10:32:52.436]                         }
[10:32:52.436]                       })
[10:32:52.436]                     }
[10:32:52.436]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.436]                     base::options(mc.cores = 1L)
[10:32:52.436]                   }
[10:32:52.436]                   ...future.strategy.old <- future::plan("list")
[10:32:52.436]                   options(future.plan = NULL)
[10:32:52.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.436]                 }
[10:32:52.436]                 ...future.workdir <- getwd()
[10:32:52.436]             }
[10:32:52.436]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.436]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.436]         }
[10:32:52.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.436]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.436]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.436]             base::names(...future.oldOptions))
[10:32:52.436]     }
[10:32:52.436]     if (FALSE) {
[10:32:52.436]     }
[10:32:52.436]     else {
[10:32:52.436]         if (TRUE) {
[10:32:52.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.436]                 open = "w")
[10:32:52.436]         }
[10:32:52.436]         else {
[10:32:52.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.436]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.436]         }
[10:32:52.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.436]             base::sink(type = "output", split = FALSE)
[10:32:52.436]             base::close(...future.stdout)
[10:32:52.436]         }, add = TRUE)
[10:32:52.436]     }
[10:32:52.436]     ...future.frame <- base::sys.nframe()
[10:32:52.436]     ...future.conditions <- base::list()
[10:32:52.436]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.436]     if (FALSE) {
[10:32:52.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.436]     }
[10:32:52.436]     ...future.result <- base::tryCatch({
[10:32:52.436]         base::withCallingHandlers({
[10:32:52.436]             ...future.value <- base::withVisible(base::local({
[10:32:52.436]                 withCallingHandlers({
[10:32:52.436]                   NULL
[10:32:52.436]                 }, immediateCondition = function(cond) {
[10:32:52.436]                   save_rds <- function (object, pathname, ...) 
[10:32:52.436]                   {
[10:32:52.436]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.436]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.436]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.436]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.436]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.436]                         fi_tmp[["mtime"]])
[10:32:52.436]                     }
[10:32:52.436]                     tryCatch({
[10:32:52.436]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.436]                     }, error = function(ex) {
[10:32:52.436]                       msg <- conditionMessage(ex)
[10:32:52.436]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.436]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.436]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.436]                         fi_tmp[["mtime"]], msg)
[10:32:52.436]                       ex$message <- msg
[10:32:52.436]                       stop(ex)
[10:32:52.436]                     })
[10:32:52.436]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.436]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.436]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.436]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.436]                       fi <- file.info(pathname)
[10:32:52.436]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.436]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.436]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.436]                         fi[["size"]], fi[["mtime"]])
[10:32:52.436]                       stop(msg)
[10:32:52.436]                     }
[10:32:52.436]                     invisible(pathname)
[10:32:52.436]                   }
[10:32:52.436]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.436]                     rootPath = tempdir()) 
[10:32:52.436]                   {
[10:32:52.436]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.436]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.436]                       tmpdir = path, fileext = ".rds")
[10:32:52.436]                     save_rds(obj, file)
[10:32:52.436]                   }
[10:32:52.436]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.436]                   {
[10:32:52.436]                     inherits <- base::inherits
[10:32:52.436]                     invokeRestart <- base::invokeRestart
[10:32:52.436]                     is.null <- base::is.null
[10:32:52.436]                     muffled <- FALSE
[10:32:52.436]                     if (inherits(cond, "message")) {
[10:32:52.436]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.436]                       if (muffled) 
[10:32:52.436]                         invokeRestart("muffleMessage")
[10:32:52.436]                     }
[10:32:52.436]                     else if (inherits(cond, "warning")) {
[10:32:52.436]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.436]                       if (muffled) 
[10:32:52.436]                         invokeRestart("muffleWarning")
[10:32:52.436]                     }
[10:32:52.436]                     else if (inherits(cond, "condition")) {
[10:32:52.436]                       if (!is.null(pattern)) {
[10:32:52.436]                         computeRestarts <- base::computeRestarts
[10:32:52.436]                         grepl <- base::grepl
[10:32:52.436]                         restarts <- computeRestarts(cond)
[10:32:52.436]                         for (restart in restarts) {
[10:32:52.436]                           name <- restart$name
[10:32:52.436]                           if (is.null(name)) 
[10:32:52.436]                             next
[10:32:52.436]                           if (!grepl(pattern, name)) 
[10:32:52.436]                             next
[10:32:52.436]                           invokeRestart(restart)
[10:32:52.436]                           muffled <- TRUE
[10:32:52.436]                           break
[10:32:52.436]                         }
[10:32:52.436]                       }
[10:32:52.436]                     }
[10:32:52.436]                     invisible(muffled)
[10:32:52.436]                   }
[10:32:52.436]                   muffleCondition(cond)
[10:32:52.436]                 })
[10:32:52.436]             }))
[10:32:52.436]             future::FutureResult(value = ...future.value$value, 
[10:32:52.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.436]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.436]                     ...future.globalenv.names))
[10:32:52.436]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.436]         }, condition = base::local({
[10:32:52.436]             c <- base::c
[10:32:52.436]             inherits <- base::inherits
[10:32:52.436]             invokeRestart <- base::invokeRestart
[10:32:52.436]             length <- base::length
[10:32:52.436]             list <- base::list
[10:32:52.436]             seq.int <- base::seq.int
[10:32:52.436]             signalCondition <- base::signalCondition
[10:32:52.436]             sys.calls <- base::sys.calls
[10:32:52.436]             `[[` <- base::`[[`
[10:32:52.436]             `+` <- base::`+`
[10:32:52.436]             `<<-` <- base::`<<-`
[10:32:52.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.436]                   3L)]
[10:32:52.436]             }
[10:32:52.436]             function(cond) {
[10:32:52.436]                 is_error <- inherits(cond, "error")
[10:32:52.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.436]                   NULL)
[10:32:52.436]                 if (is_error) {
[10:32:52.436]                   sessionInformation <- function() {
[10:32:52.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.436]                       search = base::search(), system = base::Sys.info())
[10:32:52.436]                   }
[10:32:52.436]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.436]                     cond$call), session = sessionInformation(), 
[10:32:52.436]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.436]                   signalCondition(cond)
[10:32:52.436]                 }
[10:32:52.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.436]                 "immediateCondition"))) {
[10:32:52.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.436]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.436]                   if (TRUE && !signal) {
[10:32:52.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.436]                     {
[10:32:52.436]                       inherits <- base::inherits
[10:32:52.436]                       invokeRestart <- base::invokeRestart
[10:32:52.436]                       is.null <- base::is.null
[10:32:52.436]                       muffled <- FALSE
[10:32:52.436]                       if (inherits(cond, "message")) {
[10:32:52.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.436]                         if (muffled) 
[10:32:52.436]                           invokeRestart("muffleMessage")
[10:32:52.436]                       }
[10:32:52.436]                       else if (inherits(cond, "warning")) {
[10:32:52.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.436]                         if (muffled) 
[10:32:52.436]                           invokeRestart("muffleWarning")
[10:32:52.436]                       }
[10:32:52.436]                       else if (inherits(cond, "condition")) {
[10:32:52.436]                         if (!is.null(pattern)) {
[10:32:52.436]                           computeRestarts <- base::computeRestarts
[10:32:52.436]                           grepl <- base::grepl
[10:32:52.436]                           restarts <- computeRestarts(cond)
[10:32:52.436]                           for (restart in restarts) {
[10:32:52.436]                             name <- restart$name
[10:32:52.436]                             if (is.null(name)) 
[10:32:52.436]                               next
[10:32:52.436]                             if (!grepl(pattern, name)) 
[10:32:52.436]                               next
[10:32:52.436]                             invokeRestart(restart)
[10:32:52.436]                             muffled <- TRUE
[10:32:52.436]                             break
[10:32:52.436]                           }
[10:32:52.436]                         }
[10:32:52.436]                       }
[10:32:52.436]                       invisible(muffled)
[10:32:52.436]                     }
[10:32:52.436]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.436]                   }
[10:32:52.436]                 }
[10:32:52.436]                 else {
[10:32:52.436]                   if (TRUE) {
[10:32:52.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.436]                     {
[10:32:52.436]                       inherits <- base::inherits
[10:32:52.436]                       invokeRestart <- base::invokeRestart
[10:32:52.436]                       is.null <- base::is.null
[10:32:52.436]                       muffled <- FALSE
[10:32:52.436]                       if (inherits(cond, "message")) {
[10:32:52.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.436]                         if (muffled) 
[10:32:52.436]                           invokeRestart("muffleMessage")
[10:32:52.436]                       }
[10:32:52.436]                       else if (inherits(cond, "warning")) {
[10:32:52.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.436]                         if (muffled) 
[10:32:52.436]                           invokeRestart("muffleWarning")
[10:32:52.436]                       }
[10:32:52.436]                       else if (inherits(cond, "condition")) {
[10:32:52.436]                         if (!is.null(pattern)) {
[10:32:52.436]                           computeRestarts <- base::computeRestarts
[10:32:52.436]                           grepl <- base::grepl
[10:32:52.436]                           restarts <- computeRestarts(cond)
[10:32:52.436]                           for (restart in restarts) {
[10:32:52.436]                             name <- restart$name
[10:32:52.436]                             if (is.null(name)) 
[10:32:52.436]                               next
[10:32:52.436]                             if (!grepl(pattern, name)) 
[10:32:52.436]                               next
[10:32:52.436]                             invokeRestart(restart)
[10:32:52.436]                             muffled <- TRUE
[10:32:52.436]                             break
[10:32:52.436]                           }
[10:32:52.436]                         }
[10:32:52.436]                       }
[10:32:52.436]                       invisible(muffled)
[10:32:52.436]                     }
[10:32:52.436]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.436]                   }
[10:32:52.436]                 }
[10:32:52.436]             }
[10:32:52.436]         }))
[10:32:52.436]     }, error = function(ex) {
[10:32:52.436]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.436]                 ...future.rng), started = ...future.startTime, 
[10:32:52.436]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.436]             version = "1.8"), class = "FutureResult")
[10:32:52.436]     }, finally = {
[10:32:52.436]         if (!identical(...future.workdir, getwd())) 
[10:32:52.436]             setwd(...future.workdir)
[10:32:52.436]         {
[10:32:52.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.436]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.436]             }
[10:32:52.436]             base::options(...future.oldOptions)
[10:32:52.436]             if (.Platform$OS.type == "windows") {
[10:32:52.436]                 old_names <- names(...future.oldEnvVars)
[10:32:52.436]                 envs <- base::Sys.getenv()
[10:32:52.436]                 names <- names(envs)
[10:32:52.436]                 common <- intersect(names, old_names)
[10:32:52.436]                 added <- setdiff(names, old_names)
[10:32:52.436]                 removed <- setdiff(old_names, names)
[10:32:52.436]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.436]                   envs[common]]
[10:32:52.436]                 NAMES <- toupper(changed)
[10:32:52.436]                 args <- list()
[10:32:52.436]                 for (kk in seq_along(NAMES)) {
[10:32:52.436]                   name <- changed[[kk]]
[10:32:52.436]                   NAME <- NAMES[[kk]]
[10:32:52.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.436]                     next
[10:32:52.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.436]                 }
[10:32:52.436]                 NAMES <- toupper(added)
[10:32:52.436]                 for (kk in seq_along(NAMES)) {
[10:32:52.436]                   name <- added[[kk]]
[10:32:52.436]                   NAME <- NAMES[[kk]]
[10:32:52.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.436]                     next
[10:32:52.436]                   args[[name]] <- ""
[10:32:52.436]                 }
[10:32:52.436]                 NAMES <- toupper(removed)
[10:32:52.436]                 for (kk in seq_along(NAMES)) {
[10:32:52.436]                   name <- removed[[kk]]
[10:32:52.436]                   NAME <- NAMES[[kk]]
[10:32:52.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.436]                     next
[10:32:52.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.436]                 }
[10:32:52.436]                 if (length(args) > 0) 
[10:32:52.436]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.436]             }
[10:32:52.436]             else {
[10:32:52.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.436]             }
[10:32:52.436]             {
[10:32:52.436]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.436]                   0L) {
[10:32:52.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.436]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.436]                   base::options(opts)
[10:32:52.436]                 }
[10:32:52.436]                 {
[10:32:52.436]                   {
[10:32:52.436]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.436]                     NULL
[10:32:52.436]                   }
[10:32:52.436]                   options(future.plan = NULL)
[10:32:52.436]                   if (is.na(NA_character_)) 
[10:32:52.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.436]                     .init = FALSE)
[10:32:52.436]                 }
[10:32:52.436]             }
[10:32:52.436]         }
[10:32:52.436]     })
[10:32:52.436]     if (TRUE) {
[10:32:52.436]         base::sink(type = "output", split = FALSE)
[10:32:52.436]         if (TRUE) {
[10:32:52.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.436]         }
[10:32:52.436]         else {
[10:32:52.436]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.436]         }
[10:32:52.436]         base::close(...future.stdout)
[10:32:52.436]         ...future.stdout <- NULL
[10:32:52.436]     }
[10:32:52.436]     ...future.result$conditions <- ...future.conditions
[10:32:52.436]     ...future.result$finished <- base::Sys.time()
[10:32:52.436]     ...future.result
[10:32:52.436] }
[10:32:52.440] requestCore(): workers = 2
[10:32:52.444] MulticoreFuture started
[10:32:52.445] - Launch lazy future ... done
[10:32:52.445] run() for ‘MulticoreFuture’ ... done
[10:32:52.445] plan(): Setting new future strategy stack:
[10:32:52.446] getGlobalsAndPackages() ...
[10:32:52.446] List of future strategies:
[10:32:52.446] 1. sequential:
[10:32:52.446]    - args: function (..., envir = parent.frame())
[10:32:52.446]    - tweaked: FALSE
[10:32:52.446]    - call: NULL
[10:32:52.446] Searching for globals...
[10:32:52.447] plan(): nbrOfWorkers() = 1
[10:32:52.448] - globals found: [1] ‘{’
[10:32:52.448] Searching for globals ... DONE
[10:32:52.448] plan(): Setting new future strategy stack:
[10:32:52.449] Resolving globals: FALSE
[10:32:52.449] List of future strategies:
[10:32:52.449] 1. multicore:
[10:32:52.449]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.449]    - tweaked: FALSE
[10:32:52.449]    - call: plan(strategy)
[10:32:52.449] 
[10:32:52.449] 
[10:32:52.450] getGlobalsAndPackages() ... DONE
[10:32:52.450] run() for ‘Future’ ...
[10:32:52.450] - state: ‘created’
[10:32:52.451] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.454] plan(): nbrOfWorkers() = 2
[10:32:52.457] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.457]   - Field: ‘label’
[10:32:52.457]   - Field: ‘local’
[10:32:52.458]   - Field: ‘owner’
[10:32:52.458]   - Field: ‘envir’
[10:32:52.458]   - Field: ‘workers’
[10:32:52.458]   - Field: ‘packages’
[10:32:52.458]   - Field: ‘gc’
[10:32:52.458]   - Field: ‘job’
[10:32:52.459]   - Field: ‘conditions’
[10:32:52.459]   - Field: ‘expr’
[10:32:52.459]   - Field: ‘uuid’
[10:32:52.459]   - Field: ‘seed’
[10:32:52.459]   - Field: ‘version’
[10:32:52.459]   - Field: ‘result’
[10:32:52.459]   - Field: ‘asynchronous’
[10:32:52.460]   - Field: ‘calls’
[10:32:52.460]   - Field: ‘globals’
[10:32:52.460]   - Field: ‘stdout’
[10:32:52.460]   - Field: ‘earlySignal’
[10:32:52.460]   - Field: ‘lazy’
[10:32:52.460]   - Field: ‘state’
[10:32:52.460] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.460] - Launch lazy future ...
[10:32:52.461] Packages needed by the future expression (n = 0): <none>
[10:32:52.461] Packages needed by future strategies (n = 0): <none>
[10:32:52.462] {
[10:32:52.462]     {
[10:32:52.462]         {
[10:32:52.462]             ...future.startTime <- base::Sys.time()
[10:32:52.462]             {
[10:32:52.462]                 {
[10:32:52.462]                   {
[10:32:52.462]                     {
[10:32:52.462]                       base::local({
[10:32:52.462]                         has_future <- base::requireNamespace("future", 
[10:32:52.462]                           quietly = TRUE)
[10:32:52.462]                         if (has_future) {
[10:32:52.462]                           ns <- base::getNamespace("future")
[10:32:52.462]                           version <- ns[[".package"]][["version"]]
[10:32:52.462]                           if (is.null(version)) 
[10:32:52.462]                             version <- utils::packageVersion("future")
[10:32:52.462]                         }
[10:32:52.462]                         else {
[10:32:52.462]                           version <- NULL
[10:32:52.462]                         }
[10:32:52.462]                         if (!has_future || version < "1.8.0") {
[10:32:52.462]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.462]                             "", base::R.version$version.string), 
[10:32:52.462]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.462]                               "release", "version")], collapse = " "), 
[10:32:52.462]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.462]                             info)
[10:32:52.462]                           info <- base::paste(info, collapse = "; ")
[10:32:52.462]                           if (!has_future) {
[10:32:52.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.462]                               info)
[10:32:52.462]                           }
[10:32:52.462]                           else {
[10:32:52.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.462]                               info, version)
[10:32:52.462]                           }
[10:32:52.462]                           base::stop(msg)
[10:32:52.462]                         }
[10:32:52.462]                       })
[10:32:52.462]                     }
[10:32:52.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.462]                     base::options(mc.cores = 1L)
[10:32:52.462]                   }
[10:32:52.462]                   ...future.strategy.old <- future::plan("list")
[10:32:52.462]                   options(future.plan = NULL)
[10:32:52.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.462]                 }
[10:32:52.462]                 ...future.workdir <- getwd()
[10:32:52.462]             }
[10:32:52.462]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.462]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.462]         }
[10:32:52.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.462]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.462]             base::names(...future.oldOptions))
[10:32:52.462]     }
[10:32:52.462]     if (FALSE) {
[10:32:52.462]     }
[10:32:52.462]     else {
[10:32:52.462]         if (TRUE) {
[10:32:52.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.462]                 open = "w")
[10:32:52.462]         }
[10:32:52.462]         else {
[10:32:52.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.462]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.462]         }
[10:32:52.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.462]             base::sink(type = "output", split = FALSE)
[10:32:52.462]             base::close(...future.stdout)
[10:32:52.462]         }, add = TRUE)
[10:32:52.462]     }
[10:32:52.462]     ...future.frame <- base::sys.nframe()
[10:32:52.462]     ...future.conditions <- base::list()
[10:32:52.462]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.462]     if (FALSE) {
[10:32:52.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.462]     }
[10:32:52.462]     ...future.result <- base::tryCatch({
[10:32:52.462]         base::withCallingHandlers({
[10:32:52.462]             ...future.value <- base::withVisible(base::local({
[10:32:52.462]                 withCallingHandlers({
[10:32:52.462]                   {
[10:32:52.462]                     4
[10:32:52.462]                   }
[10:32:52.462]                 }, immediateCondition = function(cond) {
[10:32:52.462]                   save_rds <- function (object, pathname, ...) 
[10:32:52.462]                   {
[10:32:52.462]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.462]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.462]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.462]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.462]                         fi_tmp[["mtime"]])
[10:32:52.462]                     }
[10:32:52.462]                     tryCatch({
[10:32:52.462]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.462]                     }, error = function(ex) {
[10:32:52.462]                       msg <- conditionMessage(ex)
[10:32:52.462]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.462]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.462]                         fi_tmp[["mtime"]], msg)
[10:32:52.462]                       ex$message <- msg
[10:32:52.462]                       stop(ex)
[10:32:52.462]                     })
[10:32:52.462]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.462]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.462]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.462]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.462]                       fi <- file.info(pathname)
[10:32:52.462]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.462]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.462]                         fi[["size"]], fi[["mtime"]])
[10:32:52.462]                       stop(msg)
[10:32:52.462]                     }
[10:32:52.462]                     invisible(pathname)
[10:32:52.462]                   }
[10:32:52.462]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.462]                     rootPath = tempdir()) 
[10:32:52.462]                   {
[10:32:52.462]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.462]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.462]                       tmpdir = path, fileext = ".rds")
[10:32:52.462]                     save_rds(obj, file)
[10:32:52.462]                   }
[10:32:52.462]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.462]                   {
[10:32:52.462]                     inherits <- base::inherits
[10:32:52.462]                     invokeRestart <- base::invokeRestart
[10:32:52.462]                     is.null <- base::is.null
[10:32:52.462]                     muffled <- FALSE
[10:32:52.462]                     if (inherits(cond, "message")) {
[10:32:52.462]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.462]                       if (muffled) 
[10:32:52.462]                         invokeRestart("muffleMessage")
[10:32:52.462]                     }
[10:32:52.462]                     else if (inherits(cond, "warning")) {
[10:32:52.462]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.462]                       if (muffled) 
[10:32:52.462]                         invokeRestart("muffleWarning")
[10:32:52.462]                     }
[10:32:52.462]                     else if (inherits(cond, "condition")) {
[10:32:52.462]                       if (!is.null(pattern)) {
[10:32:52.462]                         computeRestarts <- base::computeRestarts
[10:32:52.462]                         grepl <- base::grepl
[10:32:52.462]                         restarts <- computeRestarts(cond)
[10:32:52.462]                         for (restart in restarts) {
[10:32:52.462]                           name <- restart$name
[10:32:52.462]                           if (is.null(name)) 
[10:32:52.462]                             next
[10:32:52.462]                           if (!grepl(pattern, name)) 
[10:32:52.462]                             next
[10:32:52.462]                           invokeRestart(restart)
[10:32:52.462]                           muffled <- TRUE
[10:32:52.462]                           break
[10:32:52.462]                         }
[10:32:52.462]                       }
[10:32:52.462]                     }
[10:32:52.462]                     invisible(muffled)
[10:32:52.462]                   }
[10:32:52.462]                   muffleCondition(cond)
[10:32:52.462]                 })
[10:32:52.462]             }))
[10:32:52.462]             future::FutureResult(value = ...future.value$value, 
[10:32:52.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.462]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.462]                     ...future.globalenv.names))
[10:32:52.462]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.462]         }, condition = base::local({
[10:32:52.462]             c <- base::c
[10:32:52.462]             inherits <- base::inherits
[10:32:52.462]             invokeRestart <- base::invokeRestart
[10:32:52.462]             length <- base::length
[10:32:52.462]             list <- base::list
[10:32:52.462]             seq.int <- base::seq.int
[10:32:52.462]             signalCondition <- base::signalCondition
[10:32:52.462]             sys.calls <- base::sys.calls
[10:32:52.462]             `[[` <- base::`[[`
[10:32:52.462]             `+` <- base::`+`
[10:32:52.462]             `<<-` <- base::`<<-`
[10:32:52.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.462]                   3L)]
[10:32:52.462]             }
[10:32:52.462]             function(cond) {
[10:32:52.462]                 is_error <- inherits(cond, "error")
[10:32:52.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.462]                   NULL)
[10:32:52.462]                 if (is_error) {
[10:32:52.462]                   sessionInformation <- function() {
[10:32:52.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.462]                       search = base::search(), system = base::Sys.info())
[10:32:52.462]                   }
[10:32:52.462]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.462]                     cond$call), session = sessionInformation(), 
[10:32:52.462]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.462]                   signalCondition(cond)
[10:32:52.462]                 }
[10:32:52.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.462]                 "immediateCondition"))) {
[10:32:52.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.462]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.462]                   if (TRUE && !signal) {
[10:32:52.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.462]                     {
[10:32:52.462]                       inherits <- base::inherits
[10:32:52.462]                       invokeRestart <- base::invokeRestart
[10:32:52.462]                       is.null <- base::is.null
[10:32:52.462]                       muffled <- FALSE
[10:32:52.462]                       if (inherits(cond, "message")) {
[10:32:52.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.462]                         if (muffled) 
[10:32:52.462]                           invokeRestart("muffleMessage")
[10:32:52.462]                       }
[10:32:52.462]                       else if (inherits(cond, "warning")) {
[10:32:52.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.462]                         if (muffled) 
[10:32:52.462]                           invokeRestart("muffleWarning")
[10:32:52.462]                       }
[10:32:52.462]                       else if (inherits(cond, "condition")) {
[10:32:52.462]                         if (!is.null(pattern)) {
[10:32:52.462]                           computeRestarts <- base::computeRestarts
[10:32:52.462]                           grepl <- base::grepl
[10:32:52.462]                           restarts <- computeRestarts(cond)
[10:32:52.462]                           for (restart in restarts) {
[10:32:52.462]                             name <- restart$name
[10:32:52.462]                             if (is.null(name)) 
[10:32:52.462]                               next
[10:32:52.462]                             if (!grepl(pattern, name)) 
[10:32:52.462]                               next
[10:32:52.462]                             invokeRestart(restart)
[10:32:52.462]                             muffled <- TRUE
[10:32:52.462]                             break
[10:32:52.462]                           }
[10:32:52.462]                         }
[10:32:52.462]                       }
[10:32:52.462]                       invisible(muffled)
[10:32:52.462]                     }
[10:32:52.462]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.462]                   }
[10:32:52.462]                 }
[10:32:52.462]                 else {
[10:32:52.462]                   if (TRUE) {
[10:32:52.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.462]                     {
[10:32:52.462]                       inherits <- base::inherits
[10:32:52.462]                       invokeRestart <- base::invokeRestart
[10:32:52.462]                       is.null <- base::is.null
[10:32:52.462]                       muffled <- FALSE
[10:32:52.462]                       if (inherits(cond, "message")) {
[10:32:52.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.462]                         if (muffled) 
[10:32:52.462]                           invokeRestart("muffleMessage")
[10:32:52.462]                       }
[10:32:52.462]                       else if (inherits(cond, "warning")) {
[10:32:52.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.462]                         if (muffled) 
[10:32:52.462]                           invokeRestart("muffleWarning")
[10:32:52.462]                       }
[10:32:52.462]                       else if (inherits(cond, "condition")) {
[10:32:52.462]                         if (!is.null(pattern)) {
[10:32:52.462]                           computeRestarts <- base::computeRestarts
[10:32:52.462]                           grepl <- base::grepl
[10:32:52.462]                           restarts <- computeRestarts(cond)
[10:32:52.462]                           for (restart in restarts) {
[10:32:52.462]                             name <- restart$name
[10:32:52.462]                             if (is.null(name)) 
[10:32:52.462]                               next
[10:32:52.462]                             if (!grepl(pattern, name)) 
[10:32:52.462]                               next
[10:32:52.462]                             invokeRestart(restart)
[10:32:52.462]                             muffled <- TRUE
[10:32:52.462]                             break
[10:32:52.462]                           }
[10:32:52.462]                         }
[10:32:52.462]                       }
[10:32:52.462]                       invisible(muffled)
[10:32:52.462]                     }
[10:32:52.462]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.462]                   }
[10:32:52.462]                 }
[10:32:52.462]             }
[10:32:52.462]         }))
[10:32:52.462]     }, error = function(ex) {
[10:32:52.462]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.462]                 ...future.rng), started = ...future.startTime, 
[10:32:52.462]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.462]             version = "1.8"), class = "FutureResult")
[10:32:52.462]     }, finally = {
[10:32:52.462]         if (!identical(...future.workdir, getwd())) 
[10:32:52.462]             setwd(...future.workdir)
[10:32:52.462]         {
[10:32:52.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.462]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.462]             }
[10:32:52.462]             base::options(...future.oldOptions)
[10:32:52.462]             if (.Platform$OS.type == "windows") {
[10:32:52.462]                 old_names <- names(...future.oldEnvVars)
[10:32:52.462]                 envs <- base::Sys.getenv()
[10:32:52.462]                 names <- names(envs)
[10:32:52.462]                 common <- intersect(names, old_names)
[10:32:52.462]                 added <- setdiff(names, old_names)
[10:32:52.462]                 removed <- setdiff(old_names, names)
[10:32:52.462]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.462]                   envs[common]]
[10:32:52.462]                 NAMES <- toupper(changed)
[10:32:52.462]                 args <- list()
[10:32:52.462]                 for (kk in seq_along(NAMES)) {
[10:32:52.462]                   name <- changed[[kk]]
[10:32:52.462]                   NAME <- NAMES[[kk]]
[10:32:52.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.462]                     next
[10:32:52.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.462]                 }
[10:32:52.462]                 NAMES <- toupper(added)
[10:32:52.462]                 for (kk in seq_along(NAMES)) {
[10:32:52.462]                   name <- added[[kk]]
[10:32:52.462]                   NAME <- NAMES[[kk]]
[10:32:52.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.462]                     next
[10:32:52.462]                   args[[name]] <- ""
[10:32:52.462]                 }
[10:32:52.462]                 NAMES <- toupper(removed)
[10:32:52.462]                 for (kk in seq_along(NAMES)) {
[10:32:52.462]                   name <- removed[[kk]]
[10:32:52.462]                   NAME <- NAMES[[kk]]
[10:32:52.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.462]                     next
[10:32:52.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.462]                 }
[10:32:52.462]                 if (length(args) > 0) 
[10:32:52.462]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.462]             }
[10:32:52.462]             else {
[10:32:52.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.462]             }
[10:32:52.462]             {
[10:32:52.462]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.462]                   0L) {
[10:32:52.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.462]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.462]                   base::options(opts)
[10:32:52.462]                 }
[10:32:52.462]                 {
[10:32:52.462]                   {
[10:32:52.462]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.462]                     NULL
[10:32:52.462]                   }
[10:32:52.462]                   options(future.plan = NULL)
[10:32:52.462]                   if (is.na(NA_character_)) 
[10:32:52.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.462]                     .init = FALSE)
[10:32:52.462]                 }
[10:32:52.462]             }
[10:32:52.462]         }
[10:32:52.462]     })
[10:32:52.462]     if (TRUE) {
[10:32:52.462]         base::sink(type = "output", split = FALSE)
[10:32:52.462]         if (TRUE) {
[10:32:52.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.462]         }
[10:32:52.462]         else {
[10:32:52.462]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.462]         }
[10:32:52.462]         base::close(...future.stdout)
[10:32:52.462]         ...future.stdout <- NULL
[10:32:52.462]     }
[10:32:52.462]     ...future.result$conditions <- ...future.conditions
[10:32:52.462]     ...future.result$finished <- base::Sys.time()
[10:32:52.462]     ...future.result
[10:32:52.462] }
[10:32:52.465] requestCore(): workers = 2
[10:32:52.465] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:52.476] result() for MulticoreFuture ...
[10:32:52.477] result() for MulticoreFuture ...
[10:32:52.477] result() for MulticoreFuture ... done
[10:32:52.477] result() for MulticoreFuture ... done
[10:32:52.478] result() for MulticoreFuture ...
[10:32:52.478] result() for MulticoreFuture ... done
[10:32:52.480] MulticoreFuture started
[10:32:52.481] - Launch lazy future ... done
[10:32:52.481] run() for ‘MulticoreFuture’ ... done
[10:32:52.482] plan(): Setting new future strategy stack:
<environment: 0x5652d1f20160> 
[10:32:52.482] List of future strategies:
[10:32:52.482] 1. sequential:
[10:32:52.482]    - args: function (..., envir = parent.frame())
[10:32:52.482]    - tweaked: FALSE
[10:32:52.482]    - call: NULL
[10:32:52.483] plan(): nbrOfWorkers() = 1
<environment: 0x5652d2abe428> 
[10:32:52.486] plan(): Setting new future strategy stack:
[10:32:52.486] List of future strategies:
[10:32:52.486] 1. multicore:
[10:32:52.486]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.486]    - tweaked: FALSE
[10:32:52.486]    - call: plan(strategy)
[10:32:52.491] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:52.493] resolve() on environment ...
[10:32:52.493]  recursive: 0
[10:32:52.494]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:52.494] signalConditionsASAP(numeric, pos=1) ...
[10:32:52.494] - nx: 4
[10:32:52.494] - relay: TRUE
[10:32:52.495] - stdout: TRUE
[10:32:52.495] - signal: TRUE
[10:32:52.495] - resignal: FALSE
[10:32:52.495] - force: TRUE
[10:32:52.495] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.495] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.495]  - until=2
[10:32:52.496]  - relaying element #2
[10:32:52.496] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.496] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.496] signalConditionsASAP(NULL, pos=1) ... done
[10:32:52.496]  length: 3 (resolved future 1)
[10:32:52.496] Future #2
[10:32:52.496] result() for MulticoreFuture ...
[10:32:52.497] result() for MulticoreFuture ... done
[10:32:52.497] result() for MulticoreFuture ...
[10:32:52.497] result() for MulticoreFuture ... done
[10:32:52.497] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:52.497] - nx: 4
[10:32:52.497] - relay: TRUE
[10:32:52.497] - stdout: TRUE
[10:32:52.498] - signal: TRUE
[10:32:52.498] - resignal: FALSE
[10:32:52.498] - force: TRUE
[10:32:52.498] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.498] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.498]  - until=2
[10:32:52.498]  - relaying element #2
[10:32:52.498] result() for MulticoreFuture ...
[10:32:52.499] result() for MulticoreFuture ... done
[10:32:52.499] result() for MulticoreFuture ...
[10:32:52.499] result() for MulticoreFuture ... done
[10:32:52.499] result() for MulticoreFuture ...
[10:32:52.499] result() for MulticoreFuture ... done
[10:32:52.499] result() for MulticoreFuture ...
[10:32:52.499] result() for MulticoreFuture ... done
[10:32:52.499] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.500] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.500] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:52.500]  length: 2 (resolved future 2)
[10:32:52.500] Future #3
[10:32:52.500] result() for MulticoreFuture ...
[10:32:52.501] result() for MulticoreFuture ...
[10:32:52.501] result() for MulticoreFuture ... done
[10:32:52.502] result() for MulticoreFuture ... done
[10:32:52.502] result() for MulticoreFuture ...
[10:32:52.502] result() for MulticoreFuture ... done
[10:32:52.502] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:52.502] - nx: 4
[10:32:52.502] - relay: TRUE
[10:32:52.503] - stdout: TRUE
[10:32:52.503] - signal: TRUE
[10:32:52.503] - resignal: FALSE
[10:32:52.503] - force: TRUE
[10:32:52.503] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.503] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.504]  - until=3
[10:32:52.504]  - relaying element #3
[10:32:52.504] result() for MulticoreFuture ...
[10:32:52.504] result() for MulticoreFuture ... done
[10:32:52.504] result() for MulticoreFuture ...
[10:32:52.504] result() for MulticoreFuture ... done
[10:32:52.505] result() for MulticoreFuture ...
[10:32:52.505] result() for MulticoreFuture ... done
[10:32:52.505] result() for MulticoreFuture ...
[10:32:52.505] result() for MulticoreFuture ... done
[10:32:52.505] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.505] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.506] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:52.506]  length: 1 (resolved future 3)
[10:32:52.506] Future #4
[10:32:52.506] result() for MulticoreFuture ...
[10:32:52.507] result() for MulticoreFuture ...
[10:32:52.507] result() for MulticoreFuture ... done
[10:32:52.507] result() for MulticoreFuture ... done
[10:32:52.507] result() for MulticoreFuture ...
[10:32:52.507] result() for MulticoreFuture ... done
[10:32:52.507] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:52.507] - nx: 4
[10:32:52.515] - relay: TRUE
[10:32:52.515] - stdout: TRUE
[10:32:52.515] - signal: TRUE
[10:32:52.515] - resignal: FALSE
[10:32:52.515] - force: TRUE
[10:32:52.515] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.515] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.515]  - until=4
[10:32:52.515]  - relaying element #4
[10:32:52.515] result() for MulticoreFuture ...
[10:32:52.516] result() for MulticoreFuture ... done
[10:32:52.516] result() for MulticoreFuture ...
[10:32:52.516] result() for MulticoreFuture ... done
[10:32:52.516] result() for MulticoreFuture ...
[10:32:52.516] result() for MulticoreFuture ... done
[10:32:52.516] result() for MulticoreFuture ...
[10:32:52.516] result() for MulticoreFuture ... done
[10:32:52.516] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.516] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.516] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:52.517]  length: 0 (resolved future 4)
[10:32:52.517] Relaying remaining futures
[10:32:52.517] signalConditionsASAP(NULL, pos=0) ...
[10:32:52.517] - nx: 4
[10:32:52.517] - relay: TRUE
[10:32:52.517] - stdout: TRUE
[10:32:52.517] - signal: TRUE
[10:32:52.517] - resignal: FALSE
[10:32:52.517] - force: TRUE
[10:32:52.517] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.518] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:52.518] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.518] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.518] signalConditionsASAP(NULL, pos=0) ... done
[10:32:52.518] resolve() on environment ... DONE
[10:32:52.518] result() for MulticoreFuture ...
[10:32:52.518] result() for MulticoreFuture ... done
[10:32:52.518] result() for MulticoreFuture ...
[10:32:52.518] result() for MulticoreFuture ... done
[10:32:52.519] result() for MulticoreFuture ...
[10:32:52.519] result() for MulticoreFuture ... done
[10:32:52.519] result() for MulticoreFuture ...
[10:32:52.519] result() for MulticoreFuture ... done
[10:32:52.519] result() for MulticoreFuture ...
[10:32:52.519] result() for MulticoreFuture ... done
[10:32:52.519] result() for MulticoreFuture ...
[10:32:52.519] result() for MulticoreFuture ... done
<environment: 0x5652d2b74b58> 
Dimensions: c(2, 1, 3, 1)
[10:32:52.520] getGlobalsAndPackages() ...
[10:32:52.520] Searching for globals...
[10:32:52.520] 
[10:32:52.520] Searching for globals ... DONE
[10:32:52.521] - globals: [0] <none>
[10:32:52.521] getGlobalsAndPackages() ... DONE
[10:32:52.521] run() for ‘Future’ ...
[10:32:52.521] - state: ‘created’
[10:32:52.521] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.525] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.525]   - Field: ‘label’
[10:32:52.525]   - Field: ‘local’
[10:32:52.526]   - Field: ‘owner’
[10:32:52.526]   - Field: ‘envir’
[10:32:52.526]   - Field: ‘workers’
[10:32:52.526]   - Field: ‘packages’
[10:32:52.526]   - Field: ‘gc’
[10:32:52.526]   - Field: ‘job’
[10:32:52.526]   - Field: ‘conditions’
[10:32:52.526]   - Field: ‘expr’
[10:32:52.526]   - Field: ‘uuid’
[10:32:52.526]   - Field: ‘seed’
[10:32:52.527]   - Field: ‘version’
[10:32:52.527]   - Field: ‘result’
[10:32:52.527]   - Field: ‘asynchronous’
[10:32:52.527]   - Field: ‘calls’
[10:32:52.527]   - Field: ‘globals’
[10:32:52.527]   - Field: ‘stdout’
[10:32:52.527]   - Field: ‘earlySignal’
[10:32:52.527]   - Field: ‘lazy’
[10:32:52.527]   - Field: ‘state’
[10:32:52.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.528] - Launch lazy future ...
[10:32:52.528] Packages needed by the future expression (n = 0): <none>
[10:32:52.528] Packages needed by future strategies (n = 0): <none>
[10:32:52.529] {
[10:32:52.529]     {
[10:32:52.529]         {
[10:32:52.529]             ...future.startTime <- base::Sys.time()
[10:32:52.529]             {
[10:32:52.529]                 {
[10:32:52.529]                   {
[10:32:52.529]                     {
[10:32:52.529]                       base::local({
[10:32:52.529]                         has_future <- base::requireNamespace("future", 
[10:32:52.529]                           quietly = TRUE)
[10:32:52.529]                         if (has_future) {
[10:32:52.529]                           ns <- base::getNamespace("future")
[10:32:52.529]                           version <- ns[[".package"]][["version"]]
[10:32:52.529]                           if (is.null(version)) 
[10:32:52.529]                             version <- utils::packageVersion("future")
[10:32:52.529]                         }
[10:32:52.529]                         else {
[10:32:52.529]                           version <- NULL
[10:32:52.529]                         }
[10:32:52.529]                         if (!has_future || version < "1.8.0") {
[10:32:52.529]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.529]                             "", base::R.version$version.string), 
[10:32:52.529]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.529]                               "release", "version")], collapse = " "), 
[10:32:52.529]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.529]                             info)
[10:32:52.529]                           info <- base::paste(info, collapse = "; ")
[10:32:52.529]                           if (!has_future) {
[10:32:52.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.529]                               info)
[10:32:52.529]                           }
[10:32:52.529]                           else {
[10:32:52.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.529]                               info, version)
[10:32:52.529]                           }
[10:32:52.529]                           base::stop(msg)
[10:32:52.529]                         }
[10:32:52.529]                       })
[10:32:52.529]                     }
[10:32:52.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.529]                     base::options(mc.cores = 1L)
[10:32:52.529]                   }
[10:32:52.529]                   ...future.strategy.old <- future::plan("list")
[10:32:52.529]                   options(future.plan = NULL)
[10:32:52.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.529]                 }
[10:32:52.529]                 ...future.workdir <- getwd()
[10:32:52.529]             }
[10:32:52.529]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.529]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.529]         }
[10:32:52.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.529]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.529]             base::names(...future.oldOptions))
[10:32:52.529]     }
[10:32:52.529]     if (FALSE) {
[10:32:52.529]     }
[10:32:52.529]     else {
[10:32:52.529]         if (TRUE) {
[10:32:52.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.529]                 open = "w")
[10:32:52.529]         }
[10:32:52.529]         else {
[10:32:52.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.529]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.529]         }
[10:32:52.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.529]             base::sink(type = "output", split = FALSE)
[10:32:52.529]             base::close(...future.stdout)
[10:32:52.529]         }, add = TRUE)
[10:32:52.529]     }
[10:32:52.529]     ...future.frame <- base::sys.nframe()
[10:32:52.529]     ...future.conditions <- base::list()
[10:32:52.529]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.529]     if (FALSE) {
[10:32:52.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.529]     }
[10:32:52.529]     ...future.result <- base::tryCatch({
[10:32:52.529]         base::withCallingHandlers({
[10:32:52.529]             ...future.value <- base::withVisible(base::local({
[10:32:52.529]                 withCallingHandlers({
[10:32:52.529]                   2
[10:32:52.529]                 }, immediateCondition = function(cond) {
[10:32:52.529]                   save_rds <- function (object, pathname, ...) 
[10:32:52.529]                   {
[10:32:52.529]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.529]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.529]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.529]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.529]                         fi_tmp[["mtime"]])
[10:32:52.529]                     }
[10:32:52.529]                     tryCatch({
[10:32:52.529]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.529]                     }, error = function(ex) {
[10:32:52.529]                       msg <- conditionMessage(ex)
[10:32:52.529]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.529]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.529]                         fi_tmp[["mtime"]], msg)
[10:32:52.529]                       ex$message <- msg
[10:32:52.529]                       stop(ex)
[10:32:52.529]                     })
[10:32:52.529]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.529]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.529]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.529]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.529]                       fi <- file.info(pathname)
[10:32:52.529]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.529]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.529]                         fi[["size"]], fi[["mtime"]])
[10:32:52.529]                       stop(msg)
[10:32:52.529]                     }
[10:32:52.529]                     invisible(pathname)
[10:32:52.529]                   }
[10:32:52.529]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.529]                     rootPath = tempdir()) 
[10:32:52.529]                   {
[10:32:52.529]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.529]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.529]                       tmpdir = path, fileext = ".rds")
[10:32:52.529]                     save_rds(obj, file)
[10:32:52.529]                   }
[10:32:52.529]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.529]                   {
[10:32:52.529]                     inherits <- base::inherits
[10:32:52.529]                     invokeRestart <- base::invokeRestart
[10:32:52.529]                     is.null <- base::is.null
[10:32:52.529]                     muffled <- FALSE
[10:32:52.529]                     if (inherits(cond, "message")) {
[10:32:52.529]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.529]                       if (muffled) 
[10:32:52.529]                         invokeRestart("muffleMessage")
[10:32:52.529]                     }
[10:32:52.529]                     else if (inherits(cond, "warning")) {
[10:32:52.529]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.529]                       if (muffled) 
[10:32:52.529]                         invokeRestart("muffleWarning")
[10:32:52.529]                     }
[10:32:52.529]                     else if (inherits(cond, "condition")) {
[10:32:52.529]                       if (!is.null(pattern)) {
[10:32:52.529]                         computeRestarts <- base::computeRestarts
[10:32:52.529]                         grepl <- base::grepl
[10:32:52.529]                         restarts <- computeRestarts(cond)
[10:32:52.529]                         for (restart in restarts) {
[10:32:52.529]                           name <- restart$name
[10:32:52.529]                           if (is.null(name)) 
[10:32:52.529]                             next
[10:32:52.529]                           if (!grepl(pattern, name)) 
[10:32:52.529]                             next
[10:32:52.529]                           invokeRestart(restart)
[10:32:52.529]                           muffled <- TRUE
[10:32:52.529]                           break
[10:32:52.529]                         }
[10:32:52.529]                       }
[10:32:52.529]                     }
[10:32:52.529]                     invisible(muffled)
[10:32:52.529]                   }
[10:32:52.529]                   muffleCondition(cond)
[10:32:52.529]                 })
[10:32:52.529]             }))
[10:32:52.529]             future::FutureResult(value = ...future.value$value, 
[10:32:52.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.529]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.529]                     ...future.globalenv.names))
[10:32:52.529]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.529]         }, condition = base::local({
[10:32:52.529]             c <- base::c
[10:32:52.529]             inherits <- base::inherits
[10:32:52.529]             invokeRestart <- base::invokeRestart
[10:32:52.529]             length <- base::length
[10:32:52.529]             list <- base::list
[10:32:52.529]             seq.int <- base::seq.int
[10:32:52.529]             signalCondition <- base::signalCondition
[10:32:52.529]             sys.calls <- base::sys.calls
[10:32:52.529]             `[[` <- base::`[[`
[10:32:52.529]             `+` <- base::`+`
[10:32:52.529]             `<<-` <- base::`<<-`
[10:32:52.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.529]                   3L)]
[10:32:52.529]             }
[10:32:52.529]             function(cond) {
[10:32:52.529]                 is_error <- inherits(cond, "error")
[10:32:52.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.529]                   NULL)
[10:32:52.529]                 if (is_error) {
[10:32:52.529]                   sessionInformation <- function() {
[10:32:52.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.529]                       search = base::search(), system = base::Sys.info())
[10:32:52.529]                   }
[10:32:52.529]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.529]                     cond$call), session = sessionInformation(), 
[10:32:52.529]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.529]                   signalCondition(cond)
[10:32:52.529]                 }
[10:32:52.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.529]                 "immediateCondition"))) {
[10:32:52.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.529]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.529]                   if (TRUE && !signal) {
[10:32:52.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.529]                     {
[10:32:52.529]                       inherits <- base::inherits
[10:32:52.529]                       invokeRestart <- base::invokeRestart
[10:32:52.529]                       is.null <- base::is.null
[10:32:52.529]                       muffled <- FALSE
[10:32:52.529]                       if (inherits(cond, "message")) {
[10:32:52.529]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.529]                         if (muffled) 
[10:32:52.529]                           invokeRestart("muffleMessage")
[10:32:52.529]                       }
[10:32:52.529]                       else if (inherits(cond, "warning")) {
[10:32:52.529]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.529]                         if (muffled) 
[10:32:52.529]                           invokeRestart("muffleWarning")
[10:32:52.529]                       }
[10:32:52.529]                       else if (inherits(cond, "condition")) {
[10:32:52.529]                         if (!is.null(pattern)) {
[10:32:52.529]                           computeRestarts <- base::computeRestarts
[10:32:52.529]                           grepl <- base::grepl
[10:32:52.529]                           restarts <- computeRestarts(cond)
[10:32:52.529]                           for (restart in restarts) {
[10:32:52.529]                             name <- restart$name
[10:32:52.529]                             if (is.null(name)) 
[10:32:52.529]                               next
[10:32:52.529]                             if (!grepl(pattern, name)) 
[10:32:52.529]                               next
[10:32:52.529]                             invokeRestart(restart)
[10:32:52.529]                             muffled <- TRUE
[10:32:52.529]                             break
[10:32:52.529]                           }
[10:32:52.529]                         }
[10:32:52.529]                       }
[10:32:52.529]                       invisible(muffled)
[10:32:52.529]                     }
[10:32:52.529]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.529]                   }
[10:32:52.529]                 }
[10:32:52.529]                 else {
[10:32:52.529]                   if (TRUE) {
[10:32:52.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.529]                     {
[10:32:52.529]                       inherits <- base::inherits
[10:32:52.529]                       invokeRestart <- base::invokeRestart
[10:32:52.529]                       is.null <- base::is.null
[10:32:52.529]                       muffled <- FALSE
[10:32:52.529]                       if (inherits(cond, "message")) {
[10:32:52.529]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.529]                         if (muffled) 
[10:32:52.529]                           invokeRestart("muffleMessage")
[10:32:52.529]                       }
[10:32:52.529]                       else if (inherits(cond, "warning")) {
[10:32:52.529]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.529]                         if (muffled) 
[10:32:52.529]                           invokeRestart("muffleWarning")
[10:32:52.529]                       }
[10:32:52.529]                       else if (inherits(cond, "condition")) {
[10:32:52.529]                         if (!is.null(pattern)) {
[10:32:52.529]                           computeRestarts <- base::computeRestarts
[10:32:52.529]                           grepl <- base::grepl
[10:32:52.529]                           restarts <- computeRestarts(cond)
[10:32:52.529]                           for (restart in restarts) {
[10:32:52.529]                             name <- restart$name
[10:32:52.529]                             if (is.null(name)) 
[10:32:52.529]                               next
[10:32:52.529]                             if (!grepl(pattern, name)) 
[10:32:52.529]                               next
[10:32:52.529]                             invokeRestart(restart)
[10:32:52.529]                             muffled <- TRUE
[10:32:52.529]                             break
[10:32:52.529]                           }
[10:32:52.529]                         }
[10:32:52.529]                       }
[10:32:52.529]                       invisible(muffled)
[10:32:52.529]                     }
[10:32:52.529]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.529]                   }
[10:32:52.529]                 }
[10:32:52.529]             }
[10:32:52.529]         }))
[10:32:52.529]     }, error = function(ex) {
[10:32:52.529]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.529]                 ...future.rng), started = ...future.startTime, 
[10:32:52.529]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.529]             version = "1.8"), class = "FutureResult")
[10:32:52.529]     }, finally = {
[10:32:52.529]         if (!identical(...future.workdir, getwd())) 
[10:32:52.529]             setwd(...future.workdir)
[10:32:52.529]         {
[10:32:52.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.529]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.529]             }
[10:32:52.529]             base::options(...future.oldOptions)
[10:32:52.529]             if (.Platform$OS.type == "windows") {
[10:32:52.529]                 old_names <- names(...future.oldEnvVars)
[10:32:52.529]                 envs <- base::Sys.getenv()
[10:32:52.529]                 names <- names(envs)
[10:32:52.529]                 common <- intersect(names, old_names)
[10:32:52.529]                 added <- setdiff(names, old_names)
[10:32:52.529]                 removed <- setdiff(old_names, names)
[10:32:52.529]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.529]                   envs[common]]
[10:32:52.529]                 NAMES <- toupper(changed)
[10:32:52.529]                 args <- list()
[10:32:52.529]                 for (kk in seq_along(NAMES)) {
[10:32:52.529]                   name <- changed[[kk]]
[10:32:52.529]                   NAME <- NAMES[[kk]]
[10:32:52.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.529]                     next
[10:32:52.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.529]                 }
[10:32:52.529]                 NAMES <- toupper(added)
[10:32:52.529]                 for (kk in seq_along(NAMES)) {
[10:32:52.529]                   name <- added[[kk]]
[10:32:52.529]                   NAME <- NAMES[[kk]]
[10:32:52.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.529]                     next
[10:32:52.529]                   args[[name]] <- ""
[10:32:52.529]                 }
[10:32:52.529]                 NAMES <- toupper(removed)
[10:32:52.529]                 for (kk in seq_along(NAMES)) {
[10:32:52.529]                   name <- removed[[kk]]
[10:32:52.529]                   NAME <- NAMES[[kk]]
[10:32:52.529]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.529]                     next
[10:32:52.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.529]                 }
[10:32:52.529]                 if (length(args) > 0) 
[10:32:52.529]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.529]             }
[10:32:52.529]             else {
[10:32:52.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.529]             }
[10:32:52.529]             {
[10:32:52.529]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.529]                   0L) {
[10:32:52.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.529]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.529]                   base::options(opts)
[10:32:52.529]                 }
[10:32:52.529]                 {
[10:32:52.529]                   {
[10:32:52.529]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.529]                     NULL
[10:32:52.529]                   }
[10:32:52.529]                   options(future.plan = NULL)
[10:32:52.529]                   if (is.na(NA_character_)) 
[10:32:52.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.529]                     .init = FALSE)
[10:32:52.529]                 }
[10:32:52.529]             }
[10:32:52.529]         }
[10:32:52.529]     })
[10:32:52.529]     if (TRUE) {
[10:32:52.529]         base::sink(type = "output", split = FALSE)
[10:32:52.529]         if (TRUE) {
[10:32:52.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.529]         }
[10:32:52.529]         else {
[10:32:52.529]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.529]         }
[10:32:52.529]         base::close(...future.stdout)
[10:32:52.529]         ...future.stdout <- NULL
[10:32:52.529]     }
[10:32:52.529]     ...future.result$conditions <- ...future.conditions
[10:32:52.529]     ...future.result$finished <- base::Sys.time()
[10:32:52.529]     ...future.result
[10:32:52.529] }
[10:32:52.531] requestCore(): workers = 2
[10:32:52.533] MulticoreFuture started
[10:32:52.533] - Launch lazy future ... done
[10:32:52.533] run() for ‘MulticoreFuture’ ... done
[10:32:52.534] getGlobalsAndPackages() ...
[10:32:52.534] Searching for globals...
[10:32:52.534] plan(): Setting new future strategy stack:
[10:32:52.535] 
[10:32:52.535] Searching for globals ... DONE
[10:32:52.534] List of future strategies:
[10:32:52.534] 1. sequential:
[10:32:52.534]    - args: function (..., envir = parent.frame())
[10:32:52.534]    - tweaked: FALSE
[10:32:52.534]    - call: NULL
[10:32:52.535] - globals: [0] <none>
[10:32:52.535] plan(): nbrOfWorkers() = 1
[10:32:52.535] getGlobalsAndPackages() ... DONE
[10:32:52.536] run() for ‘Future’ ...
[10:32:52.536] - state: ‘created’
[10:32:52.536] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.537] plan(): Setting new future strategy stack:
[10:32:52.537] List of future strategies:
[10:32:52.537] 1. multicore:
[10:32:52.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.537]    - tweaked: FALSE
[10:32:52.537]    - call: plan(strategy)
[10:32:52.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.541] plan(): nbrOfWorkers() = 2
[10:32:52.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.542]   - Field: ‘label’
[10:32:52.542]   - Field: ‘local’
[10:32:52.542]   - Field: ‘owner’
[10:32:52.542]   - Field: ‘envir’
[10:32:52.542]   - Field: ‘workers’
[10:32:52.542]   - Field: ‘packages’
[10:32:52.542]   - Field: ‘gc’
[10:32:52.543]   - Field: ‘job’
[10:32:52.543]   - Field: ‘conditions’
[10:32:52.543]   - Field: ‘expr’
[10:32:52.543]   - Field: ‘uuid’
[10:32:52.543]   - Field: ‘seed’
[10:32:52.543]   - Field: ‘version’
[10:32:52.543]   - Field: ‘result’
[10:32:52.543]   - Field: ‘asynchronous’
[10:32:52.544]   - Field: ‘calls’
[10:32:52.544]   - Field: ‘globals’
[10:32:52.544]   - Field: ‘stdout’
[10:32:52.544]   - Field: ‘earlySignal’
[10:32:52.544]   - Field: ‘lazy’
[10:32:52.544]   - Field: ‘state’
[10:32:52.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.545] - Launch lazy future ...
[10:32:52.545] Packages needed by the future expression (n = 0): <none>
[10:32:52.545] Packages needed by future strategies (n = 0): <none>
[10:32:52.546] {
[10:32:52.546]     {
[10:32:52.546]         {
[10:32:52.546]             ...future.startTime <- base::Sys.time()
[10:32:52.546]             {
[10:32:52.546]                 {
[10:32:52.546]                   {
[10:32:52.546]                     {
[10:32:52.546]                       base::local({
[10:32:52.546]                         has_future <- base::requireNamespace("future", 
[10:32:52.546]                           quietly = TRUE)
[10:32:52.546]                         if (has_future) {
[10:32:52.546]                           ns <- base::getNamespace("future")
[10:32:52.546]                           version <- ns[[".package"]][["version"]]
[10:32:52.546]                           if (is.null(version)) 
[10:32:52.546]                             version <- utils::packageVersion("future")
[10:32:52.546]                         }
[10:32:52.546]                         else {
[10:32:52.546]                           version <- NULL
[10:32:52.546]                         }
[10:32:52.546]                         if (!has_future || version < "1.8.0") {
[10:32:52.546]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.546]                             "", base::R.version$version.string), 
[10:32:52.546]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.546]                               "release", "version")], collapse = " "), 
[10:32:52.546]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.546]                             info)
[10:32:52.546]                           info <- base::paste(info, collapse = "; ")
[10:32:52.546]                           if (!has_future) {
[10:32:52.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.546]                               info)
[10:32:52.546]                           }
[10:32:52.546]                           else {
[10:32:52.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.546]                               info, version)
[10:32:52.546]                           }
[10:32:52.546]                           base::stop(msg)
[10:32:52.546]                         }
[10:32:52.546]                       })
[10:32:52.546]                     }
[10:32:52.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.546]                     base::options(mc.cores = 1L)
[10:32:52.546]                   }
[10:32:52.546]                   ...future.strategy.old <- future::plan("list")
[10:32:52.546]                   options(future.plan = NULL)
[10:32:52.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.546]                 }
[10:32:52.546]                 ...future.workdir <- getwd()
[10:32:52.546]             }
[10:32:52.546]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.546]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.546]         }
[10:32:52.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.546]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.546]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.546]             base::names(...future.oldOptions))
[10:32:52.546]     }
[10:32:52.546]     if (FALSE) {
[10:32:52.546]     }
[10:32:52.546]     else {
[10:32:52.546]         if (TRUE) {
[10:32:52.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.546]                 open = "w")
[10:32:52.546]         }
[10:32:52.546]         else {
[10:32:52.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.546]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.546]         }
[10:32:52.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.546]             base::sink(type = "output", split = FALSE)
[10:32:52.546]             base::close(...future.stdout)
[10:32:52.546]         }, add = TRUE)
[10:32:52.546]     }
[10:32:52.546]     ...future.frame <- base::sys.nframe()
[10:32:52.546]     ...future.conditions <- base::list()
[10:32:52.546]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.546]     if (FALSE) {
[10:32:52.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.546]     }
[10:32:52.546]     ...future.result <- base::tryCatch({
[10:32:52.546]         base::withCallingHandlers({
[10:32:52.546]             ...future.value <- base::withVisible(base::local({
[10:32:52.546]                 withCallingHandlers({
[10:32:52.546]                   NULL
[10:32:52.546]                 }, immediateCondition = function(cond) {
[10:32:52.546]                   save_rds <- function (object, pathname, ...) 
[10:32:52.546]                   {
[10:32:52.546]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.546]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.546]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.546]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.546]                         fi_tmp[["mtime"]])
[10:32:52.546]                     }
[10:32:52.546]                     tryCatch({
[10:32:52.546]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.546]                     }, error = function(ex) {
[10:32:52.546]                       msg <- conditionMessage(ex)
[10:32:52.546]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.546]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.546]                         fi_tmp[["mtime"]], msg)
[10:32:52.546]                       ex$message <- msg
[10:32:52.546]                       stop(ex)
[10:32:52.546]                     })
[10:32:52.546]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.546]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.546]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.546]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.546]                       fi <- file.info(pathname)
[10:32:52.546]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.546]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.546]                         fi[["size"]], fi[["mtime"]])
[10:32:52.546]                       stop(msg)
[10:32:52.546]                     }
[10:32:52.546]                     invisible(pathname)
[10:32:52.546]                   }
[10:32:52.546]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.546]                     rootPath = tempdir()) 
[10:32:52.546]                   {
[10:32:52.546]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.546]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.546]                       tmpdir = path, fileext = ".rds")
[10:32:52.546]                     save_rds(obj, file)
[10:32:52.546]                   }
[10:32:52.546]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.546]                   {
[10:32:52.546]                     inherits <- base::inherits
[10:32:52.546]                     invokeRestart <- base::invokeRestart
[10:32:52.546]                     is.null <- base::is.null
[10:32:52.546]                     muffled <- FALSE
[10:32:52.546]                     if (inherits(cond, "message")) {
[10:32:52.546]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.546]                       if (muffled) 
[10:32:52.546]                         invokeRestart("muffleMessage")
[10:32:52.546]                     }
[10:32:52.546]                     else if (inherits(cond, "warning")) {
[10:32:52.546]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.546]                       if (muffled) 
[10:32:52.546]                         invokeRestart("muffleWarning")
[10:32:52.546]                     }
[10:32:52.546]                     else if (inherits(cond, "condition")) {
[10:32:52.546]                       if (!is.null(pattern)) {
[10:32:52.546]                         computeRestarts <- base::computeRestarts
[10:32:52.546]                         grepl <- base::grepl
[10:32:52.546]                         restarts <- computeRestarts(cond)
[10:32:52.546]                         for (restart in restarts) {
[10:32:52.546]                           name <- restart$name
[10:32:52.546]                           if (is.null(name)) 
[10:32:52.546]                             next
[10:32:52.546]                           if (!grepl(pattern, name)) 
[10:32:52.546]                             next
[10:32:52.546]                           invokeRestart(restart)
[10:32:52.546]                           muffled <- TRUE
[10:32:52.546]                           break
[10:32:52.546]                         }
[10:32:52.546]                       }
[10:32:52.546]                     }
[10:32:52.546]                     invisible(muffled)
[10:32:52.546]                   }
[10:32:52.546]                   muffleCondition(cond)
[10:32:52.546]                 })
[10:32:52.546]             }))
[10:32:52.546]             future::FutureResult(value = ...future.value$value, 
[10:32:52.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.546]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.546]                     ...future.globalenv.names))
[10:32:52.546]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.546]         }, condition = base::local({
[10:32:52.546]             c <- base::c
[10:32:52.546]             inherits <- base::inherits
[10:32:52.546]             invokeRestart <- base::invokeRestart
[10:32:52.546]             length <- base::length
[10:32:52.546]             list <- base::list
[10:32:52.546]             seq.int <- base::seq.int
[10:32:52.546]             signalCondition <- base::signalCondition
[10:32:52.546]             sys.calls <- base::sys.calls
[10:32:52.546]             `[[` <- base::`[[`
[10:32:52.546]             `+` <- base::`+`
[10:32:52.546]             `<<-` <- base::`<<-`
[10:32:52.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.546]                   3L)]
[10:32:52.546]             }
[10:32:52.546]             function(cond) {
[10:32:52.546]                 is_error <- inherits(cond, "error")
[10:32:52.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.546]                   NULL)
[10:32:52.546]                 if (is_error) {
[10:32:52.546]                   sessionInformation <- function() {
[10:32:52.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.546]                       search = base::search(), system = base::Sys.info())
[10:32:52.546]                   }
[10:32:52.546]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.546]                     cond$call), session = sessionInformation(), 
[10:32:52.546]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.546]                   signalCondition(cond)
[10:32:52.546]                 }
[10:32:52.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.546]                 "immediateCondition"))) {
[10:32:52.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.546]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.546]                   if (TRUE && !signal) {
[10:32:52.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.546]                     {
[10:32:52.546]                       inherits <- base::inherits
[10:32:52.546]                       invokeRestart <- base::invokeRestart
[10:32:52.546]                       is.null <- base::is.null
[10:32:52.546]                       muffled <- FALSE
[10:32:52.546]                       if (inherits(cond, "message")) {
[10:32:52.546]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.546]                         if (muffled) 
[10:32:52.546]                           invokeRestart("muffleMessage")
[10:32:52.546]                       }
[10:32:52.546]                       else if (inherits(cond, "warning")) {
[10:32:52.546]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.546]                         if (muffled) 
[10:32:52.546]                           invokeRestart("muffleWarning")
[10:32:52.546]                       }
[10:32:52.546]                       else if (inherits(cond, "condition")) {
[10:32:52.546]                         if (!is.null(pattern)) {
[10:32:52.546]                           computeRestarts <- base::computeRestarts
[10:32:52.546]                           grepl <- base::grepl
[10:32:52.546]                           restarts <- computeRestarts(cond)
[10:32:52.546]                           for (restart in restarts) {
[10:32:52.546]                             name <- restart$name
[10:32:52.546]                             if (is.null(name)) 
[10:32:52.546]                               next
[10:32:52.546]                             if (!grepl(pattern, name)) 
[10:32:52.546]                               next
[10:32:52.546]                             invokeRestart(restart)
[10:32:52.546]                             muffled <- TRUE
[10:32:52.546]                             break
[10:32:52.546]                           }
[10:32:52.546]                         }
[10:32:52.546]                       }
[10:32:52.546]                       invisible(muffled)
[10:32:52.546]                     }
[10:32:52.546]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.546]                   }
[10:32:52.546]                 }
[10:32:52.546]                 else {
[10:32:52.546]                   if (TRUE) {
[10:32:52.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.546]                     {
[10:32:52.546]                       inherits <- base::inherits
[10:32:52.546]                       invokeRestart <- base::invokeRestart
[10:32:52.546]                       is.null <- base::is.null
[10:32:52.546]                       muffled <- FALSE
[10:32:52.546]                       if (inherits(cond, "message")) {
[10:32:52.546]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.546]                         if (muffled) 
[10:32:52.546]                           invokeRestart("muffleMessage")
[10:32:52.546]                       }
[10:32:52.546]                       else if (inherits(cond, "warning")) {
[10:32:52.546]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.546]                         if (muffled) 
[10:32:52.546]                           invokeRestart("muffleWarning")
[10:32:52.546]                       }
[10:32:52.546]                       else if (inherits(cond, "condition")) {
[10:32:52.546]                         if (!is.null(pattern)) {
[10:32:52.546]                           computeRestarts <- base::computeRestarts
[10:32:52.546]                           grepl <- base::grepl
[10:32:52.546]                           restarts <- computeRestarts(cond)
[10:32:52.546]                           for (restart in restarts) {
[10:32:52.546]                             name <- restart$name
[10:32:52.546]                             if (is.null(name)) 
[10:32:52.546]                               next
[10:32:52.546]                             if (!grepl(pattern, name)) 
[10:32:52.546]                               next
[10:32:52.546]                             invokeRestart(restart)
[10:32:52.546]                             muffled <- TRUE
[10:32:52.546]                             break
[10:32:52.546]                           }
[10:32:52.546]                         }
[10:32:52.546]                       }
[10:32:52.546]                       invisible(muffled)
[10:32:52.546]                     }
[10:32:52.546]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.546]                   }
[10:32:52.546]                 }
[10:32:52.546]             }
[10:32:52.546]         }))
[10:32:52.546]     }, error = function(ex) {
[10:32:52.546]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.546]                 ...future.rng), started = ...future.startTime, 
[10:32:52.546]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.546]             version = "1.8"), class = "FutureResult")
[10:32:52.546]     }, finally = {
[10:32:52.546]         if (!identical(...future.workdir, getwd())) 
[10:32:52.546]             setwd(...future.workdir)
[10:32:52.546]         {
[10:32:52.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.546]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.546]             }
[10:32:52.546]             base::options(...future.oldOptions)
[10:32:52.546]             if (.Platform$OS.type == "windows") {
[10:32:52.546]                 old_names <- names(...future.oldEnvVars)
[10:32:52.546]                 envs <- base::Sys.getenv()
[10:32:52.546]                 names <- names(envs)
[10:32:52.546]                 common <- intersect(names, old_names)
[10:32:52.546]                 added <- setdiff(names, old_names)
[10:32:52.546]                 removed <- setdiff(old_names, names)
[10:32:52.546]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.546]                   envs[common]]
[10:32:52.546]                 NAMES <- toupper(changed)
[10:32:52.546]                 args <- list()
[10:32:52.546]                 for (kk in seq_along(NAMES)) {
[10:32:52.546]                   name <- changed[[kk]]
[10:32:52.546]                   NAME <- NAMES[[kk]]
[10:32:52.546]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.546]                     next
[10:32:52.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.546]                 }
[10:32:52.546]                 NAMES <- toupper(added)
[10:32:52.546]                 for (kk in seq_along(NAMES)) {
[10:32:52.546]                   name <- added[[kk]]
[10:32:52.546]                   NAME <- NAMES[[kk]]
[10:32:52.546]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.546]                     next
[10:32:52.546]                   args[[name]] <- ""
[10:32:52.546]                 }
[10:32:52.546]                 NAMES <- toupper(removed)
[10:32:52.546]                 for (kk in seq_along(NAMES)) {
[10:32:52.546]                   name <- removed[[kk]]
[10:32:52.546]                   NAME <- NAMES[[kk]]
[10:32:52.546]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.546]                     next
[10:32:52.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.546]                 }
[10:32:52.546]                 if (length(args) > 0) 
[10:32:52.546]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.546]             }
[10:32:52.546]             else {
[10:32:52.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.546]             }
[10:32:52.546]             {
[10:32:52.546]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.546]                   0L) {
[10:32:52.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.546]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.546]                   base::options(opts)
[10:32:52.546]                 }
[10:32:52.546]                 {
[10:32:52.546]                   {
[10:32:52.546]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.546]                     NULL
[10:32:52.546]                   }
[10:32:52.546]                   options(future.plan = NULL)
[10:32:52.546]                   if (is.na(NA_character_)) 
[10:32:52.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.546]                     .init = FALSE)
[10:32:52.546]                 }
[10:32:52.546]             }
[10:32:52.546]         }
[10:32:52.546]     })
[10:32:52.546]     if (TRUE) {
[10:32:52.546]         base::sink(type = "output", split = FALSE)
[10:32:52.546]         if (TRUE) {
[10:32:52.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.546]         }
[10:32:52.546]         else {
[10:32:52.546]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.546]         }
[10:32:52.546]         base::close(...future.stdout)
[10:32:52.546]         ...future.stdout <- NULL
[10:32:52.546]     }
[10:32:52.546]     ...future.result$conditions <- ...future.conditions
[10:32:52.546]     ...future.result$finished <- base::Sys.time()
[10:32:52.546]     ...future.result
[10:32:52.546] }
[10:32:52.550] requestCore(): workers = 2
[10:32:52.552] MulticoreFuture started
[10:32:52.553] - Launch lazy future ... done
[10:32:52.553] run() for ‘MulticoreFuture’ ... done
[10:32:52.554] plan(): Setting new future strategy stack:
[10:32:52.554] getGlobalsAndPackages() ...
[10:32:52.554] Searching for globals...
[10:32:52.554] List of future strategies:
[10:32:52.554] 1. sequential:
[10:32:52.554]    - args: function (..., envir = parent.frame())
[10:32:52.554]    - tweaked: FALSE
[10:32:52.554]    - call: NULL
[10:32:52.555] plan(): nbrOfWorkers() = 1
[10:32:52.555] - globals found: [1] ‘{’
[10:32:52.556] Searching for globals ... DONE
[10:32:52.556] Resolving globals: FALSE
[10:32:52.556] 
[10:32:52.557] 
[10:32:52.557] plan(): Setting new future strategy stack:
[10:32:52.557] getGlobalsAndPackages() ... DONE
[10:32:52.557] run() for ‘Future’ ...
[10:32:52.557] List of future strategies:
[10:32:52.557] 1. multicore:
[10:32:52.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.557]    - tweaked: FALSE
[10:32:52.557]    - call: plan(strategy)
[10:32:52.557] - state: ‘created’
[10:32:52.558] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:52.562] plan(): nbrOfWorkers() = 2
[10:32:52.563] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:52.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:52.563]   - Field: ‘label’
[10:32:52.563]   - Field: ‘local’
[10:32:52.564]   - Field: ‘owner’
[10:32:52.564]   - Field: ‘envir’
[10:32:52.564]   - Field: ‘workers’
[10:32:52.564]   - Field: ‘packages’
[10:32:52.564]   - Field: ‘gc’
[10:32:52.564]   - Field: ‘job’
[10:32:52.565]   - Field: ‘conditions’
[10:32:52.565]   - Field: ‘expr’
[10:32:52.565]   - Field: ‘uuid’
[10:32:52.565]   - Field: ‘seed’
[10:32:52.565]   - Field: ‘version’
[10:32:52.565]   - Field: ‘result’
[10:32:52.566]   - Field: ‘asynchronous’
[10:32:52.566]   - Field: ‘calls’
[10:32:52.566]   - Field: ‘globals’
[10:32:52.566]   - Field: ‘stdout’
[10:32:52.566]   - Field: ‘earlySignal’
[10:32:52.566]   - Field: ‘lazy’
[10:32:52.567]   - Field: ‘state’
[10:32:52.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:52.567] - Launch lazy future ...
[10:32:52.567] Packages needed by the future expression (n = 0): <none>
[10:32:52.568] Packages needed by future strategies (n = 0): <none>
[10:32:52.568] {
[10:32:52.568]     {
[10:32:52.568]         {
[10:32:52.568]             ...future.startTime <- base::Sys.time()
[10:32:52.568]             {
[10:32:52.568]                 {
[10:32:52.568]                   {
[10:32:52.568]                     {
[10:32:52.568]                       base::local({
[10:32:52.568]                         has_future <- base::requireNamespace("future", 
[10:32:52.568]                           quietly = TRUE)
[10:32:52.568]                         if (has_future) {
[10:32:52.568]                           ns <- base::getNamespace("future")
[10:32:52.568]                           version <- ns[[".package"]][["version"]]
[10:32:52.568]                           if (is.null(version)) 
[10:32:52.568]                             version <- utils::packageVersion("future")
[10:32:52.568]                         }
[10:32:52.568]                         else {
[10:32:52.568]                           version <- NULL
[10:32:52.568]                         }
[10:32:52.568]                         if (!has_future || version < "1.8.0") {
[10:32:52.568]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.568]                             "", base::R.version$version.string), 
[10:32:52.568]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.568]                               "release", "version")], collapse = " "), 
[10:32:52.568]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.568]                             info)
[10:32:52.568]                           info <- base::paste(info, collapse = "; ")
[10:32:52.568]                           if (!has_future) {
[10:32:52.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.568]                               info)
[10:32:52.568]                           }
[10:32:52.568]                           else {
[10:32:52.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.568]                               info, version)
[10:32:52.568]                           }
[10:32:52.568]                           base::stop(msg)
[10:32:52.568]                         }
[10:32:52.568]                       })
[10:32:52.568]                     }
[10:32:52.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.568]                     base::options(mc.cores = 1L)
[10:32:52.568]                   }
[10:32:52.568]                   ...future.strategy.old <- future::plan("list")
[10:32:52.568]                   options(future.plan = NULL)
[10:32:52.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.568]                 }
[10:32:52.568]                 ...future.workdir <- getwd()
[10:32:52.568]             }
[10:32:52.568]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.568]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.568]         }
[10:32:52.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.568]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.568]             base::names(...future.oldOptions))
[10:32:52.568]     }
[10:32:52.568]     if (FALSE) {
[10:32:52.568]     }
[10:32:52.568]     else {
[10:32:52.568]         if (TRUE) {
[10:32:52.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.568]                 open = "w")
[10:32:52.568]         }
[10:32:52.568]         else {
[10:32:52.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.568]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.568]         }
[10:32:52.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.568]             base::sink(type = "output", split = FALSE)
[10:32:52.568]             base::close(...future.stdout)
[10:32:52.568]         }, add = TRUE)
[10:32:52.568]     }
[10:32:52.568]     ...future.frame <- base::sys.nframe()
[10:32:52.568]     ...future.conditions <- base::list()
[10:32:52.568]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.568]     if (FALSE) {
[10:32:52.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.568]     }
[10:32:52.568]     ...future.result <- base::tryCatch({
[10:32:52.568]         base::withCallingHandlers({
[10:32:52.568]             ...future.value <- base::withVisible(base::local({
[10:32:52.568]                 withCallingHandlers({
[10:32:52.568]                   {
[10:32:52.568]                     4
[10:32:52.568]                   }
[10:32:52.568]                 }, immediateCondition = function(cond) {
[10:32:52.568]                   save_rds <- function (object, pathname, ...) 
[10:32:52.568]                   {
[10:32:52.568]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:52.568]                     if (file_test("-f", pathname_tmp)) {
[10:32:52.568]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.568]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:52.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.568]                         fi_tmp[["mtime"]])
[10:32:52.568]                     }
[10:32:52.568]                     tryCatch({
[10:32:52.568]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:52.568]                     }, error = function(ex) {
[10:32:52.568]                       msg <- conditionMessage(ex)
[10:32:52.568]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.568]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:52.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.568]                         fi_tmp[["mtime"]], msg)
[10:32:52.568]                       ex$message <- msg
[10:32:52.568]                       stop(ex)
[10:32:52.568]                     })
[10:32:52.568]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:52.568]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:52.568]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:52.568]                       fi_tmp <- file.info(pathname_tmp)
[10:32:52.568]                       fi <- file.info(pathname)
[10:32:52.568]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:52.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:52.568]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:52.568]                         fi[["size"]], fi[["mtime"]])
[10:32:52.568]                       stop(msg)
[10:32:52.568]                     }
[10:32:52.568]                     invisible(pathname)
[10:32:52.568]                   }
[10:32:52.568]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:52.568]                     rootPath = tempdir()) 
[10:32:52.568]                   {
[10:32:52.568]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:52.568]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:52.568]                       tmpdir = path, fileext = ".rds")
[10:32:52.568]                     save_rds(obj, file)
[10:32:52.568]                   }
[10:32:52.568]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:52.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.568]                   {
[10:32:52.568]                     inherits <- base::inherits
[10:32:52.568]                     invokeRestart <- base::invokeRestart
[10:32:52.568]                     is.null <- base::is.null
[10:32:52.568]                     muffled <- FALSE
[10:32:52.568]                     if (inherits(cond, "message")) {
[10:32:52.568]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.568]                       if (muffled) 
[10:32:52.568]                         invokeRestart("muffleMessage")
[10:32:52.568]                     }
[10:32:52.568]                     else if (inherits(cond, "warning")) {
[10:32:52.568]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.568]                       if (muffled) 
[10:32:52.568]                         invokeRestart("muffleWarning")
[10:32:52.568]                     }
[10:32:52.568]                     else if (inherits(cond, "condition")) {
[10:32:52.568]                       if (!is.null(pattern)) {
[10:32:52.568]                         computeRestarts <- base::computeRestarts
[10:32:52.568]                         grepl <- base::grepl
[10:32:52.568]                         restarts <- computeRestarts(cond)
[10:32:52.568]                         for (restart in restarts) {
[10:32:52.568]                           name <- restart$name
[10:32:52.568]                           if (is.null(name)) 
[10:32:52.568]                             next
[10:32:52.568]                           if (!grepl(pattern, name)) 
[10:32:52.568]                             next
[10:32:52.568]                           invokeRestart(restart)
[10:32:52.568]                           muffled <- TRUE
[10:32:52.568]                           break
[10:32:52.568]                         }
[10:32:52.568]                       }
[10:32:52.568]                     }
[10:32:52.568]                     invisible(muffled)
[10:32:52.568]                   }
[10:32:52.568]                   muffleCondition(cond)
[10:32:52.568]                 })
[10:32:52.568]             }))
[10:32:52.568]             future::FutureResult(value = ...future.value$value, 
[10:32:52.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.568]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.568]                     ...future.globalenv.names))
[10:32:52.568]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.568]         }, condition = base::local({
[10:32:52.568]             c <- base::c
[10:32:52.568]             inherits <- base::inherits
[10:32:52.568]             invokeRestart <- base::invokeRestart
[10:32:52.568]             length <- base::length
[10:32:52.568]             list <- base::list
[10:32:52.568]             seq.int <- base::seq.int
[10:32:52.568]             signalCondition <- base::signalCondition
[10:32:52.568]             sys.calls <- base::sys.calls
[10:32:52.568]             `[[` <- base::`[[`
[10:32:52.568]             `+` <- base::`+`
[10:32:52.568]             `<<-` <- base::`<<-`
[10:32:52.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.568]                   3L)]
[10:32:52.568]             }
[10:32:52.568]             function(cond) {
[10:32:52.568]                 is_error <- inherits(cond, "error")
[10:32:52.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.568]                   NULL)
[10:32:52.568]                 if (is_error) {
[10:32:52.568]                   sessionInformation <- function() {
[10:32:52.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.568]                       search = base::search(), system = base::Sys.info())
[10:32:52.568]                   }
[10:32:52.568]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.568]                     cond$call), session = sessionInformation(), 
[10:32:52.568]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.568]                   signalCondition(cond)
[10:32:52.568]                 }
[10:32:52.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.568]                 "immediateCondition"))) {
[10:32:52.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.568]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.568]                   if (TRUE && !signal) {
[10:32:52.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.568]                     {
[10:32:52.568]                       inherits <- base::inherits
[10:32:52.568]                       invokeRestart <- base::invokeRestart
[10:32:52.568]                       is.null <- base::is.null
[10:32:52.568]                       muffled <- FALSE
[10:32:52.568]                       if (inherits(cond, "message")) {
[10:32:52.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.568]                         if (muffled) 
[10:32:52.568]                           invokeRestart("muffleMessage")
[10:32:52.568]                       }
[10:32:52.568]                       else if (inherits(cond, "warning")) {
[10:32:52.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.568]                         if (muffled) 
[10:32:52.568]                           invokeRestart("muffleWarning")
[10:32:52.568]                       }
[10:32:52.568]                       else if (inherits(cond, "condition")) {
[10:32:52.568]                         if (!is.null(pattern)) {
[10:32:52.568]                           computeRestarts <- base::computeRestarts
[10:32:52.568]                           grepl <- base::grepl
[10:32:52.568]                           restarts <- computeRestarts(cond)
[10:32:52.568]                           for (restart in restarts) {
[10:32:52.568]                             name <- restart$name
[10:32:52.568]                             if (is.null(name)) 
[10:32:52.568]                               next
[10:32:52.568]                             if (!grepl(pattern, name)) 
[10:32:52.568]                               next
[10:32:52.568]                             invokeRestart(restart)
[10:32:52.568]                             muffled <- TRUE
[10:32:52.568]                             break
[10:32:52.568]                           }
[10:32:52.568]                         }
[10:32:52.568]                       }
[10:32:52.568]                       invisible(muffled)
[10:32:52.568]                     }
[10:32:52.568]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.568]                   }
[10:32:52.568]                 }
[10:32:52.568]                 else {
[10:32:52.568]                   if (TRUE) {
[10:32:52.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.568]                     {
[10:32:52.568]                       inherits <- base::inherits
[10:32:52.568]                       invokeRestart <- base::invokeRestart
[10:32:52.568]                       is.null <- base::is.null
[10:32:52.568]                       muffled <- FALSE
[10:32:52.568]                       if (inherits(cond, "message")) {
[10:32:52.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.568]                         if (muffled) 
[10:32:52.568]                           invokeRestart("muffleMessage")
[10:32:52.568]                       }
[10:32:52.568]                       else if (inherits(cond, "warning")) {
[10:32:52.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.568]                         if (muffled) 
[10:32:52.568]                           invokeRestart("muffleWarning")
[10:32:52.568]                       }
[10:32:52.568]                       else if (inherits(cond, "condition")) {
[10:32:52.568]                         if (!is.null(pattern)) {
[10:32:52.568]                           computeRestarts <- base::computeRestarts
[10:32:52.568]                           grepl <- base::grepl
[10:32:52.568]                           restarts <- computeRestarts(cond)
[10:32:52.568]                           for (restart in restarts) {
[10:32:52.568]                             name <- restart$name
[10:32:52.568]                             if (is.null(name)) 
[10:32:52.568]                               next
[10:32:52.568]                             if (!grepl(pattern, name)) 
[10:32:52.568]                               next
[10:32:52.568]                             invokeRestart(restart)
[10:32:52.568]                             muffled <- TRUE
[10:32:52.568]                             break
[10:32:52.568]                           }
[10:32:52.568]                         }
[10:32:52.568]                       }
[10:32:52.568]                       invisible(muffled)
[10:32:52.568]                     }
[10:32:52.568]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.568]                   }
[10:32:52.568]                 }
[10:32:52.568]             }
[10:32:52.568]         }))
[10:32:52.568]     }, error = function(ex) {
[10:32:52.568]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.568]                 ...future.rng), started = ...future.startTime, 
[10:32:52.568]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.568]             version = "1.8"), class = "FutureResult")
[10:32:52.568]     }, finally = {
[10:32:52.568]         if (!identical(...future.workdir, getwd())) 
[10:32:52.568]             setwd(...future.workdir)
[10:32:52.568]         {
[10:32:52.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.568]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.568]             }
[10:32:52.568]             base::options(...future.oldOptions)
[10:32:52.568]             if (.Platform$OS.type == "windows") {
[10:32:52.568]                 old_names <- names(...future.oldEnvVars)
[10:32:52.568]                 envs <- base::Sys.getenv()
[10:32:52.568]                 names <- names(envs)
[10:32:52.568]                 common <- intersect(names, old_names)
[10:32:52.568]                 added <- setdiff(names, old_names)
[10:32:52.568]                 removed <- setdiff(old_names, names)
[10:32:52.568]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.568]                   envs[common]]
[10:32:52.568]                 NAMES <- toupper(changed)
[10:32:52.568]                 args <- list()
[10:32:52.568]                 for (kk in seq_along(NAMES)) {
[10:32:52.568]                   name <- changed[[kk]]
[10:32:52.568]                   NAME <- NAMES[[kk]]
[10:32:52.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.568]                     next
[10:32:52.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.568]                 }
[10:32:52.568]                 NAMES <- toupper(added)
[10:32:52.568]                 for (kk in seq_along(NAMES)) {
[10:32:52.568]                   name <- added[[kk]]
[10:32:52.568]                   NAME <- NAMES[[kk]]
[10:32:52.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.568]                     next
[10:32:52.568]                   args[[name]] <- ""
[10:32:52.568]                 }
[10:32:52.568]                 NAMES <- toupper(removed)
[10:32:52.568]                 for (kk in seq_along(NAMES)) {
[10:32:52.568]                   name <- removed[[kk]]
[10:32:52.568]                   NAME <- NAMES[[kk]]
[10:32:52.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.568]                     next
[10:32:52.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.568]                 }
[10:32:52.568]                 if (length(args) > 0) 
[10:32:52.568]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.568]             }
[10:32:52.568]             else {
[10:32:52.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.568]             }
[10:32:52.568]             {
[10:32:52.568]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.568]                   0L) {
[10:32:52.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.568]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.568]                   base::options(opts)
[10:32:52.568]                 }
[10:32:52.568]                 {
[10:32:52.568]                   {
[10:32:52.568]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.568]                     NULL
[10:32:52.568]                   }
[10:32:52.568]                   options(future.plan = NULL)
[10:32:52.568]                   if (is.na(NA_character_)) 
[10:32:52.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.568]                     .init = FALSE)
[10:32:52.568]                 }
[10:32:52.568]             }
[10:32:52.568]         }
[10:32:52.568]     })
[10:32:52.568]     if (TRUE) {
[10:32:52.568]         base::sink(type = "output", split = FALSE)
[10:32:52.568]         if (TRUE) {
[10:32:52.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.568]         }
[10:32:52.568]         else {
[10:32:52.568]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.568]         }
[10:32:52.568]         base::close(...future.stdout)
[10:32:52.568]         ...future.stdout <- NULL
[10:32:52.568]     }
[10:32:52.568]     ...future.result$conditions <- ...future.conditions
[10:32:52.568]     ...future.result$finished <- base::Sys.time()
[10:32:52.568]     ...future.result
[10:32:52.568] }
[10:32:52.572] requestCore(): workers = 2
[10:32:52.572] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:52.583] result() for MulticoreFuture ...
[10:32:52.584] result() for MulticoreFuture ...
[10:32:52.584] result() for MulticoreFuture ... done
[10:32:52.584] result() for MulticoreFuture ... done
[10:32:52.585] result() for MulticoreFuture ...
[10:32:52.585] result() for MulticoreFuture ... done
[10:32:52.587] MulticoreFuture started
[10:32:52.588] - Launch lazy future ... done
[10:32:52.588] run() for ‘MulticoreFuture’ ... done
[10:32:52.589] plan(): Setting new future strategy stack:
<environment: 0x5652d1468260> 
[10:32:52.589] List of future strategies:
[10:32:52.589] 1. sequential:
[10:32:52.589]    - args: function (..., envir = parent.frame())
[10:32:52.589]    - tweaked: FALSE
[10:32:52.589]    - call: NULL
[10:32:52.590] plan(): nbrOfWorkers() = 1
<environment: 0x5652d16f0818> 
[10:32:52.593] plan(): Setting new future strategy stack:
[10:32:52.593] List of future strategies:
[10:32:52.593] 1. multicore:
[10:32:52.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:52.593]    - tweaked: FALSE
[10:32:52.593]    - call: plan(strategy)
[10:32:52.598] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:52.601] resolve() on environment ...
[10:32:52.601]  recursive: 0
[10:32:52.602]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:52.602] signalConditionsASAP(numeric, pos=1) ...
[10:32:52.602] - nx: 4
[10:32:52.602] - relay: TRUE
[10:32:52.602] - stdout: TRUE
[10:32:52.602] - signal: TRUE
[10:32:52.603] - resignal: FALSE
[10:32:52.603] - force: TRUE
[10:32:52.603] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.603] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.603]  - until=2
[10:32:52.603]  - relaying element #2
[10:32:52.604] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.604] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.604] signalConditionsASAP(NULL, pos=1) ... done
[10:32:52.604]  length: 3 (resolved future 1)
[10:32:52.604] Future #2
[10:32:52.604] result() for MulticoreFuture ...
[10:32:52.605] result() for MulticoreFuture ... done
[10:32:52.605] result() for MulticoreFuture ...
[10:32:52.605] result() for MulticoreFuture ... done
[10:32:52.605] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:52.605] - nx: 4
[10:32:52.605] - relay: TRUE
[10:32:52.605] - stdout: TRUE
[10:32:52.606] - signal: TRUE
[10:32:52.606] - resignal: FALSE
[10:32:52.606] - force: TRUE
[10:32:52.606] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:52.606] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:52.606]  - until=2
[10:32:52.606]  - relaying element #2
[10:32:52.607] result() for MulticoreFuture ...
[10:32:52.607] result() for MulticoreFuture ... done
[10:32:52.607] result() for MulticoreFuture ...
[10:32:52.607] result() for MulticoreFuture ... done
[10:32:52.607] result() for MulticoreFuture ...
[10:32:52.607] result() for MulticoreFuture ... done
[10:32:52.607] result() for MulticoreFuture ...
[10:32:52.608] result() for MulticoreFuture ... done
[10:32:52.608] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.608] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.608] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:52.608]  length: 2 (resolved future 2)
[10:32:52.608] Future #3
[10:32:52.609] result() for MulticoreFuture ...
[10:32:52.609] result() for MulticoreFuture ...
[10:32:52.610] result() for MulticoreFuture ... done
[10:32:52.610] result() for MulticoreFuture ... done
[10:32:52.610] result() for MulticoreFuture ...
[10:32:52.610] result() for MulticoreFuture ... done
[10:32:52.610] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:52.610] - nx: 4
[10:32:52.610] - relay: TRUE
[10:32:52.610] - stdout: TRUE
[10:32:52.611] - signal: TRUE
[10:32:52.611] - resignal: FALSE
[10:32:52.611] - force: TRUE
[10:32:52.611] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:52.611] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:52.611]  - until=3
[10:32:52.611]  - relaying element #3
[10:32:52.611] result() for MulticoreFuture ...
[10:32:52.612] result() for MulticoreFuture ... done
[10:32:52.612] result() for MulticoreFuture ...
[10:32:52.612] result() for MulticoreFuture ... done
[10:32:52.612] result() for MulticoreFuture ...
[10:32:52.612] result() for MulticoreFuture ... done
[10:32:52.612] result() for MulticoreFuture ...
[10:32:52.612] result() for MulticoreFuture ... done
[10:32:52.613] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.613] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.613] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:52.613]  length: 1 (resolved future 3)
[10:32:52.613] Future #4
[10:32:52.613] result() for MulticoreFuture ...
[10:32:52.614] result() for MulticoreFuture ...
[10:32:52.614] result() for MulticoreFuture ... done
[10:32:52.614] result() for MulticoreFuture ... done
[10:32:52.615] result() for MulticoreFuture ...
[10:32:52.615] result() for MulticoreFuture ... done
[10:32:52.615] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:52.615] - nx: 4
[10:32:52.615] - relay: TRUE
[10:32:52.616] - stdout: TRUE
[10:32:52.616] - signal: TRUE
[10:32:52.616] - resignal: FALSE
[10:32:52.616] - force: TRUE
[10:32:52.616] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:52.616] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:52.616]  - until=4
[10:32:52.617]  - relaying element #4
[10:32:52.617] result() for MulticoreFuture ...
[10:32:52.617] result() for MulticoreFuture ... done
[10:32:52.617] result() for MulticoreFuture ...
[10:32:52.617] result() for MulticoreFuture ... done
[10:32:52.618] result() for MulticoreFuture ...
[10:32:52.618] result() for MulticoreFuture ... done
[10:32:52.618] result() for MulticoreFuture ...
[10:32:52.618] result() for MulticoreFuture ... done
[10:32:52.618] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.618] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.618] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:52.618]  length: 0 (resolved future 4)
[10:32:52.618] Relaying remaining futures
[10:32:52.619] signalConditionsASAP(NULL, pos=0) ...
[10:32:52.619] - nx: 4
[10:32:52.619] - relay: TRUE
[10:32:52.619] - stdout: TRUE
[10:32:52.619] - signal: TRUE
[10:32:52.619] - resignal: FALSE
[10:32:52.619] - force: TRUE
[10:32:52.619] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.619] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:52.619] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:52.620] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:52.620] signalConditionsASAP(NULL, pos=0) ... done
[10:32:52.620] resolve() on environment ... DONE
[10:32:52.620] result() for MulticoreFuture ...
[10:32:52.620] result() for MulticoreFuture ... done
[10:32:52.620] result() for MulticoreFuture ...
[10:32:52.620] result() for MulticoreFuture ... done
[10:32:52.620] result() for MulticoreFuture ...
[10:32:52.620] result() for MulticoreFuture ... done
[10:32:52.621] result() for MulticoreFuture ...
[10:32:52.621] result() for MulticoreFuture ... done
[10:32:52.621] result() for MulticoreFuture ...
[10:32:52.621] result() for MulticoreFuture ... done
[10:32:52.621] result() for MulticoreFuture ...
[10:32:52.621] result() for MulticoreFuture ... done
<environment: 0x5652d18047f0> 
Type of future: multisession
[10:32:52.622] plan(): Setting new future strategy stack:
[10:32:52.622] List of future strategies:
[10:32:52.622] 1. multisession:
[10:32:52.622]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:52.622]    - tweaked: FALSE
[10:32:52.622]    - call: plan(strategy)
[10:32:52.622] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:32:52.622] multisession:
[10:32:52.622] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:52.622] - tweaked: FALSE
[10:32:52.622] - call: plan(strategy)
[10:32:52.627] getGlobalsAndPackages() ...
[10:32:52.627] Not searching for globals
[10:32:52.627] - globals: [0] <none>
[10:32:52.627] getGlobalsAndPackages() ... DONE
[10:32:52.627] [local output] makeClusterPSOCK() ...
[10:32:52.631] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:32:52.631] [local output] Base port: 11304
[10:32:52.631] [local output] Getting setup options for 2 cluster nodes ...
[10:32:52.632] [local output]  - Node 1 of 2 ...
[10:32:52.632] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:52.633] [local output] Rscript port: 11304

[10:32:52.633] [local output]  - Node 2 of 2 ...
[10:32:52.634] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:52.634] [local output] Rscript port: 11304

[10:32:52.634] [local output] Getting setup options for 2 cluster nodes ... done
[10:32:52.635] [local output]  - Parallel setup requested for some PSOCK nodes
[10:32:52.635] [local output] Setting up PSOCK nodes in parallel
[10:32:52.635] List of 36
[10:32:52.635]  $ worker          : chr "localhost"
[10:32:52.635]   ..- attr(*, "localhost")= logi TRUE
[10:32:52.635]  $ master          : chr "localhost"
[10:32:52.635]  $ port            : int 11304
[10:32:52.635]  $ connectTimeout  : num 120
[10:32:52.635]  $ timeout         : num 2592000
[10:32:52.635]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:32:52.635]  $ homogeneous     : logi TRUE
[10:32:52.635]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:32:52.635]  $ rscript_envs    : NULL
[10:32:52.635]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:52.635]  $ rscript_startup : NULL
[10:32:52.635]  $ rscript_sh      : chr "sh"
[10:32:52.635]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:52.635]  $ methods         : logi TRUE
[10:32:52.635]  $ socketOptions   : chr "no-delay"
[10:32:52.635]  $ useXDR          : logi FALSE
[10:32:52.635]  $ outfile         : chr "/dev/null"
[10:32:52.635]  $ renice          : int NA
[10:32:52.635]  $ rshcmd          : NULL
[10:32:52.635]  $ user            : chr(0) 
[10:32:52.635]  $ revtunnel       : logi FALSE
[10:32:52.635]  $ rshlogfile      : NULL
[10:32:52.635]  $ rshopts         : chr(0) 
[10:32:52.635]  $ rank            : int 1
[10:32:52.635]  $ manual          : logi FALSE
[10:32:52.635]  $ dryrun          : logi FALSE
[10:32:52.635]  $ quiet           : logi FALSE
[10:32:52.635]  $ setup_strategy  : chr "parallel"
[10:32:52.635]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:52.635]  $ pidfile         : chr "/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6924668589.pid"
[10:32:52.635]  $ rshcmd_label    : NULL
[10:32:52.635]  $ rsh_call        : NULL
[10:32:52.635]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:52.635]  $ localMachine    : logi TRUE
[10:32:52.635]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:32:52.635]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:32:52.635]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:32:52.635]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:32:52.635]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:32:52.635]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:32:52.635]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:32:52.635]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:32:52.635]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:32:52.635]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:32:52.635]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:32:52.635]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:32:52.635]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:32:52.635]  $ arguments       :List of 28
[10:32:52.635]   ..$ worker          : chr "localhost"
[10:32:52.635]   ..$ master          : NULL
[10:32:52.635]   ..$ port            : int 11304
[10:32:52.635]   ..$ connectTimeout  : num 120
[10:32:52.635]   ..$ timeout         : num 2592000
[10:32:52.635]   ..$ rscript         : NULL
[10:32:52.635]   ..$ homogeneous     : NULL
[10:32:52.635]   ..$ rscript_args    : NULL
[10:32:52.635]   ..$ rscript_envs    : NULL
[10:32:52.635]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:52.635]   ..$ rscript_startup : NULL
[10:32:52.635]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:32:52.635]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:52.635]   ..$ methods         : logi TRUE
[10:32:52.635]   ..$ socketOptions   : chr "no-delay"
[10:32:52.635]   ..$ useXDR          : logi FALSE
[10:32:52.635]   ..$ outfile         : chr "/dev/null"
[10:32:52.635]   ..$ renice          : int NA
[10:32:52.635]   ..$ rshcmd          : NULL
[10:32:52.635]   ..$ user            : NULL
[10:32:52.635]   ..$ revtunnel       : logi NA
[10:32:52.635]   ..$ rshlogfile      : NULL
[10:32:52.635]   ..$ rshopts         : NULL
[10:32:52.635]   ..$ rank            : int 1
[10:32:52.635]   ..$ manual          : logi FALSE
[10:32:52.635]   ..$ dryrun          : logi FALSE
[10:32:52.635]   ..$ quiet           : logi FALSE
[10:32:52.635]   ..$ setup_strategy  : chr "parallel"
[10:32:52.635]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:32:52.658] [local output] System call to launch all workers:
[10:32:52.658] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6924668589.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11304 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:32:52.658] [local output] Starting PSOCK main server
[10:32:52.659] [local output] Workers launched
[10:32:52.660] [local output] Waiting for workers to connect back
[10:32:52.660]  - [local output] 0 workers out of 2 ready
[10:32:52.903]  - [local output] 0 workers out of 2 ready
[10:32:52.904]  - [local output] 1 workers out of 2 ready
[10:32:52.908]  - [local output] 1 workers out of 2 ready
[10:32:52.909]  - [local output] 2 workers out of 2 ready
[10:32:52.909] [local output] Launching of workers completed
[10:32:52.909] [local output] Collecting session information from workers
[10:32:52.910] [local output]  - Worker #1 of 2
[10:32:52.910] [local output]  - Worker #2 of 2
[10:32:52.910] [local output] makeClusterPSOCK() ... done
[10:32:52.922] Packages needed by the future expression (n = 0): <none>
[10:32:52.922] Packages needed by future strategies (n = 0): <none>
[10:32:52.923] {
[10:32:52.923]     {
[10:32:52.923]         {
[10:32:52.923]             ...future.startTime <- base::Sys.time()
[10:32:52.923]             {
[10:32:52.923]                 {
[10:32:52.923]                   {
[10:32:52.923]                     {
[10:32:52.923]                       base::local({
[10:32:52.923]                         has_future <- base::requireNamespace("future", 
[10:32:52.923]                           quietly = TRUE)
[10:32:52.923]                         if (has_future) {
[10:32:52.923]                           ns <- base::getNamespace("future")
[10:32:52.923]                           version <- ns[[".package"]][["version"]]
[10:32:52.923]                           if (is.null(version)) 
[10:32:52.923]                             version <- utils::packageVersion("future")
[10:32:52.923]                         }
[10:32:52.923]                         else {
[10:32:52.923]                           version <- NULL
[10:32:52.923]                         }
[10:32:52.923]                         if (!has_future || version < "1.8.0") {
[10:32:52.923]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:52.923]                             "", base::R.version$version.string), 
[10:32:52.923]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:52.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:52.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:52.923]                               "release", "version")], collapse = " "), 
[10:32:52.923]                             hostname = base::Sys.info()[["nodename"]])
[10:32:52.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:52.923]                             info)
[10:32:52.923]                           info <- base::paste(info, collapse = "; ")
[10:32:52.923]                           if (!has_future) {
[10:32:52.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:52.923]                               info)
[10:32:52.923]                           }
[10:32:52.923]                           else {
[10:32:52.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:52.923]                               info, version)
[10:32:52.923]                           }
[10:32:52.923]                           base::stop(msg)
[10:32:52.923]                         }
[10:32:52.923]                       })
[10:32:52.923]                     }
[10:32:52.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:52.923]                     base::options(mc.cores = 1L)
[10:32:52.923]                   }
[10:32:52.923]                   ...future.strategy.old <- future::plan("list")
[10:32:52.923]                   options(future.plan = NULL)
[10:32:52.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:52.923]                 }
[10:32:52.923]                 ...future.workdir <- getwd()
[10:32:52.923]             }
[10:32:52.923]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:52.923]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:52.923]         }
[10:32:52.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:52.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:52.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:52.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:52.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:52.923]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:52.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:52.923]             base::names(...future.oldOptions))
[10:32:52.923]     }
[10:32:52.923]     if (FALSE) {
[10:32:52.923]     }
[10:32:52.923]     else {
[10:32:52.923]         if (TRUE) {
[10:32:52.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:52.923]                 open = "w")
[10:32:52.923]         }
[10:32:52.923]         else {
[10:32:52.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:52.923]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:52.923]         }
[10:32:52.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:52.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:52.923]             base::sink(type = "output", split = FALSE)
[10:32:52.923]             base::close(...future.stdout)
[10:32:52.923]         }, add = TRUE)
[10:32:52.923]     }
[10:32:52.923]     ...future.frame <- base::sys.nframe()
[10:32:52.923]     ...future.conditions <- base::list()
[10:32:52.923]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:52.923]     if (FALSE) {
[10:32:52.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:52.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:52.923]     }
[10:32:52.923]     ...future.result <- base::tryCatch({
[10:32:52.923]         base::withCallingHandlers({
[10:32:52.923]             ...future.value <- base::withVisible(base::local({
[10:32:52.923]                 ...future.makeSendCondition <- base::local({
[10:32:52.923]                   sendCondition <- NULL
[10:32:52.923]                   function(frame = 1L) {
[10:32:52.923]                     if (is.function(sendCondition)) 
[10:32:52.923]                       return(sendCondition)
[10:32:52.923]                     ns <- getNamespace("parallel")
[10:32:52.923]                     if (exists("sendData", mode = "function", 
[10:32:52.923]                       envir = ns)) {
[10:32:52.923]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:52.923]                         envir = ns)
[10:32:52.923]                       envir <- sys.frame(frame)
[10:32:52.923]                       master <- NULL
[10:32:52.923]                       while (!identical(envir, .GlobalEnv) && 
[10:32:52.923]                         !identical(envir, emptyenv())) {
[10:32:52.923]                         if (exists("master", mode = "list", envir = envir, 
[10:32:52.923]                           inherits = FALSE)) {
[10:32:52.923]                           master <- get("master", mode = "list", 
[10:32:52.923]                             envir = envir, inherits = FALSE)
[10:32:52.923]                           if (inherits(master, c("SOCKnode", 
[10:32:52.923]                             "SOCK0node"))) {
[10:32:52.923]                             sendCondition <<- function(cond) {
[10:32:52.923]                               data <- list(type = "VALUE", value = cond, 
[10:32:52.923]                                 success = TRUE)
[10:32:52.923]                               parallel_sendData(master, data)
[10:32:52.923]                             }
[10:32:52.923]                             return(sendCondition)
[10:32:52.923]                           }
[10:32:52.923]                         }
[10:32:52.923]                         frame <- frame + 1L
[10:32:52.923]                         envir <- sys.frame(frame)
[10:32:52.923]                       }
[10:32:52.923]                     }
[10:32:52.923]                     sendCondition <<- function(cond) NULL
[10:32:52.923]                   }
[10:32:52.923]                 })
[10:32:52.923]                 withCallingHandlers({
[10:32:52.923]                   NA
[10:32:52.923]                 }, immediateCondition = function(cond) {
[10:32:52.923]                   sendCondition <- ...future.makeSendCondition()
[10:32:52.923]                   sendCondition(cond)
[10:32:52.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.923]                   {
[10:32:52.923]                     inherits <- base::inherits
[10:32:52.923]                     invokeRestart <- base::invokeRestart
[10:32:52.923]                     is.null <- base::is.null
[10:32:52.923]                     muffled <- FALSE
[10:32:52.923]                     if (inherits(cond, "message")) {
[10:32:52.923]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:52.923]                       if (muffled) 
[10:32:52.923]                         invokeRestart("muffleMessage")
[10:32:52.923]                     }
[10:32:52.923]                     else if (inherits(cond, "warning")) {
[10:32:52.923]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:52.923]                       if (muffled) 
[10:32:52.923]                         invokeRestart("muffleWarning")
[10:32:52.923]                     }
[10:32:52.923]                     else if (inherits(cond, "condition")) {
[10:32:52.923]                       if (!is.null(pattern)) {
[10:32:52.923]                         computeRestarts <- base::computeRestarts
[10:32:52.923]                         grepl <- base::grepl
[10:32:52.923]                         restarts <- computeRestarts(cond)
[10:32:52.923]                         for (restart in restarts) {
[10:32:52.923]                           name <- restart$name
[10:32:52.923]                           if (is.null(name)) 
[10:32:52.923]                             next
[10:32:52.923]                           if (!grepl(pattern, name)) 
[10:32:52.923]                             next
[10:32:52.923]                           invokeRestart(restart)
[10:32:52.923]                           muffled <- TRUE
[10:32:52.923]                           break
[10:32:52.923]                         }
[10:32:52.923]                       }
[10:32:52.923]                     }
[10:32:52.923]                     invisible(muffled)
[10:32:52.923]                   }
[10:32:52.923]                   muffleCondition(cond)
[10:32:52.923]                 })
[10:32:52.923]             }))
[10:32:52.923]             future::FutureResult(value = ...future.value$value, 
[10:32:52.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.923]                   ...future.rng), globalenv = if (FALSE) 
[10:32:52.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:52.923]                     ...future.globalenv.names))
[10:32:52.923]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:52.923]         }, condition = base::local({
[10:32:52.923]             c <- base::c
[10:32:52.923]             inherits <- base::inherits
[10:32:52.923]             invokeRestart <- base::invokeRestart
[10:32:52.923]             length <- base::length
[10:32:52.923]             list <- base::list
[10:32:52.923]             seq.int <- base::seq.int
[10:32:52.923]             signalCondition <- base::signalCondition
[10:32:52.923]             sys.calls <- base::sys.calls
[10:32:52.923]             `[[` <- base::`[[`
[10:32:52.923]             `+` <- base::`+`
[10:32:52.923]             `<<-` <- base::`<<-`
[10:32:52.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:52.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:52.923]                   3L)]
[10:32:52.923]             }
[10:32:52.923]             function(cond) {
[10:32:52.923]                 is_error <- inherits(cond, "error")
[10:32:52.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:52.923]                   NULL)
[10:32:52.923]                 if (is_error) {
[10:32:52.923]                   sessionInformation <- function() {
[10:32:52.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:52.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:52.923]                       search = base::search(), system = base::Sys.info())
[10:32:52.923]                   }
[10:32:52.923]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:52.923]                     cond$call), session = sessionInformation(), 
[10:32:52.923]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:52.923]                   signalCondition(cond)
[10:32:52.923]                 }
[10:32:52.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:52.923]                 "immediateCondition"))) {
[10:32:52.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:52.923]                   ...future.conditions[[length(...future.conditions) + 
[10:32:52.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:52.923]                   if (TRUE && !signal) {
[10:32:52.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.923]                     {
[10:32:52.923]                       inherits <- base::inherits
[10:32:52.923]                       invokeRestart <- base::invokeRestart
[10:32:52.923]                       is.null <- base::is.null
[10:32:52.923]                       muffled <- FALSE
[10:32:52.923]                       if (inherits(cond, "message")) {
[10:32:52.923]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.923]                         if (muffled) 
[10:32:52.923]                           invokeRestart("muffleMessage")
[10:32:52.923]                       }
[10:32:52.923]                       else if (inherits(cond, "warning")) {
[10:32:52.923]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.923]                         if (muffled) 
[10:32:52.923]                           invokeRestart("muffleWarning")
[10:32:52.923]                       }
[10:32:52.923]                       else if (inherits(cond, "condition")) {
[10:32:52.923]                         if (!is.null(pattern)) {
[10:32:52.923]                           computeRestarts <- base::computeRestarts
[10:32:52.923]                           grepl <- base::grepl
[10:32:52.923]                           restarts <- computeRestarts(cond)
[10:32:52.923]                           for (restart in restarts) {
[10:32:52.923]                             name <- restart$name
[10:32:52.923]                             if (is.null(name)) 
[10:32:52.923]                               next
[10:32:52.923]                             if (!grepl(pattern, name)) 
[10:32:52.923]                               next
[10:32:52.923]                             invokeRestart(restart)
[10:32:52.923]                             muffled <- TRUE
[10:32:52.923]                             break
[10:32:52.923]                           }
[10:32:52.923]                         }
[10:32:52.923]                       }
[10:32:52.923]                       invisible(muffled)
[10:32:52.923]                     }
[10:32:52.923]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.923]                   }
[10:32:52.923]                 }
[10:32:52.923]                 else {
[10:32:52.923]                   if (TRUE) {
[10:32:52.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:52.923]                     {
[10:32:52.923]                       inherits <- base::inherits
[10:32:52.923]                       invokeRestart <- base::invokeRestart
[10:32:52.923]                       is.null <- base::is.null
[10:32:52.923]                       muffled <- FALSE
[10:32:52.923]                       if (inherits(cond, "message")) {
[10:32:52.923]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:52.923]                         if (muffled) 
[10:32:52.923]                           invokeRestart("muffleMessage")
[10:32:52.923]                       }
[10:32:52.923]                       else if (inherits(cond, "warning")) {
[10:32:52.923]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:52.923]                         if (muffled) 
[10:32:52.923]                           invokeRestart("muffleWarning")
[10:32:52.923]                       }
[10:32:52.923]                       else if (inherits(cond, "condition")) {
[10:32:52.923]                         if (!is.null(pattern)) {
[10:32:52.923]                           computeRestarts <- base::computeRestarts
[10:32:52.923]                           grepl <- base::grepl
[10:32:52.923]                           restarts <- computeRestarts(cond)
[10:32:52.923]                           for (restart in restarts) {
[10:32:52.923]                             name <- restart$name
[10:32:52.923]                             if (is.null(name)) 
[10:32:52.923]                               next
[10:32:52.923]                             if (!grepl(pattern, name)) 
[10:32:52.923]                               next
[10:32:52.923]                             invokeRestart(restart)
[10:32:52.923]                             muffled <- TRUE
[10:32:52.923]                             break
[10:32:52.923]                           }
[10:32:52.923]                         }
[10:32:52.923]                       }
[10:32:52.923]                       invisible(muffled)
[10:32:52.923]                     }
[10:32:52.923]                     muffleCondition(cond, pattern = "^muffle")
[10:32:52.923]                   }
[10:32:52.923]                 }
[10:32:52.923]             }
[10:32:52.923]         }))
[10:32:52.923]     }, error = function(ex) {
[10:32:52.923]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:52.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:52.923]                 ...future.rng), started = ...future.startTime, 
[10:32:52.923]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:52.923]             version = "1.8"), class = "FutureResult")
[10:32:52.923]     }, finally = {
[10:32:52.923]         if (!identical(...future.workdir, getwd())) 
[10:32:52.923]             setwd(...future.workdir)
[10:32:52.923]         {
[10:32:52.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:52.923]                 ...future.oldOptions$nwarnings <- NULL
[10:32:52.923]             }
[10:32:52.923]             base::options(...future.oldOptions)
[10:32:52.923]             if (.Platform$OS.type == "windows") {
[10:32:52.923]                 old_names <- names(...future.oldEnvVars)
[10:32:52.923]                 envs <- base::Sys.getenv()
[10:32:52.923]                 names <- names(envs)
[10:32:52.923]                 common <- intersect(names, old_names)
[10:32:52.923]                 added <- setdiff(names, old_names)
[10:32:52.923]                 removed <- setdiff(old_names, names)
[10:32:52.923]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:52.923]                   envs[common]]
[10:32:52.923]                 NAMES <- toupper(changed)
[10:32:52.923]                 args <- list()
[10:32:52.923]                 for (kk in seq_along(NAMES)) {
[10:32:52.923]                   name <- changed[[kk]]
[10:32:52.923]                   NAME <- NAMES[[kk]]
[10:32:52.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.923]                     next
[10:32:52.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.923]                 }
[10:32:52.923]                 NAMES <- toupper(added)
[10:32:52.923]                 for (kk in seq_along(NAMES)) {
[10:32:52.923]                   name <- added[[kk]]
[10:32:52.923]                   NAME <- NAMES[[kk]]
[10:32:52.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.923]                     next
[10:32:52.923]                   args[[name]] <- ""
[10:32:52.923]                 }
[10:32:52.923]                 NAMES <- toupper(removed)
[10:32:52.923]                 for (kk in seq_along(NAMES)) {
[10:32:52.923]                   name <- removed[[kk]]
[10:32:52.923]                   NAME <- NAMES[[kk]]
[10:32:52.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:52.923]                     next
[10:32:52.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:52.923]                 }
[10:32:52.923]                 if (length(args) > 0) 
[10:32:52.923]                   base::do.call(base::Sys.setenv, args = args)
[10:32:52.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:52.923]             }
[10:32:52.923]             else {
[10:32:52.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:52.923]             }
[10:32:52.923]             {
[10:32:52.923]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:52.923]                   0L) {
[10:32:52.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:52.923]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:52.923]                   base::options(opts)
[10:32:52.923]                 }
[10:32:52.923]                 {
[10:32:52.923]                   {
[10:32:52.923]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:52.923]                     NULL
[10:32:52.923]                   }
[10:32:52.923]                   options(future.plan = NULL)
[10:32:52.923]                   if (is.na(NA_character_)) 
[10:32:52.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:52.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:52.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:52.923]                     .init = FALSE)
[10:32:52.923]                 }
[10:32:52.923]             }
[10:32:52.923]         }
[10:32:52.923]     })
[10:32:52.923]     if (TRUE) {
[10:32:52.923]         base::sink(type = "output", split = FALSE)
[10:32:52.923]         if (TRUE) {
[10:32:52.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:52.923]         }
[10:32:52.923]         else {
[10:32:52.923]             ...future.result["stdout"] <- base::list(NULL)
[10:32:52.923]         }
[10:32:52.923]         base::close(...future.stdout)
[10:32:52.923]         ...future.stdout <- NULL
[10:32:52.923]     }
[10:32:52.923]     ...future.result$conditions <- ...future.conditions
[10:32:52.923]     ...future.result$finished <- base::Sys.time()
[10:32:52.923]     ...future.result
[10:32:52.923] }
[10:32:52.974] MultisessionFuture started
[10:32:52.975] result() for ClusterFuture ...
[10:32:52.975] receiveMessageFromWorker() for ClusterFuture ...
[10:32:52.975] - Validating connection of MultisessionFuture
[10:32:53.008] - received message: FutureResult
[10:32:53.008] - Received FutureResult
[10:32:53.008] - Erased future from FutureRegistry
[10:32:53.009] result() for ClusterFuture ...
[10:32:53.009] - result already collected: FutureResult
[10:32:53.009] result() for ClusterFuture ... done
[10:32:53.009] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.009] result() for ClusterFuture ... done
[10:32:53.009] result() for ClusterFuture ...
[10:32:53.009] - result already collected: FutureResult
[10:32:53.009] result() for ClusterFuture ... done
[10:32:53.010] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:32:53.013] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:32:53.014] getGlobalsAndPackages() ...
[10:32:53.014] Searching for globals...
[10:32:53.014] 
[10:32:53.014] Searching for globals ... DONE
[10:32:53.014] - globals: [0] <none>
[10:32:53.015] getGlobalsAndPackages() ... DONE
[10:32:53.015] run() for ‘Future’ ...
[10:32:53.015] - state: ‘created’
[10:32:53.015] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.029] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.030]   - Field: ‘node’
[10:32:53.030]   - Field: ‘label’
[10:32:53.030]   - Field: ‘local’
[10:32:53.030]   - Field: ‘owner’
[10:32:53.030]   - Field: ‘envir’
[10:32:53.030]   - Field: ‘workers’
[10:32:53.030]   - Field: ‘packages’
[10:32:53.030]   - Field: ‘gc’
[10:32:53.030]   - Field: ‘conditions’
[10:32:53.031]   - Field: ‘persistent’
[10:32:53.031]   - Field: ‘expr’
[10:32:53.031]   - Field: ‘uuid’
[10:32:53.031]   - Field: ‘seed’
[10:32:53.031]   - Field: ‘version’
[10:32:53.031]   - Field: ‘result’
[10:32:53.031]   - Field: ‘asynchronous’
[10:32:53.031]   - Field: ‘calls’
[10:32:53.031]   - Field: ‘globals’
[10:32:53.031]   - Field: ‘stdout’
[10:32:53.032]   - Field: ‘earlySignal’
[10:32:53.032]   - Field: ‘lazy’
[10:32:53.032]   - Field: ‘state’
[10:32:53.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.032] - Launch lazy future ...
[10:32:53.032] Packages needed by the future expression (n = 0): <none>
[10:32:53.032] Packages needed by future strategies (n = 0): <none>
[10:32:53.033] {
[10:32:53.033]     {
[10:32:53.033]         {
[10:32:53.033]             ...future.startTime <- base::Sys.time()
[10:32:53.033]             {
[10:32:53.033]                 {
[10:32:53.033]                   {
[10:32:53.033]                     {
[10:32:53.033]                       base::local({
[10:32:53.033]                         has_future <- base::requireNamespace("future", 
[10:32:53.033]                           quietly = TRUE)
[10:32:53.033]                         if (has_future) {
[10:32:53.033]                           ns <- base::getNamespace("future")
[10:32:53.033]                           version <- ns[[".package"]][["version"]]
[10:32:53.033]                           if (is.null(version)) 
[10:32:53.033]                             version <- utils::packageVersion("future")
[10:32:53.033]                         }
[10:32:53.033]                         else {
[10:32:53.033]                           version <- NULL
[10:32:53.033]                         }
[10:32:53.033]                         if (!has_future || version < "1.8.0") {
[10:32:53.033]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.033]                             "", base::R.version$version.string), 
[10:32:53.033]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.033]                               "release", "version")], collapse = " "), 
[10:32:53.033]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.033]                             info)
[10:32:53.033]                           info <- base::paste(info, collapse = "; ")
[10:32:53.033]                           if (!has_future) {
[10:32:53.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.033]                               info)
[10:32:53.033]                           }
[10:32:53.033]                           else {
[10:32:53.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.033]                               info, version)
[10:32:53.033]                           }
[10:32:53.033]                           base::stop(msg)
[10:32:53.033]                         }
[10:32:53.033]                       })
[10:32:53.033]                     }
[10:32:53.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.033]                     base::options(mc.cores = 1L)
[10:32:53.033]                   }
[10:32:53.033]                   ...future.strategy.old <- future::plan("list")
[10:32:53.033]                   options(future.plan = NULL)
[10:32:53.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.033]                 }
[10:32:53.033]                 ...future.workdir <- getwd()
[10:32:53.033]             }
[10:32:53.033]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.033]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.033]         }
[10:32:53.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.033]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.033]             base::names(...future.oldOptions))
[10:32:53.033]     }
[10:32:53.033]     if (FALSE) {
[10:32:53.033]     }
[10:32:53.033]     else {
[10:32:53.033]         if (TRUE) {
[10:32:53.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.033]                 open = "w")
[10:32:53.033]         }
[10:32:53.033]         else {
[10:32:53.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.033]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.033]         }
[10:32:53.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.033]             base::sink(type = "output", split = FALSE)
[10:32:53.033]             base::close(...future.stdout)
[10:32:53.033]         }, add = TRUE)
[10:32:53.033]     }
[10:32:53.033]     ...future.frame <- base::sys.nframe()
[10:32:53.033]     ...future.conditions <- base::list()
[10:32:53.033]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.033]     if (FALSE) {
[10:32:53.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.033]     }
[10:32:53.033]     ...future.result <- base::tryCatch({
[10:32:53.033]         base::withCallingHandlers({
[10:32:53.033]             ...future.value <- base::withVisible(base::local({
[10:32:53.033]                 ...future.makeSendCondition <- base::local({
[10:32:53.033]                   sendCondition <- NULL
[10:32:53.033]                   function(frame = 1L) {
[10:32:53.033]                     if (is.function(sendCondition)) 
[10:32:53.033]                       return(sendCondition)
[10:32:53.033]                     ns <- getNamespace("parallel")
[10:32:53.033]                     if (exists("sendData", mode = "function", 
[10:32:53.033]                       envir = ns)) {
[10:32:53.033]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.033]                         envir = ns)
[10:32:53.033]                       envir <- sys.frame(frame)
[10:32:53.033]                       master <- NULL
[10:32:53.033]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.033]                         !identical(envir, emptyenv())) {
[10:32:53.033]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.033]                           inherits = FALSE)) {
[10:32:53.033]                           master <- get("master", mode = "list", 
[10:32:53.033]                             envir = envir, inherits = FALSE)
[10:32:53.033]                           if (inherits(master, c("SOCKnode", 
[10:32:53.033]                             "SOCK0node"))) {
[10:32:53.033]                             sendCondition <<- function(cond) {
[10:32:53.033]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.033]                                 success = TRUE)
[10:32:53.033]                               parallel_sendData(master, data)
[10:32:53.033]                             }
[10:32:53.033]                             return(sendCondition)
[10:32:53.033]                           }
[10:32:53.033]                         }
[10:32:53.033]                         frame <- frame + 1L
[10:32:53.033]                         envir <- sys.frame(frame)
[10:32:53.033]                       }
[10:32:53.033]                     }
[10:32:53.033]                     sendCondition <<- function(cond) NULL
[10:32:53.033]                   }
[10:32:53.033]                 })
[10:32:53.033]                 withCallingHandlers({
[10:32:53.033]                   2
[10:32:53.033]                 }, immediateCondition = function(cond) {
[10:32:53.033]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.033]                   sendCondition(cond)
[10:32:53.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.033]                   {
[10:32:53.033]                     inherits <- base::inherits
[10:32:53.033]                     invokeRestart <- base::invokeRestart
[10:32:53.033]                     is.null <- base::is.null
[10:32:53.033]                     muffled <- FALSE
[10:32:53.033]                     if (inherits(cond, "message")) {
[10:32:53.033]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.033]                       if (muffled) 
[10:32:53.033]                         invokeRestart("muffleMessage")
[10:32:53.033]                     }
[10:32:53.033]                     else if (inherits(cond, "warning")) {
[10:32:53.033]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.033]                       if (muffled) 
[10:32:53.033]                         invokeRestart("muffleWarning")
[10:32:53.033]                     }
[10:32:53.033]                     else if (inherits(cond, "condition")) {
[10:32:53.033]                       if (!is.null(pattern)) {
[10:32:53.033]                         computeRestarts <- base::computeRestarts
[10:32:53.033]                         grepl <- base::grepl
[10:32:53.033]                         restarts <- computeRestarts(cond)
[10:32:53.033]                         for (restart in restarts) {
[10:32:53.033]                           name <- restart$name
[10:32:53.033]                           if (is.null(name)) 
[10:32:53.033]                             next
[10:32:53.033]                           if (!grepl(pattern, name)) 
[10:32:53.033]                             next
[10:32:53.033]                           invokeRestart(restart)
[10:32:53.033]                           muffled <- TRUE
[10:32:53.033]                           break
[10:32:53.033]                         }
[10:32:53.033]                       }
[10:32:53.033]                     }
[10:32:53.033]                     invisible(muffled)
[10:32:53.033]                   }
[10:32:53.033]                   muffleCondition(cond)
[10:32:53.033]                 })
[10:32:53.033]             }))
[10:32:53.033]             future::FutureResult(value = ...future.value$value, 
[10:32:53.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.033]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.033]                     ...future.globalenv.names))
[10:32:53.033]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.033]         }, condition = base::local({
[10:32:53.033]             c <- base::c
[10:32:53.033]             inherits <- base::inherits
[10:32:53.033]             invokeRestart <- base::invokeRestart
[10:32:53.033]             length <- base::length
[10:32:53.033]             list <- base::list
[10:32:53.033]             seq.int <- base::seq.int
[10:32:53.033]             signalCondition <- base::signalCondition
[10:32:53.033]             sys.calls <- base::sys.calls
[10:32:53.033]             `[[` <- base::`[[`
[10:32:53.033]             `+` <- base::`+`
[10:32:53.033]             `<<-` <- base::`<<-`
[10:32:53.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.033]                   3L)]
[10:32:53.033]             }
[10:32:53.033]             function(cond) {
[10:32:53.033]                 is_error <- inherits(cond, "error")
[10:32:53.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.033]                   NULL)
[10:32:53.033]                 if (is_error) {
[10:32:53.033]                   sessionInformation <- function() {
[10:32:53.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.033]                       search = base::search(), system = base::Sys.info())
[10:32:53.033]                   }
[10:32:53.033]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.033]                     cond$call), session = sessionInformation(), 
[10:32:53.033]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.033]                   signalCondition(cond)
[10:32:53.033]                 }
[10:32:53.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.033]                 "immediateCondition"))) {
[10:32:53.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.033]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.033]                   if (TRUE && !signal) {
[10:32:53.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.033]                     {
[10:32:53.033]                       inherits <- base::inherits
[10:32:53.033]                       invokeRestart <- base::invokeRestart
[10:32:53.033]                       is.null <- base::is.null
[10:32:53.033]                       muffled <- FALSE
[10:32:53.033]                       if (inherits(cond, "message")) {
[10:32:53.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.033]                         if (muffled) 
[10:32:53.033]                           invokeRestart("muffleMessage")
[10:32:53.033]                       }
[10:32:53.033]                       else if (inherits(cond, "warning")) {
[10:32:53.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.033]                         if (muffled) 
[10:32:53.033]                           invokeRestart("muffleWarning")
[10:32:53.033]                       }
[10:32:53.033]                       else if (inherits(cond, "condition")) {
[10:32:53.033]                         if (!is.null(pattern)) {
[10:32:53.033]                           computeRestarts <- base::computeRestarts
[10:32:53.033]                           grepl <- base::grepl
[10:32:53.033]                           restarts <- computeRestarts(cond)
[10:32:53.033]                           for (restart in restarts) {
[10:32:53.033]                             name <- restart$name
[10:32:53.033]                             if (is.null(name)) 
[10:32:53.033]                               next
[10:32:53.033]                             if (!grepl(pattern, name)) 
[10:32:53.033]                               next
[10:32:53.033]                             invokeRestart(restart)
[10:32:53.033]                             muffled <- TRUE
[10:32:53.033]                             break
[10:32:53.033]                           }
[10:32:53.033]                         }
[10:32:53.033]                       }
[10:32:53.033]                       invisible(muffled)
[10:32:53.033]                     }
[10:32:53.033]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.033]                   }
[10:32:53.033]                 }
[10:32:53.033]                 else {
[10:32:53.033]                   if (TRUE) {
[10:32:53.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.033]                     {
[10:32:53.033]                       inherits <- base::inherits
[10:32:53.033]                       invokeRestart <- base::invokeRestart
[10:32:53.033]                       is.null <- base::is.null
[10:32:53.033]                       muffled <- FALSE
[10:32:53.033]                       if (inherits(cond, "message")) {
[10:32:53.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.033]                         if (muffled) 
[10:32:53.033]                           invokeRestart("muffleMessage")
[10:32:53.033]                       }
[10:32:53.033]                       else if (inherits(cond, "warning")) {
[10:32:53.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.033]                         if (muffled) 
[10:32:53.033]                           invokeRestart("muffleWarning")
[10:32:53.033]                       }
[10:32:53.033]                       else if (inherits(cond, "condition")) {
[10:32:53.033]                         if (!is.null(pattern)) {
[10:32:53.033]                           computeRestarts <- base::computeRestarts
[10:32:53.033]                           grepl <- base::grepl
[10:32:53.033]                           restarts <- computeRestarts(cond)
[10:32:53.033]                           for (restart in restarts) {
[10:32:53.033]                             name <- restart$name
[10:32:53.033]                             if (is.null(name)) 
[10:32:53.033]                               next
[10:32:53.033]                             if (!grepl(pattern, name)) 
[10:32:53.033]                               next
[10:32:53.033]                             invokeRestart(restart)
[10:32:53.033]                             muffled <- TRUE
[10:32:53.033]                             break
[10:32:53.033]                           }
[10:32:53.033]                         }
[10:32:53.033]                       }
[10:32:53.033]                       invisible(muffled)
[10:32:53.033]                     }
[10:32:53.033]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.033]                   }
[10:32:53.033]                 }
[10:32:53.033]             }
[10:32:53.033]         }))
[10:32:53.033]     }, error = function(ex) {
[10:32:53.033]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.033]                 ...future.rng), started = ...future.startTime, 
[10:32:53.033]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.033]             version = "1.8"), class = "FutureResult")
[10:32:53.033]     }, finally = {
[10:32:53.033]         if (!identical(...future.workdir, getwd())) 
[10:32:53.033]             setwd(...future.workdir)
[10:32:53.033]         {
[10:32:53.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.033]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.033]             }
[10:32:53.033]             base::options(...future.oldOptions)
[10:32:53.033]             if (.Platform$OS.type == "windows") {
[10:32:53.033]                 old_names <- names(...future.oldEnvVars)
[10:32:53.033]                 envs <- base::Sys.getenv()
[10:32:53.033]                 names <- names(envs)
[10:32:53.033]                 common <- intersect(names, old_names)
[10:32:53.033]                 added <- setdiff(names, old_names)
[10:32:53.033]                 removed <- setdiff(old_names, names)
[10:32:53.033]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.033]                   envs[common]]
[10:32:53.033]                 NAMES <- toupper(changed)
[10:32:53.033]                 args <- list()
[10:32:53.033]                 for (kk in seq_along(NAMES)) {
[10:32:53.033]                   name <- changed[[kk]]
[10:32:53.033]                   NAME <- NAMES[[kk]]
[10:32:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.033]                     next
[10:32:53.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.033]                 }
[10:32:53.033]                 NAMES <- toupper(added)
[10:32:53.033]                 for (kk in seq_along(NAMES)) {
[10:32:53.033]                   name <- added[[kk]]
[10:32:53.033]                   NAME <- NAMES[[kk]]
[10:32:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.033]                     next
[10:32:53.033]                   args[[name]] <- ""
[10:32:53.033]                 }
[10:32:53.033]                 NAMES <- toupper(removed)
[10:32:53.033]                 for (kk in seq_along(NAMES)) {
[10:32:53.033]                   name <- removed[[kk]]
[10:32:53.033]                   NAME <- NAMES[[kk]]
[10:32:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.033]                     next
[10:32:53.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.033]                 }
[10:32:53.033]                 if (length(args) > 0) 
[10:32:53.033]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.033]             }
[10:32:53.033]             else {
[10:32:53.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.033]             }
[10:32:53.033]             {
[10:32:53.033]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.033]                   0L) {
[10:32:53.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.033]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.033]                   base::options(opts)
[10:32:53.033]                 }
[10:32:53.033]                 {
[10:32:53.033]                   {
[10:32:53.033]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.033]                     NULL
[10:32:53.033]                   }
[10:32:53.033]                   options(future.plan = NULL)
[10:32:53.033]                   if (is.na(NA_character_)) 
[10:32:53.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.033]                     .init = FALSE)
[10:32:53.033]                 }
[10:32:53.033]             }
[10:32:53.033]         }
[10:32:53.033]     })
[10:32:53.033]     if (TRUE) {
[10:32:53.033]         base::sink(type = "output", split = FALSE)
[10:32:53.033]         if (TRUE) {
[10:32:53.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.033]         }
[10:32:53.033]         else {
[10:32:53.033]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.033]         }
[10:32:53.033]         base::close(...future.stdout)
[10:32:53.033]         ...future.stdout <- NULL
[10:32:53.033]     }
[10:32:53.033]     ...future.result$conditions <- ...future.conditions
[10:32:53.033]     ...future.result$finished <- base::Sys.time()
[10:32:53.033]     ...future.result
[10:32:53.033] }
[10:32:53.036] MultisessionFuture started
[10:32:53.036] - Launch lazy future ... done
[10:32:53.036] run() for ‘MultisessionFuture’ ... done
[10:32:53.036] getGlobalsAndPackages() ...
[10:32:53.036] Searching for globals...
[10:32:53.037] 
[10:32:53.037] Searching for globals ... DONE
[10:32:53.037] - globals: [0] <none>
[10:32:53.037] getGlobalsAndPackages() ... DONE
[10:32:53.037] run() for ‘Future’ ...
[10:32:53.038] - state: ‘created’
[10:32:53.038] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.053]   - Field: ‘node’
[10:32:53.053]   - Field: ‘label’
[10:32:53.053]   - Field: ‘local’
[10:32:53.053]   - Field: ‘owner’
[10:32:53.053]   - Field: ‘envir’
[10:32:53.053]   - Field: ‘workers’
[10:32:53.054]   - Field: ‘packages’
[10:32:53.054]   - Field: ‘gc’
[10:32:53.054]   - Field: ‘conditions’
[10:32:53.054]   - Field: ‘persistent’
[10:32:53.054]   - Field: ‘expr’
[10:32:53.054]   - Field: ‘uuid’
[10:32:53.054]   - Field: ‘seed’
[10:32:53.054]   - Field: ‘version’
[10:32:53.054]   - Field: ‘result’
[10:32:53.054]   - Field: ‘asynchronous’
[10:32:53.055]   - Field: ‘calls’
[10:32:53.055]   - Field: ‘globals’
[10:32:53.055]   - Field: ‘stdout’
[10:32:53.055]   - Field: ‘earlySignal’
[10:32:53.055]   - Field: ‘lazy’
[10:32:53.055]   - Field: ‘state’
[10:32:53.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.055] - Launch lazy future ...
[10:32:53.056] Packages needed by the future expression (n = 0): <none>
[10:32:53.056] Packages needed by future strategies (n = 0): <none>
[10:32:53.056] {
[10:32:53.056]     {
[10:32:53.056]         {
[10:32:53.056]             ...future.startTime <- base::Sys.time()
[10:32:53.056]             {
[10:32:53.056]                 {
[10:32:53.056]                   {
[10:32:53.056]                     {
[10:32:53.056]                       base::local({
[10:32:53.056]                         has_future <- base::requireNamespace("future", 
[10:32:53.056]                           quietly = TRUE)
[10:32:53.056]                         if (has_future) {
[10:32:53.056]                           ns <- base::getNamespace("future")
[10:32:53.056]                           version <- ns[[".package"]][["version"]]
[10:32:53.056]                           if (is.null(version)) 
[10:32:53.056]                             version <- utils::packageVersion("future")
[10:32:53.056]                         }
[10:32:53.056]                         else {
[10:32:53.056]                           version <- NULL
[10:32:53.056]                         }
[10:32:53.056]                         if (!has_future || version < "1.8.0") {
[10:32:53.056]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.056]                             "", base::R.version$version.string), 
[10:32:53.056]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.056]                               "release", "version")], collapse = " "), 
[10:32:53.056]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.056]                             info)
[10:32:53.056]                           info <- base::paste(info, collapse = "; ")
[10:32:53.056]                           if (!has_future) {
[10:32:53.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.056]                               info)
[10:32:53.056]                           }
[10:32:53.056]                           else {
[10:32:53.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.056]                               info, version)
[10:32:53.056]                           }
[10:32:53.056]                           base::stop(msg)
[10:32:53.056]                         }
[10:32:53.056]                       })
[10:32:53.056]                     }
[10:32:53.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.056]                     base::options(mc.cores = 1L)
[10:32:53.056]                   }
[10:32:53.056]                   ...future.strategy.old <- future::plan("list")
[10:32:53.056]                   options(future.plan = NULL)
[10:32:53.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.056]                 }
[10:32:53.056]                 ...future.workdir <- getwd()
[10:32:53.056]             }
[10:32:53.056]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.056]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.056]         }
[10:32:53.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.056]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.056]             base::names(...future.oldOptions))
[10:32:53.056]     }
[10:32:53.056]     if (FALSE) {
[10:32:53.056]     }
[10:32:53.056]     else {
[10:32:53.056]         if (TRUE) {
[10:32:53.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.056]                 open = "w")
[10:32:53.056]         }
[10:32:53.056]         else {
[10:32:53.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.056]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.056]         }
[10:32:53.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.056]             base::sink(type = "output", split = FALSE)
[10:32:53.056]             base::close(...future.stdout)
[10:32:53.056]         }, add = TRUE)
[10:32:53.056]     }
[10:32:53.056]     ...future.frame <- base::sys.nframe()
[10:32:53.056]     ...future.conditions <- base::list()
[10:32:53.056]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.056]     if (FALSE) {
[10:32:53.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.056]     }
[10:32:53.056]     ...future.result <- base::tryCatch({
[10:32:53.056]         base::withCallingHandlers({
[10:32:53.056]             ...future.value <- base::withVisible(base::local({
[10:32:53.056]                 ...future.makeSendCondition <- base::local({
[10:32:53.056]                   sendCondition <- NULL
[10:32:53.056]                   function(frame = 1L) {
[10:32:53.056]                     if (is.function(sendCondition)) 
[10:32:53.056]                       return(sendCondition)
[10:32:53.056]                     ns <- getNamespace("parallel")
[10:32:53.056]                     if (exists("sendData", mode = "function", 
[10:32:53.056]                       envir = ns)) {
[10:32:53.056]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.056]                         envir = ns)
[10:32:53.056]                       envir <- sys.frame(frame)
[10:32:53.056]                       master <- NULL
[10:32:53.056]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.056]                         !identical(envir, emptyenv())) {
[10:32:53.056]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.056]                           inherits = FALSE)) {
[10:32:53.056]                           master <- get("master", mode = "list", 
[10:32:53.056]                             envir = envir, inherits = FALSE)
[10:32:53.056]                           if (inherits(master, c("SOCKnode", 
[10:32:53.056]                             "SOCK0node"))) {
[10:32:53.056]                             sendCondition <<- function(cond) {
[10:32:53.056]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.056]                                 success = TRUE)
[10:32:53.056]                               parallel_sendData(master, data)
[10:32:53.056]                             }
[10:32:53.056]                             return(sendCondition)
[10:32:53.056]                           }
[10:32:53.056]                         }
[10:32:53.056]                         frame <- frame + 1L
[10:32:53.056]                         envir <- sys.frame(frame)
[10:32:53.056]                       }
[10:32:53.056]                     }
[10:32:53.056]                     sendCondition <<- function(cond) NULL
[10:32:53.056]                   }
[10:32:53.056]                 })
[10:32:53.056]                 withCallingHandlers({
[10:32:53.056]                   NULL
[10:32:53.056]                 }, immediateCondition = function(cond) {
[10:32:53.056]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.056]                   sendCondition(cond)
[10:32:53.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.056]                   {
[10:32:53.056]                     inherits <- base::inherits
[10:32:53.056]                     invokeRestart <- base::invokeRestart
[10:32:53.056]                     is.null <- base::is.null
[10:32:53.056]                     muffled <- FALSE
[10:32:53.056]                     if (inherits(cond, "message")) {
[10:32:53.056]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.056]                       if (muffled) 
[10:32:53.056]                         invokeRestart("muffleMessage")
[10:32:53.056]                     }
[10:32:53.056]                     else if (inherits(cond, "warning")) {
[10:32:53.056]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.056]                       if (muffled) 
[10:32:53.056]                         invokeRestart("muffleWarning")
[10:32:53.056]                     }
[10:32:53.056]                     else if (inherits(cond, "condition")) {
[10:32:53.056]                       if (!is.null(pattern)) {
[10:32:53.056]                         computeRestarts <- base::computeRestarts
[10:32:53.056]                         grepl <- base::grepl
[10:32:53.056]                         restarts <- computeRestarts(cond)
[10:32:53.056]                         for (restart in restarts) {
[10:32:53.056]                           name <- restart$name
[10:32:53.056]                           if (is.null(name)) 
[10:32:53.056]                             next
[10:32:53.056]                           if (!grepl(pattern, name)) 
[10:32:53.056]                             next
[10:32:53.056]                           invokeRestart(restart)
[10:32:53.056]                           muffled <- TRUE
[10:32:53.056]                           break
[10:32:53.056]                         }
[10:32:53.056]                       }
[10:32:53.056]                     }
[10:32:53.056]                     invisible(muffled)
[10:32:53.056]                   }
[10:32:53.056]                   muffleCondition(cond)
[10:32:53.056]                 })
[10:32:53.056]             }))
[10:32:53.056]             future::FutureResult(value = ...future.value$value, 
[10:32:53.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.056]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.056]                     ...future.globalenv.names))
[10:32:53.056]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.056]         }, condition = base::local({
[10:32:53.056]             c <- base::c
[10:32:53.056]             inherits <- base::inherits
[10:32:53.056]             invokeRestart <- base::invokeRestart
[10:32:53.056]             length <- base::length
[10:32:53.056]             list <- base::list
[10:32:53.056]             seq.int <- base::seq.int
[10:32:53.056]             signalCondition <- base::signalCondition
[10:32:53.056]             sys.calls <- base::sys.calls
[10:32:53.056]             `[[` <- base::`[[`
[10:32:53.056]             `+` <- base::`+`
[10:32:53.056]             `<<-` <- base::`<<-`
[10:32:53.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.056]                   3L)]
[10:32:53.056]             }
[10:32:53.056]             function(cond) {
[10:32:53.056]                 is_error <- inherits(cond, "error")
[10:32:53.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.056]                   NULL)
[10:32:53.056]                 if (is_error) {
[10:32:53.056]                   sessionInformation <- function() {
[10:32:53.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.056]                       search = base::search(), system = base::Sys.info())
[10:32:53.056]                   }
[10:32:53.056]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.056]                     cond$call), session = sessionInformation(), 
[10:32:53.056]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.056]                   signalCondition(cond)
[10:32:53.056]                 }
[10:32:53.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.056]                 "immediateCondition"))) {
[10:32:53.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.056]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.056]                   if (TRUE && !signal) {
[10:32:53.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.056]                     {
[10:32:53.056]                       inherits <- base::inherits
[10:32:53.056]                       invokeRestart <- base::invokeRestart
[10:32:53.056]                       is.null <- base::is.null
[10:32:53.056]                       muffled <- FALSE
[10:32:53.056]                       if (inherits(cond, "message")) {
[10:32:53.056]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.056]                         if (muffled) 
[10:32:53.056]                           invokeRestart("muffleMessage")
[10:32:53.056]                       }
[10:32:53.056]                       else if (inherits(cond, "warning")) {
[10:32:53.056]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.056]                         if (muffled) 
[10:32:53.056]                           invokeRestart("muffleWarning")
[10:32:53.056]                       }
[10:32:53.056]                       else if (inherits(cond, "condition")) {
[10:32:53.056]                         if (!is.null(pattern)) {
[10:32:53.056]                           computeRestarts <- base::computeRestarts
[10:32:53.056]                           grepl <- base::grepl
[10:32:53.056]                           restarts <- computeRestarts(cond)
[10:32:53.056]                           for (restart in restarts) {
[10:32:53.056]                             name <- restart$name
[10:32:53.056]                             if (is.null(name)) 
[10:32:53.056]                               next
[10:32:53.056]                             if (!grepl(pattern, name)) 
[10:32:53.056]                               next
[10:32:53.056]                             invokeRestart(restart)
[10:32:53.056]                             muffled <- TRUE
[10:32:53.056]                             break
[10:32:53.056]                           }
[10:32:53.056]                         }
[10:32:53.056]                       }
[10:32:53.056]                       invisible(muffled)
[10:32:53.056]                     }
[10:32:53.056]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.056]                   }
[10:32:53.056]                 }
[10:32:53.056]                 else {
[10:32:53.056]                   if (TRUE) {
[10:32:53.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.056]                     {
[10:32:53.056]                       inherits <- base::inherits
[10:32:53.056]                       invokeRestart <- base::invokeRestart
[10:32:53.056]                       is.null <- base::is.null
[10:32:53.056]                       muffled <- FALSE
[10:32:53.056]                       if (inherits(cond, "message")) {
[10:32:53.056]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.056]                         if (muffled) 
[10:32:53.056]                           invokeRestart("muffleMessage")
[10:32:53.056]                       }
[10:32:53.056]                       else if (inherits(cond, "warning")) {
[10:32:53.056]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.056]                         if (muffled) 
[10:32:53.056]                           invokeRestart("muffleWarning")
[10:32:53.056]                       }
[10:32:53.056]                       else if (inherits(cond, "condition")) {
[10:32:53.056]                         if (!is.null(pattern)) {
[10:32:53.056]                           computeRestarts <- base::computeRestarts
[10:32:53.056]                           grepl <- base::grepl
[10:32:53.056]                           restarts <- computeRestarts(cond)
[10:32:53.056]                           for (restart in restarts) {
[10:32:53.056]                             name <- restart$name
[10:32:53.056]                             if (is.null(name)) 
[10:32:53.056]                               next
[10:32:53.056]                             if (!grepl(pattern, name)) 
[10:32:53.056]                               next
[10:32:53.056]                             invokeRestart(restart)
[10:32:53.056]                             muffled <- TRUE
[10:32:53.056]                             break
[10:32:53.056]                           }
[10:32:53.056]                         }
[10:32:53.056]                       }
[10:32:53.056]                       invisible(muffled)
[10:32:53.056]                     }
[10:32:53.056]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.056]                   }
[10:32:53.056]                 }
[10:32:53.056]             }
[10:32:53.056]         }))
[10:32:53.056]     }, error = function(ex) {
[10:32:53.056]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.056]                 ...future.rng), started = ...future.startTime, 
[10:32:53.056]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.056]             version = "1.8"), class = "FutureResult")
[10:32:53.056]     }, finally = {
[10:32:53.056]         if (!identical(...future.workdir, getwd())) 
[10:32:53.056]             setwd(...future.workdir)
[10:32:53.056]         {
[10:32:53.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.056]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.056]             }
[10:32:53.056]             base::options(...future.oldOptions)
[10:32:53.056]             if (.Platform$OS.type == "windows") {
[10:32:53.056]                 old_names <- names(...future.oldEnvVars)
[10:32:53.056]                 envs <- base::Sys.getenv()
[10:32:53.056]                 names <- names(envs)
[10:32:53.056]                 common <- intersect(names, old_names)
[10:32:53.056]                 added <- setdiff(names, old_names)
[10:32:53.056]                 removed <- setdiff(old_names, names)
[10:32:53.056]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.056]                   envs[common]]
[10:32:53.056]                 NAMES <- toupper(changed)
[10:32:53.056]                 args <- list()
[10:32:53.056]                 for (kk in seq_along(NAMES)) {
[10:32:53.056]                   name <- changed[[kk]]
[10:32:53.056]                   NAME <- NAMES[[kk]]
[10:32:53.056]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.056]                     next
[10:32:53.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.056]                 }
[10:32:53.056]                 NAMES <- toupper(added)
[10:32:53.056]                 for (kk in seq_along(NAMES)) {
[10:32:53.056]                   name <- added[[kk]]
[10:32:53.056]                   NAME <- NAMES[[kk]]
[10:32:53.056]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.056]                     next
[10:32:53.056]                   args[[name]] <- ""
[10:32:53.056]                 }
[10:32:53.056]                 NAMES <- toupper(removed)
[10:32:53.056]                 for (kk in seq_along(NAMES)) {
[10:32:53.056]                   name <- removed[[kk]]
[10:32:53.056]                   NAME <- NAMES[[kk]]
[10:32:53.056]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.056]                     next
[10:32:53.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.056]                 }
[10:32:53.056]                 if (length(args) > 0) 
[10:32:53.056]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.056]             }
[10:32:53.056]             else {
[10:32:53.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.056]             }
[10:32:53.056]             {
[10:32:53.056]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.056]                   0L) {
[10:32:53.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.056]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.056]                   base::options(opts)
[10:32:53.056]                 }
[10:32:53.056]                 {
[10:32:53.056]                   {
[10:32:53.056]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.056]                     NULL
[10:32:53.056]                   }
[10:32:53.056]                   options(future.plan = NULL)
[10:32:53.056]                   if (is.na(NA_character_)) 
[10:32:53.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.056]                     .init = FALSE)
[10:32:53.056]                 }
[10:32:53.056]             }
[10:32:53.056]         }
[10:32:53.056]     })
[10:32:53.056]     if (TRUE) {
[10:32:53.056]         base::sink(type = "output", split = FALSE)
[10:32:53.056]         if (TRUE) {
[10:32:53.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.056]         }
[10:32:53.056]         else {
[10:32:53.056]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.056]         }
[10:32:53.056]         base::close(...future.stdout)
[10:32:53.056]         ...future.stdout <- NULL
[10:32:53.056]     }
[10:32:53.056]     ...future.result$conditions <- ...future.conditions
[10:32:53.056]     ...future.result$finished <- base::Sys.time()
[10:32:53.056]     ...future.result
[10:32:53.056] }
[10:32:53.111] MultisessionFuture started
[10:32:53.112] - Launch lazy future ... done
[10:32:53.112] run() for ‘MultisessionFuture’ ... done
[10:32:53.112] getGlobalsAndPackages() ...
[10:32:53.112] Searching for globals...
[10:32:53.113] - globals found: [1] ‘{’
[10:32:53.113] Searching for globals ... DONE
[10:32:53.113] Resolving globals: FALSE
[10:32:53.114] 
[10:32:53.114] 
[10:32:53.114] getGlobalsAndPackages() ... DONE
[10:32:53.114] run() for ‘Future’ ...
[10:32:53.114] - state: ‘created’
[10:32:53.114] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.130]   - Field: ‘node’
[10:32:53.130]   - Field: ‘label’
[10:32:53.130]   - Field: ‘local’
[10:32:53.130]   - Field: ‘owner’
[10:32:53.130]   - Field: ‘envir’
[10:32:53.130]   - Field: ‘workers’
[10:32:53.130]   - Field: ‘packages’
[10:32:53.130]   - Field: ‘gc’
[10:32:53.131]   - Field: ‘conditions’
[10:32:53.131]   - Field: ‘persistent’
[10:32:53.131]   - Field: ‘expr’
[10:32:53.131]   - Field: ‘uuid’
[10:32:53.131]   - Field: ‘seed’
[10:32:53.131]   - Field: ‘version’
[10:32:53.131]   - Field: ‘result’
[10:32:53.131]   - Field: ‘asynchronous’
[10:32:53.131]   - Field: ‘calls’
[10:32:53.131]   - Field: ‘globals’
[10:32:53.131]   - Field: ‘stdout’
[10:32:53.132]   - Field: ‘earlySignal’
[10:32:53.132]   - Field: ‘lazy’
[10:32:53.132]   - Field: ‘state’
[10:32:53.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.132] - Launch lazy future ...
[10:32:53.132] Packages needed by the future expression (n = 0): <none>
[10:32:53.132] Packages needed by future strategies (n = 0): <none>
[10:32:53.133] {
[10:32:53.133]     {
[10:32:53.133]         {
[10:32:53.133]             ...future.startTime <- base::Sys.time()
[10:32:53.133]             {
[10:32:53.133]                 {
[10:32:53.133]                   {
[10:32:53.133]                     {
[10:32:53.133]                       base::local({
[10:32:53.133]                         has_future <- base::requireNamespace("future", 
[10:32:53.133]                           quietly = TRUE)
[10:32:53.133]                         if (has_future) {
[10:32:53.133]                           ns <- base::getNamespace("future")
[10:32:53.133]                           version <- ns[[".package"]][["version"]]
[10:32:53.133]                           if (is.null(version)) 
[10:32:53.133]                             version <- utils::packageVersion("future")
[10:32:53.133]                         }
[10:32:53.133]                         else {
[10:32:53.133]                           version <- NULL
[10:32:53.133]                         }
[10:32:53.133]                         if (!has_future || version < "1.8.0") {
[10:32:53.133]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.133]                             "", base::R.version$version.string), 
[10:32:53.133]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.133]                               "release", "version")], collapse = " "), 
[10:32:53.133]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.133]                             info)
[10:32:53.133]                           info <- base::paste(info, collapse = "; ")
[10:32:53.133]                           if (!has_future) {
[10:32:53.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.133]                               info)
[10:32:53.133]                           }
[10:32:53.133]                           else {
[10:32:53.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.133]                               info, version)
[10:32:53.133]                           }
[10:32:53.133]                           base::stop(msg)
[10:32:53.133]                         }
[10:32:53.133]                       })
[10:32:53.133]                     }
[10:32:53.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.133]                     base::options(mc.cores = 1L)
[10:32:53.133]                   }
[10:32:53.133]                   ...future.strategy.old <- future::plan("list")
[10:32:53.133]                   options(future.plan = NULL)
[10:32:53.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.133]                 }
[10:32:53.133]                 ...future.workdir <- getwd()
[10:32:53.133]             }
[10:32:53.133]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.133]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.133]         }
[10:32:53.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.133]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.133]             base::names(...future.oldOptions))
[10:32:53.133]     }
[10:32:53.133]     if (FALSE) {
[10:32:53.133]     }
[10:32:53.133]     else {
[10:32:53.133]         if (TRUE) {
[10:32:53.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.133]                 open = "w")
[10:32:53.133]         }
[10:32:53.133]         else {
[10:32:53.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.133]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.133]         }
[10:32:53.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.133]             base::sink(type = "output", split = FALSE)
[10:32:53.133]             base::close(...future.stdout)
[10:32:53.133]         }, add = TRUE)
[10:32:53.133]     }
[10:32:53.133]     ...future.frame <- base::sys.nframe()
[10:32:53.133]     ...future.conditions <- base::list()
[10:32:53.133]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.133]     if (FALSE) {
[10:32:53.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.133]     }
[10:32:53.133]     ...future.result <- base::tryCatch({
[10:32:53.133]         base::withCallingHandlers({
[10:32:53.133]             ...future.value <- base::withVisible(base::local({
[10:32:53.133]                 ...future.makeSendCondition <- base::local({
[10:32:53.133]                   sendCondition <- NULL
[10:32:53.133]                   function(frame = 1L) {
[10:32:53.133]                     if (is.function(sendCondition)) 
[10:32:53.133]                       return(sendCondition)
[10:32:53.133]                     ns <- getNamespace("parallel")
[10:32:53.133]                     if (exists("sendData", mode = "function", 
[10:32:53.133]                       envir = ns)) {
[10:32:53.133]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.133]                         envir = ns)
[10:32:53.133]                       envir <- sys.frame(frame)
[10:32:53.133]                       master <- NULL
[10:32:53.133]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.133]                         !identical(envir, emptyenv())) {
[10:32:53.133]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.133]                           inherits = FALSE)) {
[10:32:53.133]                           master <- get("master", mode = "list", 
[10:32:53.133]                             envir = envir, inherits = FALSE)
[10:32:53.133]                           if (inherits(master, c("SOCKnode", 
[10:32:53.133]                             "SOCK0node"))) {
[10:32:53.133]                             sendCondition <<- function(cond) {
[10:32:53.133]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.133]                                 success = TRUE)
[10:32:53.133]                               parallel_sendData(master, data)
[10:32:53.133]                             }
[10:32:53.133]                             return(sendCondition)
[10:32:53.133]                           }
[10:32:53.133]                         }
[10:32:53.133]                         frame <- frame + 1L
[10:32:53.133]                         envir <- sys.frame(frame)
[10:32:53.133]                       }
[10:32:53.133]                     }
[10:32:53.133]                     sendCondition <<- function(cond) NULL
[10:32:53.133]                   }
[10:32:53.133]                 })
[10:32:53.133]                 withCallingHandlers({
[10:32:53.133]                   {
[10:32:53.133]                     4
[10:32:53.133]                   }
[10:32:53.133]                 }, immediateCondition = function(cond) {
[10:32:53.133]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.133]                   sendCondition(cond)
[10:32:53.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.133]                   {
[10:32:53.133]                     inherits <- base::inherits
[10:32:53.133]                     invokeRestart <- base::invokeRestart
[10:32:53.133]                     is.null <- base::is.null
[10:32:53.133]                     muffled <- FALSE
[10:32:53.133]                     if (inherits(cond, "message")) {
[10:32:53.133]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.133]                       if (muffled) 
[10:32:53.133]                         invokeRestart("muffleMessage")
[10:32:53.133]                     }
[10:32:53.133]                     else if (inherits(cond, "warning")) {
[10:32:53.133]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.133]                       if (muffled) 
[10:32:53.133]                         invokeRestart("muffleWarning")
[10:32:53.133]                     }
[10:32:53.133]                     else if (inherits(cond, "condition")) {
[10:32:53.133]                       if (!is.null(pattern)) {
[10:32:53.133]                         computeRestarts <- base::computeRestarts
[10:32:53.133]                         grepl <- base::grepl
[10:32:53.133]                         restarts <- computeRestarts(cond)
[10:32:53.133]                         for (restart in restarts) {
[10:32:53.133]                           name <- restart$name
[10:32:53.133]                           if (is.null(name)) 
[10:32:53.133]                             next
[10:32:53.133]                           if (!grepl(pattern, name)) 
[10:32:53.133]                             next
[10:32:53.133]                           invokeRestart(restart)
[10:32:53.133]                           muffled <- TRUE
[10:32:53.133]                           break
[10:32:53.133]                         }
[10:32:53.133]                       }
[10:32:53.133]                     }
[10:32:53.133]                     invisible(muffled)
[10:32:53.133]                   }
[10:32:53.133]                   muffleCondition(cond)
[10:32:53.133]                 })
[10:32:53.133]             }))
[10:32:53.133]             future::FutureResult(value = ...future.value$value, 
[10:32:53.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.133]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.133]                     ...future.globalenv.names))
[10:32:53.133]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.133]         }, condition = base::local({
[10:32:53.133]             c <- base::c
[10:32:53.133]             inherits <- base::inherits
[10:32:53.133]             invokeRestart <- base::invokeRestart
[10:32:53.133]             length <- base::length
[10:32:53.133]             list <- base::list
[10:32:53.133]             seq.int <- base::seq.int
[10:32:53.133]             signalCondition <- base::signalCondition
[10:32:53.133]             sys.calls <- base::sys.calls
[10:32:53.133]             `[[` <- base::`[[`
[10:32:53.133]             `+` <- base::`+`
[10:32:53.133]             `<<-` <- base::`<<-`
[10:32:53.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.133]                   3L)]
[10:32:53.133]             }
[10:32:53.133]             function(cond) {
[10:32:53.133]                 is_error <- inherits(cond, "error")
[10:32:53.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.133]                   NULL)
[10:32:53.133]                 if (is_error) {
[10:32:53.133]                   sessionInformation <- function() {
[10:32:53.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.133]                       search = base::search(), system = base::Sys.info())
[10:32:53.133]                   }
[10:32:53.133]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.133]                     cond$call), session = sessionInformation(), 
[10:32:53.133]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.133]                   signalCondition(cond)
[10:32:53.133]                 }
[10:32:53.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.133]                 "immediateCondition"))) {
[10:32:53.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.133]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.133]                   if (TRUE && !signal) {
[10:32:53.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.133]                     {
[10:32:53.133]                       inherits <- base::inherits
[10:32:53.133]                       invokeRestart <- base::invokeRestart
[10:32:53.133]                       is.null <- base::is.null
[10:32:53.133]                       muffled <- FALSE
[10:32:53.133]                       if (inherits(cond, "message")) {
[10:32:53.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.133]                         if (muffled) 
[10:32:53.133]                           invokeRestart("muffleMessage")
[10:32:53.133]                       }
[10:32:53.133]                       else if (inherits(cond, "warning")) {
[10:32:53.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.133]                         if (muffled) 
[10:32:53.133]                           invokeRestart("muffleWarning")
[10:32:53.133]                       }
[10:32:53.133]                       else if (inherits(cond, "condition")) {
[10:32:53.133]                         if (!is.null(pattern)) {
[10:32:53.133]                           computeRestarts <- base::computeRestarts
[10:32:53.133]                           grepl <- base::grepl
[10:32:53.133]                           restarts <- computeRestarts(cond)
[10:32:53.133]                           for (restart in restarts) {
[10:32:53.133]                             name <- restart$name
[10:32:53.133]                             if (is.null(name)) 
[10:32:53.133]                               next
[10:32:53.133]                             if (!grepl(pattern, name)) 
[10:32:53.133]                               next
[10:32:53.133]                             invokeRestart(restart)
[10:32:53.133]                             muffled <- TRUE
[10:32:53.133]                             break
[10:32:53.133]                           }
[10:32:53.133]                         }
[10:32:53.133]                       }
[10:32:53.133]                       invisible(muffled)
[10:32:53.133]                     }
[10:32:53.133]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.133]                   }
[10:32:53.133]                 }
[10:32:53.133]                 else {
[10:32:53.133]                   if (TRUE) {
[10:32:53.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.133]                     {
[10:32:53.133]                       inherits <- base::inherits
[10:32:53.133]                       invokeRestart <- base::invokeRestart
[10:32:53.133]                       is.null <- base::is.null
[10:32:53.133]                       muffled <- FALSE
[10:32:53.133]                       if (inherits(cond, "message")) {
[10:32:53.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.133]                         if (muffled) 
[10:32:53.133]                           invokeRestart("muffleMessage")
[10:32:53.133]                       }
[10:32:53.133]                       else if (inherits(cond, "warning")) {
[10:32:53.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.133]                         if (muffled) 
[10:32:53.133]                           invokeRestart("muffleWarning")
[10:32:53.133]                       }
[10:32:53.133]                       else if (inherits(cond, "condition")) {
[10:32:53.133]                         if (!is.null(pattern)) {
[10:32:53.133]                           computeRestarts <- base::computeRestarts
[10:32:53.133]                           grepl <- base::grepl
[10:32:53.133]                           restarts <- computeRestarts(cond)
[10:32:53.133]                           for (restart in restarts) {
[10:32:53.133]                             name <- restart$name
[10:32:53.133]                             if (is.null(name)) 
[10:32:53.133]                               next
[10:32:53.133]                             if (!grepl(pattern, name)) 
[10:32:53.133]                               next
[10:32:53.133]                             invokeRestart(restart)
[10:32:53.133]                             muffled <- TRUE
[10:32:53.133]                             break
[10:32:53.133]                           }
[10:32:53.133]                         }
[10:32:53.133]                       }
[10:32:53.133]                       invisible(muffled)
[10:32:53.133]                     }
[10:32:53.133]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.133]                   }
[10:32:53.133]                 }
[10:32:53.133]             }
[10:32:53.133]         }))
[10:32:53.133]     }, error = function(ex) {
[10:32:53.133]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.133]                 ...future.rng), started = ...future.startTime, 
[10:32:53.133]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.133]             version = "1.8"), class = "FutureResult")
[10:32:53.133]     }, finally = {
[10:32:53.133]         if (!identical(...future.workdir, getwd())) 
[10:32:53.133]             setwd(...future.workdir)
[10:32:53.133]         {
[10:32:53.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.133]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.133]             }
[10:32:53.133]             base::options(...future.oldOptions)
[10:32:53.133]             if (.Platform$OS.type == "windows") {
[10:32:53.133]                 old_names <- names(...future.oldEnvVars)
[10:32:53.133]                 envs <- base::Sys.getenv()
[10:32:53.133]                 names <- names(envs)
[10:32:53.133]                 common <- intersect(names, old_names)
[10:32:53.133]                 added <- setdiff(names, old_names)
[10:32:53.133]                 removed <- setdiff(old_names, names)
[10:32:53.133]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.133]                   envs[common]]
[10:32:53.133]                 NAMES <- toupper(changed)
[10:32:53.133]                 args <- list()
[10:32:53.133]                 for (kk in seq_along(NAMES)) {
[10:32:53.133]                   name <- changed[[kk]]
[10:32:53.133]                   NAME <- NAMES[[kk]]
[10:32:53.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.133]                     next
[10:32:53.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.133]                 }
[10:32:53.133]                 NAMES <- toupper(added)
[10:32:53.133]                 for (kk in seq_along(NAMES)) {
[10:32:53.133]                   name <- added[[kk]]
[10:32:53.133]                   NAME <- NAMES[[kk]]
[10:32:53.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.133]                     next
[10:32:53.133]                   args[[name]] <- ""
[10:32:53.133]                 }
[10:32:53.133]                 NAMES <- toupper(removed)
[10:32:53.133]                 for (kk in seq_along(NAMES)) {
[10:32:53.133]                   name <- removed[[kk]]
[10:32:53.133]                   NAME <- NAMES[[kk]]
[10:32:53.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.133]                     next
[10:32:53.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.133]                 }
[10:32:53.133]                 if (length(args) > 0) 
[10:32:53.133]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.133]             }
[10:32:53.133]             else {
[10:32:53.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.133]             }
[10:32:53.133]             {
[10:32:53.133]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.133]                   0L) {
[10:32:53.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.133]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.133]                   base::options(opts)
[10:32:53.133]                 }
[10:32:53.133]                 {
[10:32:53.133]                   {
[10:32:53.133]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.133]                     NULL
[10:32:53.133]                   }
[10:32:53.133]                   options(future.plan = NULL)
[10:32:53.133]                   if (is.na(NA_character_)) 
[10:32:53.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.133]                     .init = FALSE)
[10:32:53.133]                 }
[10:32:53.133]             }
[10:32:53.133]         }
[10:32:53.133]     })
[10:32:53.133]     if (TRUE) {
[10:32:53.133]         base::sink(type = "output", split = FALSE)
[10:32:53.133]         if (TRUE) {
[10:32:53.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.133]         }
[10:32:53.133]         else {
[10:32:53.133]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.133]         }
[10:32:53.133]         base::close(...future.stdout)
[10:32:53.133]         ...future.stdout <- NULL
[10:32:53.133]     }
[10:32:53.133]     ...future.result$conditions <- ...future.conditions
[10:32:53.133]     ...future.result$finished <- base::Sys.time()
[10:32:53.133]     ...future.result
[10:32:53.133] }
[10:32:53.135] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:53.146] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.146] - Validating connection of MultisessionFuture
[10:32:53.146] - received message: FutureResult
[10:32:53.146] - Received FutureResult
[10:32:53.146] - Erased future from FutureRegistry
[10:32:53.147] result() for ClusterFuture ...
[10:32:53.147] - result already collected: FutureResult
[10:32:53.147] result() for ClusterFuture ... done
[10:32:53.147] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.147] result() for ClusterFuture ...
[10:32:53.147] - result already collected: FutureResult
[10:32:53.147] result() for ClusterFuture ... done
[10:32:53.147] result() for ClusterFuture ...
[10:32:53.147] - result already collected: FutureResult
[10:32:53.147] result() for ClusterFuture ... done
[10:32:53.148] MultisessionFuture started
[10:32:53.149] - Launch lazy future ... done
[10:32:53.149] run() for ‘MultisessionFuture’ ... done
<environment: 0x5652d10b72f0> 
<environment: 0x5652d1fb10e0> 
[10:32:53.151] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.151] - Validating connection of MultisessionFuture
[10:32:53.152] - received message: FutureResult
[10:32:53.152] - Received FutureResult
[10:32:53.152] - Erased future from FutureRegistry
[10:32:53.152] result() for ClusterFuture ...
[10:32:53.152] - result already collected: FutureResult
[10:32:53.152] result() for ClusterFuture ... done
[10:32:53.152] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.153] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.153] - Validating connection of MultisessionFuture
[10:32:53.153] - received message: FutureResult
[10:32:53.153] - Received FutureResult
[10:32:53.153] - Erased future from FutureRegistry
[10:32:53.153] result() for ClusterFuture ...
[10:32:53.153] - result already collected: FutureResult
[10:32:53.153] result() for ClusterFuture ... done
[10:32:53.153] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:53.155] resolve() on environment ...
[10:32:53.155]  recursive: 0
[10:32:53.155]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:53.155] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.155] - nx: 4
[10:32:53.155] - relay: TRUE
[10:32:53.156] - stdout: TRUE
[10:32:53.156] - signal: TRUE
[10:32:53.156] - resignal: FALSE
[10:32:53.156] - force: TRUE
[10:32:53.156] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.156] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.156]  - until=2
[10:32:53.156]  - relaying element #2
[10:32:53.156] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.156] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.156] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.157]  length: 3 (resolved future 1)
[10:32:53.157] Future #2
[10:32:53.157] result() for ClusterFuture ...
[10:32:53.157] - result already collected: FutureResult
[10:32:53.157] result() for ClusterFuture ... done
[10:32:53.157] result() for ClusterFuture ...
[10:32:53.157] - result already collected: FutureResult
[10:32:53.157] result() for ClusterFuture ... done
[10:32:53.157] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:53.157] - nx: 4
[10:32:53.158] - relay: TRUE
[10:32:53.158] - stdout: TRUE
[10:32:53.158] - signal: TRUE
[10:32:53.158] - resignal: FALSE
[10:32:53.158] - force: TRUE
[10:32:53.158] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.158] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.158]  - until=2
[10:32:53.158]  - relaying element #2
[10:32:53.158] result() for ClusterFuture ...
[10:32:53.158] - result already collected: FutureResult
[10:32:53.158] result() for ClusterFuture ... done
[10:32:53.159] result() for ClusterFuture ...
[10:32:53.159] - result already collected: FutureResult
[10:32:53.159] result() for ClusterFuture ... done
[10:32:53.159] result() for ClusterFuture ...
[10:32:53.159] - result already collected: FutureResult
[10:32:53.159] result() for ClusterFuture ... done
[10:32:53.159] result() for ClusterFuture ...
[10:32:53.159] - result already collected: FutureResult
[10:32:53.159] result() for ClusterFuture ... done
[10:32:53.159] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.159] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.160] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:53.160]  length: 2 (resolved future 2)
[10:32:53.160] Future #3
[10:32:53.160] result() for ClusterFuture ...
[10:32:53.160] - result already collected: FutureResult
[10:32:53.160] result() for ClusterFuture ... done
[10:32:53.160] result() for ClusterFuture ...
[10:32:53.160] - result already collected: FutureResult
[10:32:53.160] result() for ClusterFuture ... done
[10:32:53.160] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:53.160] - nx: 4
[10:32:53.161] - relay: TRUE
[10:32:53.161] - stdout: TRUE
[10:32:53.161] - signal: TRUE
[10:32:53.161] - resignal: FALSE
[10:32:53.161] - force: TRUE
[10:32:53.161] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.161] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.161]  - until=3
[10:32:53.161]  - relaying element #3
[10:32:53.161] result() for ClusterFuture ...
[10:32:53.161] - result already collected: FutureResult
[10:32:53.162] result() for ClusterFuture ... done
[10:32:53.162] result() for ClusterFuture ...
[10:32:53.162] - result already collected: FutureResult
[10:32:53.162] result() for ClusterFuture ... done
[10:32:53.162] result() for ClusterFuture ...
[10:32:53.162] - result already collected: FutureResult
[10:32:53.162] result() for ClusterFuture ... done
[10:32:53.162] result() for ClusterFuture ...
[10:32:53.162] - result already collected: FutureResult
[10:32:53.162] result() for ClusterFuture ... done
[10:32:53.162] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.163] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.163] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:53.163]  length: 1 (resolved future 3)
[10:32:53.163] Future #4
[10:32:53.163] result() for ClusterFuture ...
[10:32:53.163] - result already collected: FutureResult
[10:32:53.163] result() for ClusterFuture ... done
[10:32:53.163] result() for ClusterFuture ...
[10:32:53.163] - result already collected: FutureResult
[10:32:53.163] result() for ClusterFuture ... done
[10:32:53.163] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:53.164] - nx: 4
[10:32:53.164] - relay: TRUE
[10:32:53.164] - stdout: TRUE
[10:32:53.164] - signal: TRUE
[10:32:53.164] - resignal: FALSE
[10:32:53.164] - force: TRUE
[10:32:53.164] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.164] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.164]  - until=4
[10:32:53.164]  - relaying element #4
[10:32:53.164] result() for ClusterFuture ...
[10:32:53.164] - result already collected: FutureResult
[10:32:53.165] result() for ClusterFuture ... done
[10:32:53.165] result() for ClusterFuture ...
[10:32:53.165] - result already collected: FutureResult
[10:32:53.165] result() for ClusterFuture ... done
[10:32:53.165] result() for ClusterFuture ...
[10:32:53.165] - result already collected: FutureResult
[10:32:53.165] result() for ClusterFuture ... done
[10:32:53.165] result() for ClusterFuture ...
[10:32:53.165] - result already collected: FutureResult
[10:32:53.165] result() for ClusterFuture ... done
[10:32:53.165] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.166] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.166] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:53.166]  length: 0 (resolved future 4)
[10:32:53.166] Relaying remaining futures
[10:32:53.166] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.166] - nx: 4
[10:32:53.166] - relay: TRUE
[10:32:53.166] - stdout: TRUE
[10:32:53.166] - signal: TRUE
[10:32:53.166] - resignal: FALSE
[10:32:53.166] - force: TRUE
[10:32:53.166] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.167] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:53.167] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.167] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.167] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.167] resolve() on environment ... DONE
[10:32:53.167] result() for ClusterFuture ...
[10:32:53.167] - result already collected: FutureResult
[10:32:53.167] result() for ClusterFuture ... done
[10:32:53.167] result() for ClusterFuture ...
[10:32:53.167] - result already collected: FutureResult
[10:32:53.167] result() for ClusterFuture ... done
[10:32:53.168] result() for ClusterFuture ...
[10:32:53.168] - result already collected: FutureResult
[10:32:53.168] result() for ClusterFuture ... done
[10:32:53.168] result() for ClusterFuture ...
[10:32:53.168] - result already collected: FutureResult
[10:32:53.168] result() for ClusterFuture ... done
[10:32:53.168] result() for ClusterFuture ...
[10:32:53.168] - result already collected: FutureResult
[10:32:53.168] result() for ClusterFuture ... done
[10:32:53.168] result() for ClusterFuture ...
[10:32:53.168] - result already collected: FutureResult
[10:32:53.169] result() for ClusterFuture ... done
<environment: 0x5652d21d08a0> 
Dimensions: c(1, 6)
[10:32:53.169] getGlobalsAndPackages() ...
[10:32:53.169] Searching for globals...
[10:32:53.169] 
[10:32:53.170] Searching for globals ... DONE
[10:32:53.170] - globals: [0] <none>
[10:32:53.170] getGlobalsAndPackages() ... DONE
[10:32:53.170] run() for ‘Future’ ...
[10:32:53.170] - state: ‘created’
[10:32:53.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.185] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.185]   - Field: ‘node’
[10:32:53.185]   - Field: ‘label’
[10:32:53.185]   - Field: ‘local’
[10:32:53.185]   - Field: ‘owner’
[10:32:53.185]   - Field: ‘envir’
[10:32:53.185]   - Field: ‘workers’
[10:32:53.186]   - Field: ‘packages’
[10:32:53.186]   - Field: ‘gc’
[10:32:53.186]   - Field: ‘conditions’
[10:32:53.186]   - Field: ‘persistent’
[10:32:53.186]   - Field: ‘expr’
[10:32:53.186]   - Field: ‘uuid’
[10:32:53.186]   - Field: ‘seed’
[10:32:53.186]   - Field: ‘version’
[10:32:53.186]   - Field: ‘result’
[10:32:53.186]   - Field: ‘asynchronous’
[10:32:53.187]   - Field: ‘calls’
[10:32:53.187]   - Field: ‘globals’
[10:32:53.187]   - Field: ‘stdout’
[10:32:53.187]   - Field: ‘earlySignal’
[10:32:53.187]   - Field: ‘lazy’
[10:32:53.187]   - Field: ‘state’
[10:32:53.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.187] - Launch lazy future ...
[10:32:53.187] Packages needed by the future expression (n = 0): <none>
[10:32:53.188] Packages needed by future strategies (n = 0): <none>
[10:32:53.188] {
[10:32:53.188]     {
[10:32:53.188]         {
[10:32:53.188]             ...future.startTime <- base::Sys.time()
[10:32:53.188]             {
[10:32:53.188]                 {
[10:32:53.188]                   {
[10:32:53.188]                     {
[10:32:53.188]                       base::local({
[10:32:53.188]                         has_future <- base::requireNamespace("future", 
[10:32:53.188]                           quietly = TRUE)
[10:32:53.188]                         if (has_future) {
[10:32:53.188]                           ns <- base::getNamespace("future")
[10:32:53.188]                           version <- ns[[".package"]][["version"]]
[10:32:53.188]                           if (is.null(version)) 
[10:32:53.188]                             version <- utils::packageVersion("future")
[10:32:53.188]                         }
[10:32:53.188]                         else {
[10:32:53.188]                           version <- NULL
[10:32:53.188]                         }
[10:32:53.188]                         if (!has_future || version < "1.8.0") {
[10:32:53.188]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.188]                             "", base::R.version$version.string), 
[10:32:53.188]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.188]                               "release", "version")], collapse = " "), 
[10:32:53.188]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.188]                             info)
[10:32:53.188]                           info <- base::paste(info, collapse = "; ")
[10:32:53.188]                           if (!has_future) {
[10:32:53.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.188]                               info)
[10:32:53.188]                           }
[10:32:53.188]                           else {
[10:32:53.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.188]                               info, version)
[10:32:53.188]                           }
[10:32:53.188]                           base::stop(msg)
[10:32:53.188]                         }
[10:32:53.188]                       })
[10:32:53.188]                     }
[10:32:53.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.188]                     base::options(mc.cores = 1L)
[10:32:53.188]                   }
[10:32:53.188]                   ...future.strategy.old <- future::plan("list")
[10:32:53.188]                   options(future.plan = NULL)
[10:32:53.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.188]                 }
[10:32:53.188]                 ...future.workdir <- getwd()
[10:32:53.188]             }
[10:32:53.188]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.188]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.188]         }
[10:32:53.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.188]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.188]             base::names(...future.oldOptions))
[10:32:53.188]     }
[10:32:53.188]     if (FALSE) {
[10:32:53.188]     }
[10:32:53.188]     else {
[10:32:53.188]         if (TRUE) {
[10:32:53.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.188]                 open = "w")
[10:32:53.188]         }
[10:32:53.188]         else {
[10:32:53.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.188]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.188]         }
[10:32:53.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.188]             base::sink(type = "output", split = FALSE)
[10:32:53.188]             base::close(...future.stdout)
[10:32:53.188]         }, add = TRUE)
[10:32:53.188]     }
[10:32:53.188]     ...future.frame <- base::sys.nframe()
[10:32:53.188]     ...future.conditions <- base::list()
[10:32:53.188]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.188]     if (FALSE) {
[10:32:53.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.188]     }
[10:32:53.188]     ...future.result <- base::tryCatch({
[10:32:53.188]         base::withCallingHandlers({
[10:32:53.188]             ...future.value <- base::withVisible(base::local({
[10:32:53.188]                 ...future.makeSendCondition <- base::local({
[10:32:53.188]                   sendCondition <- NULL
[10:32:53.188]                   function(frame = 1L) {
[10:32:53.188]                     if (is.function(sendCondition)) 
[10:32:53.188]                       return(sendCondition)
[10:32:53.188]                     ns <- getNamespace("parallel")
[10:32:53.188]                     if (exists("sendData", mode = "function", 
[10:32:53.188]                       envir = ns)) {
[10:32:53.188]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.188]                         envir = ns)
[10:32:53.188]                       envir <- sys.frame(frame)
[10:32:53.188]                       master <- NULL
[10:32:53.188]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.188]                         !identical(envir, emptyenv())) {
[10:32:53.188]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.188]                           inherits = FALSE)) {
[10:32:53.188]                           master <- get("master", mode = "list", 
[10:32:53.188]                             envir = envir, inherits = FALSE)
[10:32:53.188]                           if (inherits(master, c("SOCKnode", 
[10:32:53.188]                             "SOCK0node"))) {
[10:32:53.188]                             sendCondition <<- function(cond) {
[10:32:53.188]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.188]                                 success = TRUE)
[10:32:53.188]                               parallel_sendData(master, data)
[10:32:53.188]                             }
[10:32:53.188]                             return(sendCondition)
[10:32:53.188]                           }
[10:32:53.188]                         }
[10:32:53.188]                         frame <- frame + 1L
[10:32:53.188]                         envir <- sys.frame(frame)
[10:32:53.188]                       }
[10:32:53.188]                     }
[10:32:53.188]                     sendCondition <<- function(cond) NULL
[10:32:53.188]                   }
[10:32:53.188]                 })
[10:32:53.188]                 withCallingHandlers({
[10:32:53.188]                   2
[10:32:53.188]                 }, immediateCondition = function(cond) {
[10:32:53.188]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.188]                   sendCondition(cond)
[10:32:53.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.188]                   {
[10:32:53.188]                     inherits <- base::inherits
[10:32:53.188]                     invokeRestart <- base::invokeRestart
[10:32:53.188]                     is.null <- base::is.null
[10:32:53.188]                     muffled <- FALSE
[10:32:53.188]                     if (inherits(cond, "message")) {
[10:32:53.188]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.188]                       if (muffled) 
[10:32:53.188]                         invokeRestart("muffleMessage")
[10:32:53.188]                     }
[10:32:53.188]                     else if (inherits(cond, "warning")) {
[10:32:53.188]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.188]                       if (muffled) 
[10:32:53.188]                         invokeRestart("muffleWarning")
[10:32:53.188]                     }
[10:32:53.188]                     else if (inherits(cond, "condition")) {
[10:32:53.188]                       if (!is.null(pattern)) {
[10:32:53.188]                         computeRestarts <- base::computeRestarts
[10:32:53.188]                         grepl <- base::grepl
[10:32:53.188]                         restarts <- computeRestarts(cond)
[10:32:53.188]                         for (restart in restarts) {
[10:32:53.188]                           name <- restart$name
[10:32:53.188]                           if (is.null(name)) 
[10:32:53.188]                             next
[10:32:53.188]                           if (!grepl(pattern, name)) 
[10:32:53.188]                             next
[10:32:53.188]                           invokeRestart(restart)
[10:32:53.188]                           muffled <- TRUE
[10:32:53.188]                           break
[10:32:53.188]                         }
[10:32:53.188]                       }
[10:32:53.188]                     }
[10:32:53.188]                     invisible(muffled)
[10:32:53.188]                   }
[10:32:53.188]                   muffleCondition(cond)
[10:32:53.188]                 })
[10:32:53.188]             }))
[10:32:53.188]             future::FutureResult(value = ...future.value$value, 
[10:32:53.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.188]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.188]                     ...future.globalenv.names))
[10:32:53.188]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.188]         }, condition = base::local({
[10:32:53.188]             c <- base::c
[10:32:53.188]             inherits <- base::inherits
[10:32:53.188]             invokeRestart <- base::invokeRestart
[10:32:53.188]             length <- base::length
[10:32:53.188]             list <- base::list
[10:32:53.188]             seq.int <- base::seq.int
[10:32:53.188]             signalCondition <- base::signalCondition
[10:32:53.188]             sys.calls <- base::sys.calls
[10:32:53.188]             `[[` <- base::`[[`
[10:32:53.188]             `+` <- base::`+`
[10:32:53.188]             `<<-` <- base::`<<-`
[10:32:53.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.188]                   3L)]
[10:32:53.188]             }
[10:32:53.188]             function(cond) {
[10:32:53.188]                 is_error <- inherits(cond, "error")
[10:32:53.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.188]                   NULL)
[10:32:53.188]                 if (is_error) {
[10:32:53.188]                   sessionInformation <- function() {
[10:32:53.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.188]                       search = base::search(), system = base::Sys.info())
[10:32:53.188]                   }
[10:32:53.188]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.188]                     cond$call), session = sessionInformation(), 
[10:32:53.188]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.188]                   signalCondition(cond)
[10:32:53.188]                 }
[10:32:53.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.188]                 "immediateCondition"))) {
[10:32:53.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.188]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.188]                   if (TRUE && !signal) {
[10:32:53.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.188]                     {
[10:32:53.188]                       inherits <- base::inherits
[10:32:53.188]                       invokeRestart <- base::invokeRestart
[10:32:53.188]                       is.null <- base::is.null
[10:32:53.188]                       muffled <- FALSE
[10:32:53.188]                       if (inherits(cond, "message")) {
[10:32:53.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.188]                         if (muffled) 
[10:32:53.188]                           invokeRestart("muffleMessage")
[10:32:53.188]                       }
[10:32:53.188]                       else if (inherits(cond, "warning")) {
[10:32:53.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.188]                         if (muffled) 
[10:32:53.188]                           invokeRestart("muffleWarning")
[10:32:53.188]                       }
[10:32:53.188]                       else if (inherits(cond, "condition")) {
[10:32:53.188]                         if (!is.null(pattern)) {
[10:32:53.188]                           computeRestarts <- base::computeRestarts
[10:32:53.188]                           grepl <- base::grepl
[10:32:53.188]                           restarts <- computeRestarts(cond)
[10:32:53.188]                           for (restart in restarts) {
[10:32:53.188]                             name <- restart$name
[10:32:53.188]                             if (is.null(name)) 
[10:32:53.188]                               next
[10:32:53.188]                             if (!grepl(pattern, name)) 
[10:32:53.188]                               next
[10:32:53.188]                             invokeRestart(restart)
[10:32:53.188]                             muffled <- TRUE
[10:32:53.188]                             break
[10:32:53.188]                           }
[10:32:53.188]                         }
[10:32:53.188]                       }
[10:32:53.188]                       invisible(muffled)
[10:32:53.188]                     }
[10:32:53.188]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.188]                   }
[10:32:53.188]                 }
[10:32:53.188]                 else {
[10:32:53.188]                   if (TRUE) {
[10:32:53.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.188]                     {
[10:32:53.188]                       inherits <- base::inherits
[10:32:53.188]                       invokeRestart <- base::invokeRestart
[10:32:53.188]                       is.null <- base::is.null
[10:32:53.188]                       muffled <- FALSE
[10:32:53.188]                       if (inherits(cond, "message")) {
[10:32:53.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.188]                         if (muffled) 
[10:32:53.188]                           invokeRestart("muffleMessage")
[10:32:53.188]                       }
[10:32:53.188]                       else if (inherits(cond, "warning")) {
[10:32:53.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.188]                         if (muffled) 
[10:32:53.188]                           invokeRestart("muffleWarning")
[10:32:53.188]                       }
[10:32:53.188]                       else if (inherits(cond, "condition")) {
[10:32:53.188]                         if (!is.null(pattern)) {
[10:32:53.188]                           computeRestarts <- base::computeRestarts
[10:32:53.188]                           grepl <- base::grepl
[10:32:53.188]                           restarts <- computeRestarts(cond)
[10:32:53.188]                           for (restart in restarts) {
[10:32:53.188]                             name <- restart$name
[10:32:53.188]                             if (is.null(name)) 
[10:32:53.188]                               next
[10:32:53.188]                             if (!grepl(pattern, name)) 
[10:32:53.188]                               next
[10:32:53.188]                             invokeRestart(restart)
[10:32:53.188]                             muffled <- TRUE
[10:32:53.188]                             break
[10:32:53.188]                           }
[10:32:53.188]                         }
[10:32:53.188]                       }
[10:32:53.188]                       invisible(muffled)
[10:32:53.188]                     }
[10:32:53.188]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.188]                   }
[10:32:53.188]                 }
[10:32:53.188]             }
[10:32:53.188]         }))
[10:32:53.188]     }, error = function(ex) {
[10:32:53.188]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.188]                 ...future.rng), started = ...future.startTime, 
[10:32:53.188]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.188]             version = "1.8"), class = "FutureResult")
[10:32:53.188]     }, finally = {
[10:32:53.188]         if (!identical(...future.workdir, getwd())) 
[10:32:53.188]             setwd(...future.workdir)
[10:32:53.188]         {
[10:32:53.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.188]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.188]             }
[10:32:53.188]             base::options(...future.oldOptions)
[10:32:53.188]             if (.Platform$OS.type == "windows") {
[10:32:53.188]                 old_names <- names(...future.oldEnvVars)
[10:32:53.188]                 envs <- base::Sys.getenv()
[10:32:53.188]                 names <- names(envs)
[10:32:53.188]                 common <- intersect(names, old_names)
[10:32:53.188]                 added <- setdiff(names, old_names)
[10:32:53.188]                 removed <- setdiff(old_names, names)
[10:32:53.188]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.188]                   envs[common]]
[10:32:53.188]                 NAMES <- toupper(changed)
[10:32:53.188]                 args <- list()
[10:32:53.188]                 for (kk in seq_along(NAMES)) {
[10:32:53.188]                   name <- changed[[kk]]
[10:32:53.188]                   NAME <- NAMES[[kk]]
[10:32:53.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.188]                     next
[10:32:53.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.188]                 }
[10:32:53.188]                 NAMES <- toupper(added)
[10:32:53.188]                 for (kk in seq_along(NAMES)) {
[10:32:53.188]                   name <- added[[kk]]
[10:32:53.188]                   NAME <- NAMES[[kk]]
[10:32:53.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.188]                     next
[10:32:53.188]                   args[[name]] <- ""
[10:32:53.188]                 }
[10:32:53.188]                 NAMES <- toupper(removed)
[10:32:53.188]                 for (kk in seq_along(NAMES)) {
[10:32:53.188]                   name <- removed[[kk]]
[10:32:53.188]                   NAME <- NAMES[[kk]]
[10:32:53.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.188]                     next
[10:32:53.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.188]                 }
[10:32:53.188]                 if (length(args) > 0) 
[10:32:53.188]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.188]             }
[10:32:53.188]             else {
[10:32:53.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.188]             }
[10:32:53.188]             {
[10:32:53.188]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.188]                   0L) {
[10:32:53.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.188]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.188]                   base::options(opts)
[10:32:53.188]                 }
[10:32:53.188]                 {
[10:32:53.188]                   {
[10:32:53.188]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.188]                     NULL
[10:32:53.188]                   }
[10:32:53.188]                   options(future.plan = NULL)
[10:32:53.188]                   if (is.na(NA_character_)) 
[10:32:53.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.188]                     .init = FALSE)
[10:32:53.188]                 }
[10:32:53.188]             }
[10:32:53.188]         }
[10:32:53.188]     })
[10:32:53.188]     if (TRUE) {
[10:32:53.188]         base::sink(type = "output", split = FALSE)
[10:32:53.188]         if (TRUE) {
[10:32:53.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.188]         }
[10:32:53.188]         else {
[10:32:53.188]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.188]         }
[10:32:53.188]         base::close(...future.stdout)
[10:32:53.188]         ...future.stdout <- NULL
[10:32:53.188]     }
[10:32:53.188]     ...future.result$conditions <- ...future.conditions
[10:32:53.188]     ...future.result$finished <- base::Sys.time()
[10:32:53.188]     ...future.result
[10:32:53.188] }
[10:32:53.191] MultisessionFuture started
[10:32:53.191] - Launch lazy future ... done
[10:32:53.191] run() for ‘MultisessionFuture’ ... done
[10:32:53.191] getGlobalsAndPackages() ...
[10:32:53.191] Searching for globals...
[10:32:53.192] 
[10:32:53.192] Searching for globals ... DONE
[10:32:53.192] - globals: [0] <none>
[10:32:53.192] getGlobalsAndPackages() ... DONE
[10:32:53.192] run() for ‘Future’ ...
[10:32:53.192] - state: ‘created’
[10:32:53.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.209]   - Field: ‘node’
[10:32:53.209]   - Field: ‘label’
[10:32:53.209]   - Field: ‘local’
[10:32:53.209]   - Field: ‘owner’
[10:32:53.209]   - Field: ‘envir’
[10:32:53.209]   - Field: ‘workers’
[10:32:53.209]   - Field: ‘packages’
[10:32:53.210]   - Field: ‘gc’
[10:32:53.210]   - Field: ‘conditions’
[10:32:53.210]   - Field: ‘persistent’
[10:32:53.210]   - Field: ‘expr’
[10:32:53.210]   - Field: ‘uuid’
[10:32:53.210]   - Field: ‘seed’
[10:32:53.210]   - Field: ‘version’
[10:32:53.210]   - Field: ‘result’
[10:32:53.210]   - Field: ‘asynchronous’
[10:32:53.210]   - Field: ‘calls’
[10:32:53.211]   - Field: ‘globals’
[10:32:53.211]   - Field: ‘stdout’
[10:32:53.211]   - Field: ‘earlySignal’
[10:32:53.211]   - Field: ‘lazy’
[10:32:53.211]   - Field: ‘state’
[10:32:53.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.211] - Launch lazy future ...
[10:32:53.211] Packages needed by the future expression (n = 0): <none>
[10:32:53.211] Packages needed by future strategies (n = 0): <none>
[10:32:53.212] {
[10:32:53.212]     {
[10:32:53.212]         {
[10:32:53.212]             ...future.startTime <- base::Sys.time()
[10:32:53.212]             {
[10:32:53.212]                 {
[10:32:53.212]                   {
[10:32:53.212]                     {
[10:32:53.212]                       base::local({
[10:32:53.212]                         has_future <- base::requireNamespace("future", 
[10:32:53.212]                           quietly = TRUE)
[10:32:53.212]                         if (has_future) {
[10:32:53.212]                           ns <- base::getNamespace("future")
[10:32:53.212]                           version <- ns[[".package"]][["version"]]
[10:32:53.212]                           if (is.null(version)) 
[10:32:53.212]                             version <- utils::packageVersion("future")
[10:32:53.212]                         }
[10:32:53.212]                         else {
[10:32:53.212]                           version <- NULL
[10:32:53.212]                         }
[10:32:53.212]                         if (!has_future || version < "1.8.0") {
[10:32:53.212]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.212]                             "", base::R.version$version.string), 
[10:32:53.212]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.212]                               "release", "version")], collapse = " "), 
[10:32:53.212]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.212]                             info)
[10:32:53.212]                           info <- base::paste(info, collapse = "; ")
[10:32:53.212]                           if (!has_future) {
[10:32:53.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.212]                               info)
[10:32:53.212]                           }
[10:32:53.212]                           else {
[10:32:53.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.212]                               info, version)
[10:32:53.212]                           }
[10:32:53.212]                           base::stop(msg)
[10:32:53.212]                         }
[10:32:53.212]                       })
[10:32:53.212]                     }
[10:32:53.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.212]                     base::options(mc.cores = 1L)
[10:32:53.212]                   }
[10:32:53.212]                   ...future.strategy.old <- future::plan("list")
[10:32:53.212]                   options(future.plan = NULL)
[10:32:53.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.212]                 }
[10:32:53.212]                 ...future.workdir <- getwd()
[10:32:53.212]             }
[10:32:53.212]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.212]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.212]         }
[10:32:53.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.212]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.212]             base::names(...future.oldOptions))
[10:32:53.212]     }
[10:32:53.212]     if (FALSE) {
[10:32:53.212]     }
[10:32:53.212]     else {
[10:32:53.212]         if (TRUE) {
[10:32:53.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.212]                 open = "w")
[10:32:53.212]         }
[10:32:53.212]         else {
[10:32:53.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.212]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.212]         }
[10:32:53.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.212]             base::sink(type = "output", split = FALSE)
[10:32:53.212]             base::close(...future.stdout)
[10:32:53.212]         }, add = TRUE)
[10:32:53.212]     }
[10:32:53.212]     ...future.frame <- base::sys.nframe()
[10:32:53.212]     ...future.conditions <- base::list()
[10:32:53.212]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.212]     if (FALSE) {
[10:32:53.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.212]     }
[10:32:53.212]     ...future.result <- base::tryCatch({
[10:32:53.212]         base::withCallingHandlers({
[10:32:53.212]             ...future.value <- base::withVisible(base::local({
[10:32:53.212]                 ...future.makeSendCondition <- base::local({
[10:32:53.212]                   sendCondition <- NULL
[10:32:53.212]                   function(frame = 1L) {
[10:32:53.212]                     if (is.function(sendCondition)) 
[10:32:53.212]                       return(sendCondition)
[10:32:53.212]                     ns <- getNamespace("parallel")
[10:32:53.212]                     if (exists("sendData", mode = "function", 
[10:32:53.212]                       envir = ns)) {
[10:32:53.212]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.212]                         envir = ns)
[10:32:53.212]                       envir <- sys.frame(frame)
[10:32:53.212]                       master <- NULL
[10:32:53.212]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.212]                         !identical(envir, emptyenv())) {
[10:32:53.212]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.212]                           inherits = FALSE)) {
[10:32:53.212]                           master <- get("master", mode = "list", 
[10:32:53.212]                             envir = envir, inherits = FALSE)
[10:32:53.212]                           if (inherits(master, c("SOCKnode", 
[10:32:53.212]                             "SOCK0node"))) {
[10:32:53.212]                             sendCondition <<- function(cond) {
[10:32:53.212]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.212]                                 success = TRUE)
[10:32:53.212]                               parallel_sendData(master, data)
[10:32:53.212]                             }
[10:32:53.212]                             return(sendCondition)
[10:32:53.212]                           }
[10:32:53.212]                         }
[10:32:53.212]                         frame <- frame + 1L
[10:32:53.212]                         envir <- sys.frame(frame)
[10:32:53.212]                       }
[10:32:53.212]                     }
[10:32:53.212]                     sendCondition <<- function(cond) NULL
[10:32:53.212]                   }
[10:32:53.212]                 })
[10:32:53.212]                 withCallingHandlers({
[10:32:53.212]                   NULL
[10:32:53.212]                 }, immediateCondition = function(cond) {
[10:32:53.212]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.212]                   sendCondition(cond)
[10:32:53.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.212]                   {
[10:32:53.212]                     inherits <- base::inherits
[10:32:53.212]                     invokeRestart <- base::invokeRestart
[10:32:53.212]                     is.null <- base::is.null
[10:32:53.212]                     muffled <- FALSE
[10:32:53.212]                     if (inherits(cond, "message")) {
[10:32:53.212]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.212]                       if (muffled) 
[10:32:53.212]                         invokeRestart("muffleMessage")
[10:32:53.212]                     }
[10:32:53.212]                     else if (inherits(cond, "warning")) {
[10:32:53.212]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.212]                       if (muffled) 
[10:32:53.212]                         invokeRestart("muffleWarning")
[10:32:53.212]                     }
[10:32:53.212]                     else if (inherits(cond, "condition")) {
[10:32:53.212]                       if (!is.null(pattern)) {
[10:32:53.212]                         computeRestarts <- base::computeRestarts
[10:32:53.212]                         grepl <- base::grepl
[10:32:53.212]                         restarts <- computeRestarts(cond)
[10:32:53.212]                         for (restart in restarts) {
[10:32:53.212]                           name <- restart$name
[10:32:53.212]                           if (is.null(name)) 
[10:32:53.212]                             next
[10:32:53.212]                           if (!grepl(pattern, name)) 
[10:32:53.212]                             next
[10:32:53.212]                           invokeRestart(restart)
[10:32:53.212]                           muffled <- TRUE
[10:32:53.212]                           break
[10:32:53.212]                         }
[10:32:53.212]                       }
[10:32:53.212]                     }
[10:32:53.212]                     invisible(muffled)
[10:32:53.212]                   }
[10:32:53.212]                   muffleCondition(cond)
[10:32:53.212]                 })
[10:32:53.212]             }))
[10:32:53.212]             future::FutureResult(value = ...future.value$value, 
[10:32:53.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.212]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.212]                     ...future.globalenv.names))
[10:32:53.212]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.212]         }, condition = base::local({
[10:32:53.212]             c <- base::c
[10:32:53.212]             inherits <- base::inherits
[10:32:53.212]             invokeRestart <- base::invokeRestart
[10:32:53.212]             length <- base::length
[10:32:53.212]             list <- base::list
[10:32:53.212]             seq.int <- base::seq.int
[10:32:53.212]             signalCondition <- base::signalCondition
[10:32:53.212]             sys.calls <- base::sys.calls
[10:32:53.212]             `[[` <- base::`[[`
[10:32:53.212]             `+` <- base::`+`
[10:32:53.212]             `<<-` <- base::`<<-`
[10:32:53.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.212]                   3L)]
[10:32:53.212]             }
[10:32:53.212]             function(cond) {
[10:32:53.212]                 is_error <- inherits(cond, "error")
[10:32:53.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.212]                   NULL)
[10:32:53.212]                 if (is_error) {
[10:32:53.212]                   sessionInformation <- function() {
[10:32:53.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.212]                       search = base::search(), system = base::Sys.info())
[10:32:53.212]                   }
[10:32:53.212]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.212]                     cond$call), session = sessionInformation(), 
[10:32:53.212]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.212]                   signalCondition(cond)
[10:32:53.212]                 }
[10:32:53.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.212]                 "immediateCondition"))) {
[10:32:53.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.212]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.212]                   if (TRUE && !signal) {
[10:32:53.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.212]                     {
[10:32:53.212]                       inherits <- base::inherits
[10:32:53.212]                       invokeRestart <- base::invokeRestart
[10:32:53.212]                       is.null <- base::is.null
[10:32:53.212]                       muffled <- FALSE
[10:32:53.212]                       if (inherits(cond, "message")) {
[10:32:53.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.212]                         if (muffled) 
[10:32:53.212]                           invokeRestart("muffleMessage")
[10:32:53.212]                       }
[10:32:53.212]                       else if (inherits(cond, "warning")) {
[10:32:53.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.212]                         if (muffled) 
[10:32:53.212]                           invokeRestart("muffleWarning")
[10:32:53.212]                       }
[10:32:53.212]                       else if (inherits(cond, "condition")) {
[10:32:53.212]                         if (!is.null(pattern)) {
[10:32:53.212]                           computeRestarts <- base::computeRestarts
[10:32:53.212]                           grepl <- base::grepl
[10:32:53.212]                           restarts <- computeRestarts(cond)
[10:32:53.212]                           for (restart in restarts) {
[10:32:53.212]                             name <- restart$name
[10:32:53.212]                             if (is.null(name)) 
[10:32:53.212]                               next
[10:32:53.212]                             if (!grepl(pattern, name)) 
[10:32:53.212]                               next
[10:32:53.212]                             invokeRestart(restart)
[10:32:53.212]                             muffled <- TRUE
[10:32:53.212]                             break
[10:32:53.212]                           }
[10:32:53.212]                         }
[10:32:53.212]                       }
[10:32:53.212]                       invisible(muffled)
[10:32:53.212]                     }
[10:32:53.212]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.212]                   }
[10:32:53.212]                 }
[10:32:53.212]                 else {
[10:32:53.212]                   if (TRUE) {
[10:32:53.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.212]                     {
[10:32:53.212]                       inherits <- base::inherits
[10:32:53.212]                       invokeRestart <- base::invokeRestart
[10:32:53.212]                       is.null <- base::is.null
[10:32:53.212]                       muffled <- FALSE
[10:32:53.212]                       if (inherits(cond, "message")) {
[10:32:53.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.212]                         if (muffled) 
[10:32:53.212]                           invokeRestart("muffleMessage")
[10:32:53.212]                       }
[10:32:53.212]                       else if (inherits(cond, "warning")) {
[10:32:53.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.212]                         if (muffled) 
[10:32:53.212]                           invokeRestart("muffleWarning")
[10:32:53.212]                       }
[10:32:53.212]                       else if (inherits(cond, "condition")) {
[10:32:53.212]                         if (!is.null(pattern)) {
[10:32:53.212]                           computeRestarts <- base::computeRestarts
[10:32:53.212]                           grepl <- base::grepl
[10:32:53.212]                           restarts <- computeRestarts(cond)
[10:32:53.212]                           for (restart in restarts) {
[10:32:53.212]                             name <- restart$name
[10:32:53.212]                             if (is.null(name)) 
[10:32:53.212]                               next
[10:32:53.212]                             if (!grepl(pattern, name)) 
[10:32:53.212]                               next
[10:32:53.212]                             invokeRestart(restart)
[10:32:53.212]                             muffled <- TRUE
[10:32:53.212]                             break
[10:32:53.212]                           }
[10:32:53.212]                         }
[10:32:53.212]                       }
[10:32:53.212]                       invisible(muffled)
[10:32:53.212]                     }
[10:32:53.212]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.212]                   }
[10:32:53.212]                 }
[10:32:53.212]             }
[10:32:53.212]         }))
[10:32:53.212]     }, error = function(ex) {
[10:32:53.212]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.212]                 ...future.rng), started = ...future.startTime, 
[10:32:53.212]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.212]             version = "1.8"), class = "FutureResult")
[10:32:53.212]     }, finally = {
[10:32:53.212]         if (!identical(...future.workdir, getwd())) 
[10:32:53.212]             setwd(...future.workdir)
[10:32:53.212]         {
[10:32:53.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.212]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.212]             }
[10:32:53.212]             base::options(...future.oldOptions)
[10:32:53.212]             if (.Platform$OS.type == "windows") {
[10:32:53.212]                 old_names <- names(...future.oldEnvVars)
[10:32:53.212]                 envs <- base::Sys.getenv()
[10:32:53.212]                 names <- names(envs)
[10:32:53.212]                 common <- intersect(names, old_names)
[10:32:53.212]                 added <- setdiff(names, old_names)
[10:32:53.212]                 removed <- setdiff(old_names, names)
[10:32:53.212]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.212]                   envs[common]]
[10:32:53.212]                 NAMES <- toupper(changed)
[10:32:53.212]                 args <- list()
[10:32:53.212]                 for (kk in seq_along(NAMES)) {
[10:32:53.212]                   name <- changed[[kk]]
[10:32:53.212]                   NAME <- NAMES[[kk]]
[10:32:53.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.212]                     next
[10:32:53.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.212]                 }
[10:32:53.212]                 NAMES <- toupper(added)
[10:32:53.212]                 for (kk in seq_along(NAMES)) {
[10:32:53.212]                   name <- added[[kk]]
[10:32:53.212]                   NAME <- NAMES[[kk]]
[10:32:53.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.212]                     next
[10:32:53.212]                   args[[name]] <- ""
[10:32:53.212]                 }
[10:32:53.212]                 NAMES <- toupper(removed)
[10:32:53.212]                 for (kk in seq_along(NAMES)) {
[10:32:53.212]                   name <- removed[[kk]]
[10:32:53.212]                   NAME <- NAMES[[kk]]
[10:32:53.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.212]                     next
[10:32:53.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.212]                 }
[10:32:53.212]                 if (length(args) > 0) 
[10:32:53.212]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.212]             }
[10:32:53.212]             else {
[10:32:53.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.212]             }
[10:32:53.212]             {
[10:32:53.212]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.212]                   0L) {
[10:32:53.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.212]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.212]                   base::options(opts)
[10:32:53.212]                 }
[10:32:53.212]                 {
[10:32:53.212]                   {
[10:32:53.212]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.212]                     NULL
[10:32:53.212]                   }
[10:32:53.212]                   options(future.plan = NULL)
[10:32:53.212]                   if (is.na(NA_character_)) 
[10:32:53.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.212]                     .init = FALSE)
[10:32:53.212]                 }
[10:32:53.212]             }
[10:32:53.212]         }
[10:32:53.212]     })
[10:32:53.212]     if (TRUE) {
[10:32:53.212]         base::sink(type = "output", split = FALSE)
[10:32:53.212]         if (TRUE) {
[10:32:53.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.212]         }
[10:32:53.212]         else {
[10:32:53.212]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.212]         }
[10:32:53.212]         base::close(...future.stdout)
[10:32:53.212]         ...future.stdout <- NULL
[10:32:53.212]     }
[10:32:53.212]     ...future.result$conditions <- ...future.conditions
[10:32:53.212]     ...future.result$finished <- base::Sys.time()
[10:32:53.212]     ...future.result
[10:32:53.212] }
[10:32:53.215] MultisessionFuture started
[10:32:53.215] - Launch lazy future ... done
[10:32:53.215] run() for ‘MultisessionFuture’ ... done
[10:32:53.215] getGlobalsAndPackages() ...
[10:32:53.215] Searching for globals...
[10:32:53.216] - globals found: [1] ‘{’
[10:32:53.216] Searching for globals ... DONE
[10:32:53.216] Resolving globals: FALSE
[10:32:53.216] 
[10:32:53.216] 
[10:32:53.217] getGlobalsAndPackages() ... DONE
[10:32:53.217] run() for ‘Future’ ...
[10:32:53.217] - state: ‘created’
[10:32:53.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.231]   - Field: ‘node’
[10:32:53.231]   - Field: ‘label’
[10:32:53.231]   - Field: ‘local’
[10:32:53.231]   - Field: ‘owner’
[10:32:53.231]   - Field: ‘envir’
[10:32:53.231]   - Field: ‘workers’
[10:32:53.231]   - Field: ‘packages’
[10:32:53.231]   - Field: ‘gc’
[10:32:53.231]   - Field: ‘conditions’
[10:32:53.231]   - Field: ‘persistent’
[10:32:53.232]   - Field: ‘expr’
[10:32:53.232]   - Field: ‘uuid’
[10:32:53.232]   - Field: ‘seed’
[10:32:53.232]   - Field: ‘version’
[10:32:53.232]   - Field: ‘result’
[10:32:53.232]   - Field: ‘asynchronous’
[10:32:53.232]   - Field: ‘calls’
[10:32:53.232]   - Field: ‘globals’
[10:32:53.232]   - Field: ‘stdout’
[10:32:53.232]   - Field: ‘earlySignal’
[10:32:53.232]   - Field: ‘lazy’
[10:32:53.233]   - Field: ‘state’
[10:32:53.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.233] - Launch lazy future ...
[10:32:53.233] Packages needed by the future expression (n = 0): <none>
[10:32:53.233] Packages needed by future strategies (n = 0): <none>
[10:32:53.233] {
[10:32:53.233]     {
[10:32:53.233]         {
[10:32:53.233]             ...future.startTime <- base::Sys.time()
[10:32:53.233]             {
[10:32:53.233]                 {
[10:32:53.233]                   {
[10:32:53.233]                     {
[10:32:53.233]                       base::local({
[10:32:53.233]                         has_future <- base::requireNamespace("future", 
[10:32:53.233]                           quietly = TRUE)
[10:32:53.233]                         if (has_future) {
[10:32:53.233]                           ns <- base::getNamespace("future")
[10:32:53.233]                           version <- ns[[".package"]][["version"]]
[10:32:53.233]                           if (is.null(version)) 
[10:32:53.233]                             version <- utils::packageVersion("future")
[10:32:53.233]                         }
[10:32:53.233]                         else {
[10:32:53.233]                           version <- NULL
[10:32:53.233]                         }
[10:32:53.233]                         if (!has_future || version < "1.8.0") {
[10:32:53.233]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.233]                             "", base::R.version$version.string), 
[10:32:53.233]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.233]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.233]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.233]                               "release", "version")], collapse = " "), 
[10:32:53.233]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.233]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.233]                             info)
[10:32:53.233]                           info <- base::paste(info, collapse = "; ")
[10:32:53.233]                           if (!has_future) {
[10:32:53.233]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.233]                               info)
[10:32:53.233]                           }
[10:32:53.233]                           else {
[10:32:53.233]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.233]                               info, version)
[10:32:53.233]                           }
[10:32:53.233]                           base::stop(msg)
[10:32:53.233]                         }
[10:32:53.233]                       })
[10:32:53.233]                     }
[10:32:53.233]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.233]                     base::options(mc.cores = 1L)
[10:32:53.233]                   }
[10:32:53.233]                   ...future.strategy.old <- future::plan("list")
[10:32:53.233]                   options(future.plan = NULL)
[10:32:53.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.233]                 }
[10:32:53.233]                 ...future.workdir <- getwd()
[10:32:53.233]             }
[10:32:53.233]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.233]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.233]         }
[10:32:53.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.233]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.233]             base::names(...future.oldOptions))
[10:32:53.233]     }
[10:32:53.233]     if (FALSE) {
[10:32:53.233]     }
[10:32:53.233]     else {
[10:32:53.233]         if (TRUE) {
[10:32:53.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.233]                 open = "w")
[10:32:53.233]         }
[10:32:53.233]         else {
[10:32:53.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.233]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.233]         }
[10:32:53.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.233]             base::sink(type = "output", split = FALSE)
[10:32:53.233]             base::close(...future.stdout)
[10:32:53.233]         }, add = TRUE)
[10:32:53.233]     }
[10:32:53.233]     ...future.frame <- base::sys.nframe()
[10:32:53.233]     ...future.conditions <- base::list()
[10:32:53.233]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.233]     if (FALSE) {
[10:32:53.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.233]     }
[10:32:53.233]     ...future.result <- base::tryCatch({
[10:32:53.233]         base::withCallingHandlers({
[10:32:53.233]             ...future.value <- base::withVisible(base::local({
[10:32:53.233]                 ...future.makeSendCondition <- base::local({
[10:32:53.233]                   sendCondition <- NULL
[10:32:53.233]                   function(frame = 1L) {
[10:32:53.233]                     if (is.function(sendCondition)) 
[10:32:53.233]                       return(sendCondition)
[10:32:53.233]                     ns <- getNamespace("parallel")
[10:32:53.233]                     if (exists("sendData", mode = "function", 
[10:32:53.233]                       envir = ns)) {
[10:32:53.233]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.233]                         envir = ns)
[10:32:53.233]                       envir <- sys.frame(frame)
[10:32:53.233]                       master <- NULL
[10:32:53.233]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.233]                         !identical(envir, emptyenv())) {
[10:32:53.233]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.233]                           inherits = FALSE)) {
[10:32:53.233]                           master <- get("master", mode = "list", 
[10:32:53.233]                             envir = envir, inherits = FALSE)
[10:32:53.233]                           if (inherits(master, c("SOCKnode", 
[10:32:53.233]                             "SOCK0node"))) {
[10:32:53.233]                             sendCondition <<- function(cond) {
[10:32:53.233]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.233]                                 success = TRUE)
[10:32:53.233]                               parallel_sendData(master, data)
[10:32:53.233]                             }
[10:32:53.233]                             return(sendCondition)
[10:32:53.233]                           }
[10:32:53.233]                         }
[10:32:53.233]                         frame <- frame + 1L
[10:32:53.233]                         envir <- sys.frame(frame)
[10:32:53.233]                       }
[10:32:53.233]                     }
[10:32:53.233]                     sendCondition <<- function(cond) NULL
[10:32:53.233]                   }
[10:32:53.233]                 })
[10:32:53.233]                 withCallingHandlers({
[10:32:53.233]                   {
[10:32:53.233]                     4
[10:32:53.233]                   }
[10:32:53.233]                 }, immediateCondition = function(cond) {
[10:32:53.233]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.233]                   sendCondition(cond)
[10:32:53.233]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.233]                   {
[10:32:53.233]                     inherits <- base::inherits
[10:32:53.233]                     invokeRestart <- base::invokeRestart
[10:32:53.233]                     is.null <- base::is.null
[10:32:53.233]                     muffled <- FALSE
[10:32:53.233]                     if (inherits(cond, "message")) {
[10:32:53.233]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.233]                       if (muffled) 
[10:32:53.233]                         invokeRestart("muffleMessage")
[10:32:53.233]                     }
[10:32:53.233]                     else if (inherits(cond, "warning")) {
[10:32:53.233]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.233]                       if (muffled) 
[10:32:53.233]                         invokeRestart("muffleWarning")
[10:32:53.233]                     }
[10:32:53.233]                     else if (inherits(cond, "condition")) {
[10:32:53.233]                       if (!is.null(pattern)) {
[10:32:53.233]                         computeRestarts <- base::computeRestarts
[10:32:53.233]                         grepl <- base::grepl
[10:32:53.233]                         restarts <- computeRestarts(cond)
[10:32:53.233]                         for (restart in restarts) {
[10:32:53.233]                           name <- restart$name
[10:32:53.233]                           if (is.null(name)) 
[10:32:53.233]                             next
[10:32:53.233]                           if (!grepl(pattern, name)) 
[10:32:53.233]                             next
[10:32:53.233]                           invokeRestart(restart)
[10:32:53.233]                           muffled <- TRUE
[10:32:53.233]                           break
[10:32:53.233]                         }
[10:32:53.233]                       }
[10:32:53.233]                     }
[10:32:53.233]                     invisible(muffled)
[10:32:53.233]                   }
[10:32:53.233]                   muffleCondition(cond)
[10:32:53.233]                 })
[10:32:53.233]             }))
[10:32:53.233]             future::FutureResult(value = ...future.value$value, 
[10:32:53.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.233]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.233]                     ...future.globalenv.names))
[10:32:53.233]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.233]         }, condition = base::local({
[10:32:53.233]             c <- base::c
[10:32:53.233]             inherits <- base::inherits
[10:32:53.233]             invokeRestart <- base::invokeRestart
[10:32:53.233]             length <- base::length
[10:32:53.233]             list <- base::list
[10:32:53.233]             seq.int <- base::seq.int
[10:32:53.233]             signalCondition <- base::signalCondition
[10:32:53.233]             sys.calls <- base::sys.calls
[10:32:53.233]             `[[` <- base::`[[`
[10:32:53.233]             `+` <- base::`+`
[10:32:53.233]             `<<-` <- base::`<<-`
[10:32:53.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.233]                   3L)]
[10:32:53.233]             }
[10:32:53.233]             function(cond) {
[10:32:53.233]                 is_error <- inherits(cond, "error")
[10:32:53.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.233]                   NULL)
[10:32:53.233]                 if (is_error) {
[10:32:53.233]                   sessionInformation <- function() {
[10:32:53.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.233]                       search = base::search(), system = base::Sys.info())
[10:32:53.233]                   }
[10:32:53.233]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.233]                     cond$call), session = sessionInformation(), 
[10:32:53.233]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.233]                   signalCondition(cond)
[10:32:53.233]                 }
[10:32:53.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.233]                 "immediateCondition"))) {
[10:32:53.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.233]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.233]                   if (TRUE && !signal) {
[10:32:53.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.233]                     {
[10:32:53.233]                       inherits <- base::inherits
[10:32:53.233]                       invokeRestart <- base::invokeRestart
[10:32:53.233]                       is.null <- base::is.null
[10:32:53.233]                       muffled <- FALSE
[10:32:53.233]                       if (inherits(cond, "message")) {
[10:32:53.233]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.233]                         if (muffled) 
[10:32:53.233]                           invokeRestart("muffleMessage")
[10:32:53.233]                       }
[10:32:53.233]                       else if (inherits(cond, "warning")) {
[10:32:53.233]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.233]                         if (muffled) 
[10:32:53.233]                           invokeRestart("muffleWarning")
[10:32:53.233]                       }
[10:32:53.233]                       else if (inherits(cond, "condition")) {
[10:32:53.233]                         if (!is.null(pattern)) {
[10:32:53.233]                           computeRestarts <- base::computeRestarts
[10:32:53.233]                           grepl <- base::grepl
[10:32:53.233]                           restarts <- computeRestarts(cond)
[10:32:53.233]                           for (restart in restarts) {
[10:32:53.233]                             name <- restart$name
[10:32:53.233]                             if (is.null(name)) 
[10:32:53.233]                               next
[10:32:53.233]                             if (!grepl(pattern, name)) 
[10:32:53.233]                               next
[10:32:53.233]                             invokeRestart(restart)
[10:32:53.233]                             muffled <- TRUE
[10:32:53.233]                             break
[10:32:53.233]                           }
[10:32:53.233]                         }
[10:32:53.233]                       }
[10:32:53.233]                       invisible(muffled)
[10:32:53.233]                     }
[10:32:53.233]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.233]                   }
[10:32:53.233]                 }
[10:32:53.233]                 else {
[10:32:53.233]                   if (TRUE) {
[10:32:53.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.233]                     {
[10:32:53.233]                       inherits <- base::inherits
[10:32:53.233]                       invokeRestart <- base::invokeRestart
[10:32:53.233]                       is.null <- base::is.null
[10:32:53.233]                       muffled <- FALSE
[10:32:53.233]                       if (inherits(cond, "message")) {
[10:32:53.233]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.233]                         if (muffled) 
[10:32:53.233]                           invokeRestart("muffleMessage")
[10:32:53.233]                       }
[10:32:53.233]                       else if (inherits(cond, "warning")) {
[10:32:53.233]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.233]                         if (muffled) 
[10:32:53.233]                           invokeRestart("muffleWarning")
[10:32:53.233]                       }
[10:32:53.233]                       else if (inherits(cond, "condition")) {
[10:32:53.233]                         if (!is.null(pattern)) {
[10:32:53.233]                           computeRestarts <- base::computeRestarts
[10:32:53.233]                           grepl <- base::grepl
[10:32:53.233]                           restarts <- computeRestarts(cond)
[10:32:53.233]                           for (restart in restarts) {
[10:32:53.233]                             name <- restart$name
[10:32:53.233]                             if (is.null(name)) 
[10:32:53.233]                               next
[10:32:53.233]                             if (!grepl(pattern, name)) 
[10:32:53.233]                               next
[10:32:53.233]                             invokeRestart(restart)
[10:32:53.233]                             muffled <- TRUE
[10:32:53.233]                             break
[10:32:53.233]                           }
[10:32:53.233]                         }
[10:32:53.233]                       }
[10:32:53.233]                       invisible(muffled)
[10:32:53.233]                     }
[10:32:53.233]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.233]                   }
[10:32:53.233]                 }
[10:32:53.233]             }
[10:32:53.233]         }))
[10:32:53.233]     }, error = function(ex) {
[10:32:53.233]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.233]                 ...future.rng), started = ...future.startTime, 
[10:32:53.233]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.233]             version = "1.8"), class = "FutureResult")
[10:32:53.233]     }, finally = {
[10:32:53.233]         if (!identical(...future.workdir, getwd())) 
[10:32:53.233]             setwd(...future.workdir)
[10:32:53.233]         {
[10:32:53.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.233]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.233]             }
[10:32:53.233]             base::options(...future.oldOptions)
[10:32:53.233]             if (.Platform$OS.type == "windows") {
[10:32:53.233]                 old_names <- names(...future.oldEnvVars)
[10:32:53.233]                 envs <- base::Sys.getenv()
[10:32:53.233]                 names <- names(envs)
[10:32:53.233]                 common <- intersect(names, old_names)
[10:32:53.233]                 added <- setdiff(names, old_names)
[10:32:53.233]                 removed <- setdiff(old_names, names)
[10:32:53.233]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.233]                   envs[common]]
[10:32:53.233]                 NAMES <- toupper(changed)
[10:32:53.233]                 args <- list()
[10:32:53.233]                 for (kk in seq_along(NAMES)) {
[10:32:53.233]                   name <- changed[[kk]]
[10:32:53.233]                   NAME <- NAMES[[kk]]
[10:32:53.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.233]                     next
[10:32:53.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.233]                 }
[10:32:53.233]                 NAMES <- toupper(added)
[10:32:53.233]                 for (kk in seq_along(NAMES)) {
[10:32:53.233]                   name <- added[[kk]]
[10:32:53.233]                   NAME <- NAMES[[kk]]
[10:32:53.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.233]                     next
[10:32:53.233]                   args[[name]] <- ""
[10:32:53.233]                 }
[10:32:53.233]                 NAMES <- toupper(removed)
[10:32:53.233]                 for (kk in seq_along(NAMES)) {
[10:32:53.233]                   name <- removed[[kk]]
[10:32:53.233]                   NAME <- NAMES[[kk]]
[10:32:53.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.233]                     next
[10:32:53.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.233]                 }
[10:32:53.233]                 if (length(args) > 0) 
[10:32:53.233]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.233]             }
[10:32:53.233]             else {
[10:32:53.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.233]             }
[10:32:53.233]             {
[10:32:53.233]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.233]                   0L) {
[10:32:53.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.233]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.233]                   base::options(opts)
[10:32:53.233]                 }
[10:32:53.233]                 {
[10:32:53.233]                   {
[10:32:53.233]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.233]                     NULL
[10:32:53.233]                   }
[10:32:53.233]                   options(future.plan = NULL)
[10:32:53.233]                   if (is.na(NA_character_)) 
[10:32:53.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.233]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.233]                     .init = FALSE)
[10:32:53.233]                 }
[10:32:53.233]             }
[10:32:53.233]         }
[10:32:53.233]     })
[10:32:53.233]     if (TRUE) {
[10:32:53.233]         base::sink(type = "output", split = FALSE)
[10:32:53.233]         if (TRUE) {
[10:32:53.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.233]         }
[10:32:53.233]         else {
[10:32:53.233]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.233]         }
[10:32:53.233]         base::close(...future.stdout)
[10:32:53.233]         ...future.stdout <- NULL
[10:32:53.233]     }
[10:32:53.233]     ...future.result$conditions <- ...future.conditions
[10:32:53.233]     ...future.result$finished <- base::Sys.time()
[10:32:53.233]     ...future.result
[10:32:53.233] }
[10:32:53.235] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:53.246] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.246] - Validating connection of MultisessionFuture
[10:32:53.246] - received message: FutureResult
[10:32:53.247] - Received FutureResult
[10:32:53.247] - Erased future from FutureRegistry
[10:32:53.247] result() for ClusterFuture ...
[10:32:53.247] - result already collected: FutureResult
[10:32:53.247] result() for ClusterFuture ... done
[10:32:53.247] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.247] result() for ClusterFuture ...
[10:32:53.247] - result already collected: FutureResult
[10:32:53.247] result() for ClusterFuture ... done
[10:32:53.247] result() for ClusterFuture ...
[10:32:53.248] - result already collected: FutureResult
[10:32:53.248] result() for ClusterFuture ... done
[10:32:53.249] MultisessionFuture started
[10:32:53.249] - Launch lazy future ... done
[10:32:53.249] run() for ‘MultisessionFuture’ ... done
<environment: 0x5652d2a53410> 
<environment: 0x5652d0c36080> 
[10:32:53.250] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.251] - Validating connection of MultisessionFuture
[10:32:53.251] - received message: FutureResult
[10:32:53.251] - Received FutureResult
[10:32:53.251] - Erased future from FutureRegistry
[10:32:53.251] result() for ClusterFuture ...
[10:32:53.251] - result already collected: FutureResult
[10:32:53.251] result() for ClusterFuture ... done
[10:32:53.251] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.252] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.252] - Validating connection of MultisessionFuture
[10:32:53.252] - received message: FutureResult
[10:32:53.252] - Received FutureResult
[10:32:53.252] - Erased future from FutureRegistry
[10:32:53.252] result() for ClusterFuture ...
[10:32:53.252] - result already collected: FutureResult
[10:32:53.252] result() for ClusterFuture ... done
[10:32:53.252] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:53.254] resolve() on environment ...
[10:32:53.254]  recursive: 0
[10:32:53.254]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:53.254] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.254] - nx: 4
[10:32:53.255] - relay: TRUE
[10:32:53.255] - stdout: TRUE
[10:32:53.255] - signal: TRUE
[10:32:53.255] - resignal: FALSE
[10:32:53.255] - force: TRUE
[10:32:53.255] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.255] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.255]  - until=2
[10:32:53.255]  - relaying element #2
[10:32:53.255] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.255] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.256] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.256]  length: 3 (resolved future 1)
[10:32:53.256] Future #2
[10:32:53.256] result() for ClusterFuture ...
[10:32:53.256] - result already collected: FutureResult
[10:32:53.256] result() for ClusterFuture ... done
[10:32:53.256] result() for ClusterFuture ...
[10:32:53.256] - result already collected: FutureResult
[10:32:53.256] result() for ClusterFuture ... done
[10:32:53.256] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:53.256] - nx: 4
[10:32:53.257] - relay: TRUE
[10:32:53.257] - stdout: TRUE
[10:32:53.257] - signal: TRUE
[10:32:53.257] - resignal: FALSE
[10:32:53.257] - force: TRUE
[10:32:53.257] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.257] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.257]  - until=2
[10:32:53.257]  - relaying element #2
[10:32:53.257] result() for ClusterFuture ...
[10:32:53.257] - result already collected: FutureResult
[10:32:53.258] result() for ClusterFuture ... done
[10:32:53.258] result() for ClusterFuture ...
[10:32:53.258] - result already collected: FutureResult
[10:32:53.258] result() for ClusterFuture ... done
[10:32:53.258] result() for ClusterFuture ...
[10:32:53.258] - result already collected: FutureResult
[10:32:53.258] result() for ClusterFuture ... done
[10:32:53.258] result() for ClusterFuture ...
[10:32:53.258] - result already collected: FutureResult
[10:32:53.258] result() for ClusterFuture ... done
[10:32:53.258] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.259] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.259] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:53.259]  length: 2 (resolved future 2)
[10:32:53.259] Future #3
[10:32:53.259] result() for ClusterFuture ...
[10:32:53.259] - result already collected: FutureResult
[10:32:53.259] result() for ClusterFuture ... done
[10:32:53.259] result() for ClusterFuture ...
[10:32:53.259] - result already collected: FutureResult
[10:32:53.259] result() for ClusterFuture ... done
[10:32:53.259] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:53.260] - nx: 4
[10:32:53.260] - relay: TRUE
[10:32:53.260] - stdout: TRUE
[10:32:53.260] - signal: TRUE
[10:32:53.260] - resignal: FALSE
[10:32:53.260] - force: TRUE
[10:32:53.260] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.260] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.260]  - until=3
[10:32:53.260]  - relaying element #3
[10:32:53.260] result() for ClusterFuture ...
[10:32:53.260] - result already collected: FutureResult
[10:32:53.261] result() for ClusterFuture ... done
[10:32:53.261] result() for ClusterFuture ...
[10:32:53.261] - result already collected: FutureResult
[10:32:53.261] result() for ClusterFuture ... done
[10:32:53.261] result() for ClusterFuture ...
[10:32:53.261] - result already collected: FutureResult
[10:32:53.261] result() for ClusterFuture ... done
[10:32:53.261] result() for ClusterFuture ...
[10:32:53.261] - result already collected: FutureResult
[10:32:53.261] result() for ClusterFuture ... done
[10:32:53.261] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.262] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.262] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:53.262]  length: 1 (resolved future 3)
[10:32:53.262] Future #4
[10:32:53.262] result() for ClusterFuture ...
[10:32:53.262] - result already collected: FutureResult
[10:32:53.262] result() for ClusterFuture ... done
[10:32:53.262] result() for ClusterFuture ...
[10:32:53.262] - result already collected: FutureResult
[10:32:53.262] result() for ClusterFuture ... done
[10:32:53.263] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:53.263] - nx: 4
[10:32:53.263] - relay: TRUE
[10:32:53.263] - stdout: TRUE
[10:32:53.263] - signal: TRUE
[10:32:53.263] - resignal: FALSE
[10:32:53.263] - force: TRUE
[10:32:53.263] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.263] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.263]  - until=4
[10:32:53.263]  - relaying element #4
[10:32:53.263] result() for ClusterFuture ...
[10:32:53.264] - result already collected: FutureResult
[10:32:53.264] result() for ClusterFuture ... done
[10:32:53.264] result() for ClusterFuture ...
[10:32:53.264] - result already collected: FutureResult
[10:32:53.264] result() for ClusterFuture ... done
[10:32:53.264] result() for ClusterFuture ...
[10:32:53.264] - result already collected: FutureResult
[10:32:53.264] result() for ClusterFuture ... done
[10:32:53.264] result() for ClusterFuture ...
[10:32:53.264] - result already collected: FutureResult
[10:32:53.264] result() for ClusterFuture ... done
[10:32:53.264] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.265] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.265] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:53.265]  length: 0 (resolved future 4)
[10:32:53.265] Relaying remaining futures
[10:32:53.265] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.265] - nx: 4
[10:32:53.265] - relay: TRUE
[10:32:53.265] - stdout: TRUE
[10:32:53.265] - signal: TRUE
[10:32:53.265] - resignal: FALSE
[10:32:53.265] - force: TRUE
[10:32:53.266] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.266] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:53.266] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.266] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.266] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.266] resolve() on environment ... DONE
[10:32:53.266] result() for ClusterFuture ...
[10:32:53.266] - result already collected: FutureResult
[10:32:53.266] result() for ClusterFuture ... done
[10:32:53.266] result() for ClusterFuture ...
[10:32:53.266] - result already collected: FutureResult
[10:32:53.267] result() for ClusterFuture ... done
[10:32:53.267] result() for ClusterFuture ...
[10:32:53.267] - result already collected: FutureResult
[10:32:53.267] result() for ClusterFuture ... done
[10:32:53.267] result() for ClusterFuture ...
[10:32:53.267] - result already collected: FutureResult
[10:32:53.267] result() for ClusterFuture ... done
[10:32:53.267] result() for ClusterFuture ...
[10:32:53.267] - result already collected: FutureResult
[10:32:53.267] result() for ClusterFuture ... done
[10:32:53.267] result() for ClusterFuture ...
[10:32:53.268] - result already collected: FutureResult
[10:32:53.268] result() for ClusterFuture ... done
<environment: 0x5652d018e928> 
Dimensions: c(2, 3)
[10:32:53.268] getGlobalsAndPackages() ...
[10:32:53.268] Searching for globals...
[10:32:53.268] 
[10:32:53.268] Searching for globals ... DONE
[10:32:53.269] - globals: [0] <none>
[10:32:53.269] getGlobalsAndPackages() ... DONE
[10:32:53.269] run() for ‘Future’ ...
[10:32:53.269] - state: ‘created’
[10:32:53.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.283]   - Field: ‘node’
[10:32:53.283]   - Field: ‘label’
[10:32:53.283]   - Field: ‘local’
[10:32:53.283]   - Field: ‘owner’
[10:32:53.284]   - Field: ‘envir’
[10:32:53.284]   - Field: ‘workers’
[10:32:53.284]   - Field: ‘packages’
[10:32:53.284]   - Field: ‘gc’
[10:32:53.284]   - Field: ‘conditions’
[10:32:53.284]   - Field: ‘persistent’
[10:32:53.284]   - Field: ‘expr’
[10:32:53.284]   - Field: ‘uuid’
[10:32:53.284]   - Field: ‘seed’
[10:32:53.284]   - Field: ‘version’
[10:32:53.284]   - Field: ‘result’
[10:32:53.285]   - Field: ‘asynchronous’
[10:32:53.285]   - Field: ‘calls’
[10:32:53.285]   - Field: ‘globals’
[10:32:53.285]   - Field: ‘stdout’
[10:32:53.285]   - Field: ‘earlySignal’
[10:32:53.285]   - Field: ‘lazy’
[10:32:53.285]   - Field: ‘state’
[10:32:53.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.285] - Launch lazy future ...
[10:32:53.286] Packages needed by the future expression (n = 0): <none>
[10:32:53.286] Packages needed by future strategies (n = 0): <none>
[10:32:53.286] {
[10:32:53.286]     {
[10:32:53.286]         {
[10:32:53.286]             ...future.startTime <- base::Sys.time()
[10:32:53.286]             {
[10:32:53.286]                 {
[10:32:53.286]                   {
[10:32:53.286]                     {
[10:32:53.286]                       base::local({
[10:32:53.286]                         has_future <- base::requireNamespace("future", 
[10:32:53.286]                           quietly = TRUE)
[10:32:53.286]                         if (has_future) {
[10:32:53.286]                           ns <- base::getNamespace("future")
[10:32:53.286]                           version <- ns[[".package"]][["version"]]
[10:32:53.286]                           if (is.null(version)) 
[10:32:53.286]                             version <- utils::packageVersion("future")
[10:32:53.286]                         }
[10:32:53.286]                         else {
[10:32:53.286]                           version <- NULL
[10:32:53.286]                         }
[10:32:53.286]                         if (!has_future || version < "1.8.0") {
[10:32:53.286]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.286]                             "", base::R.version$version.string), 
[10:32:53.286]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.286]                               "release", "version")], collapse = " "), 
[10:32:53.286]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.286]                             info)
[10:32:53.286]                           info <- base::paste(info, collapse = "; ")
[10:32:53.286]                           if (!has_future) {
[10:32:53.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.286]                               info)
[10:32:53.286]                           }
[10:32:53.286]                           else {
[10:32:53.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.286]                               info, version)
[10:32:53.286]                           }
[10:32:53.286]                           base::stop(msg)
[10:32:53.286]                         }
[10:32:53.286]                       })
[10:32:53.286]                     }
[10:32:53.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.286]                     base::options(mc.cores = 1L)
[10:32:53.286]                   }
[10:32:53.286]                   ...future.strategy.old <- future::plan("list")
[10:32:53.286]                   options(future.plan = NULL)
[10:32:53.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.286]                 }
[10:32:53.286]                 ...future.workdir <- getwd()
[10:32:53.286]             }
[10:32:53.286]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.286]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.286]         }
[10:32:53.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.286]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.286]             base::names(...future.oldOptions))
[10:32:53.286]     }
[10:32:53.286]     if (FALSE) {
[10:32:53.286]     }
[10:32:53.286]     else {
[10:32:53.286]         if (TRUE) {
[10:32:53.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.286]                 open = "w")
[10:32:53.286]         }
[10:32:53.286]         else {
[10:32:53.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.286]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.286]         }
[10:32:53.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.286]             base::sink(type = "output", split = FALSE)
[10:32:53.286]             base::close(...future.stdout)
[10:32:53.286]         }, add = TRUE)
[10:32:53.286]     }
[10:32:53.286]     ...future.frame <- base::sys.nframe()
[10:32:53.286]     ...future.conditions <- base::list()
[10:32:53.286]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.286]     if (FALSE) {
[10:32:53.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.286]     }
[10:32:53.286]     ...future.result <- base::tryCatch({
[10:32:53.286]         base::withCallingHandlers({
[10:32:53.286]             ...future.value <- base::withVisible(base::local({
[10:32:53.286]                 ...future.makeSendCondition <- base::local({
[10:32:53.286]                   sendCondition <- NULL
[10:32:53.286]                   function(frame = 1L) {
[10:32:53.286]                     if (is.function(sendCondition)) 
[10:32:53.286]                       return(sendCondition)
[10:32:53.286]                     ns <- getNamespace("parallel")
[10:32:53.286]                     if (exists("sendData", mode = "function", 
[10:32:53.286]                       envir = ns)) {
[10:32:53.286]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.286]                         envir = ns)
[10:32:53.286]                       envir <- sys.frame(frame)
[10:32:53.286]                       master <- NULL
[10:32:53.286]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.286]                         !identical(envir, emptyenv())) {
[10:32:53.286]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.286]                           inherits = FALSE)) {
[10:32:53.286]                           master <- get("master", mode = "list", 
[10:32:53.286]                             envir = envir, inherits = FALSE)
[10:32:53.286]                           if (inherits(master, c("SOCKnode", 
[10:32:53.286]                             "SOCK0node"))) {
[10:32:53.286]                             sendCondition <<- function(cond) {
[10:32:53.286]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.286]                                 success = TRUE)
[10:32:53.286]                               parallel_sendData(master, data)
[10:32:53.286]                             }
[10:32:53.286]                             return(sendCondition)
[10:32:53.286]                           }
[10:32:53.286]                         }
[10:32:53.286]                         frame <- frame + 1L
[10:32:53.286]                         envir <- sys.frame(frame)
[10:32:53.286]                       }
[10:32:53.286]                     }
[10:32:53.286]                     sendCondition <<- function(cond) NULL
[10:32:53.286]                   }
[10:32:53.286]                 })
[10:32:53.286]                 withCallingHandlers({
[10:32:53.286]                   2
[10:32:53.286]                 }, immediateCondition = function(cond) {
[10:32:53.286]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.286]                   sendCondition(cond)
[10:32:53.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.286]                   {
[10:32:53.286]                     inherits <- base::inherits
[10:32:53.286]                     invokeRestart <- base::invokeRestart
[10:32:53.286]                     is.null <- base::is.null
[10:32:53.286]                     muffled <- FALSE
[10:32:53.286]                     if (inherits(cond, "message")) {
[10:32:53.286]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.286]                       if (muffled) 
[10:32:53.286]                         invokeRestart("muffleMessage")
[10:32:53.286]                     }
[10:32:53.286]                     else if (inherits(cond, "warning")) {
[10:32:53.286]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.286]                       if (muffled) 
[10:32:53.286]                         invokeRestart("muffleWarning")
[10:32:53.286]                     }
[10:32:53.286]                     else if (inherits(cond, "condition")) {
[10:32:53.286]                       if (!is.null(pattern)) {
[10:32:53.286]                         computeRestarts <- base::computeRestarts
[10:32:53.286]                         grepl <- base::grepl
[10:32:53.286]                         restarts <- computeRestarts(cond)
[10:32:53.286]                         for (restart in restarts) {
[10:32:53.286]                           name <- restart$name
[10:32:53.286]                           if (is.null(name)) 
[10:32:53.286]                             next
[10:32:53.286]                           if (!grepl(pattern, name)) 
[10:32:53.286]                             next
[10:32:53.286]                           invokeRestart(restart)
[10:32:53.286]                           muffled <- TRUE
[10:32:53.286]                           break
[10:32:53.286]                         }
[10:32:53.286]                       }
[10:32:53.286]                     }
[10:32:53.286]                     invisible(muffled)
[10:32:53.286]                   }
[10:32:53.286]                   muffleCondition(cond)
[10:32:53.286]                 })
[10:32:53.286]             }))
[10:32:53.286]             future::FutureResult(value = ...future.value$value, 
[10:32:53.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.286]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.286]                     ...future.globalenv.names))
[10:32:53.286]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.286]         }, condition = base::local({
[10:32:53.286]             c <- base::c
[10:32:53.286]             inherits <- base::inherits
[10:32:53.286]             invokeRestart <- base::invokeRestart
[10:32:53.286]             length <- base::length
[10:32:53.286]             list <- base::list
[10:32:53.286]             seq.int <- base::seq.int
[10:32:53.286]             signalCondition <- base::signalCondition
[10:32:53.286]             sys.calls <- base::sys.calls
[10:32:53.286]             `[[` <- base::`[[`
[10:32:53.286]             `+` <- base::`+`
[10:32:53.286]             `<<-` <- base::`<<-`
[10:32:53.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.286]                   3L)]
[10:32:53.286]             }
[10:32:53.286]             function(cond) {
[10:32:53.286]                 is_error <- inherits(cond, "error")
[10:32:53.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.286]                   NULL)
[10:32:53.286]                 if (is_error) {
[10:32:53.286]                   sessionInformation <- function() {
[10:32:53.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.286]                       search = base::search(), system = base::Sys.info())
[10:32:53.286]                   }
[10:32:53.286]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.286]                     cond$call), session = sessionInformation(), 
[10:32:53.286]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.286]                   signalCondition(cond)
[10:32:53.286]                 }
[10:32:53.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.286]                 "immediateCondition"))) {
[10:32:53.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.286]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.286]                   if (TRUE && !signal) {
[10:32:53.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.286]                     {
[10:32:53.286]                       inherits <- base::inherits
[10:32:53.286]                       invokeRestart <- base::invokeRestart
[10:32:53.286]                       is.null <- base::is.null
[10:32:53.286]                       muffled <- FALSE
[10:32:53.286]                       if (inherits(cond, "message")) {
[10:32:53.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.286]                         if (muffled) 
[10:32:53.286]                           invokeRestart("muffleMessage")
[10:32:53.286]                       }
[10:32:53.286]                       else if (inherits(cond, "warning")) {
[10:32:53.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.286]                         if (muffled) 
[10:32:53.286]                           invokeRestart("muffleWarning")
[10:32:53.286]                       }
[10:32:53.286]                       else if (inherits(cond, "condition")) {
[10:32:53.286]                         if (!is.null(pattern)) {
[10:32:53.286]                           computeRestarts <- base::computeRestarts
[10:32:53.286]                           grepl <- base::grepl
[10:32:53.286]                           restarts <- computeRestarts(cond)
[10:32:53.286]                           for (restart in restarts) {
[10:32:53.286]                             name <- restart$name
[10:32:53.286]                             if (is.null(name)) 
[10:32:53.286]                               next
[10:32:53.286]                             if (!grepl(pattern, name)) 
[10:32:53.286]                               next
[10:32:53.286]                             invokeRestart(restart)
[10:32:53.286]                             muffled <- TRUE
[10:32:53.286]                             break
[10:32:53.286]                           }
[10:32:53.286]                         }
[10:32:53.286]                       }
[10:32:53.286]                       invisible(muffled)
[10:32:53.286]                     }
[10:32:53.286]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.286]                   }
[10:32:53.286]                 }
[10:32:53.286]                 else {
[10:32:53.286]                   if (TRUE) {
[10:32:53.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.286]                     {
[10:32:53.286]                       inherits <- base::inherits
[10:32:53.286]                       invokeRestart <- base::invokeRestart
[10:32:53.286]                       is.null <- base::is.null
[10:32:53.286]                       muffled <- FALSE
[10:32:53.286]                       if (inherits(cond, "message")) {
[10:32:53.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.286]                         if (muffled) 
[10:32:53.286]                           invokeRestart("muffleMessage")
[10:32:53.286]                       }
[10:32:53.286]                       else if (inherits(cond, "warning")) {
[10:32:53.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.286]                         if (muffled) 
[10:32:53.286]                           invokeRestart("muffleWarning")
[10:32:53.286]                       }
[10:32:53.286]                       else if (inherits(cond, "condition")) {
[10:32:53.286]                         if (!is.null(pattern)) {
[10:32:53.286]                           computeRestarts <- base::computeRestarts
[10:32:53.286]                           grepl <- base::grepl
[10:32:53.286]                           restarts <- computeRestarts(cond)
[10:32:53.286]                           for (restart in restarts) {
[10:32:53.286]                             name <- restart$name
[10:32:53.286]                             if (is.null(name)) 
[10:32:53.286]                               next
[10:32:53.286]                             if (!grepl(pattern, name)) 
[10:32:53.286]                               next
[10:32:53.286]                             invokeRestart(restart)
[10:32:53.286]                             muffled <- TRUE
[10:32:53.286]                             break
[10:32:53.286]                           }
[10:32:53.286]                         }
[10:32:53.286]                       }
[10:32:53.286]                       invisible(muffled)
[10:32:53.286]                     }
[10:32:53.286]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.286]                   }
[10:32:53.286]                 }
[10:32:53.286]             }
[10:32:53.286]         }))
[10:32:53.286]     }, error = function(ex) {
[10:32:53.286]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.286]                 ...future.rng), started = ...future.startTime, 
[10:32:53.286]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.286]             version = "1.8"), class = "FutureResult")
[10:32:53.286]     }, finally = {
[10:32:53.286]         if (!identical(...future.workdir, getwd())) 
[10:32:53.286]             setwd(...future.workdir)
[10:32:53.286]         {
[10:32:53.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.286]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.286]             }
[10:32:53.286]             base::options(...future.oldOptions)
[10:32:53.286]             if (.Platform$OS.type == "windows") {
[10:32:53.286]                 old_names <- names(...future.oldEnvVars)
[10:32:53.286]                 envs <- base::Sys.getenv()
[10:32:53.286]                 names <- names(envs)
[10:32:53.286]                 common <- intersect(names, old_names)
[10:32:53.286]                 added <- setdiff(names, old_names)
[10:32:53.286]                 removed <- setdiff(old_names, names)
[10:32:53.286]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.286]                   envs[common]]
[10:32:53.286]                 NAMES <- toupper(changed)
[10:32:53.286]                 args <- list()
[10:32:53.286]                 for (kk in seq_along(NAMES)) {
[10:32:53.286]                   name <- changed[[kk]]
[10:32:53.286]                   NAME <- NAMES[[kk]]
[10:32:53.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.286]                     next
[10:32:53.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.286]                 }
[10:32:53.286]                 NAMES <- toupper(added)
[10:32:53.286]                 for (kk in seq_along(NAMES)) {
[10:32:53.286]                   name <- added[[kk]]
[10:32:53.286]                   NAME <- NAMES[[kk]]
[10:32:53.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.286]                     next
[10:32:53.286]                   args[[name]] <- ""
[10:32:53.286]                 }
[10:32:53.286]                 NAMES <- toupper(removed)
[10:32:53.286]                 for (kk in seq_along(NAMES)) {
[10:32:53.286]                   name <- removed[[kk]]
[10:32:53.286]                   NAME <- NAMES[[kk]]
[10:32:53.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.286]                     next
[10:32:53.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.286]                 }
[10:32:53.286]                 if (length(args) > 0) 
[10:32:53.286]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.286]             }
[10:32:53.286]             else {
[10:32:53.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.286]             }
[10:32:53.286]             {
[10:32:53.286]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.286]                   0L) {
[10:32:53.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.286]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.286]                   base::options(opts)
[10:32:53.286]                 }
[10:32:53.286]                 {
[10:32:53.286]                   {
[10:32:53.286]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.286]                     NULL
[10:32:53.286]                   }
[10:32:53.286]                   options(future.plan = NULL)
[10:32:53.286]                   if (is.na(NA_character_)) 
[10:32:53.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.286]                     .init = FALSE)
[10:32:53.286]                 }
[10:32:53.286]             }
[10:32:53.286]         }
[10:32:53.286]     })
[10:32:53.286]     if (TRUE) {
[10:32:53.286]         base::sink(type = "output", split = FALSE)
[10:32:53.286]         if (TRUE) {
[10:32:53.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.286]         }
[10:32:53.286]         else {
[10:32:53.286]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.286]         }
[10:32:53.286]         base::close(...future.stdout)
[10:32:53.286]         ...future.stdout <- NULL
[10:32:53.286]     }
[10:32:53.286]     ...future.result$conditions <- ...future.conditions
[10:32:53.286]     ...future.result$finished <- base::Sys.time()
[10:32:53.286]     ...future.result
[10:32:53.286] }
[10:32:53.289] MultisessionFuture started
[10:32:53.289] - Launch lazy future ... done
[10:32:53.289] run() for ‘MultisessionFuture’ ... done
[10:32:53.289] getGlobalsAndPackages() ...
[10:32:53.289] Searching for globals...
[10:32:53.290] 
[10:32:53.290] Searching for globals ... DONE
[10:32:53.290] - globals: [0] <none>
[10:32:53.290] getGlobalsAndPackages() ... DONE
[10:32:53.290] run() for ‘Future’ ...
[10:32:53.290] - state: ‘created’
[10:32:53.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.304] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.304]   - Field: ‘node’
[10:32:53.304]   - Field: ‘label’
[10:32:53.304]   - Field: ‘local’
[10:32:53.304]   - Field: ‘owner’
[10:32:53.304]   - Field: ‘envir’
[10:32:53.304]   - Field: ‘workers’
[10:32:53.305]   - Field: ‘packages’
[10:32:53.305]   - Field: ‘gc’
[10:32:53.305]   - Field: ‘conditions’
[10:32:53.305]   - Field: ‘persistent’
[10:32:53.305]   - Field: ‘expr’
[10:32:53.305]   - Field: ‘uuid’
[10:32:53.305]   - Field: ‘seed’
[10:32:53.305]   - Field: ‘version’
[10:32:53.305]   - Field: ‘result’
[10:32:53.305]   - Field: ‘asynchronous’
[10:32:53.306]   - Field: ‘calls’
[10:32:53.306]   - Field: ‘globals’
[10:32:53.306]   - Field: ‘stdout’
[10:32:53.306]   - Field: ‘earlySignal’
[10:32:53.306]   - Field: ‘lazy’
[10:32:53.306]   - Field: ‘state’
[10:32:53.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.306] - Launch lazy future ...
[10:32:53.306] Packages needed by the future expression (n = 0): <none>
[10:32:53.307] Packages needed by future strategies (n = 0): <none>
[10:32:53.307] {
[10:32:53.307]     {
[10:32:53.307]         {
[10:32:53.307]             ...future.startTime <- base::Sys.time()
[10:32:53.307]             {
[10:32:53.307]                 {
[10:32:53.307]                   {
[10:32:53.307]                     {
[10:32:53.307]                       base::local({
[10:32:53.307]                         has_future <- base::requireNamespace("future", 
[10:32:53.307]                           quietly = TRUE)
[10:32:53.307]                         if (has_future) {
[10:32:53.307]                           ns <- base::getNamespace("future")
[10:32:53.307]                           version <- ns[[".package"]][["version"]]
[10:32:53.307]                           if (is.null(version)) 
[10:32:53.307]                             version <- utils::packageVersion("future")
[10:32:53.307]                         }
[10:32:53.307]                         else {
[10:32:53.307]                           version <- NULL
[10:32:53.307]                         }
[10:32:53.307]                         if (!has_future || version < "1.8.0") {
[10:32:53.307]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.307]                             "", base::R.version$version.string), 
[10:32:53.307]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.307]                               "release", "version")], collapse = " "), 
[10:32:53.307]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.307]                             info)
[10:32:53.307]                           info <- base::paste(info, collapse = "; ")
[10:32:53.307]                           if (!has_future) {
[10:32:53.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.307]                               info)
[10:32:53.307]                           }
[10:32:53.307]                           else {
[10:32:53.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.307]                               info, version)
[10:32:53.307]                           }
[10:32:53.307]                           base::stop(msg)
[10:32:53.307]                         }
[10:32:53.307]                       })
[10:32:53.307]                     }
[10:32:53.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.307]                     base::options(mc.cores = 1L)
[10:32:53.307]                   }
[10:32:53.307]                   ...future.strategy.old <- future::plan("list")
[10:32:53.307]                   options(future.plan = NULL)
[10:32:53.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.307]                 }
[10:32:53.307]                 ...future.workdir <- getwd()
[10:32:53.307]             }
[10:32:53.307]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.307]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.307]         }
[10:32:53.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.307]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.307]             base::names(...future.oldOptions))
[10:32:53.307]     }
[10:32:53.307]     if (FALSE) {
[10:32:53.307]     }
[10:32:53.307]     else {
[10:32:53.307]         if (TRUE) {
[10:32:53.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.307]                 open = "w")
[10:32:53.307]         }
[10:32:53.307]         else {
[10:32:53.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.307]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.307]         }
[10:32:53.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.307]             base::sink(type = "output", split = FALSE)
[10:32:53.307]             base::close(...future.stdout)
[10:32:53.307]         }, add = TRUE)
[10:32:53.307]     }
[10:32:53.307]     ...future.frame <- base::sys.nframe()
[10:32:53.307]     ...future.conditions <- base::list()
[10:32:53.307]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.307]     if (FALSE) {
[10:32:53.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.307]     }
[10:32:53.307]     ...future.result <- base::tryCatch({
[10:32:53.307]         base::withCallingHandlers({
[10:32:53.307]             ...future.value <- base::withVisible(base::local({
[10:32:53.307]                 ...future.makeSendCondition <- base::local({
[10:32:53.307]                   sendCondition <- NULL
[10:32:53.307]                   function(frame = 1L) {
[10:32:53.307]                     if (is.function(sendCondition)) 
[10:32:53.307]                       return(sendCondition)
[10:32:53.307]                     ns <- getNamespace("parallel")
[10:32:53.307]                     if (exists("sendData", mode = "function", 
[10:32:53.307]                       envir = ns)) {
[10:32:53.307]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.307]                         envir = ns)
[10:32:53.307]                       envir <- sys.frame(frame)
[10:32:53.307]                       master <- NULL
[10:32:53.307]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.307]                         !identical(envir, emptyenv())) {
[10:32:53.307]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.307]                           inherits = FALSE)) {
[10:32:53.307]                           master <- get("master", mode = "list", 
[10:32:53.307]                             envir = envir, inherits = FALSE)
[10:32:53.307]                           if (inherits(master, c("SOCKnode", 
[10:32:53.307]                             "SOCK0node"))) {
[10:32:53.307]                             sendCondition <<- function(cond) {
[10:32:53.307]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.307]                                 success = TRUE)
[10:32:53.307]                               parallel_sendData(master, data)
[10:32:53.307]                             }
[10:32:53.307]                             return(sendCondition)
[10:32:53.307]                           }
[10:32:53.307]                         }
[10:32:53.307]                         frame <- frame + 1L
[10:32:53.307]                         envir <- sys.frame(frame)
[10:32:53.307]                       }
[10:32:53.307]                     }
[10:32:53.307]                     sendCondition <<- function(cond) NULL
[10:32:53.307]                   }
[10:32:53.307]                 })
[10:32:53.307]                 withCallingHandlers({
[10:32:53.307]                   NULL
[10:32:53.307]                 }, immediateCondition = function(cond) {
[10:32:53.307]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.307]                   sendCondition(cond)
[10:32:53.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.307]                   {
[10:32:53.307]                     inherits <- base::inherits
[10:32:53.307]                     invokeRestart <- base::invokeRestart
[10:32:53.307]                     is.null <- base::is.null
[10:32:53.307]                     muffled <- FALSE
[10:32:53.307]                     if (inherits(cond, "message")) {
[10:32:53.307]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.307]                       if (muffled) 
[10:32:53.307]                         invokeRestart("muffleMessage")
[10:32:53.307]                     }
[10:32:53.307]                     else if (inherits(cond, "warning")) {
[10:32:53.307]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.307]                       if (muffled) 
[10:32:53.307]                         invokeRestart("muffleWarning")
[10:32:53.307]                     }
[10:32:53.307]                     else if (inherits(cond, "condition")) {
[10:32:53.307]                       if (!is.null(pattern)) {
[10:32:53.307]                         computeRestarts <- base::computeRestarts
[10:32:53.307]                         grepl <- base::grepl
[10:32:53.307]                         restarts <- computeRestarts(cond)
[10:32:53.307]                         for (restart in restarts) {
[10:32:53.307]                           name <- restart$name
[10:32:53.307]                           if (is.null(name)) 
[10:32:53.307]                             next
[10:32:53.307]                           if (!grepl(pattern, name)) 
[10:32:53.307]                             next
[10:32:53.307]                           invokeRestart(restart)
[10:32:53.307]                           muffled <- TRUE
[10:32:53.307]                           break
[10:32:53.307]                         }
[10:32:53.307]                       }
[10:32:53.307]                     }
[10:32:53.307]                     invisible(muffled)
[10:32:53.307]                   }
[10:32:53.307]                   muffleCondition(cond)
[10:32:53.307]                 })
[10:32:53.307]             }))
[10:32:53.307]             future::FutureResult(value = ...future.value$value, 
[10:32:53.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.307]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.307]                     ...future.globalenv.names))
[10:32:53.307]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.307]         }, condition = base::local({
[10:32:53.307]             c <- base::c
[10:32:53.307]             inherits <- base::inherits
[10:32:53.307]             invokeRestart <- base::invokeRestart
[10:32:53.307]             length <- base::length
[10:32:53.307]             list <- base::list
[10:32:53.307]             seq.int <- base::seq.int
[10:32:53.307]             signalCondition <- base::signalCondition
[10:32:53.307]             sys.calls <- base::sys.calls
[10:32:53.307]             `[[` <- base::`[[`
[10:32:53.307]             `+` <- base::`+`
[10:32:53.307]             `<<-` <- base::`<<-`
[10:32:53.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.307]                   3L)]
[10:32:53.307]             }
[10:32:53.307]             function(cond) {
[10:32:53.307]                 is_error <- inherits(cond, "error")
[10:32:53.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.307]                   NULL)
[10:32:53.307]                 if (is_error) {
[10:32:53.307]                   sessionInformation <- function() {
[10:32:53.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.307]                       search = base::search(), system = base::Sys.info())
[10:32:53.307]                   }
[10:32:53.307]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.307]                     cond$call), session = sessionInformation(), 
[10:32:53.307]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.307]                   signalCondition(cond)
[10:32:53.307]                 }
[10:32:53.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.307]                 "immediateCondition"))) {
[10:32:53.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.307]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.307]                   if (TRUE && !signal) {
[10:32:53.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.307]                     {
[10:32:53.307]                       inherits <- base::inherits
[10:32:53.307]                       invokeRestart <- base::invokeRestart
[10:32:53.307]                       is.null <- base::is.null
[10:32:53.307]                       muffled <- FALSE
[10:32:53.307]                       if (inherits(cond, "message")) {
[10:32:53.307]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.307]                         if (muffled) 
[10:32:53.307]                           invokeRestart("muffleMessage")
[10:32:53.307]                       }
[10:32:53.307]                       else if (inherits(cond, "warning")) {
[10:32:53.307]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.307]                         if (muffled) 
[10:32:53.307]                           invokeRestart("muffleWarning")
[10:32:53.307]                       }
[10:32:53.307]                       else if (inherits(cond, "condition")) {
[10:32:53.307]                         if (!is.null(pattern)) {
[10:32:53.307]                           computeRestarts <- base::computeRestarts
[10:32:53.307]                           grepl <- base::grepl
[10:32:53.307]                           restarts <- computeRestarts(cond)
[10:32:53.307]                           for (restart in restarts) {
[10:32:53.307]                             name <- restart$name
[10:32:53.307]                             if (is.null(name)) 
[10:32:53.307]                               next
[10:32:53.307]                             if (!grepl(pattern, name)) 
[10:32:53.307]                               next
[10:32:53.307]                             invokeRestart(restart)
[10:32:53.307]                             muffled <- TRUE
[10:32:53.307]                             break
[10:32:53.307]                           }
[10:32:53.307]                         }
[10:32:53.307]                       }
[10:32:53.307]                       invisible(muffled)
[10:32:53.307]                     }
[10:32:53.307]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.307]                   }
[10:32:53.307]                 }
[10:32:53.307]                 else {
[10:32:53.307]                   if (TRUE) {
[10:32:53.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.307]                     {
[10:32:53.307]                       inherits <- base::inherits
[10:32:53.307]                       invokeRestart <- base::invokeRestart
[10:32:53.307]                       is.null <- base::is.null
[10:32:53.307]                       muffled <- FALSE
[10:32:53.307]                       if (inherits(cond, "message")) {
[10:32:53.307]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.307]                         if (muffled) 
[10:32:53.307]                           invokeRestart("muffleMessage")
[10:32:53.307]                       }
[10:32:53.307]                       else if (inherits(cond, "warning")) {
[10:32:53.307]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.307]                         if (muffled) 
[10:32:53.307]                           invokeRestart("muffleWarning")
[10:32:53.307]                       }
[10:32:53.307]                       else if (inherits(cond, "condition")) {
[10:32:53.307]                         if (!is.null(pattern)) {
[10:32:53.307]                           computeRestarts <- base::computeRestarts
[10:32:53.307]                           grepl <- base::grepl
[10:32:53.307]                           restarts <- computeRestarts(cond)
[10:32:53.307]                           for (restart in restarts) {
[10:32:53.307]                             name <- restart$name
[10:32:53.307]                             if (is.null(name)) 
[10:32:53.307]                               next
[10:32:53.307]                             if (!grepl(pattern, name)) 
[10:32:53.307]                               next
[10:32:53.307]                             invokeRestart(restart)
[10:32:53.307]                             muffled <- TRUE
[10:32:53.307]                             break
[10:32:53.307]                           }
[10:32:53.307]                         }
[10:32:53.307]                       }
[10:32:53.307]                       invisible(muffled)
[10:32:53.307]                     }
[10:32:53.307]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.307]                   }
[10:32:53.307]                 }
[10:32:53.307]             }
[10:32:53.307]         }))
[10:32:53.307]     }, error = function(ex) {
[10:32:53.307]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.307]                 ...future.rng), started = ...future.startTime, 
[10:32:53.307]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.307]             version = "1.8"), class = "FutureResult")
[10:32:53.307]     }, finally = {
[10:32:53.307]         if (!identical(...future.workdir, getwd())) 
[10:32:53.307]             setwd(...future.workdir)
[10:32:53.307]         {
[10:32:53.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.307]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.307]             }
[10:32:53.307]             base::options(...future.oldOptions)
[10:32:53.307]             if (.Platform$OS.type == "windows") {
[10:32:53.307]                 old_names <- names(...future.oldEnvVars)
[10:32:53.307]                 envs <- base::Sys.getenv()
[10:32:53.307]                 names <- names(envs)
[10:32:53.307]                 common <- intersect(names, old_names)
[10:32:53.307]                 added <- setdiff(names, old_names)
[10:32:53.307]                 removed <- setdiff(old_names, names)
[10:32:53.307]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.307]                   envs[common]]
[10:32:53.307]                 NAMES <- toupper(changed)
[10:32:53.307]                 args <- list()
[10:32:53.307]                 for (kk in seq_along(NAMES)) {
[10:32:53.307]                   name <- changed[[kk]]
[10:32:53.307]                   NAME <- NAMES[[kk]]
[10:32:53.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.307]                     next
[10:32:53.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.307]                 }
[10:32:53.307]                 NAMES <- toupper(added)
[10:32:53.307]                 for (kk in seq_along(NAMES)) {
[10:32:53.307]                   name <- added[[kk]]
[10:32:53.307]                   NAME <- NAMES[[kk]]
[10:32:53.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.307]                     next
[10:32:53.307]                   args[[name]] <- ""
[10:32:53.307]                 }
[10:32:53.307]                 NAMES <- toupper(removed)
[10:32:53.307]                 for (kk in seq_along(NAMES)) {
[10:32:53.307]                   name <- removed[[kk]]
[10:32:53.307]                   NAME <- NAMES[[kk]]
[10:32:53.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.307]                     next
[10:32:53.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.307]                 }
[10:32:53.307]                 if (length(args) > 0) 
[10:32:53.307]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.307]             }
[10:32:53.307]             else {
[10:32:53.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.307]             }
[10:32:53.307]             {
[10:32:53.307]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.307]                   0L) {
[10:32:53.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.307]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.307]                   base::options(opts)
[10:32:53.307]                 }
[10:32:53.307]                 {
[10:32:53.307]                   {
[10:32:53.307]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.307]                     NULL
[10:32:53.307]                   }
[10:32:53.307]                   options(future.plan = NULL)
[10:32:53.307]                   if (is.na(NA_character_)) 
[10:32:53.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.307]                     .init = FALSE)
[10:32:53.307]                 }
[10:32:53.307]             }
[10:32:53.307]         }
[10:32:53.307]     })
[10:32:53.307]     if (TRUE) {
[10:32:53.307]         base::sink(type = "output", split = FALSE)
[10:32:53.307]         if (TRUE) {
[10:32:53.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.307]         }
[10:32:53.307]         else {
[10:32:53.307]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.307]         }
[10:32:53.307]         base::close(...future.stdout)
[10:32:53.307]         ...future.stdout <- NULL
[10:32:53.307]     }
[10:32:53.307]     ...future.result$conditions <- ...future.conditions
[10:32:53.307]     ...future.result$finished <- base::Sys.time()
[10:32:53.307]     ...future.result
[10:32:53.307] }
[10:32:53.310] MultisessionFuture started
[10:32:53.310] - Launch lazy future ... done
[10:32:53.310] run() for ‘MultisessionFuture’ ... done
[10:32:53.310] getGlobalsAndPackages() ...
[10:32:53.310] Searching for globals...
[10:32:53.311] - globals found: [1] ‘{’
[10:32:53.311] Searching for globals ... DONE
[10:32:53.311] Resolving globals: FALSE
[10:32:53.311] 
[10:32:53.312] 
[10:32:53.312] getGlobalsAndPackages() ... DONE
[10:32:53.312] run() for ‘Future’ ...
[10:32:53.312] - state: ‘created’
[10:32:53.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.326]   - Field: ‘node’
[10:32:53.326]   - Field: ‘label’
[10:32:53.326]   - Field: ‘local’
[10:32:53.326]   - Field: ‘owner’
[10:32:53.326]   - Field: ‘envir’
[10:32:53.326]   - Field: ‘workers’
[10:32:53.326]   - Field: ‘packages’
[10:32:53.326]   - Field: ‘gc’
[10:32:53.326]   - Field: ‘conditions’
[10:32:53.327]   - Field: ‘persistent’
[10:32:53.327]   - Field: ‘expr’
[10:32:53.327]   - Field: ‘uuid’
[10:32:53.327]   - Field: ‘seed’
[10:32:53.327]   - Field: ‘version’
[10:32:53.327]   - Field: ‘result’
[10:32:53.327]   - Field: ‘asynchronous’
[10:32:53.327]   - Field: ‘calls’
[10:32:53.327]   - Field: ‘globals’
[10:32:53.327]   - Field: ‘stdout’
[10:32:53.327]   - Field: ‘earlySignal’
[10:32:53.328]   - Field: ‘lazy’
[10:32:53.328]   - Field: ‘state’
[10:32:53.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.328] - Launch lazy future ...
[10:32:53.328] Packages needed by the future expression (n = 0): <none>
[10:32:53.328] Packages needed by future strategies (n = 0): <none>
[10:32:53.329] {
[10:32:53.329]     {
[10:32:53.329]         {
[10:32:53.329]             ...future.startTime <- base::Sys.time()
[10:32:53.329]             {
[10:32:53.329]                 {
[10:32:53.329]                   {
[10:32:53.329]                     {
[10:32:53.329]                       base::local({
[10:32:53.329]                         has_future <- base::requireNamespace("future", 
[10:32:53.329]                           quietly = TRUE)
[10:32:53.329]                         if (has_future) {
[10:32:53.329]                           ns <- base::getNamespace("future")
[10:32:53.329]                           version <- ns[[".package"]][["version"]]
[10:32:53.329]                           if (is.null(version)) 
[10:32:53.329]                             version <- utils::packageVersion("future")
[10:32:53.329]                         }
[10:32:53.329]                         else {
[10:32:53.329]                           version <- NULL
[10:32:53.329]                         }
[10:32:53.329]                         if (!has_future || version < "1.8.0") {
[10:32:53.329]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.329]                             "", base::R.version$version.string), 
[10:32:53.329]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.329]                               "release", "version")], collapse = " "), 
[10:32:53.329]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.329]                             info)
[10:32:53.329]                           info <- base::paste(info, collapse = "; ")
[10:32:53.329]                           if (!has_future) {
[10:32:53.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.329]                               info)
[10:32:53.329]                           }
[10:32:53.329]                           else {
[10:32:53.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.329]                               info, version)
[10:32:53.329]                           }
[10:32:53.329]                           base::stop(msg)
[10:32:53.329]                         }
[10:32:53.329]                       })
[10:32:53.329]                     }
[10:32:53.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.329]                     base::options(mc.cores = 1L)
[10:32:53.329]                   }
[10:32:53.329]                   ...future.strategy.old <- future::plan("list")
[10:32:53.329]                   options(future.plan = NULL)
[10:32:53.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.329]                 }
[10:32:53.329]                 ...future.workdir <- getwd()
[10:32:53.329]             }
[10:32:53.329]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.329]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.329]         }
[10:32:53.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.329]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.329]             base::names(...future.oldOptions))
[10:32:53.329]     }
[10:32:53.329]     if (FALSE) {
[10:32:53.329]     }
[10:32:53.329]     else {
[10:32:53.329]         if (TRUE) {
[10:32:53.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.329]                 open = "w")
[10:32:53.329]         }
[10:32:53.329]         else {
[10:32:53.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.329]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.329]         }
[10:32:53.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.329]             base::sink(type = "output", split = FALSE)
[10:32:53.329]             base::close(...future.stdout)
[10:32:53.329]         }, add = TRUE)
[10:32:53.329]     }
[10:32:53.329]     ...future.frame <- base::sys.nframe()
[10:32:53.329]     ...future.conditions <- base::list()
[10:32:53.329]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.329]     if (FALSE) {
[10:32:53.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.329]     }
[10:32:53.329]     ...future.result <- base::tryCatch({
[10:32:53.329]         base::withCallingHandlers({
[10:32:53.329]             ...future.value <- base::withVisible(base::local({
[10:32:53.329]                 ...future.makeSendCondition <- base::local({
[10:32:53.329]                   sendCondition <- NULL
[10:32:53.329]                   function(frame = 1L) {
[10:32:53.329]                     if (is.function(sendCondition)) 
[10:32:53.329]                       return(sendCondition)
[10:32:53.329]                     ns <- getNamespace("parallel")
[10:32:53.329]                     if (exists("sendData", mode = "function", 
[10:32:53.329]                       envir = ns)) {
[10:32:53.329]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.329]                         envir = ns)
[10:32:53.329]                       envir <- sys.frame(frame)
[10:32:53.329]                       master <- NULL
[10:32:53.329]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.329]                         !identical(envir, emptyenv())) {
[10:32:53.329]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.329]                           inherits = FALSE)) {
[10:32:53.329]                           master <- get("master", mode = "list", 
[10:32:53.329]                             envir = envir, inherits = FALSE)
[10:32:53.329]                           if (inherits(master, c("SOCKnode", 
[10:32:53.329]                             "SOCK0node"))) {
[10:32:53.329]                             sendCondition <<- function(cond) {
[10:32:53.329]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.329]                                 success = TRUE)
[10:32:53.329]                               parallel_sendData(master, data)
[10:32:53.329]                             }
[10:32:53.329]                             return(sendCondition)
[10:32:53.329]                           }
[10:32:53.329]                         }
[10:32:53.329]                         frame <- frame + 1L
[10:32:53.329]                         envir <- sys.frame(frame)
[10:32:53.329]                       }
[10:32:53.329]                     }
[10:32:53.329]                     sendCondition <<- function(cond) NULL
[10:32:53.329]                   }
[10:32:53.329]                 })
[10:32:53.329]                 withCallingHandlers({
[10:32:53.329]                   {
[10:32:53.329]                     4
[10:32:53.329]                   }
[10:32:53.329]                 }, immediateCondition = function(cond) {
[10:32:53.329]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.329]                   sendCondition(cond)
[10:32:53.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.329]                   {
[10:32:53.329]                     inherits <- base::inherits
[10:32:53.329]                     invokeRestart <- base::invokeRestart
[10:32:53.329]                     is.null <- base::is.null
[10:32:53.329]                     muffled <- FALSE
[10:32:53.329]                     if (inherits(cond, "message")) {
[10:32:53.329]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.329]                       if (muffled) 
[10:32:53.329]                         invokeRestart("muffleMessage")
[10:32:53.329]                     }
[10:32:53.329]                     else if (inherits(cond, "warning")) {
[10:32:53.329]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.329]                       if (muffled) 
[10:32:53.329]                         invokeRestart("muffleWarning")
[10:32:53.329]                     }
[10:32:53.329]                     else if (inherits(cond, "condition")) {
[10:32:53.329]                       if (!is.null(pattern)) {
[10:32:53.329]                         computeRestarts <- base::computeRestarts
[10:32:53.329]                         grepl <- base::grepl
[10:32:53.329]                         restarts <- computeRestarts(cond)
[10:32:53.329]                         for (restart in restarts) {
[10:32:53.329]                           name <- restart$name
[10:32:53.329]                           if (is.null(name)) 
[10:32:53.329]                             next
[10:32:53.329]                           if (!grepl(pattern, name)) 
[10:32:53.329]                             next
[10:32:53.329]                           invokeRestart(restart)
[10:32:53.329]                           muffled <- TRUE
[10:32:53.329]                           break
[10:32:53.329]                         }
[10:32:53.329]                       }
[10:32:53.329]                     }
[10:32:53.329]                     invisible(muffled)
[10:32:53.329]                   }
[10:32:53.329]                   muffleCondition(cond)
[10:32:53.329]                 })
[10:32:53.329]             }))
[10:32:53.329]             future::FutureResult(value = ...future.value$value, 
[10:32:53.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.329]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.329]                     ...future.globalenv.names))
[10:32:53.329]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.329]         }, condition = base::local({
[10:32:53.329]             c <- base::c
[10:32:53.329]             inherits <- base::inherits
[10:32:53.329]             invokeRestart <- base::invokeRestart
[10:32:53.329]             length <- base::length
[10:32:53.329]             list <- base::list
[10:32:53.329]             seq.int <- base::seq.int
[10:32:53.329]             signalCondition <- base::signalCondition
[10:32:53.329]             sys.calls <- base::sys.calls
[10:32:53.329]             `[[` <- base::`[[`
[10:32:53.329]             `+` <- base::`+`
[10:32:53.329]             `<<-` <- base::`<<-`
[10:32:53.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.329]                   3L)]
[10:32:53.329]             }
[10:32:53.329]             function(cond) {
[10:32:53.329]                 is_error <- inherits(cond, "error")
[10:32:53.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.329]                   NULL)
[10:32:53.329]                 if (is_error) {
[10:32:53.329]                   sessionInformation <- function() {
[10:32:53.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.329]                       search = base::search(), system = base::Sys.info())
[10:32:53.329]                   }
[10:32:53.329]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.329]                     cond$call), session = sessionInformation(), 
[10:32:53.329]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.329]                   signalCondition(cond)
[10:32:53.329]                 }
[10:32:53.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.329]                 "immediateCondition"))) {
[10:32:53.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.329]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.329]                   if (TRUE && !signal) {
[10:32:53.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.329]                     {
[10:32:53.329]                       inherits <- base::inherits
[10:32:53.329]                       invokeRestart <- base::invokeRestart
[10:32:53.329]                       is.null <- base::is.null
[10:32:53.329]                       muffled <- FALSE
[10:32:53.329]                       if (inherits(cond, "message")) {
[10:32:53.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.329]                         if (muffled) 
[10:32:53.329]                           invokeRestart("muffleMessage")
[10:32:53.329]                       }
[10:32:53.329]                       else if (inherits(cond, "warning")) {
[10:32:53.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.329]                         if (muffled) 
[10:32:53.329]                           invokeRestart("muffleWarning")
[10:32:53.329]                       }
[10:32:53.329]                       else if (inherits(cond, "condition")) {
[10:32:53.329]                         if (!is.null(pattern)) {
[10:32:53.329]                           computeRestarts <- base::computeRestarts
[10:32:53.329]                           grepl <- base::grepl
[10:32:53.329]                           restarts <- computeRestarts(cond)
[10:32:53.329]                           for (restart in restarts) {
[10:32:53.329]                             name <- restart$name
[10:32:53.329]                             if (is.null(name)) 
[10:32:53.329]                               next
[10:32:53.329]                             if (!grepl(pattern, name)) 
[10:32:53.329]                               next
[10:32:53.329]                             invokeRestart(restart)
[10:32:53.329]                             muffled <- TRUE
[10:32:53.329]                             break
[10:32:53.329]                           }
[10:32:53.329]                         }
[10:32:53.329]                       }
[10:32:53.329]                       invisible(muffled)
[10:32:53.329]                     }
[10:32:53.329]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.329]                   }
[10:32:53.329]                 }
[10:32:53.329]                 else {
[10:32:53.329]                   if (TRUE) {
[10:32:53.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.329]                     {
[10:32:53.329]                       inherits <- base::inherits
[10:32:53.329]                       invokeRestart <- base::invokeRestart
[10:32:53.329]                       is.null <- base::is.null
[10:32:53.329]                       muffled <- FALSE
[10:32:53.329]                       if (inherits(cond, "message")) {
[10:32:53.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.329]                         if (muffled) 
[10:32:53.329]                           invokeRestart("muffleMessage")
[10:32:53.329]                       }
[10:32:53.329]                       else if (inherits(cond, "warning")) {
[10:32:53.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.329]                         if (muffled) 
[10:32:53.329]                           invokeRestart("muffleWarning")
[10:32:53.329]                       }
[10:32:53.329]                       else if (inherits(cond, "condition")) {
[10:32:53.329]                         if (!is.null(pattern)) {
[10:32:53.329]                           computeRestarts <- base::computeRestarts
[10:32:53.329]                           grepl <- base::grepl
[10:32:53.329]                           restarts <- computeRestarts(cond)
[10:32:53.329]                           for (restart in restarts) {
[10:32:53.329]                             name <- restart$name
[10:32:53.329]                             if (is.null(name)) 
[10:32:53.329]                               next
[10:32:53.329]                             if (!grepl(pattern, name)) 
[10:32:53.329]                               next
[10:32:53.329]                             invokeRestart(restart)
[10:32:53.329]                             muffled <- TRUE
[10:32:53.329]                             break
[10:32:53.329]                           }
[10:32:53.329]                         }
[10:32:53.329]                       }
[10:32:53.329]                       invisible(muffled)
[10:32:53.329]                     }
[10:32:53.329]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.329]                   }
[10:32:53.329]                 }
[10:32:53.329]             }
[10:32:53.329]         }))
[10:32:53.329]     }, error = function(ex) {
[10:32:53.329]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.329]                 ...future.rng), started = ...future.startTime, 
[10:32:53.329]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.329]             version = "1.8"), class = "FutureResult")
[10:32:53.329]     }, finally = {
[10:32:53.329]         if (!identical(...future.workdir, getwd())) 
[10:32:53.329]             setwd(...future.workdir)
[10:32:53.329]         {
[10:32:53.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.329]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.329]             }
[10:32:53.329]             base::options(...future.oldOptions)
[10:32:53.329]             if (.Platform$OS.type == "windows") {
[10:32:53.329]                 old_names <- names(...future.oldEnvVars)
[10:32:53.329]                 envs <- base::Sys.getenv()
[10:32:53.329]                 names <- names(envs)
[10:32:53.329]                 common <- intersect(names, old_names)
[10:32:53.329]                 added <- setdiff(names, old_names)
[10:32:53.329]                 removed <- setdiff(old_names, names)
[10:32:53.329]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.329]                   envs[common]]
[10:32:53.329]                 NAMES <- toupper(changed)
[10:32:53.329]                 args <- list()
[10:32:53.329]                 for (kk in seq_along(NAMES)) {
[10:32:53.329]                   name <- changed[[kk]]
[10:32:53.329]                   NAME <- NAMES[[kk]]
[10:32:53.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.329]                     next
[10:32:53.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.329]                 }
[10:32:53.329]                 NAMES <- toupper(added)
[10:32:53.329]                 for (kk in seq_along(NAMES)) {
[10:32:53.329]                   name <- added[[kk]]
[10:32:53.329]                   NAME <- NAMES[[kk]]
[10:32:53.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.329]                     next
[10:32:53.329]                   args[[name]] <- ""
[10:32:53.329]                 }
[10:32:53.329]                 NAMES <- toupper(removed)
[10:32:53.329]                 for (kk in seq_along(NAMES)) {
[10:32:53.329]                   name <- removed[[kk]]
[10:32:53.329]                   NAME <- NAMES[[kk]]
[10:32:53.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.329]                     next
[10:32:53.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.329]                 }
[10:32:53.329]                 if (length(args) > 0) 
[10:32:53.329]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.329]             }
[10:32:53.329]             else {
[10:32:53.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.329]             }
[10:32:53.329]             {
[10:32:53.329]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.329]                   0L) {
[10:32:53.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.329]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.329]                   base::options(opts)
[10:32:53.329]                 }
[10:32:53.329]                 {
[10:32:53.329]                   {
[10:32:53.329]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.329]                     NULL
[10:32:53.329]                   }
[10:32:53.329]                   options(future.plan = NULL)
[10:32:53.329]                   if (is.na(NA_character_)) 
[10:32:53.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.329]                     .init = FALSE)
[10:32:53.329]                 }
[10:32:53.329]             }
[10:32:53.329]         }
[10:32:53.329]     })
[10:32:53.329]     if (TRUE) {
[10:32:53.329]         base::sink(type = "output", split = FALSE)
[10:32:53.329]         if (TRUE) {
[10:32:53.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.329]         }
[10:32:53.329]         else {
[10:32:53.329]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.329]         }
[10:32:53.329]         base::close(...future.stdout)
[10:32:53.329]         ...future.stdout <- NULL
[10:32:53.329]     }
[10:32:53.329]     ...future.result$conditions <- ...future.conditions
[10:32:53.329]     ...future.result$finished <- base::Sys.time()
[10:32:53.329]     ...future.result
[10:32:53.329] }
[10:32:53.331] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:53.341] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.342] - Validating connection of MultisessionFuture
[10:32:53.342] - received message: FutureResult
[10:32:53.342] - Received FutureResult
[10:32:53.342] - Erased future from FutureRegistry
[10:32:53.342] result() for ClusterFuture ...
[10:32:53.342] - result already collected: FutureResult
[10:32:53.342] result() for ClusterFuture ... done
[10:32:53.342] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.343] result() for ClusterFuture ...
[10:32:53.343] - result already collected: FutureResult
[10:32:53.343] result() for ClusterFuture ... done
[10:32:53.343] result() for ClusterFuture ...
[10:32:53.343] - result already collected: FutureResult
[10:32:53.343] result() for ClusterFuture ... done
[10:32:53.344] MultisessionFuture started
[10:32:53.344] - Launch lazy future ... done
[10:32:53.344] run() for ‘MultisessionFuture’ ... done
<environment: 0x5652d1f703e8> 
<environment: 0x5652d2d3ece8> 
[10:32:53.346] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.346] - Validating connection of MultisessionFuture
[10:32:53.346] - received message: FutureResult
[10:32:53.346] - Received FutureResult
[10:32:53.346] - Erased future from FutureRegistry
[10:32:53.346] result() for ClusterFuture ...
[10:32:53.347] - result already collected: FutureResult
[10:32:53.347] result() for ClusterFuture ... done
[10:32:53.347] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.347] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.347] - Validating connection of MultisessionFuture
[10:32:53.347] - received message: FutureResult
[10:32:53.347] - Received FutureResult
[10:32:53.348] - Erased future from FutureRegistry
[10:32:53.348] result() for ClusterFuture ...
[10:32:53.348] - result already collected: FutureResult
[10:32:53.348] result() for ClusterFuture ... done
[10:32:53.348] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:53.351] resolve() on environment ...
[10:32:53.352]  recursive: 0
[10:32:53.352]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:53.352] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.352] - nx: 4
[10:32:53.353] - relay: TRUE
[10:32:53.353] - stdout: TRUE
[10:32:53.353] - signal: TRUE
[10:32:53.353] - resignal: FALSE
[10:32:53.353] - force: TRUE
[10:32:53.353] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.353] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.353]  - until=2
[10:32:53.353]  - relaying element #2
[10:32:53.353] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.353] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.353] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.354]  length: 3 (resolved future 1)
[10:32:53.354] Future #2
[10:32:53.354] result() for ClusterFuture ...
[10:32:53.354] - result already collected: FutureResult
[10:32:53.354] result() for ClusterFuture ... done
[10:32:53.354] result() for ClusterFuture ...
[10:32:53.354] - result already collected: FutureResult
[10:32:53.354] result() for ClusterFuture ... done
[10:32:53.354] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:53.354] - nx: 4
[10:32:53.354] - relay: TRUE
[10:32:53.355] - stdout: TRUE
[10:32:53.355] - signal: TRUE
[10:32:53.355] - resignal: FALSE
[10:32:53.355] - force: TRUE
[10:32:53.355] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.355] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.355]  - until=2
[10:32:53.355]  - relaying element #2
[10:32:53.355] result() for ClusterFuture ...
[10:32:53.355] - result already collected: FutureResult
[10:32:53.355] result() for ClusterFuture ... done
[10:32:53.355] result() for ClusterFuture ...
[10:32:53.356] - result already collected: FutureResult
[10:32:53.356] result() for ClusterFuture ... done
[10:32:53.356] result() for ClusterFuture ...
[10:32:53.356] - result already collected: FutureResult
[10:32:53.356] result() for ClusterFuture ... done
[10:32:53.356] result() for ClusterFuture ...
[10:32:53.356] - result already collected: FutureResult
[10:32:53.356] result() for ClusterFuture ... done
[10:32:53.356] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.356] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.356] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:53.357]  length: 2 (resolved future 2)
[10:32:53.357] Future #3
[10:32:53.357] result() for ClusterFuture ...
[10:32:53.357] - result already collected: FutureResult
[10:32:53.357] result() for ClusterFuture ... done
[10:32:53.357] result() for ClusterFuture ...
[10:32:53.357] - result already collected: FutureResult
[10:32:53.357] result() for ClusterFuture ... done
[10:32:53.357] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:53.357] - nx: 4
[10:32:53.357] - relay: TRUE
[10:32:53.358] - stdout: TRUE
[10:32:53.358] - signal: TRUE
[10:32:53.358] - resignal: FALSE
[10:32:53.358] - force: TRUE
[10:32:53.358] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.358] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.358]  - until=3
[10:32:53.358]  - relaying element #3
[10:32:53.358] result() for ClusterFuture ...
[10:32:53.358] - result already collected: FutureResult
[10:32:53.358] result() for ClusterFuture ... done
[10:32:53.358] result() for ClusterFuture ...
[10:32:53.359] - result already collected: FutureResult
[10:32:53.359] result() for ClusterFuture ... done
[10:32:53.359] result() for ClusterFuture ...
[10:32:53.359] - result already collected: FutureResult
[10:32:53.359] result() for ClusterFuture ... done
[10:32:53.359] result() for ClusterFuture ...
[10:32:53.359] - result already collected: FutureResult
[10:32:53.359] result() for ClusterFuture ... done
[10:32:53.359] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.359] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.359] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:53.359]  length: 1 (resolved future 3)
[10:32:53.360] Future #4
[10:32:53.360] result() for ClusterFuture ...
[10:32:53.360] - result already collected: FutureResult
[10:32:53.360] result() for ClusterFuture ... done
[10:32:53.360] result() for ClusterFuture ...
[10:32:53.360] - result already collected: FutureResult
[10:32:53.360] result() for ClusterFuture ... done
[10:32:53.360] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:53.360] - nx: 4
[10:32:53.360] - relay: TRUE
[10:32:53.360] - stdout: TRUE
[10:32:53.361] - signal: TRUE
[10:32:53.361] - resignal: FALSE
[10:32:53.361] - force: TRUE
[10:32:53.361] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.361] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.361]  - until=4
[10:32:53.361]  - relaying element #4
[10:32:53.361] result() for ClusterFuture ...
[10:32:53.361] - result already collected: FutureResult
[10:32:53.361] result() for ClusterFuture ... done
[10:32:53.361] result() for ClusterFuture ...
[10:32:53.361] - result already collected: FutureResult
[10:32:53.362] result() for ClusterFuture ... done
[10:32:53.362] result() for ClusterFuture ...
[10:32:53.362] - result already collected: FutureResult
[10:32:53.362] result() for ClusterFuture ... done
[10:32:53.362] result() for ClusterFuture ...
[10:32:53.362] - result already collected: FutureResult
[10:32:53.362] result() for ClusterFuture ... done
[10:32:53.362] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.362] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.362] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:53.362]  length: 0 (resolved future 4)
[10:32:53.363] Relaying remaining futures
[10:32:53.363] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.363] - nx: 4
[10:32:53.363] - relay: TRUE
[10:32:53.363] - stdout: TRUE
[10:32:53.363] - signal: TRUE
[10:32:53.363] - resignal: FALSE
[10:32:53.363] - force: TRUE
[10:32:53.363] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.363] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:53.363] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.363] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.364] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.364] resolve() on environment ... DONE
[10:32:53.364] result() for ClusterFuture ...
[10:32:53.364] - result already collected: FutureResult
[10:32:53.364] result() for ClusterFuture ... done
[10:32:53.364] result() for ClusterFuture ...
[10:32:53.364] - result already collected: FutureResult
[10:32:53.364] result() for ClusterFuture ... done
[10:32:53.364] result() for ClusterFuture ...
[10:32:53.364] - result already collected: FutureResult
[10:32:53.364] result() for ClusterFuture ... done
[10:32:53.365] result() for ClusterFuture ...
[10:32:53.365] - result already collected: FutureResult
[10:32:53.365] result() for ClusterFuture ... done
[10:32:53.365] result() for ClusterFuture ...
[10:32:53.365] - result already collected: FutureResult
[10:32:53.365] result() for ClusterFuture ... done
[10:32:53.365] result() for ClusterFuture ...
[10:32:53.365] - result already collected: FutureResult
[10:32:53.365] result() for ClusterFuture ... done
<environment: 0x5652d0352eb0> 
Dimensions: c(2, 3, 1)
[10:32:53.366] getGlobalsAndPackages() ...
[10:32:53.366] Searching for globals...
[10:32:53.366] 
[10:32:53.366] Searching for globals ... DONE
[10:32:53.366] - globals: [0] <none>
[10:32:53.366] getGlobalsAndPackages() ... DONE
[10:32:53.367] run() for ‘Future’ ...
[10:32:53.367] - state: ‘created’
[10:32:53.367] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.381] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.381]   - Field: ‘node’
[10:32:53.381]   - Field: ‘label’
[10:32:53.381]   - Field: ‘local’
[10:32:53.382]   - Field: ‘owner’
[10:32:53.382]   - Field: ‘envir’
[10:32:53.382]   - Field: ‘workers’
[10:32:53.382]   - Field: ‘packages’
[10:32:53.382]   - Field: ‘gc’
[10:32:53.382]   - Field: ‘conditions’
[10:32:53.382]   - Field: ‘persistent’
[10:32:53.382]   - Field: ‘expr’
[10:32:53.382]   - Field: ‘uuid’
[10:32:53.382]   - Field: ‘seed’
[10:32:53.382]   - Field: ‘version’
[10:32:53.383]   - Field: ‘result’
[10:32:53.383]   - Field: ‘asynchronous’
[10:32:53.383]   - Field: ‘calls’
[10:32:53.383]   - Field: ‘globals’
[10:32:53.383]   - Field: ‘stdout’
[10:32:53.383]   - Field: ‘earlySignal’
[10:32:53.383]   - Field: ‘lazy’
[10:32:53.383]   - Field: ‘state’
[10:32:53.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.383] - Launch lazy future ...
[10:32:53.384] Packages needed by the future expression (n = 0): <none>
[10:32:53.384] Packages needed by future strategies (n = 0): <none>
[10:32:53.384] {
[10:32:53.384]     {
[10:32:53.384]         {
[10:32:53.384]             ...future.startTime <- base::Sys.time()
[10:32:53.384]             {
[10:32:53.384]                 {
[10:32:53.384]                   {
[10:32:53.384]                     {
[10:32:53.384]                       base::local({
[10:32:53.384]                         has_future <- base::requireNamespace("future", 
[10:32:53.384]                           quietly = TRUE)
[10:32:53.384]                         if (has_future) {
[10:32:53.384]                           ns <- base::getNamespace("future")
[10:32:53.384]                           version <- ns[[".package"]][["version"]]
[10:32:53.384]                           if (is.null(version)) 
[10:32:53.384]                             version <- utils::packageVersion("future")
[10:32:53.384]                         }
[10:32:53.384]                         else {
[10:32:53.384]                           version <- NULL
[10:32:53.384]                         }
[10:32:53.384]                         if (!has_future || version < "1.8.0") {
[10:32:53.384]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.384]                             "", base::R.version$version.string), 
[10:32:53.384]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.384]                               "release", "version")], collapse = " "), 
[10:32:53.384]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.384]                             info)
[10:32:53.384]                           info <- base::paste(info, collapse = "; ")
[10:32:53.384]                           if (!has_future) {
[10:32:53.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.384]                               info)
[10:32:53.384]                           }
[10:32:53.384]                           else {
[10:32:53.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.384]                               info, version)
[10:32:53.384]                           }
[10:32:53.384]                           base::stop(msg)
[10:32:53.384]                         }
[10:32:53.384]                       })
[10:32:53.384]                     }
[10:32:53.384]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.384]                     base::options(mc.cores = 1L)
[10:32:53.384]                   }
[10:32:53.384]                   ...future.strategy.old <- future::plan("list")
[10:32:53.384]                   options(future.plan = NULL)
[10:32:53.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.384]                 }
[10:32:53.384]                 ...future.workdir <- getwd()
[10:32:53.384]             }
[10:32:53.384]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.384]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.384]         }
[10:32:53.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.384]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.384]             base::names(...future.oldOptions))
[10:32:53.384]     }
[10:32:53.384]     if (FALSE) {
[10:32:53.384]     }
[10:32:53.384]     else {
[10:32:53.384]         if (TRUE) {
[10:32:53.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.384]                 open = "w")
[10:32:53.384]         }
[10:32:53.384]         else {
[10:32:53.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.384]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.384]         }
[10:32:53.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.384]             base::sink(type = "output", split = FALSE)
[10:32:53.384]             base::close(...future.stdout)
[10:32:53.384]         }, add = TRUE)
[10:32:53.384]     }
[10:32:53.384]     ...future.frame <- base::sys.nframe()
[10:32:53.384]     ...future.conditions <- base::list()
[10:32:53.384]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.384]     if (FALSE) {
[10:32:53.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.384]     }
[10:32:53.384]     ...future.result <- base::tryCatch({
[10:32:53.384]         base::withCallingHandlers({
[10:32:53.384]             ...future.value <- base::withVisible(base::local({
[10:32:53.384]                 ...future.makeSendCondition <- base::local({
[10:32:53.384]                   sendCondition <- NULL
[10:32:53.384]                   function(frame = 1L) {
[10:32:53.384]                     if (is.function(sendCondition)) 
[10:32:53.384]                       return(sendCondition)
[10:32:53.384]                     ns <- getNamespace("parallel")
[10:32:53.384]                     if (exists("sendData", mode = "function", 
[10:32:53.384]                       envir = ns)) {
[10:32:53.384]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.384]                         envir = ns)
[10:32:53.384]                       envir <- sys.frame(frame)
[10:32:53.384]                       master <- NULL
[10:32:53.384]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.384]                         !identical(envir, emptyenv())) {
[10:32:53.384]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.384]                           inherits = FALSE)) {
[10:32:53.384]                           master <- get("master", mode = "list", 
[10:32:53.384]                             envir = envir, inherits = FALSE)
[10:32:53.384]                           if (inherits(master, c("SOCKnode", 
[10:32:53.384]                             "SOCK0node"))) {
[10:32:53.384]                             sendCondition <<- function(cond) {
[10:32:53.384]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.384]                                 success = TRUE)
[10:32:53.384]                               parallel_sendData(master, data)
[10:32:53.384]                             }
[10:32:53.384]                             return(sendCondition)
[10:32:53.384]                           }
[10:32:53.384]                         }
[10:32:53.384]                         frame <- frame + 1L
[10:32:53.384]                         envir <- sys.frame(frame)
[10:32:53.384]                       }
[10:32:53.384]                     }
[10:32:53.384]                     sendCondition <<- function(cond) NULL
[10:32:53.384]                   }
[10:32:53.384]                 })
[10:32:53.384]                 withCallingHandlers({
[10:32:53.384]                   2
[10:32:53.384]                 }, immediateCondition = function(cond) {
[10:32:53.384]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.384]                   sendCondition(cond)
[10:32:53.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.384]                   {
[10:32:53.384]                     inherits <- base::inherits
[10:32:53.384]                     invokeRestart <- base::invokeRestart
[10:32:53.384]                     is.null <- base::is.null
[10:32:53.384]                     muffled <- FALSE
[10:32:53.384]                     if (inherits(cond, "message")) {
[10:32:53.384]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.384]                       if (muffled) 
[10:32:53.384]                         invokeRestart("muffleMessage")
[10:32:53.384]                     }
[10:32:53.384]                     else if (inherits(cond, "warning")) {
[10:32:53.384]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.384]                       if (muffled) 
[10:32:53.384]                         invokeRestart("muffleWarning")
[10:32:53.384]                     }
[10:32:53.384]                     else if (inherits(cond, "condition")) {
[10:32:53.384]                       if (!is.null(pattern)) {
[10:32:53.384]                         computeRestarts <- base::computeRestarts
[10:32:53.384]                         grepl <- base::grepl
[10:32:53.384]                         restarts <- computeRestarts(cond)
[10:32:53.384]                         for (restart in restarts) {
[10:32:53.384]                           name <- restart$name
[10:32:53.384]                           if (is.null(name)) 
[10:32:53.384]                             next
[10:32:53.384]                           if (!grepl(pattern, name)) 
[10:32:53.384]                             next
[10:32:53.384]                           invokeRestart(restart)
[10:32:53.384]                           muffled <- TRUE
[10:32:53.384]                           break
[10:32:53.384]                         }
[10:32:53.384]                       }
[10:32:53.384]                     }
[10:32:53.384]                     invisible(muffled)
[10:32:53.384]                   }
[10:32:53.384]                   muffleCondition(cond)
[10:32:53.384]                 })
[10:32:53.384]             }))
[10:32:53.384]             future::FutureResult(value = ...future.value$value, 
[10:32:53.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.384]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.384]                     ...future.globalenv.names))
[10:32:53.384]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.384]         }, condition = base::local({
[10:32:53.384]             c <- base::c
[10:32:53.384]             inherits <- base::inherits
[10:32:53.384]             invokeRestart <- base::invokeRestart
[10:32:53.384]             length <- base::length
[10:32:53.384]             list <- base::list
[10:32:53.384]             seq.int <- base::seq.int
[10:32:53.384]             signalCondition <- base::signalCondition
[10:32:53.384]             sys.calls <- base::sys.calls
[10:32:53.384]             `[[` <- base::`[[`
[10:32:53.384]             `+` <- base::`+`
[10:32:53.384]             `<<-` <- base::`<<-`
[10:32:53.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.384]                   3L)]
[10:32:53.384]             }
[10:32:53.384]             function(cond) {
[10:32:53.384]                 is_error <- inherits(cond, "error")
[10:32:53.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.384]                   NULL)
[10:32:53.384]                 if (is_error) {
[10:32:53.384]                   sessionInformation <- function() {
[10:32:53.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.384]                       search = base::search(), system = base::Sys.info())
[10:32:53.384]                   }
[10:32:53.384]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.384]                     cond$call), session = sessionInformation(), 
[10:32:53.384]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.384]                   signalCondition(cond)
[10:32:53.384]                 }
[10:32:53.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.384]                 "immediateCondition"))) {
[10:32:53.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.384]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.384]                   if (TRUE && !signal) {
[10:32:53.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.384]                     {
[10:32:53.384]                       inherits <- base::inherits
[10:32:53.384]                       invokeRestart <- base::invokeRestart
[10:32:53.384]                       is.null <- base::is.null
[10:32:53.384]                       muffled <- FALSE
[10:32:53.384]                       if (inherits(cond, "message")) {
[10:32:53.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.384]                         if (muffled) 
[10:32:53.384]                           invokeRestart("muffleMessage")
[10:32:53.384]                       }
[10:32:53.384]                       else if (inherits(cond, "warning")) {
[10:32:53.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.384]                         if (muffled) 
[10:32:53.384]                           invokeRestart("muffleWarning")
[10:32:53.384]                       }
[10:32:53.384]                       else if (inherits(cond, "condition")) {
[10:32:53.384]                         if (!is.null(pattern)) {
[10:32:53.384]                           computeRestarts <- base::computeRestarts
[10:32:53.384]                           grepl <- base::grepl
[10:32:53.384]                           restarts <- computeRestarts(cond)
[10:32:53.384]                           for (restart in restarts) {
[10:32:53.384]                             name <- restart$name
[10:32:53.384]                             if (is.null(name)) 
[10:32:53.384]                               next
[10:32:53.384]                             if (!grepl(pattern, name)) 
[10:32:53.384]                               next
[10:32:53.384]                             invokeRestart(restart)
[10:32:53.384]                             muffled <- TRUE
[10:32:53.384]                             break
[10:32:53.384]                           }
[10:32:53.384]                         }
[10:32:53.384]                       }
[10:32:53.384]                       invisible(muffled)
[10:32:53.384]                     }
[10:32:53.384]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.384]                   }
[10:32:53.384]                 }
[10:32:53.384]                 else {
[10:32:53.384]                   if (TRUE) {
[10:32:53.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.384]                     {
[10:32:53.384]                       inherits <- base::inherits
[10:32:53.384]                       invokeRestart <- base::invokeRestart
[10:32:53.384]                       is.null <- base::is.null
[10:32:53.384]                       muffled <- FALSE
[10:32:53.384]                       if (inherits(cond, "message")) {
[10:32:53.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.384]                         if (muffled) 
[10:32:53.384]                           invokeRestart("muffleMessage")
[10:32:53.384]                       }
[10:32:53.384]                       else if (inherits(cond, "warning")) {
[10:32:53.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.384]                         if (muffled) 
[10:32:53.384]                           invokeRestart("muffleWarning")
[10:32:53.384]                       }
[10:32:53.384]                       else if (inherits(cond, "condition")) {
[10:32:53.384]                         if (!is.null(pattern)) {
[10:32:53.384]                           computeRestarts <- base::computeRestarts
[10:32:53.384]                           grepl <- base::grepl
[10:32:53.384]                           restarts <- computeRestarts(cond)
[10:32:53.384]                           for (restart in restarts) {
[10:32:53.384]                             name <- restart$name
[10:32:53.384]                             if (is.null(name)) 
[10:32:53.384]                               next
[10:32:53.384]                             if (!grepl(pattern, name)) 
[10:32:53.384]                               next
[10:32:53.384]                             invokeRestart(restart)
[10:32:53.384]                             muffled <- TRUE
[10:32:53.384]                             break
[10:32:53.384]                           }
[10:32:53.384]                         }
[10:32:53.384]                       }
[10:32:53.384]                       invisible(muffled)
[10:32:53.384]                     }
[10:32:53.384]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.384]                   }
[10:32:53.384]                 }
[10:32:53.384]             }
[10:32:53.384]         }))
[10:32:53.384]     }, error = function(ex) {
[10:32:53.384]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.384]                 ...future.rng), started = ...future.startTime, 
[10:32:53.384]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.384]             version = "1.8"), class = "FutureResult")
[10:32:53.384]     }, finally = {
[10:32:53.384]         if (!identical(...future.workdir, getwd())) 
[10:32:53.384]             setwd(...future.workdir)
[10:32:53.384]         {
[10:32:53.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.384]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.384]             }
[10:32:53.384]             base::options(...future.oldOptions)
[10:32:53.384]             if (.Platform$OS.type == "windows") {
[10:32:53.384]                 old_names <- names(...future.oldEnvVars)
[10:32:53.384]                 envs <- base::Sys.getenv()
[10:32:53.384]                 names <- names(envs)
[10:32:53.384]                 common <- intersect(names, old_names)
[10:32:53.384]                 added <- setdiff(names, old_names)
[10:32:53.384]                 removed <- setdiff(old_names, names)
[10:32:53.384]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.384]                   envs[common]]
[10:32:53.384]                 NAMES <- toupper(changed)
[10:32:53.384]                 args <- list()
[10:32:53.384]                 for (kk in seq_along(NAMES)) {
[10:32:53.384]                   name <- changed[[kk]]
[10:32:53.384]                   NAME <- NAMES[[kk]]
[10:32:53.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.384]                     next
[10:32:53.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.384]                 }
[10:32:53.384]                 NAMES <- toupper(added)
[10:32:53.384]                 for (kk in seq_along(NAMES)) {
[10:32:53.384]                   name <- added[[kk]]
[10:32:53.384]                   NAME <- NAMES[[kk]]
[10:32:53.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.384]                     next
[10:32:53.384]                   args[[name]] <- ""
[10:32:53.384]                 }
[10:32:53.384]                 NAMES <- toupper(removed)
[10:32:53.384]                 for (kk in seq_along(NAMES)) {
[10:32:53.384]                   name <- removed[[kk]]
[10:32:53.384]                   NAME <- NAMES[[kk]]
[10:32:53.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.384]                     next
[10:32:53.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.384]                 }
[10:32:53.384]                 if (length(args) > 0) 
[10:32:53.384]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.384]             }
[10:32:53.384]             else {
[10:32:53.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.384]             }
[10:32:53.384]             {
[10:32:53.384]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.384]                   0L) {
[10:32:53.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.384]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.384]                   base::options(opts)
[10:32:53.384]                 }
[10:32:53.384]                 {
[10:32:53.384]                   {
[10:32:53.384]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.384]                     NULL
[10:32:53.384]                   }
[10:32:53.384]                   options(future.plan = NULL)
[10:32:53.384]                   if (is.na(NA_character_)) 
[10:32:53.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.384]                     .init = FALSE)
[10:32:53.384]                 }
[10:32:53.384]             }
[10:32:53.384]         }
[10:32:53.384]     })
[10:32:53.384]     if (TRUE) {
[10:32:53.384]         base::sink(type = "output", split = FALSE)
[10:32:53.384]         if (TRUE) {
[10:32:53.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.384]         }
[10:32:53.384]         else {
[10:32:53.384]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.384]         }
[10:32:53.384]         base::close(...future.stdout)
[10:32:53.384]         ...future.stdout <- NULL
[10:32:53.384]     }
[10:32:53.384]     ...future.result$conditions <- ...future.conditions
[10:32:53.384]     ...future.result$finished <- base::Sys.time()
[10:32:53.384]     ...future.result
[10:32:53.384] }
[10:32:53.387] MultisessionFuture started
[10:32:53.387] - Launch lazy future ... done
[10:32:53.387] run() for ‘MultisessionFuture’ ... done
[10:32:53.387] getGlobalsAndPackages() ...
[10:32:53.388] Searching for globals...
[10:32:53.388] 
[10:32:53.388] Searching for globals ... DONE
[10:32:53.388] - globals: [0] <none>
[10:32:53.388] getGlobalsAndPackages() ... DONE
[10:32:53.388] run() for ‘Future’ ...
[10:32:53.388] - state: ‘created’
[10:32:53.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.402] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.402]   - Field: ‘node’
[10:32:53.403]   - Field: ‘label’
[10:32:53.403]   - Field: ‘local’
[10:32:53.403]   - Field: ‘owner’
[10:32:53.403]   - Field: ‘envir’
[10:32:53.403]   - Field: ‘workers’
[10:32:53.403]   - Field: ‘packages’
[10:32:53.403]   - Field: ‘gc’
[10:32:53.403]   - Field: ‘conditions’
[10:32:53.403]   - Field: ‘persistent’
[10:32:53.403]   - Field: ‘expr’
[10:32:53.404]   - Field: ‘uuid’
[10:32:53.404]   - Field: ‘seed’
[10:32:53.404]   - Field: ‘version’
[10:32:53.404]   - Field: ‘result’
[10:32:53.404]   - Field: ‘asynchronous’
[10:32:53.404]   - Field: ‘calls’
[10:32:53.404]   - Field: ‘globals’
[10:32:53.404]   - Field: ‘stdout’
[10:32:53.404]   - Field: ‘earlySignal’
[10:32:53.404]   - Field: ‘lazy’
[10:32:53.404]   - Field: ‘state’
[10:32:53.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.405] - Launch lazy future ...
[10:32:53.405] Packages needed by the future expression (n = 0): <none>
[10:32:53.405] Packages needed by future strategies (n = 0): <none>
[10:32:53.405] {
[10:32:53.405]     {
[10:32:53.405]         {
[10:32:53.405]             ...future.startTime <- base::Sys.time()
[10:32:53.405]             {
[10:32:53.405]                 {
[10:32:53.405]                   {
[10:32:53.405]                     {
[10:32:53.405]                       base::local({
[10:32:53.405]                         has_future <- base::requireNamespace("future", 
[10:32:53.405]                           quietly = TRUE)
[10:32:53.405]                         if (has_future) {
[10:32:53.405]                           ns <- base::getNamespace("future")
[10:32:53.405]                           version <- ns[[".package"]][["version"]]
[10:32:53.405]                           if (is.null(version)) 
[10:32:53.405]                             version <- utils::packageVersion("future")
[10:32:53.405]                         }
[10:32:53.405]                         else {
[10:32:53.405]                           version <- NULL
[10:32:53.405]                         }
[10:32:53.405]                         if (!has_future || version < "1.8.0") {
[10:32:53.405]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.405]                             "", base::R.version$version.string), 
[10:32:53.405]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.405]                               "release", "version")], collapse = " "), 
[10:32:53.405]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.405]                             info)
[10:32:53.405]                           info <- base::paste(info, collapse = "; ")
[10:32:53.405]                           if (!has_future) {
[10:32:53.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.405]                               info)
[10:32:53.405]                           }
[10:32:53.405]                           else {
[10:32:53.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.405]                               info, version)
[10:32:53.405]                           }
[10:32:53.405]                           base::stop(msg)
[10:32:53.405]                         }
[10:32:53.405]                       })
[10:32:53.405]                     }
[10:32:53.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.405]                     base::options(mc.cores = 1L)
[10:32:53.405]                   }
[10:32:53.405]                   ...future.strategy.old <- future::plan("list")
[10:32:53.405]                   options(future.plan = NULL)
[10:32:53.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.405]                 }
[10:32:53.405]                 ...future.workdir <- getwd()
[10:32:53.405]             }
[10:32:53.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.405]         }
[10:32:53.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.405]             base::names(...future.oldOptions))
[10:32:53.405]     }
[10:32:53.405]     if (FALSE) {
[10:32:53.405]     }
[10:32:53.405]     else {
[10:32:53.405]         if (TRUE) {
[10:32:53.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.405]                 open = "w")
[10:32:53.405]         }
[10:32:53.405]         else {
[10:32:53.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.405]         }
[10:32:53.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.405]             base::sink(type = "output", split = FALSE)
[10:32:53.405]             base::close(...future.stdout)
[10:32:53.405]         }, add = TRUE)
[10:32:53.405]     }
[10:32:53.405]     ...future.frame <- base::sys.nframe()
[10:32:53.405]     ...future.conditions <- base::list()
[10:32:53.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.405]     if (FALSE) {
[10:32:53.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.405]     }
[10:32:53.405]     ...future.result <- base::tryCatch({
[10:32:53.405]         base::withCallingHandlers({
[10:32:53.405]             ...future.value <- base::withVisible(base::local({
[10:32:53.405]                 ...future.makeSendCondition <- base::local({
[10:32:53.405]                   sendCondition <- NULL
[10:32:53.405]                   function(frame = 1L) {
[10:32:53.405]                     if (is.function(sendCondition)) 
[10:32:53.405]                       return(sendCondition)
[10:32:53.405]                     ns <- getNamespace("parallel")
[10:32:53.405]                     if (exists("sendData", mode = "function", 
[10:32:53.405]                       envir = ns)) {
[10:32:53.405]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.405]                         envir = ns)
[10:32:53.405]                       envir <- sys.frame(frame)
[10:32:53.405]                       master <- NULL
[10:32:53.405]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.405]                         !identical(envir, emptyenv())) {
[10:32:53.405]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.405]                           inherits = FALSE)) {
[10:32:53.405]                           master <- get("master", mode = "list", 
[10:32:53.405]                             envir = envir, inherits = FALSE)
[10:32:53.405]                           if (inherits(master, c("SOCKnode", 
[10:32:53.405]                             "SOCK0node"))) {
[10:32:53.405]                             sendCondition <<- function(cond) {
[10:32:53.405]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.405]                                 success = TRUE)
[10:32:53.405]                               parallel_sendData(master, data)
[10:32:53.405]                             }
[10:32:53.405]                             return(sendCondition)
[10:32:53.405]                           }
[10:32:53.405]                         }
[10:32:53.405]                         frame <- frame + 1L
[10:32:53.405]                         envir <- sys.frame(frame)
[10:32:53.405]                       }
[10:32:53.405]                     }
[10:32:53.405]                     sendCondition <<- function(cond) NULL
[10:32:53.405]                   }
[10:32:53.405]                 })
[10:32:53.405]                 withCallingHandlers({
[10:32:53.405]                   NULL
[10:32:53.405]                 }, immediateCondition = function(cond) {
[10:32:53.405]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.405]                   sendCondition(cond)
[10:32:53.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.405]                   {
[10:32:53.405]                     inherits <- base::inherits
[10:32:53.405]                     invokeRestart <- base::invokeRestart
[10:32:53.405]                     is.null <- base::is.null
[10:32:53.405]                     muffled <- FALSE
[10:32:53.405]                     if (inherits(cond, "message")) {
[10:32:53.405]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.405]                       if (muffled) 
[10:32:53.405]                         invokeRestart("muffleMessage")
[10:32:53.405]                     }
[10:32:53.405]                     else if (inherits(cond, "warning")) {
[10:32:53.405]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.405]                       if (muffled) 
[10:32:53.405]                         invokeRestart("muffleWarning")
[10:32:53.405]                     }
[10:32:53.405]                     else if (inherits(cond, "condition")) {
[10:32:53.405]                       if (!is.null(pattern)) {
[10:32:53.405]                         computeRestarts <- base::computeRestarts
[10:32:53.405]                         grepl <- base::grepl
[10:32:53.405]                         restarts <- computeRestarts(cond)
[10:32:53.405]                         for (restart in restarts) {
[10:32:53.405]                           name <- restart$name
[10:32:53.405]                           if (is.null(name)) 
[10:32:53.405]                             next
[10:32:53.405]                           if (!grepl(pattern, name)) 
[10:32:53.405]                             next
[10:32:53.405]                           invokeRestart(restart)
[10:32:53.405]                           muffled <- TRUE
[10:32:53.405]                           break
[10:32:53.405]                         }
[10:32:53.405]                       }
[10:32:53.405]                     }
[10:32:53.405]                     invisible(muffled)
[10:32:53.405]                   }
[10:32:53.405]                   muffleCondition(cond)
[10:32:53.405]                 })
[10:32:53.405]             }))
[10:32:53.405]             future::FutureResult(value = ...future.value$value, 
[10:32:53.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.405]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.405]                     ...future.globalenv.names))
[10:32:53.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.405]         }, condition = base::local({
[10:32:53.405]             c <- base::c
[10:32:53.405]             inherits <- base::inherits
[10:32:53.405]             invokeRestart <- base::invokeRestart
[10:32:53.405]             length <- base::length
[10:32:53.405]             list <- base::list
[10:32:53.405]             seq.int <- base::seq.int
[10:32:53.405]             signalCondition <- base::signalCondition
[10:32:53.405]             sys.calls <- base::sys.calls
[10:32:53.405]             `[[` <- base::`[[`
[10:32:53.405]             `+` <- base::`+`
[10:32:53.405]             `<<-` <- base::`<<-`
[10:32:53.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.405]                   3L)]
[10:32:53.405]             }
[10:32:53.405]             function(cond) {
[10:32:53.405]                 is_error <- inherits(cond, "error")
[10:32:53.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.405]                   NULL)
[10:32:53.405]                 if (is_error) {
[10:32:53.405]                   sessionInformation <- function() {
[10:32:53.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.405]                       search = base::search(), system = base::Sys.info())
[10:32:53.405]                   }
[10:32:53.405]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.405]                     cond$call), session = sessionInformation(), 
[10:32:53.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.405]                   signalCondition(cond)
[10:32:53.405]                 }
[10:32:53.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.405]                 "immediateCondition"))) {
[10:32:53.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.405]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.405]                   if (TRUE && !signal) {
[10:32:53.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.405]                     {
[10:32:53.405]                       inherits <- base::inherits
[10:32:53.405]                       invokeRestart <- base::invokeRestart
[10:32:53.405]                       is.null <- base::is.null
[10:32:53.405]                       muffled <- FALSE
[10:32:53.405]                       if (inherits(cond, "message")) {
[10:32:53.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.405]                         if (muffled) 
[10:32:53.405]                           invokeRestart("muffleMessage")
[10:32:53.405]                       }
[10:32:53.405]                       else if (inherits(cond, "warning")) {
[10:32:53.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.405]                         if (muffled) 
[10:32:53.405]                           invokeRestart("muffleWarning")
[10:32:53.405]                       }
[10:32:53.405]                       else if (inherits(cond, "condition")) {
[10:32:53.405]                         if (!is.null(pattern)) {
[10:32:53.405]                           computeRestarts <- base::computeRestarts
[10:32:53.405]                           grepl <- base::grepl
[10:32:53.405]                           restarts <- computeRestarts(cond)
[10:32:53.405]                           for (restart in restarts) {
[10:32:53.405]                             name <- restart$name
[10:32:53.405]                             if (is.null(name)) 
[10:32:53.405]                               next
[10:32:53.405]                             if (!grepl(pattern, name)) 
[10:32:53.405]                               next
[10:32:53.405]                             invokeRestart(restart)
[10:32:53.405]                             muffled <- TRUE
[10:32:53.405]                             break
[10:32:53.405]                           }
[10:32:53.405]                         }
[10:32:53.405]                       }
[10:32:53.405]                       invisible(muffled)
[10:32:53.405]                     }
[10:32:53.405]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.405]                   }
[10:32:53.405]                 }
[10:32:53.405]                 else {
[10:32:53.405]                   if (TRUE) {
[10:32:53.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.405]                     {
[10:32:53.405]                       inherits <- base::inherits
[10:32:53.405]                       invokeRestart <- base::invokeRestart
[10:32:53.405]                       is.null <- base::is.null
[10:32:53.405]                       muffled <- FALSE
[10:32:53.405]                       if (inherits(cond, "message")) {
[10:32:53.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.405]                         if (muffled) 
[10:32:53.405]                           invokeRestart("muffleMessage")
[10:32:53.405]                       }
[10:32:53.405]                       else if (inherits(cond, "warning")) {
[10:32:53.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.405]                         if (muffled) 
[10:32:53.405]                           invokeRestart("muffleWarning")
[10:32:53.405]                       }
[10:32:53.405]                       else if (inherits(cond, "condition")) {
[10:32:53.405]                         if (!is.null(pattern)) {
[10:32:53.405]                           computeRestarts <- base::computeRestarts
[10:32:53.405]                           grepl <- base::grepl
[10:32:53.405]                           restarts <- computeRestarts(cond)
[10:32:53.405]                           for (restart in restarts) {
[10:32:53.405]                             name <- restart$name
[10:32:53.405]                             if (is.null(name)) 
[10:32:53.405]                               next
[10:32:53.405]                             if (!grepl(pattern, name)) 
[10:32:53.405]                               next
[10:32:53.405]                             invokeRestart(restart)
[10:32:53.405]                             muffled <- TRUE
[10:32:53.405]                             break
[10:32:53.405]                           }
[10:32:53.405]                         }
[10:32:53.405]                       }
[10:32:53.405]                       invisible(muffled)
[10:32:53.405]                     }
[10:32:53.405]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.405]                   }
[10:32:53.405]                 }
[10:32:53.405]             }
[10:32:53.405]         }))
[10:32:53.405]     }, error = function(ex) {
[10:32:53.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.405]                 ...future.rng), started = ...future.startTime, 
[10:32:53.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.405]             version = "1.8"), class = "FutureResult")
[10:32:53.405]     }, finally = {
[10:32:53.405]         if (!identical(...future.workdir, getwd())) 
[10:32:53.405]             setwd(...future.workdir)
[10:32:53.405]         {
[10:32:53.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.405]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.405]             }
[10:32:53.405]             base::options(...future.oldOptions)
[10:32:53.405]             if (.Platform$OS.type == "windows") {
[10:32:53.405]                 old_names <- names(...future.oldEnvVars)
[10:32:53.405]                 envs <- base::Sys.getenv()
[10:32:53.405]                 names <- names(envs)
[10:32:53.405]                 common <- intersect(names, old_names)
[10:32:53.405]                 added <- setdiff(names, old_names)
[10:32:53.405]                 removed <- setdiff(old_names, names)
[10:32:53.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.405]                   envs[common]]
[10:32:53.405]                 NAMES <- toupper(changed)
[10:32:53.405]                 args <- list()
[10:32:53.405]                 for (kk in seq_along(NAMES)) {
[10:32:53.405]                   name <- changed[[kk]]
[10:32:53.405]                   NAME <- NAMES[[kk]]
[10:32:53.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.405]                     next
[10:32:53.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.405]                 }
[10:32:53.405]                 NAMES <- toupper(added)
[10:32:53.405]                 for (kk in seq_along(NAMES)) {
[10:32:53.405]                   name <- added[[kk]]
[10:32:53.405]                   NAME <- NAMES[[kk]]
[10:32:53.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.405]                     next
[10:32:53.405]                   args[[name]] <- ""
[10:32:53.405]                 }
[10:32:53.405]                 NAMES <- toupper(removed)
[10:32:53.405]                 for (kk in seq_along(NAMES)) {
[10:32:53.405]                   name <- removed[[kk]]
[10:32:53.405]                   NAME <- NAMES[[kk]]
[10:32:53.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.405]                     next
[10:32:53.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.405]                 }
[10:32:53.405]                 if (length(args) > 0) 
[10:32:53.405]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.405]             }
[10:32:53.405]             else {
[10:32:53.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.405]             }
[10:32:53.405]             {
[10:32:53.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.405]                   0L) {
[10:32:53.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.405]                   base::options(opts)
[10:32:53.405]                 }
[10:32:53.405]                 {
[10:32:53.405]                   {
[10:32:53.405]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.405]                     NULL
[10:32:53.405]                   }
[10:32:53.405]                   options(future.plan = NULL)
[10:32:53.405]                   if (is.na(NA_character_)) 
[10:32:53.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.405]                     .init = FALSE)
[10:32:53.405]                 }
[10:32:53.405]             }
[10:32:53.405]         }
[10:32:53.405]     })
[10:32:53.405]     if (TRUE) {
[10:32:53.405]         base::sink(type = "output", split = FALSE)
[10:32:53.405]         if (TRUE) {
[10:32:53.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.405]         }
[10:32:53.405]         else {
[10:32:53.405]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.405]         }
[10:32:53.405]         base::close(...future.stdout)
[10:32:53.405]         ...future.stdout <- NULL
[10:32:53.405]     }
[10:32:53.405]     ...future.result$conditions <- ...future.conditions
[10:32:53.405]     ...future.result$finished <- base::Sys.time()
[10:32:53.405]     ...future.result
[10:32:53.405] }
[10:32:53.408] MultisessionFuture started
[10:32:53.408] - Launch lazy future ... done
[10:32:53.409] run() for ‘MultisessionFuture’ ... done
[10:32:53.409] getGlobalsAndPackages() ...
[10:32:53.409] Searching for globals...
[10:32:53.410] - globals found: [1] ‘{’
[10:32:53.410] Searching for globals ... DONE
[10:32:53.410] Resolving globals: FALSE
[10:32:53.410] 
[10:32:53.410] 
[10:32:53.410] getGlobalsAndPackages() ... DONE
[10:32:53.410] run() for ‘Future’ ...
[10:32:53.411] - state: ‘created’
[10:32:53.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.424]   - Field: ‘node’
[10:32:53.424]   - Field: ‘label’
[10:32:53.424]   - Field: ‘local’
[10:32:53.425]   - Field: ‘owner’
[10:32:53.425]   - Field: ‘envir’
[10:32:53.425]   - Field: ‘workers’
[10:32:53.425]   - Field: ‘packages’
[10:32:53.425]   - Field: ‘gc’
[10:32:53.425]   - Field: ‘conditions’
[10:32:53.425]   - Field: ‘persistent’
[10:32:53.425]   - Field: ‘expr’
[10:32:53.425]   - Field: ‘uuid’
[10:32:53.425]   - Field: ‘seed’
[10:32:53.426]   - Field: ‘version’
[10:32:53.426]   - Field: ‘result’
[10:32:53.426]   - Field: ‘asynchronous’
[10:32:53.426]   - Field: ‘calls’
[10:32:53.426]   - Field: ‘globals’
[10:32:53.426]   - Field: ‘stdout’
[10:32:53.426]   - Field: ‘earlySignal’
[10:32:53.426]   - Field: ‘lazy’
[10:32:53.426]   - Field: ‘state’
[10:32:53.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.426] - Launch lazy future ...
[10:32:53.427] Packages needed by the future expression (n = 0): <none>
[10:32:53.427] Packages needed by future strategies (n = 0): <none>
[10:32:53.427] {
[10:32:53.427]     {
[10:32:53.427]         {
[10:32:53.427]             ...future.startTime <- base::Sys.time()
[10:32:53.427]             {
[10:32:53.427]                 {
[10:32:53.427]                   {
[10:32:53.427]                     {
[10:32:53.427]                       base::local({
[10:32:53.427]                         has_future <- base::requireNamespace("future", 
[10:32:53.427]                           quietly = TRUE)
[10:32:53.427]                         if (has_future) {
[10:32:53.427]                           ns <- base::getNamespace("future")
[10:32:53.427]                           version <- ns[[".package"]][["version"]]
[10:32:53.427]                           if (is.null(version)) 
[10:32:53.427]                             version <- utils::packageVersion("future")
[10:32:53.427]                         }
[10:32:53.427]                         else {
[10:32:53.427]                           version <- NULL
[10:32:53.427]                         }
[10:32:53.427]                         if (!has_future || version < "1.8.0") {
[10:32:53.427]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.427]                             "", base::R.version$version.string), 
[10:32:53.427]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.427]                               "release", "version")], collapse = " "), 
[10:32:53.427]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.427]                             info)
[10:32:53.427]                           info <- base::paste(info, collapse = "; ")
[10:32:53.427]                           if (!has_future) {
[10:32:53.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.427]                               info)
[10:32:53.427]                           }
[10:32:53.427]                           else {
[10:32:53.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.427]                               info, version)
[10:32:53.427]                           }
[10:32:53.427]                           base::stop(msg)
[10:32:53.427]                         }
[10:32:53.427]                       })
[10:32:53.427]                     }
[10:32:53.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.427]                     base::options(mc.cores = 1L)
[10:32:53.427]                   }
[10:32:53.427]                   ...future.strategy.old <- future::plan("list")
[10:32:53.427]                   options(future.plan = NULL)
[10:32:53.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.427]                 }
[10:32:53.427]                 ...future.workdir <- getwd()
[10:32:53.427]             }
[10:32:53.427]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.427]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.427]         }
[10:32:53.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.427]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.427]             base::names(...future.oldOptions))
[10:32:53.427]     }
[10:32:53.427]     if (FALSE) {
[10:32:53.427]     }
[10:32:53.427]     else {
[10:32:53.427]         if (TRUE) {
[10:32:53.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.427]                 open = "w")
[10:32:53.427]         }
[10:32:53.427]         else {
[10:32:53.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.427]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.427]         }
[10:32:53.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.427]             base::sink(type = "output", split = FALSE)
[10:32:53.427]             base::close(...future.stdout)
[10:32:53.427]         }, add = TRUE)
[10:32:53.427]     }
[10:32:53.427]     ...future.frame <- base::sys.nframe()
[10:32:53.427]     ...future.conditions <- base::list()
[10:32:53.427]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.427]     if (FALSE) {
[10:32:53.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.427]     }
[10:32:53.427]     ...future.result <- base::tryCatch({
[10:32:53.427]         base::withCallingHandlers({
[10:32:53.427]             ...future.value <- base::withVisible(base::local({
[10:32:53.427]                 ...future.makeSendCondition <- base::local({
[10:32:53.427]                   sendCondition <- NULL
[10:32:53.427]                   function(frame = 1L) {
[10:32:53.427]                     if (is.function(sendCondition)) 
[10:32:53.427]                       return(sendCondition)
[10:32:53.427]                     ns <- getNamespace("parallel")
[10:32:53.427]                     if (exists("sendData", mode = "function", 
[10:32:53.427]                       envir = ns)) {
[10:32:53.427]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.427]                         envir = ns)
[10:32:53.427]                       envir <- sys.frame(frame)
[10:32:53.427]                       master <- NULL
[10:32:53.427]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.427]                         !identical(envir, emptyenv())) {
[10:32:53.427]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.427]                           inherits = FALSE)) {
[10:32:53.427]                           master <- get("master", mode = "list", 
[10:32:53.427]                             envir = envir, inherits = FALSE)
[10:32:53.427]                           if (inherits(master, c("SOCKnode", 
[10:32:53.427]                             "SOCK0node"))) {
[10:32:53.427]                             sendCondition <<- function(cond) {
[10:32:53.427]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.427]                                 success = TRUE)
[10:32:53.427]                               parallel_sendData(master, data)
[10:32:53.427]                             }
[10:32:53.427]                             return(sendCondition)
[10:32:53.427]                           }
[10:32:53.427]                         }
[10:32:53.427]                         frame <- frame + 1L
[10:32:53.427]                         envir <- sys.frame(frame)
[10:32:53.427]                       }
[10:32:53.427]                     }
[10:32:53.427]                     sendCondition <<- function(cond) NULL
[10:32:53.427]                   }
[10:32:53.427]                 })
[10:32:53.427]                 withCallingHandlers({
[10:32:53.427]                   {
[10:32:53.427]                     4
[10:32:53.427]                   }
[10:32:53.427]                 }, immediateCondition = function(cond) {
[10:32:53.427]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.427]                   sendCondition(cond)
[10:32:53.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.427]                   {
[10:32:53.427]                     inherits <- base::inherits
[10:32:53.427]                     invokeRestart <- base::invokeRestart
[10:32:53.427]                     is.null <- base::is.null
[10:32:53.427]                     muffled <- FALSE
[10:32:53.427]                     if (inherits(cond, "message")) {
[10:32:53.427]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.427]                       if (muffled) 
[10:32:53.427]                         invokeRestart("muffleMessage")
[10:32:53.427]                     }
[10:32:53.427]                     else if (inherits(cond, "warning")) {
[10:32:53.427]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.427]                       if (muffled) 
[10:32:53.427]                         invokeRestart("muffleWarning")
[10:32:53.427]                     }
[10:32:53.427]                     else if (inherits(cond, "condition")) {
[10:32:53.427]                       if (!is.null(pattern)) {
[10:32:53.427]                         computeRestarts <- base::computeRestarts
[10:32:53.427]                         grepl <- base::grepl
[10:32:53.427]                         restarts <- computeRestarts(cond)
[10:32:53.427]                         for (restart in restarts) {
[10:32:53.427]                           name <- restart$name
[10:32:53.427]                           if (is.null(name)) 
[10:32:53.427]                             next
[10:32:53.427]                           if (!grepl(pattern, name)) 
[10:32:53.427]                             next
[10:32:53.427]                           invokeRestart(restart)
[10:32:53.427]                           muffled <- TRUE
[10:32:53.427]                           break
[10:32:53.427]                         }
[10:32:53.427]                       }
[10:32:53.427]                     }
[10:32:53.427]                     invisible(muffled)
[10:32:53.427]                   }
[10:32:53.427]                   muffleCondition(cond)
[10:32:53.427]                 })
[10:32:53.427]             }))
[10:32:53.427]             future::FutureResult(value = ...future.value$value, 
[10:32:53.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.427]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.427]                     ...future.globalenv.names))
[10:32:53.427]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.427]         }, condition = base::local({
[10:32:53.427]             c <- base::c
[10:32:53.427]             inherits <- base::inherits
[10:32:53.427]             invokeRestart <- base::invokeRestart
[10:32:53.427]             length <- base::length
[10:32:53.427]             list <- base::list
[10:32:53.427]             seq.int <- base::seq.int
[10:32:53.427]             signalCondition <- base::signalCondition
[10:32:53.427]             sys.calls <- base::sys.calls
[10:32:53.427]             `[[` <- base::`[[`
[10:32:53.427]             `+` <- base::`+`
[10:32:53.427]             `<<-` <- base::`<<-`
[10:32:53.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.427]                   3L)]
[10:32:53.427]             }
[10:32:53.427]             function(cond) {
[10:32:53.427]                 is_error <- inherits(cond, "error")
[10:32:53.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.427]                   NULL)
[10:32:53.427]                 if (is_error) {
[10:32:53.427]                   sessionInformation <- function() {
[10:32:53.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.427]                       search = base::search(), system = base::Sys.info())
[10:32:53.427]                   }
[10:32:53.427]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.427]                     cond$call), session = sessionInformation(), 
[10:32:53.427]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.427]                   signalCondition(cond)
[10:32:53.427]                 }
[10:32:53.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.427]                 "immediateCondition"))) {
[10:32:53.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.427]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.427]                   if (TRUE && !signal) {
[10:32:53.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.427]                     {
[10:32:53.427]                       inherits <- base::inherits
[10:32:53.427]                       invokeRestart <- base::invokeRestart
[10:32:53.427]                       is.null <- base::is.null
[10:32:53.427]                       muffled <- FALSE
[10:32:53.427]                       if (inherits(cond, "message")) {
[10:32:53.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.427]                         if (muffled) 
[10:32:53.427]                           invokeRestart("muffleMessage")
[10:32:53.427]                       }
[10:32:53.427]                       else if (inherits(cond, "warning")) {
[10:32:53.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.427]                         if (muffled) 
[10:32:53.427]                           invokeRestart("muffleWarning")
[10:32:53.427]                       }
[10:32:53.427]                       else if (inherits(cond, "condition")) {
[10:32:53.427]                         if (!is.null(pattern)) {
[10:32:53.427]                           computeRestarts <- base::computeRestarts
[10:32:53.427]                           grepl <- base::grepl
[10:32:53.427]                           restarts <- computeRestarts(cond)
[10:32:53.427]                           for (restart in restarts) {
[10:32:53.427]                             name <- restart$name
[10:32:53.427]                             if (is.null(name)) 
[10:32:53.427]                               next
[10:32:53.427]                             if (!grepl(pattern, name)) 
[10:32:53.427]                               next
[10:32:53.427]                             invokeRestart(restart)
[10:32:53.427]                             muffled <- TRUE
[10:32:53.427]                             break
[10:32:53.427]                           }
[10:32:53.427]                         }
[10:32:53.427]                       }
[10:32:53.427]                       invisible(muffled)
[10:32:53.427]                     }
[10:32:53.427]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.427]                   }
[10:32:53.427]                 }
[10:32:53.427]                 else {
[10:32:53.427]                   if (TRUE) {
[10:32:53.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.427]                     {
[10:32:53.427]                       inherits <- base::inherits
[10:32:53.427]                       invokeRestart <- base::invokeRestart
[10:32:53.427]                       is.null <- base::is.null
[10:32:53.427]                       muffled <- FALSE
[10:32:53.427]                       if (inherits(cond, "message")) {
[10:32:53.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.427]                         if (muffled) 
[10:32:53.427]                           invokeRestart("muffleMessage")
[10:32:53.427]                       }
[10:32:53.427]                       else if (inherits(cond, "warning")) {
[10:32:53.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.427]                         if (muffled) 
[10:32:53.427]                           invokeRestart("muffleWarning")
[10:32:53.427]                       }
[10:32:53.427]                       else if (inherits(cond, "condition")) {
[10:32:53.427]                         if (!is.null(pattern)) {
[10:32:53.427]                           computeRestarts <- base::computeRestarts
[10:32:53.427]                           grepl <- base::grepl
[10:32:53.427]                           restarts <- computeRestarts(cond)
[10:32:53.427]                           for (restart in restarts) {
[10:32:53.427]                             name <- restart$name
[10:32:53.427]                             if (is.null(name)) 
[10:32:53.427]                               next
[10:32:53.427]                             if (!grepl(pattern, name)) 
[10:32:53.427]                               next
[10:32:53.427]                             invokeRestart(restart)
[10:32:53.427]                             muffled <- TRUE
[10:32:53.427]                             break
[10:32:53.427]                           }
[10:32:53.427]                         }
[10:32:53.427]                       }
[10:32:53.427]                       invisible(muffled)
[10:32:53.427]                     }
[10:32:53.427]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.427]                   }
[10:32:53.427]                 }
[10:32:53.427]             }
[10:32:53.427]         }))
[10:32:53.427]     }, error = function(ex) {
[10:32:53.427]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.427]                 ...future.rng), started = ...future.startTime, 
[10:32:53.427]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.427]             version = "1.8"), class = "FutureResult")
[10:32:53.427]     }, finally = {
[10:32:53.427]         if (!identical(...future.workdir, getwd())) 
[10:32:53.427]             setwd(...future.workdir)
[10:32:53.427]         {
[10:32:53.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.427]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.427]             }
[10:32:53.427]             base::options(...future.oldOptions)
[10:32:53.427]             if (.Platform$OS.type == "windows") {
[10:32:53.427]                 old_names <- names(...future.oldEnvVars)
[10:32:53.427]                 envs <- base::Sys.getenv()
[10:32:53.427]                 names <- names(envs)
[10:32:53.427]                 common <- intersect(names, old_names)
[10:32:53.427]                 added <- setdiff(names, old_names)
[10:32:53.427]                 removed <- setdiff(old_names, names)
[10:32:53.427]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.427]                   envs[common]]
[10:32:53.427]                 NAMES <- toupper(changed)
[10:32:53.427]                 args <- list()
[10:32:53.427]                 for (kk in seq_along(NAMES)) {
[10:32:53.427]                   name <- changed[[kk]]
[10:32:53.427]                   NAME <- NAMES[[kk]]
[10:32:53.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.427]                     next
[10:32:53.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.427]                 }
[10:32:53.427]                 NAMES <- toupper(added)
[10:32:53.427]                 for (kk in seq_along(NAMES)) {
[10:32:53.427]                   name <- added[[kk]]
[10:32:53.427]                   NAME <- NAMES[[kk]]
[10:32:53.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.427]                     next
[10:32:53.427]                   args[[name]] <- ""
[10:32:53.427]                 }
[10:32:53.427]                 NAMES <- toupper(removed)
[10:32:53.427]                 for (kk in seq_along(NAMES)) {
[10:32:53.427]                   name <- removed[[kk]]
[10:32:53.427]                   NAME <- NAMES[[kk]]
[10:32:53.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.427]                     next
[10:32:53.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.427]                 }
[10:32:53.427]                 if (length(args) > 0) 
[10:32:53.427]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.427]             }
[10:32:53.427]             else {
[10:32:53.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.427]             }
[10:32:53.427]             {
[10:32:53.427]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.427]                   0L) {
[10:32:53.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.427]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.427]                   base::options(opts)
[10:32:53.427]                 }
[10:32:53.427]                 {
[10:32:53.427]                   {
[10:32:53.427]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.427]                     NULL
[10:32:53.427]                   }
[10:32:53.427]                   options(future.plan = NULL)
[10:32:53.427]                   if (is.na(NA_character_)) 
[10:32:53.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.427]                     .init = FALSE)
[10:32:53.427]                 }
[10:32:53.427]             }
[10:32:53.427]         }
[10:32:53.427]     })
[10:32:53.427]     if (TRUE) {
[10:32:53.427]         base::sink(type = "output", split = FALSE)
[10:32:53.427]         if (TRUE) {
[10:32:53.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.427]         }
[10:32:53.427]         else {
[10:32:53.427]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.427]         }
[10:32:53.427]         base::close(...future.stdout)
[10:32:53.427]         ...future.stdout <- NULL
[10:32:53.427]     }
[10:32:53.427]     ...future.result$conditions <- ...future.conditions
[10:32:53.427]     ...future.result$finished <- base::Sys.time()
[10:32:53.427]     ...future.result
[10:32:53.427] }
[10:32:53.429] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:53.440] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.440] - Validating connection of MultisessionFuture
[10:32:53.440] - received message: FutureResult
[10:32:53.441] - Received FutureResult
[10:32:53.441] - Erased future from FutureRegistry
[10:32:53.441] result() for ClusterFuture ...
[10:32:53.441] - result already collected: FutureResult
[10:32:53.441] result() for ClusterFuture ... done
[10:32:53.441] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.441] result() for ClusterFuture ...
[10:32:53.441] - result already collected: FutureResult
[10:32:53.441] result() for ClusterFuture ... done
[10:32:53.441] result() for ClusterFuture ...
[10:32:53.442] - result already collected: FutureResult
[10:32:53.442] result() for ClusterFuture ... done
[10:32:53.443] MultisessionFuture started
[10:32:53.443] - Launch lazy future ... done
[10:32:53.443] run() for ‘MultisessionFuture’ ... done
<environment: 0x5652d0c2d910> 
<environment: 0x5652d23b02e8> 
[10:32:53.444] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.444] - Validating connection of MultisessionFuture
[10:32:53.445] - received message: FutureResult
[10:32:53.445] - Received FutureResult
[10:32:53.445] - Erased future from FutureRegistry
[10:32:53.445] result() for ClusterFuture ...
[10:32:53.445] - result already collected: FutureResult
[10:32:53.445] result() for ClusterFuture ... done
[10:32:53.445] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.446] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.446] - Validating connection of MultisessionFuture
[10:32:53.446] - received message: FutureResult
[10:32:53.446] - Received FutureResult
[10:32:53.446] - Erased future from FutureRegistry
[10:32:53.446] result() for ClusterFuture ...
[10:32:53.446] - result already collected: FutureResult
[10:32:53.446] result() for ClusterFuture ... done
[10:32:53.447] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:53.448] resolve() on environment ...
[10:32:53.448]  recursive: 0
[10:32:53.448]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:53.448] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.448] - nx: 4
[10:32:53.449] - relay: TRUE
[10:32:53.449] - stdout: TRUE
[10:32:53.449] - signal: TRUE
[10:32:53.449] - resignal: FALSE
[10:32:53.449] - force: TRUE
[10:32:53.449] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.449] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.449]  - until=2
[10:32:53.449]  - relaying element #2
[10:32:53.449] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.449] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.450] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.450]  length: 3 (resolved future 1)
[10:32:53.450] Future #2
[10:32:53.450] result() for ClusterFuture ...
[10:32:53.450] - result already collected: FutureResult
[10:32:53.450] result() for ClusterFuture ... done
[10:32:53.450] result() for ClusterFuture ...
[10:32:53.450] - result already collected: FutureResult
[10:32:53.450] result() for ClusterFuture ... done
[10:32:53.450] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:53.450] - nx: 4
[10:32:53.451] - relay: TRUE
[10:32:53.451] - stdout: TRUE
[10:32:53.451] - signal: TRUE
[10:32:53.451] - resignal: FALSE
[10:32:53.451] - force: TRUE
[10:32:53.451] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.451] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.451]  - until=2
[10:32:53.451]  - relaying element #2
[10:32:53.451] result() for ClusterFuture ...
[10:32:53.451] - result already collected: FutureResult
[10:32:53.451] result() for ClusterFuture ... done
[10:32:53.452] result() for ClusterFuture ...
[10:32:53.452] - result already collected: FutureResult
[10:32:53.452] result() for ClusterFuture ... done
[10:32:53.452] result() for ClusterFuture ...
[10:32:53.452] - result already collected: FutureResult
[10:32:53.452] result() for ClusterFuture ... done
[10:32:53.452] result() for ClusterFuture ...
[10:32:53.452] - result already collected: FutureResult
[10:32:53.452] result() for ClusterFuture ... done
[10:32:53.452] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.452] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.453] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:53.453]  length: 2 (resolved future 2)
[10:32:53.453] Future #3
[10:32:53.453] result() for ClusterFuture ...
[10:32:53.453] - result already collected: FutureResult
[10:32:53.453] result() for ClusterFuture ... done
[10:32:53.453] result() for ClusterFuture ...
[10:32:53.453] - result already collected: FutureResult
[10:32:53.453] result() for ClusterFuture ... done
[10:32:53.453] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:53.453] - nx: 4
[10:32:53.454] - relay: TRUE
[10:32:53.454] - stdout: TRUE
[10:32:53.454] - signal: TRUE
[10:32:53.454] - resignal: FALSE
[10:32:53.454] - force: TRUE
[10:32:53.454] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.454] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.454]  - until=3
[10:32:53.454]  - relaying element #3
[10:32:53.454] result() for ClusterFuture ...
[10:32:53.454] - result already collected: FutureResult
[10:32:53.454] result() for ClusterFuture ... done
[10:32:53.455] result() for ClusterFuture ...
[10:32:53.455] - result already collected: FutureResult
[10:32:53.455] result() for ClusterFuture ... done
[10:32:53.455] result() for ClusterFuture ...
[10:32:53.455] - result already collected: FutureResult
[10:32:53.455] result() for ClusterFuture ... done
[10:32:53.455] result() for ClusterFuture ...
[10:32:53.455] - result already collected: FutureResult
[10:32:53.455] result() for ClusterFuture ... done
[10:32:53.455] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.455] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.456] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:53.456]  length: 1 (resolved future 3)
[10:32:53.456] Future #4
[10:32:53.456] result() for ClusterFuture ...
[10:32:53.456] - result already collected: FutureResult
[10:32:53.456] result() for ClusterFuture ... done
[10:32:53.456] result() for ClusterFuture ...
[10:32:53.456] - result already collected: FutureResult
[10:32:53.456] result() for ClusterFuture ... done
[10:32:53.456] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:53.456] - nx: 4
[10:32:53.457] - relay: TRUE
[10:32:53.457] - stdout: TRUE
[10:32:53.457] - signal: TRUE
[10:32:53.457] - resignal: FALSE
[10:32:53.457] - force: TRUE
[10:32:53.457] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.457] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.457]  - until=4
[10:32:53.457]  - relaying element #4
[10:32:53.457] result() for ClusterFuture ...
[10:32:53.457] - result already collected: FutureResult
[10:32:53.457] result() for ClusterFuture ... done
[10:32:53.458] result() for ClusterFuture ...
[10:32:53.458] - result already collected: FutureResult
[10:32:53.458] result() for ClusterFuture ... done
[10:32:53.458] result() for ClusterFuture ...
[10:32:53.458] - result already collected: FutureResult
[10:32:53.458] result() for ClusterFuture ... done
[10:32:53.458] result() for ClusterFuture ...
[10:32:53.458] - result already collected: FutureResult
[10:32:53.458] result() for ClusterFuture ... done
[10:32:53.458] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.458] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.459] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:53.459]  length: 0 (resolved future 4)
[10:32:53.459] Relaying remaining futures
[10:32:53.459] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.459] - nx: 4
[10:32:53.459] - relay: TRUE
[10:32:53.459] - stdout: TRUE
[10:32:53.459] - signal: TRUE
[10:32:53.459] - resignal: FALSE
[10:32:53.459] - force: TRUE
[10:32:53.459] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.459] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:53.460] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.460] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.460] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.460] resolve() on environment ... DONE
[10:32:53.460] result() for ClusterFuture ...
[10:32:53.460] - result already collected: FutureResult
[10:32:53.460] result() for ClusterFuture ... done
[10:32:53.460] result() for ClusterFuture ...
[10:32:53.460] - result already collected: FutureResult
[10:32:53.460] result() for ClusterFuture ... done
[10:32:53.460] result() for ClusterFuture ...
[10:32:53.461] - result already collected: FutureResult
[10:32:53.461] result() for ClusterFuture ... done
[10:32:53.461] result() for ClusterFuture ...
[10:32:53.461] - result already collected: FutureResult
[10:32:53.461] result() for ClusterFuture ... done
[10:32:53.461] result() for ClusterFuture ...
[10:32:53.461] - result already collected: FutureResult
[10:32:53.461] result() for ClusterFuture ... done
[10:32:53.461] result() for ClusterFuture ...
[10:32:53.461] - result already collected: FutureResult
[10:32:53.461] result() for ClusterFuture ... done
<environment: 0x5652d25a2948> 
Dimensions: c(2, 1, 3, 1)
[10:32:53.462] getGlobalsAndPackages() ...
[10:32:53.462] Searching for globals...
[10:32:53.462] 
[10:32:53.462] Searching for globals ... DONE
[10:32:53.462] - globals: [0] <none>
[10:32:53.463] getGlobalsAndPackages() ... DONE
[10:32:53.463] run() for ‘Future’ ...
[10:32:53.463] - state: ‘created’
[10:32:53.463] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.477] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.479]   - Field: ‘node’
[10:32:53.479]   - Field: ‘label’
[10:32:53.479]   - Field: ‘local’
[10:32:53.480]   - Field: ‘owner’
[10:32:53.480]   - Field: ‘envir’
[10:32:53.480]   - Field: ‘workers’
[10:32:53.480]   - Field: ‘packages’
[10:32:53.480]   - Field: ‘gc’
[10:32:53.480]   - Field: ‘conditions’
[10:32:53.480]   - Field: ‘persistent’
[10:32:53.480]   - Field: ‘expr’
[10:32:53.480]   - Field: ‘uuid’
[10:32:53.480]   - Field: ‘seed’
[10:32:53.481]   - Field: ‘version’
[10:32:53.481]   - Field: ‘result’
[10:32:53.481]   - Field: ‘asynchronous’
[10:32:53.481]   - Field: ‘calls’
[10:32:53.481]   - Field: ‘globals’
[10:32:53.481]   - Field: ‘stdout’
[10:32:53.481]   - Field: ‘earlySignal’
[10:32:53.481]   - Field: ‘lazy’
[10:32:53.481]   - Field: ‘state’
[10:32:53.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.481] - Launch lazy future ...
[10:32:53.482] Packages needed by the future expression (n = 0): <none>
[10:32:53.482] Packages needed by future strategies (n = 0): <none>
[10:32:53.482] {
[10:32:53.482]     {
[10:32:53.482]         {
[10:32:53.482]             ...future.startTime <- base::Sys.time()
[10:32:53.482]             {
[10:32:53.482]                 {
[10:32:53.482]                   {
[10:32:53.482]                     {
[10:32:53.482]                       base::local({
[10:32:53.482]                         has_future <- base::requireNamespace("future", 
[10:32:53.482]                           quietly = TRUE)
[10:32:53.482]                         if (has_future) {
[10:32:53.482]                           ns <- base::getNamespace("future")
[10:32:53.482]                           version <- ns[[".package"]][["version"]]
[10:32:53.482]                           if (is.null(version)) 
[10:32:53.482]                             version <- utils::packageVersion("future")
[10:32:53.482]                         }
[10:32:53.482]                         else {
[10:32:53.482]                           version <- NULL
[10:32:53.482]                         }
[10:32:53.482]                         if (!has_future || version < "1.8.0") {
[10:32:53.482]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.482]                             "", base::R.version$version.string), 
[10:32:53.482]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.482]                               "release", "version")], collapse = " "), 
[10:32:53.482]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.482]                             info)
[10:32:53.482]                           info <- base::paste(info, collapse = "; ")
[10:32:53.482]                           if (!has_future) {
[10:32:53.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.482]                               info)
[10:32:53.482]                           }
[10:32:53.482]                           else {
[10:32:53.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.482]                               info, version)
[10:32:53.482]                           }
[10:32:53.482]                           base::stop(msg)
[10:32:53.482]                         }
[10:32:53.482]                       })
[10:32:53.482]                     }
[10:32:53.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.482]                     base::options(mc.cores = 1L)
[10:32:53.482]                   }
[10:32:53.482]                   ...future.strategy.old <- future::plan("list")
[10:32:53.482]                   options(future.plan = NULL)
[10:32:53.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.482]                 }
[10:32:53.482]                 ...future.workdir <- getwd()
[10:32:53.482]             }
[10:32:53.482]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.482]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.482]         }
[10:32:53.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.482]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.482]             base::names(...future.oldOptions))
[10:32:53.482]     }
[10:32:53.482]     if (FALSE) {
[10:32:53.482]     }
[10:32:53.482]     else {
[10:32:53.482]         if (TRUE) {
[10:32:53.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.482]                 open = "w")
[10:32:53.482]         }
[10:32:53.482]         else {
[10:32:53.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.482]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.482]         }
[10:32:53.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.482]             base::sink(type = "output", split = FALSE)
[10:32:53.482]             base::close(...future.stdout)
[10:32:53.482]         }, add = TRUE)
[10:32:53.482]     }
[10:32:53.482]     ...future.frame <- base::sys.nframe()
[10:32:53.482]     ...future.conditions <- base::list()
[10:32:53.482]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.482]     if (FALSE) {
[10:32:53.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.482]     }
[10:32:53.482]     ...future.result <- base::tryCatch({
[10:32:53.482]         base::withCallingHandlers({
[10:32:53.482]             ...future.value <- base::withVisible(base::local({
[10:32:53.482]                 ...future.makeSendCondition <- base::local({
[10:32:53.482]                   sendCondition <- NULL
[10:32:53.482]                   function(frame = 1L) {
[10:32:53.482]                     if (is.function(sendCondition)) 
[10:32:53.482]                       return(sendCondition)
[10:32:53.482]                     ns <- getNamespace("parallel")
[10:32:53.482]                     if (exists("sendData", mode = "function", 
[10:32:53.482]                       envir = ns)) {
[10:32:53.482]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.482]                         envir = ns)
[10:32:53.482]                       envir <- sys.frame(frame)
[10:32:53.482]                       master <- NULL
[10:32:53.482]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.482]                         !identical(envir, emptyenv())) {
[10:32:53.482]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.482]                           inherits = FALSE)) {
[10:32:53.482]                           master <- get("master", mode = "list", 
[10:32:53.482]                             envir = envir, inherits = FALSE)
[10:32:53.482]                           if (inherits(master, c("SOCKnode", 
[10:32:53.482]                             "SOCK0node"))) {
[10:32:53.482]                             sendCondition <<- function(cond) {
[10:32:53.482]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.482]                                 success = TRUE)
[10:32:53.482]                               parallel_sendData(master, data)
[10:32:53.482]                             }
[10:32:53.482]                             return(sendCondition)
[10:32:53.482]                           }
[10:32:53.482]                         }
[10:32:53.482]                         frame <- frame + 1L
[10:32:53.482]                         envir <- sys.frame(frame)
[10:32:53.482]                       }
[10:32:53.482]                     }
[10:32:53.482]                     sendCondition <<- function(cond) NULL
[10:32:53.482]                   }
[10:32:53.482]                 })
[10:32:53.482]                 withCallingHandlers({
[10:32:53.482]                   2
[10:32:53.482]                 }, immediateCondition = function(cond) {
[10:32:53.482]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.482]                   sendCondition(cond)
[10:32:53.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.482]                   {
[10:32:53.482]                     inherits <- base::inherits
[10:32:53.482]                     invokeRestart <- base::invokeRestart
[10:32:53.482]                     is.null <- base::is.null
[10:32:53.482]                     muffled <- FALSE
[10:32:53.482]                     if (inherits(cond, "message")) {
[10:32:53.482]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.482]                       if (muffled) 
[10:32:53.482]                         invokeRestart("muffleMessage")
[10:32:53.482]                     }
[10:32:53.482]                     else if (inherits(cond, "warning")) {
[10:32:53.482]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.482]                       if (muffled) 
[10:32:53.482]                         invokeRestart("muffleWarning")
[10:32:53.482]                     }
[10:32:53.482]                     else if (inherits(cond, "condition")) {
[10:32:53.482]                       if (!is.null(pattern)) {
[10:32:53.482]                         computeRestarts <- base::computeRestarts
[10:32:53.482]                         grepl <- base::grepl
[10:32:53.482]                         restarts <- computeRestarts(cond)
[10:32:53.482]                         for (restart in restarts) {
[10:32:53.482]                           name <- restart$name
[10:32:53.482]                           if (is.null(name)) 
[10:32:53.482]                             next
[10:32:53.482]                           if (!grepl(pattern, name)) 
[10:32:53.482]                             next
[10:32:53.482]                           invokeRestart(restart)
[10:32:53.482]                           muffled <- TRUE
[10:32:53.482]                           break
[10:32:53.482]                         }
[10:32:53.482]                       }
[10:32:53.482]                     }
[10:32:53.482]                     invisible(muffled)
[10:32:53.482]                   }
[10:32:53.482]                   muffleCondition(cond)
[10:32:53.482]                 })
[10:32:53.482]             }))
[10:32:53.482]             future::FutureResult(value = ...future.value$value, 
[10:32:53.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.482]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.482]                     ...future.globalenv.names))
[10:32:53.482]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.482]         }, condition = base::local({
[10:32:53.482]             c <- base::c
[10:32:53.482]             inherits <- base::inherits
[10:32:53.482]             invokeRestart <- base::invokeRestart
[10:32:53.482]             length <- base::length
[10:32:53.482]             list <- base::list
[10:32:53.482]             seq.int <- base::seq.int
[10:32:53.482]             signalCondition <- base::signalCondition
[10:32:53.482]             sys.calls <- base::sys.calls
[10:32:53.482]             `[[` <- base::`[[`
[10:32:53.482]             `+` <- base::`+`
[10:32:53.482]             `<<-` <- base::`<<-`
[10:32:53.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.482]                   3L)]
[10:32:53.482]             }
[10:32:53.482]             function(cond) {
[10:32:53.482]                 is_error <- inherits(cond, "error")
[10:32:53.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.482]                   NULL)
[10:32:53.482]                 if (is_error) {
[10:32:53.482]                   sessionInformation <- function() {
[10:32:53.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.482]                       search = base::search(), system = base::Sys.info())
[10:32:53.482]                   }
[10:32:53.482]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.482]                     cond$call), session = sessionInformation(), 
[10:32:53.482]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.482]                   signalCondition(cond)
[10:32:53.482]                 }
[10:32:53.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.482]                 "immediateCondition"))) {
[10:32:53.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.482]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.482]                   if (TRUE && !signal) {
[10:32:53.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.482]                     {
[10:32:53.482]                       inherits <- base::inherits
[10:32:53.482]                       invokeRestart <- base::invokeRestart
[10:32:53.482]                       is.null <- base::is.null
[10:32:53.482]                       muffled <- FALSE
[10:32:53.482]                       if (inherits(cond, "message")) {
[10:32:53.482]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.482]                         if (muffled) 
[10:32:53.482]                           invokeRestart("muffleMessage")
[10:32:53.482]                       }
[10:32:53.482]                       else if (inherits(cond, "warning")) {
[10:32:53.482]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.482]                         if (muffled) 
[10:32:53.482]                           invokeRestart("muffleWarning")
[10:32:53.482]                       }
[10:32:53.482]                       else if (inherits(cond, "condition")) {
[10:32:53.482]                         if (!is.null(pattern)) {
[10:32:53.482]                           computeRestarts <- base::computeRestarts
[10:32:53.482]                           grepl <- base::grepl
[10:32:53.482]                           restarts <- computeRestarts(cond)
[10:32:53.482]                           for (restart in restarts) {
[10:32:53.482]                             name <- restart$name
[10:32:53.482]                             if (is.null(name)) 
[10:32:53.482]                               next
[10:32:53.482]                             if (!grepl(pattern, name)) 
[10:32:53.482]                               next
[10:32:53.482]                             invokeRestart(restart)
[10:32:53.482]                             muffled <- TRUE
[10:32:53.482]                             break
[10:32:53.482]                           }
[10:32:53.482]                         }
[10:32:53.482]                       }
[10:32:53.482]                       invisible(muffled)
[10:32:53.482]                     }
[10:32:53.482]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.482]                   }
[10:32:53.482]                 }
[10:32:53.482]                 else {
[10:32:53.482]                   if (TRUE) {
[10:32:53.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.482]                     {
[10:32:53.482]                       inherits <- base::inherits
[10:32:53.482]                       invokeRestart <- base::invokeRestart
[10:32:53.482]                       is.null <- base::is.null
[10:32:53.482]                       muffled <- FALSE
[10:32:53.482]                       if (inherits(cond, "message")) {
[10:32:53.482]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.482]                         if (muffled) 
[10:32:53.482]                           invokeRestart("muffleMessage")
[10:32:53.482]                       }
[10:32:53.482]                       else if (inherits(cond, "warning")) {
[10:32:53.482]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.482]                         if (muffled) 
[10:32:53.482]                           invokeRestart("muffleWarning")
[10:32:53.482]                       }
[10:32:53.482]                       else if (inherits(cond, "condition")) {
[10:32:53.482]                         if (!is.null(pattern)) {
[10:32:53.482]                           computeRestarts <- base::computeRestarts
[10:32:53.482]                           grepl <- base::grepl
[10:32:53.482]                           restarts <- computeRestarts(cond)
[10:32:53.482]                           for (restart in restarts) {
[10:32:53.482]                             name <- restart$name
[10:32:53.482]                             if (is.null(name)) 
[10:32:53.482]                               next
[10:32:53.482]                             if (!grepl(pattern, name)) 
[10:32:53.482]                               next
[10:32:53.482]                             invokeRestart(restart)
[10:32:53.482]                             muffled <- TRUE
[10:32:53.482]                             break
[10:32:53.482]                           }
[10:32:53.482]                         }
[10:32:53.482]                       }
[10:32:53.482]                       invisible(muffled)
[10:32:53.482]                     }
[10:32:53.482]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.482]                   }
[10:32:53.482]                 }
[10:32:53.482]             }
[10:32:53.482]         }))
[10:32:53.482]     }, error = function(ex) {
[10:32:53.482]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.482]                 ...future.rng), started = ...future.startTime, 
[10:32:53.482]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.482]             version = "1.8"), class = "FutureResult")
[10:32:53.482]     }, finally = {
[10:32:53.482]         if (!identical(...future.workdir, getwd())) 
[10:32:53.482]             setwd(...future.workdir)
[10:32:53.482]         {
[10:32:53.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.482]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.482]             }
[10:32:53.482]             base::options(...future.oldOptions)
[10:32:53.482]             if (.Platform$OS.type == "windows") {
[10:32:53.482]                 old_names <- names(...future.oldEnvVars)
[10:32:53.482]                 envs <- base::Sys.getenv()
[10:32:53.482]                 names <- names(envs)
[10:32:53.482]                 common <- intersect(names, old_names)
[10:32:53.482]                 added <- setdiff(names, old_names)
[10:32:53.482]                 removed <- setdiff(old_names, names)
[10:32:53.482]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.482]                   envs[common]]
[10:32:53.482]                 NAMES <- toupper(changed)
[10:32:53.482]                 args <- list()
[10:32:53.482]                 for (kk in seq_along(NAMES)) {
[10:32:53.482]                   name <- changed[[kk]]
[10:32:53.482]                   NAME <- NAMES[[kk]]
[10:32:53.482]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.482]                     next
[10:32:53.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.482]                 }
[10:32:53.482]                 NAMES <- toupper(added)
[10:32:53.482]                 for (kk in seq_along(NAMES)) {
[10:32:53.482]                   name <- added[[kk]]
[10:32:53.482]                   NAME <- NAMES[[kk]]
[10:32:53.482]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.482]                     next
[10:32:53.482]                   args[[name]] <- ""
[10:32:53.482]                 }
[10:32:53.482]                 NAMES <- toupper(removed)
[10:32:53.482]                 for (kk in seq_along(NAMES)) {
[10:32:53.482]                   name <- removed[[kk]]
[10:32:53.482]                   NAME <- NAMES[[kk]]
[10:32:53.482]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.482]                     next
[10:32:53.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.482]                 }
[10:32:53.482]                 if (length(args) > 0) 
[10:32:53.482]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.482]             }
[10:32:53.482]             else {
[10:32:53.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.482]             }
[10:32:53.482]             {
[10:32:53.482]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.482]                   0L) {
[10:32:53.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.482]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.482]                   base::options(opts)
[10:32:53.482]                 }
[10:32:53.482]                 {
[10:32:53.482]                   {
[10:32:53.482]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.482]                     NULL
[10:32:53.482]                   }
[10:32:53.482]                   options(future.plan = NULL)
[10:32:53.482]                   if (is.na(NA_character_)) 
[10:32:53.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.482]                     .init = FALSE)
[10:32:53.482]                 }
[10:32:53.482]             }
[10:32:53.482]         }
[10:32:53.482]     })
[10:32:53.482]     if (TRUE) {
[10:32:53.482]         base::sink(type = "output", split = FALSE)
[10:32:53.482]         if (TRUE) {
[10:32:53.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.482]         }
[10:32:53.482]         else {
[10:32:53.482]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.482]         }
[10:32:53.482]         base::close(...future.stdout)
[10:32:53.482]         ...future.stdout <- NULL
[10:32:53.482]     }
[10:32:53.482]     ...future.result$conditions <- ...future.conditions
[10:32:53.482]     ...future.result$finished <- base::Sys.time()
[10:32:53.482]     ...future.result
[10:32:53.482] }
[10:32:53.485] MultisessionFuture started
[10:32:53.485] - Launch lazy future ... done
[10:32:53.485] run() for ‘MultisessionFuture’ ... done
[10:32:53.485] getGlobalsAndPackages() ...
[10:32:53.486] Searching for globals...
[10:32:53.486] 
[10:32:53.486] Searching for globals ... DONE
[10:32:53.486] - globals: [0] <none>
[10:32:53.486] getGlobalsAndPackages() ... DONE
[10:32:53.486] run() for ‘Future’ ...
[10:32:53.486] - state: ‘created’
[10:32:53.487] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.501]   - Field: ‘node’
[10:32:53.501]   - Field: ‘label’
[10:32:53.501]   - Field: ‘local’
[10:32:53.501]   - Field: ‘owner’
[10:32:53.501]   - Field: ‘envir’
[10:32:53.501]   - Field: ‘workers’
[10:32:53.501]   - Field: ‘packages’
[10:32:53.501]   - Field: ‘gc’
[10:32:53.502]   - Field: ‘conditions’
[10:32:53.502]   - Field: ‘persistent’
[10:32:53.502]   - Field: ‘expr’
[10:32:53.502]   - Field: ‘uuid’
[10:32:53.502]   - Field: ‘seed’
[10:32:53.502]   - Field: ‘version’
[10:32:53.502]   - Field: ‘result’
[10:32:53.502]   - Field: ‘asynchronous’
[10:32:53.502]   - Field: ‘calls’
[10:32:53.502]   - Field: ‘globals’
[10:32:53.502]   - Field: ‘stdout’
[10:32:53.503]   - Field: ‘earlySignal’
[10:32:53.503]   - Field: ‘lazy’
[10:32:53.503]   - Field: ‘state’
[10:32:53.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.503] - Launch lazy future ...
[10:32:53.503] Packages needed by the future expression (n = 0): <none>
[10:32:53.503] Packages needed by future strategies (n = 0): <none>
[10:32:53.504] {
[10:32:53.504]     {
[10:32:53.504]         {
[10:32:53.504]             ...future.startTime <- base::Sys.time()
[10:32:53.504]             {
[10:32:53.504]                 {
[10:32:53.504]                   {
[10:32:53.504]                     {
[10:32:53.504]                       base::local({
[10:32:53.504]                         has_future <- base::requireNamespace("future", 
[10:32:53.504]                           quietly = TRUE)
[10:32:53.504]                         if (has_future) {
[10:32:53.504]                           ns <- base::getNamespace("future")
[10:32:53.504]                           version <- ns[[".package"]][["version"]]
[10:32:53.504]                           if (is.null(version)) 
[10:32:53.504]                             version <- utils::packageVersion("future")
[10:32:53.504]                         }
[10:32:53.504]                         else {
[10:32:53.504]                           version <- NULL
[10:32:53.504]                         }
[10:32:53.504]                         if (!has_future || version < "1.8.0") {
[10:32:53.504]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.504]                             "", base::R.version$version.string), 
[10:32:53.504]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.504]                               "release", "version")], collapse = " "), 
[10:32:53.504]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.504]                             info)
[10:32:53.504]                           info <- base::paste(info, collapse = "; ")
[10:32:53.504]                           if (!has_future) {
[10:32:53.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.504]                               info)
[10:32:53.504]                           }
[10:32:53.504]                           else {
[10:32:53.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.504]                               info, version)
[10:32:53.504]                           }
[10:32:53.504]                           base::stop(msg)
[10:32:53.504]                         }
[10:32:53.504]                       })
[10:32:53.504]                     }
[10:32:53.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.504]                     base::options(mc.cores = 1L)
[10:32:53.504]                   }
[10:32:53.504]                   ...future.strategy.old <- future::plan("list")
[10:32:53.504]                   options(future.plan = NULL)
[10:32:53.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.504]                 }
[10:32:53.504]                 ...future.workdir <- getwd()
[10:32:53.504]             }
[10:32:53.504]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.504]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.504]         }
[10:32:53.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.504]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.504]             base::names(...future.oldOptions))
[10:32:53.504]     }
[10:32:53.504]     if (FALSE) {
[10:32:53.504]     }
[10:32:53.504]     else {
[10:32:53.504]         if (TRUE) {
[10:32:53.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.504]                 open = "w")
[10:32:53.504]         }
[10:32:53.504]         else {
[10:32:53.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.504]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.504]         }
[10:32:53.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.504]             base::sink(type = "output", split = FALSE)
[10:32:53.504]             base::close(...future.stdout)
[10:32:53.504]         }, add = TRUE)
[10:32:53.504]     }
[10:32:53.504]     ...future.frame <- base::sys.nframe()
[10:32:53.504]     ...future.conditions <- base::list()
[10:32:53.504]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.504]     if (FALSE) {
[10:32:53.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.504]     }
[10:32:53.504]     ...future.result <- base::tryCatch({
[10:32:53.504]         base::withCallingHandlers({
[10:32:53.504]             ...future.value <- base::withVisible(base::local({
[10:32:53.504]                 ...future.makeSendCondition <- base::local({
[10:32:53.504]                   sendCondition <- NULL
[10:32:53.504]                   function(frame = 1L) {
[10:32:53.504]                     if (is.function(sendCondition)) 
[10:32:53.504]                       return(sendCondition)
[10:32:53.504]                     ns <- getNamespace("parallel")
[10:32:53.504]                     if (exists("sendData", mode = "function", 
[10:32:53.504]                       envir = ns)) {
[10:32:53.504]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.504]                         envir = ns)
[10:32:53.504]                       envir <- sys.frame(frame)
[10:32:53.504]                       master <- NULL
[10:32:53.504]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.504]                         !identical(envir, emptyenv())) {
[10:32:53.504]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.504]                           inherits = FALSE)) {
[10:32:53.504]                           master <- get("master", mode = "list", 
[10:32:53.504]                             envir = envir, inherits = FALSE)
[10:32:53.504]                           if (inherits(master, c("SOCKnode", 
[10:32:53.504]                             "SOCK0node"))) {
[10:32:53.504]                             sendCondition <<- function(cond) {
[10:32:53.504]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.504]                                 success = TRUE)
[10:32:53.504]                               parallel_sendData(master, data)
[10:32:53.504]                             }
[10:32:53.504]                             return(sendCondition)
[10:32:53.504]                           }
[10:32:53.504]                         }
[10:32:53.504]                         frame <- frame + 1L
[10:32:53.504]                         envir <- sys.frame(frame)
[10:32:53.504]                       }
[10:32:53.504]                     }
[10:32:53.504]                     sendCondition <<- function(cond) NULL
[10:32:53.504]                   }
[10:32:53.504]                 })
[10:32:53.504]                 withCallingHandlers({
[10:32:53.504]                   NULL
[10:32:53.504]                 }, immediateCondition = function(cond) {
[10:32:53.504]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.504]                   sendCondition(cond)
[10:32:53.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.504]                   {
[10:32:53.504]                     inherits <- base::inherits
[10:32:53.504]                     invokeRestart <- base::invokeRestart
[10:32:53.504]                     is.null <- base::is.null
[10:32:53.504]                     muffled <- FALSE
[10:32:53.504]                     if (inherits(cond, "message")) {
[10:32:53.504]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.504]                       if (muffled) 
[10:32:53.504]                         invokeRestart("muffleMessage")
[10:32:53.504]                     }
[10:32:53.504]                     else if (inherits(cond, "warning")) {
[10:32:53.504]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.504]                       if (muffled) 
[10:32:53.504]                         invokeRestart("muffleWarning")
[10:32:53.504]                     }
[10:32:53.504]                     else if (inherits(cond, "condition")) {
[10:32:53.504]                       if (!is.null(pattern)) {
[10:32:53.504]                         computeRestarts <- base::computeRestarts
[10:32:53.504]                         grepl <- base::grepl
[10:32:53.504]                         restarts <- computeRestarts(cond)
[10:32:53.504]                         for (restart in restarts) {
[10:32:53.504]                           name <- restart$name
[10:32:53.504]                           if (is.null(name)) 
[10:32:53.504]                             next
[10:32:53.504]                           if (!grepl(pattern, name)) 
[10:32:53.504]                             next
[10:32:53.504]                           invokeRestart(restart)
[10:32:53.504]                           muffled <- TRUE
[10:32:53.504]                           break
[10:32:53.504]                         }
[10:32:53.504]                       }
[10:32:53.504]                     }
[10:32:53.504]                     invisible(muffled)
[10:32:53.504]                   }
[10:32:53.504]                   muffleCondition(cond)
[10:32:53.504]                 })
[10:32:53.504]             }))
[10:32:53.504]             future::FutureResult(value = ...future.value$value, 
[10:32:53.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.504]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.504]                     ...future.globalenv.names))
[10:32:53.504]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.504]         }, condition = base::local({
[10:32:53.504]             c <- base::c
[10:32:53.504]             inherits <- base::inherits
[10:32:53.504]             invokeRestart <- base::invokeRestart
[10:32:53.504]             length <- base::length
[10:32:53.504]             list <- base::list
[10:32:53.504]             seq.int <- base::seq.int
[10:32:53.504]             signalCondition <- base::signalCondition
[10:32:53.504]             sys.calls <- base::sys.calls
[10:32:53.504]             `[[` <- base::`[[`
[10:32:53.504]             `+` <- base::`+`
[10:32:53.504]             `<<-` <- base::`<<-`
[10:32:53.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.504]                   3L)]
[10:32:53.504]             }
[10:32:53.504]             function(cond) {
[10:32:53.504]                 is_error <- inherits(cond, "error")
[10:32:53.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.504]                   NULL)
[10:32:53.504]                 if (is_error) {
[10:32:53.504]                   sessionInformation <- function() {
[10:32:53.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.504]                       search = base::search(), system = base::Sys.info())
[10:32:53.504]                   }
[10:32:53.504]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.504]                     cond$call), session = sessionInformation(), 
[10:32:53.504]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.504]                   signalCondition(cond)
[10:32:53.504]                 }
[10:32:53.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.504]                 "immediateCondition"))) {
[10:32:53.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.504]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.504]                   if (TRUE && !signal) {
[10:32:53.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.504]                     {
[10:32:53.504]                       inherits <- base::inherits
[10:32:53.504]                       invokeRestart <- base::invokeRestart
[10:32:53.504]                       is.null <- base::is.null
[10:32:53.504]                       muffled <- FALSE
[10:32:53.504]                       if (inherits(cond, "message")) {
[10:32:53.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.504]                         if (muffled) 
[10:32:53.504]                           invokeRestart("muffleMessage")
[10:32:53.504]                       }
[10:32:53.504]                       else if (inherits(cond, "warning")) {
[10:32:53.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.504]                         if (muffled) 
[10:32:53.504]                           invokeRestart("muffleWarning")
[10:32:53.504]                       }
[10:32:53.504]                       else if (inherits(cond, "condition")) {
[10:32:53.504]                         if (!is.null(pattern)) {
[10:32:53.504]                           computeRestarts <- base::computeRestarts
[10:32:53.504]                           grepl <- base::grepl
[10:32:53.504]                           restarts <- computeRestarts(cond)
[10:32:53.504]                           for (restart in restarts) {
[10:32:53.504]                             name <- restart$name
[10:32:53.504]                             if (is.null(name)) 
[10:32:53.504]                               next
[10:32:53.504]                             if (!grepl(pattern, name)) 
[10:32:53.504]                               next
[10:32:53.504]                             invokeRestart(restart)
[10:32:53.504]                             muffled <- TRUE
[10:32:53.504]                             break
[10:32:53.504]                           }
[10:32:53.504]                         }
[10:32:53.504]                       }
[10:32:53.504]                       invisible(muffled)
[10:32:53.504]                     }
[10:32:53.504]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.504]                   }
[10:32:53.504]                 }
[10:32:53.504]                 else {
[10:32:53.504]                   if (TRUE) {
[10:32:53.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.504]                     {
[10:32:53.504]                       inherits <- base::inherits
[10:32:53.504]                       invokeRestart <- base::invokeRestart
[10:32:53.504]                       is.null <- base::is.null
[10:32:53.504]                       muffled <- FALSE
[10:32:53.504]                       if (inherits(cond, "message")) {
[10:32:53.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.504]                         if (muffled) 
[10:32:53.504]                           invokeRestart("muffleMessage")
[10:32:53.504]                       }
[10:32:53.504]                       else if (inherits(cond, "warning")) {
[10:32:53.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.504]                         if (muffled) 
[10:32:53.504]                           invokeRestart("muffleWarning")
[10:32:53.504]                       }
[10:32:53.504]                       else if (inherits(cond, "condition")) {
[10:32:53.504]                         if (!is.null(pattern)) {
[10:32:53.504]                           computeRestarts <- base::computeRestarts
[10:32:53.504]                           grepl <- base::grepl
[10:32:53.504]                           restarts <- computeRestarts(cond)
[10:32:53.504]                           for (restart in restarts) {
[10:32:53.504]                             name <- restart$name
[10:32:53.504]                             if (is.null(name)) 
[10:32:53.504]                               next
[10:32:53.504]                             if (!grepl(pattern, name)) 
[10:32:53.504]                               next
[10:32:53.504]                             invokeRestart(restart)
[10:32:53.504]                             muffled <- TRUE
[10:32:53.504]                             break
[10:32:53.504]                           }
[10:32:53.504]                         }
[10:32:53.504]                       }
[10:32:53.504]                       invisible(muffled)
[10:32:53.504]                     }
[10:32:53.504]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.504]                   }
[10:32:53.504]                 }
[10:32:53.504]             }
[10:32:53.504]         }))
[10:32:53.504]     }, error = function(ex) {
[10:32:53.504]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.504]                 ...future.rng), started = ...future.startTime, 
[10:32:53.504]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.504]             version = "1.8"), class = "FutureResult")
[10:32:53.504]     }, finally = {
[10:32:53.504]         if (!identical(...future.workdir, getwd())) 
[10:32:53.504]             setwd(...future.workdir)
[10:32:53.504]         {
[10:32:53.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.504]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.504]             }
[10:32:53.504]             base::options(...future.oldOptions)
[10:32:53.504]             if (.Platform$OS.type == "windows") {
[10:32:53.504]                 old_names <- names(...future.oldEnvVars)
[10:32:53.504]                 envs <- base::Sys.getenv()
[10:32:53.504]                 names <- names(envs)
[10:32:53.504]                 common <- intersect(names, old_names)
[10:32:53.504]                 added <- setdiff(names, old_names)
[10:32:53.504]                 removed <- setdiff(old_names, names)
[10:32:53.504]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.504]                   envs[common]]
[10:32:53.504]                 NAMES <- toupper(changed)
[10:32:53.504]                 args <- list()
[10:32:53.504]                 for (kk in seq_along(NAMES)) {
[10:32:53.504]                   name <- changed[[kk]]
[10:32:53.504]                   NAME <- NAMES[[kk]]
[10:32:53.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.504]                     next
[10:32:53.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.504]                 }
[10:32:53.504]                 NAMES <- toupper(added)
[10:32:53.504]                 for (kk in seq_along(NAMES)) {
[10:32:53.504]                   name <- added[[kk]]
[10:32:53.504]                   NAME <- NAMES[[kk]]
[10:32:53.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.504]                     next
[10:32:53.504]                   args[[name]] <- ""
[10:32:53.504]                 }
[10:32:53.504]                 NAMES <- toupper(removed)
[10:32:53.504]                 for (kk in seq_along(NAMES)) {
[10:32:53.504]                   name <- removed[[kk]]
[10:32:53.504]                   NAME <- NAMES[[kk]]
[10:32:53.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.504]                     next
[10:32:53.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.504]                 }
[10:32:53.504]                 if (length(args) > 0) 
[10:32:53.504]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.504]             }
[10:32:53.504]             else {
[10:32:53.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.504]             }
[10:32:53.504]             {
[10:32:53.504]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.504]                   0L) {
[10:32:53.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.504]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.504]                   base::options(opts)
[10:32:53.504]                 }
[10:32:53.504]                 {
[10:32:53.504]                   {
[10:32:53.504]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.504]                     NULL
[10:32:53.504]                   }
[10:32:53.504]                   options(future.plan = NULL)
[10:32:53.504]                   if (is.na(NA_character_)) 
[10:32:53.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.504]                     .init = FALSE)
[10:32:53.504]                 }
[10:32:53.504]             }
[10:32:53.504]         }
[10:32:53.504]     })
[10:32:53.504]     if (TRUE) {
[10:32:53.504]         base::sink(type = "output", split = FALSE)
[10:32:53.504]         if (TRUE) {
[10:32:53.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.504]         }
[10:32:53.504]         else {
[10:32:53.504]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.504]         }
[10:32:53.504]         base::close(...future.stdout)
[10:32:53.504]         ...future.stdout <- NULL
[10:32:53.504]     }
[10:32:53.504]     ...future.result$conditions <- ...future.conditions
[10:32:53.504]     ...future.result$finished <- base::Sys.time()
[10:32:53.504]     ...future.result
[10:32:53.504] }
[10:32:53.506] MultisessionFuture started
[10:32:53.507] - Launch lazy future ... done
[10:32:53.507] run() for ‘MultisessionFuture’ ... done
[10:32:53.507] getGlobalsAndPackages() ...
[10:32:53.507] Searching for globals...
[10:32:53.508] - globals found: [1] ‘{’
[10:32:53.508] Searching for globals ... DONE
[10:32:53.508] Resolving globals: FALSE
[10:32:53.508] 
[10:32:53.508] 
[10:32:53.508] getGlobalsAndPackages() ... DONE
[10:32:53.509] run() for ‘Future’ ...
[10:32:53.509] - state: ‘created’
[10:32:53.509] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:53.522]   - Field: ‘node’
[10:32:53.522]   - Field: ‘label’
[10:32:53.522]   - Field: ‘local’
[10:32:53.523]   - Field: ‘owner’
[10:32:53.523]   - Field: ‘envir’
[10:32:53.523]   - Field: ‘workers’
[10:32:53.523]   - Field: ‘packages’
[10:32:53.523]   - Field: ‘gc’
[10:32:53.523]   - Field: ‘conditions’
[10:32:53.523]   - Field: ‘persistent’
[10:32:53.523]   - Field: ‘expr’
[10:32:53.523]   - Field: ‘uuid’
[10:32:53.523]   - Field: ‘seed’
[10:32:53.523]   - Field: ‘version’
[10:32:53.524]   - Field: ‘result’
[10:32:53.524]   - Field: ‘asynchronous’
[10:32:53.524]   - Field: ‘calls’
[10:32:53.524]   - Field: ‘globals’
[10:32:53.524]   - Field: ‘stdout’
[10:32:53.524]   - Field: ‘earlySignal’
[10:32:53.524]   - Field: ‘lazy’
[10:32:53.524]   - Field: ‘state’
[10:32:53.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:53.524] - Launch lazy future ...
[10:32:53.525] Packages needed by the future expression (n = 0): <none>
[10:32:53.525] Packages needed by future strategies (n = 0): <none>
[10:32:53.525] {
[10:32:53.525]     {
[10:32:53.525]         {
[10:32:53.525]             ...future.startTime <- base::Sys.time()
[10:32:53.525]             {
[10:32:53.525]                 {
[10:32:53.525]                   {
[10:32:53.525]                     {
[10:32:53.525]                       base::local({
[10:32:53.525]                         has_future <- base::requireNamespace("future", 
[10:32:53.525]                           quietly = TRUE)
[10:32:53.525]                         if (has_future) {
[10:32:53.525]                           ns <- base::getNamespace("future")
[10:32:53.525]                           version <- ns[[".package"]][["version"]]
[10:32:53.525]                           if (is.null(version)) 
[10:32:53.525]                             version <- utils::packageVersion("future")
[10:32:53.525]                         }
[10:32:53.525]                         else {
[10:32:53.525]                           version <- NULL
[10:32:53.525]                         }
[10:32:53.525]                         if (!has_future || version < "1.8.0") {
[10:32:53.525]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.525]                             "", base::R.version$version.string), 
[10:32:53.525]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.525]                               "release", "version")], collapse = " "), 
[10:32:53.525]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.525]                             info)
[10:32:53.525]                           info <- base::paste(info, collapse = "; ")
[10:32:53.525]                           if (!has_future) {
[10:32:53.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.525]                               info)
[10:32:53.525]                           }
[10:32:53.525]                           else {
[10:32:53.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.525]                               info, version)
[10:32:53.525]                           }
[10:32:53.525]                           base::stop(msg)
[10:32:53.525]                         }
[10:32:53.525]                       })
[10:32:53.525]                     }
[10:32:53.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.525]                     base::options(mc.cores = 1L)
[10:32:53.525]                   }
[10:32:53.525]                   ...future.strategy.old <- future::plan("list")
[10:32:53.525]                   options(future.plan = NULL)
[10:32:53.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.525]                 }
[10:32:53.525]                 ...future.workdir <- getwd()
[10:32:53.525]             }
[10:32:53.525]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.525]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.525]         }
[10:32:53.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.525]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.525]             base::names(...future.oldOptions))
[10:32:53.525]     }
[10:32:53.525]     if (FALSE) {
[10:32:53.525]     }
[10:32:53.525]     else {
[10:32:53.525]         if (TRUE) {
[10:32:53.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.525]                 open = "w")
[10:32:53.525]         }
[10:32:53.525]         else {
[10:32:53.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.525]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.525]         }
[10:32:53.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.525]             base::sink(type = "output", split = FALSE)
[10:32:53.525]             base::close(...future.stdout)
[10:32:53.525]         }, add = TRUE)
[10:32:53.525]     }
[10:32:53.525]     ...future.frame <- base::sys.nframe()
[10:32:53.525]     ...future.conditions <- base::list()
[10:32:53.525]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.525]     if (FALSE) {
[10:32:53.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.525]     }
[10:32:53.525]     ...future.result <- base::tryCatch({
[10:32:53.525]         base::withCallingHandlers({
[10:32:53.525]             ...future.value <- base::withVisible(base::local({
[10:32:53.525]                 ...future.makeSendCondition <- base::local({
[10:32:53.525]                   sendCondition <- NULL
[10:32:53.525]                   function(frame = 1L) {
[10:32:53.525]                     if (is.function(sendCondition)) 
[10:32:53.525]                       return(sendCondition)
[10:32:53.525]                     ns <- getNamespace("parallel")
[10:32:53.525]                     if (exists("sendData", mode = "function", 
[10:32:53.525]                       envir = ns)) {
[10:32:53.525]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:53.525]                         envir = ns)
[10:32:53.525]                       envir <- sys.frame(frame)
[10:32:53.525]                       master <- NULL
[10:32:53.525]                       while (!identical(envir, .GlobalEnv) && 
[10:32:53.525]                         !identical(envir, emptyenv())) {
[10:32:53.525]                         if (exists("master", mode = "list", envir = envir, 
[10:32:53.525]                           inherits = FALSE)) {
[10:32:53.525]                           master <- get("master", mode = "list", 
[10:32:53.525]                             envir = envir, inherits = FALSE)
[10:32:53.525]                           if (inherits(master, c("SOCKnode", 
[10:32:53.525]                             "SOCK0node"))) {
[10:32:53.525]                             sendCondition <<- function(cond) {
[10:32:53.525]                               data <- list(type = "VALUE", value = cond, 
[10:32:53.525]                                 success = TRUE)
[10:32:53.525]                               parallel_sendData(master, data)
[10:32:53.525]                             }
[10:32:53.525]                             return(sendCondition)
[10:32:53.525]                           }
[10:32:53.525]                         }
[10:32:53.525]                         frame <- frame + 1L
[10:32:53.525]                         envir <- sys.frame(frame)
[10:32:53.525]                       }
[10:32:53.525]                     }
[10:32:53.525]                     sendCondition <<- function(cond) NULL
[10:32:53.525]                   }
[10:32:53.525]                 })
[10:32:53.525]                 withCallingHandlers({
[10:32:53.525]                   {
[10:32:53.525]                     4
[10:32:53.525]                   }
[10:32:53.525]                 }, immediateCondition = function(cond) {
[10:32:53.525]                   sendCondition <- ...future.makeSendCondition()
[10:32:53.525]                   sendCondition(cond)
[10:32:53.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.525]                   {
[10:32:53.525]                     inherits <- base::inherits
[10:32:53.525]                     invokeRestart <- base::invokeRestart
[10:32:53.525]                     is.null <- base::is.null
[10:32:53.525]                     muffled <- FALSE
[10:32:53.525]                     if (inherits(cond, "message")) {
[10:32:53.525]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.525]                       if (muffled) 
[10:32:53.525]                         invokeRestart("muffleMessage")
[10:32:53.525]                     }
[10:32:53.525]                     else if (inherits(cond, "warning")) {
[10:32:53.525]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.525]                       if (muffled) 
[10:32:53.525]                         invokeRestart("muffleWarning")
[10:32:53.525]                     }
[10:32:53.525]                     else if (inherits(cond, "condition")) {
[10:32:53.525]                       if (!is.null(pattern)) {
[10:32:53.525]                         computeRestarts <- base::computeRestarts
[10:32:53.525]                         grepl <- base::grepl
[10:32:53.525]                         restarts <- computeRestarts(cond)
[10:32:53.525]                         for (restart in restarts) {
[10:32:53.525]                           name <- restart$name
[10:32:53.525]                           if (is.null(name)) 
[10:32:53.525]                             next
[10:32:53.525]                           if (!grepl(pattern, name)) 
[10:32:53.525]                             next
[10:32:53.525]                           invokeRestart(restart)
[10:32:53.525]                           muffled <- TRUE
[10:32:53.525]                           break
[10:32:53.525]                         }
[10:32:53.525]                       }
[10:32:53.525]                     }
[10:32:53.525]                     invisible(muffled)
[10:32:53.525]                   }
[10:32:53.525]                   muffleCondition(cond)
[10:32:53.525]                 })
[10:32:53.525]             }))
[10:32:53.525]             future::FutureResult(value = ...future.value$value, 
[10:32:53.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.525]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.525]                     ...future.globalenv.names))
[10:32:53.525]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.525]         }, condition = base::local({
[10:32:53.525]             c <- base::c
[10:32:53.525]             inherits <- base::inherits
[10:32:53.525]             invokeRestart <- base::invokeRestart
[10:32:53.525]             length <- base::length
[10:32:53.525]             list <- base::list
[10:32:53.525]             seq.int <- base::seq.int
[10:32:53.525]             signalCondition <- base::signalCondition
[10:32:53.525]             sys.calls <- base::sys.calls
[10:32:53.525]             `[[` <- base::`[[`
[10:32:53.525]             `+` <- base::`+`
[10:32:53.525]             `<<-` <- base::`<<-`
[10:32:53.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.525]                   3L)]
[10:32:53.525]             }
[10:32:53.525]             function(cond) {
[10:32:53.525]                 is_error <- inherits(cond, "error")
[10:32:53.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.525]                   NULL)
[10:32:53.525]                 if (is_error) {
[10:32:53.525]                   sessionInformation <- function() {
[10:32:53.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.525]                       search = base::search(), system = base::Sys.info())
[10:32:53.525]                   }
[10:32:53.525]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.525]                     cond$call), session = sessionInformation(), 
[10:32:53.525]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.525]                   signalCondition(cond)
[10:32:53.525]                 }
[10:32:53.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.525]                 "immediateCondition"))) {
[10:32:53.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.525]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.525]                   if (TRUE && !signal) {
[10:32:53.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.525]                     {
[10:32:53.525]                       inherits <- base::inherits
[10:32:53.525]                       invokeRestart <- base::invokeRestart
[10:32:53.525]                       is.null <- base::is.null
[10:32:53.525]                       muffled <- FALSE
[10:32:53.525]                       if (inherits(cond, "message")) {
[10:32:53.525]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.525]                         if (muffled) 
[10:32:53.525]                           invokeRestart("muffleMessage")
[10:32:53.525]                       }
[10:32:53.525]                       else if (inherits(cond, "warning")) {
[10:32:53.525]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.525]                         if (muffled) 
[10:32:53.525]                           invokeRestart("muffleWarning")
[10:32:53.525]                       }
[10:32:53.525]                       else if (inherits(cond, "condition")) {
[10:32:53.525]                         if (!is.null(pattern)) {
[10:32:53.525]                           computeRestarts <- base::computeRestarts
[10:32:53.525]                           grepl <- base::grepl
[10:32:53.525]                           restarts <- computeRestarts(cond)
[10:32:53.525]                           for (restart in restarts) {
[10:32:53.525]                             name <- restart$name
[10:32:53.525]                             if (is.null(name)) 
[10:32:53.525]                               next
[10:32:53.525]                             if (!grepl(pattern, name)) 
[10:32:53.525]                               next
[10:32:53.525]                             invokeRestart(restart)
[10:32:53.525]                             muffled <- TRUE
[10:32:53.525]                             break
[10:32:53.525]                           }
[10:32:53.525]                         }
[10:32:53.525]                       }
[10:32:53.525]                       invisible(muffled)
[10:32:53.525]                     }
[10:32:53.525]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.525]                   }
[10:32:53.525]                 }
[10:32:53.525]                 else {
[10:32:53.525]                   if (TRUE) {
[10:32:53.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.525]                     {
[10:32:53.525]                       inherits <- base::inherits
[10:32:53.525]                       invokeRestart <- base::invokeRestart
[10:32:53.525]                       is.null <- base::is.null
[10:32:53.525]                       muffled <- FALSE
[10:32:53.525]                       if (inherits(cond, "message")) {
[10:32:53.525]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.525]                         if (muffled) 
[10:32:53.525]                           invokeRestart("muffleMessage")
[10:32:53.525]                       }
[10:32:53.525]                       else if (inherits(cond, "warning")) {
[10:32:53.525]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.525]                         if (muffled) 
[10:32:53.525]                           invokeRestart("muffleWarning")
[10:32:53.525]                       }
[10:32:53.525]                       else if (inherits(cond, "condition")) {
[10:32:53.525]                         if (!is.null(pattern)) {
[10:32:53.525]                           computeRestarts <- base::computeRestarts
[10:32:53.525]                           grepl <- base::grepl
[10:32:53.525]                           restarts <- computeRestarts(cond)
[10:32:53.525]                           for (restart in restarts) {
[10:32:53.525]                             name <- restart$name
[10:32:53.525]                             if (is.null(name)) 
[10:32:53.525]                               next
[10:32:53.525]                             if (!grepl(pattern, name)) 
[10:32:53.525]                               next
[10:32:53.525]                             invokeRestart(restart)
[10:32:53.525]                             muffled <- TRUE
[10:32:53.525]                             break
[10:32:53.525]                           }
[10:32:53.525]                         }
[10:32:53.525]                       }
[10:32:53.525]                       invisible(muffled)
[10:32:53.525]                     }
[10:32:53.525]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.525]                   }
[10:32:53.525]                 }
[10:32:53.525]             }
[10:32:53.525]         }))
[10:32:53.525]     }, error = function(ex) {
[10:32:53.525]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.525]                 ...future.rng), started = ...future.startTime, 
[10:32:53.525]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.525]             version = "1.8"), class = "FutureResult")
[10:32:53.525]     }, finally = {
[10:32:53.525]         if (!identical(...future.workdir, getwd())) 
[10:32:53.525]             setwd(...future.workdir)
[10:32:53.525]         {
[10:32:53.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.525]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.525]             }
[10:32:53.525]             base::options(...future.oldOptions)
[10:32:53.525]             if (.Platform$OS.type == "windows") {
[10:32:53.525]                 old_names <- names(...future.oldEnvVars)
[10:32:53.525]                 envs <- base::Sys.getenv()
[10:32:53.525]                 names <- names(envs)
[10:32:53.525]                 common <- intersect(names, old_names)
[10:32:53.525]                 added <- setdiff(names, old_names)
[10:32:53.525]                 removed <- setdiff(old_names, names)
[10:32:53.525]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.525]                   envs[common]]
[10:32:53.525]                 NAMES <- toupper(changed)
[10:32:53.525]                 args <- list()
[10:32:53.525]                 for (kk in seq_along(NAMES)) {
[10:32:53.525]                   name <- changed[[kk]]
[10:32:53.525]                   NAME <- NAMES[[kk]]
[10:32:53.525]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.525]                     next
[10:32:53.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.525]                 }
[10:32:53.525]                 NAMES <- toupper(added)
[10:32:53.525]                 for (kk in seq_along(NAMES)) {
[10:32:53.525]                   name <- added[[kk]]
[10:32:53.525]                   NAME <- NAMES[[kk]]
[10:32:53.525]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.525]                     next
[10:32:53.525]                   args[[name]] <- ""
[10:32:53.525]                 }
[10:32:53.525]                 NAMES <- toupper(removed)
[10:32:53.525]                 for (kk in seq_along(NAMES)) {
[10:32:53.525]                   name <- removed[[kk]]
[10:32:53.525]                   NAME <- NAMES[[kk]]
[10:32:53.525]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.525]                     next
[10:32:53.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.525]                 }
[10:32:53.525]                 if (length(args) > 0) 
[10:32:53.525]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.525]             }
[10:32:53.525]             else {
[10:32:53.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.525]             }
[10:32:53.525]             {
[10:32:53.525]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.525]                   0L) {
[10:32:53.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.525]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.525]                   base::options(opts)
[10:32:53.525]                 }
[10:32:53.525]                 {
[10:32:53.525]                   {
[10:32:53.525]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.525]                     NULL
[10:32:53.525]                   }
[10:32:53.525]                   options(future.plan = NULL)
[10:32:53.525]                   if (is.na(NA_character_)) 
[10:32:53.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.525]                     .init = FALSE)
[10:32:53.525]                 }
[10:32:53.525]             }
[10:32:53.525]         }
[10:32:53.525]     })
[10:32:53.525]     if (TRUE) {
[10:32:53.525]         base::sink(type = "output", split = FALSE)
[10:32:53.525]         if (TRUE) {
[10:32:53.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.525]         }
[10:32:53.525]         else {
[10:32:53.525]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.525]         }
[10:32:53.525]         base::close(...future.stdout)
[10:32:53.525]         ...future.stdout <- NULL
[10:32:53.525]     }
[10:32:53.525]     ...future.result$conditions <- ...future.conditions
[10:32:53.525]     ...future.result$finished <- base::Sys.time()
[10:32:53.525]     ...future.result
[10:32:53.525] }
[10:32:53.527] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:53.538] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.538] - Validating connection of MultisessionFuture
[10:32:53.538] - received message: FutureResult
[10:32:53.538] - Received FutureResult
[10:32:53.538] - Erased future from FutureRegistry
[10:32:53.538] result() for ClusterFuture ...
[10:32:53.539] - result already collected: FutureResult
[10:32:53.539] result() for ClusterFuture ... done
[10:32:53.539] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.539] result() for ClusterFuture ...
[10:32:53.539] - result already collected: FutureResult
[10:32:53.539] result() for ClusterFuture ... done
[10:32:53.539] result() for ClusterFuture ...
[10:32:53.539] - result already collected: FutureResult
[10:32:53.539] result() for ClusterFuture ... done
[10:32:53.540] MultisessionFuture started
[10:32:53.540] - Launch lazy future ... done
[10:32:53.540] run() for ‘MultisessionFuture’ ... done
<environment: 0x5652d2d4a498> 
<environment: 0x5652d032ae10> 
[10:32:53.542] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.542] - Validating connection of MultisessionFuture
[10:32:53.542] - received message: FutureResult
[10:32:53.542] - Received FutureResult
[10:32:53.543] - Erased future from FutureRegistry
[10:32:53.543] result() for ClusterFuture ...
[10:32:53.543] - result already collected: FutureResult
[10:32:53.543] result() for ClusterFuture ... done
[10:32:53.543] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:53.543] receiveMessageFromWorker() for ClusterFuture ...
[10:32:53.544] - Validating connection of MultisessionFuture
[10:32:53.544] - received message: FutureResult
[10:32:53.544] - Received FutureResult
[10:32:53.544] - Erased future from FutureRegistry
[10:32:53.544] result() for ClusterFuture ...
[10:32:53.544] - result already collected: FutureResult
[10:32:53.544] result() for ClusterFuture ... done
[10:32:53.544] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:32:53.545] resolve() on environment ...
[10:32:53.546]  recursive: 0
[10:32:53.546]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:32:53.546] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.546] - nx: 4
[10:32:53.546] - relay: TRUE
[10:32:53.546] - stdout: TRUE
[10:32:53.546] - signal: TRUE
[10:32:53.547] - resignal: FALSE
[10:32:53.547] - force: TRUE
[10:32:53.547] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.547] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.547]  - until=2
[10:32:53.547]  - relaying element #2
[10:32:53.547] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.547] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.547] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.547]  length: 3 (resolved future 1)
[10:32:53.547] Future #2
[10:32:53.548] result() for ClusterFuture ...
[10:32:53.548] - result already collected: FutureResult
[10:32:53.548] result() for ClusterFuture ... done
[10:32:53.548] result() for ClusterFuture ...
[10:32:53.548] - result already collected: FutureResult
[10:32:53.548] result() for ClusterFuture ... done
[10:32:53.548] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:53.548] - nx: 4
[10:32:53.548] - relay: TRUE
[10:32:53.548] - stdout: TRUE
[10:32:53.548] - signal: TRUE
[10:32:53.549] - resignal: FALSE
[10:32:53.549] - force: TRUE
[10:32:53.549] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:32:53.549] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:32:53.549]  - until=2
[10:32:53.549]  - relaying element #2
[10:32:53.549] result() for ClusterFuture ...
[10:32:53.549] - result already collected: FutureResult
[10:32:53.549] result() for ClusterFuture ... done
[10:32:53.549] result() for ClusterFuture ...
[10:32:53.549] - result already collected: FutureResult
[10:32:53.550] result() for ClusterFuture ... done
[10:32:53.550] result() for ClusterFuture ...
[10:32:53.550] - result already collected: FutureResult
[10:32:53.550] result() for ClusterFuture ... done
[10:32:53.550] result() for ClusterFuture ...
[10:32:53.550] - result already collected: FutureResult
[10:32:53.550] result() for ClusterFuture ... done
[10:32:53.550] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.550] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.550] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:53.550]  length: 2 (resolved future 2)
[10:32:53.551] Future #3
[10:32:53.551] result() for ClusterFuture ...
[10:32:53.551] - result already collected: FutureResult
[10:32:53.551] result() for ClusterFuture ... done
[10:32:53.551] result() for ClusterFuture ...
[10:32:53.551] - result already collected: FutureResult
[10:32:53.551] result() for ClusterFuture ... done
[10:32:53.551] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:53.551] - nx: 4
[10:32:53.551] - relay: TRUE
[10:32:53.551] - stdout: TRUE
[10:32:53.552] - signal: TRUE
[10:32:53.552] - resignal: FALSE
[10:32:53.552] - force: TRUE
[10:32:53.552] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:32:53.552] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:32:53.552]  - until=3
[10:32:53.552]  - relaying element #3
[10:32:53.552] result() for ClusterFuture ...
[10:32:53.552] - result already collected: FutureResult
[10:32:53.552] result() for ClusterFuture ... done
[10:32:53.552] result() for ClusterFuture ...
[10:32:53.552] - result already collected: FutureResult
[10:32:53.553] result() for ClusterFuture ... done
[10:32:53.553] result() for ClusterFuture ...
[10:32:53.553] - result already collected: FutureResult
[10:32:53.553] result() for ClusterFuture ... done
[10:32:53.553] result() for ClusterFuture ...
[10:32:53.553] - result already collected: FutureResult
[10:32:53.553] result() for ClusterFuture ... done
[10:32:53.553] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.553] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.553] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:53.553]  length: 1 (resolved future 3)
[10:32:53.554] Future #4
[10:32:53.554] result() for ClusterFuture ...
[10:32:53.554] - result already collected: FutureResult
[10:32:53.554] result() for ClusterFuture ... done
[10:32:53.554] result() for ClusterFuture ...
[10:32:53.554] - result already collected: FutureResult
[10:32:53.554] result() for ClusterFuture ... done
[10:32:53.554] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:53.554] - nx: 4
[10:32:53.554] - relay: TRUE
[10:32:53.554] - stdout: TRUE
[10:32:53.555] - signal: TRUE
[10:32:53.555] - resignal: FALSE
[10:32:53.555] - force: TRUE
[10:32:53.555] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:32:53.555] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:32:53.555]  - until=4
[10:32:53.555]  - relaying element #4
[10:32:53.555] result() for ClusterFuture ...
[10:32:53.555] - result already collected: FutureResult
[10:32:53.555] result() for ClusterFuture ... done
[10:32:53.555] result() for ClusterFuture ...
[10:32:53.555] - result already collected: FutureResult
[10:32:53.556] result() for ClusterFuture ... done
[10:32:53.556] result() for ClusterFuture ...
[10:32:53.556] - result already collected: FutureResult
[10:32:53.556] result() for ClusterFuture ... done
[10:32:53.556] result() for ClusterFuture ...
[10:32:53.556] - result already collected: FutureResult
[10:32:53.556] result() for ClusterFuture ... done
[10:32:53.556] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.556] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.556] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:53.556]  length: 0 (resolved future 4)
[10:32:53.557] Relaying remaining futures
[10:32:53.557] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.557] - nx: 4
[10:32:53.557] - relay: TRUE
[10:32:53.557] - stdout: TRUE
[10:32:53.557] - signal: TRUE
[10:32:53.557] - resignal: FALSE
[10:32:53.557] - force: TRUE
[10:32:53.557] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.557] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:32:53.557] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:32:53.558] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:32:53.558] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.558] resolve() on environment ... DONE
[10:32:53.558] result() for ClusterFuture ...
[10:32:53.558] - result already collected: FutureResult
[10:32:53.558] result() for ClusterFuture ... done
[10:32:53.558] result() for ClusterFuture ...
[10:32:53.558] - result already collected: FutureResult
[10:32:53.558] result() for ClusterFuture ... done
[10:32:53.558] result() for ClusterFuture ...
[10:32:53.558] - result already collected: FutureResult
[10:32:53.558] result() for ClusterFuture ... done
[10:32:53.559] result() for ClusterFuture ...
[10:32:53.559] - result already collected: FutureResult
[10:32:53.559] result() for ClusterFuture ... done
[10:32:53.559] result() for ClusterFuture ...
[10:32:53.559] - result already collected: FutureResult
[10:32:53.559] result() for ClusterFuture ... done
[10:32:53.559] result() for ClusterFuture ...
[10:32:53.559] - result already collected: FutureResult
[10:32:53.559] result() for ClusterFuture ... done
<environment: 0x5652d177f808> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[10:32:53.560] plan(): Setting new future strategy stack:
[10:32:53.560] List of future strategies:
[10:32:53.560] 1. multicore:
[10:32:53.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.560]    - tweaked: FALSE
[10:32:53.560]    - call: plan(strategy)
[10:32:53.565] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:32:53.565] getGlobalsAndPackages() ...
[10:32:53.565] Searching for globals...
[10:32:53.565] 
[10:32:53.566] Searching for globals ... DONE
[10:32:53.566] - globals: [0] <none>
[10:32:53.566] getGlobalsAndPackages() ... DONE
[10:32:53.566] run() for ‘Future’ ...
[10:32:53.566] - state: ‘created’
[10:32:53.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.570]   - Field: ‘label’
[10:32:53.570]   - Field: ‘local’
[10:32:53.570]   - Field: ‘owner’
[10:32:53.570]   - Field: ‘envir’
[10:32:53.570]   - Field: ‘workers’
[10:32:53.570]   - Field: ‘packages’
[10:32:53.571]   - Field: ‘gc’
[10:32:53.571]   - Field: ‘job’
[10:32:53.571]   - Field: ‘conditions’
[10:32:53.571]   - Field: ‘expr’
[10:32:53.571]   - Field: ‘uuid’
[10:32:53.571]   - Field: ‘seed’
[10:32:53.571]   - Field: ‘version’
[10:32:53.571]   - Field: ‘result’
[10:32:53.571]   - Field: ‘asynchronous’
[10:32:53.571]   - Field: ‘calls’
[10:32:53.571]   - Field: ‘globals’
[10:32:53.572]   - Field: ‘stdout’
[10:32:53.572]   - Field: ‘earlySignal’
[10:32:53.572]   - Field: ‘lazy’
[10:32:53.572]   - Field: ‘state’
[10:32:53.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.572] - Launch lazy future ...
[10:32:53.572] Packages needed by the future expression (n = 0): <none>
[10:32:53.572] Packages needed by future strategies (n = 0): <none>
[10:32:53.573] {
[10:32:53.573]     {
[10:32:53.573]         {
[10:32:53.573]             ...future.startTime <- base::Sys.time()
[10:32:53.573]             {
[10:32:53.573]                 {
[10:32:53.573]                   {
[10:32:53.573]                     {
[10:32:53.573]                       base::local({
[10:32:53.573]                         has_future <- base::requireNamespace("future", 
[10:32:53.573]                           quietly = TRUE)
[10:32:53.573]                         if (has_future) {
[10:32:53.573]                           ns <- base::getNamespace("future")
[10:32:53.573]                           version <- ns[[".package"]][["version"]]
[10:32:53.573]                           if (is.null(version)) 
[10:32:53.573]                             version <- utils::packageVersion("future")
[10:32:53.573]                         }
[10:32:53.573]                         else {
[10:32:53.573]                           version <- NULL
[10:32:53.573]                         }
[10:32:53.573]                         if (!has_future || version < "1.8.0") {
[10:32:53.573]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.573]                             "", base::R.version$version.string), 
[10:32:53.573]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.573]                               "release", "version")], collapse = " "), 
[10:32:53.573]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.573]                             info)
[10:32:53.573]                           info <- base::paste(info, collapse = "; ")
[10:32:53.573]                           if (!has_future) {
[10:32:53.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.573]                               info)
[10:32:53.573]                           }
[10:32:53.573]                           else {
[10:32:53.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.573]                               info, version)
[10:32:53.573]                           }
[10:32:53.573]                           base::stop(msg)
[10:32:53.573]                         }
[10:32:53.573]                       })
[10:32:53.573]                     }
[10:32:53.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.573]                     base::options(mc.cores = 1L)
[10:32:53.573]                   }
[10:32:53.573]                   ...future.strategy.old <- future::plan("list")
[10:32:53.573]                   options(future.plan = NULL)
[10:32:53.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.573]                 }
[10:32:53.573]                 ...future.workdir <- getwd()
[10:32:53.573]             }
[10:32:53.573]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.573]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.573]         }
[10:32:53.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.573]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.573]             base::names(...future.oldOptions))
[10:32:53.573]     }
[10:32:53.573]     if (FALSE) {
[10:32:53.573]     }
[10:32:53.573]     else {
[10:32:53.573]         if (TRUE) {
[10:32:53.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.573]                 open = "w")
[10:32:53.573]         }
[10:32:53.573]         else {
[10:32:53.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.573]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.573]         }
[10:32:53.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.573]             base::sink(type = "output", split = FALSE)
[10:32:53.573]             base::close(...future.stdout)
[10:32:53.573]         }, add = TRUE)
[10:32:53.573]     }
[10:32:53.573]     ...future.frame <- base::sys.nframe()
[10:32:53.573]     ...future.conditions <- base::list()
[10:32:53.573]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.573]     if (FALSE) {
[10:32:53.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.573]     }
[10:32:53.573]     ...future.result <- base::tryCatch({
[10:32:53.573]         base::withCallingHandlers({
[10:32:53.573]             ...future.value <- base::withVisible(base::local({
[10:32:53.573]                 withCallingHandlers({
[10:32:53.573]                   2
[10:32:53.573]                 }, immediateCondition = function(cond) {
[10:32:53.573]                   save_rds <- function (object, pathname, ...) 
[10:32:53.573]                   {
[10:32:53.573]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.573]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.573]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.573]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.573]                         fi_tmp[["mtime"]])
[10:32:53.573]                     }
[10:32:53.573]                     tryCatch({
[10:32:53.573]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.573]                     }, error = function(ex) {
[10:32:53.573]                       msg <- conditionMessage(ex)
[10:32:53.573]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.573]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.573]                         fi_tmp[["mtime"]], msg)
[10:32:53.573]                       ex$message <- msg
[10:32:53.573]                       stop(ex)
[10:32:53.573]                     })
[10:32:53.573]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.573]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.573]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.573]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.573]                       fi <- file.info(pathname)
[10:32:53.573]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.573]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.573]                         fi[["size"]], fi[["mtime"]])
[10:32:53.573]                       stop(msg)
[10:32:53.573]                     }
[10:32:53.573]                     invisible(pathname)
[10:32:53.573]                   }
[10:32:53.573]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.573]                     rootPath = tempdir()) 
[10:32:53.573]                   {
[10:32:53.573]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.573]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.573]                       tmpdir = path, fileext = ".rds")
[10:32:53.573]                     save_rds(obj, file)
[10:32:53.573]                   }
[10:32:53.573]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.573]                   {
[10:32:53.573]                     inherits <- base::inherits
[10:32:53.573]                     invokeRestart <- base::invokeRestart
[10:32:53.573]                     is.null <- base::is.null
[10:32:53.573]                     muffled <- FALSE
[10:32:53.573]                     if (inherits(cond, "message")) {
[10:32:53.573]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.573]                       if (muffled) 
[10:32:53.573]                         invokeRestart("muffleMessage")
[10:32:53.573]                     }
[10:32:53.573]                     else if (inherits(cond, "warning")) {
[10:32:53.573]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.573]                       if (muffled) 
[10:32:53.573]                         invokeRestart("muffleWarning")
[10:32:53.573]                     }
[10:32:53.573]                     else if (inherits(cond, "condition")) {
[10:32:53.573]                       if (!is.null(pattern)) {
[10:32:53.573]                         computeRestarts <- base::computeRestarts
[10:32:53.573]                         grepl <- base::grepl
[10:32:53.573]                         restarts <- computeRestarts(cond)
[10:32:53.573]                         for (restart in restarts) {
[10:32:53.573]                           name <- restart$name
[10:32:53.573]                           if (is.null(name)) 
[10:32:53.573]                             next
[10:32:53.573]                           if (!grepl(pattern, name)) 
[10:32:53.573]                             next
[10:32:53.573]                           invokeRestart(restart)
[10:32:53.573]                           muffled <- TRUE
[10:32:53.573]                           break
[10:32:53.573]                         }
[10:32:53.573]                       }
[10:32:53.573]                     }
[10:32:53.573]                     invisible(muffled)
[10:32:53.573]                   }
[10:32:53.573]                   muffleCondition(cond)
[10:32:53.573]                 })
[10:32:53.573]             }))
[10:32:53.573]             future::FutureResult(value = ...future.value$value, 
[10:32:53.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.573]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.573]                     ...future.globalenv.names))
[10:32:53.573]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.573]         }, condition = base::local({
[10:32:53.573]             c <- base::c
[10:32:53.573]             inherits <- base::inherits
[10:32:53.573]             invokeRestart <- base::invokeRestart
[10:32:53.573]             length <- base::length
[10:32:53.573]             list <- base::list
[10:32:53.573]             seq.int <- base::seq.int
[10:32:53.573]             signalCondition <- base::signalCondition
[10:32:53.573]             sys.calls <- base::sys.calls
[10:32:53.573]             `[[` <- base::`[[`
[10:32:53.573]             `+` <- base::`+`
[10:32:53.573]             `<<-` <- base::`<<-`
[10:32:53.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.573]                   3L)]
[10:32:53.573]             }
[10:32:53.573]             function(cond) {
[10:32:53.573]                 is_error <- inherits(cond, "error")
[10:32:53.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.573]                   NULL)
[10:32:53.573]                 if (is_error) {
[10:32:53.573]                   sessionInformation <- function() {
[10:32:53.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.573]                       search = base::search(), system = base::Sys.info())
[10:32:53.573]                   }
[10:32:53.573]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.573]                     cond$call), session = sessionInformation(), 
[10:32:53.573]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.573]                   signalCondition(cond)
[10:32:53.573]                 }
[10:32:53.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.573]                 "immediateCondition"))) {
[10:32:53.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.573]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.573]                   if (TRUE && !signal) {
[10:32:53.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.573]                     {
[10:32:53.573]                       inherits <- base::inherits
[10:32:53.573]                       invokeRestart <- base::invokeRestart
[10:32:53.573]                       is.null <- base::is.null
[10:32:53.573]                       muffled <- FALSE
[10:32:53.573]                       if (inherits(cond, "message")) {
[10:32:53.573]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.573]                         if (muffled) 
[10:32:53.573]                           invokeRestart("muffleMessage")
[10:32:53.573]                       }
[10:32:53.573]                       else if (inherits(cond, "warning")) {
[10:32:53.573]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.573]                         if (muffled) 
[10:32:53.573]                           invokeRestart("muffleWarning")
[10:32:53.573]                       }
[10:32:53.573]                       else if (inherits(cond, "condition")) {
[10:32:53.573]                         if (!is.null(pattern)) {
[10:32:53.573]                           computeRestarts <- base::computeRestarts
[10:32:53.573]                           grepl <- base::grepl
[10:32:53.573]                           restarts <- computeRestarts(cond)
[10:32:53.573]                           for (restart in restarts) {
[10:32:53.573]                             name <- restart$name
[10:32:53.573]                             if (is.null(name)) 
[10:32:53.573]                               next
[10:32:53.573]                             if (!grepl(pattern, name)) 
[10:32:53.573]                               next
[10:32:53.573]                             invokeRestart(restart)
[10:32:53.573]                             muffled <- TRUE
[10:32:53.573]                             break
[10:32:53.573]                           }
[10:32:53.573]                         }
[10:32:53.573]                       }
[10:32:53.573]                       invisible(muffled)
[10:32:53.573]                     }
[10:32:53.573]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.573]                   }
[10:32:53.573]                 }
[10:32:53.573]                 else {
[10:32:53.573]                   if (TRUE) {
[10:32:53.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.573]                     {
[10:32:53.573]                       inherits <- base::inherits
[10:32:53.573]                       invokeRestart <- base::invokeRestart
[10:32:53.573]                       is.null <- base::is.null
[10:32:53.573]                       muffled <- FALSE
[10:32:53.573]                       if (inherits(cond, "message")) {
[10:32:53.573]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.573]                         if (muffled) 
[10:32:53.573]                           invokeRestart("muffleMessage")
[10:32:53.573]                       }
[10:32:53.573]                       else if (inherits(cond, "warning")) {
[10:32:53.573]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.573]                         if (muffled) 
[10:32:53.573]                           invokeRestart("muffleWarning")
[10:32:53.573]                       }
[10:32:53.573]                       else if (inherits(cond, "condition")) {
[10:32:53.573]                         if (!is.null(pattern)) {
[10:32:53.573]                           computeRestarts <- base::computeRestarts
[10:32:53.573]                           grepl <- base::grepl
[10:32:53.573]                           restarts <- computeRestarts(cond)
[10:32:53.573]                           for (restart in restarts) {
[10:32:53.573]                             name <- restart$name
[10:32:53.573]                             if (is.null(name)) 
[10:32:53.573]                               next
[10:32:53.573]                             if (!grepl(pattern, name)) 
[10:32:53.573]                               next
[10:32:53.573]                             invokeRestart(restart)
[10:32:53.573]                             muffled <- TRUE
[10:32:53.573]                             break
[10:32:53.573]                           }
[10:32:53.573]                         }
[10:32:53.573]                       }
[10:32:53.573]                       invisible(muffled)
[10:32:53.573]                     }
[10:32:53.573]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.573]                   }
[10:32:53.573]                 }
[10:32:53.573]             }
[10:32:53.573]         }))
[10:32:53.573]     }, error = function(ex) {
[10:32:53.573]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.573]                 ...future.rng), started = ...future.startTime, 
[10:32:53.573]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.573]             version = "1.8"), class = "FutureResult")
[10:32:53.573]     }, finally = {
[10:32:53.573]         if (!identical(...future.workdir, getwd())) 
[10:32:53.573]             setwd(...future.workdir)
[10:32:53.573]         {
[10:32:53.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.573]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.573]             }
[10:32:53.573]             base::options(...future.oldOptions)
[10:32:53.573]             if (.Platform$OS.type == "windows") {
[10:32:53.573]                 old_names <- names(...future.oldEnvVars)
[10:32:53.573]                 envs <- base::Sys.getenv()
[10:32:53.573]                 names <- names(envs)
[10:32:53.573]                 common <- intersect(names, old_names)
[10:32:53.573]                 added <- setdiff(names, old_names)
[10:32:53.573]                 removed <- setdiff(old_names, names)
[10:32:53.573]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.573]                   envs[common]]
[10:32:53.573]                 NAMES <- toupper(changed)
[10:32:53.573]                 args <- list()
[10:32:53.573]                 for (kk in seq_along(NAMES)) {
[10:32:53.573]                   name <- changed[[kk]]
[10:32:53.573]                   NAME <- NAMES[[kk]]
[10:32:53.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.573]                     next
[10:32:53.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.573]                 }
[10:32:53.573]                 NAMES <- toupper(added)
[10:32:53.573]                 for (kk in seq_along(NAMES)) {
[10:32:53.573]                   name <- added[[kk]]
[10:32:53.573]                   NAME <- NAMES[[kk]]
[10:32:53.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.573]                     next
[10:32:53.573]                   args[[name]] <- ""
[10:32:53.573]                 }
[10:32:53.573]                 NAMES <- toupper(removed)
[10:32:53.573]                 for (kk in seq_along(NAMES)) {
[10:32:53.573]                   name <- removed[[kk]]
[10:32:53.573]                   NAME <- NAMES[[kk]]
[10:32:53.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.573]                     next
[10:32:53.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.573]                 }
[10:32:53.573]                 if (length(args) > 0) 
[10:32:53.573]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.573]             }
[10:32:53.573]             else {
[10:32:53.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.573]             }
[10:32:53.573]             {
[10:32:53.573]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.573]                   0L) {
[10:32:53.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.573]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.573]                   base::options(opts)
[10:32:53.573]                 }
[10:32:53.573]                 {
[10:32:53.573]                   {
[10:32:53.573]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.573]                     NULL
[10:32:53.573]                   }
[10:32:53.573]                   options(future.plan = NULL)
[10:32:53.573]                   if (is.na(NA_character_)) 
[10:32:53.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.573]                     .init = FALSE)
[10:32:53.573]                 }
[10:32:53.573]             }
[10:32:53.573]         }
[10:32:53.573]     })
[10:32:53.573]     if (TRUE) {
[10:32:53.573]         base::sink(type = "output", split = FALSE)
[10:32:53.573]         if (TRUE) {
[10:32:53.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.573]         }
[10:32:53.573]         else {
[10:32:53.573]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.573]         }
[10:32:53.573]         base::close(...future.stdout)
[10:32:53.573]         ...future.stdout <- NULL
[10:32:53.573]     }
[10:32:53.573]     ...future.result$conditions <- ...future.conditions
[10:32:53.573]     ...future.result$finished <- base::Sys.time()
[10:32:53.573]     ...future.result
[10:32:53.573] }
[10:32:53.575] requestCore(): workers = 2
[10:32:53.577] MulticoreFuture started
[10:32:53.578] - Launch lazy future ... done
[10:32:53.578] run() for ‘MulticoreFuture’ ... done
[10:32:53.578] getGlobalsAndPackages() ...
[10:32:53.578] Searching for globals...
[10:32:53.579] plan(): Setting new future strategy stack:
[10:32:53.579] 
[10:32:53.579] List of future strategies:
[10:32:53.579] 1. sequential:
[10:32:53.579]    - args: function (..., envir = parent.frame())
[10:32:53.579]    - tweaked: FALSE
[10:32:53.579]    - call: NULL
[10:32:53.579] Searching for globals ... DONE
[10:32:53.580] plan(): nbrOfWorkers() = 1
[10:32:53.580] - globals: [0] <none>
[10:32:53.580] getGlobalsAndPackages() ... DONE
[10:32:53.580] run() for ‘Future’ ...
[10:32:53.580] - state: ‘created’
[10:32:53.581] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.581] plan(): Setting new future strategy stack:
[10:32:53.581] List of future strategies:
[10:32:53.581] 1. multicore:
[10:32:53.581]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.581]    - tweaked: FALSE
[10:32:53.581]    - call: plan(strategy)
[10:32:53.586] plan(): nbrOfWorkers() = 2
[10:32:53.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.586]   - Field: ‘label’
[10:32:53.586]   - Field: ‘local’
[10:32:53.586]   - Field: ‘owner’
[10:32:53.587]   - Field: ‘envir’
[10:32:53.587]   - Field: ‘workers’
[10:32:53.587]   - Field: ‘packages’
[10:32:53.587]   - Field: ‘gc’
[10:32:53.587]   - Field: ‘job’
[10:32:53.587]   - Field: ‘conditions’
[10:32:53.587]   - Field: ‘expr’
[10:32:53.588]   - Field: ‘uuid’
[10:32:53.588]   - Field: ‘seed’
[10:32:53.588]   - Field: ‘version’
[10:32:53.588]   - Field: ‘result’
[10:32:53.588]   - Field: ‘asynchronous’
[10:32:53.588]   - Field: ‘calls’
[10:32:53.588]   - Field: ‘globals’
[10:32:53.588]   - Field: ‘stdout’
[10:32:53.589]   - Field: ‘earlySignal’
[10:32:53.589]   - Field: ‘lazy’
[10:32:53.589]   - Field: ‘state’
[10:32:53.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.589] - Launch lazy future ...
[10:32:53.590] Packages needed by the future expression (n = 0): <none>
[10:32:53.590] Packages needed by future strategies (n = 0): <none>
[10:32:53.590] {
[10:32:53.590]     {
[10:32:53.590]         {
[10:32:53.590]             ...future.startTime <- base::Sys.time()
[10:32:53.590]             {
[10:32:53.590]                 {
[10:32:53.590]                   {
[10:32:53.590]                     {
[10:32:53.590]                       base::local({
[10:32:53.590]                         has_future <- base::requireNamespace("future", 
[10:32:53.590]                           quietly = TRUE)
[10:32:53.590]                         if (has_future) {
[10:32:53.590]                           ns <- base::getNamespace("future")
[10:32:53.590]                           version <- ns[[".package"]][["version"]]
[10:32:53.590]                           if (is.null(version)) 
[10:32:53.590]                             version <- utils::packageVersion("future")
[10:32:53.590]                         }
[10:32:53.590]                         else {
[10:32:53.590]                           version <- NULL
[10:32:53.590]                         }
[10:32:53.590]                         if (!has_future || version < "1.8.0") {
[10:32:53.590]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.590]                             "", base::R.version$version.string), 
[10:32:53.590]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.590]                               "release", "version")], collapse = " "), 
[10:32:53.590]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.590]                             info)
[10:32:53.590]                           info <- base::paste(info, collapse = "; ")
[10:32:53.590]                           if (!has_future) {
[10:32:53.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.590]                               info)
[10:32:53.590]                           }
[10:32:53.590]                           else {
[10:32:53.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.590]                               info, version)
[10:32:53.590]                           }
[10:32:53.590]                           base::stop(msg)
[10:32:53.590]                         }
[10:32:53.590]                       })
[10:32:53.590]                     }
[10:32:53.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.590]                     base::options(mc.cores = 1L)
[10:32:53.590]                   }
[10:32:53.590]                   ...future.strategy.old <- future::plan("list")
[10:32:53.590]                   options(future.plan = NULL)
[10:32:53.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.590]                 }
[10:32:53.590]                 ...future.workdir <- getwd()
[10:32:53.590]             }
[10:32:53.590]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.590]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.590]         }
[10:32:53.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.590]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.590]             base::names(...future.oldOptions))
[10:32:53.590]     }
[10:32:53.590]     if (FALSE) {
[10:32:53.590]     }
[10:32:53.590]     else {
[10:32:53.590]         if (TRUE) {
[10:32:53.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.590]                 open = "w")
[10:32:53.590]         }
[10:32:53.590]         else {
[10:32:53.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.590]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.590]         }
[10:32:53.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.590]             base::sink(type = "output", split = FALSE)
[10:32:53.590]             base::close(...future.stdout)
[10:32:53.590]         }, add = TRUE)
[10:32:53.590]     }
[10:32:53.590]     ...future.frame <- base::sys.nframe()
[10:32:53.590]     ...future.conditions <- base::list()
[10:32:53.590]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.590]     if (FALSE) {
[10:32:53.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.590]     }
[10:32:53.590]     ...future.result <- base::tryCatch({
[10:32:53.590]         base::withCallingHandlers({
[10:32:53.590]             ...future.value <- base::withVisible(base::local({
[10:32:53.590]                 withCallingHandlers({
[10:32:53.590]                   NULL
[10:32:53.590]                 }, immediateCondition = function(cond) {
[10:32:53.590]                   save_rds <- function (object, pathname, ...) 
[10:32:53.590]                   {
[10:32:53.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.590]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.590]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.590]                         fi_tmp[["mtime"]])
[10:32:53.590]                     }
[10:32:53.590]                     tryCatch({
[10:32:53.590]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.590]                     }, error = function(ex) {
[10:32:53.590]                       msg <- conditionMessage(ex)
[10:32:53.590]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.590]                         fi_tmp[["mtime"]], msg)
[10:32:53.590]                       ex$message <- msg
[10:32:53.590]                       stop(ex)
[10:32:53.590]                     })
[10:32:53.590]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.590]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.590]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.590]                       fi <- file.info(pathname)
[10:32:53.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.590]                         fi[["size"]], fi[["mtime"]])
[10:32:53.590]                       stop(msg)
[10:32:53.590]                     }
[10:32:53.590]                     invisible(pathname)
[10:32:53.590]                   }
[10:32:53.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.590]                     rootPath = tempdir()) 
[10:32:53.590]                   {
[10:32:53.590]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.590]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.590]                       tmpdir = path, fileext = ".rds")
[10:32:53.590]                     save_rds(obj, file)
[10:32:53.590]                   }
[10:32:53.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.590]                   {
[10:32:53.590]                     inherits <- base::inherits
[10:32:53.590]                     invokeRestart <- base::invokeRestart
[10:32:53.590]                     is.null <- base::is.null
[10:32:53.590]                     muffled <- FALSE
[10:32:53.590]                     if (inherits(cond, "message")) {
[10:32:53.590]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.590]                       if (muffled) 
[10:32:53.590]                         invokeRestart("muffleMessage")
[10:32:53.590]                     }
[10:32:53.590]                     else if (inherits(cond, "warning")) {
[10:32:53.590]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.590]                       if (muffled) 
[10:32:53.590]                         invokeRestart("muffleWarning")
[10:32:53.590]                     }
[10:32:53.590]                     else if (inherits(cond, "condition")) {
[10:32:53.590]                       if (!is.null(pattern)) {
[10:32:53.590]                         computeRestarts <- base::computeRestarts
[10:32:53.590]                         grepl <- base::grepl
[10:32:53.590]                         restarts <- computeRestarts(cond)
[10:32:53.590]                         for (restart in restarts) {
[10:32:53.590]                           name <- restart$name
[10:32:53.590]                           if (is.null(name)) 
[10:32:53.590]                             next
[10:32:53.590]                           if (!grepl(pattern, name)) 
[10:32:53.590]                             next
[10:32:53.590]                           invokeRestart(restart)
[10:32:53.590]                           muffled <- TRUE
[10:32:53.590]                           break
[10:32:53.590]                         }
[10:32:53.590]                       }
[10:32:53.590]                     }
[10:32:53.590]                     invisible(muffled)
[10:32:53.590]                   }
[10:32:53.590]                   muffleCondition(cond)
[10:32:53.590]                 })
[10:32:53.590]             }))
[10:32:53.590]             future::FutureResult(value = ...future.value$value, 
[10:32:53.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.590]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.590]                     ...future.globalenv.names))
[10:32:53.590]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.590]         }, condition = base::local({
[10:32:53.590]             c <- base::c
[10:32:53.590]             inherits <- base::inherits
[10:32:53.590]             invokeRestart <- base::invokeRestart
[10:32:53.590]             length <- base::length
[10:32:53.590]             list <- base::list
[10:32:53.590]             seq.int <- base::seq.int
[10:32:53.590]             signalCondition <- base::signalCondition
[10:32:53.590]             sys.calls <- base::sys.calls
[10:32:53.590]             `[[` <- base::`[[`
[10:32:53.590]             `+` <- base::`+`
[10:32:53.590]             `<<-` <- base::`<<-`
[10:32:53.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.590]                   3L)]
[10:32:53.590]             }
[10:32:53.590]             function(cond) {
[10:32:53.590]                 is_error <- inherits(cond, "error")
[10:32:53.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.590]                   NULL)
[10:32:53.590]                 if (is_error) {
[10:32:53.590]                   sessionInformation <- function() {
[10:32:53.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.590]                       search = base::search(), system = base::Sys.info())
[10:32:53.590]                   }
[10:32:53.590]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.590]                     cond$call), session = sessionInformation(), 
[10:32:53.590]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.590]                   signalCondition(cond)
[10:32:53.590]                 }
[10:32:53.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.590]                 "immediateCondition"))) {
[10:32:53.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.590]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.590]                   if (TRUE && !signal) {
[10:32:53.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.590]                     {
[10:32:53.590]                       inherits <- base::inherits
[10:32:53.590]                       invokeRestart <- base::invokeRestart
[10:32:53.590]                       is.null <- base::is.null
[10:32:53.590]                       muffled <- FALSE
[10:32:53.590]                       if (inherits(cond, "message")) {
[10:32:53.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.590]                         if (muffled) 
[10:32:53.590]                           invokeRestart("muffleMessage")
[10:32:53.590]                       }
[10:32:53.590]                       else if (inherits(cond, "warning")) {
[10:32:53.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.590]                         if (muffled) 
[10:32:53.590]                           invokeRestart("muffleWarning")
[10:32:53.590]                       }
[10:32:53.590]                       else if (inherits(cond, "condition")) {
[10:32:53.590]                         if (!is.null(pattern)) {
[10:32:53.590]                           computeRestarts <- base::computeRestarts
[10:32:53.590]                           grepl <- base::grepl
[10:32:53.590]                           restarts <- computeRestarts(cond)
[10:32:53.590]                           for (restart in restarts) {
[10:32:53.590]                             name <- restart$name
[10:32:53.590]                             if (is.null(name)) 
[10:32:53.590]                               next
[10:32:53.590]                             if (!grepl(pattern, name)) 
[10:32:53.590]                               next
[10:32:53.590]                             invokeRestart(restart)
[10:32:53.590]                             muffled <- TRUE
[10:32:53.590]                             break
[10:32:53.590]                           }
[10:32:53.590]                         }
[10:32:53.590]                       }
[10:32:53.590]                       invisible(muffled)
[10:32:53.590]                     }
[10:32:53.590]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.590]                   }
[10:32:53.590]                 }
[10:32:53.590]                 else {
[10:32:53.590]                   if (TRUE) {
[10:32:53.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.590]                     {
[10:32:53.590]                       inherits <- base::inherits
[10:32:53.590]                       invokeRestart <- base::invokeRestart
[10:32:53.590]                       is.null <- base::is.null
[10:32:53.590]                       muffled <- FALSE
[10:32:53.590]                       if (inherits(cond, "message")) {
[10:32:53.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.590]                         if (muffled) 
[10:32:53.590]                           invokeRestart("muffleMessage")
[10:32:53.590]                       }
[10:32:53.590]                       else if (inherits(cond, "warning")) {
[10:32:53.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.590]                         if (muffled) 
[10:32:53.590]                           invokeRestart("muffleWarning")
[10:32:53.590]                       }
[10:32:53.590]                       else if (inherits(cond, "condition")) {
[10:32:53.590]                         if (!is.null(pattern)) {
[10:32:53.590]                           computeRestarts <- base::computeRestarts
[10:32:53.590]                           grepl <- base::grepl
[10:32:53.590]                           restarts <- computeRestarts(cond)
[10:32:53.590]                           for (restart in restarts) {
[10:32:53.590]                             name <- restart$name
[10:32:53.590]                             if (is.null(name)) 
[10:32:53.590]                               next
[10:32:53.590]                             if (!grepl(pattern, name)) 
[10:32:53.590]                               next
[10:32:53.590]                             invokeRestart(restart)
[10:32:53.590]                             muffled <- TRUE
[10:32:53.590]                             break
[10:32:53.590]                           }
[10:32:53.590]                         }
[10:32:53.590]                       }
[10:32:53.590]                       invisible(muffled)
[10:32:53.590]                     }
[10:32:53.590]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.590]                   }
[10:32:53.590]                 }
[10:32:53.590]             }
[10:32:53.590]         }))
[10:32:53.590]     }, error = function(ex) {
[10:32:53.590]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.590]                 ...future.rng), started = ...future.startTime, 
[10:32:53.590]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.590]             version = "1.8"), class = "FutureResult")
[10:32:53.590]     }, finally = {
[10:32:53.590]         if (!identical(...future.workdir, getwd())) 
[10:32:53.590]             setwd(...future.workdir)
[10:32:53.590]         {
[10:32:53.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.590]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.590]             }
[10:32:53.590]             base::options(...future.oldOptions)
[10:32:53.590]             if (.Platform$OS.type == "windows") {
[10:32:53.590]                 old_names <- names(...future.oldEnvVars)
[10:32:53.590]                 envs <- base::Sys.getenv()
[10:32:53.590]                 names <- names(envs)
[10:32:53.590]                 common <- intersect(names, old_names)
[10:32:53.590]                 added <- setdiff(names, old_names)
[10:32:53.590]                 removed <- setdiff(old_names, names)
[10:32:53.590]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.590]                   envs[common]]
[10:32:53.590]                 NAMES <- toupper(changed)
[10:32:53.590]                 args <- list()
[10:32:53.590]                 for (kk in seq_along(NAMES)) {
[10:32:53.590]                   name <- changed[[kk]]
[10:32:53.590]                   NAME <- NAMES[[kk]]
[10:32:53.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.590]                     next
[10:32:53.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.590]                 }
[10:32:53.590]                 NAMES <- toupper(added)
[10:32:53.590]                 for (kk in seq_along(NAMES)) {
[10:32:53.590]                   name <- added[[kk]]
[10:32:53.590]                   NAME <- NAMES[[kk]]
[10:32:53.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.590]                     next
[10:32:53.590]                   args[[name]] <- ""
[10:32:53.590]                 }
[10:32:53.590]                 NAMES <- toupper(removed)
[10:32:53.590]                 for (kk in seq_along(NAMES)) {
[10:32:53.590]                   name <- removed[[kk]]
[10:32:53.590]                   NAME <- NAMES[[kk]]
[10:32:53.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.590]                     next
[10:32:53.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.590]                 }
[10:32:53.590]                 if (length(args) > 0) 
[10:32:53.590]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.590]             }
[10:32:53.590]             else {
[10:32:53.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.590]             }
[10:32:53.590]             {
[10:32:53.590]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.590]                   0L) {
[10:32:53.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.590]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.590]                   base::options(opts)
[10:32:53.590]                 }
[10:32:53.590]                 {
[10:32:53.590]                   {
[10:32:53.590]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.590]                     NULL
[10:32:53.590]                   }
[10:32:53.590]                   options(future.plan = NULL)
[10:32:53.590]                   if (is.na(NA_character_)) 
[10:32:53.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.590]                     .init = FALSE)
[10:32:53.590]                 }
[10:32:53.590]             }
[10:32:53.590]         }
[10:32:53.590]     })
[10:32:53.590]     if (TRUE) {
[10:32:53.590]         base::sink(type = "output", split = FALSE)
[10:32:53.590]         if (TRUE) {
[10:32:53.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.590]         }
[10:32:53.590]         else {
[10:32:53.590]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.590]         }
[10:32:53.590]         base::close(...future.stdout)
[10:32:53.590]         ...future.stdout <- NULL
[10:32:53.590]     }
[10:32:53.590]     ...future.result$conditions <- ...future.conditions
[10:32:53.590]     ...future.result$finished <- base::Sys.time()
[10:32:53.590]     ...future.result
[10:32:53.590] }
[10:32:53.594] requestCore(): workers = 2
[10:32:53.596] MulticoreFuture started
[10:32:53.597] - Launch lazy future ... done
[10:32:53.597] run() for ‘MulticoreFuture’ ... done
[10:32:53.598] plan(): Setting new future strategy stack:
[10:32:53.598] getGlobalsAndPackages() ...
[10:32:53.598] Searching for globals...
[10:32:53.598] List of future strategies:
[10:32:53.598] 1. sequential:
[10:32:53.598]    - args: function (..., envir = parent.frame())
[10:32:53.598]    - tweaked: FALSE
[10:32:53.598]    - call: NULL
[10:32:53.599] plan(): nbrOfWorkers() = 1
[10:32:53.599] - globals found: [1] ‘{’
[10:32:53.599] Searching for globals ... DONE
[10:32:53.600] Resolving globals: FALSE
[10:32:53.600] 
[10:32:53.600] 
[10:32:53.600] plan(): Setting new future strategy stack:
[10:32:53.600] getGlobalsAndPackages() ... DONE
[10:32:53.601] run() for ‘Future’ ...
[10:32:53.601] List of future strategies:
[10:32:53.601] 1. multicore:
[10:32:53.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.601]    - tweaked: FALSE
[10:32:53.601]    - call: plan(strategy)
[10:32:53.601] - state: ‘created’
[10:32:53.601] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.606] plan(): nbrOfWorkers() = 2
[10:32:53.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.607]   - Field: ‘label’
[10:32:53.607]   - Field: ‘local’
[10:32:53.607]   - Field: ‘owner’
[10:32:53.607]   - Field: ‘envir’
[10:32:53.608]   - Field: ‘workers’
[10:32:53.608]   - Field: ‘packages’
[10:32:53.608]   - Field: ‘gc’
[10:32:53.608]   - Field: ‘job’
[10:32:53.608]   - Field: ‘conditions’
[10:32:53.608]   - Field: ‘expr’
[10:32:53.608]   - Field: ‘uuid’
[10:32:53.608]   - Field: ‘seed’
[10:32:53.609]   - Field: ‘version’
[10:32:53.609]   - Field: ‘result’
[10:32:53.609]   - Field: ‘asynchronous’
[10:32:53.609]   - Field: ‘calls’
[10:32:53.609]   - Field: ‘globals’
[10:32:53.609]   - Field: ‘stdout’
[10:32:53.609]   - Field: ‘earlySignal’
[10:32:53.610]   - Field: ‘lazy’
[10:32:53.610]   - Field: ‘state’
[10:32:53.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.610] - Launch lazy future ...
[10:32:53.610] Packages needed by the future expression (n = 0): <none>
[10:32:53.611] Packages needed by future strategies (n = 0): <none>
[10:32:53.611] {
[10:32:53.611]     {
[10:32:53.611]         {
[10:32:53.611]             ...future.startTime <- base::Sys.time()
[10:32:53.611]             {
[10:32:53.611]                 {
[10:32:53.611]                   {
[10:32:53.611]                     {
[10:32:53.611]                       base::local({
[10:32:53.611]                         has_future <- base::requireNamespace("future", 
[10:32:53.611]                           quietly = TRUE)
[10:32:53.611]                         if (has_future) {
[10:32:53.611]                           ns <- base::getNamespace("future")
[10:32:53.611]                           version <- ns[[".package"]][["version"]]
[10:32:53.611]                           if (is.null(version)) 
[10:32:53.611]                             version <- utils::packageVersion("future")
[10:32:53.611]                         }
[10:32:53.611]                         else {
[10:32:53.611]                           version <- NULL
[10:32:53.611]                         }
[10:32:53.611]                         if (!has_future || version < "1.8.0") {
[10:32:53.611]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.611]                             "", base::R.version$version.string), 
[10:32:53.611]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.611]                               "release", "version")], collapse = " "), 
[10:32:53.611]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.611]                             info)
[10:32:53.611]                           info <- base::paste(info, collapse = "; ")
[10:32:53.611]                           if (!has_future) {
[10:32:53.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.611]                               info)
[10:32:53.611]                           }
[10:32:53.611]                           else {
[10:32:53.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.611]                               info, version)
[10:32:53.611]                           }
[10:32:53.611]                           base::stop(msg)
[10:32:53.611]                         }
[10:32:53.611]                       })
[10:32:53.611]                     }
[10:32:53.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.611]                     base::options(mc.cores = 1L)
[10:32:53.611]                   }
[10:32:53.611]                   ...future.strategy.old <- future::plan("list")
[10:32:53.611]                   options(future.plan = NULL)
[10:32:53.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.611]                 }
[10:32:53.611]                 ...future.workdir <- getwd()
[10:32:53.611]             }
[10:32:53.611]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.611]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.611]         }
[10:32:53.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.611]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.611]             base::names(...future.oldOptions))
[10:32:53.611]     }
[10:32:53.611]     if (FALSE) {
[10:32:53.611]     }
[10:32:53.611]     else {
[10:32:53.611]         if (TRUE) {
[10:32:53.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.611]                 open = "w")
[10:32:53.611]         }
[10:32:53.611]         else {
[10:32:53.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.611]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.611]         }
[10:32:53.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.611]             base::sink(type = "output", split = FALSE)
[10:32:53.611]             base::close(...future.stdout)
[10:32:53.611]         }, add = TRUE)
[10:32:53.611]     }
[10:32:53.611]     ...future.frame <- base::sys.nframe()
[10:32:53.611]     ...future.conditions <- base::list()
[10:32:53.611]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.611]     if (FALSE) {
[10:32:53.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.611]     }
[10:32:53.611]     ...future.result <- base::tryCatch({
[10:32:53.611]         base::withCallingHandlers({
[10:32:53.611]             ...future.value <- base::withVisible(base::local({
[10:32:53.611]                 withCallingHandlers({
[10:32:53.611]                   {
[10:32:53.611]                     4
[10:32:53.611]                   }
[10:32:53.611]                 }, immediateCondition = function(cond) {
[10:32:53.611]                   save_rds <- function (object, pathname, ...) 
[10:32:53.611]                   {
[10:32:53.611]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.611]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.611]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.611]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.611]                         fi_tmp[["mtime"]])
[10:32:53.611]                     }
[10:32:53.611]                     tryCatch({
[10:32:53.611]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.611]                     }, error = function(ex) {
[10:32:53.611]                       msg <- conditionMessage(ex)
[10:32:53.611]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.611]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.611]                         fi_tmp[["mtime"]], msg)
[10:32:53.611]                       ex$message <- msg
[10:32:53.611]                       stop(ex)
[10:32:53.611]                     })
[10:32:53.611]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.611]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.611]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.611]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.611]                       fi <- file.info(pathname)
[10:32:53.611]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.611]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.611]                         fi[["size"]], fi[["mtime"]])
[10:32:53.611]                       stop(msg)
[10:32:53.611]                     }
[10:32:53.611]                     invisible(pathname)
[10:32:53.611]                   }
[10:32:53.611]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.611]                     rootPath = tempdir()) 
[10:32:53.611]                   {
[10:32:53.611]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.611]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.611]                       tmpdir = path, fileext = ".rds")
[10:32:53.611]                     save_rds(obj, file)
[10:32:53.611]                   }
[10:32:53.611]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.611]                   {
[10:32:53.611]                     inherits <- base::inherits
[10:32:53.611]                     invokeRestart <- base::invokeRestart
[10:32:53.611]                     is.null <- base::is.null
[10:32:53.611]                     muffled <- FALSE
[10:32:53.611]                     if (inherits(cond, "message")) {
[10:32:53.611]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.611]                       if (muffled) 
[10:32:53.611]                         invokeRestart("muffleMessage")
[10:32:53.611]                     }
[10:32:53.611]                     else if (inherits(cond, "warning")) {
[10:32:53.611]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.611]                       if (muffled) 
[10:32:53.611]                         invokeRestart("muffleWarning")
[10:32:53.611]                     }
[10:32:53.611]                     else if (inherits(cond, "condition")) {
[10:32:53.611]                       if (!is.null(pattern)) {
[10:32:53.611]                         computeRestarts <- base::computeRestarts
[10:32:53.611]                         grepl <- base::grepl
[10:32:53.611]                         restarts <- computeRestarts(cond)
[10:32:53.611]                         for (restart in restarts) {
[10:32:53.611]                           name <- restart$name
[10:32:53.611]                           if (is.null(name)) 
[10:32:53.611]                             next
[10:32:53.611]                           if (!grepl(pattern, name)) 
[10:32:53.611]                             next
[10:32:53.611]                           invokeRestart(restart)
[10:32:53.611]                           muffled <- TRUE
[10:32:53.611]                           break
[10:32:53.611]                         }
[10:32:53.611]                       }
[10:32:53.611]                     }
[10:32:53.611]                     invisible(muffled)
[10:32:53.611]                   }
[10:32:53.611]                   muffleCondition(cond)
[10:32:53.611]                 })
[10:32:53.611]             }))
[10:32:53.611]             future::FutureResult(value = ...future.value$value, 
[10:32:53.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.611]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.611]                     ...future.globalenv.names))
[10:32:53.611]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.611]         }, condition = base::local({
[10:32:53.611]             c <- base::c
[10:32:53.611]             inherits <- base::inherits
[10:32:53.611]             invokeRestart <- base::invokeRestart
[10:32:53.611]             length <- base::length
[10:32:53.611]             list <- base::list
[10:32:53.611]             seq.int <- base::seq.int
[10:32:53.611]             signalCondition <- base::signalCondition
[10:32:53.611]             sys.calls <- base::sys.calls
[10:32:53.611]             `[[` <- base::`[[`
[10:32:53.611]             `+` <- base::`+`
[10:32:53.611]             `<<-` <- base::`<<-`
[10:32:53.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.611]                   3L)]
[10:32:53.611]             }
[10:32:53.611]             function(cond) {
[10:32:53.611]                 is_error <- inherits(cond, "error")
[10:32:53.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.611]                   NULL)
[10:32:53.611]                 if (is_error) {
[10:32:53.611]                   sessionInformation <- function() {
[10:32:53.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.611]                       search = base::search(), system = base::Sys.info())
[10:32:53.611]                   }
[10:32:53.611]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.611]                     cond$call), session = sessionInformation(), 
[10:32:53.611]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.611]                   signalCondition(cond)
[10:32:53.611]                 }
[10:32:53.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.611]                 "immediateCondition"))) {
[10:32:53.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.611]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.611]                   if (TRUE && !signal) {
[10:32:53.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.611]                     {
[10:32:53.611]                       inherits <- base::inherits
[10:32:53.611]                       invokeRestart <- base::invokeRestart
[10:32:53.611]                       is.null <- base::is.null
[10:32:53.611]                       muffled <- FALSE
[10:32:53.611]                       if (inherits(cond, "message")) {
[10:32:53.611]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.611]                         if (muffled) 
[10:32:53.611]                           invokeRestart("muffleMessage")
[10:32:53.611]                       }
[10:32:53.611]                       else if (inherits(cond, "warning")) {
[10:32:53.611]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.611]                         if (muffled) 
[10:32:53.611]                           invokeRestart("muffleWarning")
[10:32:53.611]                       }
[10:32:53.611]                       else if (inherits(cond, "condition")) {
[10:32:53.611]                         if (!is.null(pattern)) {
[10:32:53.611]                           computeRestarts <- base::computeRestarts
[10:32:53.611]                           grepl <- base::grepl
[10:32:53.611]                           restarts <- computeRestarts(cond)
[10:32:53.611]                           for (restart in restarts) {
[10:32:53.611]                             name <- restart$name
[10:32:53.611]                             if (is.null(name)) 
[10:32:53.611]                               next
[10:32:53.611]                             if (!grepl(pattern, name)) 
[10:32:53.611]                               next
[10:32:53.611]                             invokeRestart(restart)
[10:32:53.611]                             muffled <- TRUE
[10:32:53.611]                             break
[10:32:53.611]                           }
[10:32:53.611]                         }
[10:32:53.611]                       }
[10:32:53.611]                       invisible(muffled)
[10:32:53.611]                     }
[10:32:53.611]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.611]                   }
[10:32:53.611]                 }
[10:32:53.611]                 else {
[10:32:53.611]                   if (TRUE) {
[10:32:53.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.611]                     {
[10:32:53.611]                       inherits <- base::inherits
[10:32:53.611]                       invokeRestart <- base::invokeRestart
[10:32:53.611]                       is.null <- base::is.null
[10:32:53.611]                       muffled <- FALSE
[10:32:53.611]                       if (inherits(cond, "message")) {
[10:32:53.611]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.611]                         if (muffled) 
[10:32:53.611]                           invokeRestart("muffleMessage")
[10:32:53.611]                       }
[10:32:53.611]                       else if (inherits(cond, "warning")) {
[10:32:53.611]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.611]                         if (muffled) 
[10:32:53.611]                           invokeRestart("muffleWarning")
[10:32:53.611]                       }
[10:32:53.611]                       else if (inherits(cond, "condition")) {
[10:32:53.611]                         if (!is.null(pattern)) {
[10:32:53.611]                           computeRestarts <- base::computeRestarts
[10:32:53.611]                           grepl <- base::grepl
[10:32:53.611]                           restarts <- computeRestarts(cond)
[10:32:53.611]                           for (restart in restarts) {
[10:32:53.611]                             name <- restart$name
[10:32:53.611]                             if (is.null(name)) 
[10:32:53.611]                               next
[10:32:53.611]                             if (!grepl(pattern, name)) 
[10:32:53.611]                               next
[10:32:53.611]                             invokeRestart(restart)
[10:32:53.611]                             muffled <- TRUE
[10:32:53.611]                             break
[10:32:53.611]                           }
[10:32:53.611]                         }
[10:32:53.611]                       }
[10:32:53.611]                       invisible(muffled)
[10:32:53.611]                     }
[10:32:53.611]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.611]                   }
[10:32:53.611]                 }
[10:32:53.611]             }
[10:32:53.611]         }))
[10:32:53.611]     }, error = function(ex) {
[10:32:53.611]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.611]                 ...future.rng), started = ...future.startTime, 
[10:32:53.611]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.611]             version = "1.8"), class = "FutureResult")
[10:32:53.611]     }, finally = {
[10:32:53.611]         if (!identical(...future.workdir, getwd())) 
[10:32:53.611]             setwd(...future.workdir)
[10:32:53.611]         {
[10:32:53.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.611]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.611]             }
[10:32:53.611]             base::options(...future.oldOptions)
[10:32:53.611]             if (.Platform$OS.type == "windows") {
[10:32:53.611]                 old_names <- names(...future.oldEnvVars)
[10:32:53.611]                 envs <- base::Sys.getenv()
[10:32:53.611]                 names <- names(envs)
[10:32:53.611]                 common <- intersect(names, old_names)
[10:32:53.611]                 added <- setdiff(names, old_names)
[10:32:53.611]                 removed <- setdiff(old_names, names)
[10:32:53.611]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.611]                   envs[common]]
[10:32:53.611]                 NAMES <- toupper(changed)
[10:32:53.611]                 args <- list()
[10:32:53.611]                 for (kk in seq_along(NAMES)) {
[10:32:53.611]                   name <- changed[[kk]]
[10:32:53.611]                   NAME <- NAMES[[kk]]
[10:32:53.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.611]                     next
[10:32:53.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.611]                 }
[10:32:53.611]                 NAMES <- toupper(added)
[10:32:53.611]                 for (kk in seq_along(NAMES)) {
[10:32:53.611]                   name <- added[[kk]]
[10:32:53.611]                   NAME <- NAMES[[kk]]
[10:32:53.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.611]                     next
[10:32:53.611]                   args[[name]] <- ""
[10:32:53.611]                 }
[10:32:53.611]                 NAMES <- toupper(removed)
[10:32:53.611]                 for (kk in seq_along(NAMES)) {
[10:32:53.611]                   name <- removed[[kk]]
[10:32:53.611]                   NAME <- NAMES[[kk]]
[10:32:53.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.611]                     next
[10:32:53.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.611]                 }
[10:32:53.611]                 if (length(args) > 0) 
[10:32:53.611]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.611]             }
[10:32:53.611]             else {
[10:32:53.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.611]             }
[10:32:53.611]             {
[10:32:53.611]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.611]                   0L) {
[10:32:53.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.611]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.611]                   base::options(opts)
[10:32:53.611]                 }
[10:32:53.611]                 {
[10:32:53.611]                   {
[10:32:53.611]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.611]                     NULL
[10:32:53.611]                   }
[10:32:53.611]                   options(future.plan = NULL)
[10:32:53.611]                   if (is.na(NA_character_)) 
[10:32:53.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.611]                     .init = FALSE)
[10:32:53.611]                 }
[10:32:53.611]             }
[10:32:53.611]         }
[10:32:53.611]     })
[10:32:53.611]     if (TRUE) {
[10:32:53.611]         base::sink(type = "output", split = FALSE)
[10:32:53.611]         if (TRUE) {
[10:32:53.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.611]         }
[10:32:53.611]         else {
[10:32:53.611]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.611]         }
[10:32:53.611]         base::close(...future.stdout)
[10:32:53.611]         ...future.stdout <- NULL
[10:32:53.611]     }
[10:32:53.611]     ...future.result$conditions <- ...future.conditions
[10:32:53.611]     ...future.result$finished <- base::Sys.time()
[10:32:53.611]     ...future.result
[10:32:53.611] }
[10:32:53.614] requestCore(): workers = 2
[10:32:53.615] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:53.626] result() for MulticoreFuture ...
[10:32:53.626] result() for MulticoreFuture ...
[10:32:53.627] result() for MulticoreFuture ... done
[10:32:53.627] result() for MulticoreFuture ... done
[10:32:53.634] result() for MulticoreFuture ...
[10:32:53.634] result() for MulticoreFuture ... done
[10:32:53.637] MulticoreFuture started
[10:32:53.638] - Launch lazy future ... done
[10:32:53.638] run() for ‘MulticoreFuture’ ... done
[10:32:53.638] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5652d249e000> 
[10:32:53.639] List of future strategies:
[10:32:53.639] 1. sequential:
[10:32:53.639]    - args: function (..., envir = parent.frame())
[10:32:53.639]    - tweaked: FALSE
[10:32:53.639]    - call: NULL
[10:32:53.640] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5652d1782918> 
[10:32:53.642] plan(): Setting new future strategy stack:
[10:32:53.643] List of future strategies:
[10:32:53.643] 1. multicore:
[10:32:53.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.643]    - tweaked: FALSE
[10:32:53.643]    - call: plan(strategy)
[10:32:53.648] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:53.651] resolve() on list environment ...
[10:32:53.651]  recursive: 0
[10:32:53.652]  length: 6
[10:32:53.652]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:53.653] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.653] - nx: 6
[10:32:53.653] - relay: TRUE
[10:32:53.653] - stdout: TRUE
[10:32:53.653] - signal: TRUE
[10:32:53.653] - resignal: FALSE
[10:32:53.653] - force: TRUE
[10:32:53.654] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.654] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.654]  - until=2
[10:32:53.654]  - relaying element #2
[10:32:53.654] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.654] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.654] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.655]  length: 5 (resolved future 1)
[10:32:53.655] Future #2
[10:32:53.655] result() for MulticoreFuture ...
[10:32:53.655] result() for MulticoreFuture ... done
[10:32:53.655] result() for MulticoreFuture ...
[10:32:53.655] result() for MulticoreFuture ... done
[10:32:53.656] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:53.656] - nx: 6
[10:32:53.656] - relay: TRUE
[10:32:53.656] - stdout: TRUE
[10:32:53.656] - signal: TRUE
[10:32:53.656] - resignal: FALSE
[10:32:53.656] - force: TRUE
[10:32:53.656] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.656] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.657]  - until=2
[10:32:53.657]  - relaying element #2
[10:32:53.657] result() for MulticoreFuture ...
[10:32:53.657] result() for MulticoreFuture ... done
[10:32:53.657] result() for MulticoreFuture ...
[10:32:53.657] result() for MulticoreFuture ... done
[10:32:53.657] result() for MulticoreFuture ...
[10:32:53.658] result() for MulticoreFuture ... done
[10:32:53.658] result() for MulticoreFuture ...
[10:32:53.658] result() for MulticoreFuture ... done
[10:32:53.658] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.658] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.658] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:53.658]  length: 4 (resolved future 2)
[10:32:53.659] Future #3
[10:32:53.659] result() for MulticoreFuture ...
[10:32:53.660] result() for MulticoreFuture ...
[10:32:53.660] result() for MulticoreFuture ... done
[10:32:53.660] result() for MulticoreFuture ... done
[10:32:53.660] result() for MulticoreFuture ...
[10:32:53.660] result() for MulticoreFuture ... done
[10:32:53.661] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:53.661] - nx: 6
[10:32:53.661] - relay: TRUE
[10:32:53.661] - stdout: TRUE
[10:32:53.661] - signal: TRUE
[10:32:53.662] - resignal: FALSE
[10:32:53.662] - force: TRUE
[10:32:53.662] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.662] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.662]  - until=3
[10:32:53.662]  - relaying element #3
[10:32:53.663] result() for MulticoreFuture ...
[10:32:53.663] result() for MulticoreFuture ... done
[10:32:53.663] result() for MulticoreFuture ...
[10:32:53.663] result() for MulticoreFuture ... done
[10:32:53.663] result() for MulticoreFuture ...
[10:32:53.663] result() for MulticoreFuture ... done
[10:32:53.664] result() for MulticoreFuture ...
[10:32:53.664] result() for MulticoreFuture ... done
[10:32:53.664] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.664] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.664] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:53.665]  length: 3 (resolved future 3)
[10:32:53.665] Future #4
[10:32:53.665] result() for MulticoreFuture ...
[10:32:53.666] result() for MulticoreFuture ...
[10:32:53.666] result() for MulticoreFuture ... done
[10:32:53.666] result() for MulticoreFuture ... done
[10:32:53.666] result() for MulticoreFuture ...
[10:32:53.666] result() for MulticoreFuture ... done
[10:32:53.666] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:53.667] - nx: 6
[10:32:53.667] - relay: TRUE
[10:32:53.667] - stdout: TRUE
[10:32:53.667] - signal: TRUE
[10:32:53.667] - resignal: FALSE
[10:32:53.667] - force: TRUE
[10:32:53.667] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.667] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.667]  - until=4
[10:32:53.667]  - relaying element #4
[10:32:53.668] result() for MulticoreFuture ...
[10:32:53.668] result() for MulticoreFuture ... done
[10:32:53.668] result() for MulticoreFuture ...
[10:32:53.668] result() for MulticoreFuture ... done
[10:32:53.668] result() for MulticoreFuture ...
[10:32:53.668] result() for MulticoreFuture ... done
[10:32:53.668] result() for MulticoreFuture ...
[10:32:53.668] result() for MulticoreFuture ... done
[10:32:53.669] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.669] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.669] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:53.669]  length: 2 (resolved future 4)
[10:32:53.669] signalConditionsASAP(NULL, pos=5) ...
[10:32:53.669] - nx: 6
[10:32:53.669] - relay: TRUE
[10:32:53.669] - stdout: TRUE
[10:32:53.669] - signal: TRUE
[10:32:53.670] - resignal: FALSE
[10:32:53.670] - force: TRUE
[10:32:53.670] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.670] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.670]  - until=6
[10:32:53.670]  - relaying element #6
[10:32:53.670] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:53.670] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.670] signalConditionsASAP(NULL, pos=5) ... done
[10:32:53.671]  length: 1 (resolved future 5)
[10:32:53.671] signalConditionsASAP(numeric, pos=6) ...
[10:32:53.671] - nx: 6
[10:32:53.671] - relay: TRUE
[10:32:53.671] - stdout: TRUE
[10:32:53.671] - signal: TRUE
[10:32:53.671] - resignal: FALSE
[10:32:53.671] - force: TRUE
[10:32:53.671] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:53.672] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.672]  - until=6
[10:32:53.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.672] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.672] signalConditionsASAP(numeric, pos=6) ... done
[10:32:53.672]  length: 0 (resolved future 6)
[10:32:53.672] Relaying remaining futures
[10:32:53.672] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.672] - nx: 6
[10:32:53.673] - relay: TRUE
[10:32:53.673] - stdout: TRUE
[10:32:53.673] - signal: TRUE
[10:32:53.673] - resignal: FALSE
[10:32:53.673] - force: TRUE
[10:32:53.673] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.673] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:53.673] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.674] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.674] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.674] resolve() on list environment ... DONE
[10:32:53.674] result() for MulticoreFuture ...
[10:32:53.674] result() for MulticoreFuture ... done
[10:32:53.675] result() for MulticoreFuture ...
[10:32:53.675] result() for MulticoreFuture ... done
[10:32:53.675] result() for MulticoreFuture ...
[10:32:53.675] result() for MulticoreFuture ... done
[10:32:53.675] result() for MulticoreFuture ...
[10:32:53.676] result() for MulticoreFuture ... done
[10:32:53.676] result() for MulticoreFuture ...
[10:32:53.676] result() for MulticoreFuture ... done
[10:32:53.677] result() for MulticoreFuture ...
[10:32:53.677] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d148de38> 
Dimensions: c(1, 6)
[10:32:53.678] getGlobalsAndPackages() ...
[10:32:53.678] Searching for globals...
[10:32:53.678] 
[10:32:53.678] Searching for globals ... DONE
[10:32:53.678] - globals: [0] <none>
[10:32:53.679] getGlobalsAndPackages() ... DONE
[10:32:53.679] run() for ‘Future’ ...
[10:32:53.679] - state: ‘created’
[10:32:53.679] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.683] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.684]   - Field: ‘label’
[10:32:53.684]   - Field: ‘local’
[10:32:53.684]   - Field: ‘owner’
[10:32:53.684]   - Field: ‘envir’
[10:32:53.684]   - Field: ‘workers’
[10:32:53.684]   - Field: ‘packages’
[10:32:53.684]   - Field: ‘gc’
[10:32:53.684]   - Field: ‘job’
[10:32:53.684]   - Field: ‘conditions’
[10:32:53.685]   - Field: ‘expr’
[10:32:53.685]   - Field: ‘uuid’
[10:32:53.685]   - Field: ‘seed’
[10:32:53.685]   - Field: ‘version’
[10:32:53.685]   - Field: ‘result’
[10:32:53.685]   - Field: ‘asynchronous’
[10:32:53.685]   - Field: ‘calls’
[10:32:53.685]   - Field: ‘globals’
[10:32:53.686]   - Field: ‘stdout’
[10:32:53.686]   - Field: ‘earlySignal’
[10:32:53.686]   - Field: ‘lazy’
[10:32:53.686]   - Field: ‘state’
[10:32:53.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.686] - Launch lazy future ...
[10:32:53.686] Packages needed by the future expression (n = 0): <none>
[10:32:53.687] Packages needed by future strategies (n = 0): <none>
[10:32:53.687] {
[10:32:53.687]     {
[10:32:53.687]         {
[10:32:53.687]             ...future.startTime <- base::Sys.time()
[10:32:53.687]             {
[10:32:53.687]                 {
[10:32:53.687]                   {
[10:32:53.687]                     {
[10:32:53.687]                       base::local({
[10:32:53.687]                         has_future <- base::requireNamespace("future", 
[10:32:53.687]                           quietly = TRUE)
[10:32:53.687]                         if (has_future) {
[10:32:53.687]                           ns <- base::getNamespace("future")
[10:32:53.687]                           version <- ns[[".package"]][["version"]]
[10:32:53.687]                           if (is.null(version)) 
[10:32:53.687]                             version <- utils::packageVersion("future")
[10:32:53.687]                         }
[10:32:53.687]                         else {
[10:32:53.687]                           version <- NULL
[10:32:53.687]                         }
[10:32:53.687]                         if (!has_future || version < "1.8.0") {
[10:32:53.687]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.687]                             "", base::R.version$version.string), 
[10:32:53.687]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.687]                               "release", "version")], collapse = " "), 
[10:32:53.687]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.687]                             info)
[10:32:53.687]                           info <- base::paste(info, collapse = "; ")
[10:32:53.687]                           if (!has_future) {
[10:32:53.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.687]                               info)
[10:32:53.687]                           }
[10:32:53.687]                           else {
[10:32:53.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.687]                               info, version)
[10:32:53.687]                           }
[10:32:53.687]                           base::stop(msg)
[10:32:53.687]                         }
[10:32:53.687]                       })
[10:32:53.687]                     }
[10:32:53.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.687]                     base::options(mc.cores = 1L)
[10:32:53.687]                   }
[10:32:53.687]                   ...future.strategy.old <- future::plan("list")
[10:32:53.687]                   options(future.plan = NULL)
[10:32:53.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.687]                 }
[10:32:53.687]                 ...future.workdir <- getwd()
[10:32:53.687]             }
[10:32:53.687]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.687]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.687]         }
[10:32:53.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.687]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.687]             base::names(...future.oldOptions))
[10:32:53.687]     }
[10:32:53.687]     if (FALSE) {
[10:32:53.687]     }
[10:32:53.687]     else {
[10:32:53.687]         if (TRUE) {
[10:32:53.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.687]                 open = "w")
[10:32:53.687]         }
[10:32:53.687]         else {
[10:32:53.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.687]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.687]         }
[10:32:53.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.687]             base::sink(type = "output", split = FALSE)
[10:32:53.687]             base::close(...future.stdout)
[10:32:53.687]         }, add = TRUE)
[10:32:53.687]     }
[10:32:53.687]     ...future.frame <- base::sys.nframe()
[10:32:53.687]     ...future.conditions <- base::list()
[10:32:53.687]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.687]     if (FALSE) {
[10:32:53.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.687]     }
[10:32:53.687]     ...future.result <- base::tryCatch({
[10:32:53.687]         base::withCallingHandlers({
[10:32:53.687]             ...future.value <- base::withVisible(base::local({
[10:32:53.687]                 withCallingHandlers({
[10:32:53.687]                   2
[10:32:53.687]                 }, immediateCondition = function(cond) {
[10:32:53.687]                   save_rds <- function (object, pathname, ...) 
[10:32:53.687]                   {
[10:32:53.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.687]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.687]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.687]                         fi_tmp[["mtime"]])
[10:32:53.687]                     }
[10:32:53.687]                     tryCatch({
[10:32:53.687]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.687]                     }, error = function(ex) {
[10:32:53.687]                       msg <- conditionMessage(ex)
[10:32:53.687]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.687]                         fi_tmp[["mtime"]], msg)
[10:32:53.687]                       ex$message <- msg
[10:32:53.687]                       stop(ex)
[10:32:53.687]                     })
[10:32:53.687]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.687]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.687]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.687]                       fi <- file.info(pathname)
[10:32:53.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.687]                         fi[["size"]], fi[["mtime"]])
[10:32:53.687]                       stop(msg)
[10:32:53.687]                     }
[10:32:53.687]                     invisible(pathname)
[10:32:53.687]                   }
[10:32:53.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.687]                     rootPath = tempdir()) 
[10:32:53.687]                   {
[10:32:53.687]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.687]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.687]                       tmpdir = path, fileext = ".rds")
[10:32:53.687]                     save_rds(obj, file)
[10:32:53.687]                   }
[10:32:53.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.687]                   {
[10:32:53.687]                     inherits <- base::inherits
[10:32:53.687]                     invokeRestart <- base::invokeRestart
[10:32:53.687]                     is.null <- base::is.null
[10:32:53.687]                     muffled <- FALSE
[10:32:53.687]                     if (inherits(cond, "message")) {
[10:32:53.687]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.687]                       if (muffled) 
[10:32:53.687]                         invokeRestart("muffleMessage")
[10:32:53.687]                     }
[10:32:53.687]                     else if (inherits(cond, "warning")) {
[10:32:53.687]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.687]                       if (muffled) 
[10:32:53.687]                         invokeRestart("muffleWarning")
[10:32:53.687]                     }
[10:32:53.687]                     else if (inherits(cond, "condition")) {
[10:32:53.687]                       if (!is.null(pattern)) {
[10:32:53.687]                         computeRestarts <- base::computeRestarts
[10:32:53.687]                         grepl <- base::grepl
[10:32:53.687]                         restarts <- computeRestarts(cond)
[10:32:53.687]                         for (restart in restarts) {
[10:32:53.687]                           name <- restart$name
[10:32:53.687]                           if (is.null(name)) 
[10:32:53.687]                             next
[10:32:53.687]                           if (!grepl(pattern, name)) 
[10:32:53.687]                             next
[10:32:53.687]                           invokeRestart(restart)
[10:32:53.687]                           muffled <- TRUE
[10:32:53.687]                           break
[10:32:53.687]                         }
[10:32:53.687]                       }
[10:32:53.687]                     }
[10:32:53.687]                     invisible(muffled)
[10:32:53.687]                   }
[10:32:53.687]                   muffleCondition(cond)
[10:32:53.687]                 })
[10:32:53.687]             }))
[10:32:53.687]             future::FutureResult(value = ...future.value$value, 
[10:32:53.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.687]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.687]                     ...future.globalenv.names))
[10:32:53.687]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.687]         }, condition = base::local({
[10:32:53.687]             c <- base::c
[10:32:53.687]             inherits <- base::inherits
[10:32:53.687]             invokeRestart <- base::invokeRestart
[10:32:53.687]             length <- base::length
[10:32:53.687]             list <- base::list
[10:32:53.687]             seq.int <- base::seq.int
[10:32:53.687]             signalCondition <- base::signalCondition
[10:32:53.687]             sys.calls <- base::sys.calls
[10:32:53.687]             `[[` <- base::`[[`
[10:32:53.687]             `+` <- base::`+`
[10:32:53.687]             `<<-` <- base::`<<-`
[10:32:53.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.687]                   3L)]
[10:32:53.687]             }
[10:32:53.687]             function(cond) {
[10:32:53.687]                 is_error <- inherits(cond, "error")
[10:32:53.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.687]                   NULL)
[10:32:53.687]                 if (is_error) {
[10:32:53.687]                   sessionInformation <- function() {
[10:32:53.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.687]                       search = base::search(), system = base::Sys.info())
[10:32:53.687]                   }
[10:32:53.687]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.687]                     cond$call), session = sessionInformation(), 
[10:32:53.687]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.687]                   signalCondition(cond)
[10:32:53.687]                 }
[10:32:53.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.687]                 "immediateCondition"))) {
[10:32:53.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.687]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.687]                   if (TRUE && !signal) {
[10:32:53.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.687]                     {
[10:32:53.687]                       inherits <- base::inherits
[10:32:53.687]                       invokeRestart <- base::invokeRestart
[10:32:53.687]                       is.null <- base::is.null
[10:32:53.687]                       muffled <- FALSE
[10:32:53.687]                       if (inherits(cond, "message")) {
[10:32:53.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.687]                         if (muffled) 
[10:32:53.687]                           invokeRestart("muffleMessage")
[10:32:53.687]                       }
[10:32:53.687]                       else if (inherits(cond, "warning")) {
[10:32:53.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.687]                         if (muffled) 
[10:32:53.687]                           invokeRestart("muffleWarning")
[10:32:53.687]                       }
[10:32:53.687]                       else if (inherits(cond, "condition")) {
[10:32:53.687]                         if (!is.null(pattern)) {
[10:32:53.687]                           computeRestarts <- base::computeRestarts
[10:32:53.687]                           grepl <- base::grepl
[10:32:53.687]                           restarts <- computeRestarts(cond)
[10:32:53.687]                           for (restart in restarts) {
[10:32:53.687]                             name <- restart$name
[10:32:53.687]                             if (is.null(name)) 
[10:32:53.687]                               next
[10:32:53.687]                             if (!grepl(pattern, name)) 
[10:32:53.687]                               next
[10:32:53.687]                             invokeRestart(restart)
[10:32:53.687]                             muffled <- TRUE
[10:32:53.687]                             break
[10:32:53.687]                           }
[10:32:53.687]                         }
[10:32:53.687]                       }
[10:32:53.687]                       invisible(muffled)
[10:32:53.687]                     }
[10:32:53.687]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.687]                   }
[10:32:53.687]                 }
[10:32:53.687]                 else {
[10:32:53.687]                   if (TRUE) {
[10:32:53.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.687]                     {
[10:32:53.687]                       inherits <- base::inherits
[10:32:53.687]                       invokeRestart <- base::invokeRestart
[10:32:53.687]                       is.null <- base::is.null
[10:32:53.687]                       muffled <- FALSE
[10:32:53.687]                       if (inherits(cond, "message")) {
[10:32:53.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.687]                         if (muffled) 
[10:32:53.687]                           invokeRestart("muffleMessage")
[10:32:53.687]                       }
[10:32:53.687]                       else if (inherits(cond, "warning")) {
[10:32:53.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.687]                         if (muffled) 
[10:32:53.687]                           invokeRestart("muffleWarning")
[10:32:53.687]                       }
[10:32:53.687]                       else if (inherits(cond, "condition")) {
[10:32:53.687]                         if (!is.null(pattern)) {
[10:32:53.687]                           computeRestarts <- base::computeRestarts
[10:32:53.687]                           grepl <- base::grepl
[10:32:53.687]                           restarts <- computeRestarts(cond)
[10:32:53.687]                           for (restart in restarts) {
[10:32:53.687]                             name <- restart$name
[10:32:53.687]                             if (is.null(name)) 
[10:32:53.687]                               next
[10:32:53.687]                             if (!grepl(pattern, name)) 
[10:32:53.687]                               next
[10:32:53.687]                             invokeRestart(restart)
[10:32:53.687]                             muffled <- TRUE
[10:32:53.687]                             break
[10:32:53.687]                           }
[10:32:53.687]                         }
[10:32:53.687]                       }
[10:32:53.687]                       invisible(muffled)
[10:32:53.687]                     }
[10:32:53.687]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.687]                   }
[10:32:53.687]                 }
[10:32:53.687]             }
[10:32:53.687]         }))
[10:32:53.687]     }, error = function(ex) {
[10:32:53.687]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.687]                 ...future.rng), started = ...future.startTime, 
[10:32:53.687]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.687]             version = "1.8"), class = "FutureResult")
[10:32:53.687]     }, finally = {
[10:32:53.687]         if (!identical(...future.workdir, getwd())) 
[10:32:53.687]             setwd(...future.workdir)
[10:32:53.687]         {
[10:32:53.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.687]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.687]             }
[10:32:53.687]             base::options(...future.oldOptions)
[10:32:53.687]             if (.Platform$OS.type == "windows") {
[10:32:53.687]                 old_names <- names(...future.oldEnvVars)
[10:32:53.687]                 envs <- base::Sys.getenv()
[10:32:53.687]                 names <- names(envs)
[10:32:53.687]                 common <- intersect(names, old_names)
[10:32:53.687]                 added <- setdiff(names, old_names)
[10:32:53.687]                 removed <- setdiff(old_names, names)
[10:32:53.687]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.687]                   envs[common]]
[10:32:53.687]                 NAMES <- toupper(changed)
[10:32:53.687]                 args <- list()
[10:32:53.687]                 for (kk in seq_along(NAMES)) {
[10:32:53.687]                   name <- changed[[kk]]
[10:32:53.687]                   NAME <- NAMES[[kk]]
[10:32:53.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.687]                     next
[10:32:53.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.687]                 }
[10:32:53.687]                 NAMES <- toupper(added)
[10:32:53.687]                 for (kk in seq_along(NAMES)) {
[10:32:53.687]                   name <- added[[kk]]
[10:32:53.687]                   NAME <- NAMES[[kk]]
[10:32:53.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.687]                     next
[10:32:53.687]                   args[[name]] <- ""
[10:32:53.687]                 }
[10:32:53.687]                 NAMES <- toupper(removed)
[10:32:53.687]                 for (kk in seq_along(NAMES)) {
[10:32:53.687]                   name <- removed[[kk]]
[10:32:53.687]                   NAME <- NAMES[[kk]]
[10:32:53.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.687]                     next
[10:32:53.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.687]                 }
[10:32:53.687]                 if (length(args) > 0) 
[10:32:53.687]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.687]             }
[10:32:53.687]             else {
[10:32:53.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.687]             }
[10:32:53.687]             {
[10:32:53.687]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.687]                   0L) {
[10:32:53.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.687]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.687]                   base::options(opts)
[10:32:53.687]                 }
[10:32:53.687]                 {
[10:32:53.687]                   {
[10:32:53.687]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.687]                     NULL
[10:32:53.687]                   }
[10:32:53.687]                   options(future.plan = NULL)
[10:32:53.687]                   if (is.na(NA_character_)) 
[10:32:53.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.687]                     .init = FALSE)
[10:32:53.687]                 }
[10:32:53.687]             }
[10:32:53.687]         }
[10:32:53.687]     })
[10:32:53.687]     if (TRUE) {
[10:32:53.687]         base::sink(type = "output", split = FALSE)
[10:32:53.687]         if (TRUE) {
[10:32:53.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.687]         }
[10:32:53.687]         else {
[10:32:53.687]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.687]         }
[10:32:53.687]         base::close(...future.stdout)
[10:32:53.687]         ...future.stdout <- NULL
[10:32:53.687]     }
[10:32:53.687]     ...future.result$conditions <- ...future.conditions
[10:32:53.687]     ...future.result$finished <- base::Sys.time()
[10:32:53.687]     ...future.result
[10:32:53.687] }
[10:32:53.690] requestCore(): workers = 2
[10:32:53.692] MulticoreFuture started
[10:32:53.692] - Launch lazy future ... done
[10:32:53.692] run() for ‘MulticoreFuture’ ... done
[10:32:53.693] getGlobalsAndPackages() ...
[10:32:53.693] Searching for globals...
[10:32:53.693] plan(): Setting new future strategy stack:
[10:32:53.694] 
[10:32:53.693] List of future strategies:
[10:32:53.693] 1. sequential:
[10:32:53.693]    - args: function (..., envir = parent.frame())
[10:32:53.693]    - tweaked: FALSE
[10:32:53.693]    - call: NULL
[10:32:53.694] Searching for globals ... DONE
[10:32:53.694] - globals: [0] <none>
[10:32:53.694] plan(): nbrOfWorkers() = 1
[10:32:53.694] getGlobalsAndPackages() ... DONE
[10:32:53.695] run() for ‘Future’ ...
[10:32:53.695] - state: ‘created’
[10:32:53.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.696] plan(): Setting new future strategy stack:
[10:32:53.696] List of future strategies:
[10:32:53.696] 1. multicore:
[10:32:53.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.696]    - tweaked: FALSE
[10:32:53.696]    - call: plan(strategy)
[10:32:53.700] plan(): nbrOfWorkers() = 2
[10:32:53.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.701] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.701]   - Field: ‘label’
[10:32:53.701]   - Field: ‘local’
[10:32:53.701]   - Field: ‘owner’
[10:32:53.701]   - Field: ‘envir’
[10:32:53.702]   - Field: ‘workers’
[10:32:53.702]   - Field: ‘packages’
[10:32:53.702]   - Field: ‘gc’
[10:32:53.702]   - Field: ‘job’
[10:32:53.702]   - Field: ‘conditions’
[10:32:53.702]   - Field: ‘expr’
[10:32:53.702]   - Field: ‘uuid’
[10:32:53.703]   - Field: ‘seed’
[10:32:53.703]   - Field: ‘version’
[10:32:53.703]   - Field: ‘result’
[10:32:53.703]   - Field: ‘asynchronous’
[10:32:53.703]   - Field: ‘calls’
[10:32:53.703]   - Field: ‘globals’
[10:32:53.703]   - Field: ‘stdout’
[10:32:53.703]   - Field: ‘earlySignal’
[10:32:53.704]   - Field: ‘lazy’
[10:32:53.704]   - Field: ‘state’
[10:32:53.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.704] - Launch lazy future ...
[10:32:53.705] Packages needed by the future expression (n = 0): <none>
[10:32:53.705] Packages needed by future strategies (n = 0): <none>
[10:32:53.706] {
[10:32:53.706]     {
[10:32:53.706]         {
[10:32:53.706]             ...future.startTime <- base::Sys.time()
[10:32:53.706]             {
[10:32:53.706]                 {
[10:32:53.706]                   {
[10:32:53.706]                     {
[10:32:53.706]                       base::local({
[10:32:53.706]                         has_future <- base::requireNamespace("future", 
[10:32:53.706]                           quietly = TRUE)
[10:32:53.706]                         if (has_future) {
[10:32:53.706]                           ns <- base::getNamespace("future")
[10:32:53.706]                           version <- ns[[".package"]][["version"]]
[10:32:53.706]                           if (is.null(version)) 
[10:32:53.706]                             version <- utils::packageVersion("future")
[10:32:53.706]                         }
[10:32:53.706]                         else {
[10:32:53.706]                           version <- NULL
[10:32:53.706]                         }
[10:32:53.706]                         if (!has_future || version < "1.8.0") {
[10:32:53.706]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.706]                             "", base::R.version$version.string), 
[10:32:53.706]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.706]                               "release", "version")], collapse = " "), 
[10:32:53.706]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.706]                             info)
[10:32:53.706]                           info <- base::paste(info, collapse = "; ")
[10:32:53.706]                           if (!has_future) {
[10:32:53.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.706]                               info)
[10:32:53.706]                           }
[10:32:53.706]                           else {
[10:32:53.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.706]                               info, version)
[10:32:53.706]                           }
[10:32:53.706]                           base::stop(msg)
[10:32:53.706]                         }
[10:32:53.706]                       })
[10:32:53.706]                     }
[10:32:53.706]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.706]                     base::options(mc.cores = 1L)
[10:32:53.706]                   }
[10:32:53.706]                   ...future.strategy.old <- future::plan("list")
[10:32:53.706]                   options(future.plan = NULL)
[10:32:53.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.706]                 }
[10:32:53.706]                 ...future.workdir <- getwd()
[10:32:53.706]             }
[10:32:53.706]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.706]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.706]         }
[10:32:53.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.706]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.706]             base::names(...future.oldOptions))
[10:32:53.706]     }
[10:32:53.706]     if (FALSE) {
[10:32:53.706]     }
[10:32:53.706]     else {
[10:32:53.706]         if (TRUE) {
[10:32:53.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.706]                 open = "w")
[10:32:53.706]         }
[10:32:53.706]         else {
[10:32:53.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.706]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.706]         }
[10:32:53.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.706]             base::sink(type = "output", split = FALSE)
[10:32:53.706]             base::close(...future.stdout)
[10:32:53.706]         }, add = TRUE)
[10:32:53.706]     }
[10:32:53.706]     ...future.frame <- base::sys.nframe()
[10:32:53.706]     ...future.conditions <- base::list()
[10:32:53.706]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.706]     if (FALSE) {
[10:32:53.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.706]     }
[10:32:53.706]     ...future.result <- base::tryCatch({
[10:32:53.706]         base::withCallingHandlers({
[10:32:53.706]             ...future.value <- base::withVisible(base::local({
[10:32:53.706]                 withCallingHandlers({
[10:32:53.706]                   NULL
[10:32:53.706]                 }, immediateCondition = function(cond) {
[10:32:53.706]                   save_rds <- function (object, pathname, ...) 
[10:32:53.706]                   {
[10:32:53.706]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.706]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.706]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.706]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.706]                         fi_tmp[["mtime"]])
[10:32:53.706]                     }
[10:32:53.706]                     tryCatch({
[10:32:53.706]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.706]                     }, error = function(ex) {
[10:32:53.706]                       msg <- conditionMessage(ex)
[10:32:53.706]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.706]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.706]                         fi_tmp[["mtime"]], msg)
[10:32:53.706]                       ex$message <- msg
[10:32:53.706]                       stop(ex)
[10:32:53.706]                     })
[10:32:53.706]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.706]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.706]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.706]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.706]                       fi <- file.info(pathname)
[10:32:53.706]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.706]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.706]                         fi[["size"]], fi[["mtime"]])
[10:32:53.706]                       stop(msg)
[10:32:53.706]                     }
[10:32:53.706]                     invisible(pathname)
[10:32:53.706]                   }
[10:32:53.706]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.706]                     rootPath = tempdir()) 
[10:32:53.706]                   {
[10:32:53.706]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.706]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.706]                       tmpdir = path, fileext = ".rds")
[10:32:53.706]                     save_rds(obj, file)
[10:32:53.706]                   }
[10:32:53.706]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.706]                   {
[10:32:53.706]                     inherits <- base::inherits
[10:32:53.706]                     invokeRestart <- base::invokeRestart
[10:32:53.706]                     is.null <- base::is.null
[10:32:53.706]                     muffled <- FALSE
[10:32:53.706]                     if (inherits(cond, "message")) {
[10:32:53.706]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.706]                       if (muffled) 
[10:32:53.706]                         invokeRestart("muffleMessage")
[10:32:53.706]                     }
[10:32:53.706]                     else if (inherits(cond, "warning")) {
[10:32:53.706]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.706]                       if (muffled) 
[10:32:53.706]                         invokeRestart("muffleWarning")
[10:32:53.706]                     }
[10:32:53.706]                     else if (inherits(cond, "condition")) {
[10:32:53.706]                       if (!is.null(pattern)) {
[10:32:53.706]                         computeRestarts <- base::computeRestarts
[10:32:53.706]                         grepl <- base::grepl
[10:32:53.706]                         restarts <- computeRestarts(cond)
[10:32:53.706]                         for (restart in restarts) {
[10:32:53.706]                           name <- restart$name
[10:32:53.706]                           if (is.null(name)) 
[10:32:53.706]                             next
[10:32:53.706]                           if (!grepl(pattern, name)) 
[10:32:53.706]                             next
[10:32:53.706]                           invokeRestart(restart)
[10:32:53.706]                           muffled <- TRUE
[10:32:53.706]                           break
[10:32:53.706]                         }
[10:32:53.706]                       }
[10:32:53.706]                     }
[10:32:53.706]                     invisible(muffled)
[10:32:53.706]                   }
[10:32:53.706]                   muffleCondition(cond)
[10:32:53.706]                 })
[10:32:53.706]             }))
[10:32:53.706]             future::FutureResult(value = ...future.value$value, 
[10:32:53.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.706]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.706]                     ...future.globalenv.names))
[10:32:53.706]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.706]         }, condition = base::local({
[10:32:53.706]             c <- base::c
[10:32:53.706]             inherits <- base::inherits
[10:32:53.706]             invokeRestart <- base::invokeRestart
[10:32:53.706]             length <- base::length
[10:32:53.706]             list <- base::list
[10:32:53.706]             seq.int <- base::seq.int
[10:32:53.706]             signalCondition <- base::signalCondition
[10:32:53.706]             sys.calls <- base::sys.calls
[10:32:53.706]             `[[` <- base::`[[`
[10:32:53.706]             `+` <- base::`+`
[10:32:53.706]             `<<-` <- base::`<<-`
[10:32:53.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.706]                   3L)]
[10:32:53.706]             }
[10:32:53.706]             function(cond) {
[10:32:53.706]                 is_error <- inherits(cond, "error")
[10:32:53.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.706]                   NULL)
[10:32:53.706]                 if (is_error) {
[10:32:53.706]                   sessionInformation <- function() {
[10:32:53.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.706]                       search = base::search(), system = base::Sys.info())
[10:32:53.706]                   }
[10:32:53.706]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.706]                     cond$call), session = sessionInformation(), 
[10:32:53.706]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.706]                   signalCondition(cond)
[10:32:53.706]                 }
[10:32:53.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.706]                 "immediateCondition"))) {
[10:32:53.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.706]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.706]                   if (TRUE && !signal) {
[10:32:53.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.706]                     {
[10:32:53.706]                       inherits <- base::inherits
[10:32:53.706]                       invokeRestart <- base::invokeRestart
[10:32:53.706]                       is.null <- base::is.null
[10:32:53.706]                       muffled <- FALSE
[10:32:53.706]                       if (inherits(cond, "message")) {
[10:32:53.706]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.706]                         if (muffled) 
[10:32:53.706]                           invokeRestart("muffleMessage")
[10:32:53.706]                       }
[10:32:53.706]                       else if (inherits(cond, "warning")) {
[10:32:53.706]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.706]                         if (muffled) 
[10:32:53.706]                           invokeRestart("muffleWarning")
[10:32:53.706]                       }
[10:32:53.706]                       else if (inherits(cond, "condition")) {
[10:32:53.706]                         if (!is.null(pattern)) {
[10:32:53.706]                           computeRestarts <- base::computeRestarts
[10:32:53.706]                           grepl <- base::grepl
[10:32:53.706]                           restarts <- computeRestarts(cond)
[10:32:53.706]                           for (restart in restarts) {
[10:32:53.706]                             name <- restart$name
[10:32:53.706]                             if (is.null(name)) 
[10:32:53.706]                               next
[10:32:53.706]                             if (!grepl(pattern, name)) 
[10:32:53.706]                               next
[10:32:53.706]                             invokeRestart(restart)
[10:32:53.706]                             muffled <- TRUE
[10:32:53.706]                             break
[10:32:53.706]                           }
[10:32:53.706]                         }
[10:32:53.706]                       }
[10:32:53.706]                       invisible(muffled)
[10:32:53.706]                     }
[10:32:53.706]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.706]                   }
[10:32:53.706]                 }
[10:32:53.706]                 else {
[10:32:53.706]                   if (TRUE) {
[10:32:53.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.706]                     {
[10:32:53.706]                       inherits <- base::inherits
[10:32:53.706]                       invokeRestart <- base::invokeRestart
[10:32:53.706]                       is.null <- base::is.null
[10:32:53.706]                       muffled <- FALSE
[10:32:53.706]                       if (inherits(cond, "message")) {
[10:32:53.706]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.706]                         if (muffled) 
[10:32:53.706]                           invokeRestart("muffleMessage")
[10:32:53.706]                       }
[10:32:53.706]                       else if (inherits(cond, "warning")) {
[10:32:53.706]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.706]                         if (muffled) 
[10:32:53.706]                           invokeRestart("muffleWarning")
[10:32:53.706]                       }
[10:32:53.706]                       else if (inherits(cond, "condition")) {
[10:32:53.706]                         if (!is.null(pattern)) {
[10:32:53.706]                           computeRestarts <- base::computeRestarts
[10:32:53.706]                           grepl <- base::grepl
[10:32:53.706]                           restarts <- computeRestarts(cond)
[10:32:53.706]                           for (restart in restarts) {
[10:32:53.706]                             name <- restart$name
[10:32:53.706]                             if (is.null(name)) 
[10:32:53.706]                               next
[10:32:53.706]                             if (!grepl(pattern, name)) 
[10:32:53.706]                               next
[10:32:53.706]                             invokeRestart(restart)
[10:32:53.706]                             muffled <- TRUE
[10:32:53.706]                             break
[10:32:53.706]                           }
[10:32:53.706]                         }
[10:32:53.706]                       }
[10:32:53.706]                       invisible(muffled)
[10:32:53.706]                     }
[10:32:53.706]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.706]                   }
[10:32:53.706]                 }
[10:32:53.706]             }
[10:32:53.706]         }))
[10:32:53.706]     }, error = function(ex) {
[10:32:53.706]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.706]                 ...future.rng), started = ...future.startTime, 
[10:32:53.706]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.706]             version = "1.8"), class = "FutureResult")
[10:32:53.706]     }, finally = {
[10:32:53.706]         if (!identical(...future.workdir, getwd())) 
[10:32:53.706]             setwd(...future.workdir)
[10:32:53.706]         {
[10:32:53.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.706]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.706]             }
[10:32:53.706]             base::options(...future.oldOptions)
[10:32:53.706]             if (.Platform$OS.type == "windows") {
[10:32:53.706]                 old_names <- names(...future.oldEnvVars)
[10:32:53.706]                 envs <- base::Sys.getenv()
[10:32:53.706]                 names <- names(envs)
[10:32:53.706]                 common <- intersect(names, old_names)
[10:32:53.706]                 added <- setdiff(names, old_names)
[10:32:53.706]                 removed <- setdiff(old_names, names)
[10:32:53.706]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.706]                   envs[common]]
[10:32:53.706]                 NAMES <- toupper(changed)
[10:32:53.706]                 args <- list()
[10:32:53.706]                 for (kk in seq_along(NAMES)) {
[10:32:53.706]                   name <- changed[[kk]]
[10:32:53.706]                   NAME <- NAMES[[kk]]
[10:32:53.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.706]                     next
[10:32:53.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.706]                 }
[10:32:53.706]                 NAMES <- toupper(added)
[10:32:53.706]                 for (kk in seq_along(NAMES)) {
[10:32:53.706]                   name <- added[[kk]]
[10:32:53.706]                   NAME <- NAMES[[kk]]
[10:32:53.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.706]                     next
[10:32:53.706]                   args[[name]] <- ""
[10:32:53.706]                 }
[10:32:53.706]                 NAMES <- toupper(removed)
[10:32:53.706]                 for (kk in seq_along(NAMES)) {
[10:32:53.706]                   name <- removed[[kk]]
[10:32:53.706]                   NAME <- NAMES[[kk]]
[10:32:53.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.706]                     next
[10:32:53.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.706]                 }
[10:32:53.706]                 if (length(args) > 0) 
[10:32:53.706]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.706]             }
[10:32:53.706]             else {
[10:32:53.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.706]             }
[10:32:53.706]             {
[10:32:53.706]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.706]                   0L) {
[10:32:53.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.706]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.706]                   base::options(opts)
[10:32:53.706]                 }
[10:32:53.706]                 {
[10:32:53.706]                   {
[10:32:53.706]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.706]                     NULL
[10:32:53.706]                   }
[10:32:53.706]                   options(future.plan = NULL)
[10:32:53.706]                   if (is.na(NA_character_)) 
[10:32:53.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.706]                     .init = FALSE)
[10:32:53.706]                 }
[10:32:53.706]             }
[10:32:53.706]         }
[10:32:53.706]     })
[10:32:53.706]     if (TRUE) {
[10:32:53.706]         base::sink(type = "output", split = FALSE)
[10:32:53.706]         if (TRUE) {
[10:32:53.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.706]         }
[10:32:53.706]         else {
[10:32:53.706]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.706]         }
[10:32:53.706]         base::close(...future.stdout)
[10:32:53.706]         ...future.stdout <- NULL
[10:32:53.706]     }
[10:32:53.706]     ...future.result$conditions <- ...future.conditions
[10:32:53.706]     ...future.result$finished <- base::Sys.time()
[10:32:53.706]     ...future.result
[10:32:53.706] }
[10:32:53.709] requestCore(): workers = 2
[10:32:53.712] MulticoreFuture started
[10:32:53.712] - Launch lazy future ... done
[10:32:53.712] run() for ‘MulticoreFuture’ ... done
[10:32:53.713] plan(): Setting new future strategy stack:
[10:32:53.713] getGlobalsAndPackages() ...
[10:32:53.713] Searching for globals...
[10:32:53.713] List of future strategies:
[10:32:53.713] 1. sequential:
[10:32:53.713]    - args: function (..., envir = parent.frame())
[10:32:53.713]    - tweaked: FALSE
[10:32:53.713]    - call: NULL
[10:32:53.714] plan(): nbrOfWorkers() = 1
[10:32:53.715] - globals found: [1] ‘{’
[10:32:53.715] Searching for globals ... DONE
[10:32:53.715] Resolving globals: FALSE
[10:32:53.716] 
[10:32:53.716] 
[10:32:53.716] plan(): Setting new future strategy stack:
[10:32:53.716] getGlobalsAndPackages() ... DONE
[10:32:53.716] run() for ‘Future’ ...
[10:32:53.716] List of future strategies:
[10:32:53.716] 1. multicore:
[10:32:53.716]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.716]    - tweaked: FALSE
[10:32:53.716]    - call: plan(strategy)
[10:32:53.716] - state: ‘created’
[10:32:53.717] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.721] plan(): nbrOfWorkers() = 2
[10:32:53.722] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.722]   - Field: ‘label’
[10:32:53.722]   - Field: ‘local’
[10:32:53.722]   - Field: ‘owner’
[10:32:53.723]   - Field: ‘envir’
[10:32:53.723]   - Field: ‘workers’
[10:32:53.723]   - Field: ‘packages’
[10:32:53.723]   - Field: ‘gc’
[10:32:53.723]   - Field: ‘job’
[10:32:53.723]   - Field: ‘conditions’
[10:32:53.724]   - Field: ‘expr’
[10:32:53.724]   - Field: ‘uuid’
[10:32:53.724]   - Field: ‘seed’
[10:32:53.724]   - Field: ‘version’
[10:32:53.724]   - Field: ‘result’
[10:32:53.724]   - Field: ‘asynchronous’
[10:32:53.724]   - Field: ‘calls’
[10:32:53.725]   - Field: ‘globals’
[10:32:53.725]   - Field: ‘stdout’
[10:32:53.725]   - Field: ‘earlySignal’
[10:32:53.725]   - Field: ‘lazy’
[10:32:53.725]   - Field: ‘state’
[10:32:53.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.726] - Launch lazy future ...
[10:32:53.726] Packages needed by the future expression (n = 0): <none>
[10:32:53.726] Packages needed by future strategies (n = 0): <none>
[10:32:53.727] {
[10:32:53.727]     {
[10:32:53.727]         {
[10:32:53.727]             ...future.startTime <- base::Sys.time()
[10:32:53.727]             {
[10:32:53.727]                 {
[10:32:53.727]                   {
[10:32:53.727]                     {
[10:32:53.727]                       base::local({
[10:32:53.727]                         has_future <- base::requireNamespace("future", 
[10:32:53.727]                           quietly = TRUE)
[10:32:53.727]                         if (has_future) {
[10:32:53.727]                           ns <- base::getNamespace("future")
[10:32:53.727]                           version <- ns[[".package"]][["version"]]
[10:32:53.727]                           if (is.null(version)) 
[10:32:53.727]                             version <- utils::packageVersion("future")
[10:32:53.727]                         }
[10:32:53.727]                         else {
[10:32:53.727]                           version <- NULL
[10:32:53.727]                         }
[10:32:53.727]                         if (!has_future || version < "1.8.0") {
[10:32:53.727]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.727]                             "", base::R.version$version.string), 
[10:32:53.727]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.727]                               "release", "version")], collapse = " "), 
[10:32:53.727]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.727]                             info)
[10:32:53.727]                           info <- base::paste(info, collapse = "; ")
[10:32:53.727]                           if (!has_future) {
[10:32:53.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.727]                               info)
[10:32:53.727]                           }
[10:32:53.727]                           else {
[10:32:53.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.727]                               info, version)
[10:32:53.727]                           }
[10:32:53.727]                           base::stop(msg)
[10:32:53.727]                         }
[10:32:53.727]                       })
[10:32:53.727]                     }
[10:32:53.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.727]                     base::options(mc.cores = 1L)
[10:32:53.727]                   }
[10:32:53.727]                   ...future.strategy.old <- future::plan("list")
[10:32:53.727]                   options(future.plan = NULL)
[10:32:53.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.727]                 }
[10:32:53.727]                 ...future.workdir <- getwd()
[10:32:53.727]             }
[10:32:53.727]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.727]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.727]         }
[10:32:53.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.727]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.727]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.727]             base::names(...future.oldOptions))
[10:32:53.727]     }
[10:32:53.727]     if (FALSE) {
[10:32:53.727]     }
[10:32:53.727]     else {
[10:32:53.727]         if (TRUE) {
[10:32:53.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.727]                 open = "w")
[10:32:53.727]         }
[10:32:53.727]         else {
[10:32:53.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.727]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.727]         }
[10:32:53.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.727]             base::sink(type = "output", split = FALSE)
[10:32:53.727]             base::close(...future.stdout)
[10:32:53.727]         }, add = TRUE)
[10:32:53.727]     }
[10:32:53.727]     ...future.frame <- base::sys.nframe()
[10:32:53.727]     ...future.conditions <- base::list()
[10:32:53.727]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.727]     if (FALSE) {
[10:32:53.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.727]     }
[10:32:53.727]     ...future.result <- base::tryCatch({
[10:32:53.727]         base::withCallingHandlers({
[10:32:53.727]             ...future.value <- base::withVisible(base::local({
[10:32:53.727]                 withCallingHandlers({
[10:32:53.727]                   {
[10:32:53.727]                     4
[10:32:53.727]                   }
[10:32:53.727]                 }, immediateCondition = function(cond) {
[10:32:53.727]                   save_rds <- function (object, pathname, ...) 
[10:32:53.727]                   {
[10:32:53.727]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.727]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.727]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.727]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.727]                         fi_tmp[["mtime"]])
[10:32:53.727]                     }
[10:32:53.727]                     tryCatch({
[10:32:53.727]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.727]                     }, error = function(ex) {
[10:32:53.727]                       msg <- conditionMessage(ex)
[10:32:53.727]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.727]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.727]                         fi_tmp[["mtime"]], msg)
[10:32:53.727]                       ex$message <- msg
[10:32:53.727]                       stop(ex)
[10:32:53.727]                     })
[10:32:53.727]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.727]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.727]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.727]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.727]                       fi <- file.info(pathname)
[10:32:53.727]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.727]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.727]                         fi[["size"]], fi[["mtime"]])
[10:32:53.727]                       stop(msg)
[10:32:53.727]                     }
[10:32:53.727]                     invisible(pathname)
[10:32:53.727]                   }
[10:32:53.727]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.727]                     rootPath = tempdir()) 
[10:32:53.727]                   {
[10:32:53.727]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.727]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.727]                       tmpdir = path, fileext = ".rds")
[10:32:53.727]                     save_rds(obj, file)
[10:32:53.727]                   }
[10:32:53.727]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.727]                   {
[10:32:53.727]                     inherits <- base::inherits
[10:32:53.727]                     invokeRestart <- base::invokeRestart
[10:32:53.727]                     is.null <- base::is.null
[10:32:53.727]                     muffled <- FALSE
[10:32:53.727]                     if (inherits(cond, "message")) {
[10:32:53.727]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.727]                       if (muffled) 
[10:32:53.727]                         invokeRestart("muffleMessage")
[10:32:53.727]                     }
[10:32:53.727]                     else if (inherits(cond, "warning")) {
[10:32:53.727]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.727]                       if (muffled) 
[10:32:53.727]                         invokeRestart("muffleWarning")
[10:32:53.727]                     }
[10:32:53.727]                     else if (inherits(cond, "condition")) {
[10:32:53.727]                       if (!is.null(pattern)) {
[10:32:53.727]                         computeRestarts <- base::computeRestarts
[10:32:53.727]                         grepl <- base::grepl
[10:32:53.727]                         restarts <- computeRestarts(cond)
[10:32:53.727]                         for (restart in restarts) {
[10:32:53.727]                           name <- restart$name
[10:32:53.727]                           if (is.null(name)) 
[10:32:53.727]                             next
[10:32:53.727]                           if (!grepl(pattern, name)) 
[10:32:53.727]                             next
[10:32:53.727]                           invokeRestart(restart)
[10:32:53.727]                           muffled <- TRUE
[10:32:53.727]                           break
[10:32:53.727]                         }
[10:32:53.727]                       }
[10:32:53.727]                     }
[10:32:53.727]                     invisible(muffled)
[10:32:53.727]                   }
[10:32:53.727]                   muffleCondition(cond)
[10:32:53.727]                 })
[10:32:53.727]             }))
[10:32:53.727]             future::FutureResult(value = ...future.value$value, 
[10:32:53.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.727]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.727]                     ...future.globalenv.names))
[10:32:53.727]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.727]         }, condition = base::local({
[10:32:53.727]             c <- base::c
[10:32:53.727]             inherits <- base::inherits
[10:32:53.727]             invokeRestart <- base::invokeRestart
[10:32:53.727]             length <- base::length
[10:32:53.727]             list <- base::list
[10:32:53.727]             seq.int <- base::seq.int
[10:32:53.727]             signalCondition <- base::signalCondition
[10:32:53.727]             sys.calls <- base::sys.calls
[10:32:53.727]             `[[` <- base::`[[`
[10:32:53.727]             `+` <- base::`+`
[10:32:53.727]             `<<-` <- base::`<<-`
[10:32:53.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.727]                   3L)]
[10:32:53.727]             }
[10:32:53.727]             function(cond) {
[10:32:53.727]                 is_error <- inherits(cond, "error")
[10:32:53.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.727]                   NULL)
[10:32:53.727]                 if (is_error) {
[10:32:53.727]                   sessionInformation <- function() {
[10:32:53.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.727]                       search = base::search(), system = base::Sys.info())
[10:32:53.727]                   }
[10:32:53.727]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.727]                     cond$call), session = sessionInformation(), 
[10:32:53.727]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.727]                   signalCondition(cond)
[10:32:53.727]                 }
[10:32:53.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.727]                 "immediateCondition"))) {
[10:32:53.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.727]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.727]                   if (TRUE && !signal) {
[10:32:53.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.727]                     {
[10:32:53.727]                       inherits <- base::inherits
[10:32:53.727]                       invokeRestart <- base::invokeRestart
[10:32:53.727]                       is.null <- base::is.null
[10:32:53.727]                       muffled <- FALSE
[10:32:53.727]                       if (inherits(cond, "message")) {
[10:32:53.727]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.727]                         if (muffled) 
[10:32:53.727]                           invokeRestart("muffleMessage")
[10:32:53.727]                       }
[10:32:53.727]                       else if (inherits(cond, "warning")) {
[10:32:53.727]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.727]                         if (muffled) 
[10:32:53.727]                           invokeRestart("muffleWarning")
[10:32:53.727]                       }
[10:32:53.727]                       else if (inherits(cond, "condition")) {
[10:32:53.727]                         if (!is.null(pattern)) {
[10:32:53.727]                           computeRestarts <- base::computeRestarts
[10:32:53.727]                           grepl <- base::grepl
[10:32:53.727]                           restarts <- computeRestarts(cond)
[10:32:53.727]                           for (restart in restarts) {
[10:32:53.727]                             name <- restart$name
[10:32:53.727]                             if (is.null(name)) 
[10:32:53.727]                               next
[10:32:53.727]                             if (!grepl(pattern, name)) 
[10:32:53.727]                               next
[10:32:53.727]                             invokeRestart(restart)
[10:32:53.727]                             muffled <- TRUE
[10:32:53.727]                             break
[10:32:53.727]                           }
[10:32:53.727]                         }
[10:32:53.727]                       }
[10:32:53.727]                       invisible(muffled)
[10:32:53.727]                     }
[10:32:53.727]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.727]                   }
[10:32:53.727]                 }
[10:32:53.727]                 else {
[10:32:53.727]                   if (TRUE) {
[10:32:53.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.727]                     {
[10:32:53.727]                       inherits <- base::inherits
[10:32:53.727]                       invokeRestart <- base::invokeRestart
[10:32:53.727]                       is.null <- base::is.null
[10:32:53.727]                       muffled <- FALSE
[10:32:53.727]                       if (inherits(cond, "message")) {
[10:32:53.727]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.727]                         if (muffled) 
[10:32:53.727]                           invokeRestart("muffleMessage")
[10:32:53.727]                       }
[10:32:53.727]                       else if (inherits(cond, "warning")) {
[10:32:53.727]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.727]                         if (muffled) 
[10:32:53.727]                           invokeRestart("muffleWarning")
[10:32:53.727]                       }
[10:32:53.727]                       else if (inherits(cond, "condition")) {
[10:32:53.727]                         if (!is.null(pattern)) {
[10:32:53.727]                           computeRestarts <- base::computeRestarts
[10:32:53.727]                           grepl <- base::grepl
[10:32:53.727]                           restarts <- computeRestarts(cond)
[10:32:53.727]                           for (restart in restarts) {
[10:32:53.727]                             name <- restart$name
[10:32:53.727]                             if (is.null(name)) 
[10:32:53.727]                               next
[10:32:53.727]                             if (!grepl(pattern, name)) 
[10:32:53.727]                               next
[10:32:53.727]                             invokeRestart(restart)
[10:32:53.727]                             muffled <- TRUE
[10:32:53.727]                             break
[10:32:53.727]                           }
[10:32:53.727]                         }
[10:32:53.727]                       }
[10:32:53.727]                       invisible(muffled)
[10:32:53.727]                     }
[10:32:53.727]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.727]                   }
[10:32:53.727]                 }
[10:32:53.727]             }
[10:32:53.727]         }))
[10:32:53.727]     }, error = function(ex) {
[10:32:53.727]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.727]                 ...future.rng), started = ...future.startTime, 
[10:32:53.727]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.727]             version = "1.8"), class = "FutureResult")
[10:32:53.727]     }, finally = {
[10:32:53.727]         if (!identical(...future.workdir, getwd())) 
[10:32:53.727]             setwd(...future.workdir)
[10:32:53.727]         {
[10:32:53.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.727]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.727]             }
[10:32:53.727]             base::options(...future.oldOptions)
[10:32:53.727]             if (.Platform$OS.type == "windows") {
[10:32:53.727]                 old_names <- names(...future.oldEnvVars)
[10:32:53.727]                 envs <- base::Sys.getenv()
[10:32:53.727]                 names <- names(envs)
[10:32:53.727]                 common <- intersect(names, old_names)
[10:32:53.727]                 added <- setdiff(names, old_names)
[10:32:53.727]                 removed <- setdiff(old_names, names)
[10:32:53.727]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.727]                   envs[common]]
[10:32:53.727]                 NAMES <- toupper(changed)
[10:32:53.727]                 args <- list()
[10:32:53.727]                 for (kk in seq_along(NAMES)) {
[10:32:53.727]                   name <- changed[[kk]]
[10:32:53.727]                   NAME <- NAMES[[kk]]
[10:32:53.727]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.727]                     next
[10:32:53.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.727]                 }
[10:32:53.727]                 NAMES <- toupper(added)
[10:32:53.727]                 for (kk in seq_along(NAMES)) {
[10:32:53.727]                   name <- added[[kk]]
[10:32:53.727]                   NAME <- NAMES[[kk]]
[10:32:53.727]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.727]                     next
[10:32:53.727]                   args[[name]] <- ""
[10:32:53.727]                 }
[10:32:53.727]                 NAMES <- toupper(removed)
[10:32:53.727]                 for (kk in seq_along(NAMES)) {
[10:32:53.727]                   name <- removed[[kk]]
[10:32:53.727]                   NAME <- NAMES[[kk]]
[10:32:53.727]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.727]                     next
[10:32:53.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.727]                 }
[10:32:53.727]                 if (length(args) > 0) 
[10:32:53.727]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.727]             }
[10:32:53.727]             else {
[10:32:53.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.727]             }
[10:32:53.727]             {
[10:32:53.727]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.727]                   0L) {
[10:32:53.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.727]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.727]                   base::options(opts)
[10:32:53.727]                 }
[10:32:53.727]                 {
[10:32:53.727]                   {
[10:32:53.727]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.727]                     NULL
[10:32:53.727]                   }
[10:32:53.727]                   options(future.plan = NULL)
[10:32:53.727]                   if (is.na(NA_character_)) 
[10:32:53.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.727]                     .init = FALSE)
[10:32:53.727]                 }
[10:32:53.727]             }
[10:32:53.727]         }
[10:32:53.727]     })
[10:32:53.727]     if (TRUE) {
[10:32:53.727]         base::sink(type = "output", split = FALSE)
[10:32:53.727]         if (TRUE) {
[10:32:53.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.727]         }
[10:32:53.727]         else {
[10:32:53.727]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.727]         }
[10:32:53.727]         base::close(...future.stdout)
[10:32:53.727]         ...future.stdout <- NULL
[10:32:53.727]     }
[10:32:53.727]     ...future.result$conditions <- ...future.conditions
[10:32:53.727]     ...future.result$finished <- base::Sys.time()
[10:32:53.727]     ...future.result
[10:32:53.727] }
[10:32:53.730] requestCore(): workers = 2
[10:32:53.731] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:53.742] result() for MulticoreFuture ...
[10:32:53.743] result() for MulticoreFuture ...
[10:32:53.743] result() for MulticoreFuture ... done
[10:32:53.743] result() for MulticoreFuture ... done
[10:32:53.743] result() for MulticoreFuture ...
[10:32:53.743] result() for MulticoreFuture ... done
[10:32:53.747] MulticoreFuture started
[10:32:53.747] - Launch lazy future ... done
[10:32:53.747] run() for ‘MulticoreFuture’ ... done
[10:32:53.747] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5652cfb3b600> 
[10:32:53.748] List of future strategies:
[10:32:53.748] 1. sequential:
[10:32:53.748]    - args: function (..., envir = parent.frame())
[10:32:53.748]    - tweaked: FALSE
[10:32:53.748]    - call: NULL
[10:32:53.749] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5652d2583898> 
 - attr(*, "dim.")=[10:32:53.750] plan(): Setting new future strategy stack:
 int [1:2] 1 6
 - attr(*, "dimnames.")=[10:32:53.751] List of future strategies:
[10:32:53.751] 1. multicore:
[10:32:53.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.751]    - tweaked: FALSE
[10:32:53.751]    - call: plan(strategy)
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:32:53.756] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:53.760] resolve() on list environment ...
[10:32:53.760]  recursive: 0
[10:32:53.761]  length: 6
[10:32:53.761]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:53.761] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.762] - nx: 6
[10:32:53.762] - relay: TRUE
[10:32:53.762] - stdout: TRUE
[10:32:53.762] - signal: TRUE
[10:32:53.762] - resignal: FALSE
[10:32:53.762] - force: TRUE
[10:32:53.762] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.762] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.763]  - until=2
[10:32:53.763]  - relaying element #2
[10:32:53.763] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.763] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.763] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.763]  length: 5 (resolved future 1)
[10:32:53.763] Future #2
[10:32:53.764] result() for MulticoreFuture ...
[10:32:53.764] result() for MulticoreFuture ... done
[10:32:53.764] result() for MulticoreFuture ...
[10:32:53.764] result() for MulticoreFuture ... done
[10:32:53.764] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:53.764] - nx: 6
[10:32:53.764] - relay: TRUE
[10:32:53.765] - stdout: TRUE
[10:32:53.765] - signal: TRUE
[10:32:53.765] - resignal: FALSE
[10:32:53.765] - force: TRUE
[10:32:53.765] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.765] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.765]  - until=2
[10:32:53.765]  - relaying element #2
[10:32:53.766] result() for MulticoreFuture ...
[10:32:53.766] result() for MulticoreFuture ... done
[10:32:53.766] result() for MulticoreFuture ...
[10:32:53.766] result() for MulticoreFuture ... done
[10:32:53.766] result() for MulticoreFuture ...
[10:32:53.766] result() for MulticoreFuture ... done
[10:32:53.766] result() for MulticoreFuture ...
[10:32:53.767] result() for MulticoreFuture ... done
[10:32:53.767] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.767] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.767] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:53.767]  length: 4 (resolved future 2)
[10:32:53.767] Future #3
[10:32:53.768] result() for MulticoreFuture ...
[10:32:53.768] result() for MulticoreFuture ...
[10:32:53.769] result() for MulticoreFuture ... done
[10:32:53.769] result() for MulticoreFuture ... done
[10:32:53.769] result() for MulticoreFuture ...
[10:32:53.769] result() for MulticoreFuture ... done
[10:32:53.769] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:53.769] - nx: 6
[10:32:53.769] - relay: TRUE
[10:32:53.770] - stdout: TRUE
[10:32:53.770] - signal: TRUE
[10:32:53.770] - resignal: FALSE
[10:32:53.770] - force: TRUE
[10:32:53.770] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.770] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.770]  - until=3
[10:32:53.770]  - relaying element #3
[10:32:53.771] result() for MulticoreFuture ...
[10:32:53.771] result() for MulticoreFuture ... done
[10:32:53.771] result() for MulticoreFuture ...
[10:32:53.771] result() for MulticoreFuture ... done
[10:32:53.771] result() for MulticoreFuture ...
[10:32:53.771] result() for MulticoreFuture ... done
[10:32:53.771] result() for MulticoreFuture ...
[10:32:53.771] result() for MulticoreFuture ... done
[10:32:53.772] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.772] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.772] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:53.772]  length: 3 (resolved future 3)
[10:32:53.772] Future #4
[10:32:53.772] result() for MulticoreFuture ...
[10:32:53.773] result() for MulticoreFuture ...
[10:32:53.773] result() for MulticoreFuture ... done
[10:32:53.773] result() for MulticoreFuture ... done
[10:32:53.774] result() for MulticoreFuture ...
[10:32:53.774] result() for MulticoreFuture ... done
[10:32:53.774] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:53.774] - nx: 6
[10:32:53.774] - relay: TRUE
[10:32:53.774] - stdout: TRUE
[10:32:53.774] - signal: TRUE
[10:32:53.774] - resignal: FALSE
[10:32:53.775] - force: TRUE
[10:32:53.775] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.775]  - until=4
[10:32:53.775]  - relaying element #4
[10:32:53.775] result() for MulticoreFuture ...
[10:32:53.775] result() for MulticoreFuture ... done
[10:32:53.775] result() for MulticoreFuture ...
[10:32:53.775] result() for MulticoreFuture ... done
[10:32:53.776] result() for MulticoreFuture ...
[10:32:53.776] result() for MulticoreFuture ... done
[10:32:53.776] result() for MulticoreFuture ...
[10:32:53.776] result() for MulticoreFuture ... done
[10:32:53.776] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.776] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.776] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:53.776]  length: 2 (resolved future 4)
[10:32:53.776] signalConditionsASAP(NULL, pos=5) ...
[10:32:53.777] - nx: 6
[10:32:53.777] - relay: TRUE
[10:32:53.777] - stdout: TRUE
[10:32:53.777] - signal: TRUE
[10:32:53.777] - resignal: FALSE
[10:32:53.777] - force: TRUE
[10:32:53.777] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.777] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.777]  - until=6
[10:32:53.778]  - relaying element #6
[10:32:53.778] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:53.778] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.778] signalConditionsASAP(NULL, pos=5) ... done
[10:32:53.778]  length: 1 (resolved future 5)
[10:32:53.782] signalConditionsASAP(numeric, pos=6) ...
[10:32:53.782] - nx: 6
[10:32:53.782] - relay: TRUE
[10:32:53.783] - stdout: TRUE
[10:32:53.783] - signal: TRUE
[10:32:53.783] - resignal: FALSE
[10:32:53.783] - force: TRUE
[10:32:53.783] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:53.783] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.783]  - until=6
[10:32:53.783] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.784] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.784] signalConditionsASAP(numeric, pos=6) ... done
[10:32:53.784]  length: 0 (resolved future 6)
[10:32:53.784] Relaying remaining futures
[10:32:53.784] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.784] - nx: 6
[10:32:53.784] - relay: TRUE
[10:32:53.784] - stdout: TRUE
[10:32:53.784] - signal: TRUE
[10:32:53.785] - resignal: FALSE
[10:32:53.785] - force: TRUE
[10:32:53.785] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.785] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:53.785] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.785] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.785] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.785] resolve() on list environment ... DONE
[10:32:53.786] result() for MulticoreFuture ...
[10:32:53.786] result() for MulticoreFuture ... done
[10:32:53.786] result() for MulticoreFuture ...
[10:32:53.786] result() for MulticoreFuture ... done
[10:32:53.786] result() for MulticoreFuture ...
[10:32:53.786] result() for MulticoreFuture ... done
[10:32:53.786] result() for MulticoreFuture ...
[10:32:53.786] result() for MulticoreFuture ... done
[10:32:53.787] result() for MulticoreFuture ...
[10:32:53.787] result() for MulticoreFuture ... done
[10:32:53.787] result() for MulticoreFuture ...
[10:32:53.787] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d28b5318> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:32:53.789] getGlobalsAndPackages() ...
[10:32:53.789] Searching for globals...
[10:32:53.790] 
[10:32:53.790] Searching for globals ... DONE
[10:32:53.790] - globals: [0] <none>
[10:32:53.790] getGlobalsAndPackages() ... DONE
[10:32:53.790] run() for ‘Future’ ...
[10:32:53.790] - state: ‘created’
[10:32:53.790] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.795] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.795]   - Field: ‘label’
[10:32:53.795]   - Field: ‘local’
[10:32:53.795]   - Field: ‘owner’
[10:32:53.795]   - Field: ‘envir’
[10:32:53.795]   - Field: ‘workers’
[10:32:53.796]   - Field: ‘packages’
[10:32:53.796]   - Field: ‘gc’
[10:32:53.796]   - Field: ‘job’
[10:32:53.796]   - Field: ‘conditions’
[10:32:53.796]   - Field: ‘expr’
[10:32:53.796]   - Field: ‘uuid’
[10:32:53.796]   - Field: ‘seed’
[10:32:53.796]   - Field: ‘version’
[10:32:53.796]   - Field: ‘result’
[10:32:53.796]   - Field: ‘asynchronous’
[10:32:53.797]   - Field: ‘calls’
[10:32:53.797]   - Field: ‘globals’
[10:32:53.797]   - Field: ‘stdout’
[10:32:53.797]   - Field: ‘earlySignal’
[10:32:53.797]   - Field: ‘lazy’
[10:32:53.797]   - Field: ‘state’
[10:32:53.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.797] - Launch lazy future ...
[10:32:53.798] Packages needed by the future expression (n = 0): <none>
[10:32:53.798] Packages needed by future strategies (n = 0): <none>
[10:32:53.798] {
[10:32:53.798]     {
[10:32:53.798]         {
[10:32:53.798]             ...future.startTime <- base::Sys.time()
[10:32:53.798]             {
[10:32:53.798]                 {
[10:32:53.798]                   {
[10:32:53.798]                     {
[10:32:53.798]                       base::local({
[10:32:53.798]                         has_future <- base::requireNamespace("future", 
[10:32:53.798]                           quietly = TRUE)
[10:32:53.798]                         if (has_future) {
[10:32:53.798]                           ns <- base::getNamespace("future")
[10:32:53.798]                           version <- ns[[".package"]][["version"]]
[10:32:53.798]                           if (is.null(version)) 
[10:32:53.798]                             version <- utils::packageVersion("future")
[10:32:53.798]                         }
[10:32:53.798]                         else {
[10:32:53.798]                           version <- NULL
[10:32:53.798]                         }
[10:32:53.798]                         if (!has_future || version < "1.8.0") {
[10:32:53.798]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.798]                             "", base::R.version$version.string), 
[10:32:53.798]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.798]                               "release", "version")], collapse = " "), 
[10:32:53.798]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.798]                             info)
[10:32:53.798]                           info <- base::paste(info, collapse = "; ")
[10:32:53.798]                           if (!has_future) {
[10:32:53.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.798]                               info)
[10:32:53.798]                           }
[10:32:53.798]                           else {
[10:32:53.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.798]                               info, version)
[10:32:53.798]                           }
[10:32:53.798]                           base::stop(msg)
[10:32:53.798]                         }
[10:32:53.798]                       })
[10:32:53.798]                     }
[10:32:53.798]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.798]                     base::options(mc.cores = 1L)
[10:32:53.798]                   }
[10:32:53.798]                   ...future.strategy.old <- future::plan("list")
[10:32:53.798]                   options(future.plan = NULL)
[10:32:53.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.798]                 }
[10:32:53.798]                 ...future.workdir <- getwd()
[10:32:53.798]             }
[10:32:53.798]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.798]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.798]         }
[10:32:53.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.798]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.798]             base::names(...future.oldOptions))
[10:32:53.798]     }
[10:32:53.798]     if (FALSE) {
[10:32:53.798]     }
[10:32:53.798]     else {
[10:32:53.798]         if (TRUE) {
[10:32:53.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.798]                 open = "w")
[10:32:53.798]         }
[10:32:53.798]         else {
[10:32:53.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.798]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.798]         }
[10:32:53.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.798]             base::sink(type = "output", split = FALSE)
[10:32:53.798]             base::close(...future.stdout)
[10:32:53.798]         }, add = TRUE)
[10:32:53.798]     }
[10:32:53.798]     ...future.frame <- base::sys.nframe()
[10:32:53.798]     ...future.conditions <- base::list()
[10:32:53.798]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.798]     if (FALSE) {
[10:32:53.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.798]     }
[10:32:53.798]     ...future.result <- base::tryCatch({
[10:32:53.798]         base::withCallingHandlers({
[10:32:53.798]             ...future.value <- base::withVisible(base::local({
[10:32:53.798]                 withCallingHandlers({
[10:32:53.798]                   2
[10:32:53.798]                 }, immediateCondition = function(cond) {
[10:32:53.798]                   save_rds <- function (object, pathname, ...) 
[10:32:53.798]                   {
[10:32:53.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.798]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.798]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.798]                         fi_tmp[["mtime"]])
[10:32:53.798]                     }
[10:32:53.798]                     tryCatch({
[10:32:53.798]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.798]                     }, error = function(ex) {
[10:32:53.798]                       msg <- conditionMessage(ex)
[10:32:53.798]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.798]                         fi_tmp[["mtime"]], msg)
[10:32:53.798]                       ex$message <- msg
[10:32:53.798]                       stop(ex)
[10:32:53.798]                     })
[10:32:53.798]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.798]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.798]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.798]                       fi <- file.info(pathname)
[10:32:53.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.798]                         fi[["size"]], fi[["mtime"]])
[10:32:53.798]                       stop(msg)
[10:32:53.798]                     }
[10:32:53.798]                     invisible(pathname)
[10:32:53.798]                   }
[10:32:53.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.798]                     rootPath = tempdir()) 
[10:32:53.798]                   {
[10:32:53.798]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.798]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.798]                       tmpdir = path, fileext = ".rds")
[10:32:53.798]                     save_rds(obj, file)
[10:32:53.798]                   }
[10:32:53.798]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.798]                   {
[10:32:53.798]                     inherits <- base::inherits
[10:32:53.798]                     invokeRestart <- base::invokeRestart
[10:32:53.798]                     is.null <- base::is.null
[10:32:53.798]                     muffled <- FALSE
[10:32:53.798]                     if (inherits(cond, "message")) {
[10:32:53.798]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.798]                       if (muffled) 
[10:32:53.798]                         invokeRestart("muffleMessage")
[10:32:53.798]                     }
[10:32:53.798]                     else if (inherits(cond, "warning")) {
[10:32:53.798]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.798]                       if (muffled) 
[10:32:53.798]                         invokeRestart("muffleWarning")
[10:32:53.798]                     }
[10:32:53.798]                     else if (inherits(cond, "condition")) {
[10:32:53.798]                       if (!is.null(pattern)) {
[10:32:53.798]                         computeRestarts <- base::computeRestarts
[10:32:53.798]                         grepl <- base::grepl
[10:32:53.798]                         restarts <- computeRestarts(cond)
[10:32:53.798]                         for (restart in restarts) {
[10:32:53.798]                           name <- restart$name
[10:32:53.798]                           if (is.null(name)) 
[10:32:53.798]                             next
[10:32:53.798]                           if (!grepl(pattern, name)) 
[10:32:53.798]                             next
[10:32:53.798]                           invokeRestart(restart)
[10:32:53.798]                           muffled <- TRUE
[10:32:53.798]                           break
[10:32:53.798]                         }
[10:32:53.798]                       }
[10:32:53.798]                     }
[10:32:53.798]                     invisible(muffled)
[10:32:53.798]                   }
[10:32:53.798]                   muffleCondition(cond)
[10:32:53.798]                 })
[10:32:53.798]             }))
[10:32:53.798]             future::FutureResult(value = ...future.value$value, 
[10:32:53.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.798]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.798]                     ...future.globalenv.names))
[10:32:53.798]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.798]         }, condition = base::local({
[10:32:53.798]             c <- base::c
[10:32:53.798]             inherits <- base::inherits
[10:32:53.798]             invokeRestart <- base::invokeRestart
[10:32:53.798]             length <- base::length
[10:32:53.798]             list <- base::list
[10:32:53.798]             seq.int <- base::seq.int
[10:32:53.798]             signalCondition <- base::signalCondition
[10:32:53.798]             sys.calls <- base::sys.calls
[10:32:53.798]             `[[` <- base::`[[`
[10:32:53.798]             `+` <- base::`+`
[10:32:53.798]             `<<-` <- base::`<<-`
[10:32:53.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.798]                   3L)]
[10:32:53.798]             }
[10:32:53.798]             function(cond) {
[10:32:53.798]                 is_error <- inherits(cond, "error")
[10:32:53.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.798]                   NULL)
[10:32:53.798]                 if (is_error) {
[10:32:53.798]                   sessionInformation <- function() {
[10:32:53.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.798]                       search = base::search(), system = base::Sys.info())
[10:32:53.798]                   }
[10:32:53.798]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.798]                     cond$call), session = sessionInformation(), 
[10:32:53.798]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.798]                   signalCondition(cond)
[10:32:53.798]                 }
[10:32:53.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.798]                 "immediateCondition"))) {
[10:32:53.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.798]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.798]                   if (TRUE && !signal) {
[10:32:53.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.798]                     {
[10:32:53.798]                       inherits <- base::inherits
[10:32:53.798]                       invokeRestart <- base::invokeRestart
[10:32:53.798]                       is.null <- base::is.null
[10:32:53.798]                       muffled <- FALSE
[10:32:53.798]                       if (inherits(cond, "message")) {
[10:32:53.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.798]                         if (muffled) 
[10:32:53.798]                           invokeRestart("muffleMessage")
[10:32:53.798]                       }
[10:32:53.798]                       else if (inherits(cond, "warning")) {
[10:32:53.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.798]                         if (muffled) 
[10:32:53.798]                           invokeRestart("muffleWarning")
[10:32:53.798]                       }
[10:32:53.798]                       else if (inherits(cond, "condition")) {
[10:32:53.798]                         if (!is.null(pattern)) {
[10:32:53.798]                           computeRestarts <- base::computeRestarts
[10:32:53.798]                           grepl <- base::grepl
[10:32:53.798]                           restarts <- computeRestarts(cond)
[10:32:53.798]                           for (restart in restarts) {
[10:32:53.798]                             name <- restart$name
[10:32:53.798]                             if (is.null(name)) 
[10:32:53.798]                               next
[10:32:53.798]                             if (!grepl(pattern, name)) 
[10:32:53.798]                               next
[10:32:53.798]                             invokeRestart(restart)
[10:32:53.798]                             muffled <- TRUE
[10:32:53.798]                             break
[10:32:53.798]                           }
[10:32:53.798]                         }
[10:32:53.798]                       }
[10:32:53.798]                       invisible(muffled)
[10:32:53.798]                     }
[10:32:53.798]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.798]                   }
[10:32:53.798]                 }
[10:32:53.798]                 else {
[10:32:53.798]                   if (TRUE) {
[10:32:53.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.798]                     {
[10:32:53.798]                       inherits <- base::inherits
[10:32:53.798]                       invokeRestart <- base::invokeRestart
[10:32:53.798]                       is.null <- base::is.null
[10:32:53.798]                       muffled <- FALSE
[10:32:53.798]                       if (inherits(cond, "message")) {
[10:32:53.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.798]                         if (muffled) 
[10:32:53.798]                           invokeRestart("muffleMessage")
[10:32:53.798]                       }
[10:32:53.798]                       else if (inherits(cond, "warning")) {
[10:32:53.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.798]                         if (muffled) 
[10:32:53.798]                           invokeRestart("muffleWarning")
[10:32:53.798]                       }
[10:32:53.798]                       else if (inherits(cond, "condition")) {
[10:32:53.798]                         if (!is.null(pattern)) {
[10:32:53.798]                           computeRestarts <- base::computeRestarts
[10:32:53.798]                           grepl <- base::grepl
[10:32:53.798]                           restarts <- computeRestarts(cond)
[10:32:53.798]                           for (restart in restarts) {
[10:32:53.798]                             name <- restart$name
[10:32:53.798]                             if (is.null(name)) 
[10:32:53.798]                               next
[10:32:53.798]                             if (!grepl(pattern, name)) 
[10:32:53.798]                               next
[10:32:53.798]                             invokeRestart(restart)
[10:32:53.798]                             muffled <- TRUE
[10:32:53.798]                             break
[10:32:53.798]                           }
[10:32:53.798]                         }
[10:32:53.798]                       }
[10:32:53.798]                       invisible(muffled)
[10:32:53.798]                     }
[10:32:53.798]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.798]                   }
[10:32:53.798]                 }
[10:32:53.798]             }
[10:32:53.798]         }))
[10:32:53.798]     }, error = function(ex) {
[10:32:53.798]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.798]                 ...future.rng), started = ...future.startTime, 
[10:32:53.798]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.798]             version = "1.8"), class = "FutureResult")
[10:32:53.798]     }, finally = {
[10:32:53.798]         if (!identical(...future.workdir, getwd())) 
[10:32:53.798]             setwd(...future.workdir)
[10:32:53.798]         {
[10:32:53.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.798]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.798]             }
[10:32:53.798]             base::options(...future.oldOptions)
[10:32:53.798]             if (.Platform$OS.type == "windows") {
[10:32:53.798]                 old_names <- names(...future.oldEnvVars)
[10:32:53.798]                 envs <- base::Sys.getenv()
[10:32:53.798]                 names <- names(envs)
[10:32:53.798]                 common <- intersect(names, old_names)
[10:32:53.798]                 added <- setdiff(names, old_names)
[10:32:53.798]                 removed <- setdiff(old_names, names)
[10:32:53.798]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.798]                   envs[common]]
[10:32:53.798]                 NAMES <- toupper(changed)
[10:32:53.798]                 args <- list()
[10:32:53.798]                 for (kk in seq_along(NAMES)) {
[10:32:53.798]                   name <- changed[[kk]]
[10:32:53.798]                   NAME <- NAMES[[kk]]
[10:32:53.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.798]                     next
[10:32:53.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.798]                 }
[10:32:53.798]                 NAMES <- toupper(added)
[10:32:53.798]                 for (kk in seq_along(NAMES)) {
[10:32:53.798]                   name <- added[[kk]]
[10:32:53.798]                   NAME <- NAMES[[kk]]
[10:32:53.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.798]                     next
[10:32:53.798]                   args[[name]] <- ""
[10:32:53.798]                 }
[10:32:53.798]                 NAMES <- toupper(removed)
[10:32:53.798]                 for (kk in seq_along(NAMES)) {
[10:32:53.798]                   name <- removed[[kk]]
[10:32:53.798]                   NAME <- NAMES[[kk]]
[10:32:53.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.798]                     next
[10:32:53.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.798]                 }
[10:32:53.798]                 if (length(args) > 0) 
[10:32:53.798]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.798]             }
[10:32:53.798]             else {
[10:32:53.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.798]             }
[10:32:53.798]             {
[10:32:53.798]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.798]                   0L) {
[10:32:53.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.798]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.798]                   base::options(opts)
[10:32:53.798]                 }
[10:32:53.798]                 {
[10:32:53.798]                   {
[10:32:53.798]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.798]                     NULL
[10:32:53.798]                   }
[10:32:53.798]                   options(future.plan = NULL)
[10:32:53.798]                   if (is.na(NA_character_)) 
[10:32:53.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.798]                     .init = FALSE)
[10:32:53.798]                 }
[10:32:53.798]             }
[10:32:53.798]         }
[10:32:53.798]     })
[10:32:53.798]     if (TRUE) {
[10:32:53.798]         base::sink(type = "output", split = FALSE)
[10:32:53.798]         if (TRUE) {
[10:32:53.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.798]         }
[10:32:53.798]         else {
[10:32:53.798]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.798]         }
[10:32:53.798]         base::close(...future.stdout)
[10:32:53.798]         ...future.stdout <- NULL
[10:32:53.798]     }
[10:32:53.798]     ...future.result$conditions <- ...future.conditions
[10:32:53.798]     ...future.result$finished <- base::Sys.time()
[10:32:53.798]     ...future.result
[10:32:53.798] }
[10:32:53.801] requestCore(): workers = 2
[10:32:53.803] MulticoreFuture started
[10:32:53.803] - Launch lazy future ... done
[10:32:53.803] run() for ‘MulticoreFuture’ ... done
[10:32:53.804] getGlobalsAndPackages() ...
[10:32:53.804] Searching for globals...
[10:32:53.804] plan(): Setting new future strategy stack:
[10:32:53.804] List of future strategies:
[10:32:53.804] 1. sequential:
[10:32:53.804]    - args: function (..., envir = parent.frame())
[10:32:53.804]    - tweaked: FALSE
[10:32:53.804]    - call: NULL
[10:32:53.805] 
[10:32:53.805] Searching for globals ... DONE
[10:32:53.805] plan(): nbrOfWorkers() = 1
[10:32:53.805] - globals: [0] <none>
[10:32:53.805] getGlobalsAndPackages() ... DONE
[10:32:53.806] run() for ‘Future’ ...
[10:32:53.806] - state: ‘created’
[10:32:53.806] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.807] plan(): Setting new future strategy stack:
[10:32:53.807] List of future strategies:
[10:32:53.807] 1. multicore:
[10:32:53.807]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.807]    - tweaked: FALSE
[10:32:53.807]    - call: plan(strategy)
[10:32:53.811] plan(): nbrOfWorkers() = 2
[10:32:53.811] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.811] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.812]   - Field: ‘label’
[10:32:53.812]   - Field: ‘local’
[10:32:53.812]   - Field: ‘owner’
[10:32:53.812]   - Field: ‘envir’
[10:32:53.812]   - Field: ‘workers’
[10:32:53.812]   - Field: ‘packages’
[10:32:53.812]   - Field: ‘gc’
[10:32:53.813]   - Field: ‘job’
[10:32:53.813]   - Field: ‘conditions’
[10:32:53.813]   - Field: ‘expr’
[10:32:53.813]   - Field: ‘uuid’
[10:32:53.813]   - Field: ‘seed’
[10:32:53.813]   - Field: ‘version’
[10:32:53.813]   - Field: ‘result’
[10:32:53.814]   - Field: ‘asynchronous’
[10:32:53.814]   - Field: ‘calls’
[10:32:53.814]   - Field: ‘globals’
[10:32:53.814]   - Field: ‘stdout’
[10:32:53.814]   - Field: ‘earlySignal’
[10:32:53.814]   - Field: ‘lazy’
[10:32:53.814]   - Field: ‘state’
[10:32:53.815] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.815] - Launch lazy future ...
[10:32:53.815] Packages needed by the future expression (n = 0): <none>
[10:32:53.816] Packages needed by future strategies (n = 0): <none>
[10:32:53.816] {
[10:32:53.816]     {
[10:32:53.816]         {
[10:32:53.816]             ...future.startTime <- base::Sys.time()
[10:32:53.816]             {
[10:32:53.816]                 {
[10:32:53.816]                   {
[10:32:53.816]                     {
[10:32:53.816]                       base::local({
[10:32:53.816]                         has_future <- base::requireNamespace("future", 
[10:32:53.816]                           quietly = TRUE)
[10:32:53.816]                         if (has_future) {
[10:32:53.816]                           ns <- base::getNamespace("future")
[10:32:53.816]                           version <- ns[[".package"]][["version"]]
[10:32:53.816]                           if (is.null(version)) 
[10:32:53.816]                             version <- utils::packageVersion("future")
[10:32:53.816]                         }
[10:32:53.816]                         else {
[10:32:53.816]                           version <- NULL
[10:32:53.816]                         }
[10:32:53.816]                         if (!has_future || version < "1.8.0") {
[10:32:53.816]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.816]                             "", base::R.version$version.string), 
[10:32:53.816]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.816]                               "release", "version")], collapse = " "), 
[10:32:53.816]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.816]                             info)
[10:32:53.816]                           info <- base::paste(info, collapse = "; ")
[10:32:53.816]                           if (!has_future) {
[10:32:53.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.816]                               info)
[10:32:53.816]                           }
[10:32:53.816]                           else {
[10:32:53.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.816]                               info, version)
[10:32:53.816]                           }
[10:32:53.816]                           base::stop(msg)
[10:32:53.816]                         }
[10:32:53.816]                       })
[10:32:53.816]                     }
[10:32:53.816]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.816]                     base::options(mc.cores = 1L)
[10:32:53.816]                   }
[10:32:53.816]                   ...future.strategy.old <- future::plan("list")
[10:32:53.816]                   options(future.plan = NULL)
[10:32:53.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.816]                 }
[10:32:53.816]                 ...future.workdir <- getwd()
[10:32:53.816]             }
[10:32:53.816]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.816]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.816]         }
[10:32:53.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.816]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.816]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.816]             base::names(...future.oldOptions))
[10:32:53.816]     }
[10:32:53.816]     if (FALSE) {
[10:32:53.816]     }
[10:32:53.816]     else {
[10:32:53.816]         if (TRUE) {
[10:32:53.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.816]                 open = "w")
[10:32:53.816]         }
[10:32:53.816]         else {
[10:32:53.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.816]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.816]         }
[10:32:53.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.816]             base::sink(type = "output", split = FALSE)
[10:32:53.816]             base::close(...future.stdout)
[10:32:53.816]         }, add = TRUE)
[10:32:53.816]     }
[10:32:53.816]     ...future.frame <- base::sys.nframe()
[10:32:53.816]     ...future.conditions <- base::list()
[10:32:53.816]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.816]     if (FALSE) {
[10:32:53.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.816]     }
[10:32:53.816]     ...future.result <- base::tryCatch({
[10:32:53.816]         base::withCallingHandlers({
[10:32:53.816]             ...future.value <- base::withVisible(base::local({
[10:32:53.816]                 withCallingHandlers({
[10:32:53.816]                   NULL
[10:32:53.816]                 }, immediateCondition = function(cond) {
[10:32:53.816]                   save_rds <- function (object, pathname, ...) 
[10:32:53.816]                   {
[10:32:53.816]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.816]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.816]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.816]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.816]                         fi_tmp[["mtime"]])
[10:32:53.816]                     }
[10:32:53.816]                     tryCatch({
[10:32:53.816]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.816]                     }, error = function(ex) {
[10:32:53.816]                       msg <- conditionMessage(ex)
[10:32:53.816]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.816]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.816]                         fi_tmp[["mtime"]], msg)
[10:32:53.816]                       ex$message <- msg
[10:32:53.816]                       stop(ex)
[10:32:53.816]                     })
[10:32:53.816]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.816]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.816]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.816]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.816]                       fi <- file.info(pathname)
[10:32:53.816]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.816]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.816]                         fi[["size"]], fi[["mtime"]])
[10:32:53.816]                       stop(msg)
[10:32:53.816]                     }
[10:32:53.816]                     invisible(pathname)
[10:32:53.816]                   }
[10:32:53.816]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.816]                     rootPath = tempdir()) 
[10:32:53.816]                   {
[10:32:53.816]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.816]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.816]                       tmpdir = path, fileext = ".rds")
[10:32:53.816]                     save_rds(obj, file)
[10:32:53.816]                   }
[10:32:53.816]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.816]                   {
[10:32:53.816]                     inherits <- base::inherits
[10:32:53.816]                     invokeRestart <- base::invokeRestart
[10:32:53.816]                     is.null <- base::is.null
[10:32:53.816]                     muffled <- FALSE
[10:32:53.816]                     if (inherits(cond, "message")) {
[10:32:53.816]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.816]                       if (muffled) 
[10:32:53.816]                         invokeRestart("muffleMessage")
[10:32:53.816]                     }
[10:32:53.816]                     else if (inherits(cond, "warning")) {
[10:32:53.816]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.816]                       if (muffled) 
[10:32:53.816]                         invokeRestart("muffleWarning")
[10:32:53.816]                     }
[10:32:53.816]                     else if (inherits(cond, "condition")) {
[10:32:53.816]                       if (!is.null(pattern)) {
[10:32:53.816]                         computeRestarts <- base::computeRestarts
[10:32:53.816]                         grepl <- base::grepl
[10:32:53.816]                         restarts <- computeRestarts(cond)
[10:32:53.816]                         for (restart in restarts) {
[10:32:53.816]                           name <- restart$name
[10:32:53.816]                           if (is.null(name)) 
[10:32:53.816]                             next
[10:32:53.816]                           if (!grepl(pattern, name)) 
[10:32:53.816]                             next
[10:32:53.816]                           invokeRestart(restart)
[10:32:53.816]                           muffled <- TRUE
[10:32:53.816]                           break
[10:32:53.816]                         }
[10:32:53.816]                       }
[10:32:53.816]                     }
[10:32:53.816]                     invisible(muffled)
[10:32:53.816]                   }
[10:32:53.816]                   muffleCondition(cond)
[10:32:53.816]                 })
[10:32:53.816]             }))
[10:32:53.816]             future::FutureResult(value = ...future.value$value, 
[10:32:53.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.816]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.816]                     ...future.globalenv.names))
[10:32:53.816]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.816]         }, condition = base::local({
[10:32:53.816]             c <- base::c
[10:32:53.816]             inherits <- base::inherits
[10:32:53.816]             invokeRestart <- base::invokeRestart
[10:32:53.816]             length <- base::length
[10:32:53.816]             list <- base::list
[10:32:53.816]             seq.int <- base::seq.int
[10:32:53.816]             signalCondition <- base::signalCondition
[10:32:53.816]             sys.calls <- base::sys.calls
[10:32:53.816]             `[[` <- base::`[[`
[10:32:53.816]             `+` <- base::`+`
[10:32:53.816]             `<<-` <- base::`<<-`
[10:32:53.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.816]                   3L)]
[10:32:53.816]             }
[10:32:53.816]             function(cond) {
[10:32:53.816]                 is_error <- inherits(cond, "error")
[10:32:53.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.816]                   NULL)
[10:32:53.816]                 if (is_error) {
[10:32:53.816]                   sessionInformation <- function() {
[10:32:53.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.816]                       search = base::search(), system = base::Sys.info())
[10:32:53.816]                   }
[10:32:53.816]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.816]                     cond$call), session = sessionInformation(), 
[10:32:53.816]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.816]                   signalCondition(cond)
[10:32:53.816]                 }
[10:32:53.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.816]                 "immediateCondition"))) {
[10:32:53.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.816]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.816]                   if (TRUE && !signal) {
[10:32:53.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.816]                     {
[10:32:53.816]                       inherits <- base::inherits
[10:32:53.816]                       invokeRestart <- base::invokeRestart
[10:32:53.816]                       is.null <- base::is.null
[10:32:53.816]                       muffled <- FALSE
[10:32:53.816]                       if (inherits(cond, "message")) {
[10:32:53.816]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.816]                         if (muffled) 
[10:32:53.816]                           invokeRestart("muffleMessage")
[10:32:53.816]                       }
[10:32:53.816]                       else if (inherits(cond, "warning")) {
[10:32:53.816]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.816]                         if (muffled) 
[10:32:53.816]                           invokeRestart("muffleWarning")
[10:32:53.816]                       }
[10:32:53.816]                       else if (inherits(cond, "condition")) {
[10:32:53.816]                         if (!is.null(pattern)) {
[10:32:53.816]                           computeRestarts <- base::computeRestarts
[10:32:53.816]                           grepl <- base::grepl
[10:32:53.816]                           restarts <- computeRestarts(cond)
[10:32:53.816]                           for (restart in restarts) {
[10:32:53.816]                             name <- restart$name
[10:32:53.816]                             if (is.null(name)) 
[10:32:53.816]                               next
[10:32:53.816]                             if (!grepl(pattern, name)) 
[10:32:53.816]                               next
[10:32:53.816]                             invokeRestart(restart)
[10:32:53.816]                             muffled <- TRUE
[10:32:53.816]                             break
[10:32:53.816]                           }
[10:32:53.816]                         }
[10:32:53.816]                       }
[10:32:53.816]                       invisible(muffled)
[10:32:53.816]                     }
[10:32:53.816]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.816]                   }
[10:32:53.816]                 }
[10:32:53.816]                 else {
[10:32:53.816]                   if (TRUE) {
[10:32:53.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.816]                     {
[10:32:53.816]                       inherits <- base::inherits
[10:32:53.816]                       invokeRestart <- base::invokeRestart
[10:32:53.816]                       is.null <- base::is.null
[10:32:53.816]                       muffled <- FALSE
[10:32:53.816]                       if (inherits(cond, "message")) {
[10:32:53.816]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.816]                         if (muffled) 
[10:32:53.816]                           invokeRestart("muffleMessage")
[10:32:53.816]                       }
[10:32:53.816]                       else if (inherits(cond, "warning")) {
[10:32:53.816]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.816]                         if (muffled) 
[10:32:53.816]                           invokeRestart("muffleWarning")
[10:32:53.816]                       }
[10:32:53.816]                       else if (inherits(cond, "condition")) {
[10:32:53.816]                         if (!is.null(pattern)) {
[10:32:53.816]                           computeRestarts <- base::computeRestarts
[10:32:53.816]                           grepl <- base::grepl
[10:32:53.816]                           restarts <- computeRestarts(cond)
[10:32:53.816]                           for (restart in restarts) {
[10:32:53.816]                             name <- restart$name
[10:32:53.816]                             if (is.null(name)) 
[10:32:53.816]                               next
[10:32:53.816]                             if (!grepl(pattern, name)) 
[10:32:53.816]                               next
[10:32:53.816]                             invokeRestart(restart)
[10:32:53.816]                             muffled <- TRUE
[10:32:53.816]                             break
[10:32:53.816]                           }
[10:32:53.816]                         }
[10:32:53.816]                       }
[10:32:53.816]                       invisible(muffled)
[10:32:53.816]                     }
[10:32:53.816]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.816]                   }
[10:32:53.816]                 }
[10:32:53.816]             }
[10:32:53.816]         }))
[10:32:53.816]     }, error = function(ex) {
[10:32:53.816]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.816]                 ...future.rng), started = ...future.startTime, 
[10:32:53.816]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.816]             version = "1.8"), class = "FutureResult")
[10:32:53.816]     }, finally = {
[10:32:53.816]         if (!identical(...future.workdir, getwd())) 
[10:32:53.816]             setwd(...future.workdir)
[10:32:53.816]         {
[10:32:53.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.816]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.816]             }
[10:32:53.816]             base::options(...future.oldOptions)
[10:32:53.816]             if (.Platform$OS.type == "windows") {
[10:32:53.816]                 old_names <- names(...future.oldEnvVars)
[10:32:53.816]                 envs <- base::Sys.getenv()
[10:32:53.816]                 names <- names(envs)
[10:32:53.816]                 common <- intersect(names, old_names)
[10:32:53.816]                 added <- setdiff(names, old_names)
[10:32:53.816]                 removed <- setdiff(old_names, names)
[10:32:53.816]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.816]                   envs[common]]
[10:32:53.816]                 NAMES <- toupper(changed)
[10:32:53.816]                 args <- list()
[10:32:53.816]                 for (kk in seq_along(NAMES)) {
[10:32:53.816]                   name <- changed[[kk]]
[10:32:53.816]                   NAME <- NAMES[[kk]]
[10:32:53.816]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.816]                     next
[10:32:53.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.816]                 }
[10:32:53.816]                 NAMES <- toupper(added)
[10:32:53.816]                 for (kk in seq_along(NAMES)) {
[10:32:53.816]                   name <- added[[kk]]
[10:32:53.816]                   NAME <- NAMES[[kk]]
[10:32:53.816]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.816]                     next
[10:32:53.816]                   args[[name]] <- ""
[10:32:53.816]                 }
[10:32:53.816]                 NAMES <- toupper(removed)
[10:32:53.816]                 for (kk in seq_along(NAMES)) {
[10:32:53.816]                   name <- removed[[kk]]
[10:32:53.816]                   NAME <- NAMES[[kk]]
[10:32:53.816]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.816]                     next
[10:32:53.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.816]                 }
[10:32:53.816]                 if (length(args) > 0) 
[10:32:53.816]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.816]             }
[10:32:53.816]             else {
[10:32:53.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.816]             }
[10:32:53.816]             {
[10:32:53.816]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.816]                   0L) {
[10:32:53.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.816]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.816]                   base::options(opts)
[10:32:53.816]                 }
[10:32:53.816]                 {
[10:32:53.816]                   {
[10:32:53.816]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.816]                     NULL
[10:32:53.816]                   }
[10:32:53.816]                   options(future.plan = NULL)
[10:32:53.816]                   if (is.na(NA_character_)) 
[10:32:53.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.816]                     .init = FALSE)
[10:32:53.816]                 }
[10:32:53.816]             }
[10:32:53.816]         }
[10:32:53.816]     })
[10:32:53.816]     if (TRUE) {
[10:32:53.816]         base::sink(type = "output", split = FALSE)
[10:32:53.816]         if (TRUE) {
[10:32:53.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.816]         }
[10:32:53.816]         else {
[10:32:53.816]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.816]         }
[10:32:53.816]         base::close(...future.stdout)
[10:32:53.816]         ...future.stdout <- NULL
[10:32:53.816]     }
[10:32:53.816]     ...future.result$conditions <- ...future.conditions
[10:32:53.816]     ...future.result$finished <- base::Sys.time()
[10:32:53.816]     ...future.result
[10:32:53.816] }
[10:32:53.820] requestCore(): workers = 2
[10:32:53.823] MulticoreFuture started
[10:32:53.823] - Launch lazy future ... done
[10:32:53.823] run() for ‘MulticoreFuture’ ... done
[10:32:53.824] plan(): Setting new future strategy stack:
[10:32:53.824] getGlobalsAndPackages() ...
[10:32:53.824] Searching for globals...
[10:32:53.824] List of future strategies:
[10:32:53.824] 1. sequential:
[10:32:53.824]    - args: function (..., envir = parent.frame())
[10:32:53.824]    - tweaked: FALSE
[10:32:53.824]    - call: NULL
[10:32:53.825] plan(): nbrOfWorkers() = 1
[10:32:53.826] - globals found: [1] ‘{’
[10:32:53.826] Searching for globals ... DONE
[10:32:53.826] Resolving globals: FALSE
[10:32:53.827] 
[10:32:53.827] plan(): Setting new future strategy stack:
[10:32:53.827] 
[10:32:53.827] getGlobalsAndPackages() ... DONE
[10:32:53.827] List of future strategies:
[10:32:53.827] 1. multicore:
[10:32:53.827]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.827]    - tweaked: FALSE
[10:32:53.827]    - call: plan(strategy)
[10:32:53.828] run() for ‘Future’ ...
[10:32:53.828] - state: ‘created’
[10:32:53.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.832] plan(): nbrOfWorkers() = 2
[10:32:53.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.833]   - Field: ‘label’
[10:32:53.834]   - Field: ‘local’
[10:32:53.834]   - Field: ‘owner’
[10:32:53.834]   - Field: ‘envir’
[10:32:53.834]   - Field: ‘workers’
[10:32:53.834]   - Field: ‘packages’
[10:32:53.834]   - Field: ‘gc’
[10:32:53.835]   - Field: ‘job’
[10:32:53.835]   - Field: ‘conditions’
[10:32:53.835]   - Field: ‘expr’
[10:32:53.835]   - Field: ‘uuid’
[10:32:53.835]   - Field: ‘seed’
[10:32:53.835]   - Field: ‘version’
[10:32:53.836]   - Field: ‘result’
[10:32:53.836]   - Field: ‘asynchronous’
[10:32:53.836]   - Field: ‘calls’
[10:32:53.836]   - Field: ‘globals’
[10:32:53.836]   - Field: ‘stdout’
[10:32:53.836]   - Field: ‘earlySignal’
[10:32:53.837]   - Field: ‘lazy’
[10:32:53.837]   - Field: ‘state’
[10:32:53.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.837] - Launch lazy future ...
[10:32:53.838] Packages needed by the future expression (n = 0): <none>
[10:32:53.838] Packages needed by future strategies (n = 0): <none>
[10:32:53.839] {
[10:32:53.839]     {
[10:32:53.839]         {
[10:32:53.839]             ...future.startTime <- base::Sys.time()
[10:32:53.839]             {
[10:32:53.839]                 {
[10:32:53.839]                   {
[10:32:53.839]                     {
[10:32:53.839]                       base::local({
[10:32:53.839]                         has_future <- base::requireNamespace("future", 
[10:32:53.839]                           quietly = TRUE)
[10:32:53.839]                         if (has_future) {
[10:32:53.839]                           ns <- base::getNamespace("future")
[10:32:53.839]                           version <- ns[[".package"]][["version"]]
[10:32:53.839]                           if (is.null(version)) 
[10:32:53.839]                             version <- utils::packageVersion("future")
[10:32:53.839]                         }
[10:32:53.839]                         else {
[10:32:53.839]                           version <- NULL
[10:32:53.839]                         }
[10:32:53.839]                         if (!has_future || version < "1.8.0") {
[10:32:53.839]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.839]                             "", base::R.version$version.string), 
[10:32:53.839]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.839]                               "release", "version")], collapse = " "), 
[10:32:53.839]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.839]                             info)
[10:32:53.839]                           info <- base::paste(info, collapse = "; ")
[10:32:53.839]                           if (!has_future) {
[10:32:53.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.839]                               info)
[10:32:53.839]                           }
[10:32:53.839]                           else {
[10:32:53.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.839]                               info, version)
[10:32:53.839]                           }
[10:32:53.839]                           base::stop(msg)
[10:32:53.839]                         }
[10:32:53.839]                       })
[10:32:53.839]                     }
[10:32:53.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.839]                     base::options(mc.cores = 1L)
[10:32:53.839]                   }
[10:32:53.839]                   ...future.strategy.old <- future::plan("list")
[10:32:53.839]                   options(future.plan = NULL)
[10:32:53.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.839]                 }
[10:32:53.839]                 ...future.workdir <- getwd()
[10:32:53.839]             }
[10:32:53.839]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.839]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.839]         }
[10:32:53.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.839]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.839]             base::names(...future.oldOptions))
[10:32:53.839]     }
[10:32:53.839]     if (FALSE) {
[10:32:53.839]     }
[10:32:53.839]     else {
[10:32:53.839]         if (TRUE) {
[10:32:53.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.839]                 open = "w")
[10:32:53.839]         }
[10:32:53.839]         else {
[10:32:53.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.839]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.839]         }
[10:32:53.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.839]             base::sink(type = "output", split = FALSE)
[10:32:53.839]             base::close(...future.stdout)
[10:32:53.839]         }, add = TRUE)
[10:32:53.839]     }
[10:32:53.839]     ...future.frame <- base::sys.nframe()
[10:32:53.839]     ...future.conditions <- base::list()
[10:32:53.839]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.839]     if (FALSE) {
[10:32:53.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.839]     }
[10:32:53.839]     ...future.result <- base::tryCatch({
[10:32:53.839]         base::withCallingHandlers({
[10:32:53.839]             ...future.value <- base::withVisible(base::local({
[10:32:53.839]                 withCallingHandlers({
[10:32:53.839]                   {
[10:32:53.839]                     4
[10:32:53.839]                   }
[10:32:53.839]                 }, immediateCondition = function(cond) {
[10:32:53.839]                   save_rds <- function (object, pathname, ...) 
[10:32:53.839]                   {
[10:32:53.839]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.839]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.839]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.839]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.839]                         fi_tmp[["mtime"]])
[10:32:53.839]                     }
[10:32:53.839]                     tryCatch({
[10:32:53.839]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.839]                     }, error = function(ex) {
[10:32:53.839]                       msg <- conditionMessage(ex)
[10:32:53.839]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.839]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.839]                         fi_tmp[["mtime"]], msg)
[10:32:53.839]                       ex$message <- msg
[10:32:53.839]                       stop(ex)
[10:32:53.839]                     })
[10:32:53.839]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.839]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.839]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.839]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.839]                       fi <- file.info(pathname)
[10:32:53.839]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.839]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.839]                         fi[["size"]], fi[["mtime"]])
[10:32:53.839]                       stop(msg)
[10:32:53.839]                     }
[10:32:53.839]                     invisible(pathname)
[10:32:53.839]                   }
[10:32:53.839]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.839]                     rootPath = tempdir()) 
[10:32:53.839]                   {
[10:32:53.839]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.839]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.839]                       tmpdir = path, fileext = ".rds")
[10:32:53.839]                     save_rds(obj, file)
[10:32:53.839]                   }
[10:32:53.839]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.839]                   {
[10:32:53.839]                     inherits <- base::inherits
[10:32:53.839]                     invokeRestart <- base::invokeRestart
[10:32:53.839]                     is.null <- base::is.null
[10:32:53.839]                     muffled <- FALSE
[10:32:53.839]                     if (inherits(cond, "message")) {
[10:32:53.839]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.839]                       if (muffled) 
[10:32:53.839]                         invokeRestart("muffleMessage")
[10:32:53.839]                     }
[10:32:53.839]                     else if (inherits(cond, "warning")) {
[10:32:53.839]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.839]                       if (muffled) 
[10:32:53.839]                         invokeRestart("muffleWarning")
[10:32:53.839]                     }
[10:32:53.839]                     else if (inherits(cond, "condition")) {
[10:32:53.839]                       if (!is.null(pattern)) {
[10:32:53.839]                         computeRestarts <- base::computeRestarts
[10:32:53.839]                         grepl <- base::grepl
[10:32:53.839]                         restarts <- computeRestarts(cond)
[10:32:53.839]                         for (restart in restarts) {
[10:32:53.839]                           name <- restart$name
[10:32:53.839]                           if (is.null(name)) 
[10:32:53.839]                             next
[10:32:53.839]                           if (!grepl(pattern, name)) 
[10:32:53.839]                             next
[10:32:53.839]                           invokeRestart(restart)
[10:32:53.839]                           muffled <- TRUE
[10:32:53.839]                           break
[10:32:53.839]                         }
[10:32:53.839]                       }
[10:32:53.839]                     }
[10:32:53.839]                     invisible(muffled)
[10:32:53.839]                   }
[10:32:53.839]                   muffleCondition(cond)
[10:32:53.839]                 })
[10:32:53.839]             }))
[10:32:53.839]             future::FutureResult(value = ...future.value$value, 
[10:32:53.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.839]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.839]                     ...future.globalenv.names))
[10:32:53.839]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.839]         }, condition = base::local({
[10:32:53.839]             c <- base::c
[10:32:53.839]             inherits <- base::inherits
[10:32:53.839]             invokeRestart <- base::invokeRestart
[10:32:53.839]             length <- base::length
[10:32:53.839]             list <- base::list
[10:32:53.839]             seq.int <- base::seq.int
[10:32:53.839]             signalCondition <- base::signalCondition
[10:32:53.839]             sys.calls <- base::sys.calls
[10:32:53.839]             `[[` <- base::`[[`
[10:32:53.839]             `+` <- base::`+`
[10:32:53.839]             `<<-` <- base::`<<-`
[10:32:53.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.839]                   3L)]
[10:32:53.839]             }
[10:32:53.839]             function(cond) {
[10:32:53.839]                 is_error <- inherits(cond, "error")
[10:32:53.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.839]                   NULL)
[10:32:53.839]                 if (is_error) {
[10:32:53.839]                   sessionInformation <- function() {
[10:32:53.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.839]                       search = base::search(), system = base::Sys.info())
[10:32:53.839]                   }
[10:32:53.839]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.839]                     cond$call), session = sessionInformation(), 
[10:32:53.839]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.839]                   signalCondition(cond)
[10:32:53.839]                 }
[10:32:53.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.839]                 "immediateCondition"))) {
[10:32:53.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.839]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.839]                   if (TRUE && !signal) {
[10:32:53.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.839]                     {
[10:32:53.839]                       inherits <- base::inherits
[10:32:53.839]                       invokeRestart <- base::invokeRestart
[10:32:53.839]                       is.null <- base::is.null
[10:32:53.839]                       muffled <- FALSE
[10:32:53.839]                       if (inherits(cond, "message")) {
[10:32:53.839]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.839]                         if (muffled) 
[10:32:53.839]                           invokeRestart("muffleMessage")
[10:32:53.839]                       }
[10:32:53.839]                       else if (inherits(cond, "warning")) {
[10:32:53.839]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.839]                         if (muffled) 
[10:32:53.839]                           invokeRestart("muffleWarning")
[10:32:53.839]                       }
[10:32:53.839]                       else if (inherits(cond, "condition")) {
[10:32:53.839]                         if (!is.null(pattern)) {
[10:32:53.839]                           computeRestarts <- base::computeRestarts
[10:32:53.839]                           grepl <- base::grepl
[10:32:53.839]                           restarts <- computeRestarts(cond)
[10:32:53.839]                           for (restart in restarts) {
[10:32:53.839]                             name <- restart$name
[10:32:53.839]                             if (is.null(name)) 
[10:32:53.839]                               next
[10:32:53.839]                             if (!grepl(pattern, name)) 
[10:32:53.839]                               next
[10:32:53.839]                             invokeRestart(restart)
[10:32:53.839]                             muffled <- TRUE
[10:32:53.839]                             break
[10:32:53.839]                           }
[10:32:53.839]                         }
[10:32:53.839]                       }
[10:32:53.839]                       invisible(muffled)
[10:32:53.839]                     }
[10:32:53.839]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.839]                   }
[10:32:53.839]                 }
[10:32:53.839]                 else {
[10:32:53.839]                   if (TRUE) {
[10:32:53.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.839]                     {
[10:32:53.839]                       inherits <- base::inherits
[10:32:53.839]                       invokeRestart <- base::invokeRestart
[10:32:53.839]                       is.null <- base::is.null
[10:32:53.839]                       muffled <- FALSE
[10:32:53.839]                       if (inherits(cond, "message")) {
[10:32:53.839]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.839]                         if (muffled) 
[10:32:53.839]                           invokeRestart("muffleMessage")
[10:32:53.839]                       }
[10:32:53.839]                       else if (inherits(cond, "warning")) {
[10:32:53.839]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.839]                         if (muffled) 
[10:32:53.839]                           invokeRestart("muffleWarning")
[10:32:53.839]                       }
[10:32:53.839]                       else if (inherits(cond, "condition")) {
[10:32:53.839]                         if (!is.null(pattern)) {
[10:32:53.839]                           computeRestarts <- base::computeRestarts
[10:32:53.839]                           grepl <- base::grepl
[10:32:53.839]                           restarts <- computeRestarts(cond)
[10:32:53.839]                           for (restart in restarts) {
[10:32:53.839]                             name <- restart$name
[10:32:53.839]                             if (is.null(name)) 
[10:32:53.839]                               next
[10:32:53.839]                             if (!grepl(pattern, name)) 
[10:32:53.839]                               next
[10:32:53.839]                             invokeRestart(restart)
[10:32:53.839]                             muffled <- TRUE
[10:32:53.839]                             break
[10:32:53.839]                           }
[10:32:53.839]                         }
[10:32:53.839]                       }
[10:32:53.839]                       invisible(muffled)
[10:32:53.839]                     }
[10:32:53.839]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.839]                   }
[10:32:53.839]                 }
[10:32:53.839]             }
[10:32:53.839]         }))
[10:32:53.839]     }, error = function(ex) {
[10:32:53.839]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.839]                 ...future.rng), started = ...future.startTime, 
[10:32:53.839]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.839]             version = "1.8"), class = "FutureResult")
[10:32:53.839]     }, finally = {
[10:32:53.839]         if (!identical(...future.workdir, getwd())) 
[10:32:53.839]             setwd(...future.workdir)
[10:32:53.839]         {
[10:32:53.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.839]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.839]             }
[10:32:53.839]             base::options(...future.oldOptions)
[10:32:53.839]             if (.Platform$OS.type == "windows") {
[10:32:53.839]                 old_names <- names(...future.oldEnvVars)
[10:32:53.839]                 envs <- base::Sys.getenv()
[10:32:53.839]                 names <- names(envs)
[10:32:53.839]                 common <- intersect(names, old_names)
[10:32:53.839]                 added <- setdiff(names, old_names)
[10:32:53.839]                 removed <- setdiff(old_names, names)
[10:32:53.839]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.839]                   envs[common]]
[10:32:53.839]                 NAMES <- toupper(changed)
[10:32:53.839]                 args <- list()
[10:32:53.839]                 for (kk in seq_along(NAMES)) {
[10:32:53.839]                   name <- changed[[kk]]
[10:32:53.839]                   NAME <- NAMES[[kk]]
[10:32:53.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.839]                     next
[10:32:53.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.839]                 }
[10:32:53.839]                 NAMES <- toupper(added)
[10:32:53.839]                 for (kk in seq_along(NAMES)) {
[10:32:53.839]                   name <- added[[kk]]
[10:32:53.839]                   NAME <- NAMES[[kk]]
[10:32:53.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.839]                     next
[10:32:53.839]                   args[[name]] <- ""
[10:32:53.839]                 }
[10:32:53.839]                 NAMES <- toupper(removed)
[10:32:53.839]                 for (kk in seq_along(NAMES)) {
[10:32:53.839]                   name <- removed[[kk]]
[10:32:53.839]                   NAME <- NAMES[[kk]]
[10:32:53.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.839]                     next
[10:32:53.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.839]                 }
[10:32:53.839]                 if (length(args) > 0) 
[10:32:53.839]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.839]             }
[10:32:53.839]             else {
[10:32:53.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.839]             }
[10:32:53.839]             {
[10:32:53.839]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.839]                   0L) {
[10:32:53.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.839]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.839]                   base::options(opts)
[10:32:53.839]                 }
[10:32:53.839]                 {
[10:32:53.839]                   {
[10:32:53.839]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.839]                     NULL
[10:32:53.839]                   }
[10:32:53.839]                   options(future.plan = NULL)
[10:32:53.839]                   if (is.na(NA_character_)) 
[10:32:53.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.839]                     .init = FALSE)
[10:32:53.839]                 }
[10:32:53.839]             }
[10:32:53.839]         }
[10:32:53.839]     })
[10:32:53.839]     if (TRUE) {
[10:32:53.839]         base::sink(type = "output", split = FALSE)
[10:32:53.839]         if (TRUE) {
[10:32:53.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.839]         }
[10:32:53.839]         else {
[10:32:53.839]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.839]         }
[10:32:53.839]         base::close(...future.stdout)
[10:32:53.839]         ...future.stdout <- NULL
[10:32:53.839]     }
[10:32:53.839]     ...future.result$conditions <- ...future.conditions
[10:32:53.839]     ...future.result$finished <- base::Sys.time()
[10:32:53.839]     ...future.result
[10:32:53.839] }
[10:32:53.842] requestCore(): workers = 2
[10:32:53.843] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:53.854] result() for MulticoreFuture ...
[10:32:53.855] result() for MulticoreFuture ...
[10:32:53.855] result() for MulticoreFuture ... done
[10:32:53.855] result() for MulticoreFuture ... done
[10:32:53.855] result() for MulticoreFuture ...
[10:32:53.855] result() for MulticoreFuture ... done
[10:32:53.858] MulticoreFuture started
[10:32:53.858] - Launch lazy future ... done
[10:32:53.859] run() for ‘MulticoreFuture’ ... done
[10:32:53.859] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5652d13e6de8> 
[10:32:53.860] List of future strategies:
[10:32:53.860] 1. sequential:
[10:32:53.860]    - args: function (..., envir = parent.frame())
[10:32:53.860]    - tweaked: FALSE
[10:32:53.860]    - call: NULL
[10:32:53.861] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5652d1822e10> 
 - attr(*, "dim.")=[10:32:53.864] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ :[10:32:53.864] List of future strategies:
[10:32:53.864] 1. multicore:
[10:32:53.864]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.864]    - tweaked: FALSE
[10:32:53.864]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:32:53.870] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:53.874] resolve() on list environment ...
[10:32:53.874]  recursive: 0
[10:32:53.875]  length: 6
[10:32:53.876]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:53.876] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.876] - nx: 6
[10:32:53.876] - relay: TRUE
[10:32:53.876] - stdout: TRUE
[10:32:53.876] - signal: TRUE
[10:32:53.877] - resignal: FALSE
[10:32:53.877] - force: TRUE
[10:32:53.877] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.877] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.877]  - until=2
[10:32:53.877]  - relaying element #2
[10:32:53.877] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.878] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.878] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.878]  length: 5 (resolved future 1)
[10:32:53.878] Future #2
[10:32:53.878] result() for MulticoreFuture ...
[10:32:53.878] result() for MulticoreFuture ... done
[10:32:53.878] result() for MulticoreFuture ...
[10:32:53.879] result() for MulticoreFuture ... done
[10:32:53.879] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:53.879] - nx: 6
[10:32:53.879] - relay: TRUE
[10:32:53.879] - stdout: TRUE
[10:32:53.879] - signal: TRUE
[10:32:53.879] - resignal: FALSE
[10:32:53.879] - force: TRUE
[10:32:53.880] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.880] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.880]  - until=2
[10:32:53.880]  - relaying element #2
[10:32:53.880] result() for MulticoreFuture ...
[10:32:53.880] result() for MulticoreFuture ... done
[10:32:53.880] result() for MulticoreFuture ...
[10:32:53.880] result() for MulticoreFuture ... done
[10:32:53.881] result() for MulticoreFuture ...
[10:32:53.881] result() for MulticoreFuture ... done
[10:32:53.881] result() for MulticoreFuture ...
[10:32:53.881] result() for MulticoreFuture ... done
[10:32:53.881] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.881] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.881] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:53.882]  length: 4 (resolved future 2)
[10:32:53.882] Future #3
[10:32:53.882] result() for MulticoreFuture ...
[10:32:53.883] result() for MulticoreFuture ...
[10:32:53.883] result() for MulticoreFuture ... done
[10:32:53.883] result() for MulticoreFuture ... done
[10:32:53.883] result() for MulticoreFuture ...
[10:32:53.883] result() for MulticoreFuture ... done
[10:32:53.884] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:53.884] - nx: 6
[10:32:53.884] - relay: TRUE
[10:32:53.884] - stdout: TRUE
[10:32:53.884] - signal: TRUE
[10:32:53.884] - resignal: FALSE
[10:32:53.884] - force: TRUE
[10:32:53.884] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.885] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:53.885]  - until=3
[10:32:53.885]  - relaying element #3
[10:32:53.885] result() for MulticoreFuture ...
[10:32:53.885] result() for MulticoreFuture ... done
[10:32:53.885] result() for MulticoreFuture ...
[10:32:53.885] result() for MulticoreFuture ... done
[10:32:53.886] result() for MulticoreFuture ...
[10:32:53.886] result() for MulticoreFuture ... done
[10:32:53.886] result() for MulticoreFuture ...
[10:32:53.886] result() for MulticoreFuture ... done
[10:32:53.886] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.886] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.886] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:53.887]  length: 3 (resolved future 3)
[10:32:53.887] Future #4
[10:32:53.887] result() for MulticoreFuture ...
[10:32:53.888] result() for MulticoreFuture ...
[10:32:53.888] result() for MulticoreFuture ... done
[10:32:53.888] result() for MulticoreFuture ... done
[10:32:53.888] result() for MulticoreFuture ...
[10:32:53.888] result() for MulticoreFuture ... done
[10:32:53.889] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:53.889] - nx: 6
[10:32:53.889] - relay: TRUE
[10:32:53.889] - stdout: TRUE
[10:32:53.889] - signal: TRUE
[10:32:53.889] - resignal: FALSE
[10:32:53.890] - force: TRUE
[10:32:53.890] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.890] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:53.890]  - until=4
[10:32:53.890]  - relaying element #4
[10:32:53.890] result() for MulticoreFuture ...
[10:32:53.891] result() for MulticoreFuture ... done
[10:32:53.891] result() for MulticoreFuture ...
[10:32:53.891] result() for MulticoreFuture ... done
[10:32:53.891] result() for MulticoreFuture ...
[10:32:53.891] result() for MulticoreFuture ... done
[10:32:53.891] result() for MulticoreFuture ...
[10:32:53.892] result() for MulticoreFuture ... done
[10:32:53.892] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.892] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.892] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:53.892]  length: 2 (resolved future 4)
[10:32:53.892] signalConditionsASAP(NULL, pos=5) ...
[10:32:53.892] - nx: 6
[10:32:53.892] - relay: TRUE
[10:32:53.892] - stdout: TRUE
[10:32:53.892] - signal: TRUE
[10:32:53.893] - resignal: FALSE
[10:32:53.893] - force: TRUE
[10:32:53.893] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.893] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.893]  - until=6
[10:32:53.893]  - relaying element #6
[10:32:53.893] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:53.893] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.894] signalConditionsASAP(NULL, pos=5) ... done
[10:32:53.894]  length: 1 (resolved future 5)
[10:32:53.894] signalConditionsASAP(numeric, pos=6) ...
[10:32:53.894] - nx: 6
[10:32:53.894] - relay: TRUE
[10:32:53.894] - stdout: TRUE
[10:32:53.894] - signal: TRUE
[10:32:53.894] - resignal: FALSE
[10:32:53.894] - force: TRUE
[10:32:53.894] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:53.895] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.895]  - until=6
[10:32:53.895] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.895] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.895] signalConditionsASAP(numeric, pos=6) ... done
[10:32:53.895]  length: 0 (resolved future 6)
[10:32:53.895] Relaying remaining futures
[10:32:53.895] signalConditionsASAP(NULL, pos=0) ...
[10:32:53.896] - nx: 6
[10:32:53.896] - relay: TRUE
[10:32:53.896] - stdout: TRUE
[10:32:53.896] - signal: TRUE
[10:32:53.896] - resignal: FALSE
[10:32:53.896] - force: TRUE
[10:32:53.896] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.896] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:53.896] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:53.896] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:53.897] signalConditionsASAP(NULL, pos=0) ... done
[10:32:53.897] resolve() on list environment ... DONE
[10:32:53.897] result() for MulticoreFuture ...
[10:32:53.897] result() for MulticoreFuture ... done
[10:32:53.897] result() for MulticoreFuture ...
[10:32:53.897] result() for MulticoreFuture ... done
[10:32:53.897] result() for MulticoreFuture ...
[10:32:53.897] result() for MulticoreFuture ... done
[10:32:53.898] result() for MulticoreFuture ...
[10:32:53.898] result() for MulticoreFuture ... done
[10:32:53.898] result() for MulticoreFuture ...
[10:32:53.898] result() for MulticoreFuture ... done
[10:32:53.898] result() for MulticoreFuture ...
[10:32:53.898] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d1ee2278> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:32:53.900] getGlobalsAndPackages() ...
[10:32:53.900] Searching for globals...
[10:32:53.901] 
[10:32:53.901] Searching for globals ... DONE
[10:32:53.901] - globals: [0] <none>
[10:32:53.901] getGlobalsAndPackages() ... DONE
[10:32:53.902] run() for ‘Future’ ...
[10:32:53.902] - state: ‘created’
[10:32:53.902] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.906] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.906]   - Field: ‘label’
[10:32:53.907]   - Field: ‘local’
[10:32:53.907]   - Field: ‘owner’
[10:32:53.907]   - Field: ‘envir’
[10:32:53.907]   - Field: ‘workers’
[10:32:53.907]   - Field: ‘packages’
[10:32:53.907]   - Field: ‘gc’
[10:32:53.907]   - Field: ‘job’
[10:32:53.907]   - Field: ‘conditions’
[10:32:53.907]   - Field: ‘expr’
[10:32:53.908]   - Field: ‘uuid’
[10:32:53.908]   - Field: ‘seed’
[10:32:53.908]   - Field: ‘version’
[10:32:53.908]   - Field: ‘result’
[10:32:53.908]   - Field: ‘asynchronous’
[10:32:53.908]   - Field: ‘calls’
[10:32:53.908]   - Field: ‘globals’
[10:32:53.908]   - Field: ‘stdout’
[10:32:53.908]   - Field: ‘earlySignal’
[10:32:53.909]   - Field: ‘lazy’
[10:32:53.909]   - Field: ‘state’
[10:32:53.909] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.909] - Launch lazy future ...
[10:32:53.909] Packages needed by the future expression (n = 0): <none>
[10:32:53.909] Packages needed by future strategies (n = 0): <none>
[10:32:53.910] {
[10:32:53.910]     {
[10:32:53.910]         {
[10:32:53.910]             ...future.startTime <- base::Sys.time()
[10:32:53.910]             {
[10:32:53.910]                 {
[10:32:53.910]                   {
[10:32:53.910]                     {
[10:32:53.910]                       base::local({
[10:32:53.910]                         has_future <- base::requireNamespace("future", 
[10:32:53.910]                           quietly = TRUE)
[10:32:53.910]                         if (has_future) {
[10:32:53.910]                           ns <- base::getNamespace("future")
[10:32:53.910]                           version <- ns[[".package"]][["version"]]
[10:32:53.910]                           if (is.null(version)) 
[10:32:53.910]                             version <- utils::packageVersion("future")
[10:32:53.910]                         }
[10:32:53.910]                         else {
[10:32:53.910]                           version <- NULL
[10:32:53.910]                         }
[10:32:53.910]                         if (!has_future || version < "1.8.0") {
[10:32:53.910]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.910]                             "", base::R.version$version.string), 
[10:32:53.910]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.910]                               "release", "version")], collapse = " "), 
[10:32:53.910]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.910]                             info)
[10:32:53.910]                           info <- base::paste(info, collapse = "; ")
[10:32:53.910]                           if (!has_future) {
[10:32:53.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.910]                               info)
[10:32:53.910]                           }
[10:32:53.910]                           else {
[10:32:53.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.910]                               info, version)
[10:32:53.910]                           }
[10:32:53.910]                           base::stop(msg)
[10:32:53.910]                         }
[10:32:53.910]                       })
[10:32:53.910]                     }
[10:32:53.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.910]                     base::options(mc.cores = 1L)
[10:32:53.910]                   }
[10:32:53.910]                   ...future.strategy.old <- future::plan("list")
[10:32:53.910]                   options(future.plan = NULL)
[10:32:53.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.910]                 }
[10:32:53.910]                 ...future.workdir <- getwd()
[10:32:53.910]             }
[10:32:53.910]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.910]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.910]         }
[10:32:53.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.910]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.910]             base::names(...future.oldOptions))
[10:32:53.910]     }
[10:32:53.910]     if (FALSE) {
[10:32:53.910]     }
[10:32:53.910]     else {
[10:32:53.910]         if (TRUE) {
[10:32:53.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.910]                 open = "w")
[10:32:53.910]         }
[10:32:53.910]         else {
[10:32:53.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.910]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.910]         }
[10:32:53.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.910]             base::sink(type = "output", split = FALSE)
[10:32:53.910]             base::close(...future.stdout)
[10:32:53.910]         }, add = TRUE)
[10:32:53.910]     }
[10:32:53.910]     ...future.frame <- base::sys.nframe()
[10:32:53.910]     ...future.conditions <- base::list()
[10:32:53.910]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.910]     if (FALSE) {
[10:32:53.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.910]     }
[10:32:53.910]     ...future.result <- base::tryCatch({
[10:32:53.910]         base::withCallingHandlers({
[10:32:53.910]             ...future.value <- base::withVisible(base::local({
[10:32:53.910]                 withCallingHandlers({
[10:32:53.910]                   2
[10:32:53.910]                 }, immediateCondition = function(cond) {
[10:32:53.910]                   save_rds <- function (object, pathname, ...) 
[10:32:53.910]                   {
[10:32:53.910]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.910]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.910]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.910]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.910]                         fi_tmp[["mtime"]])
[10:32:53.910]                     }
[10:32:53.910]                     tryCatch({
[10:32:53.910]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.910]                     }, error = function(ex) {
[10:32:53.910]                       msg <- conditionMessage(ex)
[10:32:53.910]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.910]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.910]                         fi_tmp[["mtime"]], msg)
[10:32:53.910]                       ex$message <- msg
[10:32:53.910]                       stop(ex)
[10:32:53.910]                     })
[10:32:53.910]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.910]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.910]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.910]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.910]                       fi <- file.info(pathname)
[10:32:53.910]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.910]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.910]                         fi[["size"]], fi[["mtime"]])
[10:32:53.910]                       stop(msg)
[10:32:53.910]                     }
[10:32:53.910]                     invisible(pathname)
[10:32:53.910]                   }
[10:32:53.910]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.910]                     rootPath = tempdir()) 
[10:32:53.910]                   {
[10:32:53.910]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.910]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.910]                       tmpdir = path, fileext = ".rds")
[10:32:53.910]                     save_rds(obj, file)
[10:32:53.910]                   }
[10:32:53.910]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.910]                   {
[10:32:53.910]                     inherits <- base::inherits
[10:32:53.910]                     invokeRestart <- base::invokeRestart
[10:32:53.910]                     is.null <- base::is.null
[10:32:53.910]                     muffled <- FALSE
[10:32:53.910]                     if (inherits(cond, "message")) {
[10:32:53.910]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.910]                       if (muffled) 
[10:32:53.910]                         invokeRestart("muffleMessage")
[10:32:53.910]                     }
[10:32:53.910]                     else if (inherits(cond, "warning")) {
[10:32:53.910]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.910]                       if (muffled) 
[10:32:53.910]                         invokeRestart("muffleWarning")
[10:32:53.910]                     }
[10:32:53.910]                     else if (inherits(cond, "condition")) {
[10:32:53.910]                       if (!is.null(pattern)) {
[10:32:53.910]                         computeRestarts <- base::computeRestarts
[10:32:53.910]                         grepl <- base::grepl
[10:32:53.910]                         restarts <- computeRestarts(cond)
[10:32:53.910]                         for (restart in restarts) {
[10:32:53.910]                           name <- restart$name
[10:32:53.910]                           if (is.null(name)) 
[10:32:53.910]                             next
[10:32:53.910]                           if (!grepl(pattern, name)) 
[10:32:53.910]                             next
[10:32:53.910]                           invokeRestart(restart)
[10:32:53.910]                           muffled <- TRUE
[10:32:53.910]                           break
[10:32:53.910]                         }
[10:32:53.910]                       }
[10:32:53.910]                     }
[10:32:53.910]                     invisible(muffled)
[10:32:53.910]                   }
[10:32:53.910]                   muffleCondition(cond)
[10:32:53.910]                 })
[10:32:53.910]             }))
[10:32:53.910]             future::FutureResult(value = ...future.value$value, 
[10:32:53.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.910]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.910]                     ...future.globalenv.names))
[10:32:53.910]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.910]         }, condition = base::local({
[10:32:53.910]             c <- base::c
[10:32:53.910]             inherits <- base::inherits
[10:32:53.910]             invokeRestart <- base::invokeRestart
[10:32:53.910]             length <- base::length
[10:32:53.910]             list <- base::list
[10:32:53.910]             seq.int <- base::seq.int
[10:32:53.910]             signalCondition <- base::signalCondition
[10:32:53.910]             sys.calls <- base::sys.calls
[10:32:53.910]             `[[` <- base::`[[`
[10:32:53.910]             `+` <- base::`+`
[10:32:53.910]             `<<-` <- base::`<<-`
[10:32:53.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.910]                   3L)]
[10:32:53.910]             }
[10:32:53.910]             function(cond) {
[10:32:53.910]                 is_error <- inherits(cond, "error")
[10:32:53.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.910]                   NULL)
[10:32:53.910]                 if (is_error) {
[10:32:53.910]                   sessionInformation <- function() {
[10:32:53.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.910]                       search = base::search(), system = base::Sys.info())
[10:32:53.910]                   }
[10:32:53.910]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.910]                     cond$call), session = sessionInformation(), 
[10:32:53.910]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.910]                   signalCondition(cond)
[10:32:53.910]                 }
[10:32:53.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.910]                 "immediateCondition"))) {
[10:32:53.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.910]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.910]                   if (TRUE && !signal) {
[10:32:53.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.910]                     {
[10:32:53.910]                       inherits <- base::inherits
[10:32:53.910]                       invokeRestart <- base::invokeRestart
[10:32:53.910]                       is.null <- base::is.null
[10:32:53.910]                       muffled <- FALSE
[10:32:53.910]                       if (inherits(cond, "message")) {
[10:32:53.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.910]                         if (muffled) 
[10:32:53.910]                           invokeRestart("muffleMessage")
[10:32:53.910]                       }
[10:32:53.910]                       else if (inherits(cond, "warning")) {
[10:32:53.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.910]                         if (muffled) 
[10:32:53.910]                           invokeRestart("muffleWarning")
[10:32:53.910]                       }
[10:32:53.910]                       else if (inherits(cond, "condition")) {
[10:32:53.910]                         if (!is.null(pattern)) {
[10:32:53.910]                           computeRestarts <- base::computeRestarts
[10:32:53.910]                           grepl <- base::grepl
[10:32:53.910]                           restarts <- computeRestarts(cond)
[10:32:53.910]                           for (restart in restarts) {
[10:32:53.910]                             name <- restart$name
[10:32:53.910]                             if (is.null(name)) 
[10:32:53.910]                               next
[10:32:53.910]                             if (!grepl(pattern, name)) 
[10:32:53.910]                               next
[10:32:53.910]                             invokeRestart(restart)
[10:32:53.910]                             muffled <- TRUE
[10:32:53.910]                             break
[10:32:53.910]                           }
[10:32:53.910]                         }
[10:32:53.910]                       }
[10:32:53.910]                       invisible(muffled)
[10:32:53.910]                     }
[10:32:53.910]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.910]                   }
[10:32:53.910]                 }
[10:32:53.910]                 else {
[10:32:53.910]                   if (TRUE) {
[10:32:53.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.910]                     {
[10:32:53.910]                       inherits <- base::inherits
[10:32:53.910]                       invokeRestart <- base::invokeRestart
[10:32:53.910]                       is.null <- base::is.null
[10:32:53.910]                       muffled <- FALSE
[10:32:53.910]                       if (inherits(cond, "message")) {
[10:32:53.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.910]                         if (muffled) 
[10:32:53.910]                           invokeRestart("muffleMessage")
[10:32:53.910]                       }
[10:32:53.910]                       else if (inherits(cond, "warning")) {
[10:32:53.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.910]                         if (muffled) 
[10:32:53.910]                           invokeRestart("muffleWarning")
[10:32:53.910]                       }
[10:32:53.910]                       else if (inherits(cond, "condition")) {
[10:32:53.910]                         if (!is.null(pattern)) {
[10:32:53.910]                           computeRestarts <- base::computeRestarts
[10:32:53.910]                           grepl <- base::grepl
[10:32:53.910]                           restarts <- computeRestarts(cond)
[10:32:53.910]                           for (restart in restarts) {
[10:32:53.910]                             name <- restart$name
[10:32:53.910]                             if (is.null(name)) 
[10:32:53.910]                               next
[10:32:53.910]                             if (!grepl(pattern, name)) 
[10:32:53.910]                               next
[10:32:53.910]                             invokeRestart(restart)
[10:32:53.910]                             muffled <- TRUE
[10:32:53.910]                             break
[10:32:53.910]                           }
[10:32:53.910]                         }
[10:32:53.910]                       }
[10:32:53.910]                       invisible(muffled)
[10:32:53.910]                     }
[10:32:53.910]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.910]                   }
[10:32:53.910]                 }
[10:32:53.910]             }
[10:32:53.910]         }))
[10:32:53.910]     }, error = function(ex) {
[10:32:53.910]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.910]                 ...future.rng), started = ...future.startTime, 
[10:32:53.910]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.910]             version = "1.8"), class = "FutureResult")
[10:32:53.910]     }, finally = {
[10:32:53.910]         if (!identical(...future.workdir, getwd())) 
[10:32:53.910]             setwd(...future.workdir)
[10:32:53.910]         {
[10:32:53.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.910]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.910]             }
[10:32:53.910]             base::options(...future.oldOptions)
[10:32:53.910]             if (.Platform$OS.type == "windows") {
[10:32:53.910]                 old_names <- names(...future.oldEnvVars)
[10:32:53.910]                 envs <- base::Sys.getenv()
[10:32:53.910]                 names <- names(envs)
[10:32:53.910]                 common <- intersect(names, old_names)
[10:32:53.910]                 added <- setdiff(names, old_names)
[10:32:53.910]                 removed <- setdiff(old_names, names)
[10:32:53.910]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.910]                   envs[common]]
[10:32:53.910]                 NAMES <- toupper(changed)
[10:32:53.910]                 args <- list()
[10:32:53.910]                 for (kk in seq_along(NAMES)) {
[10:32:53.910]                   name <- changed[[kk]]
[10:32:53.910]                   NAME <- NAMES[[kk]]
[10:32:53.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.910]                     next
[10:32:53.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.910]                 }
[10:32:53.910]                 NAMES <- toupper(added)
[10:32:53.910]                 for (kk in seq_along(NAMES)) {
[10:32:53.910]                   name <- added[[kk]]
[10:32:53.910]                   NAME <- NAMES[[kk]]
[10:32:53.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.910]                     next
[10:32:53.910]                   args[[name]] <- ""
[10:32:53.910]                 }
[10:32:53.910]                 NAMES <- toupper(removed)
[10:32:53.910]                 for (kk in seq_along(NAMES)) {
[10:32:53.910]                   name <- removed[[kk]]
[10:32:53.910]                   NAME <- NAMES[[kk]]
[10:32:53.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.910]                     next
[10:32:53.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.910]                 }
[10:32:53.910]                 if (length(args) > 0) 
[10:32:53.910]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.910]             }
[10:32:53.910]             else {
[10:32:53.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.910]             }
[10:32:53.910]             {
[10:32:53.910]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.910]                   0L) {
[10:32:53.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.910]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.910]                   base::options(opts)
[10:32:53.910]                 }
[10:32:53.910]                 {
[10:32:53.910]                   {
[10:32:53.910]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.910]                     NULL
[10:32:53.910]                   }
[10:32:53.910]                   options(future.plan = NULL)
[10:32:53.910]                   if (is.na(NA_character_)) 
[10:32:53.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.910]                     .init = FALSE)
[10:32:53.910]                 }
[10:32:53.910]             }
[10:32:53.910]         }
[10:32:53.910]     })
[10:32:53.910]     if (TRUE) {
[10:32:53.910]         base::sink(type = "output", split = FALSE)
[10:32:53.910]         if (TRUE) {
[10:32:53.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.910]         }
[10:32:53.910]         else {
[10:32:53.910]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.910]         }
[10:32:53.910]         base::close(...future.stdout)
[10:32:53.910]         ...future.stdout <- NULL
[10:32:53.910]     }
[10:32:53.910]     ...future.result$conditions <- ...future.conditions
[10:32:53.910]     ...future.result$finished <- base::Sys.time()
[10:32:53.910]     ...future.result
[10:32:53.910] }
[10:32:53.913] requestCore(): workers = 2
[10:32:53.915] MulticoreFuture started
[10:32:53.915] - Launch lazy future ... done
[10:32:53.915] run() for ‘MulticoreFuture’ ... done
[10:32:53.916] getGlobalsAndPackages() ...
[10:32:53.916] Searching for globals...
[10:32:53.916] plan(): Setting new future strategy stack:
[10:32:53.917] 
[10:32:53.917] Searching for globals ... DONE
[10:32:53.916] List of future strategies:
[10:32:53.916] 1. sequential:
[10:32:53.916]    - args: function (..., envir = parent.frame())
[10:32:53.916]    - tweaked: FALSE
[10:32:53.916]    - call: NULL
[10:32:53.917] - globals: [0] <none>
[10:32:53.917] plan(): nbrOfWorkers() = 1
[10:32:53.917] getGlobalsAndPackages() ... DONE
[10:32:53.918] run() for ‘Future’ ...
[10:32:53.918] - state: ‘created’
[10:32:53.918] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.919] plan(): Setting new future strategy stack:
[10:32:53.919] List of future strategies:
[10:32:53.919] 1. multicore:
[10:32:53.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.919]    - tweaked: FALSE
[10:32:53.919]    - call: plan(strategy)
[10:32:53.923] plan(): nbrOfWorkers() = 2
[10:32:53.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.923]   - Field: ‘label’
[10:32:53.924]   - Field: ‘local’
[10:32:53.924]   - Field: ‘owner’
[10:32:53.924]   - Field: ‘envir’
[10:32:53.924]   - Field: ‘workers’
[10:32:53.924]   - Field: ‘packages’
[10:32:53.924]   - Field: ‘gc’
[10:32:53.924]   - Field: ‘job’
[10:32:53.925]   - Field: ‘conditions’
[10:32:53.925]   - Field: ‘expr’
[10:32:53.925]   - Field: ‘uuid’
[10:32:53.925]   - Field: ‘seed’
[10:32:53.925]   - Field: ‘version’
[10:32:53.925]   - Field: ‘result’
[10:32:53.925]   - Field: ‘asynchronous’
[10:32:53.926]   - Field: ‘calls’
[10:32:53.926]   - Field: ‘globals’
[10:32:53.926]   - Field: ‘stdout’
[10:32:53.926]   - Field: ‘earlySignal’
[10:32:53.926]   - Field: ‘lazy’
[10:32:53.926]   - Field: ‘state’
[10:32:53.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.927] - Launch lazy future ...
[10:32:53.927] Packages needed by the future expression (n = 0): <none>
[10:32:53.934] Packages needed by future strategies (n = 0): <none>
[10:32:53.935] {
[10:32:53.935]     {
[10:32:53.935]         {
[10:32:53.935]             ...future.startTime <- base::Sys.time()
[10:32:53.935]             {
[10:32:53.935]                 {
[10:32:53.935]                   {
[10:32:53.935]                     {
[10:32:53.935]                       base::local({
[10:32:53.935]                         has_future <- base::requireNamespace("future", 
[10:32:53.935]                           quietly = TRUE)
[10:32:53.935]                         if (has_future) {
[10:32:53.935]                           ns <- base::getNamespace("future")
[10:32:53.935]                           version <- ns[[".package"]][["version"]]
[10:32:53.935]                           if (is.null(version)) 
[10:32:53.935]                             version <- utils::packageVersion("future")
[10:32:53.935]                         }
[10:32:53.935]                         else {
[10:32:53.935]                           version <- NULL
[10:32:53.935]                         }
[10:32:53.935]                         if (!has_future || version < "1.8.0") {
[10:32:53.935]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.935]                             "", base::R.version$version.string), 
[10:32:53.935]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.935]                               "release", "version")], collapse = " "), 
[10:32:53.935]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.935]                             info)
[10:32:53.935]                           info <- base::paste(info, collapse = "; ")
[10:32:53.935]                           if (!has_future) {
[10:32:53.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.935]                               info)
[10:32:53.935]                           }
[10:32:53.935]                           else {
[10:32:53.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.935]                               info, version)
[10:32:53.935]                           }
[10:32:53.935]                           base::stop(msg)
[10:32:53.935]                         }
[10:32:53.935]                       })
[10:32:53.935]                     }
[10:32:53.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.935]                     base::options(mc.cores = 1L)
[10:32:53.935]                   }
[10:32:53.935]                   ...future.strategy.old <- future::plan("list")
[10:32:53.935]                   options(future.plan = NULL)
[10:32:53.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.935]                 }
[10:32:53.935]                 ...future.workdir <- getwd()
[10:32:53.935]             }
[10:32:53.935]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.935]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.935]         }
[10:32:53.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.935]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.935]             base::names(...future.oldOptions))
[10:32:53.935]     }
[10:32:53.935]     if (FALSE) {
[10:32:53.935]     }
[10:32:53.935]     else {
[10:32:53.935]         if (TRUE) {
[10:32:53.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.935]                 open = "w")
[10:32:53.935]         }
[10:32:53.935]         else {
[10:32:53.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.935]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.935]         }
[10:32:53.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.935]             base::sink(type = "output", split = FALSE)
[10:32:53.935]             base::close(...future.stdout)
[10:32:53.935]         }, add = TRUE)
[10:32:53.935]     }
[10:32:53.935]     ...future.frame <- base::sys.nframe()
[10:32:53.935]     ...future.conditions <- base::list()
[10:32:53.935]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.935]     if (FALSE) {
[10:32:53.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.935]     }
[10:32:53.935]     ...future.result <- base::tryCatch({
[10:32:53.935]         base::withCallingHandlers({
[10:32:53.935]             ...future.value <- base::withVisible(base::local({
[10:32:53.935]                 withCallingHandlers({
[10:32:53.935]                   NULL
[10:32:53.935]                 }, immediateCondition = function(cond) {
[10:32:53.935]                   save_rds <- function (object, pathname, ...) 
[10:32:53.935]                   {
[10:32:53.935]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.935]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.935]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.935]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.935]                         fi_tmp[["mtime"]])
[10:32:53.935]                     }
[10:32:53.935]                     tryCatch({
[10:32:53.935]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.935]                     }, error = function(ex) {
[10:32:53.935]                       msg <- conditionMessage(ex)
[10:32:53.935]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.935]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.935]                         fi_tmp[["mtime"]], msg)
[10:32:53.935]                       ex$message <- msg
[10:32:53.935]                       stop(ex)
[10:32:53.935]                     })
[10:32:53.935]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.935]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.935]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.935]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.935]                       fi <- file.info(pathname)
[10:32:53.935]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.935]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.935]                         fi[["size"]], fi[["mtime"]])
[10:32:53.935]                       stop(msg)
[10:32:53.935]                     }
[10:32:53.935]                     invisible(pathname)
[10:32:53.935]                   }
[10:32:53.935]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.935]                     rootPath = tempdir()) 
[10:32:53.935]                   {
[10:32:53.935]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.935]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.935]                       tmpdir = path, fileext = ".rds")
[10:32:53.935]                     save_rds(obj, file)
[10:32:53.935]                   }
[10:32:53.935]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.935]                   {
[10:32:53.935]                     inherits <- base::inherits
[10:32:53.935]                     invokeRestart <- base::invokeRestart
[10:32:53.935]                     is.null <- base::is.null
[10:32:53.935]                     muffled <- FALSE
[10:32:53.935]                     if (inherits(cond, "message")) {
[10:32:53.935]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.935]                       if (muffled) 
[10:32:53.935]                         invokeRestart("muffleMessage")
[10:32:53.935]                     }
[10:32:53.935]                     else if (inherits(cond, "warning")) {
[10:32:53.935]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.935]                       if (muffled) 
[10:32:53.935]                         invokeRestart("muffleWarning")
[10:32:53.935]                     }
[10:32:53.935]                     else if (inherits(cond, "condition")) {
[10:32:53.935]                       if (!is.null(pattern)) {
[10:32:53.935]                         computeRestarts <- base::computeRestarts
[10:32:53.935]                         grepl <- base::grepl
[10:32:53.935]                         restarts <- computeRestarts(cond)
[10:32:53.935]                         for (restart in restarts) {
[10:32:53.935]                           name <- restart$name
[10:32:53.935]                           if (is.null(name)) 
[10:32:53.935]                             next
[10:32:53.935]                           if (!grepl(pattern, name)) 
[10:32:53.935]                             next
[10:32:53.935]                           invokeRestart(restart)
[10:32:53.935]                           muffled <- TRUE
[10:32:53.935]                           break
[10:32:53.935]                         }
[10:32:53.935]                       }
[10:32:53.935]                     }
[10:32:53.935]                     invisible(muffled)
[10:32:53.935]                   }
[10:32:53.935]                   muffleCondition(cond)
[10:32:53.935]                 })
[10:32:53.935]             }))
[10:32:53.935]             future::FutureResult(value = ...future.value$value, 
[10:32:53.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.935]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.935]                     ...future.globalenv.names))
[10:32:53.935]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.935]         }, condition = base::local({
[10:32:53.935]             c <- base::c
[10:32:53.935]             inherits <- base::inherits
[10:32:53.935]             invokeRestart <- base::invokeRestart
[10:32:53.935]             length <- base::length
[10:32:53.935]             list <- base::list
[10:32:53.935]             seq.int <- base::seq.int
[10:32:53.935]             signalCondition <- base::signalCondition
[10:32:53.935]             sys.calls <- base::sys.calls
[10:32:53.935]             `[[` <- base::`[[`
[10:32:53.935]             `+` <- base::`+`
[10:32:53.935]             `<<-` <- base::`<<-`
[10:32:53.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.935]                   3L)]
[10:32:53.935]             }
[10:32:53.935]             function(cond) {
[10:32:53.935]                 is_error <- inherits(cond, "error")
[10:32:53.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.935]                   NULL)
[10:32:53.935]                 if (is_error) {
[10:32:53.935]                   sessionInformation <- function() {
[10:32:53.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.935]                       search = base::search(), system = base::Sys.info())
[10:32:53.935]                   }
[10:32:53.935]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.935]                     cond$call), session = sessionInformation(), 
[10:32:53.935]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.935]                   signalCondition(cond)
[10:32:53.935]                 }
[10:32:53.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.935]                 "immediateCondition"))) {
[10:32:53.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.935]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.935]                   if (TRUE && !signal) {
[10:32:53.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.935]                     {
[10:32:53.935]                       inherits <- base::inherits
[10:32:53.935]                       invokeRestart <- base::invokeRestart
[10:32:53.935]                       is.null <- base::is.null
[10:32:53.935]                       muffled <- FALSE
[10:32:53.935]                       if (inherits(cond, "message")) {
[10:32:53.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.935]                         if (muffled) 
[10:32:53.935]                           invokeRestart("muffleMessage")
[10:32:53.935]                       }
[10:32:53.935]                       else if (inherits(cond, "warning")) {
[10:32:53.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.935]                         if (muffled) 
[10:32:53.935]                           invokeRestart("muffleWarning")
[10:32:53.935]                       }
[10:32:53.935]                       else if (inherits(cond, "condition")) {
[10:32:53.935]                         if (!is.null(pattern)) {
[10:32:53.935]                           computeRestarts <- base::computeRestarts
[10:32:53.935]                           grepl <- base::grepl
[10:32:53.935]                           restarts <- computeRestarts(cond)
[10:32:53.935]                           for (restart in restarts) {
[10:32:53.935]                             name <- restart$name
[10:32:53.935]                             if (is.null(name)) 
[10:32:53.935]                               next
[10:32:53.935]                             if (!grepl(pattern, name)) 
[10:32:53.935]                               next
[10:32:53.935]                             invokeRestart(restart)
[10:32:53.935]                             muffled <- TRUE
[10:32:53.935]                             break
[10:32:53.935]                           }
[10:32:53.935]                         }
[10:32:53.935]                       }
[10:32:53.935]                       invisible(muffled)
[10:32:53.935]                     }
[10:32:53.935]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.935]                   }
[10:32:53.935]                 }
[10:32:53.935]                 else {
[10:32:53.935]                   if (TRUE) {
[10:32:53.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.935]                     {
[10:32:53.935]                       inherits <- base::inherits
[10:32:53.935]                       invokeRestart <- base::invokeRestart
[10:32:53.935]                       is.null <- base::is.null
[10:32:53.935]                       muffled <- FALSE
[10:32:53.935]                       if (inherits(cond, "message")) {
[10:32:53.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.935]                         if (muffled) 
[10:32:53.935]                           invokeRestart("muffleMessage")
[10:32:53.935]                       }
[10:32:53.935]                       else if (inherits(cond, "warning")) {
[10:32:53.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.935]                         if (muffled) 
[10:32:53.935]                           invokeRestart("muffleWarning")
[10:32:53.935]                       }
[10:32:53.935]                       else if (inherits(cond, "condition")) {
[10:32:53.935]                         if (!is.null(pattern)) {
[10:32:53.935]                           computeRestarts <- base::computeRestarts
[10:32:53.935]                           grepl <- base::grepl
[10:32:53.935]                           restarts <- computeRestarts(cond)
[10:32:53.935]                           for (restart in restarts) {
[10:32:53.935]                             name <- restart$name
[10:32:53.935]                             if (is.null(name)) 
[10:32:53.935]                               next
[10:32:53.935]                             if (!grepl(pattern, name)) 
[10:32:53.935]                               next
[10:32:53.935]                             invokeRestart(restart)
[10:32:53.935]                             muffled <- TRUE
[10:32:53.935]                             break
[10:32:53.935]                           }
[10:32:53.935]                         }
[10:32:53.935]                       }
[10:32:53.935]                       invisible(muffled)
[10:32:53.935]                     }
[10:32:53.935]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.935]                   }
[10:32:53.935]                 }
[10:32:53.935]             }
[10:32:53.935]         }))
[10:32:53.935]     }, error = function(ex) {
[10:32:53.935]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.935]                 ...future.rng), started = ...future.startTime, 
[10:32:53.935]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.935]             version = "1.8"), class = "FutureResult")
[10:32:53.935]     }, finally = {
[10:32:53.935]         if (!identical(...future.workdir, getwd())) 
[10:32:53.935]             setwd(...future.workdir)
[10:32:53.935]         {
[10:32:53.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.935]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.935]             }
[10:32:53.935]             base::options(...future.oldOptions)
[10:32:53.935]             if (.Platform$OS.type == "windows") {
[10:32:53.935]                 old_names <- names(...future.oldEnvVars)
[10:32:53.935]                 envs <- base::Sys.getenv()
[10:32:53.935]                 names <- names(envs)
[10:32:53.935]                 common <- intersect(names, old_names)
[10:32:53.935]                 added <- setdiff(names, old_names)
[10:32:53.935]                 removed <- setdiff(old_names, names)
[10:32:53.935]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.935]                   envs[common]]
[10:32:53.935]                 NAMES <- toupper(changed)
[10:32:53.935]                 args <- list()
[10:32:53.935]                 for (kk in seq_along(NAMES)) {
[10:32:53.935]                   name <- changed[[kk]]
[10:32:53.935]                   NAME <- NAMES[[kk]]
[10:32:53.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.935]                     next
[10:32:53.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.935]                 }
[10:32:53.935]                 NAMES <- toupper(added)
[10:32:53.935]                 for (kk in seq_along(NAMES)) {
[10:32:53.935]                   name <- added[[kk]]
[10:32:53.935]                   NAME <- NAMES[[kk]]
[10:32:53.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.935]                     next
[10:32:53.935]                   args[[name]] <- ""
[10:32:53.935]                 }
[10:32:53.935]                 NAMES <- toupper(removed)
[10:32:53.935]                 for (kk in seq_along(NAMES)) {
[10:32:53.935]                   name <- removed[[kk]]
[10:32:53.935]                   NAME <- NAMES[[kk]]
[10:32:53.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.935]                     next
[10:32:53.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.935]                 }
[10:32:53.935]                 if (length(args) > 0) 
[10:32:53.935]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.935]             }
[10:32:53.935]             else {
[10:32:53.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.935]             }
[10:32:53.935]             {
[10:32:53.935]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.935]                   0L) {
[10:32:53.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.935]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.935]                   base::options(opts)
[10:32:53.935]                 }
[10:32:53.935]                 {
[10:32:53.935]                   {
[10:32:53.935]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.935]                     NULL
[10:32:53.935]                   }
[10:32:53.935]                   options(future.plan = NULL)
[10:32:53.935]                   if (is.na(NA_character_)) 
[10:32:53.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.935]                     .init = FALSE)
[10:32:53.935]                 }
[10:32:53.935]             }
[10:32:53.935]         }
[10:32:53.935]     })
[10:32:53.935]     if (TRUE) {
[10:32:53.935]         base::sink(type = "output", split = FALSE)
[10:32:53.935]         if (TRUE) {
[10:32:53.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.935]         }
[10:32:53.935]         else {
[10:32:53.935]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.935]         }
[10:32:53.935]         base::close(...future.stdout)
[10:32:53.935]         ...future.stdout <- NULL
[10:32:53.935]     }
[10:32:53.935]     ...future.result$conditions <- ...future.conditions
[10:32:53.935]     ...future.result$finished <- base::Sys.time()
[10:32:53.935]     ...future.result
[10:32:53.935] }
[10:32:53.938] requestCore(): workers = 2
[10:32:53.942] MulticoreFuture started
[10:32:53.942] - Launch lazy future ... done
[10:32:53.942] run() for ‘MulticoreFuture’ ... done
[10:32:53.943] plan(): Setting new future strategy stack:
[10:32:53.943] getGlobalsAndPackages() ...
[10:32:53.943] Searching for globals...
[10:32:53.943] List of future strategies:
[10:32:53.943] 1. sequential:
[10:32:53.943]    - args: function (..., envir = parent.frame())
[10:32:53.943]    - tweaked: FALSE
[10:32:53.943]    - call: NULL
[10:32:53.944] plan(): nbrOfWorkers() = 1
[10:32:53.945] - globals found: [1] ‘{’
[10:32:53.945] Searching for globals ... DONE
[10:32:53.945] Resolving globals: FALSE
[10:32:53.946] plan(): Setting new future strategy stack:
[10:32:53.946] 
[10:32:53.946] 
[10:32:53.946] getGlobalsAndPackages() ... DONE
[10:32:53.946] List of future strategies:
[10:32:53.946] 1. multicore:
[10:32:53.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.946]    - tweaked: FALSE
[10:32:53.946]    - call: plan(strategy)
[10:32:53.947] run() for ‘Future’ ...
[10:32:53.947] - state: ‘created’
[10:32:53.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:53.953] plan(): nbrOfWorkers() = 2
[10:32:53.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:53.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:53.953]   - Field: ‘label’
[10:32:53.954]   - Field: ‘local’
[10:32:53.954]   - Field: ‘owner’
[10:32:53.954]   - Field: ‘envir’
[10:32:53.954]   - Field: ‘workers’
[10:32:53.954]   - Field: ‘packages’
[10:32:53.954]   - Field: ‘gc’
[10:32:53.954]   - Field: ‘job’
[10:32:53.955]   - Field: ‘conditions’
[10:32:53.955]   - Field: ‘expr’
[10:32:53.955]   - Field: ‘uuid’
[10:32:53.955]   - Field: ‘seed’
[10:32:53.955]   - Field: ‘version’
[10:32:53.955]   - Field: ‘result’
[10:32:53.955]   - Field: ‘asynchronous’
[10:32:53.956]   - Field: ‘calls’
[10:32:53.956]   - Field: ‘globals’
[10:32:53.956]   - Field: ‘stdout’
[10:32:53.956]   - Field: ‘earlySignal’
[10:32:53.956]   - Field: ‘lazy’
[10:32:53.956]   - Field: ‘state’
[10:32:53.956] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:53.957] - Launch lazy future ...
[10:32:53.957] Packages needed by the future expression (n = 0): <none>
[10:32:53.957] Packages needed by future strategies (n = 0): <none>
[10:32:53.958] {
[10:32:53.958]     {
[10:32:53.958]         {
[10:32:53.958]             ...future.startTime <- base::Sys.time()
[10:32:53.958]             {
[10:32:53.958]                 {
[10:32:53.958]                   {
[10:32:53.958]                     {
[10:32:53.958]                       base::local({
[10:32:53.958]                         has_future <- base::requireNamespace("future", 
[10:32:53.958]                           quietly = TRUE)
[10:32:53.958]                         if (has_future) {
[10:32:53.958]                           ns <- base::getNamespace("future")
[10:32:53.958]                           version <- ns[[".package"]][["version"]]
[10:32:53.958]                           if (is.null(version)) 
[10:32:53.958]                             version <- utils::packageVersion("future")
[10:32:53.958]                         }
[10:32:53.958]                         else {
[10:32:53.958]                           version <- NULL
[10:32:53.958]                         }
[10:32:53.958]                         if (!has_future || version < "1.8.0") {
[10:32:53.958]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:53.958]                             "", base::R.version$version.string), 
[10:32:53.958]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:53.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:53.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:53.958]                               "release", "version")], collapse = " "), 
[10:32:53.958]                             hostname = base::Sys.info()[["nodename"]])
[10:32:53.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:53.958]                             info)
[10:32:53.958]                           info <- base::paste(info, collapse = "; ")
[10:32:53.958]                           if (!has_future) {
[10:32:53.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:53.958]                               info)
[10:32:53.958]                           }
[10:32:53.958]                           else {
[10:32:53.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:53.958]                               info, version)
[10:32:53.958]                           }
[10:32:53.958]                           base::stop(msg)
[10:32:53.958]                         }
[10:32:53.958]                       })
[10:32:53.958]                     }
[10:32:53.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:53.958]                     base::options(mc.cores = 1L)
[10:32:53.958]                   }
[10:32:53.958]                   ...future.strategy.old <- future::plan("list")
[10:32:53.958]                   options(future.plan = NULL)
[10:32:53.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:53.958]                 }
[10:32:53.958]                 ...future.workdir <- getwd()
[10:32:53.958]             }
[10:32:53.958]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:53.958]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:53.958]         }
[10:32:53.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:53.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:53.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:53.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:53.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:53.958]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:53.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:53.958]             base::names(...future.oldOptions))
[10:32:53.958]     }
[10:32:53.958]     if (FALSE) {
[10:32:53.958]     }
[10:32:53.958]     else {
[10:32:53.958]         if (TRUE) {
[10:32:53.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:53.958]                 open = "w")
[10:32:53.958]         }
[10:32:53.958]         else {
[10:32:53.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:53.958]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:53.958]         }
[10:32:53.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:53.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:53.958]             base::sink(type = "output", split = FALSE)
[10:32:53.958]             base::close(...future.stdout)
[10:32:53.958]         }, add = TRUE)
[10:32:53.958]     }
[10:32:53.958]     ...future.frame <- base::sys.nframe()
[10:32:53.958]     ...future.conditions <- base::list()
[10:32:53.958]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:53.958]     if (FALSE) {
[10:32:53.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:53.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:53.958]     }
[10:32:53.958]     ...future.result <- base::tryCatch({
[10:32:53.958]         base::withCallingHandlers({
[10:32:53.958]             ...future.value <- base::withVisible(base::local({
[10:32:53.958]                 withCallingHandlers({
[10:32:53.958]                   {
[10:32:53.958]                     4
[10:32:53.958]                   }
[10:32:53.958]                 }, immediateCondition = function(cond) {
[10:32:53.958]                   save_rds <- function (object, pathname, ...) 
[10:32:53.958]                   {
[10:32:53.958]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:53.958]                     if (file_test("-f", pathname_tmp)) {
[10:32:53.958]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.958]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:53.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.958]                         fi_tmp[["mtime"]])
[10:32:53.958]                     }
[10:32:53.958]                     tryCatch({
[10:32:53.958]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:53.958]                     }, error = function(ex) {
[10:32:53.958]                       msg <- conditionMessage(ex)
[10:32:53.958]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.958]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:53.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.958]                         fi_tmp[["mtime"]], msg)
[10:32:53.958]                       ex$message <- msg
[10:32:53.958]                       stop(ex)
[10:32:53.958]                     })
[10:32:53.958]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:53.958]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:53.958]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:53.958]                       fi_tmp <- file.info(pathname_tmp)
[10:32:53.958]                       fi <- file.info(pathname)
[10:32:53.958]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:53.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:53.958]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:53.958]                         fi[["size"]], fi[["mtime"]])
[10:32:53.958]                       stop(msg)
[10:32:53.958]                     }
[10:32:53.958]                     invisible(pathname)
[10:32:53.958]                   }
[10:32:53.958]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:53.958]                     rootPath = tempdir()) 
[10:32:53.958]                   {
[10:32:53.958]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:53.958]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:53.958]                       tmpdir = path, fileext = ".rds")
[10:32:53.958]                     save_rds(obj, file)
[10:32:53.958]                   }
[10:32:53.958]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:53.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.958]                   {
[10:32:53.958]                     inherits <- base::inherits
[10:32:53.958]                     invokeRestart <- base::invokeRestart
[10:32:53.958]                     is.null <- base::is.null
[10:32:53.958]                     muffled <- FALSE
[10:32:53.958]                     if (inherits(cond, "message")) {
[10:32:53.958]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:53.958]                       if (muffled) 
[10:32:53.958]                         invokeRestart("muffleMessage")
[10:32:53.958]                     }
[10:32:53.958]                     else if (inherits(cond, "warning")) {
[10:32:53.958]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:53.958]                       if (muffled) 
[10:32:53.958]                         invokeRestart("muffleWarning")
[10:32:53.958]                     }
[10:32:53.958]                     else if (inherits(cond, "condition")) {
[10:32:53.958]                       if (!is.null(pattern)) {
[10:32:53.958]                         computeRestarts <- base::computeRestarts
[10:32:53.958]                         grepl <- base::grepl
[10:32:53.958]                         restarts <- computeRestarts(cond)
[10:32:53.958]                         for (restart in restarts) {
[10:32:53.958]                           name <- restart$name
[10:32:53.958]                           if (is.null(name)) 
[10:32:53.958]                             next
[10:32:53.958]                           if (!grepl(pattern, name)) 
[10:32:53.958]                             next
[10:32:53.958]                           invokeRestart(restart)
[10:32:53.958]                           muffled <- TRUE
[10:32:53.958]                           break
[10:32:53.958]                         }
[10:32:53.958]                       }
[10:32:53.958]                     }
[10:32:53.958]                     invisible(muffled)
[10:32:53.958]                   }
[10:32:53.958]                   muffleCondition(cond)
[10:32:53.958]                 })
[10:32:53.958]             }))
[10:32:53.958]             future::FutureResult(value = ...future.value$value, 
[10:32:53.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.958]                   ...future.rng), globalenv = if (FALSE) 
[10:32:53.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:53.958]                     ...future.globalenv.names))
[10:32:53.958]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:53.958]         }, condition = base::local({
[10:32:53.958]             c <- base::c
[10:32:53.958]             inherits <- base::inherits
[10:32:53.958]             invokeRestart <- base::invokeRestart
[10:32:53.958]             length <- base::length
[10:32:53.958]             list <- base::list
[10:32:53.958]             seq.int <- base::seq.int
[10:32:53.958]             signalCondition <- base::signalCondition
[10:32:53.958]             sys.calls <- base::sys.calls
[10:32:53.958]             `[[` <- base::`[[`
[10:32:53.958]             `+` <- base::`+`
[10:32:53.958]             `<<-` <- base::`<<-`
[10:32:53.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:53.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:53.958]                   3L)]
[10:32:53.958]             }
[10:32:53.958]             function(cond) {
[10:32:53.958]                 is_error <- inherits(cond, "error")
[10:32:53.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:53.958]                   NULL)
[10:32:53.958]                 if (is_error) {
[10:32:53.958]                   sessionInformation <- function() {
[10:32:53.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:53.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:53.958]                       search = base::search(), system = base::Sys.info())
[10:32:53.958]                   }
[10:32:53.958]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:53.958]                     cond$call), session = sessionInformation(), 
[10:32:53.958]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:53.958]                   signalCondition(cond)
[10:32:53.958]                 }
[10:32:53.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:53.958]                 "immediateCondition"))) {
[10:32:53.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:53.958]                   ...future.conditions[[length(...future.conditions) + 
[10:32:53.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:53.958]                   if (TRUE && !signal) {
[10:32:53.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.958]                     {
[10:32:53.958]                       inherits <- base::inherits
[10:32:53.958]                       invokeRestart <- base::invokeRestart
[10:32:53.958]                       is.null <- base::is.null
[10:32:53.958]                       muffled <- FALSE
[10:32:53.958]                       if (inherits(cond, "message")) {
[10:32:53.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.958]                         if (muffled) 
[10:32:53.958]                           invokeRestart("muffleMessage")
[10:32:53.958]                       }
[10:32:53.958]                       else if (inherits(cond, "warning")) {
[10:32:53.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.958]                         if (muffled) 
[10:32:53.958]                           invokeRestart("muffleWarning")
[10:32:53.958]                       }
[10:32:53.958]                       else if (inherits(cond, "condition")) {
[10:32:53.958]                         if (!is.null(pattern)) {
[10:32:53.958]                           computeRestarts <- base::computeRestarts
[10:32:53.958]                           grepl <- base::grepl
[10:32:53.958]                           restarts <- computeRestarts(cond)
[10:32:53.958]                           for (restart in restarts) {
[10:32:53.958]                             name <- restart$name
[10:32:53.958]                             if (is.null(name)) 
[10:32:53.958]                               next
[10:32:53.958]                             if (!grepl(pattern, name)) 
[10:32:53.958]                               next
[10:32:53.958]                             invokeRestart(restart)
[10:32:53.958]                             muffled <- TRUE
[10:32:53.958]                             break
[10:32:53.958]                           }
[10:32:53.958]                         }
[10:32:53.958]                       }
[10:32:53.958]                       invisible(muffled)
[10:32:53.958]                     }
[10:32:53.958]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.958]                   }
[10:32:53.958]                 }
[10:32:53.958]                 else {
[10:32:53.958]                   if (TRUE) {
[10:32:53.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:53.958]                     {
[10:32:53.958]                       inherits <- base::inherits
[10:32:53.958]                       invokeRestart <- base::invokeRestart
[10:32:53.958]                       is.null <- base::is.null
[10:32:53.958]                       muffled <- FALSE
[10:32:53.958]                       if (inherits(cond, "message")) {
[10:32:53.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:53.958]                         if (muffled) 
[10:32:53.958]                           invokeRestart("muffleMessage")
[10:32:53.958]                       }
[10:32:53.958]                       else if (inherits(cond, "warning")) {
[10:32:53.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:53.958]                         if (muffled) 
[10:32:53.958]                           invokeRestart("muffleWarning")
[10:32:53.958]                       }
[10:32:53.958]                       else if (inherits(cond, "condition")) {
[10:32:53.958]                         if (!is.null(pattern)) {
[10:32:53.958]                           computeRestarts <- base::computeRestarts
[10:32:53.958]                           grepl <- base::grepl
[10:32:53.958]                           restarts <- computeRestarts(cond)
[10:32:53.958]                           for (restart in restarts) {
[10:32:53.958]                             name <- restart$name
[10:32:53.958]                             if (is.null(name)) 
[10:32:53.958]                               next
[10:32:53.958]                             if (!grepl(pattern, name)) 
[10:32:53.958]                               next
[10:32:53.958]                             invokeRestart(restart)
[10:32:53.958]                             muffled <- TRUE
[10:32:53.958]                             break
[10:32:53.958]                           }
[10:32:53.958]                         }
[10:32:53.958]                       }
[10:32:53.958]                       invisible(muffled)
[10:32:53.958]                     }
[10:32:53.958]                     muffleCondition(cond, pattern = "^muffle")
[10:32:53.958]                   }
[10:32:53.958]                 }
[10:32:53.958]             }
[10:32:53.958]         }))
[10:32:53.958]     }, error = function(ex) {
[10:32:53.958]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:53.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:53.958]                 ...future.rng), started = ...future.startTime, 
[10:32:53.958]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:53.958]             version = "1.8"), class = "FutureResult")
[10:32:53.958]     }, finally = {
[10:32:53.958]         if (!identical(...future.workdir, getwd())) 
[10:32:53.958]             setwd(...future.workdir)
[10:32:53.958]         {
[10:32:53.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:53.958]                 ...future.oldOptions$nwarnings <- NULL
[10:32:53.958]             }
[10:32:53.958]             base::options(...future.oldOptions)
[10:32:53.958]             if (.Platform$OS.type == "windows") {
[10:32:53.958]                 old_names <- names(...future.oldEnvVars)
[10:32:53.958]                 envs <- base::Sys.getenv()
[10:32:53.958]                 names <- names(envs)
[10:32:53.958]                 common <- intersect(names, old_names)
[10:32:53.958]                 added <- setdiff(names, old_names)
[10:32:53.958]                 removed <- setdiff(old_names, names)
[10:32:53.958]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:53.958]                   envs[common]]
[10:32:53.958]                 NAMES <- toupper(changed)
[10:32:53.958]                 args <- list()
[10:32:53.958]                 for (kk in seq_along(NAMES)) {
[10:32:53.958]                   name <- changed[[kk]]
[10:32:53.958]                   NAME <- NAMES[[kk]]
[10:32:53.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.958]                     next
[10:32:53.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.958]                 }
[10:32:53.958]                 NAMES <- toupper(added)
[10:32:53.958]                 for (kk in seq_along(NAMES)) {
[10:32:53.958]                   name <- added[[kk]]
[10:32:53.958]                   NAME <- NAMES[[kk]]
[10:32:53.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.958]                     next
[10:32:53.958]                   args[[name]] <- ""
[10:32:53.958]                 }
[10:32:53.958]                 NAMES <- toupper(removed)
[10:32:53.958]                 for (kk in seq_along(NAMES)) {
[10:32:53.958]                   name <- removed[[kk]]
[10:32:53.958]                   NAME <- NAMES[[kk]]
[10:32:53.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:53.958]                     next
[10:32:53.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:53.958]                 }
[10:32:53.958]                 if (length(args) > 0) 
[10:32:53.958]                   base::do.call(base::Sys.setenv, args = args)
[10:32:53.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:53.958]             }
[10:32:53.958]             else {
[10:32:53.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:53.958]             }
[10:32:53.958]             {
[10:32:53.958]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:53.958]                   0L) {
[10:32:53.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:53.958]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:53.958]                   base::options(opts)
[10:32:53.958]                 }
[10:32:53.958]                 {
[10:32:53.958]                   {
[10:32:53.958]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:53.958]                     NULL
[10:32:53.958]                   }
[10:32:53.958]                   options(future.plan = NULL)
[10:32:53.958]                   if (is.na(NA_character_)) 
[10:32:53.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:53.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:53.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:53.958]                     .init = FALSE)
[10:32:53.958]                 }
[10:32:53.958]             }
[10:32:53.958]         }
[10:32:53.958]     })
[10:32:53.958]     if (TRUE) {
[10:32:53.958]         base::sink(type = "output", split = FALSE)
[10:32:53.958]         if (TRUE) {
[10:32:53.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:53.958]         }
[10:32:53.958]         else {
[10:32:53.958]             ...future.result["stdout"] <- base::list(NULL)
[10:32:53.958]         }
[10:32:53.958]         base::close(...future.stdout)
[10:32:53.958]         ...future.stdout <- NULL
[10:32:53.958]     }
[10:32:53.958]     ...future.result$conditions <- ...future.conditions
[10:32:53.958]     ...future.result$finished <- base::Sys.time()
[10:32:53.958]     ...future.result
[10:32:53.958] }
[10:32:53.962] requestCore(): workers = 2
[10:32:53.962] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:53.973] result() for MulticoreFuture ...
[10:32:53.974] result() for MulticoreFuture ...
[10:32:53.974] result() for MulticoreFuture ... done
[10:32:53.974] result() for MulticoreFuture ... done
[10:32:53.974] result() for MulticoreFuture ...
[10:32:53.975] result() for MulticoreFuture ... done
[10:32:53.977] MulticoreFuture started
[10:32:53.978] - Launch lazy future ... done
[10:32:53.978] run() for ‘MulticoreFuture’ ... done
[10:32:53.979] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5652d29ce980> 
[10:32:53.979] List of future strategies:
[10:32:53.979] 1. sequential:
[10:32:53.979]    - args: function (..., envir = parent.frame())
[10:32:53.979]    - tweaked: FALSE
[10:32:53.979]    - call: NULL
[10:32:53.981] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5652d0f07690> 
 - attr(*, "dim.")=[10:32:53.983] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ :[10:32:53.984] List of future strategies:
[10:32:53.984] 1. multicore:
[10:32:53.984]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:53.984]    - tweaked: FALSE
[10:32:53.984]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:53.990] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:53.994] resolve() on list environment ...
[10:32:53.994]  recursive: 0
[10:32:53.996]  length: 6
[10:32:53.996]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:53.996] signalConditionsASAP(numeric, pos=1) ...
[10:32:53.996] - nx: 6
[10:32:53.996] - relay: TRUE
[10:32:53.996] - stdout: TRUE
[10:32:53.997] - signal: TRUE
[10:32:53.997] - resignal: FALSE
[10:32:53.997] - force: TRUE
[10:32:53.997] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.997] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.997]  - until=2
[10:32:53.998]  - relaying element #2
[10:32:53.998] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.998] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:53.998] signalConditionsASAP(NULL, pos=1) ... done
[10:32:53.998]  length: 5 (resolved future 1)
[10:32:53.998] Future #2
[10:32:53.998] result() for MulticoreFuture ...
[10:32:53.999] result() for MulticoreFuture ... done
[10:32:53.999] result() for MulticoreFuture ...
[10:32:53.999] result() for MulticoreFuture ... done
[10:32:53.999] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:53.999] - nx: 6
[10:32:53.999] - relay: TRUE
[10:32:53.999] - stdout: TRUE
[10:32:54.000] - signal: TRUE
[10:32:54.000] - resignal: FALSE
[10:32:54.000] - force: TRUE
[10:32:54.000] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.000] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.000]  - until=2
[10:32:54.000]  - relaying element #2
[10:32:54.001] result() for MulticoreFuture ...
[10:32:54.001] result() for MulticoreFuture ... done
[10:32:54.001] result() for MulticoreFuture ...
[10:32:54.001] result() for MulticoreFuture ... done
[10:32:54.002] result() for MulticoreFuture ...
[10:32:54.002] result() for MulticoreFuture ... done
[10:32:54.002] result() for MulticoreFuture ...
[10:32:54.002] result() for MulticoreFuture ... done
[10:32:54.002] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.002] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.002] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:54.003]  length: 4 (resolved future 2)
[10:32:54.003] Future #3
[10:32:54.003] result() for MulticoreFuture ...
[10:32:54.004] result() for MulticoreFuture ...
[10:32:54.004] result() for MulticoreFuture ... done
[10:32:54.005] result() for MulticoreFuture ... done
[10:32:54.005] result() for MulticoreFuture ...
[10:32:54.005] result() for MulticoreFuture ... done
[10:32:54.005] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:54.005] - nx: 6
[10:32:54.005] - relay: TRUE
[10:32:54.006] - stdout: TRUE
[10:32:54.006] - signal: TRUE
[10:32:54.006] - resignal: FALSE
[10:32:54.006] - force: TRUE
[10:32:54.006] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.006] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.007]  - until=3
[10:32:54.007]  - relaying element #3
[10:32:54.007] result() for MulticoreFuture ...
[10:32:54.007] result() for MulticoreFuture ... done
[10:32:54.007] result() for MulticoreFuture ...
[10:32:54.007] result() for MulticoreFuture ... done
[10:32:54.008] result() for MulticoreFuture ...
[10:32:54.008] result() for MulticoreFuture ... done
[10:32:54.008] result() for MulticoreFuture ...
[10:32:54.008] result() for MulticoreFuture ... done
[10:32:54.008] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.008] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.008] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:54.009]  length: 3 (resolved future 3)
[10:32:54.009] Future #4
[10:32:54.009] result() for MulticoreFuture ...
[10:32:54.010] result() for MulticoreFuture ...
[10:32:54.010] result() for MulticoreFuture ... done
[10:32:54.010] result() for MulticoreFuture ... done
[10:32:54.010] result() for MulticoreFuture ...
[10:32:54.011] result() for MulticoreFuture ... done
[10:32:54.011] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:54.011] - nx: 6
[10:32:54.011] - relay: TRUE
[10:32:54.011] - stdout: TRUE
[10:32:54.012] - signal: TRUE
[10:32:54.012] - resignal: FALSE
[10:32:54.012] - force: TRUE
[10:32:54.012] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.012] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.013]  - until=4
[10:32:54.013]  - relaying element #4
[10:32:54.013] result() for MulticoreFuture ...
[10:32:54.013] result() for MulticoreFuture ... done
[10:32:54.013] result() for MulticoreFuture ...
[10:32:54.013] result() for MulticoreFuture ... done
[10:32:54.014] result() for MulticoreFuture ...
[10:32:54.014] result() for MulticoreFuture ... done
[10:32:54.014] result() for MulticoreFuture ...
[10:32:54.014] result() for MulticoreFuture ... done
[10:32:54.014] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.014] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.014] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:54.015]  length: 2 (resolved future 4)
[10:32:54.015] signalConditionsASAP(NULL, pos=5) ...
[10:32:54.015] - nx: 6
[10:32:54.015] - relay: TRUE
[10:32:54.015] - stdout: TRUE
[10:32:54.015] - signal: TRUE
[10:32:54.015] - resignal: FALSE
[10:32:54.015] - force: TRUE
[10:32:54.015] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.015] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.016]  - until=6
[10:32:54.016]  - relaying element #6
[10:32:54.016] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.016] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.016] signalConditionsASAP(NULL, pos=5) ... done
[10:32:54.016]  length: 1 (resolved future 5)
[10:32:54.016] signalConditionsASAP(numeric, pos=6) ...
[10:32:54.016] - nx: 6
[10:32:54.016] - relay: TRUE
[10:32:54.017] - stdout: TRUE
[10:32:54.017] - signal: TRUE
[10:32:54.017] - resignal: FALSE
[10:32:54.017] - force: TRUE
[10:32:54.017] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.017] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.017]  - until=6
[10:32:54.017] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.017] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.018] signalConditionsASAP(numeric, pos=6) ... done
[10:32:54.018]  length: 0 (resolved future 6)
[10:32:54.018] Relaying remaining futures
[10:32:54.018] signalConditionsASAP(NULL, pos=0) ...
[10:32:54.018] - nx: 6
[10:32:54.018] - relay: TRUE
[10:32:54.018] - stdout: TRUE
[10:32:54.018] - signal: TRUE
[10:32:54.018] - resignal: FALSE
[10:32:54.018] - force: TRUE
[10:32:54.018] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.019] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:54.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.019] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.019] signalConditionsASAP(NULL, pos=0) ... done
[10:32:54.019] resolve() on list environment ... DONE
[10:32:54.019] result() for MulticoreFuture ...
[10:32:54.019] result() for MulticoreFuture ... done
[10:32:54.019] result() for MulticoreFuture ...
[10:32:54.020] result() for MulticoreFuture ... done
[10:32:54.020] result() for MulticoreFuture ...
[10:32:54.020] result() for MulticoreFuture ... done
[10:32:54.020] result() for MulticoreFuture ...
[10:32:54.020] result() for MulticoreFuture ... done
[10:32:54.020] result() for MulticoreFuture ...
[10:32:54.020] result() for MulticoreFuture ... done
[10:32:54.020] result() for MulticoreFuture ...
[10:32:54.021] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d0aee060> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:32:54.023] getGlobalsAndPackages() ...
[10:32:54.023] Searching for globals...
[10:32:54.023] 
[10:32:54.024] Searching for globals ... DONE
[10:32:54.024] - globals: [0] <none>
[10:32:54.024] getGlobalsAndPackages() ... DONE
[10:32:54.024] run() for ‘Future’ ...
[10:32:54.024] - state: ‘created’
[10:32:54.024] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.029] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:54.029]   - Field: ‘label’
[10:32:54.029]   - Field: ‘local’
[10:32:54.029]   - Field: ‘owner’
[10:32:54.029]   - Field: ‘envir’
[10:32:54.029]   - Field: ‘workers’
[10:32:54.030]   - Field: ‘packages’
[10:32:54.030]   - Field: ‘gc’
[10:32:54.030]   - Field: ‘job’
[10:32:54.030]   - Field: ‘conditions’
[10:32:54.030]   - Field: ‘expr’
[10:32:54.030]   - Field: ‘uuid’
[10:32:54.030]   - Field: ‘seed’
[10:32:54.030]   - Field: ‘version’
[10:32:54.030]   - Field: ‘result’
[10:32:54.031]   - Field: ‘asynchronous’
[10:32:54.031]   - Field: ‘calls’
[10:32:54.031]   - Field: ‘globals’
[10:32:54.031]   - Field: ‘stdout’
[10:32:54.031]   - Field: ‘earlySignal’
[10:32:54.031]   - Field: ‘lazy’
[10:32:54.031]   - Field: ‘state’
[10:32:54.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:54.031] - Launch lazy future ...
[10:32:54.032] Packages needed by the future expression (n = 0): <none>
[10:32:54.032] Packages needed by future strategies (n = 0): <none>
[10:32:54.032] {
[10:32:54.032]     {
[10:32:54.032]         {
[10:32:54.032]             ...future.startTime <- base::Sys.time()
[10:32:54.032]             {
[10:32:54.032]                 {
[10:32:54.032]                   {
[10:32:54.032]                     {
[10:32:54.032]                       base::local({
[10:32:54.032]                         has_future <- base::requireNamespace("future", 
[10:32:54.032]                           quietly = TRUE)
[10:32:54.032]                         if (has_future) {
[10:32:54.032]                           ns <- base::getNamespace("future")
[10:32:54.032]                           version <- ns[[".package"]][["version"]]
[10:32:54.032]                           if (is.null(version)) 
[10:32:54.032]                             version <- utils::packageVersion("future")
[10:32:54.032]                         }
[10:32:54.032]                         else {
[10:32:54.032]                           version <- NULL
[10:32:54.032]                         }
[10:32:54.032]                         if (!has_future || version < "1.8.0") {
[10:32:54.032]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.032]                             "", base::R.version$version.string), 
[10:32:54.032]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.032]                               "release", "version")], collapse = " "), 
[10:32:54.032]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.032]                             info)
[10:32:54.032]                           info <- base::paste(info, collapse = "; ")
[10:32:54.032]                           if (!has_future) {
[10:32:54.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.032]                               info)
[10:32:54.032]                           }
[10:32:54.032]                           else {
[10:32:54.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.032]                               info, version)
[10:32:54.032]                           }
[10:32:54.032]                           base::stop(msg)
[10:32:54.032]                         }
[10:32:54.032]                       })
[10:32:54.032]                     }
[10:32:54.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.032]                     base::options(mc.cores = 1L)
[10:32:54.032]                   }
[10:32:54.032]                   ...future.strategy.old <- future::plan("list")
[10:32:54.032]                   options(future.plan = NULL)
[10:32:54.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.032]                 }
[10:32:54.032]                 ...future.workdir <- getwd()
[10:32:54.032]             }
[10:32:54.032]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.032]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.032]         }
[10:32:54.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.032]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.032]             base::names(...future.oldOptions))
[10:32:54.032]     }
[10:32:54.032]     if (FALSE) {
[10:32:54.032]     }
[10:32:54.032]     else {
[10:32:54.032]         if (TRUE) {
[10:32:54.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.032]                 open = "w")
[10:32:54.032]         }
[10:32:54.032]         else {
[10:32:54.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.032]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.032]         }
[10:32:54.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.032]             base::sink(type = "output", split = FALSE)
[10:32:54.032]             base::close(...future.stdout)
[10:32:54.032]         }, add = TRUE)
[10:32:54.032]     }
[10:32:54.032]     ...future.frame <- base::sys.nframe()
[10:32:54.032]     ...future.conditions <- base::list()
[10:32:54.032]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.032]     if (FALSE) {
[10:32:54.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.032]     }
[10:32:54.032]     ...future.result <- base::tryCatch({
[10:32:54.032]         base::withCallingHandlers({
[10:32:54.032]             ...future.value <- base::withVisible(base::local({
[10:32:54.032]                 withCallingHandlers({
[10:32:54.032]                   2
[10:32:54.032]                 }, immediateCondition = function(cond) {
[10:32:54.032]                   save_rds <- function (object, pathname, ...) 
[10:32:54.032]                   {
[10:32:54.032]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:54.032]                     if (file_test("-f", pathname_tmp)) {
[10:32:54.032]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.032]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:54.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.032]                         fi_tmp[["mtime"]])
[10:32:54.032]                     }
[10:32:54.032]                     tryCatch({
[10:32:54.032]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:54.032]                     }, error = function(ex) {
[10:32:54.032]                       msg <- conditionMessage(ex)
[10:32:54.032]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.032]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:54.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.032]                         fi_tmp[["mtime"]], msg)
[10:32:54.032]                       ex$message <- msg
[10:32:54.032]                       stop(ex)
[10:32:54.032]                     })
[10:32:54.032]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:54.032]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:54.032]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:54.032]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.032]                       fi <- file.info(pathname)
[10:32:54.032]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:54.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.032]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:54.032]                         fi[["size"]], fi[["mtime"]])
[10:32:54.032]                       stop(msg)
[10:32:54.032]                     }
[10:32:54.032]                     invisible(pathname)
[10:32:54.032]                   }
[10:32:54.032]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:54.032]                     rootPath = tempdir()) 
[10:32:54.032]                   {
[10:32:54.032]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:54.032]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:54.032]                       tmpdir = path, fileext = ".rds")
[10:32:54.032]                     save_rds(obj, file)
[10:32:54.032]                   }
[10:32:54.032]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:54.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.032]                   {
[10:32:54.032]                     inherits <- base::inherits
[10:32:54.032]                     invokeRestart <- base::invokeRestart
[10:32:54.032]                     is.null <- base::is.null
[10:32:54.032]                     muffled <- FALSE
[10:32:54.032]                     if (inherits(cond, "message")) {
[10:32:54.032]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.032]                       if (muffled) 
[10:32:54.032]                         invokeRestart("muffleMessage")
[10:32:54.032]                     }
[10:32:54.032]                     else if (inherits(cond, "warning")) {
[10:32:54.032]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.032]                       if (muffled) 
[10:32:54.032]                         invokeRestart("muffleWarning")
[10:32:54.032]                     }
[10:32:54.032]                     else if (inherits(cond, "condition")) {
[10:32:54.032]                       if (!is.null(pattern)) {
[10:32:54.032]                         computeRestarts <- base::computeRestarts
[10:32:54.032]                         grepl <- base::grepl
[10:32:54.032]                         restarts <- computeRestarts(cond)
[10:32:54.032]                         for (restart in restarts) {
[10:32:54.032]                           name <- restart$name
[10:32:54.032]                           if (is.null(name)) 
[10:32:54.032]                             next
[10:32:54.032]                           if (!grepl(pattern, name)) 
[10:32:54.032]                             next
[10:32:54.032]                           invokeRestart(restart)
[10:32:54.032]                           muffled <- TRUE
[10:32:54.032]                           break
[10:32:54.032]                         }
[10:32:54.032]                       }
[10:32:54.032]                     }
[10:32:54.032]                     invisible(muffled)
[10:32:54.032]                   }
[10:32:54.032]                   muffleCondition(cond)
[10:32:54.032]                 })
[10:32:54.032]             }))
[10:32:54.032]             future::FutureResult(value = ...future.value$value, 
[10:32:54.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.032]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.032]                     ...future.globalenv.names))
[10:32:54.032]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.032]         }, condition = base::local({
[10:32:54.032]             c <- base::c
[10:32:54.032]             inherits <- base::inherits
[10:32:54.032]             invokeRestart <- base::invokeRestart
[10:32:54.032]             length <- base::length
[10:32:54.032]             list <- base::list
[10:32:54.032]             seq.int <- base::seq.int
[10:32:54.032]             signalCondition <- base::signalCondition
[10:32:54.032]             sys.calls <- base::sys.calls
[10:32:54.032]             `[[` <- base::`[[`
[10:32:54.032]             `+` <- base::`+`
[10:32:54.032]             `<<-` <- base::`<<-`
[10:32:54.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.032]                   3L)]
[10:32:54.032]             }
[10:32:54.032]             function(cond) {
[10:32:54.032]                 is_error <- inherits(cond, "error")
[10:32:54.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.032]                   NULL)
[10:32:54.032]                 if (is_error) {
[10:32:54.032]                   sessionInformation <- function() {
[10:32:54.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.032]                       search = base::search(), system = base::Sys.info())
[10:32:54.032]                   }
[10:32:54.032]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.032]                     cond$call), session = sessionInformation(), 
[10:32:54.032]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.032]                   signalCondition(cond)
[10:32:54.032]                 }
[10:32:54.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.032]                 "immediateCondition"))) {
[10:32:54.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.032]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.032]                   if (TRUE && !signal) {
[10:32:54.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.032]                     {
[10:32:54.032]                       inherits <- base::inherits
[10:32:54.032]                       invokeRestart <- base::invokeRestart
[10:32:54.032]                       is.null <- base::is.null
[10:32:54.032]                       muffled <- FALSE
[10:32:54.032]                       if (inherits(cond, "message")) {
[10:32:54.032]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.032]                         if (muffled) 
[10:32:54.032]                           invokeRestart("muffleMessage")
[10:32:54.032]                       }
[10:32:54.032]                       else if (inherits(cond, "warning")) {
[10:32:54.032]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.032]                         if (muffled) 
[10:32:54.032]                           invokeRestart("muffleWarning")
[10:32:54.032]                       }
[10:32:54.032]                       else if (inherits(cond, "condition")) {
[10:32:54.032]                         if (!is.null(pattern)) {
[10:32:54.032]                           computeRestarts <- base::computeRestarts
[10:32:54.032]                           grepl <- base::grepl
[10:32:54.032]                           restarts <- computeRestarts(cond)
[10:32:54.032]                           for (restart in restarts) {
[10:32:54.032]                             name <- restart$name
[10:32:54.032]                             if (is.null(name)) 
[10:32:54.032]                               next
[10:32:54.032]                             if (!grepl(pattern, name)) 
[10:32:54.032]                               next
[10:32:54.032]                             invokeRestart(restart)
[10:32:54.032]                             muffled <- TRUE
[10:32:54.032]                             break
[10:32:54.032]                           }
[10:32:54.032]                         }
[10:32:54.032]                       }
[10:32:54.032]                       invisible(muffled)
[10:32:54.032]                     }
[10:32:54.032]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.032]                   }
[10:32:54.032]                 }
[10:32:54.032]                 else {
[10:32:54.032]                   if (TRUE) {
[10:32:54.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.032]                     {
[10:32:54.032]                       inherits <- base::inherits
[10:32:54.032]                       invokeRestart <- base::invokeRestart
[10:32:54.032]                       is.null <- base::is.null
[10:32:54.032]                       muffled <- FALSE
[10:32:54.032]                       if (inherits(cond, "message")) {
[10:32:54.032]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.032]                         if (muffled) 
[10:32:54.032]                           invokeRestart("muffleMessage")
[10:32:54.032]                       }
[10:32:54.032]                       else if (inherits(cond, "warning")) {
[10:32:54.032]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.032]                         if (muffled) 
[10:32:54.032]                           invokeRestart("muffleWarning")
[10:32:54.032]                       }
[10:32:54.032]                       else if (inherits(cond, "condition")) {
[10:32:54.032]                         if (!is.null(pattern)) {
[10:32:54.032]                           computeRestarts <- base::computeRestarts
[10:32:54.032]                           grepl <- base::grepl
[10:32:54.032]                           restarts <- computeRestarts(cond)
[10:32:54.032]                           for (restart in restarts) {
[10:32:54.032]                             name <- restart$name
[10:32:54.032]                             if (is.null(name)) 
[10:32:54.032]                               next
[10:32:54.032]                             if (!grepl(pattern, name)) 
[10:32:54.032]                               next
[10:32:54.032]                             invokeRestart(restart)
[10:32:54.032]                             muffled <- TRUE
[10:32:54.032]                             break
[10:32:54.032]                           }
[10:32:54.032]                         }
[10:32:54.032]                       }
[10:32:54.032]                       invisible(muffled)
[10:32:54.032]                     }
[10:32:54.032]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.032]                   }
[10:32:54.032]                 }
[10:32:54.032]             }
[10:32:54.032]         }))
[10:32:54.032]     }, error = function(ex) {
[10:32:54.032]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.032]                 ...future.rng), started = ...future.startTime, 
[10:32:54.032]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.032]             version = "1.8"), class = "FutureResult")
[10:32:54.032]     }, finally = {
[10:32:54.032]         if (!identical(...future.workdir, getwd())) 
[10:32:54.032]             setwd(...future.workdir)
[10:32:54.032]         {
[10:32:54.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.032]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.032]             }
[10:32:54.032]             base::options(...future.oldOptions)
[10:32:54.032]             if (.Platform$OS.type == "windows") {
[10:32:54.032]                 old_names <- names(...future.oldEnvVars)
[10:32:54.032]                 envs <- base::Sys.getenv()
[10:32:54.032]                 names <- names(envs)
[10:32:54.032]                 common <- intersect(names, old_names)
[10:32:54.032]                 added <- setdiff(names, old_names)
[10:32:54.032]                 removed <- setdiff(old_names, names)
[10:32:54.032]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.032]                   envs[common]]
[10:32:54.032]                 NAMES <- toupper(changed)
[10:32:54.032]                 args <- list()
[10:32:54.032]                 for (kk in seq_along(NAMES)) {
[10:32:54.032]                   name <- changed[[kk]]
[10:32:54.032]                   NAME <- NAMES[[kk]]
[10:32:54.032]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.032]                     next
[10:32:54.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.032]                 }
[10:32:54.032]                 NAMES <- toupper(added)
[10:32:54.032]                 for (kk in seq_along(NAMES)) {
[10:32:54.032]                   name <- added[[kk]]
[10:32:54.032]                   NAME <- NAMES[[kk]]
[10:32:54.032]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.032]                     next
[10:32:54.032]                   args[[name]] <- ""
[10:32:54.032]                 }
[10:32:54.032]                 NAMES <- toupper(removed)
[10:32:54.032]                 for (kk in seq_along(NAMES)) {
[10:32:54.032]                   name <- removed[[kk]]
[10:32:54.032]                   NAME <- NAMES[[kk]]
[10:32:54.032]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.032]                     next
[10:32:54.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.032]                 }
[10:32:54.032]                 if (length(args) > 0) 
[10:32:54.032]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.032]             }
[10:32:54.032]             else {
[10:32:54.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.032]             }
[10:32:54.032]             {
[10:32:54.032]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.032]                   0L) {
[10:32:54.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.032]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.032]                   base::options(opts)
[10:32:54.032]                 }
[10:32:54.032]                 {
[10:32:54.032]                   {
[10:32:54.032]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.032]                     NULL
[10:32:54.032]                   }
[10:32:54.032]                   options(future.plan = NULL)
[10:32:54.032]                   if (is.na(NA_character_)) 
[10:32:54.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.032]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.032]                     .init = FALSE)
[10:32:54.032]                 }
[10:32:54.032]             }
[10:32:54.032]         }
[10:32:54.032]     })
[10:32:54.032]     if (TRUE) {
[10:32:54.032]         base::sink(type = "output", split = FALSE)
[10:32:54.032]         if (TRUE) {
[10:32:54.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.032]         }
[10:32:54.032]         else {
[10:32:54.032]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.032]         }
[10:32:54.032]         base::close(...future.stdout)
[10:32:54.032]         ...future.stdout <- NULL
[10:32:54.032]     }
[10:32:54.032]     ...future.result$conditions <- ...future.conditions
[10:32:54.032]     ...future.result$finished <- base::Sys.time()
[10:32:54.032]     ...future.result
[10:32:54.032] }
[10:32:54.035] requestCore(): workers = 2
[10:32:54.037] MulticoreFuture started
[10:32:54.038] - Launch lazy future ... done
[10:32:54.038] run() for ‘MulticoreFuture’ ... done
[10:32:54.038] getGlobalsAndPackages() ...
[10:32:54.038] Searching for globals...
[10:32:54.038] plan(): Setting new future strategy stack:
[10:32:54.039] 
[10:32:54.039] List of future strategies:
[10:32:54.039] 1. sequential:
[10:32:54.039]    - args: function (..., envir = parent.frame())
[10:32:54.039]    - tweaked: FALSE
[10:32:54.039]    - call: NULL
[10:32:54.039] Searching for globals ... DONE
[10:32:54.039] - globals: [0] <none>
[10:32:54.039] plan(): nbrOfWorkers() = 1
[10:32:54.040] getGlobalsAndPackages() ... DONE
[10:32:54.040] run() for ‘Future’ ...
[10:32:54.040] - state: ‘created’
[10:32:54.040] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.041] plan(): Setting new future strategy stack:
[10:32:54.041] List of future strategies:
[10:32:54.041] 1. multicore:
[10:32:54.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:54.041]    - tweaked: FALSE
[10:32:54.041]    - call: plan(strategy)
[10:32:54.046] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.046] plan(): nbrOfWorkers() = 2
[10:32:54.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:54.046]   - Field: ‘label’
[10:32:54.046]   - Field: ‘local’
[10:32:54.046]   - Field: ‘owner’
[10:32:54.047]   - Field: ‘envir’
[10:32:54.047]   - Field: ‘workers’
[10:32:54.047]   - Field: ‘packages’
[10:32:54.047]   - Field: ‘gc’
[10:32:54.047]   - Field: ‘job’
[10:32:54.047]   - Field: ‘conditions’
[10:32:54.047]   - Field: ‘expr’
[10:32:54.048]   - Field: ‘uuid’
[10:32:54.048]   - Field: ‘seed’
[10:32:54.048]   - Field: ‘version’
[10:32:54.048]   - Field: ‘result’
[10:32:54.048]   - Field: ‘asynchronous’
[10:32:54.048]   - Field: ‘calls’
[10:32:54.048]   - Field: ‘globals’
[10:32:54.049]   - Field: ‘stdout’
[10:32:54.049]   - Field: ‘earlySignal’
[10:32:54.049]   - Field: ‘lazy’
[10:32:54.049]   - Field: ‘state’
[10:32:54.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:54.049] - Launch lazy future ...
[10:32:54.050] Packages needed by the future expression (n = 0): <none>
[10:32:54.050] Packages needed by future strategies (n = 0): <none>
[10:32:54.051] {
[10:32:54.051]     {
[10:32:54.051]         {
[10:32:54.051]             ...future.startTime <- base::Sys.time()
[10:32:54.051]             {
[10:32:54.051]                 {
[10:32:54.051]                   {
[10:32:54.051]                     {
[10:32:54.051]                       base::local({
[10:32:54.051]                         has_future <- base::requireNamespace("future", 
[10:32:54.051]                           quietly = TRUE)
[10:32:54.051]                         if (has_future) {
[10:32:54.051]                           ns <- base::getNamespace("future")
[10:32:54.051]                           version <- ns[[".package"]][["version"]]
[10:32:54.051]                           if (is.null(version)) 
[10:32:54.051]                             version <- utils::packageVersion("future")
[10:32:54.051]                         }
[10:32:54.051]                         else {
[10:32:54.051]                           version <- NULL
[10:32:54.051]                         }
[10:32:54.051]                         if (!has_future || version < "1.8.0") {
[10:32:54.051]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.051]                             "", base::R.version$version.string), 
[10:32:54.051]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.051]                               "release", "version")], collapse = " "), 
[10:32:54.051]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.051]                             info)
[10:32:54.051]                           info <- base::paste(info, collapse = "; ")
[10:32:54.051]                           if (!has_future) {
[10:32:54.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.051]                               info)
[10:32:54.051]                           }
[10:32:54.051]                           else {
[10:32:54.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.051]                               info, version)
[10:32:54.051]                           }
[10:32:54.051]                           base::stop(msg)
[10:32:54.051]                         }
[10:32:54.051]                       })
[10:32:54.051]                     }
[10:32:54.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.051]                     base::options(mc.cores = 1L)
[10:32:54.051]                   }
[10:32:54.051]                   ...future.strategy.old <- future::plan("list")
[10:32:54.051]                   options(future.plan = NULL)
[10:32:54.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.051]                 }
[10:32:54.051]                 ...future.workdir <- getwd()
[10:32:54.051]             }
[10:32:54.051]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.051]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.051]         }
[10:32:54.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.051]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.051]             base::names(...future.oldOptions))
[10:32:54.051]     }
[10:32:54.051]     if (FALSE) {
[10:32:54.051]     }
[10:32:54.051]     else {
[10:32:54.051]         if (TRUE) {
[10:32:54.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.051]                 open = "w")
[10:32:54.051]         }
[10:32:54.051]         else {
[10:32:54.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.051]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.051]         }
[10:32:54.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.051]             base::sink(type = "output", split = FALSE)
[10:32:54.051]             base::close(...future.stdout)
[10:32:54.051]         }, add = TRUE)
[10:32:54.051]     }
[10:32:54.051]     ...future.frame <- base::sys.nframe()
[10:32:54.051]     ...future.conditions <- base::list()
[10:32:54.051]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.051]     if (FALSE) {
[10:32:54.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.051]     }
[10:32:54.051]     ...future.result <- base::tryCatch({
[10:32:54.051]         base::withCallingHandlers({
[10:32:54.051]             ...future.value <- base::withVisible(base::local({
[10:32:54.051]                 withCallingHandlers({
[10:32:54.051]                   NULL
[10:32:54.051]                 }, immediateCondition = function(cond) {
[10:32:54.051]                   save_rds <- function (object, pathname, ...) 
[10:32:54.051]                   {
[10:32:54.051]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:54.051]                     if (file_test("-f", pathname_tmp)) {
[10:32:54.051]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.051]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:54.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.051]                         fi_tmp[["mtime"]])
[10:32:54.051]                     }
[10:32:54.051]                     tryCatch({
[10:32:54.051]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:54.051]                     }, error = function(ex) {
[10:32:54.051]                       msg <- conditionMessage(ex)
[10:32:54.051]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.051]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:54.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.051]                         fi_tmp[["mtime"]], msg)
[10:32:54.051]                       ex$message <- msg
[10:32:54.051]                       stop(ex)
[10:32:54.051]                     })
[10:32:54.051]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:54.051]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:54.051]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:54.051]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.051]                       fi <- file.info(pathname)
[10:32:54.051]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:54.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.051]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:54.051]                         fi[["size"]], fi[["mtime"]])
[10:32:54.051]                       stop(msg)
[10:32:54.051]                     }
[10:32:54.051]                     invisible(pathname)
[10:32:54.051]                   }
[10:32:54.051]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:54.051]                     rootPath = tempdir()) 
[10:32:54.051]                   {
[10:32:54.051]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:54.051]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:54.051]                       tmpdir = path, fileext = ".rds")
[10:32:54.051]                     save_rds(obj, file)
[10:32:54.051]                   }
[10:32:54.051]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:54.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.051]                   {
[10:32:54.051]                     inherits <- base::inherits
[10:32:54.051]                     invokeRestart <- base::invokeRestart
[10:32:54.051]                     is.null <- base::is.null
[10:32:54.051]                     muffled <- FALSE
[10:32:54.051]                     if (inherits(cond, "message")) {
[10:32:54.051]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.051]                       if (muffled) 
[10:32:54.051]                         invokeRestart("muffleMessage")
[10:32:54.051]                     }
[10:32:54.051]                     else if (inherits(cond, "warning")) {
[10:32:54.051]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.051]                       if (muffled) 
[10:32:54.051]                         invokeRestart("muffleWarning")
[10:32:54.051]                     }
[10:32:54.051]                     else if (inherits(cond, "condition")) {
[10:32:54.051]                       if (!is.null(pattern)) {
[10:32:54.051]                         computeRestarts <- base::computeRestarts
[10:32:54.051]                         grepl <- base::grepl
[10:32:54.051]                         restarts <- computeRestarts(cond)
[10:32:54.051]                         for (restart in restarts) {
[10:32:54.051]                           name <- restart$name
[10:32:54.051]                           if (is.null(name)) 
[10:32:54.051]                             next
[10:32:54.051]                           if (!grepl(pattern, name)) 
[10:32:54.051]                             next
[10:32:54.051]                           invokeRestart(restart)
[10:32:54.051]                           muffled <- TRUE
[10:32:54.051]                           break
[10:32:54.051]                         }
[10:32:54.051]                       }
[10:32:54.051]                     }
[10:32:54.051]                     invisible(muffled)
[10:32:54.051]                   }
[10:32:54.051]                   muffleCondition(cond)
[10:32:54.051]                 })
[10:32:54.051]             }))
[10:32:54.051]             future::FutureResult(value = ...future.value$value, 
[10:32:54.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.051]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.051]                     ...future.globalenv.names))
[10:32:54.051]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.051]         }, condition = base::local({
[10:32:54.051]             c <- base::c
[10:32:54.051]             inherits <- base::inherits
[10:32:54.051]             invokeRestart <- base::invokeRestart
[10:32:54.051]             length <- base::length
[10:32:54.051]             list <- base::list
[10:32:54.051]             seq.int <- base::seq.int
[10:32:54.051]             signalCondition <- base::signalCondition
[10:32:54.051]             sys.calls <- base::sys.calls
[10:32:54.051]             `[[` <- base::`[[`
[10:32:54.051]             `+` <- base::`+`
[10:32:54.051]             `<<-` <- base::`<<-`
[10:32:54.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.051]                   3L)]
[10:32:54.051]             }
[10:32:54.051]             function(cond) {
[10:32:54.051]                 is_error <- inherits(cond, "error")
[10:32:54.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.051]                   NULL)
[10:32:54.051]                 if (is_error) {
[10:32:54.051]                   sessionInformation <- function() {
[10:32:54.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.051]                       search = base::search(), system = base::Sys.info())
[10:32:54.051]                   }
[10:32:54.051]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.051]                     cond$call), session = sessionInformation(), 
[10:32:54.051]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.051]                   signalCondition(cond)
[10:32:54.051]                 }
[10:32:54.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.051]                 "immediateCondition"))) {
[10:32:54.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.051]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.051]                   if (TRUE && !signal) {
[10:32:54.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.051]                     {
[10:32:54.051]                       inherits <- base::inherits
[10:32:54.051]                       invokeRestart <- base::invokeRestart
[10:32:54.051]                       is.null <- base::is.null
[10:32:54.051]                       muffled <- FALSE
[10:32:54.051]                       if (inherits(cond, "message")) {
[10:32:54.051]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.051]                         if (muffled) 
[10:32:54.051]                           invokeRestart("muffleMessage")
[10:32:54.051]                       }
[10:32:54.051]                       else if (inherits(cond, "warning")) {
[10:32:54.051]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.051]                         if (muffled) 
[10:32:54.051]                           invokeRestart("muffleWarning")
[10:32:54.051]                       }
[10:32:54.051]                       else if (inherits(cond, "condition")) {
[10:32:54.051]                         if (!is.null(pattern)) {
[10:32:54.051]                           computeRestarts <- base::computeRestarts
[10:32:54.051]                           grepl <- base::grepl
[10:32:54.051]                           restarts <- computeRestarts(cond)
[10:32:54.051]                           for (restart in restarts) {
[10:32:54.051]                             name <- restart$name
[10:32:54.051]                             if (is.null(name)) 
[10:32:54.051]                               next
[10:32:54.051]                             if (!grepl(pattern, name)) 
[10:32:54.051]                               next
[10:32:54.051]                             invokeRestart(restart)
[10:32:54.051]                             muffled <- TRUE
[10:32:54.051]                             break
[10:32:54.051]                           }
[10:32:54.051]                         }
[10:32:54.051]                       }
[10:32:54.051]                       invisible(muffled)
[10:32:54.051]                     }
[10:32:54.051]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.051]                   }
[10:32:54.051]                 }
[10:32:54.051]                 else {
[10:32:54.051]                   if (TRUE) {
[10:32:54.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.051]                     {
[10:32:54.051]                       inherits <- base::inherits
[10:32:54.051]                       invokeRestart <- base::invokeRestart
[10:32:54.051]                       is.null <- base::is.null
[10:32:54.051]                       muffled <- FALSE
[10:32:54.051]                       if (inherits(cond, "message")) {
[10:32:54.051]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.051]                         if (muffled) 
[10:32:54.051]                           invokeRestart("muffleMessage")
[10:32:54.051]                       }
[10:32:54.051]                       else if (inherits(cond, "warning")) {
[10:32:54.051]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.051]                         if (muffled) 
[10:32:54.051]                           invokeRestart("muffleWarning")
[10:32:54.051]                       }
[10:32:54.051]                       else if (inherits(cond, "condition")) {
[10:32:54.051]                         if (!is.null(pattern)) {
[10:32:54.051]                           computeRestarts <- base::computeRestarts
[10:32:54.051]                           grepl <- base::grepl
[10:32:54.051]                           restarts <- computeRestarts(cond)
[10:32:54.051]                           for (restart in restarts) {
[10:32:54.051]                             name <- restart$name
[10:32:54.051]                             if (is.null(name)) 
[10:32:54.051]                               next
[10:32:54.051]                             if (!grepl(pattern, name)) 
[10:32:54.051]                               next
[10:32:54.051]                             invokeRestart(restart)
[10:32:54.051]                             muffled <- TRUE
[10:32:54.051]                             break
[10:32:54.051]                           }
[10:32:54.051]                         }
[10:32:54.051]                       }
[10:32:54.051]                       invisible(muffled)
[10:32:54.051]                     }
[10:32:54.051]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.051]                   }
[10:32:54.051]                 }
[10:32:54.051]             }
[10:32:54.051]         }))
[10:32:54.051]     }, error = function(ex) {
[10:32:54.051]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.051]                 ...future.rng), started = ...future.startTime, 
[10:32:54.051]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.051]             version = "1.8"), class = "FutureResult")
[10:32:54.051]     }, finally = {
[10:32:54.051]         if (!identical(...future.workdir, getwd())) 
[10:32:54.051]             setwd(...future.workdir)
[10:32:54.051]         {
[10:32:54.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.051]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.051]             }
[10:32:54.051]             base::options(...future.oldOptions)
[10:32:54.051]             if (.Platform$OS.type == "windows") {
[10:32:54.051]                 old_names <- names(...future.oldEnvVars)
[10:32:54.051]                 envs <- base::Sys.getenv()
[10:32:54.051]                 names <- names(envs)
[10:32:54.051]                 common <- intersect(names, old_names)
[10:32:54.051]                 added <- setdiff(names, old_names)
[10:32:54.051]                 removed <- setdiff(old_names, names)
[10:32:54.051]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.051]                   envs[common]]
[10:32:54.051]                 NAMES <- toupper(changed)
[10:32:54.051]                 args <- list()
[10:32:54.051]                 for (kk in seq_along(NAMES)) {
[10:32:54.051]                   name <- changed[[kk]]
[10:32:54.051]                   NAME <- NAMES[[kk]]
[10:32:54.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.051]                     next
[10:32:54.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.051]                 }
[10:32:54.051]                 NAMES <- toupper(added)
[10:32:54.051]                 for (kk in seq_along(NAMES)) {
[10:32:54.051]                   name <- added[[kk]]
[10:32:54.051]                   NAME <- NAMES[[kk]]
[10:32:54.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.051]                     next
[10:32:54.051]                   args[[name]] <- ""
[10:32:54.051]                 }
[10:32:54.051]                 NAMES <- toupper(removed)
[10:32:54.051]                 for (kk in seq_along(NAMES)) {
[10:32:54.051]                   name <- removed[[kk]]
[10:32:54.051]                   NAME <- NAMES[[kk]]
[10:32:54.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.051]                     next
[10:32:54.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.051]                 }
[10:32:54.051]                 if (length(args) > 0) 
[10:32:54.051]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.051]             }
[10:32:54.051]             else {
[10:32:54.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.051]             }
[10:32:54.051]             {
[10:32:54.051]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.051]                   0L) {
[10:32:54.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.051]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.051]                   base::options(opts)
[10:32:54.051]                 }
[10:32:54.051]                 {
[10:32:54.051]                   {
[10:32:54.051]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.051]                     NULL
[10:32:54.051]                   }
[10:32:54.051]                   options(future.plan = NULL)
[10:32:54.051]                   if (is.na(NA_character_)) 
[10:32:54.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.051]                     .init = FALSE)
[10:32:54.051]                 }
[10:32:54.051]             }
[10:32:54.051]         }
[10:32:54.051]     })
[10:32:54.051]     if (TRUE) {
[10:32:54.051]         base::sink(type = "output", split = FALSE)
[10:32:54.051]         if (TRUE) {
[10:32:54.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.051]         }
[10:32:54.051]         else {
[10:32:54.051]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.051]         }
[10:32:54.051]         base::close(...future.stdout)
[10:32:54.051]         ...future.stdout <- NULL
[10:32:54.051]     }
[10:32:54.051]     ...future.result$conditions <- ...future.conditions
[10:32:54.051]     ...future.result$finished <- base::Sys.time()
[10:32:54.051]     ...future.result
[10:32:54.051] }
[10:32:54.054] requestCore(): workers = 2
[10:32:54.057] MulticoreFuture started
[10:32:54.057] - Launch lazy future ... done
[10:32:54.057] run() for ‘MulticoreFuture’ ... done
[10:32:54.058] plan(): Setting new future strategy stack:
[10:32:54.058] getGlobalsAndPackages() ...
[10:32:54.058] Searching for globals...
[10:32:54.058] List of future strategies:
[10:32:54.058] 1. sequential:
[10:32:54.058]    - args: function (..., envir = parent.frame())
[10:32:54.058]    - tweaked: FALSE
[10:32:54.058]    - call: NULL
[10:32:54.059] plan(): nbrOfWorkers() = 1
[10:32:54.060] - globals found: [1] ‘{’
[10:32:54.060] Searching for globals ... DONE
[10:32:54.060] Resolving globals: FALSE
[10:32:54.060] 
[10:32:54.061] 
[10:32:54.061] plan(): Setting new future strategy stack:
[10:32:54.061] getGlobalsAndPackages() ... DONE
[10:32:54.061] List of future strategies:
[10:32:54.061] 1. multicore:
[10:32:54.061]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:54.061]    - tweaked: FALSE
[10:32:54.061]    - call: plan(strategy)
[10:32:54.061] run() for ‘Future’ ...
[10:32:54.061] - state: ‘created’
[10:32:54.062] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.066] plan(): nbrOfWorkers() = 2
[10:32:54.066] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:54.067]   - Field: ‘label’
[10:32:54.067]   - Field: ‘local’
[10:32:54.067]   - Field: ‘owner’
[10:32:54.067]   - Field: ‘envir’
[10:32:54.067]   - Field: ‘workers’
[10:32:54.067]   - Field: ‘packages’
[10:32:54.068]   - Field: ‘gc’
[10:32:54.068]   - Field: ‘job’
[10:32:54.068]   - Field: ‘conditions’
[10:32:54.068]   - Field: ‘expr’
[10:32:54.068]   - Field: ‘uuid’
[10:32:54.068]   - Field: ‘seed’
[10:32:54.068]   - Field: ‘version’
[10:32:54.069]   - Field: ‘result’
[10:32:54.069]   - Field: ‘asynchronous’
[10:32:54.069]   - Field: ‘calls’
[10:32:54.069]   - Field: ‘globals’
[10:32:54.069]   - Field: ‘stdout’
[10:32:54.069]   - Field: ‘earlySignal’
[10:32:54.069]   - Field: ‘lazy’
[10:32:54.070]   - Field: ‘state’
[10:32:54.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:54.070] - Launch lazy future ...
[10:32:54.070] Packages needed by the future expression (n = 0): <none>
[10:32:54.071] Packages needed by future strategies (n = 0): <none>
[10:32:54.071] {
[10:32:54.071]     {
[10:32:54.071]         {
[10:32:54.071]             ...future.startTime <- base::Sys.time()
[10:32:54.071]             {
[10:32:54.071]                 {
[10:32:54.071]                   {
[10:32:54.071]                     {
[10:32:54.071]                       base::local({
[10:32:54.071]                         has_future <- base::requireNamespace("future", 
[10:32:54.071]                           quietly = TRUE)
[10:32:54.071]                         if (has_future) {
[10:32:54.071]                           ns <- base::getNamespace("future")
[10:32:54.071]                           version <- ns[[".package"]][["version"]]
[10:32:54.071]                           if (is.null(version)) 
[10:32:54.071]                             version <- utils::packageVersion("future")
[10:32:54.071]                         }
[10:32:54.071]                         else {
[10:32:54.071]                           version <- NULL
[10:32:54.071]                         }
[10:32:54.071]                         if (!has_future || version < "1.8.0") {
[10:32:54.071]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.071]                             "", base::R.version$version.string), 
[10:32:54.071]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.071]                               "release", "version")], collapse = " "), 
[10:32:54.071]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.071]                             info)
[10:32:54.071]                           info <- base::paste(info, collapse = "; ")
[10:32:54.071]                           if (!has_future) {
[10:32:54.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.071]                               info)
[10:32:54.071]                           }
[10:32:54.071]                           else {
[10:32:54.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.071]                               info, version)
[10:32:54.071]                           }
[10:32:54.071]                           base::stop(msg)
[10:32:54.071]                         }
[10:32:54.071]                       })
[10:32:54.071]                     }
[10:32:54.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.071]                     base::options(mc.cores = 1L)
[10:32:54.071]                   }
[10:32:54.071]                   ...future.strategy.old <- future::plan("list")
[10:32:54.071]                   options(future.plan = NULL)
[10:32:54.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.071]                 }
[10:32:54.071]                 ...future.workdir <- getwd()
[10:32:54.071]             }
[10:32:54.071]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.071]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.071]         }
[10:32:54.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.071]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.071]             base::names(...future.oldOptions))
[10:32:54.071]     }
[10:32:54.071]     if (FALSE) {
[10:32:54.071]     }
[10:32:54.071]     else {
[10:32:54.071]         if (TRUE) {
[10:32:54.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.071]                 open = "w")
[10:32:54.071]         }
[10:32:54.071]         else {
[10:32:54.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.071]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.071]         }
[10:32:54.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.071]             base::sink(type = "output", split = FALSE)
[10:32:54.071]             base::close(...future.stdout)
[10:32:54.071]         }, add = TRUE)
[10:32:54.071]     }
[10:32:54.071]     ...future.frame <- base::sys.nframe()
[10:32:54.071]     ...future.conditions <- base::list()
[10:32:54.071]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.071]     if (FALSE) {
[10:32:54.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.071]     }
[10:32:54.071]     ...future.result <- base::tryCatch({
[10:32:54.071]         base::withCallingHandlers({
[10:32:54.071]             ...future.value <- base::withVisible(base::local({
[10:32:54.071]                 withCallingHandlers({
[10:32:54.071]                   {
[10:32:54.071]                     4
[10:32:54.071]                   }
[10:32:54.071]                 }, immediateCondition = function(cond) {
[10:32:54.071]                   save_rds <- function (object, pathname, ...) 
[10:32:54.071]                   {
[10:32:54.071]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:54.071]                     if (file_test("-f", pathname_tmp)) {
[10:32:54.071]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.071]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:54.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.071]                         fi_tmp[["mtime"]])
[10:32:54.071]                     }
[10:32:54.071]                     tryCatch({
[10:32:54.071]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:54.071]                     }, error = function(ex) {
[10:32:54.071]                       msg <- conditionMessage(ex)
[10:32:54.071]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.071]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:54.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.071]                         fi_tmp[["mtime"]], msg)
[10:32:54.071]                       ex$message <- msg
[10:32:54.071]                       stop(ex)
[10:32:54.071]                     })
[10:32:54.071]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:54.071]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:54.071]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:54.071]                       fi_tmp <- file.info(pathname_tmp)
[10:32:54.071]                       fi <- file.info(pathname)
[10:32:54.071]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:54.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:54.071]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:54.071]                         fi[["size"]], fi[["mtime"]])
[10:32:54.071]                       stop(msg)
[10:32:54.071]                     }
[10:32:54.071]                     invisible(pathname)
[10:32:54.071]                   }
[10:32:54.071]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:54.071]                     rootPath = tempdir()) 
[10:32:54.071]                   {
[10:32:54.071]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:54.071]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:54.071]                       tmpdir = path, fileext = ".rds")
[10:32:54.071]                     save_rds(obj, file)
[10:32:54.071]                   }
[10:32:54.071]                   saveImmediateCondition(cond, path = "/tmp/RtmpvxlbHV/.future/immediateConditions")
[10:32:54.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.071]                   {
[10:32:54.071]                     inherits <- base::inherits
[10:32:54.071]                     invokeRestart <- base::invokeRestart
[10:32:54.071]                     is.null <- base::is.null
[10:32:54.071]                     muffled <- FALSE
[10:32:54.071]                     if (inherits(cond, "message")) {
[10:32:54.071]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.071]                       if (muffled) 
[10:32:54.071]                         invokeRestart("muffleMessage")
[10:32:54.071]                     }
[10:32:54.071]                     else if (inherits(cond, "warning")) {
[10:32:54.071]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.071]                       if (muffled) 
[10:32:54.071]                         invokeRestart("muffleWarning")
[10:32:54.071]                     }
[10:32:54.071]                     else if (inherits(cond, "condition")) {
[10:32:54.071]                       if (!is.null(pattern)) {
[10:32:54.071]                         computeRestarts <- base::computeRestarts
[10:32:54.071]                         grepl <- base::grepl
[10:32:54.071]                         restarts <- computeRestarts(cond)
[10:32:54.071]                         for (restart in restarts) {
[10:32:54.071]                           name <- restart$name
[10:32:54.071]                           if (is.null(name)) 
[10:32:54.071]                             next
[10:32:54.071]                           if (!grepl(pattern, name)) 
[10:32:54.071]                             next
[10:32:54.071]                           invokeRestart(restart)
[10:32:54.071]                           muffled <- TRUE
[10:32:54.071]                           break
[10:32:54.071]                         }
[10:32:54.071]                       }
[10:32:54.071]                     }
[10:32:54.071]                     invisible(muffled)
[10:32:54.071]                   }
[10:32:54.071]                   muffleCondition(cond)
[10:32:54.071]                 })
[10:32:54.071]             }))
[10:32:54.071]             future::FutureResult(value = ...future.value$value, 
[10:32:54.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.071]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.071]                     ...future.globalenv.names))
[10:32:54.071]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.071]         }, condition = base::local({
[10:32:54.071]             c <- base::c
[10:32:54.071]             inherits <- base::inherits
[10:32:54.071]             invokeRestart <- base::invokeRestart
[10:32:54.071]             length <- base::length
[10:32:54.071]             list <- base::list
[10:32:54.071]             seq.int <- base::seq.int
[10:32:54.071]             signalCondition <- base::signalCondition
[10:32:54.071]             sys.calls <- base::sys.calls
[10:32:54.071]             `[[` <- base::`[[`
[10:32:54.071]             `+` <- base::`+`
[10:32:54.071]             `<<-` <- base::`<<-`
[10:32:54.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.071]                   3L)]
[10:32:54.071]             }
[10:32:54.071]             function(cond) {
[10:32:54.071]                 is_error <- inherits(cond, "error")
[10:32:54.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.071]                   NULL)
[10:32:54.071]                 if (is_error) {
[10:32:54.071]                   sessionInformation <- function() {
[10:32:54.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.071]                       search = base::search(), system = base::Sys.info())
[10:32:54.071]                   }
[10:32:54.071]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.071]                     cond$call), session = sessionInformation(), 
[10:32:54.071]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.071]                   signalCondition(cond)
[10:32:54.071]                 }
[10:32:54.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.071]                 "immediateCondition"))) {
[10:32:54.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.071]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.071]                   if (TRUE && !signal) {
[10:32:54.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.071]                     {
[10:32:54.071]                       inherits <- base::inherits
[10:32:54.071]                       invokeRestart <- base::invokeRestart
[10:32:54.071]                       is.null <- base::is.null
[10:32:54.071]                       muffled <- FALSE
[10:32:54.071]                       if (inherits(cond, "message")) {
[10:32:54.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.071]                         if (muffled) 
[10:32:54.071]                           invokeRestart("muffleMessage")
[10:32:54.071]                       }
[10:32:54.071]                       else if (inherits(cond, "warning")) {
[10:32:54.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.071]                         if (muffled) 
[10:32:54.071]                           invokeRestart("muffleWarning")
[10:32:54.071]                       }
[10:32:54.071]                       else if (inherits(cond, "condition")) {
[10:32:54.071]                         if (!is.null(pattern)) {
[10:32:54.071]                           computeRestarts <- base::computeRestarts
[10:32:54.071]                           grepl <- base::grepl
[10:32:54.071]                           restarts <- computeRestarts(cond)
[10:32:54.071]                           for (restart in restarts) {
[10:32:54.071]                             name <- restart$name
[10:32:54.071]                             if (is.null(name)) 
[10:32:54.071]                               next
[10:32:54.071]                             if (!grepl(pattern, name)) 
[10:32:54.071]                               next
[10:32:54.071]                             invokeRestart(restart)
[10:32:54.071]                             muffled <- TRUE
[10:32:54.071]                             break
[10:32:54.071]                           }
[10:32:54.071]                         }
[10:32:54.071]                       }
[10:32:54.071]                       invisible(muffled)
[10:32:54.071]                     }
[10:32:54.071]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.071]                   }
[10:32:54.071]                 }
[10:32:54.071]                 else {
[10:32:54.071]                   if (TRUE) {
[10:32:54.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.071]                     {
[10:32:54.071]                       inherits <- base::inherits
[10:32:54.071]                       invokeRestart <- base::invokeRestart
[10:32:54.071]                       is.null <- base::is.null
[10:32:54.071]                       muffled <- FALSE
[10:32:54.071]                       if (inherits(cond, "message")) {
[10:32:54.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.071]                         if (muffled) 
[10:32:54.071]                           invokeRestart("muffleMessage")
[10:32:54.071]                       }
[10:32:54.071]                       else if (inherits(cond, "warning")) {
[10:32:54.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.071]                         if (muffled) 
[10:32:54.071]                           invokeRestart("muffleWarning")
[10:32:54.071]                       }
[10:32:54.071]                       else if (inherits(cond, "condition")) {
[10:32:54.071]                         if (!is.null(pattern)) {
[10:32:54.071]                           computeRestarts <- base::computeRestarts
[10:32:54.071]                           grepl <- base::grepl
[10:32:54.071]                           restarts <- computeRestarts(cond)
[10:32:54.071]                           for (restart in restarts) {
[10:32:54.071]                             name <- restart$name
[10:32:54.071]                             if (is.null(name)) 
[10:32:54.071]                               next
[10:32:54.071]                             if (!grepl(pattern, name)) 
[10:32:54.071]                               next
[10:32:54.071]                             invokeRestart(restart)
[10:32:54.071]                             muffled <- TRUE
[10:32:54.071]                             break
[10:32:54.071]                           }
[10:32:54.071]                         }
[10:32:54.071]                       }
[10:32:54.071]                       invisible(muffled)
[10:32:54.071]                     }
[10:32:54.071]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.071]                   }
[10:32:54.071]                 }
[10:32:54.071]             }
[10:32:54.071]         }))
[10:32:54.071]     }, error = function(ex) {
[10:32:54.071]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.071]                 ...future.rng), started = ...future.startTime, 
[10:32:54.071]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.071]             version = "1.8"), class = "FutureResult")
[10:32:54.071]     }, finally = {
[10:32:54.071]         if (!identical(...future.workdir, getwd())) 
[10:32:54.071]             setwd(...future.workdir)
[10:32:54.071]         {
[10:32:54.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.071]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.071]             }
[10:32:54.071]             base::options(...future.oldOptions)
[10:32:54.071]             if (.Platform$OS.type == "windows") {
[10:32:54.071]                 old_names <- names(...future.oldEnvVars)
[10:32:54.071]                 envs <- base::Sys.getenv()
[10:32:54.071]                 names <- names(envs)
[10:32:54.071]                 common <- intersect(names, old_names)
[10:32:54.071]                 added <- setdiff(names, old_names)
[10:32:54.071]                 removed <- setdiff(old_names, names)
[10:32:54.071]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.071]                   envs[common]]
[10:32:54.071]                 NAMES <- toupper(changed)
[10:32:54.071]                 args <- list()
[10:32:54.071]                 for (kk in seq_along(NAMES)) {
[10:32:54.071]                   name <- changed[[kk]]
[10:32:54.071]                   NAME <- NAMES[[kk]]
[10:32:54.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.071]                     next
[10:32:54.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.071]                 }
[10:32:54.071]                 NAMES <- toupper(added)
[10:32:54.071]                 for (kk in seq_along(NAMES)) {
[10:32:54.071]                   name <- added[[kk]]
[10:32:54.071]                   NAME <- NAMES[[kk]]
[10:32:54.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.071]                     next
[10:32:54.071]                   args[[name]] <- ""
[10:32:54.071]                 }
[10:32:54.071]                 NAMES <- toupper(removed)
[10:32:54.071]                 for (kk in seq_along(NAMES)) {
[10:32:54.071]                   name <- removed[[kk]]
[10:32:54.071]                   NAME <- NAMES[[kk]]
[10:32:54.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.071]                     next
[10:32:54.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.071]                 }
[10:32:54.071]                 if (length(args) > 0) 
[10:32:54.071]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.071]             }
[10:32:54.071]             else {
[10:32:54.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.071]             }
[10:32:54.071]             {
[10:32:54.071]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.071]                   0L) {
[10:32:54.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.071]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.071]                   base::options(opts)
[10:32:54.071]                 }
[10:32:54.071]                 {
[10:32:54.071]                   {
[10:32:54.071]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.071]                     NULL
[10:32:54.071]                   }
[10:32:54.071]                   options(future.plan = NULL)
[10:32:54.071]                   if (is.na(NA_character_)) 
[10:32:54.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.071]                     .init = FALSE)
[10:32:54.071]                 }
[10:32:54.071]             }
[10:32:54.071]         }
[10:32:54.071]     })
[10:32:54.071]     if (TRUE) {
[10:32:54.071]         base::sink(type = "output", split = FALSE)
[10:32:54.071]         if (TRUE) {
[10:32:54.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.071]         }
[10:32:54.071]         else {
[10:32:54.071]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.071]         }
[10:32:54.071]         base::close(...future.stdout)
[10:32:54.071]         ...future.stdout <- NULL
[10:32:54.071]     }
[10:32:54.071]     ...future.result$conditions <- ...future.conditions
[10:32:54.071]     ...future.result$finished <- base::Sys.time()
[10:32:54.071]     ...future.result
[10:32:54.071] }
[10:32:54.075] requestCore(): workers = 2
[10:32:54.075] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:54.086] result() for MulticoreFuture ...
[10:32:54.087] result() for MulticoreFuture ...
[10:32:54.087] result() for MulticoreFuture ... done
[10:32:54.087] result() for MulticoreFuture ... done
[10:32:54.087] result() for MulticoreFuture ...
[10:32:54.087] result() for MulticoreFuture ... done
[10:32:54.090] MulticoreFuture started
[10:32:54.090] - Launch lazy future ... done
[10:32:54.091] run() for ‘MulticoreFuture’ ... done
[10:32:54.091] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5652d2085b38> 
[10:32:54.091] List of future strategies:
[10:32:54.091] 1. sequential:
[10:32:54.091]    - args: function (..., envir = parent.frame())
[10:32:54.091]    - tweaked: FALSE
[10:32:54.091]    - call: NULL
[10:32:54.093] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5652d2c6e8b0> 
 - attr(*, "dim.")=[10:32:54.095] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[10:32:54.095] List of future strategies:
[10:32:54.095] 1. multicore:
[10:32:54.095]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:54.095]    - tweaked: FALSE
[10:32:54.095]    - call: plan(strategy)
List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:54.102] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:54.115] resolve() on list environment ...
[10:32:54.115]  recursive: 0
[10:32:54.117]  length: 6
[10:32:54.117]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:54.117] signalConditionsASAP(numeric, pos=1) ...
[10:32:54.117] - nx: 6
[10:32:54.117] - relay: TRUE
[10:32:54.117] - stdout: TRUE
[10:32:54.118] - signal: TRUE
[10:32:54.118] - resignal: FALSE
[10:32:54.118] - force: TRUE
[10:32:54.118] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.118]  - until=2
[10:32:54.118]  - relaying element #2
[10:32:54.119] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.119] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.119] signalConditionsASAP(NULL, pos=1) ... done
[10:32:54.119]  length: 5 (resolved future 1)
[10:32:54.119] Future #2
[10:32:54.119] result() for MulticoreFuture ...
[10:32:54.119] result() for MulticoreFuture ... done
[10:32:54.120] result() for MulticoreFuture ...
[10:32:54.120] result() for MulticoreFuture ... done
[10:32:54.120] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:32:54.120] - nx: 6
[10:32:54.120] - relay: TRUE
[10:32:54.120] - stdout: TRUE
[10:32:54.120] - signal: TRUE
[10:32:54.120] - resignal: FALSE
[10:32:54.121] - force: TRUE
[10:32:54.121] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.121]  - until=2
[10:32:54.121]  - relaying element #2
[10:32:54.121] result() for MulticoreFuture ...
[10:32:54.121] result() for MulticoreFuture ... done
[10:32:54.122] result() for MulticoreFuture ...
[10:32:54.122] result() for MulticoreFuture ... done
[10:32:54.122] result() for MulticoreFuture ...
[10:32:54.122] result() for MulticoreFuture ... done
[10:32:54.122] result() for MulticoreFuture ...
[10:32:54.122] result() for MulticoreFuture ... done
[10:32:54.122] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.123] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.123] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:32:54.123]  length: 4 (resolved future 2)
[10:32:54.123] Future #3
[10:32:54.123] result() for MulticoreFuture ...
[10:32:54.124] result() for MulticoreFuture ...
[10:32:54.124] result() for MulticoreFuture ... done
[10:32:54.124] result() for MulticoreFuture ... done
[10:32:54.125] result() for MulticoreFuture ...
[10:32:54.125] result() for MulticoreFuture ... done
[10:32:54.125] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:32:54.125] - nx: 6
[10:32:54.125] - relay: TRUE
[10:32:54.125] - stdout: TRUE
[10:32:54.125] - signal: TRUE
[10:32:54.126] - resignal: FALSE
[10:32:54.126] - force: TRUE
[10:32:54.126] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.126] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.126]  - until=3
[10:32:54.126]  - relaying element #3
[10:32:54.126] result() for MulticoreFuture ...
[10:32:54.126] result() for MulticoreFuture ... done
[10:32:54.126] result() for MulticoreFuture ...
[10:32:54.127] result() for MulticoreFuture ... done
[10:32:54.127] result() for MulticoreFuture ...
[10:32:54.127] result() for MulticoreFuture ... done
[10:32:54.127] result() for MulticoreFuture ...
[10:32:54.127] result() for MulticoreFuture ... done
[10:32:54.127] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.127] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.128] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:32:54.128]  length: 3 (resolved future 3)
[10:32:54.128] Future #4
[10:32:54.128] result() for MulticoreFuture ...
[10:32:54.129] result() for MulticoreFuture ...
[10:32:54.129] result() for MulticoreFuture ... done
[10:32:54.129] result() for MulticoreFuture ... done
[10:32:54.129] result() for MulticoreFuture ...
[10:32:54.130] result() for MulticoreFuture ... done
[10:32:54.130] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:32:54.130] - nx: 6
[10:32:54.130] - relay: TRUE
[10:32:54.130] - stdout: TRUE
[10:32:54.130] - signal: TRUE
[10:32:54.130] - resignal: FALSE
[10:32:54.131] - force: TRUE
[10:32:54.131] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.131] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.131]  - until=4
[10:32:54.131]  - relaying element #4
[10:32:54.131] result() for MulticoreFuture ...
[10:32:54.132] result() for MulticoreFuture ... done
[10:32:54.132] result() for MulticoreFuture ...
[10:32:54.132] result() for MulticoreFuture ... done
[10:32:54.132] result() for MulticoreFuture ...
[10:32:54.132] result() for MulticoreFuture ... done
[10:32:54.132] result() for MulticoreFuture ...
[10:32:54.132] result() for MulticoreFuture ... done
[10:32:54.133] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.133] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.133] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:32:54.133]  length: 2 (resolved future 4)
[10:32:54.133] signalConditionsASAP(NULL, pos=5) ...
[10:32:54.133] - nx: 6
[10:32:54.134] - relay: TRUE
[10:32:54.134] - stdout: TRUE
[10:32:54.134] - signal: TRUE
[10:32:54.134] - resignal: FALSE
[10:32:54.134] - force: TRUE
[10:32:54.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.134] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.134]  - until=6
[10:32:54.134]  - relaying element #6
[10:32:54.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.135] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.135] signalConditionsASAP(NULL, pos=5) ... done
[10:32:54.135]  length: 1 (resolved future 5)
[10:32:54.135] signalConditionsASAP(numeric, pos=6) ...
[10:32:54.135] - nx: 6
[10:32:54.135] - relay: TRUE
[10:32:54.135] - stdout: TRUE
[10:32:54.135] - signal: TRUE
[10:32:54.135] - resignal: FALSE
[10:32:54.135] - force: TRUE
[10:32:54.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.136] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.136]  - until=6
[10:32:54.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.136] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.136] signalConditionsASAP(numeric, pos=6) ... done
[10:32:54.136]  length: 0 (resolved future 6)
[10:32:54.136] Relaying remaining futures
[10:32:54.136] signalConditionsASAP(NULL, pos=0) ...
[10:32:54.137] - nx: 6
[10:32:54.137] - relay: TRUE
[10:32:54.137] - stdout: TRUE
[10:32:54.137] - signal: TRUE
[10:32:54.137] - resignal: FALSE
[10:32:54.137] - force: TRUE
[10:32:54.137] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.137] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:54.137] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.138] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.138] signalConditionsASAP(NULL, pos=0) ... done
[10:32:54.138] resolve() on list environment ... DONE
[10:32:54.138] result() for MulticoreFuture ...
[10:32:54.138] result() for MulticoreFuture ... done
[10:32:54.138] result() for MulticoreFuture ...
[10:32:54.138] result() for MulticoreFuture ... done
[10:32:54.138] result() for MulticoreFuture ...
[10:32:54.138] result() for MulticoreFuture ... done
[10:32:54.139] result() for MulticoreFuture ...
[10:32:54.139] result() for MulticoreFuture ... done
[10:32:54.139] result() for MulticoreFuture ...
[10:32:54.139] result() for MulticoreFuture ... done
[10:32:54.139] result() for MulticoreFuture ...
[10:32:54.139] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d17e29d8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[10:32:54.142] plan(): Setting new future strategy stack:
[10:32:54.142] List of future strategies:
[10:32:54.142] 1. multisession:
[10:32:54.142]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:54.142]    - tweaked: FALSE
[10:32:54.142]    - call: plan(strategy)
[10:32:54.142] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:32:54.143] multisession:
[10:32:54.143] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:54.143] - tweaked: FALSE
[10:32:54.143] - call: plan(strategy)
[10:32:54.147] getGlobalsAndPackages() ...
[10:32:54.147] Not searching for globals
[10:32:54.147] - globals: [0] <none>
[10:32:54.148] getGlobalsAndPackages() ... DONE
[10:32:54.148] [local output] makeClusterPSOCK() ...
[10:32:54.152] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:32:54.153] [local output] Base port: 11175
[10:32:54.153] [local output] Getting setup options for 2 cluster nodes ...
[10:32:54.153] [local output]  - Node 1 of 2 ...
[10:32:54.153] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:54.154] [local output] Rscript port: 11175

[10:32:54.154] [local output]  - Node 2 of 2 ...
[10:32:54.155] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:54.155] [local output] Rscript port: 11175

[10:32:54.156] [local output] Getting setup options for 2 cluster nodes ... done
[10:32:54.156] [local output]  - Parallel setup requested for some PSOCK nodes
[10:32:54.156] [local output] Setting up PSOCK nodes in parallel
[10:32:54.156] List of 36
[10:32:54.156]  $ worker          : chr "localhost"
[10:32:54.156]   ..- attr(*, "localhost")= logi TRUE
[10:32:54.156]  $ master          : chr "localhost"
[10:32:54.156]  $ port            : int 11175
[10:32:54.156]  $ connectTimeout  : num 120
[10:32:54.156]  $ timeout         : num 2592000
[10:32:54.156]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:32:54.156]  $ homogeneous     : logi TRUE
[10:32:54.156]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:32:54.156]  $ rscript_envs    : NULL
[10:32:54.156]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:54.156]  $ rscript_startup : NULL
[10:32:54.156]  $ rscript_sh      : chr "sh"
[10:32:54.156]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:54.156]  $ methods         : logi TRUE
[10:32:54.156]  $ socketOptions   : chr "no-delay"
[10:32:54.156]  $ useXDR          : logi FALSE
[10:32:54.156]  $ outfile         : chr "/dev/null"
[10:32:54.156]  $ renice          : int NA
[10:32:54.156]  $ rshcmd          : NULL
[10:32:54.156]  $ user            : chr(0) 
[10:32:54.156]  $ revtunnel       : logi FALSE
[10:32:54.156]  $ rshlogfile      : NULL
[10:32:54.156]  $ rshopts         : chr(0) 
[10:32:54.156]  $ rank            : int 1
[10:32:54.156]  $ manual          : logi FALSE
[10:32:54.156]  $ dryrun          : logi FALSE
[10:32:54.156]  $ quiet           : logi FALSE
[10:32:54.156]  $ setup_strategy  : chr "parallel"
[10:32:54.156]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:54.156]  $ pidfile         : chr "/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6942726bb3.pid"
[10:32:54.156]  $ rshcmd_label    : NULL
[10:32:54.156]  $ rsh_call        : NULL
[10:32:54.156]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:54.156]  $ localMachine    : logi TRUE
[10:32:54.156]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:32:54.156]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:32:54.156]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:32:54.156]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:32:54.156]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:32:54.156]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:32:54.156]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:32:54.156]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:32:54.156]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:32:54.156]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:32:54.156]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:32:54.156]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:32:54.156]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:32:54.156]  $ arguments       :List of 28
[10:32:54.156]   ..$ worker          : chr "localhost"
[10:32:54.156]   ..$ master          : NULL
[10:32:54.156]   ..$ port            : int 11175
[10:32:54.156]   ..$ connectTimeout  : num 120
[10:32:54.156]   ..$ timeout         : num 2592000
[10:32:54.156]   ..$ rscript         : NULL
[10:32:54.156]   ..$ homogeneous     : NULL
[10:32:54.156]   ..$ rscript_args    : NULL
[10:32:54.156]   ..$ rscript_envs    : NULL
[10:32:54.156]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:54.156]   ..$ rscript_startup : NULL
[10:32:54.156]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:32:54.156]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:54.156]   ..$ methods         : logi TRUE
[10:32:54.156]   ..$ socketOptions   : chr "no-delay"
[10:32:54.156]   ..$ useXDR          : logi FALSE
[10:32:54.156]   ..$ outfile         : chr "/dev/null"
[10:32:54.156]   ..$ renice          : int NA
[10:32:54.156]   ..$ rshcmd          : NULL
[10:32:54.156]   ..$ user            : NULL
[10:32:54.156]   ..$ revtunnel       : logi NA
[10:32:54.156]   ..$ rshlogfile      : NULL
[10:32:54.156]   ..$ rshopts         : NULL
[10:32:54.156]   ..$ rank            : int 1
[10:32:54.156]   ..$ manual          : logi FALSE
[10:32:54.156]   ..$ dryrun          : logi FALSE
[10:32:54.156]   ..$ quiet           : logi FALSE
[10:32:54.156]   ..$ setup_strategy  : chr "parallel"
[10:32:54.156]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:32:54.176] [local output] System call to launch all workers:
[10:32:54.176] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpvxlbHV/worker.rank=1.parallelly.parent=81769.13f6942726bb3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11175 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:32:54.176] [local output] Starting PSOCK main server
[10:32:54.177] [local output] Workers launched
[10:32:54.178] [local output] Waiting for workers to connect back
[10:32:54.178]  - [local output] 0 workers out of 2 ready
[10:32:54.411]  - [local output] 0 workers out of 2 ready
[10:32:54.412]  - [local output] 1 workers out of 2 ready
[10:32:54.423]  - [local output] 1 workers out of 2 ready
[10:32:54.423]  - [local output] 2 workers out of 2 ready
[10:32:54.423] [local output] Launching of workers completed
[10:32:54.424] [local output] Collecting session information from workers
[10:32:54.424] [local output]  - Worker #1 of 2
[10:32:54.425] [local output]  - Worker #2 of 2
[10:32:54.425] [local output] makeClusterPSOCK() ... done
[10:32:54.436] Packages needed by the future expression (n = 0): <none>
[10:32:54.436] Packages needed by future strategies (n = 0): <none>
[10:32:54.437] {
[10:32:54.437]     {
[10:32:54.437]         {
[10:32:54.437]             ...future.startTime <- base::Sys.time()
[10:32:54.437]             {
[10:32:54.437]                 {
[10:32:54.437]                   {
[10:32:54.437]                     {
[10:32:54.437]                       base::local({
[10:32:54.437]                         has_future <- base::requireNamespace("future", 
[10:32:54.437]                           quietly = TRUE)
[10:32:54.437]                         if (has_future) {
[10:32:54.437]                           ns <- base::getNamespace("future")
[10:32:54.437]                           version <- ns[[".package"]][["version"]]
[10:32:54.437]                           if (is.null(version)) 
[10:32:54.437]                             version <- utils::packageVersion("future")
[10:32:54.437]                         }
[10:32:54.437]                         else {
[10:32:54.437]                           version <- NULL
[10:32:54.437]                         }
[10:32:54.437]                         if (!has_future || version < "1.8.0") {
[10:32:54.437]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.437]                             "", base::R.version$version.string), 
[10:32:54.437]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.437]                               "release", "version")], collapse = " "), 
[10:32:54.437]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.437]                             info)
[10:32:54.437]                           info <- base::paste(info, collapse = "; ")
[10:32:54.437]                           if (!has_future) {
[10:32:54.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.437]                               info)
[10:32:54.437]                           }
[10:32:54.437]                           else {
[10:32:54.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.437]                               info, version)
[10:32:54.437]                           }
[10:32:54.437]                           base::stop(msg)
[10:32:54.437]                         }
[10:32:54.437]                       })
[10:32:54.437]                     }
[10:32:54.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.437]                     base::options(mc.cores = 1L)
[10:32:54.437]                   }
[10:32:54.437]                   ...future.strategy.old <- future::plan("list")
[10:32:54.437]                   options(future.plan = NULL)
[10:32:54.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.437]                 }
[10:32:54.437]                 ...future.workdir <- getwd()
[10:32:54.437]             }
[10:32:54.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.437]         }
[10:32:54.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.437]             base::names(...future.oldOptions))
[10:32:54.437]     }
[10:32:54.437]     if (FALSE) {
[10:32:54.437]     }
[10:32:54.437]     else {
[10:32:54.437]         if (TRUE) {
[10:32:54.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.437]                 open = "w")
[10:32:54.437]         }
[10:32:54.437]         else {
[10:32:54.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.437]         }
[10:32:54.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.437]             base::sink(type = "output", split = FALSE)
[10:32:54.437]             base::close(...future.stdout)
[10:32:54.437]         }, add = TRUE)
[10:32:54.437]     }
[10:32:54.437]     ...future.frame <- base::sys.nframe()
[10:32:54.437]     ...future.conditions <- base::list()
[10:32:54.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.437]     if (FALSE) {
[10:32:54.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.437]     }
[10:32:54.437]     ...future.result <- base::tryCatch({
[10:32:54.437]         base::withCallingHandlers({
[10:32:54.437]             ...future.value <- base::withVisible(base::local({
[10:32:54.437]                 ...future.makeSendCondition <- base::local({
[10:32:54.437]                   sendCondition <- NULL
[10:32:54.437]                   function(frame = 1L) {
[10:32:54.437]                     if (is.function(sendCondition)) 
[10:32:54.437]                       return(sendCondition)
[10:32:54.437]                     ns <- getNamespace("parallel")
[10:32:54.437]                     if (exists("sendData", mode = "function", 
[10:32:54.437]                       envir = ns)) {
[10:32:54.437]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.437]                         envir = ns)
[10:32:54.437]                       envir <- sys.frame(frame)
[10:32:54.437]                       master <- NULL
[10:32:54.437]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.437]                         !identical(envir, emptyenv())) {
[10:32:54.437]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.437]                           inherits = FALSE)) {
[10:32:54.437]                           master <- get("master", mode = "list", 
[10:32:54.437]                             envir = envir, inherits = FALSE)
[10:32:54.437]                           if (inherits(master, c("SOCKnode", 
[10:32:54.437]                             "SOCK0node"))) {
[10:32:54.437]                             sendCondition <<- function(cond) {
[10:32:54.437]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.437]                                 success = TRUE)
[10:32:54.437]                               parallel_sendData(master, data)
[10:32:54.437]                             }
[10:32:54.437]                             return(sendCondition)
[10:32:54.437]                           }
[10:32:54.437]                         }
[10:32:54.437]                         frame <- frame + 1L
[10:32:54.437]                         envir <- sys.frame(frame)
[10:32:54.437]                       }
[10:32:54.437]                     }
[10:32:54.437]                     sendCondition <<- function(cond) NULL
[10:32:54.437]                   }
[10:32:54.437]                 })
[10:32:54.437]                 withCallingHandlers({
[10:32:54.437]                   NA
[10:32:54.437]                 }, immediateCondition = function(cond) {
[10:32:54.437]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.437]                   sendCondition(cond)
[10:32:54.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.437]                   {
[10:32:54.437]                     inherits <- base::inherits
[10:32:54.437]                     invokeRestart <- base::invokeRestart
[10:32:54.437]                     is.null <- base::is.null
[10:32:54.437]                     muffled <- FALSE
[10:32:54.437]                     if (inherits(cond, "message")) {
[10:32:54.437]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.437]                       if (muffled) 
[10:32:54.437]                         invokeRestart("muffleMessage")
[10:32:54.437]                     }
[10:32:54.437]                     else if (inherits(cond, "warning")) {
[10:32:54.437]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.437]                       if (muffled) 
[10:32:54.437]                         invokeRestart("muffleWarning")
[10:32:54.437]                     }
[10:32:54.437]                     else if (inherits(cond, "condition")) {
[10:32:54.437]                       if (!is.null(pattern)) {
[10:32:54.437]                         computeRestarts <- base::computeRestarts
[10:32:54.437]                         grepl <- base::grepl
[10:32:54.437]                         restarts <- computeRestarts(cond)
[10:32:54.437]                         for (restart in restarts) {
[10:32:54.437]                           name <- restart$name
[10:32:54.437]                           if (is.null(name)) 
[10:32:54.437]                             next
[10:32:54.437]                           if (!grepl(pattern, name)) 
[10:32:54.437]                             next
[10:32:54.437]                           invokeRestart(restart)
[10:32:54.437]                           muffled <- TRUE
[10:32:54.437]                           break
[10:32:54.437]                         }
[10:32:54.437]                       }
[10:32:54.437]                     }
[10:32:54.437]                     invisible(muffled)
[10:32:54.437]                   }
[10:32:54.437]                   muffleCondition(cond)
[10:32:54.437]                 })
[10:32:54.437]             }))
[10:32:54.437]             future::FutureResult(value = ...future.value$value, 
[10:32:54.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.437]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.437]                     ...future.globalenv.names))
[10:32:54.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.437]         }, condition = base::local({
[10:32:54.437]             c <- base::c
[10:32:54.437]             inherits <- base::inherits
[10:32:54.437]             invokeRestart <- base::invokeRestart
[10:32:54.437]             length <- base::length
[10:32:54.437]             list <- base::list
[10:32:54.437]             seq.int <- base::seq.int
[10:32:54.437]             signalCondition <- base::signalCondition
[10:32:54.437]             sys.calls <- base::sys.calls
[10:32:54.437]             `[[` <- base::`[[`
[10:32:54.437]             `+` <- base::`+`
[10:32:54.437]             `<<-` <- base::`<<-`
[10:32:54.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.437]                   3L)]
[10:32:54.437]             }
[10:32:54.437]             function(cond) {
[10:32:54.437]                 is_error <- inherits(cond, "error")
[10:32:54.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.437]                   NULL)
[10:32:54.437]                 if (is_error) {
[10:32:54.437]                   sessionInformation <- function() {
[10:32:54.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.437]                       search = base::search(), system = base::Sys.info())
[10:32:54.437]                   }
[10:32:54.437]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.437]                     cond$call), session = sessionInformation(), 
[10:32:54.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.437]                   signalCondition(cond)
[10:32:54.437]                 }
[10:32:54.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.437]                 "immediateCondition"))) {
[10:32:54.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.437]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.437]                   if (TRUE && !signal) {
[10:32:54.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.437]                     {
[10:32:54.437]                       inherits <- base::inherits
[10:32:54.437]                       invokeRestart <- base::invokeRestart
[10:32:54.437]                       is.null <- base::is.null
[10:32:54.437]                       muffled <- FALSE
[10:32:54.437]                       if (inherits(cond, "message")) {
[10:32:54.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.437]                         if (muffled) 
[10:32:54.437]                           invokeRestart("muffleMessage")
[10:32:54.437]                       }
[10:32:54.437]                       else if (inherits(cond, "warning")) {
[10:32:54.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.437]                         if (muffled) 
[10:32:54.437]                           invokeRestart("muffleWarning")
[10:32:54.437]                       }
[10:32:54.437]                       else if (inherits(cond, "condition")) {
[10:32:54.437]                         if (!is.null(pattern)) {
[10:32:54.437]                           computeRestarts <- base::computeRestarts
[10:32:54.437]                           grepl <- base::grepl
[10:32:54.437]                           restarts <- computeRestarts(cond)
[10:32:54.437]                           for (restart in restarts) {
[10:32:54.437]                             name <- restart$name
[10:32:54.437]                             if (is.null(name)) 
[10:32:54.437]                               next
[10:32:54.437]                             if (!grepl(pattern, name)) 
[10:32:54.437]                               next
[10:32:54.437]                             invokeRestart(restart)
[10:32:54.437]                             muffled <- TRUE
[10:32:54.437]                             break
[10:32:54.437]                           }
[10:32:54.437]                         }
[10:32:54.437]                       }
[10:32:54.437]                       invisible(muffled)
[10:32:54.437]                     }
[10:32:54.437]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.437]                   }
[10:32:54.437]                 }
[10:32:54.437]                 else {
[10:32:54.437]                   if (TRUE) {
[10:32:54.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.437]                     {
[10:32:54.437]                       inherits <- base::inherits
[10:32:54.437]                       invokeRestart <- base::invokeRestart
[10:32:54.437]                       is.null <- base::is.null
[10:32:54.437]                       muffled <- FALSE
[10:32:54.437]                       if (inherits(cond, "message")) {
[10:32:54.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.437]                         if (muffled) 
[10:32:54.437]                           invokeRestart("muffleMessage")
[10:32:54.437]                       }
[10:32:54.437]                       else if (inherits(cond, "warning")) {
[10:32:54.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.437]                         if (muffled) 
[10:32:54.437]                           invokeRestart("muffleWarning")
[10:32:54.437]                       }
[10:32:54.437]                       else if (inherits(cond, "condition")) {
[10:32:54.437]                         if (!is.null(pattern)) {
[10:32:54.437]                           computeRestarts <- base::computeRestarts
[10:32:54.437]                           grepl <- base::grepl
[10:32:54.437]                           restarts <- computeRestarts(cond)
[10:32:54.437]                           for (restart in restarts) {
[10:32:54.437]                             name <- restart$name
[10:32:54.437]                             if (is.null(name)) 
[10:32:54.437]                               next
[10:32:54.437]                             if (!grepl(pattern, name)) 
[10:32:54.437]                               next
[10:32:54.437]                             invokeRestart(restart)
[10:32:54.437]                             muffled <- TRUE
[10:32:54.437]                             break
[10:32:54.437]                           }
[10:32:54.437]                         }
[10:32:54.437]                       }
[10:32:54.437]                       invisible(muffled)
[10:32:54.437]                     }
[10:32:54.437]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.437]                   }
[10:32:54.437]                 }
[10:32:54.437]             }
[10:32:54.437]         }))
[10:32:54.437]     }, error = function(ex) {
[10:32:54.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.437]                 ...future.rng), started = ...future.startTime, 
[10:32:54.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.437]             version = "1.8"), class = "FutureResult")
[10:32:54.437]     }, finally = {
[10:32:54.437]         if (!identical(...future.workdir, getwd())) 
[10:32:54.437]             setwd(...future.workdir)
[10:32:54.437]         {
[10:32:54.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.437]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.437]             }
[10:32:54.437]             base::options(...future.oldOptions)
[10:32:54.437]             if (.Platform$OS.type == "windows") {
[10:32:54.437]                 old_names <- names(...future.oldEnvVars)
[10:32:54.437]                 envs <- base::Sys.getenv()
[10:32:54.437]                 names <- names(envs)
[10:32:54.437]                 common <- intersect(names, old_names)
[10:32:54.437]                 added <- setdiff(names, old_names)
[10:32:54.437]                 removed <- setdiff(old_names, names)
[10:32:54.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.437]                   envs[common]]
[10:32:54.437]                 NAMES <- toupper(changed)
[10:32:54.437]                 args <- list()
[10:32:54.437]                 for (kk in seq_along(NAMES)) {
[10:32:54.437]                   name <- changed[[kk]]
[10:32:54.437]                   NAME <- NAMES[[kk]]
[10:32:54.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.437]                     next
[10:32:54.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.437]                 }
[10:32:54.437]                 NAMES <- toupper(added)
[10:32:54.437]                 for (kk in seq_along(NAMES)) {
[10:32:54.437]                   name <- added[[kk]]
[10:32:54.437]                   NAME <- NAMES[[kk]]
[10:32:54.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.437]                     next
[10:32:54.437]                   args[[name]] <- ""
[10:32:54.437]                 }
[10:32:54.437]                 NAMES <- toupper(removed)
[10:32:54.437]                 for (kk in seq_along(NAMES)) {
[10:32:54.437]                   name <- removed[[kk]]
[10:32:54.437]                   NAME <- NAMES[[kk]]
[10:32:54.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.437]                     next
[10:32:54.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.437]                 }
[10:32:54.437]                 if (length(args) > 0) 
[10:32:54.437]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.437]             }
[10:32:54.437]             else {
[10:32:54.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.437]             }
[10:32:54.437]             {
[10:32:54.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.437]                   0L) {
[10:32:54.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.437]                   base::options(opts)
[10:32:54.437]                 }
[10:32:54.437]                 {
[10:32:54.437]                   {
[10:32:54.437]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.437]                     NULL
[10:32:54.437]                   }
[10:32:54.437]                   options(future.plan = NULL)
[10:32:54.437]                   if (is.na(NA_character_)) 
[10:32:54.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.437]                     .init = FALSE)
[10:32:54.437]                 }
[10:32:54.437]             }
[10:32:54.437]         }
[10:32:54.437]     })
[10:32:54.437]     if (TRUE) {
[10:32:54.437]         base::sink(type = "output", split = FALSE)
[10:32:54.437]         if (TRUE) {
[10:32:54.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.437]         }
[10:32:54.437]         else {
[10:32:54.437]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.437]         }
[10:32:54.437]         base::close(...future.stdout)
[10:32:54.437]         ...future.stdout <- NULL
[10:32:54.437]     }
[10:32:54.437]     ...future.result$conditions <- ...future.conditions
[10:32:54.437]     ...future.result$finished <- base::Sys.time()
[10:32:54.437]     ...future.result
[10:32:54.437] }
[10:32:54.489] MultisessionFuture started
[10:32:54.490] result() for ClusterFuture ...
[10:32:54.490] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.490] - Validating connection of MultisessionFuture
[10:32:54.524] - received message: FutureResult
[10:32:54.524] - Received FutureResult
[10:32:54.524] - Erased future from FutureRegistry
[10:32:54.524] result() for ClusterFuture ...
[10:32:54.524] - result already collected: FutureResult
[10:32:54.524] result() for ClusterFuture ... done
[10:32:54.525] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.525] result() for ClusterFuture ... done
[10:32:54.525] result() for ClusterFuture ...
[10:32:54.525] - result already collected: FutureResult
[10:32:54.525] result() for ClusterFuture ... done
[10:32:54.525] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:32:54.529] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:32:54.530] getGlobalsAndPackages() ...
[10:32:54.530] Searching for globals...
[10:32:54.530] 
[10:32:54.530] Searching for globals ... DONE
[10:32:54.531] - globals: [0] <none>
[10:32:54.531] getGlobalsAndPackages() ... DONE
[10:32:54.531] run() for ‘Future’ ...
[10:32:54.531] - state: ‘created’
[10:32:54.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.545] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.545]   - Field: ‘node’
[10:32:54.546]   - Field: ‘label’
[10:32:54.546]   - Field: ‘local’
[10:32:54.546]   - Field: ‘owner’
[10:32:54.546]   - Field: ‘envir’
[10:32:54.546]   - Field: ‘workers’
[10:32:54.546]   - Field: ‘packages’
[10:32:54.546]   - Field: ‘gc’
[10:32:54.546]   - Field: ‘conditions’
[10:32:54.546]   - Field: ‘persistent’
[10:32:54.546]   - Field: ‘expr’
[10:32:54.547]   - Field: ‘uuid’
[10:32:54.547]   - Field: ‘seed’
[10:32:54.547]   - Field: ‘version’
[10:32:54.547]   - Field: ‘result’
[10:32:54.547]   - Field: ‘asynchronous’
[10:32:54.547]   - Field: ‘calls’
[10:32:54.547]   - Field: ‘globals’
[10:32:54.547]   - Field: ‘stdout’
[10:32:54.547]   - Field: ‘earlySignal’
[10:32:54.547]   - Field: ‘lazy’
[10:32:54.547]   - Field: ‘state’
[10:32:54.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.548] - Launch lazy future ...
[10:32:54.548] Packages needed by the future expression (n = 0): <none>
[10:32:54.548] Packages needed by future strategies (n = 0): <none>
[10:32:54.549] {
[10:32:54.549]     {
[10:32:54.549]         {
[10:32:54.549]             ...future.startTime <- base::Sys.time()
[10:32:54.549]             {
[10:32:54.549]                 {
[10:32:54.549]                   {
[10:32:54.549]                     {
[10:32:54.549]                       base::local({
[10:32:54.549]                         has_future <- base::requireNamespace("future", 
[10:32:54.549]                           quietly = TRUE)
[10:32:54.549]                         if (has_future) {
[10:32:54.549]                           ns <- base::getNamespace("future")
[10:32:54.549]                           version <- ns[[".package"]][["version"]]
[10:32:54.549]                           if (is.null(version)) 
[10:32:54.549]                             version <- utils::packageVersion("future")
[10:32:54.549]                         }
[10:32:54.549]                         else {
[10:32:54.549]                           version <- NULL
[10:32:54.549]                         }
[10:32:54.549]                         if (!has_future || version < "1.8.0") {
[10:32:54.549]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.549]                             "", base::R.version$version.string), 
[10:32:54.549]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.549]                               "release", "version")], collapse = " "), 
[10:32:54.549]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.549]                             info)
[10:32:54.549]                           info <- base::paste(info, collapse = "; ")
[10:32:54.549]                           if (!has_future) {
[10:32:54.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.549]                               info)
[10:32:54.549]                           }
[10:32:54.549]                           else {
[10:32:54.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.549]                               info, version)
[10:32:54.549]                           }
[10:32:54.549]                           base::stop(msg)
[10:32:54.549]                         }
[10:32:54.549]                       })
[10:32:54.549]                     }
[10:32:54.549]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.549]                     base::options(mc.cores = 1L)
[10:32:54.549]                   }
[10:32:54.549]                   ...future.strategy.old <- future::plan("list")
[10:32:54.549]                   options(future.plan = NULL)
[10:32:54.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.549]                 }
[10:32:54.549]                 ...future.workdir <- getwd()
[10:32:54.549]             }
[10:32:54.549]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.549]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.549]         }
[10:32:54.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.549]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.549]             base::names(...future.oldOptions))
[10:32:54.549]     }
[10:32:54.549]     if (FALSE) {
[10:32:54.549]     }
[10:32:54.549]     else {
[10:32:54.549]         if (TRUE) {
[10:32:54.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.549]                 open = "w")
[10:32:54.549]         }
[10:32:54.549]         else {
[10:32:54.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.549]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.549]         }
[10:32:54.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.549]             base::sink(type = "output", split = FALSE)
[10:32:54.549]             base::close(...future.stdout)
[10:32:54.549]         }, add = TRUE)
[10:32:54.549]     }
[10:32:54.549]     ...future.frame <- base::sys.nframe()
[10:32:54.549]     ...future.conditions <- base::list()
[10:32:54.549]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.549]     if (FALSE) {
[10:32:54.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.549]     }
[10:32:54.549]     ...future.result <- base::tryCatch({
[10:32:54.549]         base::withCallingHandlers({
[10:32:54.549]             ...future.value <- base::withVisible(base::local({
[10:32:54.549]                 ...future.makeSendCondition <- base::local({
[10:32:54.549]                   sendCondition <- NULL
[10:32:54.549]                   function(frame = 1L) {
[10:32:54.549]                     if (is.function(sendCondition)) 
[10:32:54.549]                       return(sendCondition)
[10:32:54.549]                     ns <- getNamespace("parallel")
[10:32:54.549]                     if (exists("sendData", mode = "function", 
[10:32:54.549]                       envir = ns)) {
[10:32:54.549]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.549]                         envir = ns)
[10:32:54.549]                       envir <- sys.frame(frame)
[10:32:54.549]                       master <- NULL
[10:32:54.549]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.549]                         !identical(envir, emptyenv())) {
[10:32:54.549]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.549]                           inherits = FALSE)) {
[10:32:54.549]                           master <- get("master", mode = "list", 
[10:32:54.549]                             envir = envir, inherits = FALSE)
[10:32:54.549]                           if (inherits(master, c("SOCKnode", 
[10:32:54.549]                             "SOCK0node"))) {
[10:32:54.549]                             sendCondition <<- function(cond) {
[10:32:54.549]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.549]                                 success = TRUE)
[10:32:54.549]                               parallel_sendData(master, data)
[10:32:54.549]                             }
[10:32:54.549]                             return(sendCondition)
[10:32:54.549]                           }
[10:32:54.549]                         }
[10:32:54.549]                         frame <- frame + 1L
[10:32:54.549]                         envir <- sys.frame(frame)
[10:32:54.549]                       }
[10:32:54.549]                     }
[10:32:54.549]                     sendCondition <<- function(cond) NULL
[10:32:54.549]                   }
[10:32:54.549]                 })
[10:32:54.549]                 withCallingHandlers({
[10:32:54.549]                   2
[10:32:54.549]                 }, immediateCondition = function(cond) {
[10:32:54.549]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.549]                   sendCondition(cond)
[10:32:54.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.549]                   {
[10:32:54.549]                     inherits <- base::inherits
[10:32:54.549]                     invokeRestart <- base::invokeRestart
[10:32:54.549]                     is.null <- base::is.null
[10:32:54.549]                     muffled <- FALSE
[10:32:54.549]                     if (inherits(cond, "message")) {
[10:32:54.549]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.549]                       if (muffled) 
[10:32:54.549]                         invokeRestart("muffleMessage")
[10:32:54.549]                     }
[10:32:54.549]                     else if (inherits(cond, "warning")) {
[10:32:54.549]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.549]                       if (muffled) 
[10:32:54.549]                         invokeRestart("muffleWarning")
[10:32:54.549]                     }
[10:32:54.549]                     else if (inherits(cond, "condition")) {
[10:32:54.549]                       if (!is.null(pattern)) {
[10:32:54.549]                         computeRestarts <- base::computeRestarts
[10:32:54.549]                         grepl <- base::grepl
[10:32:54.549]                         restarts <- computeRestarts(cond)
[10:32:54.549]                         for (restart in restarts) {
[10:32:54.549]                           name <- restart$name
[10:32:54.549]                           if (is.null(name)) 
[10:32:54.549]                             next
[10:32:54.549]                           if (!grepl(pattern, name)) 
[10:32:54.549]                             next
[10:32:54.549]                           invokeRestart(restart)
[10:32:54.549]                           muffled <- TRUE
[10:32:54.549]                           break
[10:32:54.549]                         }
[10:32:54.549]                       }
[10:32:54.549]                     }
[10:32:54.549]                     invisible(muffled)
[10:32:54.549]                   }
[10:32:54.549]                   muffleCondition(cond)
[10:32:54.549]                 })
[10:32:54.549]             }))
[10:32:54.549]             future::FutureResult(value = ...future.value$value, 
[10:32:54.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.549]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.549]                     ...future.globalenv.names))
[10:32:54.549]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.549]         }, condition = base::local({
[10:32:54.549]             c <- base::c
[10:32:54.549]             inherits <- base::inherits
[10:32:54.549]             invokeRestart <- base::invokeRestart
[10:32:54.549]             length <- base::length
[10:32:54.549]             list <- base::list
[10:32:54.549]             seq.int <- base::seq.int
[10:32:54.549]             signalCondition <- base::signalCondition
[10:32:54.549]             sys.calls <- base::sys.calls
[10:32:54.549]             `[[` <- base::`[[`
[10:32:54.549]             `+` <- base::`+`
[10:32:54.549]             `<<-` <- base::`<<-`
[10:32:54.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.549]                   3L)]
[10:32:54.549]             }
[10:32:54.549]             function(cond) {
[10:32:54.549]                 is_error <- inherits(cond, "error")
[10:32:54.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.549]                   NULL)
[10:32:54.549]                 if (is_error) {
[10:32:54.549]                   sessionInformation <- function() {
[10:32:54.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.549]                       search = base::search(), system = base::Sys.info())
[10:32:54.549]                   }
[10:32:54.549]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.549]                     cond$call), session = sessionInformation(), 
[10:32:54.549]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.549]                   signalCondition(cond)
[10:32:54.549]                 }
[10:32:54.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.549]                 "immediateCondition"))) {
[10:32:54.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.549]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.549]                   if (TRUE && !signal) {
[10:32:54.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.549]                     {
[10:32:54.549]                       inherits <- base::inherits
[10:32:54.549]                       invokeRestart <- base::invokeRestart
[10:32:54.549]                       is.null <- base::is.null
[10:32:54.549]                       muffled <- FALSE
[10:32:54.549]                       if (inherits(cond, "message")) {
[10:32:54.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.549]                         if (muffled) 
[10:32:54.549]                           invokeRestart("muffleMessage")
[10:32:54.549]                       }
[10:32:54.549]                       else if (inherits(cond, "warning")) {
[10:32:54.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.549]                         if (muffled) 
[10:32:54.549]                           invokeRestart("muffleWarning")
[10:32:54.549]                       }
[10:32:54.549]                       else if (inherits(cond, "condition")) {
[10:32:54.549]                         if (!is.null(pattern)) {
[10:32:54.549]                           computeRestarts <- base::computeRestarts
[10:32:54.549]                           grepl <- base::grepl
[10:32:54.549]                           restarts <- computeRestarts(cond)
[10:32:54.549]                           for (restart in restarts) {
[10:32:54.549]                             name <- restart$name
[10:32:54.549]                             if (is.null(name)) 
[10:32:54.549]                               next
[10:32:54.549]                             if (!grepl(pattern, name)) 
[10:32:54.549]                               next
[10:32:54.549]                             invokeRestart(restart)
[10:32:54.549]                             muffled <- TRUE
[10:32:54.549]                             break
[10:32:54.549]                           }
[10:32:54.549]                         }
[10:32:54.549]                       }
[10:32:54.549]                       invisible(muffled)
[10:32:54.549]                     }
[10:32:54.549]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.549]                   }
[10:32:54.549]                 }
[10:32:54.549]                 else {
[10:32:54.549]                   if (TRUE) {
[10:32:54.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.549]                     {
[10:32:54.549]                       inherits <- base::inherits
[10:32:54.549]                       invokeRestart <- base::invokeRestart
[10:32:54.549]                       is.null <- base::is.null
[10:32:54.549]                       muffled <- FALSE
[10:32:54.549]                       if (inherits(cond, "message")) {
[10:32:54.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.549]                         if (muffled) 
[10:32:54.549]                           invokeRestart("muffleMessage")
[10:32:54.549]                       }
[10:32:54.549]                       else if (inherits(cond, "warning")) {
[10:32:54.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.549]                         if (muffled) 
[10:32:54.549]                           invokeRestart("muffleWarning")
[10:32:54.549]                       }
[10:32:54.549]                       else if (inherits(cond, "condition")) {
[10:32:54.549]                         if (!is.null(pattern)) {
[10:32:54.549]                           computeRestarts <- base::computeRestarts
[10:32:54.549]                           grepl <- base::grepl
[10:32:54.549]                           restarts <- computeRestarts(cond)
[10:32:54.549]                           for (restart in restarts) {
[10:32:54.549]                             name <- restart$name
[10:32:54.549]                             if (is.null(name)) 
[10:32:54.549]                               next
[10:32:54.549]                             if (!grepl(pattern, name)) 
[10:32:54.549]                               next
[10:32:54.549]                             invokeRestart(restart)
[10:32:54.549]                             muffled <- TRUE
[10:32:54.549]                             break
[10:32:54.549]                           }
[10:32:54.549]                         }
[10:32:54.549]                       }
[10:32:54.549]                       invisible(muffled)
[10:32:54.549]                     }
[10:32:54.549]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.549]                   }
[10:32:54.549]                 }
[10:32:54.549]             }
[10:32:54.549]         }))
[10:32:54.549]     }, error = function(ex) {
[10:32:54.549]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.549]                 ...future.rng), started = ...future.startTime, 
[10:32:54.549]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.549]             version = "1.8"), class = "FutureResult")
[10:32:54.549]     }, finally = {
[10:32:54.549]         if (!identical(...future.workdir, getwd())) 
[10:32:54.549]             setwd(...future.workdir)
[10:32:54.549]         {
[10:32:54.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.549]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.549]             }
[10:32:54.549]             base::options(...future.oldOptions)
[10:32:54.549]             if (.Platform$OS.type == "windows") {
[10:32:54.549]                 old_names <- names(...future.oldEnvVars)
[10:32:54.549]                 envs <- base::Sys.getenv()
[10:32:54.549]                 names <- names(envs)
[10:32:54.549]                 common <- intersect(names, old_names)
[10:32:54.549]                 added <- setdiff(names, old_names)
[10:32:54.549]                 removed <- setdiff(old_names, names)
[10:32:54.549]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.549]                   envs[common]]
[10:32:54.549]                 NAMES <- toupper(changed)
[10:32:54.549]                 args <- list()
[10:32:54.549]                 for (kk in seq_along(NAMES)) {
[10:32:54.549]                   name <- changed[[kk]]
[10:32:54.549]                   NAME <- NAMES[[kk]]
[10:32:54.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.549]                     next
[10:32:54.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.549]                 }
[10:32:54.549]                 NAMES <- toupper(added)
[10:32:54.549]                 for (kk in seq_along(NAMES)) {
[10:32:54.549]                   name <- added[[kk]]
[10:32:54.549]                   NAME <- NAMES[[kk]]
[10:32:54.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.549]                     next
[10:32:54.549]                   args[[name]] <- ""
[10:32:54.549]                 }
[10:32:54.549]                 NAMES <- toupper(removed)
[10:32:54.549]                 for (kk in seq_along(NAMES)) {
[10:32:54.549]                   name <- removed[[kk]]
[10:32:54.549]                   NAME <- NAMES[[kk]]
[10:32:54.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.549]                     next
[10:32:54.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.549]                 }
[10:32:54.549]                 if (length(args) > 0) 
[10:32:54.549]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.549]             }
[10:32:54.549]             else {
[10:32:54.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.549]             }
[10:32:54.549]             {
[10:32:54.549]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.549]                   0L) {
[10:32:54.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.549]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.549]                   base::options(opts)
[10:32:54.549]                 }
[10:32:54.549]                 {
[10:32:54.549]                   {
[10:32:54.549]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.549]                     NULL
[10:32:54.549]                   }
[10:32:54.549]                   options(future.plan = NULL)
[10:32:54.549]                   if (is.na(NA_character_)) 
[10:32:54.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.549]                     .init = FALSE)
[10:32:54.549]                 }
[10:32:54.549]             }
[10:32:54.549]         }
[10:32:54.549]     })
[10:32:54.549]     if (TRUE) {
[10:32:54.549]         base::sink(type = "output", split = FALSE)
[10:32:54.549]         if (TRUE) {
[10:32:54.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.549]         }
[10:32:54.549]         else {
[10:32:54.549]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.549]         }
[10:32:54.549]         base::close(...future.stdout)
[10:32:54.549]         ...future.stdout <- NULL
[10:32:54.549]     }
[10:32:54.549]     ...future.result$conditions <- ...future.conditions
[10:32:54.549]     ...future.result$finished <- base::Sys.time()
[10:32:54.549]     ...future.result
[10:32:54.549] }
[10:32:54.552] MultisessionFuture started
[10:32:54.552] - Launch lazy future ... done
[10:32:54.552] run() for ‘MultisessionFuture’ ... done
[10:32:54.552] getGlobalsAndPackages() ...
[10:32:54.552] Searching for globals...
[10:32:54.553] 
[10:32:54.553] Searching for globals ... DONE
[10:32:54.553] - globals: [0] <none>
[10:32:54.553] getGlobalsAndPackages() ... DONE
[10:32:54.554] run() for ‘Future’ ...
[10:32:54.554] - state: ‘created’
[10:32:54.558] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.572]   - Field: ‘node’
[10:32:54.572]   - Field: ‘label’
[10:32:54.573]   - Field: ‘local’
[10:32:54.573]   - Field: ‘owner’
[10:32:54.573]   - Field: ‘envir’
[10:32:54.573]   - Field: ‘workers’
[10:32:54.573]   - Field: ‘packages’
[10:32:54.573]   - Field: ‘gc’
[10:32:54.573]   - Field: ‘conditions’
[10:32:54.573]   - Field: ‘persistent’
[10:32:54.573]   - Field: ‘expr’
[10:32:54.573]   - Field: ‘uuid’
[10:32:54.573]   - Field: ‘seed’
[10:32:54.574]   - Field: ‘version’
[10:32:54.574]   - Field: ‘result’
[10:32:54.574]   - Field: ‘asynchronous’
[10:32:54.574]   - Field: ‘calls’
[10:32:54.574]   - Field: ‘globals’
[10:32:54.574]   - Field: ‘stdout’
[10:32:54.574]   - Field: ‘earlySignal’
[10:32:54.574]   - Field: ‘lazy’
[10:32:54.574]   - Field: ‘state’
[10:32:54.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.575] - Launch lazy future ...
[10:32:54.575] Packages needed by the future expression (n = 0): <none>
[10:32:54.575] Packages needed by future strategies (n = 0): <none>
[10:32:54.575] {
[10:32:54.575]     {
[10:32:54.575]         {
[10:32:54.575]             ...future.startTime <- base::Sys.time()
[10:32:54.575]             {
[10:32:54.575]                 {
[10:32:54.575]                   {
[10:32:54.575]                     {
[10:32:54.575]                       base::local({
[10:32:54.575]                         has_future <- base::requireNamespace("future", 
[10:32:54.575]                           quietly = TRUE)
[10:32:54.575]                         if (has_future) {
[10:32:54.575]                           ns <- base::getNamespace("future")
[10:32:54.575]                           version <- ns[[".package"]][["version"]]
[10:32:54.575]                           if (is.null(version)) 
[10:32:54.575]                             version <- utils::packageVersion("future")
[10:32:54.575]                         }
[10:32:54.575]                         else {
[10:32:54.575]                           version <- NULL
[10:32:54.575]                         }
[10:32:54.575]                         if (!has_future || version < "1.8.0") {
[10:32:54.575]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.575]                             "", base::R.version$version.string), 
[10:32:54.575]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.575]                               "release", "version")], collapse = " "), 
[10:32:54.575]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.575]                             info)
[10:32:54.575]                           info <- base::paste(info, collapse = "; ")
[10:32:54.575]                           if (!has_future) {
[10:32:54.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.575]                               info)
[10:32:54.575]                           }
[10:32:54.575]                           else {
[10:32:54.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.575]                               info, version)
[10:32:54.575]                           }
[10:32:54.575]                           base::stop(msg)
[10:32:54.575]                         }
[10:32:54.575]                       })
[10:32:54.575]                     }
[10:32:54.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.575]                     base::options(mc.cores = 1L)
[10:32:54.575]                   }
[10:32:54.575]                   ...future.strategy.old <- future::plan("list")
[10:32:54.575]                   options(future.plan = NULL)
[10:32:54.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.575]                 }
[10:32:54.575]                 ...future.workdir <- getwd()
[10:32:54.575]             }
[10:32:54.575]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.575]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.575]         }
[10:32:54.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.575]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.575]             base::names(...future.oldOptions))
[10:32:54.575]     }
[10:32:54.575]     if (FALSE) {
[10:32:54.575]     }
[10:32:54.575]     else {
[10:32:54.575]         if (TRUE) {
[10:32:54.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.575]                 open = "w")
[10:32:54.575]         }
[10:32:54.575]         else {
[10:32:54.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.575]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.575]         }
[10:32:54.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.575]             base::sink(type = "output", split = FALSE)
[10:32:54.575]             base::close(...future.stdout)
[10:32:54.575]         }, add = TRUE)
[10:32:54.575]     }
[10:32:54.575]     ...future.frame <- base::sys.nframe()
[10:32:54.575]     ...future.conditions <- base::list()
[10:32:54.575]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.575]     if (FALSE) {
[10:32:54.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.575]     }
[10:32:54.575]     ...future.result <- base::tryCatch({
[10:32:54.575]         base::withCallingHandlers({
[10:32:54.575]             ...future.value <- base::withVisible(base::local({
[10:32:54.575]                 ...future.makeSendCondition <- base::local({
[10:32:54.575]                   sendCondition <- NULL
[10:32:54.575]                   function(frame = 1L) {
[10:32:54.575]                     if (is.function(sendCondition)) 
[10:32:54.575]                       return(sendCondition)
[10:32:54.575]                     ns <- getNamespace("parallel")
[10:32:54.575]                     if (exists("sendData", mode = "function", 
[10:32:54.575]                       envir = ns)) {
[10:32:54.575]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.575]                         envir = ns)
[10:32:54.575]                       envir <- sys.frame(frame)
[10:32:54.575]                       master <- NULL
[10:32:54.575]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.575]                         !identical(envir, emptyenv())) {
[10:32:54.575]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.575]                           inherits = FALSE)) {
[10:32:54.575]                           master <- get("master", mode = "list", 
[10:32:54.575]                             envir = envir, inherits = FALSE)
[10:32:54.575]                           if (inherits(master, c("SOCKnode", 
[10:32:54.575]                             "SOCK0node"))) {
[10:32:54.575]                             sendCondition <<- function(cond) {
[10:32:54.575]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.575]                                 success = TRUE)
[10:32:54.575]                               parallel_sendData(master, data)
[10:32:54.575]                             }
[10:32:54.575]                             return(sendCondition)
[10:32:54.575]                           }
[10:32:54.575]                         }
[10:32:54.575]                         frame <- frame + 1L
[10:32:54.575]                         envir <- sys.frame(frame)
[10:32:54.575]                       }
[10:32:54.575]                     }
[10:32:54.575]                     sendCondition <<- function(cond) NULL
[10:32:54.575]                   }
[10:32:54.575]                 })
[10:32:54.575]                 withCallingHandlers({
[10:32:54.575]                   NULL
[10:32:54.575]                 }, immediateCondition = function(cond) {
[10:32:54.575]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.575]                   sendCondition(cond)
[10:32:54.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.575]                   {
[10:32:54.575]                     inherits <- base::inherits
[10:32:54.575]                     invokeRestart <- base::invokeRestart
[10:32:54.575]                     is.null <- base::is.null
[10:32:54.575]                     muffled <- FALSE
[10:32:54.575]                     if (inherits(cond, "message")) {
[10:32:54.575]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.575]                       if (muffled) 
[10:32:54.575]                         invokeRestart("muffleMessage")
[10:32:54.575]                     }
[10:32:54.575]                     else if (inherits(cond, "warning")) {
[10:32:54.575]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.575]                       if (muffled) 
[10:32:54.575]                         invokeRestart("muffleWarning")
[10:32:54.575]                     }
[10:32:54.575]                     else if (inherits(cond, "condition")) {
[10:32:54.575]                       if (!is.null(pattern)) {
[10:32:54.575]                         computeRestarts <- base::computeRestarts
[10:32:54.575]                         grepl <- base::grepl
[10:32:54.575]                         restarts <- computeRestarts(cond)
[10:32:54.575]                         for (restart in restarts) {
[10:32:54.575]                           name <- restart$name
[10:32:54.575]                           if (is.null(name)) 
[10:32:54.575]                             next
[10:32:54.575]                           if (!grepl(pattern, name)) 
[10:32:54.575]                             next
[10:32:54.575]                           invokeRestart(restart)
[10:32:54.575]                           muffled <- TRUE
[10:32:54.575]                           break
[10:32:54.575]                         }
[10:32:54.575]                       }
[10:32:54.575]                     }
[10:32:54.575]                     invisible(muffled)
[10:32:54.575]                   }
[10:32:54.575]                   muffleCondition(cond)
[10:32:54.575]                 })
[10:32:54.575]             }))
[10:32:54.575]             future::FutureResult(value = ...future.value$value, 
[10:32:54.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.575]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.575]                     ...future.globalenv.names))
[10:32:54.575]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.575]         }, condition = base::local({
[10:32:54.575]             c <- base::c
[10:32:54.575]             inherits <- base::inherits
[10:32:54.575]             invokeRestart <- base::invokeRestart
[10:32:54.575]             length <- base::length
[10:32:54.575]             list <- base::list
[10:32:54.575]             seq.int <- base::seq.int
[10:32:54.575]             signalCondition <- base::signalCondition
[10:32:54.575]             sys.calls <- base::sys.calls
[10:32:54.575]             `[[` <- base::`[[`
[10:32:54.575]             `+` <- base::`+`
[10:32:54.575]             `<<-` <- base::`<<-`
[10:32:54.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.575]                   3L)]
[10:32:54.575]             }
[10:32:54.575]             function(cond) {
[10:32:54.575]                 is_error <- inherits(cond, "error")
[10:32:54.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.575]                   NULL)
[10:32:54.575]                 if (is_error) {
[10:32:54.575]                   sessionInformation <- function() {
[10:32:54.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.575]                       search = base::search(), system = base::Sys.info())
[10:32:54.575]                   }
[10:32:54.575]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.575]                     cond$call), session = sessionInformation(), 
[10:32:54.575]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.575]                   signalCondition(cond)
[10:32:54.575]                 }
[10:32:54.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.575]                 "immediateCondition"))) {
[10:32:54.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.575]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.575]                   if (TRUE && !signal) {
[10:32:54.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.575]                     {
[10:32:54.575]                       inherits <- base::inherits
[10:32:54.575]                       invokeRestart <- base::invokeRestart
[10:32:54.575]                       is.null <- base::is.null
[10:32:54.575]                       muffled <- FALSE
[10:32:54.575]                       if (inherits(cond, "message")) {
[10:32:54.575]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.575]                         if (muffled) 
[10:32:54.575]                           invokeRestart("muffleMessage")
[10:32:54.575]                       }
[10:32:54.575]                       else if (inherits(cond, "warning")) {
[10:32:54.575]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.575]                         if (muffled) 
[10:32:54.575]                           invokeRestart("muffleWarning")
[10:32:54.575]                       }
[10:32:54.575]                       else if (inherits(cond, "condition")) {
[10:32:54.575]                         if (!is.null(pattern)) {
[10:32:54.575]                           computeRestarts <- base::computeRestarts
[10:32:54.575]                           grepl <- base::grepl
[10:32:54.575]                           restarts <- computeRestarts(cond)
[10:32:54.575]                           for (restart in restarts) {
[10:32:54.575]                             name <- restart$name
[10:32:54.575]                             if (is.null(name)) 
[10:32:54.575]                               next
[10:32:54.575]                             if (!grepl(pattern, name)) 
[10:32:54.575]                               next
[10:32:54.575]                             invokeRestart(restart)
[10:32:54.575]                             muffled <- TRUE
[10:32:54.575]                             break
[10:32:54.575]                           }
[10:32:54.575]                         }
[10:32:54.575]                       }
[10:32:54.575]                       invisible(muffled)
[10:32:54.575]                     }
[10:32:54.575]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.575]                   }
[10:32:54.575]                 }
[10:32:54.575]                 else {
[10:32:54.575]                   if (TRUE) {
[10:32:54.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.575]                     {
[10:32:54.575]                       inherits <- base::inherits
[10:32:54.575]                       invokeRestart <- base::invokeRestart
[10:32:54.575]                       is.null <- base::is.null
[10:32:54.575]                       muffled <- FALSE
[10:32:54.575]                       if (inherits(cond, "message")) {
[10:32:54.575]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.575]                         if (muffled) 
[10:32:54.575]                           invokeRestart("muffleMessage")
[10:32:54.575]                       }
[10:32:54.575]                       else if (inherits(cond, "warning")) {
[10:32:54.575]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.575]                         if (muffled) 
[10:32:54.575]                           invokeRestart("muffleWarning")
[10:32:54.575]                       }
[10:32:54.575]                       else if (inherits(cond, "condition")) {
[10:32:54.575]                         if (!is.null(pattern)) {
[10:32:54.575]                           computeRestarts <- base::computeRestarts
[10:32:54.575]                           grepl <- base::grepl
[10:32:54.575]                           restarts <- computeRestarts(cond)
[10:32:54.575]                           for (restart in restarts) {
[10:32:54.575]                             name <- restart$name
[10:32:54.575]                             if (is.null(name)) 
[10:32:54.575]                               next
[10:32:54.575]                             if (!grepl(pattern, name)) 
[10:32:54.575]                               next
[10:32:54.575]                             invokeRestart(restart)
[10:32:54.575]                             muffled <- TRUE
[10:32:54.575]                             break
[10:32:54.575]                           }
[10:32:54.575]                         }
[10:32:54.575]                       }
[10:32:54.575]                       invisible(muffled)
[10:32:54.575]                     }
[10:32:54.575]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.575]                   }
[10:32:54.575]                 }
[10:32:54.575]             }
[10:32:54.575]         }))
[10:32:54.575]     }, error = function(ex) {
[10:32:54.575]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.575]                 ...future.rng), started = ...future.startTime, 
[10:32:54.575]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.575]             version = "1.8"), class = "FutureResult")
[10:32:54.575]     }, finally = {
[10:32:54.575]         if (!identical(...future.workdir, getwd())) 
[10:32:54.575]             setwd(...future.workdir)
[10:32:54.575]         {
[10:32:54.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.575]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.575]             }
[10:32:54.575]             base::options(...future.oldOptions)
[10:32:54.575]             if (.Platform$OS.type == "windows") {
[10:32:54.575]                 old_names <- names(...future.oldEnvVars)
[10:32:54.575]                 envs <- base::Sys.getenv()
[10:32:54.575]                 names <- names(envs)
[10:32:54.575]                 common <- intersect(names, old_names)
[10:32:54.575]                 added <- setdiff(names, old_names)
[10:32:54.575]                 removed <- setdiff(old_names, names)
[10:32:54.575]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.575]                   envs[common]]
[10:32:54.575]                 NAMES <- toupper(changed)
[10:32:54.575]                 args <- list()
[10:32:54.575]                 for (kk in seq_along(NAMES)) {
[10:32:54.575]                   name <- changed[[kk]]
[10:32:54.575]                   NAME <- NAMES[[kk]]
[10:32:54.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.575]                     next
[10:32:54.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.575]                 }
[10:32:54.575]                 NAMES <- toupper(added)
[10:32:54.575]                 for (kk in seq_along(NAMES)) {
[10:32:54.575]                   name <- added[[kk]]
[10:32:54.575]                   NAME <- NAMES[[kk]]
[10:32:54.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.575]                     next
[10:32:54.575]                   args[[name]] <- ""
[10:32:54.575]                 }
[10:32:54.575]                 NAMES <- toupper(removed)
[10:32:54.575]                 for (kk in seq_along(NAMES)) {
[10:32:54.575]                   name <- removed[[kk]]
[10:32:54.575]                   NAME <- NAMES[[kk]]
[10:32:54.575]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.575]                     next
[10:32:54.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.575]                 }
[10:32:54.575]                 if (length(args) > 0) 
[10:32:54.575]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.575]             }
[10:32:54.575]             else {
[10:32:54.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.575]             }
[10:32:54.575]             {
[10:32:54.575]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.575]                   0L) {
[10:32:54.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.575]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.575]                   base::options(opts)
[10:32:54.575]                 }
[10:32:54.575]                 {
[10:32:54.575]                   {
[10:32:54.575]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.575]                     NULL
[10:32:54.575]                   }
[10:32:54.575]                   options(future.plan = NULL)
[10:32:54.575]                   if (is.na(NA_character_)) 
[10:32:54.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.575]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.575]                     .init = FALSE)
[10:32:54.575]                 }
[10:32:54.575]             }
[10:32:54.575]         }
[10:32:54.575]     })
[10:32:54.575]     if (TRUE) {
[10:32:54.575]         base::sink(type = "output", split = FALSE)
[10:32:54.575]         if (TRUE) {
[10:32:54.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.575]         }
[10:32:54.575]         else {
[10:32:54.575]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.575]         }
[10:32:54.575]         base::close(...future.stdout)
[10:32:54.575]         ...future.stdout <- NULL
[10:32:54.575]     }
[10:32:54.575]     ...future.result$conditions <- ...future.conditions
[10:32:54.575]     ...future.result$finished <- base::Sys.time()
[10:32:54.575]     ...future.result
[10:32:54.575] }
[10:32:54.628] MultisessionFuture started
[10:32:54.628] - Launch lazy future ... done
[10:32:54.628] run() for ‘MultisessionFuture’ ... done
[10:32:54.628] getGlobalsAndPackages() ...
[10:32:54.629] Searching for globals...
[10:32:54.629] - globals found: [1] ‘{’
[10:32:54.629] Searching for globals ... DONE
[10:32:54.630] Resolving globals: FALSE
[10:32:54.630] 
[10:32:54.630] 
[10:32:54.630] getGlobalsAndPackages() ... DONE
[10:32:54.630] run() for ‘Future’ ...
[10:32:54.630] - state: ‘created’
[10:32:54.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.645] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.645]   - Field: ‘node’
[10:32:54.645]   - Field: ‘label’
[10:32:54.645]   - Field: ‘local’
[10:32:54.645]   - Field: ‘owner’
[10:32:54.645]   - Field: ‘envir’
[10:32:54.645]   - Field: ‘workers’
[10:32:54.645]   - Field: ‘packages’
[10:32:54.646]   - Field: ‘gc’
[10:32:54.646]   - Field: ‘conditions’
[10:32:54.646]   - Field: ‘persistent’
[10:32:54.646]   - Field: ‘expr’
[10:32:54.646]   - Field: ‘uuid’
[10:32:54.646]   - Field: ‘seed’
[10:32:54.646]   - Field: ‘version’
[10:32:54.646]   - Field: ‘result’
[10:32:54.646]   - Field: ‘asynchronous’
[10:32:54.646]   - Field: ‘calls’
[10:32:54.647]   - Field: ‘globals’
[10:32:54.647]   - Field: ‘stdout’
[10:32:54.647]   - Field: ‘earlySignal’
[10:32:54.647]   - Field: ‘lazy’
[10:32:54.647]   - Field: ‘state’
[10:32:54.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.647] - Launch lazy future ...
[10:32:54.647] Packages needed by the future expression (n = 0): <none>
[10:32:54.647] Packages needed by future strategies (n = 0): <none>
[10:32:54.648] {
[10:32:54.648]     {
[10:32:54.648]         {
[10:32:54.648]             ...future.startTime <- base::Sys.time()
[10:32:54.648]             {
[10:32:54.648]                 {
[10:32:54.648]                   {
[10:32:54.648]                     {
[10:32:54.648]                       base::local({
[10:32:54.648]                         has_future <- base::requireNamespace("future", 
[10:32:54.648]                           quietly = TRUE)
[10:32:54.648]                         if (has_future) {
[10:32:54.648]                           ns <- base::getNamespace("future")
[10:32:54.648]                           version <- ns[[".package"]][["version"]]
[10:32:54.648]                           if (is.null(version)) 
[10:32:54.648]                             version <- utils::packageVersion("future")
[10:32:54.648]                         }
[10:32:54.648]                         else {
[10:32:54.648]                           version <- NULL
[10:32:54.648]                         }
[10:32:54.648]                         if (!has_future || version < "1.8.0") {
[10:32:54.648]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.648]                             "", base::R.version$version.string), 
[10:32:54.648]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.648]                               "release", "version")], collapse = " "), 
[10:32:54.648]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.648]                             info)
[10:32:54.648]                           info <- base::paste(info, collapse = "; ")
[10:32:54.648]                           if (!has_future) {
[10:32:54.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.648]                               info)
[10:32:54.648]                           }
[10:32:54.648]                           else {
[10:32:54.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.648]                               info, version)
[10:32:54.648]                           }
[10:32:54.648]                           base::stop(msg)
[10:32:54.648]                         }
[10:32:54.648]                       })
[10:32:54.648]                     }
[10:32:54.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.648]                     base::options(mc.cores = 1L)
[10:32:54.648]                   }
[10:32:54.648]                   ...future.strategy.old <- future::plan("list")
[10:32:54.648]                   options(future.plan = NULL)
[10:32:54.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.648]                 }
[10:32:54.648]                 ...future.workdir <- getwd()
[10:32:54.648]             }
[10:32:54.648]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.648]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.648]         }
[10:32:54.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.648]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.648]             base::names(...future.oldOptions))
[10:32:54.648]     }
[10:32:54.648]     if (FALSE) {
[10:32:54.648]     }
[10:32:54.648]     else {
[10:32:54.648]         if (TRUE) {
[10:32:54.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.648]                 open = "w")
[10:32:54.648]         }
[10:32:54.648]         else {
[10:32:54.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.648]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.648]         }
[10:32:54.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.648]             base::sink(type = "output", split = FALSE)
[10:32:54.648]             base::close(...future.stdout)
[10:32:54.648]         }, add = TRUE)
[10:32:54.648]     }
[10:32:54.648]     ...future.frame <- base::sys.nframe()
[10:32:54.648]     ...future.conditions <- base::list()
[10:32:54.648]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.648]     if (FALSE) {
[10:32:54.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.648]     }
[10:32:54.648]     ...future.result <- base::tryCatch({
[10:32:54.648]         base::withCallingHandlers({
[10:32:54.648]             ...future.value <- base::withVisible(base::local({
[10:32:54.648]                 ...future.makeSendCondition <- base::local({
[10:32:54.648]                   sendCondition <- NULL
[10:32:54.648]                   function(frame = 1L) {
[10:32:54.648]                     if (is.function(sendCondition)) 
[10:32:54.648]                       return(sendCondition)
[10:32:54.648]                     ns <- getNamespace("parallel")
[10:32:54.648]                     if (exists("sendData", mode = "function", 
[10:32:54.648]                       envir = ns)) {
[10:32:54.648]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.648]                         envir = ns)
[10:32:54.648]                       envir <- sys.frame(frame)
[10:32:54.648]                       master <- NULL
[10:32:54.648]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.648]                         !identical(envir, emptyenv())) {
[10:32:54.648]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.648]                           inherits = FALSE)) {
[10:32:54.648]                           master <- get("master", mode = "list", 
[10:32:54.648]                             envir = envir, inherits = FALSE)
[10:32:54.648]                           if (inherits(master, c("SOCKnode", 
[10:32:54.648]                             "SOCK0node"))) {
[10:32:54.648]                             sendCondition <<- function(cond) {
[10:32:54.648]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.648]                                 success = TRUE)
[10:32:54.648]                               parallel_sendData(master, data)
[10:32:54.648]                             }
[10:32:54.648]                             return(sendCondition)
[10:32:54.648]                           }
[10:32:54.648]                         }
[10:32:54.648]                         frame <- frame + 1L
[10:32:54.648]                         envir <- sys.frame(frame)
[10:32:54.648]                       }
[10:32:54.648]                     }
[10:32:54.648]                     sendCondition <<- function(cond) NULL
[10:32:54.648]                   }
[10:32:54.648]                 })
[10:32:54.648]                 withCallingHandlers({
[10:32:54.648]                   {
[10:32:54.648]                     4
[10:32:54.648]                   }
[10:32:54.648]                 }, immediateCondition = function(cond) {
[10:32:54.648]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.648]                   sendCondition(cond)
[10:32:54.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.648]                   {
[10:32:54.648]                     inherits <- base::inherits
[10:32:54.648]                     invokeRestart <- base::invokeRestart
[10:32:54.648]                     is.null <- base::is.null
[10:32:54.648]                     muffled <- FALSE
[10:32:54.648]                     if (inherits(cond, "message")) {
[10:32:54.648]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.648]                       if (muffled) 
[10:32:54.648]                         invokeRestart("muffleMessage")
[10:32:54.648]                     }
[10:32:54.648]                     else if (inherits(cond, "warning")) {
[10:32:54.648]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.648]                       if (muffled) 
[10:32:54.648]                         invokeRestart("muffleWarning")
[10:32:54.648]                     }
[10:32:54.648]                     else if (inherits(cond, "condition")) {
[10:32:54.648]                       if (!is.null(pattern)) {
[10:32:54.648]                         computeRestarts <- base::computeRestarts
[10:32:54.648]                         grepl <- base::grepl
[10:32:54.648]                         restarts <- computeRestarts(cond)
[10:32:54.648]                         for (restart in restarts) {
[10:32:54.648]                           name <- restart$name
[10:32:54.648]                           if (is.null(name)) 
[10:32:54.648]                             next
[10:32:54.648]                           if (!grepl(pattern, name)) 
[10:32:54.648]                             next
[10:32:54.648]                           invokeRestart(restart)
[10:32:54.648]                           muffled <- TRUE
[10:32:54.648]                           break
[10:32:54.648]                         }
[10:32:54.648]                       }
[10:32:54.648]                     }
[10:32:54.648]                     invisible(muffled)
[10:32:54.648]                   }
[10:32:54.648]                   muffleCondition(cond)
[10:32:54.648]                 })
[10:32:54.648]             }))
[10:32:54.648]             future::FutureResult(value = ...future.value$value, 
[10:32:54.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.648]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.648]                     ...future.globalenv.names))
[10:32:54.648]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.648]         }, condition = base::local({
[10:32:54.648]             c <- base::c
[10:32:54.648]             inherits <- base::inherits
[10:32:54.648]             invokeRestart <- base::invokeRestart
[10:32:54.648]             length <- base::length
[10:32:54.648]             list <- base::list
[10:32:54.648]             seq.int <- base::seq.int
[10:32:54.648]             signalCondition <- base::signalCondition
[10:32:54.648]             sys.calls <- base::sys.calls
[10:32:54.648]             `[[` <- base::`[[`
[10:32:54.648]             `+` <- base::`+`
[10:32:54.648]             `<<-` <- base::`<<-`
[10:32:54.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.648]                   3L)]
[10:32:54.648]             }
[10:32:54.648]             function(cond) {
[10:32:54.648]                 is_error <- inherits(cond, "error")
[10:32:54.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.648]                   NULL)
[10:32:54.648]                 if (is_error) {
[10:32:54.648]                   sessionInformation <- function() {
[10:32:54.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.648]                       search = base::search(), system = base::Sys.info())
[10:32:54.648]                   }
[10:32:54.648]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.648]                     cond$call), session = sessionInformation(), 
[10:32:54.648]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.648]                   signalCondition(cond)
[10:32:54.648]                 }
[10:32:54.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.648]                 "immediateCondition"))) {
[10:32:54.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.648]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.648]                   if (TRUE && !signal) {
[10:32:54.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.648]                     {
[10:32:54.648]                       inherits <- base::inherits
[10:32:54.648]                       invokeRestart <- base::invokeRestart
[10:32:54.648]                       is.null <- base::is.null
[10:32:54.648]                       muffled <- FALSE
[10:32:54.648]                       if (inherits(cond, "message")) {
[10:32:54.648]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.648]                         if (muffled) 
[10:32:54.648]                           invokeRestart("muffleMessage")
[10:32:54.648]                       }
[10:32:54.648]                       else if (inherits(cond, "warning")) {
[10:32:54.648]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.648]                         if (muffled) 
[10:32:54.648]                           invokeRestart("muffleWarning")
[10:32:54.648]                       }
[10:32:54.648]                       else if (inherits(cond, "condition")) {
[10:32:54.648]                         if (!is.null(pattern)) {
[10:32:54.648]                           computeRestarts <- base::computeRestarts
[10:32:54.648]                           grepl <- base::grepl
[10:32:54.648]                           restarts <- computeRestarts(cond)
[10:32:54.648]                           for (restart in restarts) {
[10:32:54.648]                             name <- restart$name
[10:32:54.648]                             if (is.null(name)) 
[10:32:54.648]                               next
[10:32:54.648]                             if (!grepl(pattern, name)) 
[10:32:54.648]                               next
[10:32:54.648]                             invokeRestart(restart)
[10:32:54.648]                             muffled <- TRUE
[10:32:54.648]                             break
[10:32:54.648]                           }
[10:32:54.648]                         }
[10:32:54.648]                       }
[10:32:54.648]                       invisible(muffled)
[10:32:54.648]                     }
[10:32:54.648]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.648]                   }
[10:32:54.648]                 }
[10:32:54.648]                 else {
[10:32:54.648]                   if (TRUE) {
[10:32:54.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.648]                     {
[10:32:54.648]                       inherits <- base::inherits
[10:32:54.648]                       invokeRestart <- base::invokeRestart
[10:32:54.648]                       is.null <- base::is.null
[10:32:54.648]                       muffled <- FALSE
[10:32:54.648]                       if (inherits(cond, "message")) {
[10:32:54.648]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.648]                         if (muffled) 
[10:32:54.648]                           invokeRestart("muffleMessage")
[10:32:54.648]                       }
[10:32:54.648]                       else if (inherits(cond, "warning")) {
[10:32:54.648]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.648]                         if (muffled) 
[10:32:54.648]                           invokeRestart("muffleWarning")
[10:32:54.648]                       }
[10:32:54.648]                       else if (inherits(cond, "condition")) {
[10:32:54.648]                         if (!is.null(pattern)) {
[10:32:54.648]                           computeRestarts <- base::computeRestarts
[10:32:54.648]                           grepl <- base::grepl
[10:32:54.648]                           restarts <- computeRestarts(cond)
[10:32:54.648]                           for (restart in restarts) {
[10:32:54.648]                             name <- restart$name
[10:32:54.648]                             if (is.null(name)) 
[10:32:54.648]                               next
[10:32:54.648]                             if (!grepl(pattern, name)) 
[10:32:54.648]                               next
[10:32:54.648]                             invokeRestart(restart)
[10:32:54.648]                             muffled <- TRUE
[10:32:54.648]                             break
[10:32:54.648]                           }
[10:32:54.648]                         }
[10:32:54.648]                       }
[10:32:54.648]                       invisible(muffled)
[10:32:54.648]                     }
[10:32:54.648]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.648]                   }
[10:32:54.648]                 }
[10:32:54.648]             }
[10:32:54.648]         }))
[10:32:54.648]     }, error = function(ex) {
[10:32:54.648]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.648]                 ...future.rng), started = ...future.startTime, 
[10:32:54.648]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.648]             version = "1.8"), class = "FutureResult")
[10:32:54.648]     }, finally = {
[10:32:54.648]         if (!identical(...future.workdir, getwd())) 
[10:32:54.648]             setwd(...future.workdir)
[10:32:54.648]         {
[10:32:54.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.648]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.648]             }
[10:32:54.648]             base::options(...future.oldOptions)
[10:32:54.648]             if (.Platform$OS.type == "windows") {
[10:32:54.648]                 old_names <- names(...future.oldEnvVars)
[10:32:54.648]                 envs <- base::Sys.getenv()
[10:32:54.648]                 names <- names(envs)
[10:32:54.648]                 common <- intersect(names, old_names)
[10:32:54.648]                 added <- setdiff(names, old_names)
[10:32:54.648]                 removed <- setdiff(old_names, names)
[10:32:54.648]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.648]                   envs[common]]
[10:32:54.648]                 NAMES <- toupper(changed)
[10:32:54.648]                 args <- list()
[10:32:54.648]                 for (kk in seq_along(NAMES)) {
[10:32:54.648]                   name <- changed[[kk]]
[10:32:54.648]                   NAME <- NAMES[[kk]]
[10:32:54.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.648]                     next
[10:32:54.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.648]                 }
[10:32:54.648]                 NAMES <- toupper(added)
[10:32:54.648]                 for (kk in seq_along(NAMES)) {
[10:32:54.648]                   name <- added[[kk]]
[10:32:54.648]                   NAME <- NAMES[[kk]]
[10:32:54.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.648]                     next
[10:32:54.648]                   args[[name]] <- ""
[10:32:54.648]                 }
[10:32:54.648]                 NAMES <- toupper(removed)
[10:32:54.648]                 for (kk in seq_along(NAMES)) {
[10:32:54.648]                   name <- removed[[kk]]
[10:32:54.648]                   NAME <- NAMES[[kk]]
[10:32:54.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.648]                     next
[10:32:54.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.648]                 }
[10:32:54.648]                 if (length(args) > 0) 
[10:32:54.648]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.648]             }
[10:32:54.648]             else {
[10:32:54.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.648]             }
[10:32:54.648]             {
[10:32:54.648]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.648]                   0L) {
[10:32:54.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.648]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.648]                   base::options(opts)
[10:32:54.648]                 }
[10:32:54.648]                 {
[10:32:54.648]                   {
[10:32:54.648]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.648]                     NULL
[10:32:54.648]                   }
[10:32:54.648]                   options(future.plan = NULL)
[10:32:54.648]                   if (is.na(NA_character_)) 
[10:32:54.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.648]                     .init = FALSE)
[10:32:54.648]                 }
[10:32:54.648]             }
[10:32:54.648]         }
[10:32:54.648]     })
[10:32:54.648]     if (TRUE) {
[10:32:54.648]         base::sink(type = "output", split = FALSE)
[10:32:54.648]         if (TRUE) {
[10:32:54.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.648]         }
[10:32:54.648]         else {
[10:32:54.648]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.648]         }
[10:32:54.648]         base::close(...future.stdout)
[10:32:54.648]         ...future.stdout <- NULL
[10:32:54.648]     }
[10:32:54.648]     ...future.result$conditions <- ...future.conditions
[10:32:54.648]     ...future.result$finished <- base::Sys.time()
[10:32:54.648]     ...future.result
[10:32:54.648] }
[10:32:54.650] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:54.661] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.661] - Validating connection of MultisessionFuture
[10:32:54.661] - received message: FutureResult
[10:32:54.662] - Received FutureResult
[10:32:54.662] - Erased future from FutureRegistry
[10:32:54.662] result() for ClusterFuture ...
[10:32:54.662] - result already collected: FutureResult
[10:32:54.662] result() for ClusterFuture ... done
[10:32:54.662] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.662] result() for ClusterFuture ...
[10:32:54.662] - result already collected: FutureResult
[10:32:54.662] result() for ClusterFuture ... done
[10:32:54.662] result() for ClusterFuture ...
[10:32:54.663] - result already collected: FutureResult
[10:32:54.663] result() for ClusterFuture ... done
[10:32:54.664] MultisessionFuture started
[10:32:54.664] - Launch lazy future ... done
[10:32:54.664] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d2af21d0> 
Classes 'listenv', 'environment' <environment: 0x5652d0938b78> 
[10:32:54.668] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.668] - Validating connection of MultisessionFuture
[10:32:54.668] - received message: FutureResult
[10:32:54.668] - Received FutureResult
[10:32:54.668] - Erased future from FutureRegistry
[10:32:54.668] result() for ClusterFuture ...
[10:32:54.668] - result already collected: FutureResult
[10:32:54.668] result() for ClusterFuture ... done
[10:32:54.668] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.669] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.669] - Validating connection of MultisessionFuture
[10:32:54.669] - received message: FutureResult
[10:32:54.669] - Received FutureResult
[10:32:54.669] - Erased future from FutureRegistry
[10:32:54.670] result() for ClusterFuture ...
[10:32:54.670] - result already collected: FutureResult
[10:32:54.670] result() for ClusterFuture ... done
[10:32:54.670] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:54.671] resolve() on list environment ...
[10:32:54.671]  recursive: 0
[10:32:54.672]  length: 6
[10:32:54.672]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:54.673] signalConditionsASAP(numeric, pos=1) ...
[10:32:54.673] - nx: 6
[10:32:54.673] - relay: TRUE
[10:32:54.673] - stdout: TRUE
[10:32:54.673] - signal: TRUE
[10:32:54.673] - resignal: FALSE
[10:32:54.673] - force: TRUE
[10:32:54.673] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.673] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.673]  - until=2
[10:32:54.674]  - relaying element #2
[10:32:54.674] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.674] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.674] signalConditionsASAP(NULL, pos=1) ... done
[10:32:54.674]  length: 5 (resolved future 1)
[10:32:54.674] Future #2
[10:32:54.674] result() for ClusterFuture ...
[10:32:54.674] - result already collected: FutureResult
[10:32:54.674] result() for ClusterFuture ... done
[10:32:54.674] result() for ClusterFuture ...
[10:32:54.675] - result already collected: FutureResult
[10:32:54.675] result() for ClusterFuture ... done
[10:32:54.675] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:54.675] - nx: 6
[10:32:54.675] - relay: TRUE
[10:32:54.675] - stdout: TRUE
[10:32:54.675] - signal: TRUE
[10:32:54.675] - resignal: FALSE
[10:32:54.675] - force: TRUE
[10:32:54.675] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.675] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.675]  - until=2
[10:32:54.676]  - relaying element #2
[10:32:54.676] result() for ClusterFuture ...
[10:32:54.676] - result already collected: FutureResult
[10:32:54.676] result() for ClusterFuture ... done
[10:32:54.676] result() for ClusterFuture ...
[10:32:54.676] - result already collected: FutureResult
[10:32:54.676] result() for ClusterFuture ... done
[10:32:54.676] result() for ClusterFuture ...
[10:32:54.676] - result already collected: FutureResult
[10:32:54.676] result() for ClusterFuture ... done
[10:32:54.676] result() for ClusterFuture ...
[10:32:54.677] - result already collected: FutureResult
[10:32:54.677] result() for ClusterFuture ... done
[10:32:54.677] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.677] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.677] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:54.677]  length: 4 (resolved future 2)
[10:32:54.677] Future #3
[10:32:54.677] result() for ClusterFuture ...
[10:32:54.677] - result already collected: FutureResult
[10:32:54.677] result() for ClusterFuture ... done
[10:32:54.678] result() for ClusterFuture ...
[10:32:54.678] - result already collected: FutureResult
[10:32:54.678] result() for ClusterFuture ... done
[10:32:54.678] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:54.678] - nx: 6
[10:32:54.678] - relay: TRUE
[10:32:54.678] - stdout: TRUE
[10:32:54.678] - signal: TRUE
[10:32:54.678] - resignal: FALSE
[10:32:54.678] - force: TRUE
[10:32:54.678] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.679] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.679]  - until=3
[10:32:54.679]  - relaying element #3
[10:32:54.679] result() for ClusterFuture ...
[10:32:54.679] - result already collected: FutureResult
[10:32:54.679] result() for ClusterFuture ... done
[10:32:54.679] result() for ClusterFuture ...
[10:32:54.679] - result already collected: FutureResult
[10:32:54.679] result() for ClusterFuture ... done
[10:32:54.679] result() for ClusterFuture ...
[10:32:54.679] - result already collected: FutureResult
[10:32:54.680] result() for ClusterFuture ... done
[10:32:54.680] result() for ClusterFuture ...
[10:32:54.680] - result already collected: FutureResult
[10:32:54.680] result() for ClusterFuture ... done
[10:32:54.680] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.680] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.680] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:54.680]  length: 3 (resolved future 3)
[10:32:54.680] Future #4
[10:32:54.680] result() for ClusterFuture ...
[10:32:54.681] - result already collected: FutureResult
[10:32:54.681] result() for ClusterFuture ... done
[10:32:54.681] result() for ClusterFuture ...
[10:32:54.681] - result already collected: FutureResult
[10:32:54.681] result() for ClusterFuture ... done
[10:32:54.681] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:54.681] - nx: 6
[10:32:54.681] - relay: TRUE
[10:32:54.681] - stdout: TRUE
[10:32:54.681] - signal: TRUE
[10:32:54.681] - resignal: FALSE
[10:32:54.681] - force: TRUE
[10:32:54.682] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.682] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.682]  - until=4
[10:32:54.682]  - relaying element #4
[10:32:54.682] result() for ClusterFuture ...
[10:32:54.682] - result already collected: FutureResult
[10:32:54.682] result() for ClusterFuture ... done
[10:32:54.682] result() for ClusterFuture ...
[10:32:54.682] - result already collected: FutureResult
[10:32:54.682] result() for ClusterFuture ... done
[10:32:54.682] result() for ClusterFuture ...
[10:32:54.683] - result already collected: FutureResult
[10:32:54.683] result() for ClusterFuture ... done
[10:32:54.683] result() for ClusterFuture ...
[10:32:54.683] - result already collected: FutureResult
[10:32:54.683] result() for ClusterFuture ... done
[10:32:54.683] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.683] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.683] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:54.683]  length: 2 (resolved future 4)
[10:32:54.683] signalConditionsASAP(NULL, pos=5) ...
[10:32:54.683] - nx: 6
[10:32:54.684] - relay: TRUE
[10:32:54.684] - stdout: TRUE
[10:32:54.684] - signal: TRUE
[10:32:54.684] - resignal: FALSE
[10:32:54.684] - force: TRUE
[10:32:54.684] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.684] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.684]  - until=6
[10:32:54.684]  - relaying element #6
[10:32:54.684] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.684] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.684] signalConditionsASAP(NULL, pos=5) ... done
[10:32:54.685]  length: 1 (resolved future 5)
[10:32:54.685] signalConditionsASAP(numeric, pos=6) ...
[10:32:54.685] - nx: 6
[10:32:54.685] - relay: TRUE
[10:32:54.685] - stdout: TRUE
[10:32:54.685] - signal: TRUE
[10:32:54.685] - resignal: FALSE
[10:32:54.685] - force: TRUE
[10:32:54.685] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.685] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.685]  - until=6
[10:32:54.686] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.686] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.686] signalConditionsASAP(numeric, pos=6) ... done
[10:32:54.686]  length: 0 (resolved future 6)
[10:32:54.686] Relaying remaining futures
[10:32:54.686] signalConditionsASAP(NULL, pos=0) ...
[10:32:54.686] - nx: 6
[10:32:54.686] - relay: TRUE
[10:32:54.686] - stdout: TRUE
[10:32:54.686] - signal: TRUE
[10:32:54.686] - resignal: FALSE
[10:32:54.686] - force: TRUE
[10:32:54.687] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.687] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:54.687] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.687] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.687] signalConditionsASAP(NULL, pos=0) ... done
[10:32:54.687] resolve() on list environment ... DONE
[10:32:54.687] result() for ClusterFuture ...
[10:32:54.687] - result already collected: FutureResult
[10:32:54.687] result() for ClusterFuture ... done
[10:32:54.687] result() for ClusterFuture ...
[10:32:54.688] - result already collected: FutureResult
[10:32:54.688] result() for ClusterFuture ... done
[10:32:54.688] result() for ClusterFuture ...
[10:32:54.688] - result already collected: FutureResult
[10:32:54.688] result() for ClusterFuture ... done
[10:32:54.688] result() for ClusterFuture ...
[10:32:54.688] - result already collected: FutureResult
[10:32:54.688] result() for ClusterFuture ... done
[10:32:54.688] result() for ClusterFuture ...
[10:32:54.688] - result already collected: FutureResult
[10:32:54.689] result() for ClusterFuture ... done
[10:32:54.689] result() for ClusterFuture ...
[10:32:54.689] - result already collected: FutureResult
[10:32:54.689] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652cf8e1340> 
Dimensions: c(1, 6)
[10:32:54.689] getGlobalsAndPackages() ...
[10:32:54.689] Searching for globals...
[10:32:54.690] 
[10:32:54.690] Searching for globals ... DONE
[10:32:54.690] - globals: [0] <none>
[10:32:54.690] getGlobalsAndPackages() ... DONE
[10:32:54.690] run() for ‘Future’ ...
[10:32:54.691] - state: ‘created’
[10:32:54.691] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.705]   - Field: ‘node’
[10:32:54.705]   - Field: ‘label’
[10:32:54.705]   - Field: ‘local’
[10:32:54.705]   - Field: ‘owner’
[10:32:54.705]   - Field: ‘envir’
[10:32:54.705]   - Field: ‘workers’
[10:32:54.705]   - Field: ‘packages’
[10:32:54.706]   - Field: ‘gc’
[10:32:54.706]   - Field: ‘conditions’
[10:32:54.706]   - Field: ‘persistent’
[10:32:54.706]   - Field: ‘expr’
[10:32:54.706]   - Field: ‘uuid’
[10:32:54.706]   - Field: ‘seed’
[10:32:54.706]   - Field: ‘version’
[10:32:54.706]   - Field: ‘result’
[10:32:54.706]   - Field: ‘asynchronous’
[10:32:54.706]   - Field: ‘calls’
[10:32:54.707]   - Field: ‘globals’
[10:32:54.707]   - Field: ‘stdout’
[10:32:54.707]   - Field: ‘earlySignal’
[10:32:54.707]   - Field: ‘lazy’
[10:32:54.707]   - Field: ‘state’
[10:32:54.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.707] - Launch lazy future ...
[10:32:54.707] Packages needed by the future expression (n = 0): <none>
[10:32:54.708] Packages needed by future strategies (n = 0): <none>
[10:32:54.708] {
[10:32:54.708]     {
[10:32:54.708]         {
[10:32:54.708]             ...future.startTime <- base::Sys.time()
[10:32:54.708]             {
[10:32:54.708]                 {
[10:32:54.708]                   {
[10:32:54.708]                     {
[10:32:54.708]                       base::local({
[10:32:54.708]                         has_future <- base::requireNamespace("future", 
[10:32:54.708]                           quietly = TRUE)
[10:32:54.708]                         if (has_future) {
[10:32:54.708]                           ns <- base::getNamespace("future")
[10:32:54.708]                           version <- ns[[".package"]][["version"]]
[10:32:54.708]                           if (is.null(version)) 
[10:32:54.708]                             version <- utils::packageVersion("future")
[10:32:54.708]                         }
[10:32:54.708]                         else {
[10:32:54.708]                           version <- NULL
[10:32:54.708]                         }
[10:32:54.708]                         if (!has_future || version < "1.8.0") {
[10:32:54.708]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.708]                             "", base::R.version$version.string), 
[10:32:54.708]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.708]                               "release", "version")], collapse = " "), 
[10:32:54.708]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.708]                             info)
[10:32:54.708]                           info <- base::paste(info, collapse = "; ")
[10:32:54.708]                           if (!has_future) {
[10:32:54.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.708]                               info)
[10:32:54.708]                           }
[10:32:54.708]                           else {
[10:32:54.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.708]                               info, version)
[10:32:54.708]                           }
[10:32:54.708]                           base::stop(msg)
[10:32:54.708]                         }
[10:32:54.708]                       })
[10:32:54.708]                     }
[10:32:54.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.708]                     base::options(mc.cores = 1L)
[10:32:54.708]                   }
[10:32:54.708]                   ...future.strategy.old <- future::plan("list")
[10:32:54.708]                   options(future.plan = NULL)
[10:32:54.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.708]                 }
[10:32:54.708]                 ...future.workdir <- getwd()
[10:32:54.708]             }
[10:32:54.708]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.708]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.708]         }
[10:32:54.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.708]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.708]             base::names(...future.oldOptions))
[10:32:54.708]     }
[10:32:54.708]     if (FALSE) {
[10:32:54.708]     }
[10:32:54.708]     else {
[10:32:54.708]         if (TRUE) {
[10:32:54.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.708]                 open = "w")
[10:32:54.708]         }
[10:32:54.708]         else {
[10:32:54.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.708]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.708]         }
[10:32:54.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.708]             base::sink(type = "output", split = FALSE)
[10:32:54.708]             base::close(...future.stdout)
[10:32:54.708]         }, add = TRUE)
[10:32:54.708]     }
[10:32:54.708]     ...future.frame <- base::sys.nframe()
[10:32:54.708]     ...future.conditions <- base::list()
[10:32:54.708]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.708]     if (FALSE) {
[10:32:54.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.708]     }
[10:32:54.708]     ...future.result <- base::tryCatch({
[10:32:54.708]         base::withCallingHandlers({
[10:32:54.708]             ...future.value <- base::withVisible(base::local({
[10:32:54.708]                 ...future.makeSendCondition <- base::local({
[10:32:54.708]                   sendCondition <- NULL
[10:32:54.708]                   function(frame = 1L) {
[10:32:54.708]                     if (is.function(sendCondition)) 
[10:32:54.708]                       return(sendCondition)
[10:32:54.708]                     ns <- getNamespace("parallel")
[10:32:54.708]                     if (exists("sendData", mode = "function", 
[10:32:54.708]                       envir = ns)) {
[10:32:54.708]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.708]                         envir = ns)
[10:32:54.708]                       envir <- sys.frame(frame)
[10:32:54.708]                       master <- NULL
[10:32:54.708]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.708]                         !identical(envir, emptyenv())) {
[10:32:54.708]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.708]                           inherits = FALSE)) {
[10:32:54.708]                           master <- get("master", mode = "list", 
[10:32:54.708]                             envir = envir, inherits = FALSE)
[10:32:54.708]                           if (inherits(master, c("SOCKnode", 
[10:32:54.708]                             "SOCK0node"))) {
[10:32:54.708]                             sendCondition <<- function(cond) {
[10:32:54.708]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.708]                                 success = TRUE)
[10:32:54.708]                               parallel_sendData(master, data)
[10:32:54.708]                             }
[10:32:54.708]                             return(sendCondition)
[10:32:54.708]                           }
[10:32:54.708]                         }
[10:32:54.708]                         frame <- frame + 1L
[10:32:54.708]                         envir <- sys.frame(frame)
[10:32:54.708]                       }
[10:32:54.708]                     }
[10:32:54.708]                     sendCondition <<- function(cond) NULL
[10:32:54.708]                   }
[10:32:54.708]                 })
[10:32:54.708]                 withCallingHandlers({
[10:32:54.708]                   2
[10:32:54.708]                 }, immediateCondition = function(cond) {
[10:32:54.708]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.708]                   sendCondition(cond)
[10:32:54.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.708]                   {
[10:32:54.708]                     inherits <- base::inherits
[10:32:54.708]                     invokeRestart <- base::invokeRestart
[10:32:54.708]                     is.null <- base::is.null
[10:32:54.708]                     muffled <- FALSE
[10:32:54.708]                     if (inherits(cond, "message")) {
[10:32:54.708]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.708]                       if (muffled) 
[10:32:54.708]                         invokeRestart("muffleMessage")
[10:32:54.708]                     }
[10:32:54.708]                     else if (inherits(cond, "warning")) {
[10:32:54.708]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.708]                       if (muffled) 
[10:32:54.708]                         invokeRestart("muffleWarning")
[10:32:54.708]                     }
[10:32:54.708]                     else if (inherits(cond, "condition")) {
[10:32:54.708]                       if (!is.null(pattern)) {
[10:32:54.708]                         computeRestarts <- base::computeRestarts
[10:32:54.708]                         grepl <- base::grepl
[10:32:54.708]                         restarts <- computeRestarts(cond)
[10:32:54.708]                         for (restart in restarts) {
[10:32:54.708]                           name <- restart$name
[10:32:54.708]                           if (is.null(name)) 
[10:32:54.708]                             next
[10:32:54.708]                           if (!grepl(pattern, name)) 
[10:32:54.708]                             next
[10:32:54.708]                           invokeRestart(restart)
[10:32:54.708]                           muffled <- TRUE
[10:32:54.708]                           break
[10:32:54.708]                         }
[10:32:54.708]                       }
[10:32:54.708]                     }
[10:32:54.708]                     invisible(muffled)
[10:32:54.708]                   }
[10:32:54.708]                   muffleCondition(cond)
[10:32:54.708]                 })
[10:32:54.708]             }))
[10:32:54.708]             future::FutureResult(value = ...future.value$value, 
[10:32:54.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.708]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.708]                     ...future.globalenv.names))
[10:32:54.708]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.708]         }, condition = base::local({
[10:32:54.708]             c <- base::c
[10:32:54.708]             inherits <- base::inherits
[10:32:54.708]             invokeRestart <- base::invokeRestart
[10:32:54.708]             length <- base::length
[10:32:54.708]             list <- base::list
[10:32:54.708]             seq.int <- base::seq.int
[10:32:54.708]             signalCondition <- base::signalCondition
[10:32:54.708]             sys.calls <- base::sys.calls
[10:32:54.708]             `[[` <- base::`[[`
[10:32:54.708]             `+` <- base::`+`
[10:32:54.708]             `<<-` <- base::`<<-`
[10:32:54.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.708]                   3L)]
[10:32:54.708]             }
[10:32:54.708]             function(cond) {
[10:32:54.708]                 is_error <- inherits(cond, "error")
[10:32:54.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.708]                   NULL)
[10:32:54.708]                 if (is_error) {
[10:32:54.708]                   sessionInformation <- function() {
[10:32:54.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.708]                       search = base::search(), system = base::Sys.info())
[10:32:54.708]                   }
[10:32:54.708]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.708]                     cond$call), session = sessionInformation(), 
[10:32:54.708]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.708]                   signalCondition(cond)
[10:32:54.708]                 }
[10:32:54.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.708]                 "immediateCondition"))) {
[10:32:54.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.708]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.708]                   if (TRUE && !signal) {
[10:32:54.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.708]                     {
[10:32:54.708]                       inherits <- base::inherits
[10:32:54.708]                       invokeRestart <- base::invokeRestart
[10:32:54.708]                       is.null <- base::is.null
[10:32:54.708]                       muffled <- FALSE
[10:32:54.708]                       if (inherits(cond, "message")) {
[10:32:54.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.708]                         if (muffled) 
[10:32:54.708]                           invokeRestart("muffleMessage")
[10:32:54.708]                       }
[10:32:54.708]                       else if (inherits(cond, "warning")) {
[10:32:54.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.708]                         if (muffled) 
[10:32:54.708]                           invokeRestart("muffleWarning")
[10:32:54.708]                       }
[10:32:54.708]                       else if (inherits(cond, "condition")) {
[10:32:54.708]                         if (!is.null(pattern)) {
[10:32:54.708]                           computeRestarts <- base::computeRestarts
[10:32:54.708]                           grepl <- base::grepl
[10:32:54.708]                           restarts <- computeRestarts(cond)
[10:32:54.708]                           for (restart in restarts) {
[10:32:54.708]                             name <- restart$name
[10:32:54.708]                             if (is.null(name)) 
[10:32:54.708]                               next
[10:32:54.708]                             if (!grepl(pattern, name)) 
[10:32:54.708]                               next
[10:32:54.708]                             invokeRestart(restart)
[10:32:54.708]                             muffled <- TRUE
[10:32:54.708]                             break
[10:32:54.708]                           }
[10:32:54.708]                         }
[10:32:54.708]                       }
[10:32:54.708]                       invisible(muffled)
[10:32:54.708]                     }
[10:32:54.708]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.708]                   }
[10:32:54.708]                 }
[10:32:54.708]                 else {
[10:32:54.708]                   if (TRUE) {
[10:32:54.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.708]                     {
[10:32:54.708]                       inherits <- base::inherits
[10:32:54.708]                       invokeRestart <- base::invokeRestart
[10:32:54.708]                       is.null <- base::is.null
[10:32:54.708]                       muffled <- FALSE
[10:32:54.708]                       if (inherits(cond, "message")) {
[10:32:54.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.708]                         if (muffled) 
[10:32:54.708]                           invokeRestart("muffleMessage")
[10:32:54.708]                       }
[10:32:54.708]                       else if (inherits(cond, "warning")) {
[10:32:54.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.708]                         if (muffled) 
[10:32:54.708]                           invokeRestart("muffleWarning")
[10:32:54.708]                       }
[10:32:54.708]                       else if (inherits(cond, "condition")) {
[10:32:54.708]                         if (!is.null(pattern)) {
[10:32:54.708]                           computeRestarts <- base::computeRestarts
[10:32:54.708]                           grepl <- base::grepl
[10:32:54.708]                           restarts <- computeRestarts(cond)
[10:32:54.708]                           for (restart in restarts) {
[10:32:54.708]                             name <- restart$name
[10:32:54.708]                             if (is.null(name)) 
[10:32:54.708]                               next
[10:32:54.708]                             if (!grepl(pattern, name)) 
[10:32:54.708]                               next
[10:32:54.708]                             invokeRestart(restart)
[10:32:54.708]                             muffled <- TRUE
[10:32:54.708]                             break
[10:32:54.708]                           }
[10:32:54.708]                         }
[10:32:54.708]                       }
[10:32:54.708]                       invisible(muffled)
[10:32:54.708]                     }
[10:32:54.708]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.708]                   }
[10:32:54.708]                 }
[10:32:54.708]             }
[10:32:54.708]         }))
[10:32:54.708]     }, error = function(ex) {
[10:32:54.708]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.708]                 ...future.rng), started = ...future.startTime, 
[10:32:54.708]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.708]             version = "1.8"), class = "FutureResult")
[10:32:54.708]     }, finally = {
[10:32:54.708]         if (!identical(...future.workdir, getwd())) 
[10:32:54.708]             setwd(...future.workdir)
[10:32:54.708]         {
[10:32:54.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.708]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.708]             }
[10:32:54.708]             base::options(...future.oldOptions)
[10:32:54.708]             if (.Platform$OS.type == "windows") {
[10:32:54.708]                 old_names <- names(...future.oldEnvVars)
[10:32:54.708]                 envs <- base::Sys.getenv()
[10:32:54.708]                 names <- names(envs)
[10:32:54.708]                 common <- intersect(names, old_names)
[10:32:54.708]                 added <- setdiff(names, old_names)
[10:32:54.708]                 removed <- setdiff(old_names, names)
[10:32:54.708]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.708]                   envs[common]]
[10:32:54.708]                 NAMES <- toupper(changed)
[10:32:54.708]                 args <- list()
[10:32:54.708]                 for (kk in seq_along(NAMES)) {
[10:32:54.708]                   name <- changed[[kk]]
[10:32:54.708]                   NAME <- NAMES[[kk]]
[10:32:54.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.708]                     next
[10:32:54.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.708]                 }
[10:32:54.708]                 NAMES <- toupper(added)
[10:32:54.708]                 for (kk in seq_along(NAMES)) {
[10:32:54.708]                   name <- added[[kk]]
[10:32:54.708]                   NAME <- NAMES[[kk]]
[10:32:54.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.708]                     next
[10:32:54.708]                   args[[name]] <- ""
[10:32:54.708]                 }
[10:32:54.708]                 NAMES <- toupper(removed)
[10:32:54.708]                 for (kk in seq_along(NAMES)) {
[10:32:54.708]                   name <- removed[[kk]]
[10:32:54.708]                   NAME <- NAMES[[kk]]
[10:32:54.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.708]                     next
[10:32:54.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.708]                 }
[10:32:54.708]                 if (length(args) > 0) 
[10:32:54.708]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.708]             }
[10:32:54.708]             else {
[10:32:54.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.708]             }
[10:32:54.708]             {
[10:32:54.708]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.708]                   0L) {
[10:32:54.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.708]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.708]                   base::options(opts)
[10:32:54.708]                 }
[10:32:54.708]                 {
[10:32:54.708]                   {
[10:32:54.708]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.708]                     NULL
[10:32:54.708]                   }
[10:32:54.708]                   options(future.plan = NULL)
[10:32:54.708]                   if (is.na(NA_character_)) 
[10:32:54.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.708]                     .init = FALSE)
[10:32:54.708]                 }
[10:32:54.708]             }
[10:32:54.708]         }
[10:32:54.708]     })
[10:32:54.708]     if (TRUE) {
[10:32:54.708]         base::sink(type = "output", split = FALSE)
[10:32:54.708]         if (TRUE) {
[10:32:54.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.708]         }
[10:32:54.708]         else {
[10:32:54.708]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.708]         }
[10:32:54.708]         base::close(...future.stdout)
[10:32:54.708]         ...future.stdout <- NULL
[10:32:54.708]     }
[10:32:54.708]     ...future.result$conditions <- ...future.conditions
[10:32:54.708]     ...future.result$finished <- base::Sys.time()
[10:32:54.708]     ...future.result
[10:32:54.708] }
[10:32:54.711] MultisessionFuture started
[10:32:54.711] - Launch lazy future ... done
[10:32:54.711] run() for ‘MultisessionFuture’ ... done
[10:32:54.712] getGlobalsAndPackages() ...
[10:32:54.712] Searching for globals...
[10:32:54.712] 
[10:32:54.712] Searching for globals ... DONE
[10:32:54.713] - globals: [0] <none>
[10:32:54.713] getGlobalsAndPackages() ... DONE
[10:32:54.713] run() for ‘Future’ ...
[10:32:54.713] - state: ‘created’
[10:32:54.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.727]   - Field: ‘node’
[10:32:54.727]   - Field: ‘label’
[10:32:54.728]   - Field: ‘local’
[10:32:54.728]   - Field: ‘owner’
[10:32:54.728]   - Field: ‘envir’
[10:32:54.728]   - Field: ‘workers’
[10:32:54.728]   - Field: ‘packages’
[10:32:54.728]   - Field: ‘gc’
[10:32:54.728]   - Field: ‘conditions’
[10:32:54.728]   - Field: ‘persistent’
[10:32:54.728]   - Field: ‘expr’
[10:32:54.728]   - Field: ‘uuid’
[10:32:54.729]   - Field: ‘seed’
[10:32:54.729]   - Field: ‘version’
[10:32:54.729]   - Field: ‘result’
[10:32:54.729]   - Field: ‘asynchronous’
[10:32:54.729]   - Field: ‘calls’
[10:32:54.729]   - Field: ‘globals’
[10:32:54.729]   - Field: ‘stdout’
[10:32:54.729]   - Field: ‘earlySignal’
[10:32:54.729]   - Field: ‘lazy’
[10:32:54.729]   - Field: ‘state’
[10:32:54.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.730] - Launch lazy future ...
[10:32:54.730] Packages needed by the future expression (n = 0): <none>
[10:32:54.730] Packages needed by future strategies (n = 0): <none>
[10:32:54.730] {
[10:32:54.730]     {
[10:32:54.730]         {
[10:32:54.730]             ...future.startTime <- base::Sys.time()
[10:32:54.730]             {
[10:32:54.730]                 {
[10:32:54.730]                   {
[10:32:54.730]                     {
[10:32:54.730]                       base::local({
[10:32:54.730]                         has_future <- base::requireNamespace("future", 
[10:32:54.730]                           quietly = TRUE)
[10:32:54.730]                         if (has_future) {
[10:32:54.730]                           ns <- base::getNamespace("future")
[10:32:54.730]                           version <- ns[[".package"]][["version"]]
[10:32:54.730]                           if (is.null(version)) 
[10:32:54.730]                             version <- utils::packageVersion("future")
[10:32:54.730]                         }
[10:32:54.730]                         else {
[10:32:54.730]                           version <- NULL
[10:32:54.730]                         }
[10:32:54.730]                         if (!has_future || version < "1.8.0") {
[10:32:54.730]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.730]                             "", base::R.version$version.string), 
[10:32:54.730]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.730]                               "release", "version")], collapse = " "), 
[10:32:54.730]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.730]                             info)
[10:32:54.730]                           info <- base::paste(info, collapse = "; ")
[10:32:54.730]                           if (!has_future) {
[10:32:54.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.730]                               info)
[10:32:54.730]                           }
[10:32:54.730]                           else {
[10:32:54.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.730]                               info, version)
[10:32:54.730]                           }
[10:32:54.730]                           base::stop(msg)
[10:32:54.730]                         }
[10:32:54.730]                       })
[10:32:54.730]                     }
[10:32:54.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.730]                     base::options(mc.cores = 1L)
[10:32:54.730]                   }
[10:32:54.730]                   ...future.strategy.old <- future::plan("list")
[10:32:54.730]                   options(future.plan = NULL)
[10:32:54.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.730]                 }
[10:32:54.730]                 ...future.workdir <- getwd()
[10:32:54.730]             }
[10:32:54.730]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.730]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.730]         }
[10:32:54.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.730]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.730]             base::names(...future.oldOptions))
[10:32:54.730]     }
[10:32:54.730]     if (FALSE) {
[10:32:54.730]     }
[10:32:54.730]     else {
[10:32:54.730]         if (TRUE) {
[10:32:54.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.730]                 open = "w")
[10:32:54.730]         }
[10:32:54.730]         else {
[10:32:54.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.730]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.730]         }
[10:32:54.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.730]             base::sink(type = "output", split = FALSE)
[10:32:54.730]             base::close(...future.stdout)
[10:32:54.730]         }, add = TRUE)
[10:32:54.730]     }
[10:32:54.730]     ...future.frame <- base::sys.nframe()
[10:32:54.730]     ...future.conditions <- base::list()
[10:32:54.730]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.730]     if (FALSE) {
[10:32:54.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.730]     }
[10:32:54.730]     ...future.result <- base::tryCatch({
[10:32:54.730]         base::withCallingHandlers({
[10:32:54.730]             ...future.value <- base::withVisible(base::local({
[10:32:54.730]                 ...future.makeSendCondition <- base::local({
[10:32:54.730]                   sendCondition <- NULL
[10:32:54.730]                   function(frame = 1L) {
[10:32:54.730]                     if (is.function(sendCondition)) 
[10:32:54.730]                       return(sendCondition)
[10:32:54.730]                     ns <- getNamespace("parallel")
[10:32:54.730]                     if (exists("sendData", mode = "function", 
[10:32:54.730]                       envir = ns)) {
[10:32:54.730]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.730]                         envir = ns)
[10:32:54.730]                       envir <- sys.frame(frame)
[10:32:54.730]                       master <- NULL
[10:32:54.730]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.730]                         !identical(envir, emptyenv())) {
[10:32:54.730]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.730]                           inherits = FALSE)) {
[10:32:54.730]                           master <- get("master", mode = "list", 
[10:32:54.730]                             envir = envir, inherits = FALSE)
[10:32:54.730]                           if (inherits(master, c("SOCKnode", 
[10:32:54.730]                             "SOCK0node"))) {
[10:32:54.730]                             sendCondition <<- function(cond) {
[10:32:54.730]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.730]                                 success = TRUE)
[10:32:54.730]                               parallel_sendData(master, data)
[10:32:54.730]                             }
[10:32:54.730]                             return(sendCondition)
[10:32:54.730]                           }
[10:32:54.730]                         }
[10:32:54.730]                         frame <- frame + 1L
[10:32:54.730]                         envir <- sys.frame(frame)
[10:32:54.730]                       }
[10:32:54.730]                     }
[10:32:54.730]                     sendCondition <<- function(cond) NULL
[10:32:54.730]                   }
[10:32:54.730]                 })
[10:32:54.730]                 withCallingHandlers({
[10:32:54.730]                   NULL
[10:32:54.730]                 }, immediateCondition = function(cond) {
[10:32:54.730]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.730]                   sendCondition(cond)
[10:32:54.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.730]                   {
[10:32:54.730]                     inherits <- base::inherits
[10:32:54.730]                     invokeRestart <- base::invokeRestart
[10:32:54.730]                     is.null <- base::is.null
[10:32:54.730]                     muffled <- FALSE
[10:32:54.730]                     if (inherits(cond, "message")) {
[10:32:54.730]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.730]                       if (muffled) 
[10:32:54.730]                         invokeRestart("muffleMessage")
[10:32:54.730]                     }
[10:32:54.730]                     else if (inherits(cond, "warning")) {
[10:32:54.730]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.730]                       if (muffled) 
[10:32:54.730]                         invokeRestart("muffleWarning")
[10:32:54.730]                     }
[10:32:54.730]                     else if (inherits(cond, "condition")) {
[10:32:54.730]                       if (!is.null(pattern)) {
[10:32:54.730]                         computeRestarts <- base::computeRestarts
[10:32:54.730]                         grepl <- base::grepl
[10:32:54.730]                         restarts <- computeRestarts(cond)
[10:32:54.730]                         for (restart in restarts) {
[10:32:54.730]                           name <- restart$name
[10:32:54.730]                           if (is.null(name)) 
[10:32:54.730]                             next
[10:32:54.730]                           if (!grepl(pattern, name)) 
[10:32:54.730]                             next
[10:32:54.730]                           invokeRestart(restart)
[10:32:54.730]                           muffled <- TRUE
[10:32:54.730]                           break
[10:32:54.730]                         }
[10:32:54.730]                       }
[10:32:54.730]                     }
[10:32:54.730]                     invisible(muffled)
[10:32:54.730]                   }
[10:32:54.730]                   muffleCondition(cond)
[10:32:54.730]                 })
[10:32:54.730]             }))
[10:32:54.730]             future::FutureResult(value = ...future.value$value, 
[10:32:54.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.730]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.730]                     ...future.globalenv.names))
[10:32:54.730]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.730]         }, condition = base::local({
[10:32:54.730]             c <- base::c
[10:32:54.730]             inherits <- base::inherits
[10:32:54.730]             invokeRestart <- base::invokeRestart
[10:32:54.730]             length <- base::length
[10:32:54.730]             list <- base::list
[10:32:54.730]             seq.int <- base::seq.int
[10:32:54.730]             signalCondition <- base::signalCondition
[10:32:54.730]             sys.calls <- base::sys.calls
[10:32:54.730]             `[[` <- base::`[[`
[10:32:54.730]             `+` <- base::`+`
[10:32:54.730]             `<<-` <- base::`<<-`
[10:32:54.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.730]                   3L)]
[10:32:54.730]             }
[10:32:54.730]             function(cond) {
[10:32:54.730]                 is_error <- inherits(cond, "error")
[10:32:54.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.730]                   NULL)
[10:32:54.730]                 if (is_error) {
[10:32:54.730]                   sessionInformation <- function() {
[10:32:54.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.730]                       search = base::search(), system = base::Sys.info())
[10:32:54.730]                   }
[10:32:54.730]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.730]                     cond$call), session = sessionInformation(), 
[10:32:54.730]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.730]                   signalCondition(cond)
[10:32:54.730]                 }
[10:32:54.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.730]                 "immediateCondition"))) {
[10:32:54.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.730]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.730]                   if (TRUE && !signal) {
[10:32:54.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.730]                     {
[10:32:54.730]                       inherits <- base::inherits
[10:32:54.730]                       invokeRestart <- base::invokeRestart
[10:32:54.730]                       is.null <- base::is.null
[10:32:54.730]                       muffled <- FALSE
[10:32:54.730]                       if (inherits(cond, "message")) {
[10:32:54.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.730]                         if (muffled) 
[10:32:54.730]                           invokeRestart("muffleMessage")
[10:32:54.730]                       }
[10:32:54.730]                       else if (inherits(cond, "warning")) {
[10:32:54.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.730]                         if (muffled) 
[10:32:54.730]                           invokeRestart("muffleWarning")
[10:32:54.730]                       }
[10:32:54.730]                       else if (inherits(cond, "condition")) {
[10:32:54.730]                         if (!is.null(pattern)) {
[10:32:54.730]                           computeRestarts <- base::computeRestarts
[10:32:54.730]                           grepl <- base::grepl
[10:32:54.730]                           restarts <- computeRestarts(cond)
[10:32:54.730]                           for (restart in restarts) {
[10:32:54.730]                             name <- restart$name
[10:32:54.730]                             if (is.null(name)) 
[10:32:54.730]                               next
[10:32:54.730]                             if (!grepl(pattern, name)) 
[10:32:54.730]                               next
[10:32:54.730]                             invokeRestart(restart)
[10:32:54.730]                             muffled <- TRUE
[10:32:54.730]                             break
[10:32:54.730]                           }
[10:32:54.730]                         }
[10:32:54.730]                       }
[10:32:54.730]                       invisible(muffled)
[10:32:54.730]                     }
[10:32:54.730]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.730]                   }
[10:32:54.730]                 }
[10:32:54.730]                 else {
[10:32:54.730]                   if (TRUE) {
[10:32:54.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.730]                     {
[10:32:54.730]                       inherits <- base::inherits
[10:32:54.730]                       invokeRestart <- base::invokeRestart
[10:32:54.730]                       is.null <- base::is.null
[10:32:54.730]                       muffled <- FALSE
[10:32:54.730]                       if (inherits(cond, "message")) {
[10:32:54.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.730]                         if (muffled) 
[10:32:54.730]                           invokeRestart("muffleMessage")
[10:32:54.730]                       }
[10:32:54.730]                       else if (inherits(cond, "warning")) {
[10:32:54.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.730]                         if (muffled) 
[10:32:54.730]                           invokeRestart("muffleWarning")
[10:32:54.730]                       }
[10:32:54.730]                       else if (inherits(cond, "condition")) {
[10:32:54.730]                         if (!is.null(pattern)) {
[10:32:54.730]                           computeRestarts <- base::computeRestarts
[10:32:54.730]                           grepl <- base::grepl
[10:32:54.730]                           restarts <- computeRestarts(cond)
[10:32:54.730]                           for (restart in restarts) {
[10:32:54.730]                             name <- restart$name
[10:32:54.730]                             if (is.null(name)) 
[10:32:54.730]                               next
[10:32:54.730]                             if (!grepl(pattern, name)) 
[10:32:54.730]                               next
[10:32:54.730]                             invokeRestart(restart)
[10:32:54.730]                             muffled <- TRUE
[10:32:54.730]                             break
[10:32:54.730]                           }
[10:32:54.730]                         }
[10:32:54.730]                       }
[10:32:54.730]                       invisible(muffled)
[10:32:54.730]                     }
[10:32:54.730]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.730]                   }
[10:32:54.730]                 }
[10:32:54.730]             }
[10:32:54.730]         }))
[10:32:54.730]     }, error = function(ex) {
[10:32:54.730]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.730]                 ...future.rng), started = ...future.startTime, 
[10:32:54.730]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.730]             version = "1.8"), class = "FutureResult")
[10:32:54.730]     }, finally = {
[10:32:54.730]         if (!identical(...future.workdir, getwd())) 
[10:32:54.730]             setwd(...future.workdir)
[10:32:54.730]         {
[10:32:54.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.730]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.730]             }
[10:32:54.730]             base::options(...future.oldOptions)
[10:32:54.730]             if (.Platform$OS.type == "windows") {
[10:32:54.730]                 old_names <- names(...future.oldEnvVars)
[10:32:54.730]                 envs <- base::Sys.getenv()
[10:32:54.730]                 names <- names(envs)
[10:32:54.730]                 common <- intersect(names, old_names)
[10:32:54.730]                 added <- setdiff(names, old_names)
[10:32:54.730]                 removed <- setdiff(old_names, names)
[10:32:54.730]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.730]                   envs[common]]
[10:32:54.730]                 NAMES <- toupper(changed)
[10:32:54.730]                 args <- list()
[10:32:54.730]                 for (kk in seq_along(NAMES)) {
[10:32:54.730]                   name <- changed[[kk]]
[10:32:54.730]                   NAME <- NAMES[[kk]]
[10:32:54.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.730]                     next
[10:32:54.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.730]                 }
[10:32:54.730]                 NAMES <- toupper(added)
[10:32:54.730]                 for (kk in seq_along(NAMES)) {
[10:32:54.730]                   name <- added[[kk]]
[10:32:54.730]                   NAME <- NAMES[[kk]]
[10:32:54.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.730]                     next
[10:32:54.730]                   args[[name]] <- ""
[10:32:54.730]                 }
[10:32:54.730]                 NAMES <- toupper(removed)
[10:32:54.730]                 for (kk in seq_along(NAMES)) {
[10:32:54.730]                   name <- removed[[kk]]
[10:32:54.730]                   NAME <- NAMES[[kk]]
[10:32:54.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.730]                     next
[10:32:54.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.730]                 }
[10:32:54.730]                 if (length(args) > 0) 
[10:32:54.730]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.730]             }
[10:32:54.730]             else {
[10:32:54.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.730]             }
[10:32:54.730]             {
[10:32:54.730]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.730]                   0L) {
[10:32:54.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.730]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.730]                   base::options(opts)
[10:32:54.730]                 }
[10:32:54.730]                 {
[10:32:54.730]                   {
[10:32:54.730]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.730]                     NULL
[10:32:54.730]                   }
[10:32:54.730]                   options(future.plan = NULL)
[10:32:54.730]                   if (is.na(NA_character_)) 
[10:32:54.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.730]                     .init = FALSE)
[10:32:54.730]                 }
[10:32:54.730]             }
[10:32:54.730]         }
[10:32:54.730]     })
[10:32:54.730]     if (TRUE) {
[10:32:54.730]         base::sink(type = "output", split = FALSE)
[10:32:54.730]         if (TRUE) {
[10:32:54.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.730]         }
[10:32:54.730]         else {
[10:32:54.730]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.730]         }
[10:32:54.730]         base::close(...future.stdout)
[10:32:54.730]         ...future.stdout <- NULL
[10:32:54.730]     }
[10:32:54.730]     ...future.result$conditions <- ...future.conditions
[10:32:54.730]     ...future.result$finished <- base::Sys.time()
[10:32:54.730]     ...future.result
[10:32:54.730] }
[10:32:54.734] MultisessionFuture started
[10:32:54.734] - Launch lazy future ... done
[10:32:54.734] run() for ‘MultisessionFuture’ ... done
[10:32:54.734] getGlobalsAndPackages() ...
[10:32:54.734] Searching for globals...
[10:32:54.735] - globals found: [1] ‘{’
[10:32:54.735] Searching for globals ... DONE
[10:32:54.735] Resolving globals: FALSE
[10:32:54.735] 
[10:32:54.736] 
[10:32:54.736] getGlobalsAndPackages() ... DONE
[10:32:54.736] run() for ‘Future’ ...
[10:32:54.736] - state: ‘created’
[10:32:54.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.757] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.758]   - Field: ‘node’
[10:32:54.758]   - Field: ‘label’
[10:32:54.758]   - Field: ‘local’
[10:32:54.758]   - Field: ‘owner’
[10:32:54.758]   - Field: ‘envir’
[10:32:54.758]   - Field: ‘workers’
[10:32:54.758]   - Field: ‘packages’
[10:32:54.758]   - Field: ‘gc’
[10:32:54.758]   - Field: ‘conditions’
[10:32:54.759]   - Field: ‘persistent’
[10:32:54.759]   - Field: ‘expr’
[10:32:54.759]   - Field: ‘uuid’
[10:32:54.759]   - Field: ‘seed’
[10:32:54.759]   - Field: ‘version’
[10:32:54.759]   - Field: ‘result’
[10:32:54.759]   - Field: ‘asynchronous’
[10:32:54.759]   - Field: ‘calls’
[10:32:54.759]   - Field: ‘globals’
[10:32:54.759]   - Field: ‘stdout’
[10:32:54.759]   - Field: ‘earlySignal’
[10:32:54.760]   - Field: ‘lazy’
[10:32:54.760]   - Field: ‘state’
[10:32:54.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.760] - Launch lazy future ...
[10:32:54.760] Packages needed by the future expression (n = 0): <none>
[10:32:54.760] Packages needed by future strategies (n = 0): <none>
[10:32:54.761] {
[10:32:54.761]     {
[10:32:54.761]         {
[10:32:54.761]             ...future.startTime <- base::Sys.time()
[10:32:54.761]             {
[10:32:54.761]                 {
[10:32:54.761]                   {
[10:32:54.761]                     {
[10:32:54.761]                       base::local({
[10:32:54.761]                         has_future <- base::requireNamespace("future", 
[10:32:54.761]                           quietly = TRUE)
[10:32:54.761]                         if (has_future) {
[10:32:54.761]                           ns <- base::getNamespace("future")
[10:32:54.761]                           version <- ns[[".package"]][["version"]]
[10:32:54.761]                           if (is.null(version)) 
[10:32:54.761]                             version <- utils::packageVersion("future")
[10:32:54.761]                         }
[10:32:54.761]                         else {
[10:32:54.761]                           version <- NULL
[10:32:54.761]                         }
[10:32:54.761]                         if (!has_future || version < "1.8.0") {
[10:32:54.761]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.761]                             "", base::R.version$version.string), 
[10:32:54.761]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.761]                               "release", "version")], collapse = " "), 
[10:32:54.761]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.761]                             info)
[10:32:54.761]                           info <- base::paste(info, collapse = "; ")
[10:32:54.761]                           if (!has_future) {
[10:32:54.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.761]                               info)
[10:32:54.761]                           }
[10:32:54.761]                           else {
[10:32:54.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.761]                               info, version)
[10:32:54.761]                           }
[10:32:54.761]                           base::stop(msg)
[10:32:54.761]                         }
[10:32:54.761]                       })
[10:32:54.761]                     }
[10:32:54.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.761]                     base::options(mc.cores = 1L)
[10:32:54.761]                   }
[10:32:54.761]                   ...future.strategy.old <- future::plan("list")
[10:32:54.761]                   options(future.plan = NULL)
[10:32:54.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.761]                 }
[10:32:54.761]                 ...future.workdir <- getwd()
[10:32:54.761]             }
[10:32:54.761]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.761]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.761]         }
[10:32:54.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.761]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.761]             base::names(...future.oldOptions))
[10:32:54.761]     }
[10:32:54.761]     if (FALSE) {
[10:32:54.761]     }
[10:32:54.761]     else {
[10:32:54.761]         if (TRUE) {
[10:32:54.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.761]                 open = "w")
[10:32:54.761]         }
[10:32:54.761]         else {
[10:32:54.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.761]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.761]         }
[10:32:54.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.761]             base::sink(type = "output", split = FALSE)
[10:32:54.761]             base::close(...future.stdout)
[10:32:54.761]         }, add = TRUE)
[10:32:54.761]     }
[10:32:54.761]     ...future.frame <- base::sys.nframe()
[10:32:54.761]     ...future.conditions <- base::list()
[10:32:54.761]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.761]     if (FALSE) {
[10:32:54.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.761]     }
[10:32:54.761]     ...future.result <- base::tryCatch({
[10:32:54.761]         base::withCallingHandlers({
[10:32:54.761]             ...future.value <- base::withVisible(base::local({
[10:32:54.761]                 ...future.makeSendCondition <- base::local({
[10:32:54.761]                   sendCondition <- NULL
[10:32:54.761]                   function(frame = 1L) {
[10:32:54.761]                     if (is.function(sendCondition)) 
[10:32:54.761]                       return(sendCondition)
[10:32:54.761]                     ns <- getNamespace("parallel")
[10:32:54.761]                     if (exists("sendData", mode = "function", 
[10:32:54.761]                       envir = ns)) {
[10:32:54.761]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.761]                         envir = ns)
[10:32:54.761]                       envir <- sys.frame(frame)
[10:32:54.761]                       master <- NULL
[10:32:54.761]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.761]                         !identical(envir, emptyenv())) {
[10:32:54.761]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.761]                           inherits = FALSE)) {
[10:32:54.761]                           master <- get("master", mode = "list", 
[10:32:54.761]                             envir = envir, inherits = FALSE)
[10:32:54.761]                           if (inherits(master, c("SOCKnode", 
[10:32:54.761]                             "SOCK0node"))) {
[10:32:54.761]                             sendCondition <<- function(cond) {
[10:32:54.761]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.761]                                 success = TRUE)
[10:32:54.761]                               parallel_sendData(master, data)
[10:32:54.761]                             }
[10:32:54.761]                             return(sendCondition)
[10:32:54.761]                           }
[10:32:54.761]                         }
[10:32:54.761]                         frame <- frame + 1L
[10:32:54.761]                         envir <- sys.frame(frame)
[10:32:54.761]                       }
[10:32:54.761]                     }
[10:32:54.761]                     sendCondition <<- function(cond) NULL
[10:32:54.761]                   }
[10:32:54.761]                 })
[10:32:54.761]                 withCallingHandlers({
[10:32:54.761]                   {
[10:32:54.761]                     4
[10:32:54.761]                   }
[10:32:54.761]                 }, immediateCondition = function(cond) {
[10:32:54.761]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.761]                   sendCondition(cond)
[10:32:54.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.761]                   {
[10:32:54.761]                     inherits <- base::inherits
[10:32:54.761]                     invokeRestart <- base::invokeRestart
[10:32:54.761]                     is.null <- base::is.null
[10:32:54.761]                     muffled <- FALSE
[10:32:54.761]                     if (inherits(cond, "message")) {
[10:32:54.761]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.761]                       if (muffled) 
[10:32:54.761]                         invokeRestart("muffleMessage")
[10:32:54.761]                     }
[10:32:54.761]                     else if (inherits(cond, "warning")) {
[10:32:54.761]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.761]                       if (muffled) 
[10:32:54.761]                         invokeRestart("muffleWarning")
[10:32:54.761]                     }
[10:32:54.761]                     else if (inherits(cond, "condition")) {
[10:32:54.761]                       if (!is.null(pattern)) {
[10:32:54.761]                         computeRestarts <- base::computeRestarts
[10:32:54.761]                         grepl <- base::grepl
[10:32:54.761]                         restarts <- computeRestarts(cond)
[10:32:54.761]                         for (restart in restarts) {
[10:32:54.761]                           name <- restart$name
[10:32:54.761]                           if (is.null(name)) 
[10:32:54.761]                             next
[10:32:54.761]                           if (!grepl(pattern, name)) 
[10:32:54.761]                             next
[10:32:54.761]                           invokeRestart(restart)
[10:32:54.761]                           muffled <- TRUE
[10:32:54.761]                           break
[10:32:54.761]                         }
[10:32:54.761]                       }
[10:32:54.761]                     }
[10:32:54.761]                     invisible(muffled)
[10:32:54.761]                   }
[10:32:54.761]                   muffleCondition(cond)
[10:32:54.761]                 })
[10:32:54.761]             }))
[10:32:54.761]             future::FutureResult(value = ...future.value$value, 
[10:32:54.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.761]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.761]                     ...future.globalenv.names))
[10:32:54.761]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.761]         }, condition = base::local({
[10:32:54.761]             c <- base::c
[10:32:54.761]             inherits <- base::inherits
[10:32:54.761]             invokeRestart <- base::invokeRestart
[10:32:54.761]             length <- base::length
[10:32:54.761]             list <- base::list
[10:32:54.761]             seq.int <- base::seq.int
[10:32:54.761]             signalCondition <- base::signalCondition
[10:32:54.761]             sys.calls <- base::sys.calls
[10:32:54.761]             `[[` <- base::`[[`
[10:32:54.761]             `+` <- base::`+`
[10:32:54.761]             `<<-` <- base::`<<-`
[10:32:54.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.761]                   3L)]
[10:32:54.761]             }
[10:32:54.761]             function(cond) {
[10:32:54.761]                 is_error <- inherits(cond, "error")
[10:32:54.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.761]                   NULL)
[10:32:54.761]                 if (is_error) {
[10:32:54.761]                   sessionInformation <- function() {
[10:32:54.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.761]                       search = base::search(), system = base::Sys.info())
[10:32:54.761]                   }
[10:32:54.761]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.761]                     cond$call), session = sessionInformation(), 
[10:32:54.761]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.761]                   signalCondition(cond)
[10:32:54.761]                 }
[10:32:54.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.761]                 "immediateCondition"))) {
[10:32:54.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.761]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.761]                   if (TRUE && !signal) {
[10:32:54.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.761]                     {
[10:32:54.761]                       inherits <- base::inherits
[10:32:54.761]                       invokeRestart <- base::invokeRestart
[10:32:54.761]                       is.null <- base::is.null
[10:32:54.761]                       muffled <- FALSE
[10:32:54.761]                       if (inherits(cond, "message")) {
[10:32:54.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.761]                         if (muffled) 
[10:32:54.761]                           invokeRestart("muffleMessage")
[10:32:54.761]                       }
[10:32:54.761]                       else if (inherits(cond, "warning")) {
[10:32:54.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.761]                         if (muffled) 
[10:32:54.761]                           invokeRestart("muffleWarning")
[10:32:54.761]                       }
[10:32:54.761]                       else if (inherits(cond, "condition")) {
[10:32:54.761]                         if (!is.null(pattern)) {
[10:32:54.761]                           computeRestarts <- base::computeRestarts
[10:32:54.761]                           grepl <- base::grepl
[10:32:54.761]                           restarts <- computeRestarts(cond)
[10:32:54.761]                           for (restart in restarts) {
[10:32:54.761]                             name <- restart$name
[10:32:54.761]                             if (is.null(name)) 
[10:32:54.761]                               next
[10:32:54.761]                             if (!grepl(pattern, name)) 
[10:32:54.761]                               next
[10:32:54.761]                             invokeRestart(restart)
[10:32:54.761]                             muffled <- TRUE
[10:32:54.761]                             break
[10:32:54.761]                           }
[10:32:54.761]                         }
[10:32:54.761]                       }
[10:32:54.761]                       invisible(muffled)
[10:32:54.761]                     }
[10:32:54.761]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.761]                   }
[10:32:54.761]                 }
[10:32:54.761]                 else {
[10:32:54.761]                   if (TRUE) {
[10:32:54.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.761]                     {
[10:32:54.761]                       inherits <- base::inherits
[10:32:54.761]                       invokeRestart <- base::invokeRestart
[10:32:54.761]                       is.null <- base::is.null
[10:32:54.761]                       muffled <- FALSE
[10:32:54.761]                       if (inherits(cond, "message")) {
[10:32:54.761]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.761]                         if (muffled) 
[10:32:54.761]                           invokeRestart("muffleMessage")
[10:32:54.761]                       }
[10:32:54.761]                       else if (inherits(cond, "warning")) {
[10:32:54.761]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.761]                         if (muffled) 
[10:32:54.761]                           invokeRestart("muffleWarning")
[10:32:54.761]                       }
[10:32:54.761]                       else if (inherits(cond, "condition")) {
[10:32:54.761]                         if (!is.null(pattern)) {
[10:32:54.761]                           computeRestarts <- base::computeRestarts
[10:32:54.761]                           grepl <- base::grepl
[10:32:54.761]                           restarts <- computeRestarts(cond)
[10:32:54.761]                           for (restart in restarts) {
[10:32:54.761]                             name <- restart$name
[10:32:54.761]                             if (is.null(name)) 
[10:32:54.761]                               next
[10:32:54.761]                             if (!grepl(pattern, name)) 
[10:32:54.761]                               next
[10:32:54.761]                             invokeRestart(restart)
[10:32:54.761]                             muffled <- TRUE
[10:32:54.761]                             break
[10:32:54.761]                           }
[10:32:54.761]                         }
[10:32:54.761]                       }
[10:32:54.761]                       invisible(muffled)
[10:32:54.761]                     }
[10:32:54.761]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.761]                   }
[10:32:54.761]                 }
[10:32:54.761]             }
[10:32:54.761]         }))
[10:32:54.761]     }, error = function(ex) {
[10:32:54.761]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.761]                 ...future.rng), started = ...future.startTime, 
[10:32:54.761]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.761]             version = "1.8"), class = "FutureResult")
[10:32:54.761]     }, finally = {
[10:32:54.761]         if (!identical(...future.workdir, getwd())) 
[10:32:54.761]             setwd(...future.workdir)
[10:32:54.761]         {
[10:32:54.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.761]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.761]             }
[10:32:54.761]             base::options(...future.oldOptions)
[10:32:54.761]             if (.Platform$OS.type == "windows") {
[10:32:54.761]                 old_names <- names(...future.oldEnvVars)
[10:32:54.761]                 envs <- base::Sys.getenv()
[10:32:54.761]                 names <- names(envs)
[10:32:54.761]                 common <- intersect(names, old_names)
[10:32:54.761]                 added <- setdiff(names, old_names)
[10:32:54.761]                 removed <- setdiff(old_names, names)
[10:32:54.761]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.761]                   envs[common]]
[10:32:54.761]                 NAMES <- toupper(changed)
[10:32:54.761]                 args <- list()
[10:32:54.761]                 for (kk in seq_along(NAMES)) {
[10:32:54.761]                   name <- changed[[kk]]
[10:32:54.761]                   NAME <- NAMES[[kk]]
[10:32:54.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.761]                     next
[10:32:54.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.761]                 }
[10:32:54.761]                 NAMES <- toupper(added)
[10:32:54.761]                 for (kk in seq_along(NAMES)) {
[10:32:54.761]                   name <- added[[kk]]
[10:32:54.761]                   NAME <- NAMES[[kk]]
[10:32:54.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.761]                     next
[10:32:54.761]                   args[[name]] <- ""
[10:32:54.761]                 }
[10:32:54.761]                 NAMES <- toupper(removed)
[10:32:54.761]                 for (kk in seq_along(NAMES)) {
[10:32:54.761]                   name <- removed[[kk]]
[10:32:54.761]                   NAME <- NAMES[[kk]]
[10:32:54.761]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.761]                     next
[10:32:54.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.761]                 }
[10:32:54.761]                 if (length(args) > 0) 
[10:32:54.761]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.761]             }
[10:32:54.761]             else {
[10:32:54.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.761]             }
[10:32:54.761]             {
[10:32:54.761]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.761]                   0L) {
[10:32:54.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.761]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.761]                   base::options(opts)
[10:32:54.761]                 }
[10:32:54.761]                 {
[10:32:54.761]                   {
[10:32:54.761]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.761]                     NULL
[10:32:54.761]                   }
[10:32:54.761]                   options(future.plan = NULL)
[10:32:54.761]                   if (is.na(NA_character_)) 
[10:32:54.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.761]                     .init = FALSE)
[10:32:54.761]                 }
[10:32:54.761]             }
[10:32:54.761]         }
[10:32:54.761]     })
[10:32:54.761]     if (TRUE) {
[10:32:54.761]         base::sink(type = "output", split = FALSE)
[10:32:54.761]         if (TRUE) {
[10:32:54.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.761]         }
[10:32:54.761]         else {
[10:32:54.761]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.761]         }
[10:32:54.761]         base::close(...future.stdout)
[10:32:54.761]         ...future.stdout <- NULL
[10:32:54.761]     }
[10:32:54.761]     ...future.result$conditions <- ...future.conditions
[10:32:54.761]     ...future.result$finished <- base::Sys.time()
[10:32:54.761]     ...future.result
[10:32:54.761] }
[10:32:54.763] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:54.773] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.774] - Validating connection of MultisessionFuture
[10:32:54.774] - received message: FutureResult
[10:32:54.774] - Received FutureResult
[10:32:54.774] - Erased future from FutureRegistry
[10:32:54.774] result() for ClusterFuture ...
[10:32:54.774] - result already collected: FutureResult
[10:32:54.774] result() for ClusterFuture ... done
[10:32:54.774] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.775] result() for ClusterFuture ...
[10:32:54.775] - result already collected: FutureResult
[10:32:54.775] result() for ClusterFuture ... done
[10:32:54.775] result() for ClusterFuture ...
[10:32:54.775] - result already collected: FutureResult
[10:32:54.775] result() for ClusterFuture ... done
[10:32:54.776] MultisessionFuture started
[10:32:54.776] - Launch lazy future ... done
[10:32:54.776] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d244e050> 
Classes 'listenv', 'environment' <environment: 0x5652d1154a98> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:32:54.781] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.781] - Validating connection of MultisessionFuture
[10:32:54.781] - received message: FutureResult
[10:32:54.781] - Received FutureResult
[10:32:54.782] - Erased future from FutureRegistry
[10:32:54.782] result() for ClusterFuture ...
[10:32:54.782] - result already collected: FutureResult
[10:32:54.782] result() for ClusterFuture ... done
[10:32:54.782] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.782] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.782] - Validating connection of MultisessionFuture
[10:32:54.783] - received message: FutureResult
[10:32:54.783] - Received FutureResult
[10:32:54.783] - Erased future from FutureRegistry
[10:32:54.783] result() for ClusterFuture ...
[10:32:54.783] - result already collected: FutureResult
[10:32:54.783] result() for ClusterFuture ... done
[10:32:54.783] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:54.785] resolve() on list environment ...
[10:32:54.786]  recursive: 0
[10:32:54.786]  length: 6
[10:32:54.786]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:54.787] signalConditionsASAP(numeric, pos=1) ...
[10:32:54.787] - nx: 6
[10:32:54.787] - relay: TRUE
[10:32:54.787] - stdout: TRUE
[10:32:54.787] - signal: TRUE
[10:32:54.787] - resignal: FALSE
[10:32:54.787] - force: TRUE
[10:32:54.787] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.787] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.787]  - until=2
[10:32:54.788]  - relaying element #2
[10:32:54.788] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.788] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.788] signalConditionsASAP(NULL, pos=1) ... done
[10:32:54.788]  length: 5 (resolved future 1)
[10:32:54.788] Future #2
[10:32:54.788] result() for ClusterFuture ...
[10:32:54.788] - result already collected: FutureResult
[10:32:54.788] result() for ClusterFuture ... done
[10:32:54.788] result() for ClusterFuture ...
[10:32:54.788] - result already collected: FutureResult
[10:32:54.789] result() for ClusterFuture ... done
[10:32:54.789] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:54.789] - nx: 6
[10:32:54.789] - relay: TRUE
[10:32:54.789] - stdout: TRUE
[10:32:54.789] - signal: TRUE
[10:32:54.789] - resignal: FALSE
[10:32:54.789] - force: TRUE
[10:32:54.789] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.789] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.789]  - until=2
[10:32:54.790]  - relaying element #2
[10:32:54.790] result() for ClusterFuture ...
[10:32:54.790] - result already collected: FutureResult
[10:32:54.790] result() for ClusterFuture ... done
[10:32:54.790] result() for ClusterFuture ...
[10:32:54.790] - result already collected: FutureResult
[10:32:54.790] result() for ClusterFuture ... done
[10:32:54.790] result() for ClusterFuture ...
[10:32:54.790] - result already collected: FutureResult
[10:32:54.790] result() for ClusterFuture ... done
[10:32:54.790] result() for ClusterFuture ...
[10:32:54.791] - result already collected: FutureResult
[10:32:54.791] result() for ClusterFuture ... done
[10:32:54.791] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.791] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.791] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:54.791]  length: 4 (resolved future 2)
[10:32:54.791] Future #3
[10:32:54.791] result() for ClusterFuture ...
[10:32:54.791] - result already collected: FutureResult
[10:32:54.791] result() for ClusterFuture ... done
[10:32:54.791] result() for ClusterFuture ...
[10:32:54.792] - result already collected: FutureResult
[10:32:54.792] result() for ClusterFuture ... done
[10:32:54.792] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:54.792] - nx: 6
[10:32:54.792] - relay: TRUE
[10:32:54.792] - stdout: TRUE
[10:32:54.792] - signal: TRUE
[10:32:54.792] - resignal: FALSE
[10:32:54.792] - force: TRUE
[10:32:54.792] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.792] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.793]  - until=3
[10:32:54.793]  - relaying element #3
[10:32:54.793] result() for ClusterFuture ...
[10:32:54.793] - result already collected: FutureResult
[10:32:54.793] result() for ClusterFuture ... done
[10:32:54.793] result() for ClusterFuture ...
[10:32:54.793] - result already collected: FutureResult
[10:32:54.793] result() for ClusterFuture ... done
[10:32:54.793] result() for ClusterFuture ...
[10:32:54.793] - result already collected: FutureResult
[10:32:54.793] result() for ClusterFuture ... done
[10:32:54.794] result() for ClusterFuture ...
[10:32:54.794] - result already collected: FutureResult
[10:32:54.794] result() for ClusterFuture ... done
[10:32:54.794] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.794] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.794] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:54.794]  length: 3 (resolved future 3)
[10:32:54.794] Future #4
[10:32:54.794] result() for ClusterFuture ...
[10:32:54.794] - result already collected: FutureResult
[10:32:54.795] result() for ClusterFuture ... done
[10:32:54.795] result() for ClusterFuture ...
[10:32:54.795] - result already collected: FutureResult
[10:32:54.795] result() for ClusterFuture ... done
[10:32:54.795] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:54.795] - nx: 6
[10:32:54.795] - relay: TRUE
[10:32:54.795] - stdout: TRUE
[10:32:54.795] - signal: TRUE
[10:32:54.795] - resignal: FALSE
[10:32:54.795] - force: TRUE
[10:32:54.795] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.796] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.796]  - until=4
[10:32:54.796]  - relaying element #4
[10:32:54.796] result() for ClusterFuture ...
[10:32:54.796] - result already collected: FutureResult
[10:32:54.796] result() for ClusterFuture ... done
[10:32:54.796] result() for ClusterFuture ...
[10:32:54.796] - result already collected: FutureResult
[10:32:54.796] result() for ClusterFuture ... done
[10:32:54.796] result() for ClusterFuture ...
[10:32:54.796] - result already collected: FutureResult
[10:32:54.797] result() for ClusterFuture ... done
[10:32:54.797] result() for ClusterFuture ...
[10:32:54.797] - result already collected: FutureResult
[10:32:54.797] result() for ClusterFuture ... done
[10:32:54.797] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.797] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.797] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:54.797]  length: 2 (resolved future 4)
[10:32:54.797] signalConditionsASAP(NULL, pos=5) ...
[10:32:54.797] - nx: 6
[10:32:54.798] - relay: TRUE
[10:32:54.798] - stdout: TRUE
[10:32:54.798] - signal: TRUE
[10:32:54.798] - resignal: FALSE
[10:32:54.798] - force: TRUE
[10:32:54.798] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.798] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.798]  - until=6
[10:32:54.798]  - relaying element #6
[10:32:54.798] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.798] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.798] signalConditionsASAP(NULL, pos=5) ... done
[10:32:54.799]  length: 1 (resolved future 5)
[10:32:54.799] signalConditionsASAP(numeric, pos=6) ...
[10:32:54.799] - nx: 6
[10:32:54.799] - relay: TRUE
[10:32:54.799] - stdout: TRUE
[10:32:54.799] - signal: TRUE
[10:32:54.799] - resignal: FALSE
[10:32:54.799] - force: TRUE
[10:32:54.799] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.799] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.799]  - until=6
[10:32:54.799] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.800] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.800] signalConditionsASAP(numeric, pos=6) ... done
[10:32:54.800]  length: 0 (resolved future 6)
[10:32:54.800] Relaying remaining futures
[10:32:54.800] signalConditionsASAP(NULL, pos=0) ...
[10:32:54.800] - nx: 6
[10:32:54.800] - relay: TRUE
[10:32:54.800] - stdout: TRUE
[10:32:54.800] - signal: TRUE
[10:32:54.800] - resignal: FALSE
[10:32:54.800] - force: TRUE
[10:32:54.800] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.801] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:54.801] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.801] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.801] signalConditionsASAP(NULL, pos=0) ... done
[10:32:54.801] resolve() on list environment ... DONE
[10:32:54.801] result() for ClusterFuture ...
[10:32:54.801] - result already collected: FutureResult
[10:32:54.801] result() for ClusterFuture ... done
[10:32:54.801] result() for ClusterFuture ...
[10:32:54.801] - result already collected: FutureResult
[10:32:54.802] result() for ClusterFuture ... done
[10:32:54.802] result() for ClusterFuture ...
[10:32:54.802] - result already collected: FutureResult
[10:32:54.802] result() for ClusterFuture ... done
[10:32:54.802] result() for ClusterFuture ...
[10:32:54.802] - result already collected: FutureResult
[10:32:54.802] result() for ClusterFuture ... done
[10:32:54.802] result() for ClusterFuture ...
[10:32:54.802] - result already collected: FutureResult
[10:32:54.803] result() for ClusterFuture ... done
[10:32:54.803] result() for ClusterFuture ...
[10:32:54.803] - result already collected: FutureResult
[10:32:54.803] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d0c6d798> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:32:54.804] getGlobalsAndPackages() ...
[10:32:54.804] Searching for globals...
[10:32:54.805] 
[10:32:54.805] Searching for globals ... DONE
[10:32:54.805] - globals: [0] <none>
[10:32:54.805] getGlobalsAndPackages() ... DONE
[10:32:54.805] run() for ‘Future’ ...
[10:32:54.805] - state: ‘created’
[10:32:54.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.820]   - Field: ‘node’
[10:32:54.820]   - Field: ‘label’
[10:32:54.820]   - Field: ‘local’
[10:32:54.820]   - Field: ‘owner’
[10:32:54.820]   - Field: ‘envir’
[10:32:54.820]   - Field: ‘workers’
[10:32:54.820]   - Field: ‘packages’
[10:32:54.821]   - Field: ‘gc’
[10:32:54.821]   - Field: ‘conditions’
[10:32:54.821]   - Field: ‘persistent’
[10:32:54.821]   - Field: ‘expr’
[10:32:54.821]   - Field: ‘uuid’
[10:32:54.821]   - Field: ‘seed’
[10:32:54.821]   - Field: ‘version’
[10:32:54.821]   - Field: ‘result’
[10:32:54.821]   - Field: ‘asynchronous’
[10:32:54.821]   - Field: ‘calls’
[10:32:54.822]   - Field: ‘globals’
[10:32:54.822]   - Field: ‘stdout’
[10:32:54.822]   - Field: ‘earlySignal’
[10:32:54.822]   - Field: ‘lazy’
[10:32:54.822]   - Field: ‘state’
[10:32:54.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.822] - Launch lazy future ...
[10:32:54.822] Packages needed by the future expression (n = 0): <none>
[10:32:54.822] Packages needed by future strategies (n = 0): <none>
[10:32:54.823] {
[10:32:54.823]     {
[10:32:54.823]         {
[10:32:54.823]             ...future.startTime <- base::Sys.time()
[10:32:54.823]             {
[10:32:54.823]                 {
[10:32:54.823]                   {
[10:32:54.823]                     {
[10:32:54.823]                       base::local({
[10:32:54.823]                         has_future <- base::requireNamespace("future", 
[10:32:54.823]                           quietly = TRUE)
[10:32:54.823]                         if (has_future) {
[10:32:54.823]                           ns <- base::getNamespace("future")
[10:32:54.823]                           version <- ns[[".package"]][["version"]]
[10:32:54.823]                           if (is.null(version)) 
[10:32:54.823]                             version <- utils::packageVersion("future")
[10:32:54.823]                         }
[10:32:54.823]                         else {
[10:32:54.823]                           version <- NULL
[10:32:54.823]                         }
[10:32:54.823]                         if (!has_future || version < "1.8.0") {
[10:32:54.823]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.823]                             "", base::R.version$version.string), 
[10:32:54.823]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.823]                               "release", "version")], collapse = " "), 
[10:32:54.823]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.823]                             info)
[10:32:54.823]                           info <- base::paste(info, collapse = "; ")
[10:32:54.823]                           if (!has_future) {
[10:32:54.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.823]                               info)
[10:32:54.823]                           }
[10:32:54.823]                           else {
[10:32:54.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.823]                               info, version)
[10:32:54.823]                           }
[10:32:54.823]                           base::stop(msg)
[10:32:54.823]                         }
[10:32:54.823]                       })
[10:32:54.823]                     }
[10:32:54.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.823]                     base::options(mc.cores = 1L)
[10:32:54.823]                   }
[10:32:54.823]                   ...future.strategy.old <- future::plan("list")
[10:32:54.823]                   options(future.plan = NULL)
[10:32:54.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.823]                 }
[10:32:54.823]                 ...future.workdir <- getwd()
[10:32:54.823]             }
[10:32:54.823]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.823]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.823]         }
[10:32:54.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.823]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.823]             base::names(...future.oldOptions))
[10:32:54.823]     }
[10:32:54.823]     if (FALSE) {
[10:32:54.823]     }
[10:32:54.823]     else {
[10:32:54.823]         if (TRUE) {
[10:32:54.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.823]                 open = "w")
[10:32:54.823]         }
[10:32:54.823]         else {
[10:32:54.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.823]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.823]         }
[10:32:54.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.823]             base::sink(type = "output", split = FALSE)
[10:32:54.823]             base::close(...future.stdout)
[10:32:54.823]         }, add = TRUE)
[10:32:54.823]     }
[10:32:54.823]     ...future.frame <- base::sys.nframe()
[10:32:54.823]     ...future.conditions <- base::list()
[10:32:54.823]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.823]     if (FALSE) {
[10:32:54.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.823]     }
[10:32:54.823]     ...future.result <- base::tryCatch({
[10:32:54.823]         base::withCallingHandlers({
[10:32:54.823]             ...future.value <- base::withVisible(base::local({
[10:32:54.823]                 ...future.makeSendCondition <- base::local({
[10:32:54.823]                   sendCondition <- NULL
[10:32:54.823]                   function(frame = 1L) {
[10:32:54.823]                     if (is.function(sendCondition)) 
[10:32:54.823]                       return(sendCondition)
[10:32:54.823]                     ns <- getNamespace("parallel")
[10:32:54.823]                     if (exists("sendData", mode = "function", 
[10:32:54.823]                       envir = ns)) {
[10:32:54.823]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.823]                         envir = ns)
[10:32:54.823]                       envir <- sys.frame(frame)
[10:32:54.823]                       master <- NULL
[10:32:54.823]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.823]                         !identical(envir, emptyenv())) {
[10:32:54.823]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.823]                           inherits = FALSE)) {
[10:32:54.823]                           master <- get("master", mode = "list", 
[10:32:54.823]                             envir = envir, inherits = FALSE)
[10:32:54.823]                           if (inherits(master, c("SOCKnode", 
[10:32:54.823]                             "SOCK0node"))) {
[10:32:54.823]                             sendCondition <<- function(cond) {
[10:32:54.823]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.823]                                 success = TRUE)
[10:32:54.823]                               parallel_sendData(master, data)
[10:32:54.823]                             }
[10:32:54.823]                             return(sendCondition)
[10:32:54.823]                           }
[10:32:54.823]                         }
[10:32:54.823]                         frame <- frame + 1L
[10:32:54.823]                         envir <- sys.frame(frame)
[10:32:54.823]                       }
[10:32:54.823]                     }
[10:32:54.823]                     sendCondition <<- function(cond) NULL
[10:32:54.823]                   }
[10:32:54.823]                 })
[10:32:54.823]                 withCallingHandlers({
[10:32:54.823]                   2
[10:32:54.823]                 }, immediateCondition = function(cond) {
[10:32:54.823]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.823]                   sendCondition(cond)
[10:32:54.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.823]                   {
[10:32:54.823]                     inherits <- base::inherits
[10:32:54.823]                     invokeRestart <- base::invokeRestart
[10:32:54.823]                     is.null <- base::is.null
[10:32:54.823]                     muffled <- FALSE
[10:32:54.823]                     if (inherits(cond, "message")) {
[10:32:54.823]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.823]                       if (muffled) 
[10:32:54.823]                         invokeRestart("muffleMessage")
[10:32:54.823]                     }
[10:32:54.823]                     else if (inherits(cond, "warning")) {
[10:32:54.823]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.823]                       if (muffled) 
[10:32:54.823]                         invokeRestart("muffleWarning")
[10:32:54.823]                     }
[10:32:54.823]                     else if (inherits(cond, "condition")) {
[10:32:54.823]                       if (!is.null(pattern)) {
[10:32:54.823]                         computeRestarts <- base::computeRestarts
[10:32:54.823]                         grepl <- base::grepl
[10:32:54.823]                         restarts <- computeRestarts(cond)
[10:32:54.823]                         for (restart in restarts) {
[10:32:54.823]                           name <- restart$name
[10:32:54.823]                           if (is.null(name)) 
[10:32:54.823]                             next
[10:32:54.823]                           if (!grepl(pattern, name)) 
[10:32:54.823]                             next
[10:32:54.823]                           invokeRestart(restart)
[10:32:54.823]                           muffled <- TRUE
[10:32:54.823]                           break
[10:32:54.823]                         }
[10:32:54.823]                       }
[10:32:54.823]                     }
[10:32:54.823]                     invisible(muffled)
[10:32:54.823]                   }
[10:32:54.823]                   muffleCondition(cond)
[10:32:54.823]                 })
[10:32:54.823]             }))
[10:32:54.823]             future::FutureResult(value = ...future.value$value, 
[10:32:54.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.823]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.823]                     ...future.globalenv.names))
[10:32:54.823]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.823]         }, condition = base::local({
[10:32:54.823]             c <- base::c
[10:32:54.823]             inherits <- base::inherits
[10:32:54.823]             invokeRestart <- base::invokeRestart
[10:32:54.823]             length <- base::length
[10:32:54.823]             list <- base::list
[10:32:54.823]             seq.int <- base::seq.int
[10:32:54.823]             signalCondition <- base::signalCondition
[10:32:54.823]             sys.calls <- base::sys.calls
[10:32:54.823]             `[[` <- base::`[[`
[10:32:54.823]             `+` <- base::`+`
[10:32:54.823]             `<<-` <- base::`<<-`
[10:32:54.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.823]                   3L)]
[10:32:54.823]             }
[10:32:54.823]             function(cond) {
[10:32:54.823]                 is_error <- inherits(cond, "error")
[10:32:54.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.823]                   NULL)
[10:32:54.823]                 if (is_error) {
[10:32:54.823]                   sessionInformation <- function() {
[10:32:54.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.823]                       search = base::search(), system = base::Sys.info())
[10:32:54.823]                   }
[10:32:54.823]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.823]                     cond$call), session = sessionInformation(), 
[10:32:54.823]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.823]                   signalCondition(cond)
[10:32:54.823]                 }
[10:32:54.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.823]                 "immediateCondition"))) {
[10:32:54.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.823]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.823]                   if (TRUE && !signal) {
[10:32:54.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.823]                     {
[10:32:54.823]                       inherits <- base::inherits
[10:32:54.823]                       invokeRestart <- base::invokeRestart
[10:32:54.823]                       is.null <- base::is.null
[10:32:54.823]                       muffled <- FALSE
[10:32:54.823]                       if (inherits(cond, "message")) {
[10:32:54.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.823]                         if (muffled) 
[10:32:54.823]                           invokeRestart("muffleMessage")
[10:32:54.823]                       }
[10:32:54.823]                       else if (inherits(cond, "warning")) {
[10:32:54.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.823]                         if (muffled) 
[10:32:54.823]                           invokeRestart("muffleWarning")
[10:32:54.823]                       }
[10:32:54.823]                       else if (inherits(cond, "condition")) {
[10:32:54.823]                         if (!is.null(pattern)) {
[10:32:54.823]                           computeRestarts <- base::computeRestarts
[10:32:54.823]                           grepl <- base::grepl
[10:32:54.823]                           restarts <- computeRestarts(cond)
[10:32:54.823]                           for (restart in restarts) {
[10:32:54.823]                             name <- restart$name
[10:32:54.823]                             if (is.null(name)) 
[10:32:54.823]                               next
[10:32:54.823]                             if (!grepl(pattern, name)) 
[10:32:54.823]                               next
[10:32:54.823]                             invokeRestart(restart)
[10:32:54.823]                             muffled <- TRUE
[10:32:54.823]                             break
[10:32:54.823]                           }
[10:32:54.823]                         }
[10:32:54.823]                       }
[10:32:54.823]                       invisible(muffled)
[10:32:54.823]                     }
[10:32:54.823]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.823]                   }
[10:32:54.823]                 }
[10:32:54.823]                 else {
[10:32:54.823]                   if (TRUE) {
[10:32:54.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.823]                     {
[10:32:54.823]                       inherits <- base::inherits
[10:32:54.823]                       invokeRestart <- base::invokeRestart
[10:32:54.823]                       is.null <- base::is.null
[10:32:54.823]                       muffled <- FALSE
[10:32:54.823]                       if (inherits(cond, "message")) {
[10:32:54.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.823]                         if (muffled) 
[10:32:54.823]                           invokeRestart("muffleMessage")
[10:32:54.823]                       }
[10:32:54.823]                       else if (inherits(cond, "warning")) {
[10:32:54.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.823]                         if (muffled) 
[10:32:54.823]                           invokeRestart("muffleWarning")
[10:32:54.823]                       }
[10:32:54.823]                       else if (inherits(cond, "condition")) {
[10:32:54.823]                         if (!is.null(pattern)) {
[10:32:54.823]                           computeRestarts <- base::computeRestarts
[10:32:54.823]                           grepl <- base::grepl
[10:32:54.823]                           restarts <- computeRestarts(cond)
[10:32:54.823]                           for (restart in restarts) {
[10:32:54.823]                             name <- restart$name
[10:32:54.823]                             if (is.null(name)) 
[10:32:54.823]                               next
[10:32:54.823]                             if (!grepl(pattern, name)) 
[10:32:54.823]                               next
[10:32:54.823]                             invokeRestart(restart)
[10:32:54.823]                             muffled <- TRUE
[10:32:54.823]                             break
[10:32:54.823]                           }
[10:32:54.823]                         }
[10:32:54.823]                       }
[10:32:54.823]                       invisible(muffled)
[10:32:54.823]                     }
[10:32:54.823]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.823]                   }
[10:32:54.823]                 }
[10:32:54.823]             }
[10:32:54.823]         }))
[10:32:54.823]     }, error = function(ex) {
[10:32:54.823]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.823]                 ...future.rng), started = ...future.startTime, 
[10:32:54.823]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.823]             version = "1.8"), class = "FutureResult")
[10:32:54.823]     }, finally = {
[10:32:54.823]         if (!identical(...future.workdir, getwd())) 
[10:32:54.823]             setwd(...future.workdir)
[10:32:54.823]         {
[10:32:54.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.823]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.823]             }
[10:32:54.823]             base::options(...future.oldOptions)
[10:32:54.823]             if (.Platform$OS.type == "windows") {
[10:32:54.823]                 old_names <- names(...future.oldEnvVars)
[10:32:54.823]                 envs <- base::Sys.getenv()
[10:32:54.823]                 names <- names(envs)
[10:32:54.823]                 common <- intersect(names, old_names)
[10:32:54.823]                 added <- setdiff(names, old_names)
[10:32:54.823]                 removed <- setdiff(old_names, names)
[10:32:54.823]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.823]                   envs[common]]
[10:32:54.823]                 NAMES <- toupper(changed)
[10:32:54.823]                 args <- list()
[10:32:54.823]                 for (kk in seq_along(NAMES)) {
[10:32:54.823]                   name <- changed[[kk]]
[10:32:54.823]                   NAME <- NAMES[[kk]]
[10:32:54.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.823]                     next
[10:32:54.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.823]                 }
[10:32:54.823]                 NAMES <- toupper(added)
[10:32:54.823]                 for (kk in seq_along(NAMES)) {
[10:32:54.823]                   name <- added[[kk]]
[10:32:54.823]                   NAME <- NAMES[[kk]]
[10:32:54.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.823]                     next
[10:32:54.823]                   args[[name]] <- ""
[10:32:54.823]                 }
[10:32:54.823]                 NAMES <- toupper(removed)
[10:32:54.823]                 for (kk in seq_along(NAMES)) {
[10:32:54.823]                   name <- removed[[kk]]
[10:32:54.823]                   NAME <- NAMES[[kk]]
[10:32:54.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.823]                     next
[10:32:54.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.823]                 }
[10:32:54.823]                 if (length(args) > 0) 
[10:32:54.823]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.823]             }
[10:32:54.823]             else {
[10:32:54.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.823]             }
[10:32:54.823]             {
[10:32:54.823]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.823]                   0L) {
[10:32:54.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.823]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.823]                   base::options(opts)
[10:32:54.823]                 }
[10:32:54.823]                 {
[10:32:54.823]                   {
[10:32:54.823]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.823]                     NULL
[10:32:54.823]                   }
[10:32:54.823]                   options(future.plan = NULL)
[10:32:54.823]                   if (is.na(NA_character_)) 
[10:32:54.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.823]                     .init = FALSE)
[10:32:54.823]                 }
[10:32:54.823]             }
[10:32:54.823]         }
[10:32:54.823]     })
[10:32:54.823]     if (TRUE) {
[10:32:54.823]         base::sink(type = "output", split = FALSE)
[10:32:54.823]         if (TRUE) {
[10:32:54.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.823]         }
[10:32:54.823]         else {
[10:32:54.823]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.823]         }
[10:32:54.823]         base::close(...future.stdout)
[10:32:54.823]         ...future.stdout <- NULL
[10:32:54.823]     }
[10:32:54.823]     ...future.result$conditions <- ...future.conditions
[10:32:54.823]     ...future.result$finished <- base::Sys.time()
[10:32:54.823]     ...future.result
[10:32:54.823] }
[10:32:54.826] MultisessionFuture started
[10:32:54.826] - Launch lazy future ... done
[10:32:54.826] run() for ‘MultisessionFuture’ ... done
[10:32:54.826] getGlobalsAndPackages() ...
[10:32:54.827] Searching for globals...
[10:32:54.827] 
[10:32:54.827] Searching for globals ... DONE
[10:32:54.827] - globals: [0] <none>
[10:32:54.827] getGlobalsAndPackages() ... DONE
[10:32:54.828] run() for ‘Future’ ...
[10:32:54.828] - state: ‘created’
[10:32:54.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.842] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.842]   - Field: ‘node’
[10:32:54.842]   - Field: ‘label’
[10:32:54.842]   - Field: ‘local’
[10:32:54.842]   - Field: ‘owner’
[10:32:54.842]   - Field: ‘envir’
[10:32:54.843]   - Field: ‘workers’
[10:32:54.843]   - Field: ‘packages’
[10:32:54.843]   - Field: ‘gc’
[10:32:54.843]   - Field: ‘conditions’
[10:32:54.843]   - Field: ‘persistent’
[10:32:54.843]   - Field: ‘expr’
[10:32:54.843]   - Field: ‘uuid’
[10:32:54.843]   - Field: ‘seed’
[10:32:54.843]   - Field: ‘version’
[10:32:54.843]   - Field: ‘result’
[10:32:54.843]   - Field: ‘asynchronous’
[10:32:54.844]   - Field: ‘calls’
[10:32:54.844]   - Field: ‘globals’
[10:32:54.844]   - Field: ‘stdout’
[10:32:54.844]   - Field: ‘earlySignal’
[10:32:54.844]   - Field: ‘lazy’
[10:32:54.844]   - Field: ‘state’
[10:32:54.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.844] - Launch lazy future ...
[10:32:54.844] Packages needed by the future expression (n = 0): <none>
[10:32:54.845] Packages needed by future strategies (n = 0): <none>
[10:32:54.845] {
[10:32:54.845]     {
[10:32:54.845]         {
[10:32:54.845]             ...future.startTime <- base::Sys.time()
[10:32:54.845]             {
[10:32:54.845]                 {
[10:32:54.845]                   {
[10:32:54.845]                     {
[10:32:54.845]                       base::local({
[10:32:54.845]                         has_future <- base::requireNamespace("future", 
[10:32:54.845]                           quietly = TRUE)
[10:32:54.845]                         if (has_future) {
[10:32:54.845]                           ns <- base::getNamespace("future")
[10:32:54.845]                           version <- ns[[".package"]][["version"]]
[10:32:54.845]                           if (is.null(version)) 
[10:32:54.845]                             version <- utils::packageVersion("future")
[10:32:54.845]                         }
[10:32:54.845]                         else {
[10:32:54.845]                           version <- NULL
[10:32:54.845]                         }
[10:32:54.845]                         if (!has_future || version < "1.8.0") {
[10:32:54.845]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.845]                             "", base::R.version$version.string), 
[10:32:54.845]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.845]                               "release", "version")], collapse = " "), 
[10:32:54.845]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.845]                             info)
[10:32:54.845]                           info <- base::paste(info, collapse = "; ")
[10:32:54.845]                           if (!has_future) {
[10:32:54.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.845]                               info)
[10:32:54.845]                           }
[10:32:54.845]                           else {
[10:32:54.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.845]                               info, version)
[10:32:54.845]                           }
[10:32:54.845]                           base::stop(msg)
[10:32:54.845]                         }
[10:32:54.845]                       })
[10:32:54.845]                     }
[10:32:54.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.845]                     base::options(mc.cores = 1L)
[10:32:54.845]                   }
[10:32:54.845]                   ...future.strategy.old <- future::plan("list")
[10:32:54.845]                   options(future.plan = NULL)
[10:32:54.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.845]                 }
[10:32:54.845]                 ...future.workdir <- getwd()
[10:32:54.845]             }
[10:32:54.845]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.845]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.845]         }
[10:32:54.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.845]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.845]             base::names(...future.oldOptions))
[10:32:54.845]     }
[10:32:54.845]     if (FALSE) {
[10:32:54.845]     }
[10:32:54.845]     else {
[10:32:54.845]         if (TRUE) {
[10:32:54.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.845]                 open = "w")
[10:32:54.845]         }
[10:32:54.845]         else {
[10:32:54.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.845]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.845]         }
[10:32:54.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.845]             base::sink(type = "output", split = FALSE)
[10:32:54.845]             base::close(...future.stdout)
[10:32:54.845]         }, add = TRUE)
[10:32:54.845]     }
[10:32:54.845]     ...future.frame <- base::sys.nframe()
[10:32:54.845]     ...future.conditions <- base::list()
[10:32:54.845]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.845]     if (FALSE) {
[10:32:54.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.845]     }
[10:32:54.845]     ...future.result <- base::tryCatch({
[10:32:54.845]         base::withCallingHandlers({
[10:32:54.845]             ...future.value <- base::withVisible(base::local({
[10:32:54.845]                 ...future.makeSendCondition <- base::local({
[10:32:54.845]                   sendCondition <- NULL
[10:32:54.845]                   function(frame = 1L) {
[10:32:54.845]                     if (is.function(sendCondition)) 
[10:32:54.845]                       return(sendCondition)
[10:32:54.845]                     ns <- getNamespace("parallel")
[10:32:54.845]                     if (exists("sendData", mode = "function", 
[10:32:54.845]                       envir = ns)) {
[10:32:54.845]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.845]                         envir = ns)
[10:32:54.845]                       envir <- sys.frame(frame)
[10:32:54.845]                       master <- NULL
[10:32:54.845]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.845]                         !identical(envir, emptyenv())) {
[10:32:54.845]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.845]                           inherits = FALSE)) {
[10:32:54.845]                           master <- get("master", mode = "list", 
[10:32:54.845]                             envir = envir, inherits = FALSE)
[10:32:54.845]                           if (inherits(master, c("SOCKnode", 
[10:32:54.845]                             "SOCK0node"))) {
[10:32:54.845]                             sendCondition <<- function(cond) {
[10:32:54.845]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.845]                                 success = TRUE)
[10:32:54.845]                               parallel_sendData(master, data)
[10:32:54.845]                             }
[10:32:54.845]                             return(sendCondition)
[10:32:54.845]                           }
[10:32:54.845]                         }
[10:32:54.845]                         frame <- frame + 1L
[10:32:54.845]                         envir <- sys.frame(frame)
[10:32:54.845]                       }
[10:32:54.845]                     }
[10:32:54.845]                     sendCondition <<- function(cond) NULL
[10:32:54.845]                   }
[10:32:54.845]                 })
[10:32:54.845]                 withCallingHandlers({
[10:32:54.845]                   NULL
[10:32:54.845]                 }, immediateCondition = function(cond) {
[10:32:54.845]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.845]                   sendCondition(cond)
[10:32:54.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.845]                   {
[10:32:54.845]                     inherits <- base::inherits
[10:32:54.845]                     invokeRestart <- base::invokeRestart
[10:32:54.845]                     is.null <- base::is.null
[10:32:54.845]                     muffled <- FALSE
[10:32:54.845]                     if (inherits(cond, "message")) {
[10:32:54.845]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.845]                       if (muffled) 
[10:32:54.845]                         invokeRestart("muffleMessage")
[10:32:54.845]                     }
[10:32:54.845]                     else if (inherits(cond, "warning")) {
[10:32:54.845]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.845]                       if (muffled) 
[10:32:54.845]                         invokeRestart("muffleWarning")
[10:32:54.845]                     }
[10:32:54.845]                     else if (inherits(cond, "condition")) {
[10:32:54.845]                       if (!is.null(pattern)) {
[10:32:54.845]                         computeRestarts <- base::computeRestarts
[10:32:54.845]                         grepl <- base::grepl
[10:32:54.845]                         restarts <- computeRestarts(cond)
[10:32:54.845]                         for (restart in restarts) {
[10:32:54.845]                           name <- restart$name
[10:32:54.845]                           if (is.null(name)) 
[10:32:54.845]                             next
[10:32:54.845]                           if (!grepl(pattern, name)) 
[10:32:54.845]                             next
[10:32:54.845]                           invokeRestart(restart)
[10:32:54.845]                           muffled <- TRUE
[10:32:54.845]                           break
[10:32:54.845]                         }
[10:32:54.845]                       }
[10:32:54.845]                     }
[10:32:54.845]                     invisible(muffled)
[10:32:54.845]                   }
[10:32:54.845]                   muffleCondition(cond)
[10:32:54.845]                 })
[10:32:54.845]             }))
[10:32:54.845]             future::FutureResult(value = ...future.value$value, 
[10:32:54.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.845]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.845]                     ...future.globalenv.names))
[10:32:54.845]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.845]         }, condition = base::local({
[10:32:54.845]             c <- base::c
[10:32:54.845]             inherits <- base::inherits
[10:32:54.845]             invokeRestart <- base::invokeRestart
[10:32:54.845]             length <- base::length
[10:32:54.845]             list <- base::list
[10:32:54.845]             seq.int <- base::seq.int
[10:32:54.845]             signalCondition <- base::signalCondition
[10:32:54.845]             sys.calls <- base::sys.calls
[10:32:54.845]             `[[` <- base::`[[`
[10:32:54.845]             `+` <- base::`+`
[10:32:54.845]             `<<-` <- base::`<<-`
[10:32:54.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.845]                   3L)]
[10:32:54.845]             }
[10:32:54.845]             function(cond) {
[10:32:54.845]                 is_error <- inherits(cond, "error")
[10:32:54.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.845]                   NULL)
[10:32:54.845]                 if (is_error) {
[10:32:54.845]                   sessionInformation <- function() {
[10:32:54.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.845]                       search = base::search(), system = base::Sys.info())
[10:32:54.845]                   }
[10:32:54.845]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.845]                     cond$call), session = sessionInformation(), 
[10:32:54.845]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.845]                   signalCondition(cond)
[10:32:54.845]                 }
[10:32:54.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.845]                 "immediateCondition"))) {
[10:32:54.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.845]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.845]                   if (TRUE && !signal) {
[10:32:54.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.845]                     {
[10:32:54.845]                       inherits <- base::inherits
[10:32:54.845]                       invokeRestart <- base::invokeRestart
[10:32:54.845]                       is.null <- base::is.null
[10:32:54.845]                       muffled <- FALSE
[10:32:54.845]                       if (inherits(cond, "message")) {
[10:32:54.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.845]                         if (muffled) 
[10:32:54.845]                           invokeRestart("muffleMessage")
[10:32:54.845]                       }
[10:32:54.845]                       else if (inherits(cond, "warning")) {
[10:32:54.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.845]                         if (muffled) 
[10:32:54.845]                           invokeRestart("muffleWarning")
[10:32:54.845]                       }
[10:32:54.845]                       else if (inherits(cond, "condition")) {
[10:32:54.845]                         if (!is.null(pattern)) {
[10:32:54.845]                           computeRestarts <- base::computeRestarts
[10:32:54.845]                           grepl <- base::grepl
[10:32:54.845]                           restarts <- computeRestarts(cond)
[10:32:54.845]                           for (restart in restarts) {
[10:32:54.845]                             name <- restart$name
[10:32:54.845]                             if (is.null(name)) 
[10:32:54.845]                               next
[10:32:54.845]                             if (!grepl(pattern, name)) 
[10:32:54.845]                               next
[10:32:54.845]                             invokeRestart(restart)
[10:32:54.845]                             muffled <- TRUE
[10:32:54.845]                             break
[10:32:54.845]                           }
[10:32:54.845]                         }
[10:32:54.845]                       }
[10:32:54.845]                       invisible(muffled)
[10:32:54.845]                     }
[10:32:54.845]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.845]                   }
[10:32:54.845]                 }
[10:32:54.845]                 else {
[10:32:54.845]                   if (TRUE) {
[10:32:54.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.845]                     {
[10:32:54.845]                       inherits <- base::inherits
[10:32:54.845]                       invokeRestart <- base::invokeRestart
[10:32:54.845]                       is.null <- base::is.null
[10:32:54.845]                       muffled <- FALSE
[10:32:54.845]                       if (inherits(cond, "message")) {
[10:32:54.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.845]                         if (muffled) 
[10:32:54.845]                           invokeRestart("muffleMessage")
[10:32:54.845]                       }
[10:32:54.845]                       else if (inherits(cond, "warning")) {
[10:32:54.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.845]                         if (muffled) 
[10:32:54.845]                           invokeRestart("muffleWarning")
[10:32:54.845]                       }
[10:32:54.845]                       else if (inherits(cond, "condition")) {
[10:32:54.845]                         if (!is.null(pattern)) {
[10:32:54.845]                           computeRestarts <- base::computeRestarts
[10:32:54.845]                           grepl <- base::grepl
[10:32:54.845]                           restarts <- computeRestarts(cond)
[10:32:54.845]                           for (restart in restarts) {
[10:32:54.845]                             name <- restart$name
[10:32:54.845]                             if (is.null(name)) 
[10:32:54.845]                               next
[10:32:54.845]                             if (!grepl(pattern, name)) 
[10:32:54.845]                               next
[10:32:54.845]                             invokeRestart(restart)
[10:32:54.845]                             muffled <- TRUE
[10:32:54.845]                             break
[10:32:54.845]                           }
[10:32:54.845]                         }
[10:32:54.845]                       }
[10:32:54.845]                       invisible(muffled)
[10:32:54.845]                     }
[10:32:54.845]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.845]                   }
[10:32:54.845]                 }
[10:32:54.845]             }
[10:32:54.845]         }))
[10:32:54.845]     }, error = function(ex) {
[10:32:54.845]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.845]                 ...future.rng), started = ...future.startTime, 
[10:32:54.845]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.845]             version = "1.8"), class = "FutureResult")
[10:32:54.845]     }, finally = {
[10:32:54.845]         if (!identical(...future.workdir, getwd())) 
[10:32:54.845]             setwd(...future.workdir)
[10:32:54.845]         {
[10:32:54.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.845]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.845]             }
[10:32:54.845]             base::options(...future.oldOptions)
[10:32:54.845]             if (.Platform$OS.type == "windows") {
[10:32:54.845]                 old_names <- names(...future.oldEnvVars)
[10:32:54.845]                 envs <- base::Sys.getenv()
[10:32:54.845]                 names <- names(envs)
[10:32:54.845]                 common <- intersect(names, old_names)
[10:32:54.845]                 added <- setdiff(names, old_names)
[10:32:54.845]                 removed <- setdiff(old_names, names)
[10:32:54.845]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.845]                   envs[common]]
[10:32:54.845]                 NAMES <- toupper(changed)
[10:32:54.845]                 args <- list()
[10:32:54.845]                 for (kk in seq_along(NAMES)) {
[10:32:54.845]                   name <- changed[[kk]]
[10:32:54.845]                   NAME <- NAMES[[kk]]
[10:32:54.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.845]                     next
[10:32:54.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.845]                 }
[10:32:54.845]                 NAMES <- toupper(added)
[10:32:54.845]                 for (kk in seq_along(NAMES)) {
[10:32:54.845]                   name <- added[[kk]]
[10:32:54.845]                   NAME <- NAMES[[kk]]
[10:32:54.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.845]                     next
[10:32:54.845]                   args[[name]] <- ""
[10:32:54.845]                 }
[10:32:54.845]                 NAMES <- toupper(removed)
[10:32:54.845]                 for (kk in seq_along(NAMES)) {
[10:32:54.845]                   name <- removed[[kk]]
[10:32:54.845]                   NAME <- NAMES[[kk]]
[10:32:54.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.845]                     next
[10:32:54.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.845]                 }
[10:32:54.845]                 if (length(args) > 0) 
[10:32:54.845]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.845]             }
[10:32:54.845]             else {
[10:32:54.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.845]             }
[10:32:54.845]             {
[10:32:54.845]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.845]                   0L) {
[10:32:54.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.845]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.845]                   base::options(opts)
[10:32:54.845]                 }
[10:32:54.845]                 {
[10:32:54.845]                   {
[10:32:54.845]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.845]                     NULL
[10:32:54.845]                   }
[10:32:54.845]                   options(future.plan = NULL)
[10:32:54.845]                   if (is.na(NA_character_)) 
[10:32:54.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.845]                     .init = FALSE)
[10:32:54.845]                 }
[10:32:54.845]             }
[10:32:54.845]         }
[10:32:54.845]     })
[10:32:54.845]     if (TRUE) {
[10:32:54.845]         base::sink(type = "output", split = FALSE)
[10:32:54.845]         if (TRUE) {
[10:32:54.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.845]         }
[10:32:54.845]         else {
[10:32:54.845]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.845]         }
[10:32:54.845]         base::close(...future.stdout)
[10:32:54.845]         ...future.stdout <- NULL
[10:32:54.845]     }
[10:32:54.845]     ...future.result$conditions <- ...future.conditions
[10:32:54.845]     ...future.result$finished <- base::Sys.time()
[10:32:54.845]     ...future.result
[10:32:54.845] }
[10:32:54.848] MultisessionFuture started
[10:32:54.848] - Launch lazy future ... done
[10:32:54.848] run() for ‘MultisessionFuture’ ... done
[10:32:54.849] getGlobalsAndPackages() ...
[10:32:54.849] Searching for globals...
[10:32:54.849] - globals found: [1] ‘{’
[10:32:54.849] Searching for globals ... DONE
[10:32:54.850] Resolving globals: FALSE
[10:32:54.850] 
[10:32:54.850] 
[10:32:54.850] getGlobalsAndPackages() ... DONE
[10:32:54.850] run() for ‘Future’ ...
[10:32:54.850] - state: ‘created’
[10:32:54.850] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.864] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.864]   - Field: ‘node’
[10:32:54.864]   - Field: ‘label’
[10:32:54.864]   - Field: ‘local’
[10:32:54.864]   - Field: ‘owner’
[10:32:54.865]   - Field: ‘envir’
[10:32:54.865]   - Field: ‘workers’
[10:32:54.865]   - Field: ‘packages’
[10:32:54.865]   - Field: ‘gc’
[10:32:54.865]   - Field: ‘conditions’
[10:32:54.865]   - Field: ‘persistent’
[10:32:54.865]   - Field: ‘expr’
[10:32:54.865]   - Field: ‘uuid’
[10:32:54.865]   - Field: ‘seed’
[10:32:54.865]   - Field: ‘version’
[10:32:54.866]   - Field: ‘result’
[10:32:54.866]   - Field: ‘asynchronous’
[10:32:54.866]   - Field: ‘calls’
[10:32:54.866]   - Field: ‘globals’
[10:32:54.866]   - Field: ‘stdout’
[10:32:54.866]   - Field: ‘earlySignal’
[10:32:54.866]   - Field: ‘lazy’
[10:32:54.866]   - Field: ‘state’
[10:32:54.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.866] - Launch lazy future ...
[10:32:54.867] Packages needed by the future expression (n = 0): <none>
[10:32:54.867] Packages needed by future strategies (n = 0): <none>
[10:32:54.867] {
[10:32:54.867]     {
[10:32:54.867]         {
[10:32:54.867]             ...future.startTime <- base::Sys.time()
[10:32:54.867]             {
[10:32:54.867]                 {
[10:32:54.867]                   {
[10:32:54.867]                     {
[10:32:54.867]                       base::local({
[10:32:54.867]                         has_future <- base::requireNamespace("future", 
[10:32:54.867]                           quietly = TRUE)
[10:32:54.867]                         if (has_future) {
[10:32:54.867]                           ns <- base::getNamespace("future")
[10:32:54.867]                           version <- ns[[".package"]][["version"]]
[10:32:54.867]                           if (is.null(version)) 
[10:32:54.867]                             version <- utils::packageVersion("future")
[10:32:54.867]                         }
[10:32:54.867]                         else {
[10:32:54.867]                           version <- NULL
[10:32:54.867]                         }
[10:32:54.867]                         if (!has_future || version < "1.8.0") {
[10:32:54.867]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.867]                             "", base::R.version$version.string), 
[10:32:54.867]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.867]                               "release", "version")], collapse = " "), 
[10:32:54.867]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.867]                             info)
[10:32:54.867]                           info <- base::paste(info, collapse = "; ")
[10:32:54.867]                           if (!has_future) {
[10:32:54.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.867]                               info)
[10:32:54.867]                           }
[10:32:54.867]                           else {
[10:32:54.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.867]                               info, version)
[10:32:54.867]                           }
[10:32:54.867]                           base::stop(msg)
[10:32:54.867]                         }
[10:32:54.867]                       })
[10:32:54.867]                     }
[10:32:54.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.867]                     base::options(mc.cores = 1L)
[10:32:54.867]                   }
[10:32:54.867]                   ...future.strategy.old <- future::plan("list")
[10:32:54.867]                   options(future.plan = NULL)
[10:32:54.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.867]                 }
[10:32:54.867]                 ...future.workdir <- getwd()
[10:32:54.867]             }
[10:32:54.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.867]         }
[10:32:54.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.867]             base::names(...future.oldOptions))
[10:32:54.867]     }
[10:32:54.867]     if (FALSE) {
[10:32:54.867]     }
[10:32:54.867]     else {
[10:32:54.867]         if (TRUE) {
[10:32:54.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.867]                 open = "w")
[10:32:54.867]         }
[10:32:54.867]         else {
[10:32:54.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.867]         }
[10:32:54.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.867]             base::sink(type = "output", split = FALSE)
[10:32:54.867]             base::close(...future.stdout)
[10:32:54.867]         }, add = TRUE)
[10:32:54.867]     }
[10:32:54.867]     ...future.frame <- base::sys.nframe()
[10:32:54.867]     ...future.conditions <- base::list()
[10:32:54.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.867]     if (FALSE) {
[10:32:54.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.867]     }
[10:32:54.867]     ...future.result <- base::tryCatch({
[10:32:54.867]         base::withCallingHandlers({
[10:32:54.867]             ...future.value <- base::withVisible(base::local({
[10:32:54.867]                 ...future.makeSendCondition <- base::local({
[10:32:54.867]                   sendCondition <- NULL
[10:32:54.867]                   function(frame = 1L) {
[10:32:54.867]                     if (is.function(sendCondition)) 
[10:32:54.867]                       return(sendCondition)
[10:32:54.867]                     ns <- getNamespace("parallel")
[10:32:54.867]                     if (exists("sendData", mode = "function", 
[10:32:54.867]                       envir = ns)) {
[10:32:54.867]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.867]                         envir = ns)
[10:32:54.867]                       envir <- sys.frame(frame)
[10:32:54.867]                       master <- NULL
[10:32:54.867]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.867]                         !identical(envir, emptyenv())) {
[10:32:54.867]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.867]                           inherits = FALSE)) {
[10:32:54.867]                           master <- get("master", mode = "list", 
[10:32:54.867]                             envir = envir, inherits = FALSE)
[10:32:54.867]                           if (inherits(master, c("SOCKnode", 
[10:32:54.867]                             "SOCK0node"))) {
[10:32:54.867]                             sendCondition <<- function(cond) {
[10:32:54.867]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.867]                                 success = TRUE)
[10:32:54.867]                               parallel_sendData(master, data)
[10:32:54.867]                             }
[10:32:54.867]                             return(sendCondition)
[10:32:54.867]                           }
[10:32:54.867]                         }
[10:32:54.867]                         frame <- frame + 1L
[10:32:54.867]                         envir <- sys.frame(frame)
[10:32:54.867]                       }
[10:32:54.867]                     }
[10:32:54.867]                     sendCondition <<- function(cond) NULL
[10:32:54.867]                   }
[10:32:54.867]                 })
[10:32:54.867]                 withCallingHandlers({
[10:32:54.867]                   {
[10:32:54.867]                     4
[10:32:54.867]                   }
[10:32:54.867]                 }, immediateCondition = function(cond) {
[10:32:54.867]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.867]                   sendCondition(cond)
[10:32:54.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.867]                   {
[10:32:54.867]                     inherits <- base::inherits
[10:32:54.867]                     invokeRestart <- base::invokeRestart
[10:32:54.867]                     is.null <- base::is.null
[10:32:54.867]                     muffled <- FALSE
[10:32:54.867]                     if (inherits(cond, "message")) {
[10:32:54.867]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.867]                       if (muffled) 
[10:32:54.867]                         invokeRestart("muffleMessage")
[10:32:54.867]                     }
[10:32:54.867]                     else if (inherits(cond, "warning")) {
[10:32:54.867]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.867]                       if (muffled) 
[10:32:54.867]                         invokeRestart("muffleWarning")
[10:32:54.867]                     }
[10:32:54.867]                     else if (inherits(cond, "condition")) {
[10:32:54.867]                       if (!is.null(pattern)) {
[10:32:54.867]                         computeRestarts <- base::computeRestarts
[10:32:54.867]                         grepl <- base::grepl
[10:32:54.867]                         restarts <- computeRestarts(cond)
[10:32:54.867]                         for (restart in restarts) {
[10:32:54.867]                           name <- restart$name
[10:32:54.867]                           if (is.null(name)) 
[10:32:54.867]                             next
[10:32:54.867]                           if (!grepl(pattern, name)) 
[10:32:54.867]                             next
[10:32:54.867]                           invokeRestart(restart)
[10:32:54.867]                           muffled <- TRUE
[10:32:54.867]                           break
[10:32:54.867]                         }
[10:32:54.867]                       }
[10:32:54.867]                     }
[10:32:54.867]                     invisible(muffled)
[10:32:54.867]                   }
[10:32:54.867]                   muffleCondition(cond)
[10:32:54.867]                 })
[10:32:54.867]             }))
[10:32:54.867]             future::FutureResult(value = ...future.value$value, 
[10:32:54.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.867]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.867]                     ...future.globalenv.names))
[10:32:54.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.867]         }, condition = base::local({
[10:32:54.867]             c <- base::c
[10:32:54.867]             inherits <- base::inherits
[10:32:54.867]             invokeRestart <- base::invokeRestart
[10:32:54.867]             length <- base::length
[10:32:54.867]             list <- base::list
[10:32:54.867]             seq.int <- base::seq.int
[10:32:54.867]             signalCondition <- base::signalCondition
[10:32:54.867]             sys.calls <- base::sys.calls
[10:32:54.867]             `[[` <- base::`[[`
[10:32:54.867]             `+` <- base::`+`
[10:32:54.867]             `<<-` <- base::`<<-`
[10:32:54.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.867]                   3L)]
[10:32:54.867]             }
[10:32:54.867]             function(cond) {
[10:32:54.867]                 is_error <- inherits(cond, "error")
[10:32:54.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.867]                   NULL)
[10:32:54.867]                 if (is_error) {
[10:32:54.867]                   sessionInformation <- function() {
[10:32:54.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.867]                       search = base::search(), system = base::Sys.info())
[10:32:54.867]                   }
[10:32:54.867]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.867]                     cond$call), session = sessionInformation(), 
[10:32:54.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.867]                   signalCondition(cond)
[10:32:54.867]                 }
[10:32:54.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.867]                 "immediateCondition"))) {
[10:32:54.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.867]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.867]                   if (TRUE && !signal) {
[10:32:54.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.867]                     {
[10:32:54.867]                       inherits <- base::inherits
[10:32:54.867]                       invokeRestart <- base::invokeRestart
[10:32:54.867]                       is.null <- base::is.null
[10:32:54.867]                       muffled <- FALSE
[10:32:54.867]                       if (inherits(cond, "message")) {
[10:32:54.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.867]                         if (muffled) 
[10:32:54.867]                           invokeRestart("muffleMessage")
[10:32:54.867]                       }
[10:32:54.867]                       else if (inherits(cond, "warning")) {
[10:32:54.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.867]                         if (muffled) 
[10:32:54.867]                           invokeRestart("muffleWarning")
[10:32:54.867]                       }
[10:32:54.867]                       else if (inherits(cond, "condition")) {
[10:32:54.867]                         if (!is.null(pattern)) {
[10:32:54.867]                           computeRestarts <- base::computeRestarts
[10:32:54.867]                           grepl <- base::grepl
[10:32:54.867]                           restarts <- computeRestarts(cond)
[10:32:54.867]                           for (restart in restarts) {
[10:32:54.867]                             name <- restart$name
[10:32:54.867]                             if (is.null(name)) 
[10:32:54.867]                               next
[10:32:54.867]                             if (!grepl(pattern, name)) 
[10:32:54.867]                               next
[10:32:54.867]                             invokeRestart(restart)
[10:32:54.867]                             muffled <- TRUE
[10:32:54.867]                             break
[10:32:54.867]                           }
[10:32:54.867]                         }
[10:32:54.867]                       }
[10:32:54.867]                       invisible(muffled)
[10:32:54.867]                     }
[10:32:54.867]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.867]                   }
[10:32:54.867]                 }
[10:32:54.867]                 else {
[10:32:54.867]                   if (TRUE) {
[10:32:54.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.867]                     {
[10:32:54.867]                       inherits <- base::inherits
[10:32:54.867]                       invokeRestart <- base::invokeRestart
[10:32:54.867]                       is.null <- base::is.null
[10:32:54.867]                       muffled <- FALSE
[10:32:54.867]                       if (inherits(cond, "message")) {
[10:32:54.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.867]                         if (muffled) 
[10:32:54.867]                           invokeRestart("muffleMessage")
[10:32:54.867]                       }
[10:32:54.867]                       else if (inherits(cond, "warning")) {
[10:32:54.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.867]                         if (muffled) 
[10:32:54.867]                           invokeRestart("muffleWarning")
[10:32:54.867]                       }
[10:32:54.867]                       else if (inherits(cond, "condition")) {
[10:32:54.867]                         if (!is.null(pattern)) {
[10:32:54.867]                           computeRestarts <- base::computeRestarts
[10:32:54.867]                           grepl <- base::grepl
[10:32:54.867]                           restarts <- computeRestarts(cond)
[10:32:54.867]                           for (restart in restarts) {
[10:32:54.867]                             name <- restart$name
[10:32:54.867]                             if (is.null(name)) 
[10:32:54.867]                               next
[10:32:54.867]                             if (!grepl(pattern, name)) 
[10:32:54.867]                               next
[10:32:54.867]                             invokeRestart(restart)
[10:32:54.867]                             muffled <- TRUE
[10:32:54.867]                             break
[10:32:54.867]                           }
[10:32:54.867]                         }
[10:32:54.867]                       }
[10:32:54.867]                       invisible(muffled)
[10:32:54.867]                     }
[10:32:54.867]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.867]                   }
[10:32:54.867]                 }
[10:32:54.867]             }
[10:32:54.867]         }))
[10:32:54.867]     }, error = function(ex) {
[10:32:54.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.867]                 ...future.rng), started = ...future.startTime, 
[10:32:54.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.867]             version = "1.8"), class = "FutureResult")
[10:32:54.867]     }, finally = {
[10:32:54.867]         if (!identical(...future.workdir, getwd())) 
[10:32:54.867]             setwd(...future.workdir)
[10:32:54.867]         {
[10:32:54.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.867]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.867]             }
[10:32:54.867]             base::options(...future.oldOptions)
[10:32:54.867]             if (.Platform$OS.type == "windows") {
[10:32:54.867]                 old_names <- names(...future.oldEnvVars)
[10:32:54.867]                 envs <- base::Sys.getenv()
[10:32:54.867]                 names <- names(envs)
[10:32:54.867]                 common <- intersect(names, old_names)
[10:32:54.867]                 added <- setdiff(names, old_names)
[10:32:54.867]                 removed <- setdiff(old_names, names)
[10:32:54.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.867]                   envs[common]]
[10:32:54.867]                 NAMES <- toupper(changed)
[10:32:54.867]                 args <- list()
[10:32:54.867]                 for (kk in seq_along(NAMES)) {
[10:32:54.867]                   name <- changed[[kk]]
[10:32:54.867]                   NAME <- NAMES[[kk]]
[10:32:54.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.867]                     next
[10:32:54.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.867]                 }
[10:32:54.867]                 NAMES <- toupper(added)
[10:32:54.867]                 for (kk in seq_along(NAMES)) {
[10:32:54.867]                   name <- added[[kk]]
[10:32:54.867]                   NAME <- NAMES[[kk]]
[10:32:54.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.867]                     next
[10:32:54.867]                   args[[name]] <- ""
[10:32:54.867]                 }
[10:32:54.867]                 NAMES <- toupper(removed)
[10:32:54.867]                 for (kk in seq_along(NAMES)) {
[10:32:54.867]                   name <- removed[[kk]]
[10:32:54.867]                   NAME <- NAMES[[kk]]
[10:32:54.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.867]                     next
[10:32:54.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.867]                 }
[10:32:54.867]                 if (length(args) > 0) 
[10:32:54.867]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.867]             }
[10:32:54.867]             else {
[10:32:54.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.867]             }
[10:32:54.867]             {
[10:32:54.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.867]                   0L) {
[10:32:54.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.867]                   base::options(opts)
[10:32:54.867]                 }
[10:32:54.867]                 {
[10:32:54.867]                   {
[10:32:54.867]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.867]                     NULL
[10:32:54.867]                   }
[10:32:54.867]                   options(future.plan = NULL)
[10:32:54.867]                   if (is.na(NA_character_)) 
[10:32:54.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.867]                     .init = FALSE)
[10:32:54.867]                 }
[10:32:54.867]             }
[10:32:54.867]         }
[10:32:54.867]     })
[10:32:54.867]     if (TRUE) {
[10:32:54.867]         base::sink(type = "output", split = FALSE)
[10:32:54.867]         if (TRUE) {
[10:32:54.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.867]         }
[10:32:54.867]         else {
[10:32:54.867]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.867]         }
[10:32:54.867]         base::close(...future.stdout)
[10:32:54.867]         ...future.stdout <- NULL
[10:32:54.867]     }
[10:32:54.867]     ...future.result$conditions <- ...future.conditions
[10:32:54.867]     ...future.result$finished <- base::Sys.time()
[10:32:54.867]     ...future.result
[10:32:54.867] }
[10:32:54.869] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:54.880] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.880] - Validating connection of MultisessionFuture
[10:32:54.880] - received message: FutureResult
[10:32:54.880] - Received FutureResult
[10:32:54.880] - Erased future from FutureRegistry
[10:32:54.881] result() for ClusterFuture ...
[10:32:54.881] - result already collected: FutureResult
[10:32:54.881] result() for ClusterFuture ... done
[10:32:54.881] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.881] result() for ClusterFuture ...
[10:32:54.881] - result already collected: FutureResult
[10:32:54.881] result() for ClusterFuture ... done
[10:32:54.881] result() for ClusterFuture ...
[10:32:54.881] - result already collected: FutureResult
[10:32:54.881] result() for ClusterFuture ... done
[10:32:54.883] MultisessionFuture started
[10:32:54.883] - Launch lazy future ... done
[10:32:54.883] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d2011048> 
Classes 'listenv', 'environment' <environment: 0x5652d2fd2f80> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:32:54.891] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.891] - Validating connection of MultisessionFuture
[10:32:54.891] - received message: FutureResult
[10:32:54.891] - Received FutureResult
[10:32:54.891] - Erased future from FutureRegistry
[10:32:54.891] result() for ClusterFuture ...
[10:32:54.891] - result already collected: FutureResult
[10:32:54.892] result() for ClusterFuture ... done
[10:32:54.892] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.892] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.892] - Validating connection of MultisessionFuture
[10:32:54.892] - received message: FutureResult
[10:32:54.892] - Received FutureResult
[10:32:54.893] - Erased future from FutureRegistry
[10:32:54.893] result() for ClusterFuture ...
[10:32:54.893] - result already collected: FutureResult
[10:32:54.893] result() for ClusterFuture ... done
[10:32:54.893] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:54.895] resolve() on list environment ...
[10:32:54.895]  recursive: 0
[10:32:54.896]  length: 6
[10:32:54.896]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:54.896] signalConditionsASAP(numeric, pos=1) ...
[10:32:54.896] - nx: 6
[10:32:54.897] - relay: TRUE
[10:32:54.897] - stdout: TRUE
[10:32:54.897] - signal: TRUE
[10:32:54.897] - resignal: FALSE
[10:32:54.897] - force: TRUE
[10:32:54.897] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.897] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.897]  - until=2
[10:32:54.897]  - relaying element #2
[10:32:54.897] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.897] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.898] signalConditionsASAP(NULL, pos=1) ... done
[10:32:54.898]  length: 5 (resolved future 1)
[10:32:54.898] Future #2
[10:32:54.898] result() for ClusterFuture ...
[10:32:54.898] - result already collected: FutureResult
[10:32:54.898] result() for ClusterFuture ... done
[10:32:54.898] result() for ClusterFuture ...
[10:32:54.898] - result already collected: FutureResult
[10:32:54.898] result() for ClusterFuture ... done
[10:32:54.899] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:54.899] - nx: 6
[10:32:54.899] - relay: TRUE
[10:32:54.899] - stdout: TRUE
[10:32:54.899] - signal: TRUE
[10:32:54.899] - resignal: FALSE
[10:32:54.899] - force: TRUE
[10:32:54.899] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.899] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:54.899]  - until=2
[10:32:54.899]  - relaying element #2
[10:32:54.899] result() for ClusterFuture ...
[10:32:54.900] - result already collected: FutureResult
[10:32:54.900] result() for ClusterFuture ... done
[10:32:54.900] result() for ClusterFuture ...
[10:32:54.900] - result already collected: FutureResult
[10:32:54.900] result() for ClusterFuture ... done
[10:32:54.900] result() for ClusterFuture ...
[10:32:54.900] - result already collected: FutureResult
[10:32:54.900] result() for ClusterFuture ... done
[10:32:54.900] result() for ClusterFuture ...
[10:32:54.900] - result already collected: FutureResult
[10:32:54.901] result() for ClusterFuture ... done
[10:32:54.901] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.901] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.901] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:54.901]  length: 4 (resolved future 2)
[10:32:54.901] Future #3
[10:32:54.901] result() for ClusterFuture ...
[10:32:54.901] - result already collected: FutureResult
[10:32:54.901] result() for ClusterFuture ... done
[10:32:54.901] result() for ClusterFuture ...
[10:32:54.901] - result already collected: FutureResult
[10:32:54.902] result() for ClusterFuture ... done
[10:32:54.902] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:54.902] - nx: 6
[10:32:54.902] - relay: TRUE
[10:32:54.902] - stdout: TRUE
[10:32:54.902] - signal: TRUE
[10:32:54.902] - resignal: FALSE
[10:32:54.902] - force: TRUE
[10:32:54.902] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.902] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:54.902]  - until=3
[10:32:54.902]  - relaying element #3
[10:32:54.903] result() for ClusterFuture ...
[10:32:54.903] - result already collected: FutureResult
[10:32:54.903] result() for ClusterFuture ... done
[10:32:54.903] result() for ClusterFuture ...
[10:32:54.903] - result already collected: FutureResult
[10:32:54.903] result() for ClusterFuture ... done
[10:32:54.903] result() for ClusterFuture ...
[10:32:54.903] - result already collected: FutureResult
[10:32:54.903] result() for ClusterFuture ... done
[10:32:54.903] result() for ClusterFuture ...
[10:32:54.904] - result already collected: FutureResult
[10:32:54.904] result() for ClusterFuture ... done
[10:32:54.904] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.904] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:54.904]  length: 3 (resolved future 3)
[10:32:54.904] Future #4
[10:32:54.904] result() for ClusterFuture ...
[10:32:54.904] - result already collected: FutureResult
[10:32:54.904] result() for ClusterFuture ... done
[10:32:54.904] result() for ClusterFuture ...
[10:32:54.905] - result already collected: FutureResult
[10:32:54.905] result() for ClusterFuture ... done
[10:32:54.905] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:54.905] - nx: 6
[10:32:54.905] - relay: TRUE
[10:32:54.905] - stdout: TRUE
[10:32:54.905] - signal: TRUE
[10:32:54.905] - resignal: FALSE
[10:32:54.905] - force: TRUE
[10:32:54.905] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:54.906]  - until=4
[10:32:54.906]  - relaying element #4
[10:32:54.906] result() for ClusterFuture ...
[10:32:54.906] - result already collected: FutureResult
[10:32:54.906] result() for ClusterFuture ... done
[10:32:54.906] result() for ClusterFuture ...
[10:32:54.906] - result already collected: FutureResult
[10:32:54.906] result() for ClusterFuture ... done
[10:32:54.906] result() for ClusterFuture ...
[10:32:54.906] - result already collected: FutureResult
[10:32:54.906] result() for ClusterFuture ... done
[10:32:54.907] result() for ClusterFuture ...
[10:32:54.907] - result already collected: FutureResult
[10:32:54.907] result() for ClusterFuture ... done
[10:32:54.907] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.907] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.907] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:54.907]  length: 2 (resolved future 4)
[10:32:54.907] signalConditionsASAP(NULL, pos=5) ...
[10:32:54.907] - nx: 6
[10:32:54.907] - relay: TRUE
[10:32:54.907] - stdout: TRUE
[10:32:54.908] - signal: TRUE
[10:32:54.908] - resignal: FALSE
[10:32:54.908] - force: TRUE
[10:32:54.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.908] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.908]  - until=6
[10:32:54.908]  - relaying element #6
[10:32:54.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.908] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.908] signalConditionsASAP(NULL, pos=5) ... done
[10:32:54.908]  length: 1 (resolved future 5)
[10:32:54.909] signalConditionsASAP(numeric, pos=6) ...
[10:32:54.909] - nx: 6
[10:32:54.909] - relay: TRUE
[10:32:54.909] - stdout: TRUE
[10:32:54.909] - signal: TRUE
[10:32:54.909] - resignal: FALSE
[10:32:54.909] - force: TRUE
[10:32:54.909] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:54.909] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.909]  - until=6
[10:32:54.909] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.909] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.910] signalConditionsASAP(numeric, pos=6) ... done
[10:32:54.910]  length: 0 (resolved future 6)
[10:32:54.910] Relaying remaining futures
[10:32:54.910] signalConditionsASAP(NULL, pos=0) ...
[10:32:54.910] - nx: 6
[10:32:54.910] - relay: TRUE
[10:32:54.910] - stdout: TRUE
[10:32:54.910] - signal: TRUE
[10:32:54.910] - resignal: FALSE
[10:32:54.910] - force: TRUE
[10:32:54.910] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.911] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:54.911] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:54.911] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:54.911] signalConditionsASAP(NULL, pos=0) ... done
[10:32:54.911] resolve() on list environment ... DONE
[10:32:54.911] result() for ClusterFuture ...
[10:32:54.911] - result already collected: FutureResult
[10:32:54.911] result() for ClusterFuture ... done
[10:32:54.911] result() for ClusterFuture ...
[10:32:54.911] - result already collected: FutureResult
[10:32:54.911] result() for ClusterFuture ... done
[10:32:54.912] result() for ClusterFuture ...
[10:32:54.912] - result already collected: FutureResult
[10:32:54.912] result() for ClusterFuture ... done
[10:32:54.912] result() for ClusterFuture ...
[10:32:54.912] - result already collected: FutureResult
[10:32:54.912] result() for ClusterFuture ... done
[10:32:54.912] result() for ClusterFuture ...
[10:32:54.912] - result already collected: FutureResult
[10:32:54.912] result() for ClusterFuture ... done
[10:32:54.913] result() for ClusterFuture ...
[10:32:54.913] - result already collected: FutureResult
[10:32:54.913] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d10cc5d0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:32:54.914] getGlobalsAndPackages() ...
[10:32:54.914] Searching for globals...
[10:32:54.915] 
[10:32:54.915] Searching for globals ... DONE
[10:32:54.915] - globals: [0] <none>
[10:32:54.915] getGlobalsAndPackages() ... DONE
[10:32:54.915] run() for ‘Future’ ...
[10:32:54.915] - state: ‘created’
[10:32:54.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.930]   - Field: ‘node’
[10:32:54.930]   - Field: ‘label’
[10:32:54.930]   - Field: ‘local’
[10:32:54.930]   - Field: ‘owner’
[10:32:54.930]   - Field: ‘envir’
[10:32:54.930]   - Field: ‘workers’
[10:32:54.930]   - Field: ‘packages’
[10:32:54.930]   - Field: ‘gc’
[10:32:54.930]   - Field: ‘conditions’
[10:32:54.930]   - Field: ‘persistent’
[10:32:54.930]   - Field: ‘expr’
[10:32:54.931]   - Field: ‘uuid’
[10:32:54.931]   - Field: ‘seed’
[10:32:54.931]   - Field: ‘version’
[10:32:54.931]   - Field: ‘result’
[10:32:54.931]   - Field: ‘asynchronous’
[10:32:54.931]   - Field: ‘calls’
[10:32:54.931]   - Field: ‘globals’
[10:32:54.931]   - Field: ‘stdout’
[10:32:54.931]   - Field: ‘earlySignal’
[10:32:54.931]   - Field: ‘lazy’
[10:32:54.931]   - Field: ‘state’
[10:32:54.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.932] - Launch lazy future ...
[10:32:54.932] Packages needed by the future expression (n = 0): <none>
[10:32:54.932] Packages needed by future strategies (n = 0): <none>
[10:32:54.932] {
[10:32:54.932]     {
[10:32:54.932]         {
[10:32:54.932]             ...future.startTime <- base::Sys.time()
[10:32:54.932]             {
[10:32:54.932]                 {
[10:32:54.932]                   {
[10:32:54.932]                     {
[10:32:54.932]                       base::local({
[10:32:54.932]                         has_future <- base::requireNamespace("future", 
[10:32:54.932]                           quietly = TRUE)
[10:32:54.932]                         if (has_future) {
[10:32:54.932]                           ns <- base::getNamespace("future")
[10:32:54.932]                           version <- ns[[".package"]][["version"]]
[10:32:54.932]                           if (is.null(version)) 
[10:32:54.932]                             version <- utils::packageVersion("future")
[10:32:54.932]                         }
[10:32:54.932]                         else {
[10:32:54.932]                           version <- NULL
[10:32:54.932]                         }
[10:32:54.932]                         if (!has_future || version < "1.8.0") {
[10:32:54.932]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.932]                             "", base::R.version$version.string), 
[10:32:54.932]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.932]                               "release", "version")], collapse = " "), 
[10:32:54.932]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.932]                             info)
[10:32:54.932]                           info <- base::paste(info, collapse = "; ")
[10:32:54.932]                           if (!has_future) {
[10:32:54.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.932]                               info)
[10:32:54.932]                           }
[10:32:54.932]                           else {
[10:32:54.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.932]                               info, version)
[10:32:54.932]                           }
[10:32:54.932]                           base::stop(msg)
[10:32:54.932]                         }
[10:32:54.932]                       })
[10:32:54.932]                     }
[10:32:54.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.932]                     base::options(mc.cores = 1L)
[10:32:54.932]                   }
[10:32:54.932]                   ...future.strategy.old <- future::plan("list")
[10:32:54.932]                   options(future.plan = NULL)
[10:32:54.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.932]                 }
[10:32:54.932]                 ...future.workdir <- getwd()
[10:32:54.932]             }
[10:32:54.932]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.932]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.932]         }
[10:32:54.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.932]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.932]             base::names(...future.oldOptions))
[10:32:54.932]     }
[10:32:54.932]     if (FALSE) {
[10:32:54.932]     }
[10:32:54.932]     else {
[10:32:54.932]         if (TRUE) {
[10:32:54.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.932]                 open = "w")
[10:32:54.932]         }
[10:32:54.932]         else {
[10:32:54.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.932]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.932]         }
[10:32:54.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.932]             base::sink(type = "output", split = FALSE)
[10:32:54.932]             base::close(...future.stdout)
[10:32:54.932]         }, add = TRUE)
[10:32:54.932]     }
[10:32:54.932]     ...future.frame <- base::sys.nframe()
[10:32:54.932]     ...future.conditions <- base::list()
[10:32:54.932]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.932]     if (FALSE) {
[10:32:54.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.932]     }
[10:32:54.932]     ...future.result <- base::tryCatch({
[10:32:54.932]         base::withCallingHandlers({
[10:32:54.932]             ...future.value <- base::withVisible(base::local({
[10:32:54.932]                 ...future.makeSendCondition <- base::local({
[10:32:54.932]                   sendCondition <- NULL
[10:32:54.932]                   function(frame = 1L) {
[10:32:54.932]                     if (is.function(sendCondition)) 
[10:32:54.932]                       return(sendCondition)
[10:32:54.932]                     ns <- getNamespace("parallel")
[10:32:54.932]                     if (exists("sendData", mode = "function", 
[10:32:54.932]                       envir = ns)) {
[10:32:54.932]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.932]                         envir = ns)
[10:32:54.932]                       envir <- sys.frame(frame)
[10:32:54.932]                       master <- NULL
[10:32:54.932]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.932]                         !identical(envir, emptyenv())) {
[10:32:54.932]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.932]                           inherits = FALSE)) {
[10:32:54.932]                           master <- get("master", mode = "list", 
[10:32:54.932]                             envir = envir, inherits = FALSE)
[10:32:54.932]                           if (inherits(master, c("SOCKnode", 
[10:32:54.932]                             "SOCK0node"))) {
[10:32:54.932]                             sendCondition <<- function(cond) {
[10:32:54.932]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.932]                                 success = TRUE)
[10:32:54.932]                               parallel_sendData(master, data)
[10:32:54.932]                             }
[10:32:54.932]                             return(sendCondition)
[10:32:54.932]                           }
[10:32:54.932]                         }
[10:32:54.932]                         frame <- frame + 1L
[10:32:54.932]                         envir <- sys.frame(frame)
[10:32:54.932]                       }
[10:32:54.932]                     }
[10:32:54.932]                     sendCondition <<- function(cond) NULL
[10:32:54.932]                   }
[10:32:54.932]                 })
[10:32:54.932]                 withCallingHandlers({
[10:32:54.932]                   2
[10:32:54.932]                 }, immediateCondition = function(cond) {
[10:32:54.932]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.932]                   sendCondition(cond)
[10:32:54.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.932]                   {
[10:32:54.932]                     inherits <- base::inherits
[10:32:54.932]                     invokeRestart <- base::invokeRestart
[10:32:54.932]                     is.null <- base::is.null
[10:32:54.932]                     muffled <- FALSE
[10:32:54.932]                     if (inherits(cond, "message")) {
[10:32:54.932]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.932]                       if (muffled) 
[10:32:54.932]                         invokeRestart("muffleMessage")
[10:32:54.932]                     }
[10:32:54.932]                     else if (inherits(cond, "warning")) {
[10:32:54.932]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.932]                       if (muffled) 
[10:32:54.932]                         invokeRestart("muffleWarning")
[10:32:54.932]                     }
[10:32:54.932]                     else if (inherits(cond, "condition")) {
[10:32:54.932]                       if (!is.null(pattern)) {
[10:32:54.932]                         computeRestarts <- base::computeRestarts
[10:32:54.932]                         grepl <- base::grepl
[10:32:54.932]                         restarts <- computeRestarts(cond)
[10:32:54.932]                         for (restart in restarts) {
[10:32:54.932]                           name <- restart$name
[10:32:54.932]                           if (is.null(name)) 
[10:32:54.932]                             next
[10:32:54.932]                           if (!grepl(pattern, name)) 
[10:32:54.932]                             next
[10:32:54.932]                           invokeRestart(restart)
[10:32:54.932]                           muffled <- TRUE
[10:32:54.932]                           break
[10:32:54.932]                         }
[10:32:54.932]                       }
[10:32:54.932]                     }
[10:32:54.932]                     invisible(muffled)
[10:32:54.932]                   }
[10:32:54.932]                   muffleCondition(cond)
[10:32:54.932]                 })
[10:32:54.932]             }))
[10:32:54.932]             future::FutureResult(value = ...future.value$value, 
[10:32:54.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.932]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.932]                     ...future.globalenv.names))
[10:32:54.932]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.932]         }, condition = base::local({
[10:32:54.932]             c <- base::c
[10:32:54.932]             inherits <- base::inherits
[10:32:54.932]             invokeRestart <- base::invokeRestart
[10:32:54.932]             length <- base::length
[10:32:54.932]             list <- base::list
[10:32:54.932]             seq.int <- base::seq.int
[10:32:54.932]             signalCondition <- base::signalCondition
[10:32:54.932]             sys.calls <- base::sys.calls
[10:32:54.932]             `[[` <- base::`[[`
[10:32:54.932]             `+` <- base::`+`
[10:32:54.932]             `<<-` <- base::`<<-`
[10:32:54.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.932]                   3L)]
[10:32:54.932]             }
[10:32:54.932]             function(cond) {
[10:32:54.932]                 is_error <- inherits(cond, "error")
[10:32:54.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.932]                   NULL)
[10:32:54.932]                 if (is_error) {
[10:32:54.932]                   sessionInformation <- function() {
[10:32:54.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.932]                       search = base::search(), system = base::Sys.info())
[10:32:54.932]                   }
[10:32:54.932]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.932]                     cond$call), session = sessionInformation(), 
[10:32:54.932]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.932]                   signalCondition(cond)
[10:32:54.932]                 }
[10:32:54.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.932]                 "immediateCondition"))) {
[10:32:54.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.932]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.932]                   if (TRUE && !signal) {
[10:32:54.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.932]                     {
[10:32:54.932]                       inherits <- base::inherits
[10:32:54.932]                       invokeRestart <- base::invokeRestart
[10:32:54.932]                       is.null <- base::is.null
[10:32:54.932]                       muffled <- FALSE
[10:32:54.932]                       if (inherits(cond, "message")) {
[10:32:54.932]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.932]                         if (muffled) 
[10:32:54.932]                           invokeRestart("muffleMessage")
[10:32:54.932]                       }
[10:32:54.932]                       else if (inherits(cond, "warning")) {
[10:32:54.932]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.932]                         if (muffled) 
[10:32:54.932]                           invokeRestart("muffleWarning")
[10:32:54.932]                       }
[10:32:54.932]                       else if (inherits(cond, "condition")) {
[10:32:54.932]                         if (!is.null(pattern)) {
[10:32:54.932]                           computeRestarts <- base::computeRestarts
[10:32:54.932]                           grepl <- base::grepl
[10:32:54.932]                           restarts <- computeRestarts(cond)
[10:32:54.932]                           for (restart in restarts) {
[10:32:54.932]                             name <- restart$name
[10:32:54.932]                             if (is.null(name)) 
[10:32:54.932]                               next
[10:32:54.932]                             if (!grepl(pattern, name)) 
[10:32:54.932]                               next
[10:32:54.932]                             invokeRestart(restart)
[10:32:54.932]                             muffled <- TRUE
[10:32:54.932]                             break
[10:32:54.932]                           }
[10:32:54.932]                         }
[10:32:54.932]                       }
[10:32:54.932]                       invisible(muffled)
[10:32:54.932]                     }
[10:32:54.932]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.932]                   }
[10:32:54.932]                 }
[10:32:54.932]                 else {
[10:32:54.932]                   if (TRUE) {
[10:32:54.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.932]                     {
[10:32:54.932]                       inherits <- base::inherits
[10:32:54.932]                       invokeRestart <- base::invokeRestart
[10:32:54.932]                       is.null <- base::is.null
[10:32:54.932]                       muffled <- FALSE
[10:32:54.932]                       if (inherits(cond, "message")) {
[10:32:54.932]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.932]                         if (muffled) 
[10:32:54.932]                           invokeRestart("muffleMessage")
[10:32:54.932]                       }
[10:32:54.932]                       else if (inherits(cond, "warning")) {
[10:32:54.932]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.932]                         if (muffled) 
[10:32:54.932]                           invokeRestart("muffleWarning")
[10:32:54.932]                       }
[10:32:54.932]                       else if (inherits(cond, "condition")) {
[10:32:54.932]                         if (!is.null(pattern)) {
[10:32:54.932]                           computeRestarts <- base::computeRestarts
[10:32:54.932]                           grepl <- base::grepl
[10:32:54.932]                           restarts <- computeRestarts(cond)
[10:32:54.932]                           for (restart in restarts) {
[10:32:54.932]                             name <- restart$name
[10:32:54.932]                             if (is.null(name)) 
[10:32:54.932]                               next
[10:32:54.932]                             if (!grepl(pattern, name)) 
[10:32:54.932]                               next
[10:32:54.932]                             invokeRestart(restart)
[10:32:54.932]                             muffled <- TRUE
[10:32:54.932]                             break
[10:32:54.932]                           }
[10:32:54.932]                         }
[10:32:54.932]                       }
[10:32:54.932]                       invisible(muffled)
[10:32:54.932]                     }
[10:32:54.932]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.932]                   }
[10:32:54.932]                 }
[10:32:54.932]             }
[10:32:54.932]         }))
[10:32:54.932]     }, error = function(ex) {
[10:32:54.932]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.932]                 ...future.rng), started = ...future.startTime, 
[10:32:54.932]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.932]             version = "1.8"), class = "FutureResult")
[10:32:54.932]     }, finally = {
[10:32:54.932]         if (!identical(...future.workdir, getwd())) 
[10:32:54.932]             setwd(...future.workdir)
[10:32:54.932]         {
[10:32:54.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.932]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.932]             }
[10:32:54.932]             base::options(...future.oldOptions)
[10:32:54.932]             if (.Platform$OS.type == "windows") {
[10:32:54.932]                 old_names <- names(...future.oldEnvVars)
[10:32:54.932]                 envs <- base::Sys.getenv()
[10:32:54.932]                 names <- names(envs)
[10:32:54.932]                 common <- intersect(names, old_names)
[10:32:54.932]                 added <- setdiff(names, old_names)
[10:32:54.932]                 removed <- setdiff(old_names, names)
[10:32:54.932]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.932]                   envs[common]]
[10:32:54.932]                 NAMES <- toupper(changed)
[10:32:54.932]                 args <- list()
[10:32:54.932]                 for (kk in seq_along(NAMES)) {
[10:32:54.932]                   name <- changed[[kk]]
[10:32:54.932]                   NAME <- NAMES[[kk]]
[10:32:54.932]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.932]                     next
[10:32:54.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.932]                 }
[10:32:54.932]                 NAMES <- toupper(added)
[10:32:54.932]                 for (kk in seq_along(NAMES)) {
[10:32:54.932]                   name <- added[[kk]]
[10:32:54.932]                   NAME <- NAMES[[kk]]
[10:32:54.932]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.932]                     next
[10:32:54.932]                   args[[name]] <- ""
[10:32:54.932]                 }
[10:32:54.932]                 NAMES <- toupper(removed)
[10:32:54.932]                 for (kk in seq_along(NAMES)) {
[10:32:54.932]                   name <- removed[[kk]]
[10:32:54.932]                   NAME <- NAMES[[kk]]
[10:32:54.932]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.932]                     next
[10:32:54.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.932]                 }
[10:32:54.932]                 if (length(args) > 0) 
[10:32:54.932]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.932]             }
[10:32:54.932]             else {
[10:32:54.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.932]             }
[10:32:54.932]             {
[10:32:54.932]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.932]                   0L) {
[10:32:54.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.932]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.932]                   base::options(opts)
[10:32:54.932]                 }
[10:32:54.932]                 {
[10:32:54.932]                   {
[10:32:54.932]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.932]                     NULL
[10:32:54.932]                   }
[10:32:54.932]                   options(future.plan = NULL)
[10:32:54.932]                   if (is.na(NA_character_)) 
[10:32:54.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.932]                     .init = FALSE)
[10:32:54.932]                 }
[10:32:54.932]             }
[10:32:54.932]         }
[10:32:54.932]     })
[10:32:54.932]     if (TRUE) {
[10:32:54.932]         base::sink(type = "output", split = FALSE)
[10:32:54.932]         if (TRUE) {
[10:32:54.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.932]         }
[10:32:54.932]         else {
[10:32:54.932]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.932]         }
[10:32:54.932]         base::close(...future.stdout)
[10:32:54.932]         ...future.stdout <- NULL
[10:32:54.932]     }
[10:32:54.932]     ...future.result$conditions <- ...future.conditions
[10:32:54.932]     ...future.result$finished <- base::Sys.time()
[10:32:54.932]     ...future.result
[10:32:54.932] }
[10:32:54.935] MultisessionFuture started
[10:32:54.936] - Launch lazy future ... done
[10:32:54.936] run() for ‘MultisessionFuture’ ... done
[10:32:54.936] getGlobalsAndPackages() ...
[10:32:54.936] Searching for globals...
[10:32:54.937] 
[10:32:54.937] Searching for globals ... DONE
[10:32:54.937] - globals: [0] <none>
[10:32:54.937] getGlobalsAndPackages() ... DONE
[10:32:54.937] run() for ‘Future’ ...
[10:32:54.938] - state: ‘created’
[10:32:54.938] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.951]   - Field: ‘node’
[10:32:54.952]   - Field: ‘label’
[10:32:54.952]   - Field: ‘local’
[10:32:54.952]   - Field: ‘owner’
[10:32:54.952]   - Field: ‘envir’
[10:32:54.952]   - Field: ‘workers’
[10:32:54.952]   - Field: ‘packages’
[10:32:54.952]   - Field: ‘gc’
[10:32:54.952]   - Field: ‘conditions’
[10:32:54.952]   - Field: ‘persistent’
[10:32:54.952]   - Field: ‘expr’
[10:32:54.952]   - Field: ‘uuid’
[10:32:54.953]   - Field: ‘seed’
[10:32:54.953]   - Field: ‘version’
[10:32:54.953]   - Field: ‘result’
[10:32:54.953]   - Field: ‘asynchronous’
[10:32:54.953]   - Field: ‘calls’
[10:32:54.953]   - Field: ‘globals’
[10:32:54.953]   - Field: ‘stdout’
[10:32:54.953]   - Field: ‘earlySignal’
[10:32:54.953]   - Field: ‘lazy’
[10:32:54.953]   - Field: ‘state’
[10:32:54.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.954] - Launch lazy future ...
[10:32:54.954] Packages needed by the future expression (n = 0): <none>
[10:32:54.954] Packages needed by future strategies (n = 0): <none>
[10:32:54.954] {
[10:32:54.954]     {
[10:32:54.954]         {
[10:32:54.954]             ...future.startTime <- base::Sys.time()
[10:32:54.954]             {
[10:32:54.954]                 {
[10:32:54.954]                   {
[10:32:54.954]                     {
[10:32:54.954]                       base::local({
[10:32:54.954]                         has_future <- base::requireNamespace("future", 
[10:32:54.954]                           quietly = TRUE)
[10:32:54.954]                         if (has_future) {
[10:32:54.954]                           ns <- base::getNamespace("future")
[10:32:54.954]                           version <- ns[[".package"]][["version"]]
[10:32:54.954]                           if (is.null(version)) 
[10:32:54.954]                             version <- utils::packageVersion("future")
[10:32:54.954]                         }
[10:32:54.954]                         else {
[10:32:54.954]                           version <- NULL
[10:32:54.954]                         }
[10:32:54.954]                         if (!has_future || version < "1.8.0") {
[10:32:54.954]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.954]                             "", base::R.version$version.string), 
[10:32:54.954]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.954]                               "release", "version")], collapse = " "), 
[10:32:54.954]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.954]                             info)
[10:32:54.954]                           info <- base::paste(info, collapse = "; ")
[10:32:54.954]                           if (!has_future) {
[10:32:54.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.954]                               info)
[10:32:54.954]                           }
[10:32:54.954]                           else {
[10:32:54.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.954]                               info, version)
[10:32:54.954]                           }
[10:32:54.954]                           base::stop(msg)
[10:32:54.954]                         }
[10:32:54.954]                       })
[10:32:54.954]                     }
[10:32:54.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.954]                     base::options(mc.cores = 1L)
[10:32:54.954]                   }
[10:32:54.954]                   ...future.strategy.old <- future::plan("list")
[10:32:54.954]                   options(future.plan = NULL)
[10:32:54.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.954]                 }
[10:32:54.954]                 ...future.workdir <- getwd()
[10:32:54.954]             }
[10:32:54.954]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.954]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.954]         }
[10:32:54.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.954]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.954]             base::names(...future.oldOptions))
[10:32:54.954]     }
[10:32:54.954]     if (FALSE) {
[10:32:54.954]     }
[10:32:54.954]     else {
[10:32:54.954]         if (TRUE) {
[10:32:54.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.954]                 open = "w")
[10:32:54.954]         }
[10:32:54.954]         else {
[10:32:54.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.954]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.954]         }
[10:32:54.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.954]             base::sink(type = "output", split = FALSE)
[10:32:54.954]             base::close(...future.stdout)
[10:32:54.954]         }, add = TRUE)
[10:32:54.954]     }
[10:32:54.954]     ...future.frame <- base::sys.nframe()
[10:32:54.954]     ...future.conditions <- base::list()
[10:32:54.954]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.954]     if (FALSE) {
[10:32:54.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.954]     }
[10:32:54.954]     ...future.result <- base::tryCatch({
[10:32:54.954]         base::withCallingHandlers({
[10:32:54.954]             ...future.value <- base::withVisible(base::local({
[10:32:54.954]                 ...future.makeSendCondition <- base::local({
[10:32:54.954]                   sendCondition <- NULL
[10:32:54.954]                   function(frame = 1L) {
[10:32:54.954]                     if (is.function(sendCondition)) 
[10:32:54.954]                       return(sendCondition)
[10:32:54.954]                     ns <- getNamespace("parallel")
[10:32:54.954]                     if (exists("sendData", mode = "function", 
[10:32:54.954]                       envir = ns)) {
[10:32:54.954]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.954]                         envir = ns)
[10:32:54.954]                       envir <- sys.frame(frame)
[10:32:54.954]                       master <- NULL
[10:32:54.954]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.954]                         !identical(envir, emptyenv())) {
[10:32:54.954]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.954]                           inherits = FALSE)) {
[10:32:54.954]                           master <- get("master", mode = "list", 
[10:32:54.954]                             envir = envir, inherits = FALSE)
[10:32:54.954]                           if (inherits(master, c("SOCKnode", 
[10:32:54.954]                             "SOCK0node"))) {
[10:32:54.954]                             sendCondition <<- function(cond) {
[10:32:54.954]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.954]                                 success = TRUE)
[10:32:54.954]                               parallel_sendData(master, data)
[10:32:54.954]                             }
[10:32:54.954]                             return(sendCondition)
[10:32:54.954]                           }
[10:32:54.954]                         }
[10:32:54.954]                         frame <- frame + 1L
[10:32:54.954]                         envir <- sys.frame(frame)
[10:32:54.954]                       }
[10:32:54.954]                     }
[10:32:54.954]                     sendCondition <<- function(cond) NULL
[10:32:54.954]                   }
[10:32:54.954]                 })
[10:32:54.954]                 withCallingHandlers({
[10:32:54.954]                   NULL
[10:32:54.954]                 }, immediateCondition = function(cond) {
[10:32:54.954]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.954]                   sendCondition(cond)
[10:32:54.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.954]                   {
[10:32:54.954]                     inherits <- base::inherits
[10:32:54.954]                     invokeRestart <- base::invokeRestart
[10:32:54.954]                     is.null <- base::is.null
[10:32:54.954]                     muffled <- FALSE
[10:32:54.954]                     if (inherits(cond, "message")) {
[10:32:54.954]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.954]                       if (muffled) 
[10:32:54.954]                         invokeRestart("muffleMessage")
[10:32:54.954]                     }
[10:32:54.954]                     else if (inherits(cond, "warning")) {
[10:32:54.954]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.954]                       if (muffled) 
[10:32:54.954]                         invokeRestart("muffleWarning")
[10:32:54.954]                     }
[10:32:54.954]                     else if (inherits(cond, "condition")) {
[10:32:54.954]                       if (!is.null(pattern)) {
[10:32:54.954]                         computeRestarts <- base::computeRestarts
[10:32:54.954]                         grepl <- base::grepl
[10:32:54.954]                         restarts <- computeRestarts(cond)
[10:32:54.954]                         for (restart in restarts) {
[10:32:54.954]                           name <- restart$name
[10:32:54.954]                           if (is.null(name)) 
[10:32:54.954]                             next
[10:32:54.954]                           if (!grepl(pattern, name)) 
[10:32:54.954]                             next
[10:32:54.954]                           invokeRestart(restart)
[10:32:54.954]                           muffled <- TRUE
[10:32:54.954]                           break
[10:32:54.954]                         }
[10:32:54.954]                       }
[10:32:54.954]                     }
[10:32:54.954]                     invisible(muffled)
[10:32:54.954]                   }
[10:32:54.954]                   muffleCondition(cond)
[10:32:54.954]                 })
[10:32:54.954]             }))
[10:32:54.954]             future::FutureResult(value = ...future.value$value, 
[10:32:54.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.954]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.954]                     ...future.globalenv.names))
[10:32:54.954]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.954]         }, condition = base::local({
[10:32:54.954]             c <- base::c
[10:32:54.954]             inherits <- base::inherits
[10:32:54.954]             invokeRestart <- base::invokeRestart
[10:32:54.954]             length <- base::length
[10:32:54.954]             list <- base::list
[10:32:54.954]             seq.int <- base::seq.int
[10:32:54.954]             signalCondition <- base::signalCondition
[10:32:54.954]             sys.calls <- base::sys.calls
[10:32:54.954]             `[[` <- base::`[[`
[10:32:54.954]             `+` <- base::`+`
[10:32:54.954]             `<<-` <- base::`<<-`
[10:32:54.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.954]                   3L)]
[10:32:54.954]             }
[10:32:54.954]             function(cond) {
[10:32:54.954]                 is_error <- inherits(cond, "error")
[10:32:54.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.954]                   NULL)
[10:32:54.954]                 if (is_error) {
[10:32:54.954]                   sessionInformation <- function() {
[10:32:54.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.954]                       search = base::search(), system = base::Sys.info())
[10:32:54.954]                   }
[10:32:54.954]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.954]                     cond$call), session = sessionInformation(), 
[10:32:54.954]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.954]                   signalCondition(cond)
[10:32:54.954]                 }
[10:32:54.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.954]                 "immediateCondition"))) {
[10:32:54.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.954]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.954]                   if (TRUE && !signal) {
[10:32:54.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.954]                     {
[10:32:54.954]                       inherits <- base::inherits
[10:32:54.954]                       invokeRestart <- base::invokeRestart
[10:32:54.954]                       is.null <- base::is.null
[10:32:54.954]                       muffled <- FALSE
[10:32:54.954]                       if (inherits(cond, "message")) {
[10:32:54.954]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.954]                         if (muffled) 
[10:32:54.954]                           invokeRestart("muffleMessage")
[10:32:54.954]                       }
[10:32:54.954]                       else if (inherits(cond, "warning")) {
[10:32:54.954]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.954]                         if (muffled) 
[10:32:54.954]                           invokeRestart("muffleWarning")
[10:32:54.954]                       }
[10:32:54.954]                       else if (inherits(cond, "condition")) {
[10:32:54.954]                         if (!is.null(pattern)) {
[10:32:54.954]                           computeRestarts <- base::computeRestarts
[10:32:54.954]                           grepl <- base::grepl
[10:32:54.954]                           restarts <- computeRestarts(cond)
[10:32:54.954]                           for (restart in restarts) {
[10:32:54.954]                             name <- restart$name
[10:32:54.954]                             if (is.null(name)) 
[10:32:54.954]                               next
[10:32:54.954]                             if (!grepl(pattern, name)) 
[10:32:54.954]                               next
[10:32:54.954]                             invokeRestart(restart)
[10:32:54.954]                             muffled <- TRUE
[10:32:54.954]                             break
[10:32:54.954]                           }
[10:32:54.954]                         }
[10:32:54.954]                       }
[10:32:54.954]                       invisible(muffled)
[10:32:54.954]                     }
[10:32:54.954]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.954]                   }
[10:32:54.954]                 }
[10:32:54.954]                 else {
[10:32:54.954]                   if (TRUE) {
[10:32:54.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.954]                     {
[10:32:54.954]                       inherits <- base::inherits
[10:32:54.954]                       invokeRestart <- base::invokeRestart
[10:32:54.954]                       is.null <- base::is.null
[10:32:54.954]                       muffled <- FALSE
[10:32:54.954]                       if (inherits(cond, "message")) {
[10:32:54.954]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.954]                         if (muffled) 
[10:32:54.954]                           invokeRestart("muffleMessage")
[10:32:54.954]                       }
[10:32:54.954]                       else if (inherits(cond, "warning")) {
[10:32:54.954]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.954]                         if (muffled) 
[10:32:54.954]                           invokeRestart("muffleWarning")
[10:32:54.954]                       }
[10:32:54.954]                       else if (inherits(cond, "condition")) {
[10:32:54.954]                         if (!is.null(pattern)) {
[10:32:54.954]                           computeRestarts <- base::computeRestarts
[10:32:54.954]                           grepl <- base::grepl
[10:32:54.954]                           restarts <- computeRestarts(cond)
[10:32:54.954]                           for (restart in restarts) {
[10:32:54.954]                             name <- restart$name
[10:32:54.954]                             if (is.null(name)) 
[10:32:54.954]                               next
[10:32:54.954]                             if (!grepl(pattern, name)) 
[10:32:54.954]                               next
[10:32:54.954]                             invokeRestart(restart)
[10:32:54.954]                             muffled <- TRUE
[10:32:54.954]                             break
[10:32:54.954]                           }
[10:32:54.954]                         }
[10:32:54.954]                       }
[10:32:54.954]                       invisible(muffled)
[10:32:54.954]                     }
[10:32:54.954]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.954]                   }
[10:32:54.954]                 }
[10:32:54.954]             }
[10:32:54.954]         }))
[10:32:54.954]     }, error = function(ex) {
[10:32:54.954]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.954]                 ...future.rng), started = ...future.startTime, 
[10:32:54.954]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.954]             version = "1.8"), class = "FutureResult")
[10:32:54.954]     }, finally = {
[10:32:54.954]         if (!identical(...future.workdir, getwd())) 
[10:32:54.954]             setwd(...future.workdir)
[10:32:54.954]         {
[10:32:54.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.954]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.954]             }
[10:32:54.954]             base::options(...future.oldOptions)
[10:32:54.954]             if (.Platform$OS.type == "windows") {
[10:32:54.954]                 old_names <- names(...future.oldEnvVars)
[10:32:54.954]                 envs <- base::Sys.getenv()
[10:32:54.954]                 names <- names(envs)
[10:32:54.954]                 common <- intersect(names, old_names)
[10:32:54.954]                 added <- setdiff(names, old_names)
[10:32:54.954]                 removed <- setdiff(old_names, names)
[10:32:54.954]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.954]                   envs[common]]
[10:32:54.954]                 NAMES <- toupper(changed)
[10:32:54.954]                 args <- list()
[10:32:54.954]                 for (kk in seq_along(NAMES)) {
[10:32:54.954]                   name <- changed[[kk]]
[10:32:54.954]                   NAME <- NAMES[[kk]]
[10:32:54.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.954]                     next
[10:32:54.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.954]                 }
[10:32:54.954]                 NAMES <- toupper(added)
[10:32:54.954]                 for (kk in seq_along(NAMES)) {
[10:32:54.954]                   name <- added[[kk]]
[10:32:54.954]                   NAME <- NAMES[[kk]]
[10:32:54.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.954]                     next
[10:32:54.954]                   args[[name]] <- ""
[10:32:54.954]                 }
[10:32:54.954]                 NAMES <- toupper(removed)
[10:32:54.954]                 for (kk in seq_along(NAMES)) {
[10:32:54.954]                   name <- removed[[kk]]
[10:32:54.954]                   NAME <- NAMES[[kk]]
[10:32:54.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.954]                     next
[10:32:54.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.954]                 }
[10:32:54.954]                 if (length(args) > 0) 
[10:32:54.954]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.954]             }
[10:32:54.954]             else {
[10:32:54.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.954]             }
[10:32:54.954]             {
[10:32:54.954]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.954]                   0L) {
[10:32:54.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.954]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.954]                   base::options(opts)
[10:32:54.954]                 }
[10:32:54.954]                 {
[10:32:54.954]                   {
[10:32:54.954]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.954]                     NULL
[10:32:54.954]                   }
[10:32:54.954]                   options(future.plan = NULL)
[10:32:54.954]                   if (is.na(NA_character_)) 
[10:32:54.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.954]                     .init = FALSE)
[10:32:54.954]                 }
[10:32:54.954]             }
[10:32:54.954]         }
[10:32:54.954]     })
[10:32:54.954]     if (TRUE) {
[10:32:54.954]         base::sink(type = "output", split = FALSE)
[10:32:54.954]         if (TRUE) {
[10:32:54.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.954]         }
[10:32:54.954]         else {
[10:32:54.954]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.954]         }
[10:32:54.954]         base::close(...future.stdout)
[10:32:54.954]         ...future.stdout <- NULL
[10:32:54.954]     }
[10:32:54.954]     ...future.result$conditions <- ...future.conditions
[10:32:54.954]     ...future.result$finished <- base::Sys.time()
[10:32:54.954]     ...future.result
[10:32:54.954] }
[10:32:54.957] MultisessionFuture started
[10:32:54.957] - Launch lazy future ... done
[10:32:54.958] run() for ‘MultisessionFuture’ ... done
[10:32:54.958] getGlobalsAndPackages() ...
[10:32:54.958] Searching for globals...
[10:32:54.959] - globals found: [1] ‘{’
[10:32:54.959] Searching for globals ... DONE
[10:32:54.959] Resolving globals: FALSE
[10:32:54.959] 
[10:32:54.959] 
[10:32:54.959] getGlobalsAndPackages() ... DONE
[10:32:54.960] run() for ‘Future’ ...
[10:32:54.960] - state: ‘created’
[10:32:54.960] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:54.973] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:54.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:54.973]   - Field: ‘node’
[10:32:54.974]   - Field: ‘label’
[10:32:54.974]   - Field: ‘local’
[10:32:54.974]   - Field: ‘owner’
[10:32:54.974]   - Field: ‘envir’
[10:32:54.974]   - Field: ‘workers’
[10:32:54.974]   - Field: ‘packages’
[10:32:54.974]   - Field: ‘gc’
[10:32:54.974]   - Field: ‘conditions’
[10:32:54.974]   - Field: ‘persistent’
[10:32:54.974]   - Field: ‘expr’
[10:32:54.975]   - Field: ‘uuid’
[10:32:54.975]   - Field: ‘seed’
[10:32:54.975]   - Field: ‘version’
[10:32:54.975]   - Field: ‘result’
[10:32:54.975]   - Field: ‘asynchronous’
[10:32:54.975]   - Field: ‘calls’
[10:32:54.975]   - Field: ‘globals’
[10:32:54.975]   - Field: ‘stdout’
[10:32:54.975]   - Field: ‘earlySignal’
[10:32:54.975]   - Field: ‘lazy’
[10:32:54.975]   - Field: ‘state’
[10:32:54.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:54.976] - Launch lazy future ...
[10:32:54.976] Packages needed by the future expression (n = 0): <none>
[10:32:54.976] Packages needed by future strategies (n = 0): <none>
[10:32:54.976] {
[10:32:54.976]     {
[10:32:54.976]         {
[10:32:54.976]             ...future.startTime <- base::Sys.time()
[10:32:54.976]             {
[10:32:54.976]                 {
[10:32:54.976]                   {
[10:32:54.976]                     {
[10:32:54.976]                       base::local({
[10:32:54.976]                         has_future <- base::requireNamespace("future", 
[10:32:54.976]                           quietly = TRUE)
[10:32:54.976]                         if (has_future) {
[10:32:54.976]                           ns <- base::getNamespace("future")
[10:32:54.976]                           version <- ns[[".package"]][["version"]]
[10:32:54.976]                           if (is.null(version)) 
[10:32:54.976]                             version <- utils::packageVersion("future")
[10:32:54.976]                         }
[10:32:54.976]                         else {
[10:32:54.976]                           version <- NULL
[10:32:54.976]                         }
[10:32:54.976]                         if (!has_future || version < "1.8.0") {
[10:32:54.976]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:54.976]                             "", base::R.version$version.string), 
[10:32:54.976]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:54.976]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:54.976]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:54.976]                               "release", "version")], collapse = " "), 
[10:32:54.976]                             hostname = base::Sys.info()[["nodename"]])
[10:32:54.976]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:54.976]                             info)
[10:32:54.976]                           info <- base::paste(info, collapse = "; ")
[10:32:54.976]                           if (!has_future) {
[10:32:54.976]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:54.976]                               info)
[10:32:54.976]                           }
[10:32:54.976]                           else {
[10:32:54.976]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:54.976]                               info, version)
[10:32:54.976]                           }
[10:32:54.976]                           base::stop(msg)
[10:32:54.976]                         }
[10:32:54.976]                       })
[10:32:54.976]                     }
[10:32:54.976]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:54.976]                     base::options(mc.cores = 1L)
[10:32:54.976]                   }
[10:32:54.976]                   ...future.strategy.old <- future::plan("list")
[10:32:54.976]                   options(future.plan = NULL)
[10:32:54.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:54.976]                 }
[10:32:54.976]                 ...future.workdir <- getwd()
[10:32:54.976]             }
[10:32:54.976]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:54.976]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:54.976]         }
[10:32:54.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:54.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:54.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:54.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:54.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:54.976]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:54.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:54.976]             base::names(...future.oldOptions))
[10:32:54.976]     }
[10:32:54.976]     if (FALSE) {
[10:32:54.976]     }
[10:32:54.976]     else {
[10:32:54.976]         if (TRUE) {
[10:32:54.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:54.976]                 open = "w")
[10:32:54.976]         }
[10:32:54.976]         else {
[10:32:54.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:54.976]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:54.976]         }
[10:32:54.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:54.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:54.976]             base::sink(type = "output", split = FALSE)
[10:32:54.976]             base::close(...future.stdout)
[10:32:54.976]         }, add = TRUE)
[10:32:54.976]     }
[10:32:54.976]     ...future.frame <- base::sys.nframe()
[10:32:54.976]     ...future.conditions <- base::list()
[10:32:54.976]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:54.976]     if (FALSE) {
[10:32:54.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:54.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:54.976]     }
[10:32:54.976]     ...future.result <- base::tryCatch({
[10:32:54.976]         base::withCallingHandlers({
[10:32:54.976]             ...future.value <- base::withVisible(base::local({
[10:32:54.976]                 ...future.makeSendCondition <- base::local({
[10:32:54.976]                   sendCondition <- NULL
[10:32:54.976]                   function(frame = 1L) {
[10:32:54.976]                     if (is.function(sendCondition)) 
[10:32:54.976]                       return(sendCondition)
[10:32:54.976]                     ns <- getNamespace("parallel")
[10:32:54.976]                     if (exists("sendData", mode = "function", 
[10:32:54.976]                       envir = ns)) {
[10:32:54.976]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:54.976]                         envir = ns)
[10:32:54.976]                       envir <- sys.frame(frame)
[10:32:54.976]                       master <- NULL
[10:32:54.976]                       while (!identical(envir, .GlobalEnv) && 
[10:32:54.976]                         !identical(envir, emptyenv())) {
[10:32:54.976]                         if (exists("master", mode = "list", envir = envir, 
[10:32:54.976]                           inherits = FALSE)) {
[10:32:54.976]                           master <- get("master", mode = "list", 
[10:32:54.976]                             envir = envir, inherits = FALSE)
[10:32:54.976]                           if (inherits(master, c("SOCKnode", 
[10:32:54.976]                             "SOCK0node"))) {
[10:32:54.976]                             sendCondition <<- function(cond) {
[10:32:54.976]                               data <- list(type = "VALUE", value = cond, 
[10:32:54.976]                                 success = TRUE)
[10:32:54.976]                               parallel_sendData(master, data)
[10:32:54.976]                             }
[10:32:54.976]                             return(sendCondition)
[10:32:54.976]                           }
[10:32:54.976]                         }
[10:32:54.976]                         frame <- frame + 1L
[10:32:54.976]                         envir <- sys.frame(frame)
[10:32:54.976]                       }
[10:32:54.976]                     }
[10:32:54.976]                     sendCondition <<- function(cond) NULL
[10:32:54.976]                   }
[10:32:54.976]                 })
[10:32:54.976]                 withCallingHandlers({
[10:32:54.976]                   {
[10:32:54.976]                     4
[10:32:54.976]                   }
[10:32:54.976]                 }, immediateCondition = function(cond) {
[10:32:54.976]                   sendCondition <- ...future.makeSendCondition()
[10:32:54.976]                   sendCondition(cond)
[10:32:54.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.976]                   {
[10:32:54.976]                     inherits <- base::inherits
[10:32:54.976]                     invokeRestart <- base::invokeRestart
[10:32:54.976]                     is.null <- base::is.null
[10:32:54.976]                     muffled <- FALSE
[10:32:54.976]                     if (inherits(cond, "message")) {
[10:32:54.976]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:54.976]                       if (muffled) 
[10:32:54.976]                         invokeRestart("muffleMessage")
[10:32:54.976]                     }
[10:32:54.976]                     else if (inherits(cond, "warning")) {
[10:32:54.976]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:54.976]                       if (muffled) 
[10:32:54.976]                         invokeRestart("muffleWarning")
[10:32:54.976]                     }
[10:32:54.976]                     else if (inherits(cond, "condition")) {
[10:32:54.976]                       if (!is.null(pattern)) {
[10:32:54.976]                         computeRestarts <- base::computeRestarts
[10:32:54.976]                         grepl <- base::grepl
[10:32:54.976]                         restarts <- computeRestarts(cond)
[10:32:54.976]                         for (restart in restarts) {
[10:32:54.976]                           name <- restart$name
[10:32:54.976]                           if (is.null(name)) 
[10:32:54.976]                             next
[10:32:54.976]                           if (!grepl(pattern, name)) 
[10:32:54.976]                             next
[10:32:54.976]                           invokeRestart(restart)
[10:32:54.976]                           muffled <- TRUE
[10:32:54.976]                           break
[10:32:54.976]                         }
[10:32:54.976]                       }
[10:32:54.976]                     }
[10:32:54.976]                     invisible(muffled)
[10:32:54.976]                   }
[10:32:54.976]                   muffleCondition(cond)
[10:32:54.976]                 })
[10:32:54.976]             }))
[10:32:54.976]             future::FutureResult(value = ...future.value$value, 
[10:32:54.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.976]                   ...future.rng), globalenv = if (FALSE) 
[10:32:54.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:54.976]                     ...future.globalenv.names))
[10:32:54.976]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:54.976]         }, condition = base::local({
[10:32:54.976]             c <- base::c
[10:32:54.976]             inherits <- base::inherits
[10:32:54.976]             invokeRestart <- base::invokeRestart
[10:32:54.976]             length <- base::length
[10:32:54.976]             list <- base::list
[10:32:54.976]             seq.int <- base::seq.int
[10:32:54.976]             signalCondition <- base::signalCondition
[10:32:54.976]             sys.calls <- base::sys.calls
[10:32:54.976]             `[[` <- base::`[[`
[10:32:54.976]             `+` <- base::`+`
[10:32:54.976]             `<<-` <- base::`<<-`
[10:32:54.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:54.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:54.976]                   3L)]
[10:32:54.976]             }
[10:32:54.976]             function(cond) {
[10:32:54.976]                 is_error <- inherits(cond, "error")
[10:32:54.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:54.976]                   NULL)
[10:32:54.976]                 if (is_error) {
[10:32:54.976]                   sessionInformation <- function() {
[10:32:54.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:54.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:54.976]                       search = base::search(), system = base::Sys.info())
[10:32:54.976]                   }
[10:32:54.976]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:54.976]                     cond$call), session = sessionInformation(), 
[10:32:54.976]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:54.976]                   signalCondition(cond)
[10:32:54.976]                 }
[10:32:54.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:54.976]                 "immediateCondition"))) {
[10:32:54.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:54.976]                   ...future.conditions[[length(...future.conditions) + 
[10:32:54.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:54.976]                   if (TRUE && !signal) {
[10:32:54.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.976]                     {
[10:32:54.976]                       inherits <- base::inherits
[10:32:54.976]                       invokeRestart <- base::invokeRestart
[10:32:54.976]                       is.null <- base::is.null
[10:32:54.976]                       muffled <- FALSE
[10:32:54.976]                       if (inherits(cond, "message")) {
[10:32:54.976]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.976]                         if (muffled) 
[10:32:54.976]                           invokeRestart("muffleMessage")
[10:32:54.976]                       }
[10:32:54.976]                       else if (inherits(cond, "warning")) {
[10:32:54.976]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.976]                         if (muffled) 
[10:32:54.976]                           invokeRestart("muffleWarning")
[10:32:54.976]                       }
[10:32:54.976]                       else if (inherits(cond, "condition")) {
[10:32:54.976]                         if (!is.null(pattern)) {
[10:32:54.976]                           computeRestarts <- base::computeRestarts
[10:32:54.976]                           grepl <- base::grepl
[10:32:54.976]                           restarts <- computeRestarts(cond)
[10:32:54.976]                           for (restart in restarts) {
[10:32:54.976]                             name <- restart$name
[10:32:54.976]                             if (is.null(name)) 
[10:32:54.976]                               next
[10:32:54.976]                             if (!grepl(pattern, name)) 
[10:32:54.976]                               next
[10:32:54.976]                             invokeRestart(restart)
[10:32:54.976]                             muffled <- TRUE
[10:32:54.976]                             break
[10:32:54.976]                           }
[10:32:54.976]                         }
[10:32:54.976]                       }
[10:32:54.976]                       invisible(muffled)
[10:32:54.976]                     }
[10:32:54.976]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.976]                   }
[10:32:54.976]                 }
[10:32:54.976]                 else {
[10:32:54.976]                   if (TRUE) {
[10:32:54.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:54.976]                     {
[10:32:54.976]                       inherits <- base::inherits
[10:32:54.976]                       invokeRestart <- base::invokeRestart
[10:32:54.976]                       is.null <- base::is.null
[10:32:54.976]                       muffled <- FALSE
[10:32:54.976]                       if (inherits(cond, "message")) {
[10:32:54.976]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:54.976]                         if (muffled) 
[10:32:54.976]                           invokeRestart("muffleMessage")
[10:32:54.976]                       }
[10:32:54.976]                       else if (inherits(cond, "warning")) {
[10:32:54.976]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:54.976]                         if (muffled) 
[10:32:54.976]                           invokeRestart("muffleWarning")
[10:32:54.976]                       }
[10:32:54.976]                       else if (inherits(cond, "condition")) {
[10:32:54.976]                         if (!is.null(pattern)) {
[10:32:54.976]                           computeRestarts <- base::computeRestarts
[10:32:54.976]                           grepl <- base::grepl
[10:32:54.976]                           restarts <- computeRestarts(cond)
[10:32:54.976]                           for (restart in restarts) {
[10:32:54.976]                             name <- restart$name
[10:32:54.976]                             if (is.null(name)) 
[10:32:54.976]                               next
[10:32:54.976]                             if (!grepl(pattern, name)) 
[10:32:54.976]                               next
[10:32:54.976]                             invokeRestart(restart)
[10:32:54.976]                             muffled <- TRUE
[10:32:54.976]                             break
[10:32:54.976]                           }
[10:32:54.976]                         }
[10:32:54.976]                       }
[10:32:54.976]                       invisible(muffled)
[10:32:54.976]                     }
[10:32:54.976]                     muffleCondition(cond, pattern = "^muffle")
[10:32:54.976]                   }
[10:32:54.976]                 }
[10:32:54.976]             }
[10:32:54.976]         }))
[10:32:54.976]     }, error = function(ex) {
[10:32:54.976]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:54.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:54.976]                 ...future.rng), started = ...future.startTime, 
[10:32:54.976]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:54.976]             version = "1.8"), class = "FutureResult")
[10:32:54.976]     }, finally = {
[10:32:54.976]         if (!identical(...future.workdir, getwd())) 
[10:32:54.976]             setwd(...future.workdir)
[10:32:54.976]         {
[10:32:54.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:54.976]                 ...future.oldOptions$nwarnings <- NULL
[10:32:54.976]             }
[10:32:54.976]             base::options(...future.oldOptions)
[10:32:54.976]             if (.Platform$OS.type == "windows") {
[10:32:54.976]                 old_names <- names(...future.oldEnvVars)
[10:32:54.976]                 envs <- base::Sys.getenv()
[10:32:54.976]                 names <- names(envs)
[10:32:54.976]                 common <- intersect(names, old_names)
[10:32:54.976]                 added <- setdiff(names, old_names)
[10:32:54.976]                 removed <- setdiff(old_names, names)
[10:32:54.976]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:54.976]                   envs[common]]
[10:32:54.976]                 NAMES <- toupper(changed)
[10:32:54.976]                 args <- list()
[10:32:54.976]                 for (kk in seq_along(NAMES)) {
[10:32:54.976]                   name <- changed[[kk]]
[10:32:54.976]                   NAME <- NAMES[[kk]]
[10:32:54.976]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.976]                     next
[10:32:54.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.976]                 }
[10:32:54.976]                 NAMES <- toupper(added)
[10:32:54.976]                 for (kk in seq_along(NAMES)) {
[10:32:54.976]                   name <- added[[kk]]
[10:32:54.976]                   NAME <- NAMES[[kk]]
[10:32:54.976]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.976]                     next
[10:32:54.976]                   args[[name]] <- ""
[10:32:54.976]                 }
[10:32:54.976]                 NAMES <- toupper(removed)
[10:32:54.976]                 for (kk in seq_along(NAMES)) {
[10:32:54.976]                   name <- removed[[kk]]
[10:32:54.976]                   NAME <- NAMES[[kk]]
[10:32:54.976]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:54.976]                     next
[10:32:54.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:54.976]                 }
[10:32:54.976]                 if (length(args) > 0) 
[10:32:54.976]                   base::do.call(base::Sys.setenv, args = args)
[10:32:54.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:54.976]             }
[10:32:54.976]             else {
[10:32:54.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:54.976]             }
[10:32:54.976]             {
[10:32:54.976]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:54.976]                   0L) {
[10:32:54.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:54.976]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:54.976]                   base::options(opts)
[10:32:54.976]                 }
[10:32:54.976]                 {
[10:32:54.976]                   {
[10:32:54.976]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:54.976]                     NULL
[10:32:54.976]                   }
[10:32:54.976]                   options(future.plan = NULL)
[10:32:54.976]                   if (is.na(NA_character_)) 
[10:32:54.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:54.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:54.976]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:54.976]                     .init = FALSE)
[10:32:54.976]                 }
[10:32:54.976]             }
[10:32:54.976]         }
[10:32:54.976]     })
[10:32:54.976]     if (TRUE) {
[10:32:54.976]         base::sink(type = "output", split = FALSE)
[10:32:54.976]         if (TRUE) {
[10:32:54.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:54.976]         }
[10:32:54.976]         else {
[10:32:54.976]             ...future.result["stdout"] <- base::list(NULL)
[10:32:54.976]         }
[10:32:54.976]         base::close(...future.stdout)
[10:32:54.976]         ...future.stdout <- NULL
[10:32:54.976]     }
[10:32:54.976]     ...future.result$conditions <- ...future.conditions
[10:32:54.976]     ...future.result$finished <- base::Sys.time()
[10:32:54.976]     ...future.result
[10:32:54.976] }
[10:32:54.979] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:54.989] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.989] - Validating connection of MultisessionFuture
[10:32:54.990] - received message: FutureResult
[10:32:54.990] - Received FutureResult
[10:32:54.990] - Erased future from FutureRegistry
[10:32:54.990] result() for ClusterFuture ...
[10:32:54.990] - result already collected: FutureResult
[10:32:54.990] result() for ClusterFuture ... done
[10:32:54.990] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.990] result() for ClusterFuture ...
[10:32:54.990] - result already collected: FutureResult
[10:32:54.990] result() for ClusterFuture ... done
[10:32:54.991] result() for ClusterFuture ...
[10:32:54.991] - result already collected: FutureResult
[10:32:54.991] result() for ClusterFuture ... done
[10:32:54.992] MultisessionFuture started
[10:32:54.992] - Launch lazy future ... done
[10:32:54.992] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652d1c9a958> 
Classes 'listenv', 'environment' <environment: 0x5652d2b66090> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:54.997] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.997] - Validating connection of MultisessionFuture
[10:32:54.997] - received message: FutureResult
[10:32:54.997] - Received FutureResult
[10:32:54.998] - Erased future from FutureRegistry
[10:32:54.998] result() for ClusterFuture ...
[10:32:54.998] - result already collected: FutureResult
[10:32:54.998] result() for ClusterFuture ... done
[10:32:54.998] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:54.998] receiveMessageFromWorker() for ClusterFuture ...
[10:32:54.998] - Validating connection of MultisessionFuture
[10:32:54.999] - received message: FutureResult
[10:32:54.999] - Received FutureResult
[10:32:54.999] - Erased future from FutureRegistry
[10:32:54.999] result() for ClusterFuture ...
[10:32:54.999] - result already collected: FutureResult
[10:32:54.999] result() for ClusterFuture ... done
[10:32:54.999] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:55.005] resolve() on list environment ...
[10:32:55.005]  recursive: 0
[10:32:55.006]  length: 6
[10:32:55.006]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:55.006] signalConditionsASAP(numeric, pos=1) ...
[10:32:55.006] - nx: 6
[10:32:55.006] - relay: TRUE
[10:32:55.006] - stdout: TRUE
[10:32:55.006] - signal: TRUE
[10:32:55.007] - resignal: FALSE
[10:32:55.007] - force: TRUE
[10:32:55.007] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.007] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.007]  - until=2
[10:32:55.007]  - relaying element #2
[10:32:55.007] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.007] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.007] signalConditionsASAP(NULL, pos=1) ... done
[10:32:55.007]  length: 5 (resolved future 1)
[10:32:55.007] Future #2
[10:32:55.008] result() for ClusterFuture ...
[10:32:55.008] - result already collected: FutureResult
[10:32:55.008] result() for ClusterFuture ... done
[10:32:55.008] result() for ClusterFuture ...
[10:32:55.008] - result already collected: FutureResult
[10:32:55.008] result() for ClusterFuture ... done
[10:32:55.008] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:55.008] - nx: 6
[10:32:55.008] - relay: TRUE
[10:32:55.008] - stdout: TRUE
[10:32:55.008] - signal: TRUE
[10:32:55.009] - resignal: FALSE
[10:32:55.009] - force: TRUE
[10:32:55.009] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.009] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.009]  - until=2
[10:32:55.009]  - relaying element #2
[10:32:55.009] result() for ClusterFuture ...
[10:32:55.009] - result already collected: FutureResult
[10:32:55.009] result() for ClusterFuture ... done
[10:32:55.009] result() for ClusterFuture ...
[10:32:55.009] - result already collected: FutureResult
[10:32:55.009] result() for ClusterFuture ... done
[10:32:55.010] result() for ClusterFuture ...
[10:32:55.010] - result already collected: FutureResult
[10:32:55.010] result() for ClusterFuture ... done
[10:32:55.010] result() for ClusterFuture ...
[10:32:55.010] - result already collected: FutureResult
[10:32:55.010] result() for ClusterFuture ... done
[10:32:55.010] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.010] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.010] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:55.010]  length: 4 (resolved future 2)
[10:32:55.011] Future #3
[10:32:55.011] result() for ClusterFuture ...
[10:32:55.011] - result already collected: FutureResult
[10:32:55.011] result() for ClusterFuture ... done
[10:32:55.011] result() for ClusterFuture ...
[10:32:55.011] - result already collected: FutureResult
[10:32:55.011] result() for ClusterFuture ... done
[10:32:55.011] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:55.011] - nx: 6
[10:32:55.011] - relay: TRUE
[10:32:55.011] - stdout: TRUE
[10:32:55.011] - signal: TRUE
[10:32:55.012] - resignal: FALSE
[10:32:55.012] - force: TRUE
[10:32:55.012] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.012] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.012]  - until=3
[10:32:55.012]  - relaying element #3
[10:32:55.012] result() for ClusterFuture ...
[10:32:55.012] - result already collected: FutureResult
[10:32:55.012] result() for ClusterFuture ... done
[10:32:55.012] result() for ClusterFuture ...
[10:32:55.012] - result already collected: FutureResult
[10:32:55.012] result() for ClusterFuture ... done
[10:32:55.013] result() for ClusterFuture ...
[10:32:55.013] - result already collected: FutureResult
[10:32:55.013] result() for ClusterFuture ... done
[10:32:55.013] result() for ClusterFuture ...
[10:32:55.013] - result already collected: FutureResult
[10:32:55.013] result() for ClusterFuture ... done
[10:32:55.013] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.013] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.013] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:55.013]  length: 3 (resolved future 3)
[10:32:55.013] Future #4
[10:32:55.014] result() for ClusterFuture ...
[10:32:55.014] - result already collected: FutureResult
[10:32:55.014] result() for ClusterFuture ... done
[10:32:55.014] result() for ClusterFuture ...
[10:32:55.014] - result already collected: FutureResult
[10:32:55.014] result() for ClusterFuture ... done
[10:32:55.014] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:55.014] - nx: 6
[10:32:55.014] - relay: TRUE
[10:32:55.014] - stdout: TRUE
[10:32:55.014] - signal: TRUE
[10:32:55.015] - resignal: FALSE
[10:32:55.015] - force: TRUE
[10:32:55.015] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.015] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.015]  - until=4
[10:32:55.015]  - relaying element #4
[10:32:55.015] result() for ClusterFuture ...
[10:32:55.015] - result already collected: FutureResult
[10:32:55.015] result() for ClusterFuture ... done
[10:32:55.015] result() for ClusterFuture ...
[10:32:55.015] - result already collected: FutureResult
[10:32:55.015] result() for ClusterFuture ... done
[10:32:55.016] result() for ClusterFuture ...
[10:32:55.016] - result already collected: FutureResult
[10:32:55.016] result() for ClusterFuture ... done
[10:32:55.016] result() for ClusterFuture ...
[10:32:55.016] - result already collected: FutureResult
[10:32:55.016] result() for ClusterFuture ... done
[10:32:55.016] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.016] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.016] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:55.016]  length: 2 (resolved future 4)
[10:32:55.016] signalConditionsASAP(NULL, pos=5) ...
[10:32:55.017] - nx: 6
[10:32:55.017] - relay: TRUE
[10:32:55.017] - stdout: TRUE
[10:32:55.017] - signal: TRUE
[10:32:55.017] - resignal: FALSE
[10:32:55.017] - force: TRUE
[10:32:55.017] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.017] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.017]  - until=6
[10:32:55.017]  - relaying element #6
[10:32:55.017] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:55.017] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.018] signalConditionsASAP(NULL, pos=5) ... done
[10:32:55.018]  length: 1 (resolved future 5)
[10:32:55.018] signalConditionsASAP(numeric, pos=6) ...
[10:32:55.018] - nx: 6
[10:32:55.018] - relay: TRUE
[10:32:55.018] - stdout: TRUE
[10:32:55.018] - signal: TRUE
[10:32:55.018] - resignal: FALSE
[10:32:55.018] - force: TRUE
[10:32:55.018] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:55.018] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.019]  - until=6
[10:32:55.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:55.019] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.019] signalConditionsASAP(numeric, pos=6) ... done
[10:32:55.019]  length: 0 (resolved future 6)
[10:32:55.019] Relaying remaining futures
[10:32:55.019] signalConditionsASAP(NULL, pos=0) ...
[10:32:55.019] - nx: 6
[10:32:55.019] - relay: TRUE
[10:32:55.019] - stdout: TRUE
[10:32:55.019] - signal: TRUE
[10:32:55.019] - resignal: FALSE
[10:32:55.020] - force: TRUE
[10:32:55.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:55.020] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:55.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:55.020] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.020] signalConditionsASAP(NULL, pos=0) ... done
[10:32:55.020] resolve() on list environment ... DONE
[10:32:55.020] result() for ClusterFuture ...
[10:32:55.020] - result already collected: FutureResult
[10:32:55.020] result() for ClusterFuture ... done
[10:32:55.021] result() for ClusterFuture ...
[10:32:55.021] - result already collected: FutureResult
[10:32:55.021] result() for ClusterFuture ... done
[10:32:55.021] result() for ClusterFuture ...
[10:32:55.021] - result already collected: FutureResult
[10:32:55.021] result() for ClusterFuture ... done
[10:32:55.021] result() for ClusterFuture ...
[10:32:55.021] - result already collected: FutureResult
[10:32:55.021] result() for ClusterFuture ... done
[10:32:55.021] result() for ClusterFuture ...
[10:32:55.022] - result already collected: FutureResult
[10:32:55.022] result() for ClusterFuture ... done
[10:32:55.022] result() for ClusterFuture ...
[10:32:55.022] - result already collected: FutureResult
[10:32:55.022] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d161e880> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:32:55.024] getGlobalsAndPackages() ...
[10:32:55.024] Searching for globals...
[10:32:55.024] 
[10:32:55.024] Searching for globals ... DONE
[10:32:55.024] - globals: [0] <none>
[10:32:55.025] getGlobalsAndPackages() ... DONE
[10:32:55.025] run() for ‘Future’ ...
[10:32:55.025] - state: ‘created’
[10:32:55.025] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:55.039] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:55.039] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:55.039]   - Field: ‘node’
[10:32:55.039]   - Field: ‘label’
[10:32:55.040]   - Field: ‘local’
[10:32:55.040]   - Field: ‘owner’
[10:32:55.040]   - Field: ‘envir’
[10:32:55.040]   - Field: ‘workers’
[10:32:55.040]   - Field: ‘packages’
[10:32:55.040]   - Field: ‘gc’
[10:32:55.040]   - Field: ‘conditions’
[10:32:55.040]   - Field: ‘persistent’
[10:32:55.040]   - Field: ‘expr’
[10:32:55.040]   - Field: ‘uuid’
[10:32:55.040]   - Field: ‘seed’
[10:32:55.041]   - Field: ‘version’
[10:32:55.041]   - Field: ‘result’
[10:32:55.041]   - Field: ‘asynchronous’
[10:32:55.041]   - Field: ‘calls’
[10:32:55.041]   - Field: ‘globals’
[10:32:55.041]   - Field: ‘stdout’
[10:32:55.041]   - Field: ‘earlySignal’
[10:32:55.041]   - Field: ‘lazy’
[10:32:55.041]   - Field: ‘state’
[10:32:55.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:55.042] - Launch lazy future ...
[10:32:55.042] Packages needed by the future expression (n = 0): <none>
[10:32:55.042] Packages needed by future strategies (n = 0): <none>
[10:32:55.042] {
[10:32:55.042]     {
[10:32:55.042]         {
[10:32:55.042]             ...future.startTime <- base::Sys.time()
[10:32:55.042]             {
[10:32:55.042]                 {
[10:32:55.042]                   {
[10:32:55.042]                     {
[10:32:55.042]                       base::local({
[10:32:55.042]                         has_future <- base::requireNamespace("future", 
[10:32:55.042]                           quietly = TRUE)
[10:32:55.042]                         if (has_future) {
[10:32:55.042]                           ns <- base::getNamespace("future")
[10:32:55.042]                           version <- ns[[".package"]][["version"]]
[10:32:55.042]                           if (is.null(version)) 
[10:32:55.042]                             version <- utils::packageVersion("future")
[10:32:55.042]                         }
[10:32:55.042]                         else {
[10:32:55.042]                           version <- NULL
[10:32:55.042]                         }
[10:32:55.042]                         if (!has_future || version < "1.8.0") {
[10:32:55.042]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:55.042]                             "", base::R.version$version.string), 
[10:32:55.042]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:55.042]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:55.042]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:55.042]                               "release", "version")], collapse = " "), 
[10:32:55.042]                             hostname = base::Sys.info()[["nodename"]])
[10:32:55.042]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:55.042]                             info)
[10:32:55.042]                           info <- base::paste(info, collapse = "; ")
[10:32:55.042]                           if (!has_future) {
[10:32:55.042]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:55.042]                               info)
[10:32:55.042]                           }
[10:32:55.042]                           else {
[10:32:55.042]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:55.042]                               info, version)
[10:32:55.042]                           }
[10:32:55.042]                           base::stop(msg)
[10:32:55.042]                         }
[10:32:55.042]                       })
[10:32:55.042]                     }
[10:32:55.042]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:55.042]                     base::options(mc.cores = 1L)
[10:32:55.042]                   }
[10:32:55.042]                   ...future.strategy.old <- future::plan("list")
[10:32:55.042]                   options(future.plan = NULL)
[10:32:55.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:55.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:55.042]                 }
[10:32:55.042]                 ...future.workdir <- getwd()
[10:32:55.042]             }
[10:32:55.042]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:55.042]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:55.042]         }
[10:32:55.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:55.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:55.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:55.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:55.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:55.042]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:55.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:55.042]             base::names(...future.oldOptions))
[10:32:55.042]     }
[10:32:55.042]     if (FALSE) {
[10:32:55.042]     }
[10:32:55.042]     else {
[10:32:55.042]         if (TRUE) {
[10:32:55.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:55.042]                 open = "w")
[10:32:55.042]         }
[10:32:55.042]         else {
[10:32:55.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:55.042]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:55.042]         }
[10:32:55.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:55.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:55.042]             base::sink(type = "output", split = FALSE)
[10:32:55.042]             base::close(...future.stdout)
[10:32:55.042]         }, add = TRUE)
[10:32:55.042]     }
[10:32:55.042]     ...future.frame <- base::sys.nframe()
[10:32:55.042]     ...future.conditions <- base::list()
[10:32:55.042]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:55.042]     if (FALSE) {
[10:32:55.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:55.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:55.042]     }
[10:32:55.042]     ...future.result <- base::tryCatch({
[10:32:55.042]         base::withCallingHandlers({
[10:32:55.042]             ...future.value <- base::withVisible(base::local({
[10:32:55.042]                 ...future.makeSendCondition <- base::local({
[10:32:55.042]                   sendCondition <- NULL
[10:32:55.042]                   function(frame = 1L) {
[10:32:55.042]                     if (is.function(sendCondition)) 
[10:32:55.042]                       return(sendCondition)
[10:32:55.042]                     ns <- getNamespace("parallel")
[10:32:55.042]                     if (exists("sendData", mode = "function", 
[10:32:55.042]                       envir = ns)) {
[10:32:55.042]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:55.042]                         envir = ns)
[10:32:55.042]                       envir <- sys.frame(frame)
[10:32:55.042]                       master <- NULL
[10:32:55.042]                       while (!identical(envir, .GlobalEnv) && 
[10:32:55.042]                         !identical(envir, emptyenv())) {
[10:32:55.042]                         if (exists("master", mode = "list", envir = envir, 
[10:32:55.042]                           inherits = FALSE)) {
[10:32:55.042]                           master <- get("master", mode = "list", 
[10:32:55.042]                             envir = envir, inherits = FALSE)
[10:32:55.042]                           if (inherits(master, c("SOCKnode", 
[10:32:55.042]                             "SOCK0node"))) {
[10:32:55.042]                             sendCondition <<- function(cond) {
[10:32:55.042]                               data <- list(type = "VALUE", value = cond, 
[10:32:55.042]                                 success = TRUE)
[10:32:55.042]                               parallel_sendData(master, data)
[10:32:55.042]                             }
[10:32:55.042]                             return(sendCondition)
[10:32:55.042]                           }
[10:32:55.042]                         }
[10:32:55.042]                         frame <- frame + 1L
[10:32:55.042]                         envir <- sys.frame(frame)
[10:32:55.042]                       }
[10:32:55.042]                     }
[10:32:55.042]                     sendCondition <<- function(cond) NULL
[10:32:55.042]                   }
[10:32:55.042]                 })
[10:32:55.042]                 withCallingHandlers({
[10:32:55.042]                   2
[10:32:55.042]                 }, immediateCondition = function(cond) {
[10:32:55.042]                   sendCondition <- ...future.makeSendCondition()
[10:32:55.042]                   sendCondition(cond)
[10:32:55.042]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.042]                   {
[10:32:55.042]                     inherits <- base::inherits
[10:32:55.042]                     invokeRestart <- base::invokeRestart
[10:32:55.042]                     is.null <- base::is.null
[10:32:55.042]                     muffled <- FALSE
[10:32:55.042]                     if (inherits(cond, "message")) {
[10:32:55.042]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:55.042]                       if (muffled) 
[10:32:55.042]                         invokeRestart("muffleMessage")
[10:32:55.042]                     }
[10:32:55.042]                     else if (inherits(cond, "warning")) {
[10:32:55.042]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:55.042]                       if (muffled) 
[10:32:55.042]                         invokeRestart("muffleWarning")
[10:32:55.042]                     }
[10:32:55.042]                     else if (inherits(cond, "condition")) {
[10:32:55.042]                       if (!is.null(pattern)) {
[10:32:55.042]                         computeRestarts <- base::computeRestarts
[10:32:55.042]                         grepl <- base::grepl
[10:32:55.042]                         restarts <- computeRestarts(cond)
[10:32:55.042]                         for (restart in restarts) {
[10:32:55.042]                           name <- restart$name
[10:32:55.042]                           if (is.null(name)) 
[10:32:55.042]                             next
[10:32:55.042]                           if (!grepl(pattern, name)) 
[10:32:55.042]                             next
[10:32:55.042]                           invokeRestart(restart)
[10:32:55.042]                           muffled <- TRUE
[10:32:55.042]                           break
[10:32:55.042]                         }
[10:32:55.042]                       }
[10:32:55.042]                     }
[10:32:55.042]                     invisible(muffled)
[10:32:55.042]                   }
[10:32:55.042]                   muffleCondition(cond)
[10:32:55.042]                 })
[10:32:55.042]             }))
[10:32:55.042]             future::FutureResult(value = ...future.value$value, 
[10:32:55.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:55.042]                   ...future.rng), globalenv = if (FALSE) 
[10:32:55.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:55.042]                     ...future.globalenv.names))
[10:32:55.042]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:55.042]         }, condition = base::local({
[10:32:55.042]             c <- base::c
[10:32:55.042]             inherits <- base::inherits
[10:32:55.042]             invokeRestart <- base::invokeRestart
[10:32:55.042]             length <- base::length
[10:32:55.042]             list <- base::list
[10:32:55.042]             seq.int <- base::seq.int
[10:32:55.042]             signalCondition <- base::signalCondition
[10:32:55.042]             sys.calls <- base::sys.calls
[10:32:55.042]             `[[` <- base::`[[`
[10:32:55.042]             `+` <- base::`+`
[10:32:55.042]             `<<-` <- base::`<<-`
[10:32:55.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:55.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:55.042]                   3L)]
[10:32:55.042]             }
[10:32:55.042]             function(cond) {
[10:32:55.042]                 is_error <- inherits(cond, "error")
[10:32:55.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:55.042]                   NULL)
[10:32:55.042]                 if (is_error) {
[10:32:55.042]                   sessionInformation <- function() {
[10:32:55.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:55.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:55.042]                       search = base::search(), system = base::Sys.info())
[10:32:55.042]                   }
[10:32:55.042]                   ...future.conditions[[length(...future.conditions) + 
[10:32:55.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:55.042]                     cond$call), session = sessionInformation(), 
[10:32:55.042]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:55.042]                   signalCondition(cond)
[10:32:55.042]                 }
[10:32:55.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:55.042]                 "immediateCondition"))) {
[10:32:55.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:55.042]                   ...future.conditions[[length(...future.conditions) + 
[10:32:55.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:55.042]                   if (TRUE && !signal) {
[10:32:55.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.042]                     {
[10:32:55.042]                       inherits <- base::inherits
[10:32:55.042]                       invokeRestart <- base::invokeRestart
[10:32:55.042]                       is.null <- base::is.null
[10:32:55.042]                       muffled <- FALSE
[10:32:55.042]                       if (inherits(cond, "message")) {
[10:32:55.042]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:55.042]                         if (muffled) 
[10:32:55.042]                           invokeRestart("muffleMessage")
[10:32:55.042]                       }
[10:32:55.042]                       else if (inherits(cond, "warning")) {
[10:32:55.042]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:55.042]                         if (muffled) 
[10:32:55.042]                           invokeRestart("muffleWarning")
[10:32:55.042]                       }
[10:32:55.042]                       else if (inherits(cond, "condition")) {
[10:32:55.042]                         if (!is.null(pattern)) {
[10:32:55.042]                           computeRestarts <- base::computeRestarts
[10:32:55.042]                           grepl <- base::grepl
[10:32:55.042]                           restarts <- computeRestarts(cond)
[10:32:55.042]                           for (restart in restarts) {
[10:32:55.042]                             name <- restart$name
[10:32:55.042]                             if (is.null(name)) 
[10:32:55.042]                               next
[10:32:55.042]                             if (!grepl(pattern, name)) 
[10:32:55.042]                               next
[10:32:55.042]                             invokeRestart(restart)
[10:32:55.042]                             muffled <- TRUE
[10:32:55.042]                             break
[10:32:55.042]                           }
[10:32:55.042]                         }
[10:32:55.042]                       }
[10:32:55.042]                       invisible(muffled)
[10:32:55.042]                     }
[10:32:55.042]                     muffleCondition(cond, pattern = "^muffle")
[10:32:55.042]                   }
[10:32:55.042]                 }
[10:32:55.042]                 else {
[10:32:55.042]                   if (TRUE) {
[10:32:55.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.042]                     {
[10:32:55.042]                       inherits <- base::inherits
[10:32:55.042]                       invokeRestart <- base::invokeRestart
[10:32:55.042]                       is.null <- base::is.null
[10:32:55.042]                       muffled <- FALSE
[10:32:55.042]                       if (inherits(cond, "message")) {
[10:32:55.042]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:55.042]                         if (muffled) 
[10:32:55.042]                           invokeRestart("muffleMessage")
[10:32:55.042]                       }
[10:32:55.042]                       else if (inherits(cond, "warning")) {
[10:32:55.042]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:55.042]                         if (muffled) 
[10:32:55.042]                           invokeRestart("muffleWarning")
[10:32:55.042]                       }
[10:32:55.042]                       else if (inherits(cond, "condition")) {
[10:32:55.042]                         if (!is.null(pattern)) {
[10:32:55.042]                           computeRestarts <- base::computeRestarts
[10:32:55.042]                           grepl <- base::grepl
[10:32:55.042]                           restarts <- computeRestarts(cond)
[10:32:55.042]                           for (restart in restarts) {
[10:32:55.042]                             name <- restart$name
[10:32:55.042]                             if (is.null(name)) 
[10:32:55.042]                               next
[10:32:55.042]                             if (!grepl(pattern, name)) 
[10:32:55.042]                               next
[10:32:55.042]                             invokeRestart(restart)
[10:32:55.042]                             muffled <- TRUE
[10:32:55.042]                             break
[10:32:55.042]                           }
[10:32:55.042]                         }
[10:32:55.042]                       }
[10:32:55.042]                       invisible(muffled)
[10:32:55.042]                     }
[10:32:55.042]                     muffleCondition(cond, pattern = "^muffle")
[10:32:55.042]                   }
[10:32:55.042]                 }
[10:32:55.042]             }
[10:32:55.042]         }))
[10:32:55.042]     }, error = function(ex) {
[10:32:55.042]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:55.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:55.042]                 ...future.rng), started = ...future.startTime, 
[10:32:55.042]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:55.042]             version = "1.8"), class = "FutureResult")
[10:32:55.042]     }, finally = {
[10:32:55.042]         if (!identical(...future.workdir, getwd())) 
[10:32:55.042]             setwd(...future.workdir)
[10:32:55.042]         {
[10:32:55.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:55.042]                 ...future.oldOptions$nwarnings <- NULL
[10:32:55.042]             }
[10:32:55.042]             base::options(...future.oldOptions)
[10:32:55.042]             if (.Platform$OS.type == "windows") {
[10:32:55.042]                 old_names <- names(...future.oldEnvVars)
[10:32:55.042]                 envs <- base::Sys.getenv()
[10:32:55.042]                 names <- names(envs)
[10:32:55.042]                 common <- intersect(names, old_names)
[10:32:55.042]                 added <- setdiff(names, old_names)
[10:32:55.042]                 removed <- setdiff(old_names, names)
[10:32:55.042]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:55.042]                   envs[common]]
[10:32:55.042]                 NAMES <- toupper(changed)
[10:32:55.042]                 args <- list()
[10:32:55.042]                 for (kk in seq_along(NAMES)) {
[10:32:55.042]                   name <- changed[[kk]]
[10:32:55.042]                   NAME <- NAMES[[kk]]
[10:32:55.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.042]                     next
[10:32:55.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:55.042]                 }
[10:32:55.042]                 NAMES <- toupper(added)
[10:32:55.042]                 for (kk in seq_along(NAMES)) {
[10:32:55.042]                   name <- added[[kk]]
[10:32:55.042]                   NAME <- NAMES[[kk]]
[10:32:55.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.042]                     next
[10:32:55.042]                   args[[name]] <- ""
[10:32:55.042]                 }
[10:32:55.042]                 NAMES <- toupper(removed)
[10:32:55.042]                 for (kk in seq_along(NAMES)) {
[10:32:55.042]                   name <- removed[[kk]]
[10:32:55.042]                   NAME <- NAMES[[kk]]
[10:32:55.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.042]                     next
[10:32:55.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:55.042]                 }
[10:32:55.042]                 if (length(args) > 0) 
[10:32:55.042]                   base::do.call(base::Sys.setenv, args = args)
[10:32:55.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:55.042]             }
[10:32:55.042]             else {
[10:32:55.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:55.042]             }
[10:32:55.042]             {
[10:32:55.042]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:55.042]                   0L) {
[10:32:55.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:55.042]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:55.042]                   base::options(opts)
[10:32:55.042]                 }
[10:32:55.042]                 {
[10:32:55.042]                   {
[10:32:55.042]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:55.042]                     NULL
[10:32:55.042]                   }
[10:32:55.042]                   options(future.plan = NULL)
[10:32:55.042]                   if (is.na(NA_character_)) 
[10:32:55.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:55.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:55.042]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:55.042]                     .init = FALSE)
[10:32:55.042]                 }
[10:32:55.042]             }
[10:32:55.042]         }
[10:32:55.042]     })
[10:32:55.042]     if (TRUE) {
[10:32:55.042]         base::sink(type = "output", split = FALSE)
[10:32:55.042]         if (TRUE) {
[10:32:55.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:55.042]         }
[10:32:55.042]         else {
[10:32:55.042]             ...future.result["stdout"] <- base::list(NULL)
[10:32:55.042]         }
[10:32:55.042]         base::close(...future.stdout)
[10:32:55.042]         ...future.stdout <- NULL
[10:32:55.042]     }
[10:32:55.042]     ...future.result$conditions <- ...future.conditions
[10:32:55.042]     ...future.result$finished <- base::Sys.time()
[10:32:55.042]     ...future.result
[10:32:55.042] }
[10:32:55.045] MultisessionFuture started
[10:32:55.045] - Launch lazy future ... done
[10:32:55.046] run() for ‘MultisessionFuture’ ... done
[10:32:55.046] getGlobalsAndPackages() ...
[10:32:55.046] Searching for globals...
[10:32:55.046] 
[10:32:55.047] Searching for globals ... DONE
[10:32:55.047] - globals: [0] <none>
[10:32:55.047] getGlobalsAndPackages() ... DONE
[10:32:55.047] run() for ‘Future’ ...
[10:32:55.047] - state: ‘created’
[10:32:55.048] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:55.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:55.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:55.061]   - Field: ‘node’
[10:32:55.061]   - Field: ‘label’
[10:32:55.062]   - Field: ‘local’
[10:32:55.062]   - Field: ‘owner’
[10:32:55.062]   - Field: ‘envir’
[10:32:55.062]   - Field: ‘workers’
[10:32:55.062]   - Field: ‘packages’
[10:32:55.062]   - Field: ‘gc’
[10:32:55.062]   - Field: ‘conditions’
[10:32:55.062]   - Field: ‘persistent’
[10:32:55.062]   - Field: ‘expr’
[10:32:55.062]   - Field: ‘uuid’
[10:32:55.062]   - Field: ‘seed’
[10:32:55.063]   - Field: ‘version’
[10:32:55.063]   - Field: ‘result’
[10:32:55.063]   - Field: ‘asynchronous’
[10:32:55.063]   - Field: ‘calls’
[10:32:55.063]   - Field: ‘globals’
[10:32:55.063]   - Field: ‘stdout’
[10:32:55.063]   - Field: ‘earlySignal’
[10:32:55.063]   - Field: ‘lazy’
[10:32:55.063]   - Field: ‘state’
[10:32:55.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:55.064] - Launch lazy future ...
[10:32:55.064] Packages needed by the future expression (n = 0): <none>
[10:32:55.064] Packages needed by future strategies (n = 0): <none>
[10:32:55.064] {
[10:32:55.064]     {
[10:32:55.064]         {
[10:32:55.064]             ...future.startTime <- base::Sys.time()
[10:32:55.064]             {
[10:32:55.064]                 {
[10:32:55.064]                   {
[10:32:55.064]                     {
[10:32:55.064]                       base::local({
[10:32:55.064]                         has_future <- base::requireNamespace("future", 
[10:32:55.064]                           quietly = TRUE)
[10:32:55.064]                         if (has_future) {
[10:32:55.064]                           ns <- base::getNamespace("future")
[10:32:55.064]                           version <- ns[[".package"]][["version"]]
[10:32:55.064]                           if (is.null(version)) 
[10:32:55.064]                             version <- utils::packageVersion("future")
[10:32:55.064]                         }
[10:32:55.064]                         else {
[10:32:55.064]                           version <- NULL
[10:32:55.064]                         }
[10:32:55.064]                         if (!has_future || version < "1.8.0") {
[10:32:55.064]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:55.064]                             "", base::R.version$version.string), 
[10:32:55.064]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:55.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:55.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:55.064]                               "release", "version")], collapse = " "), 
[10:32:55.064]                             hostname = base::Sys.info()[["nodename"]])
[10:32:55.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:55.064]                             info)
[10:32:55.064]                           info <- base::paste(info, collapse = "; ")
[10:32:55.064]                           if (!has_future) {
[10:32:55.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:55.064]                               info)
[10:32:55.064]                           }
[10:32:55.064]                           else {
[10:32:55.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:55.064]                               info, version)
[10:32:55.064]                           }
[10:32:55.064]                           base::stop(msg)
[10:32:55.064]                         }
[10:32:55.064]                       })
[10:32:55.064]                     }
[10:32:55.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:55.064]                     base::options(mc.cores = 1L)
[10:32:55.064]                   }
[10:32:55.064]                   ...future.strategy.old <- future::plan("list")
[10:32:55.064]                   options(future.plan = NULL)
[10:32:55.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:55.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:55.064]                 }
[10:32:55.064]                 ...future.workdir <- getwd()
[10:32:55.064]             }
[10:32:55.064]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:55.064]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:55.064]         }
[10:32:55.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:55.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:55.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:55.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:55.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:55.064]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:55.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:55.064]             base::names(...future.oldOptions))
[10:32:55.064]     }
[10:32:55.064]     if (FALSE) {
[10:32:55.064]     }
[10:32:55.064]     else {
[10:32:55.064]         if (TRUE) {
[10:32:55.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:55.064]                 open = "w")
[10:32:55.064]         }
[10:32:55.064]         else {
[10:32:55.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:55.064]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:55.064]         }
[10:32:55.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:55.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:55.064]             base::sink(type = "output", split = FALSE)
[10:32:55.064]             base::close(...future.stdout)
[10:32:55.064]         }, add = TRUE)
[10:32:55.064]     }
[10:32:55.064]     ...future.frame <- base::sys.nframe()
[10:32:55.064]     ...future.conditions <- base::list()
[10:32:55.064]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:55.064]     if (FALSE) {
[10:32:55.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:55.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:55.064]     }
[10:32:55.064]     ...future.result <- base::tryCatch({
[10:32:55.064]         base::withCallingHandlers({
[10:32:55.064]             ...future.value <- base::withVisible(base::local({
[10:32:55.064]                 ...future.makeSendCondition <- base::local({
[10:32:55.064]                   sendCondition <- NULL
[10:32:55.064]                   function(frame = 1L) {
[10:32:55.064]                     if (is.function(sendCondition)) 
[10:32:55.064]                       return(sendCondition)
[10:32:55.064]                     ns <- getNamespace("parallel")
[10:32:55.064]                     if (exists("sendData", mode = "function", 
[10:32:55.064]                       envir = ns)) {
[10:32:55.064]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:55.064]                         envir = ns)
[10:32:55.064]                       envir <- sys.frame(frame)
[10:32:55.064]                       master <- NULL
[10:32:55.064]                       while (!identical(envir, .GlobalEnv) && 
[10:32:55.064]                         !identical(envir, emptyenv())) {
[10:32:55.064]                         if (exists("master", mode = "list", envir = envir, 
[10:32:55.064]                           inherits = FALSE)) {
[10:32:55.064]                           master <- get("master", mode = "list", 
[10:32:55.064]                             envir = envir, inherits = FALSE)
[10:32:55.064]                           if (inherits(master, c("SOCKnode", 
[10:32:55.064]                             "SOCK0node"))) {
[10:32:55.064]                             sendCondition <<- function(cond) {
[10:32:55.064]                               data <- list(type = "VALUE", value = cond, 
[10:32:55.064]                                 success = TRUE)
[10:32:55.064]                               parallel_sendData(master, data)
[10:32:55.064]                             }
[10:32:55.064]                             return(sendCondition)
[10:32:55.064]                           }
[10:32:55.064]                         }
[10:32:55.064]                         frame <- frame + 1L
[10:32:55.064]                         envir <- sys.frame(frame)
[10:32:55.064]                       }
[10:32:55.064]                     }
[10:32:55.064]                     sendCondition <<- function(cond) NULL
[10:32:55.064]                   }
[10:32:55.064]                 })
[10:32:55.064]                 withCallingHandlers({
[10:32:55.064]                   NULL
[10:32:55.064]                 }, immediateCondition = function(cond) {
[10:32:55.064]                   sendCondition <- ...future.makeSendCondition()
[10:32:55.064]                   sendCondition(cond)
[10:32:55.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.064]                   {
[10:32:55.064]                     inherits <- base::inherits
[10:32:55.064]                     invokeRestart <- base::invokeRestart
[10:32:55.064]                     is.null <- base::is.null
[10:32:55.064]                     muffled <- FALSE
[10:32:55.064]                     if (inherits(cond, "message")) {
[10:32:55.064]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:55.064]                       if (muffled) 
[10:32:55.064]                         invokeRestart("muffleMessage")
[10:32:55.064]                     }
[10:32:55.064]                     else if (inherits(cond, "warning")) {
[10:32:55.064]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:55.064]                       if (muffled) 
[10:32:55.064]                         invokeRestart("muffleWarning")
[10:32:55.064]                     }
[10:32:55.064]                     else if (inherits(cond, "condition")) {
[10:32:55.064]                       if (!is.null(pattern)) {
[10:32:55.064]                         computeRestarts <- base::computeRestarts
[10:32:55.064]                         grepl <- base::grepl
[10:32:55.064]                         restarts <- computeRestarts(cond)
[10:32:55.064]                         for (restart in restarts) {
[10:32:55.064]                           name <- restart$name
[10:32:55.064]                           if (is.null(name)) 
[10:32:55.064]                             next
[10:32:55.064]                           if (!grepl(pattern, name)) 
[10:32:55.064]                             next
[10:32:55.064]                           invokeRestart(restart)
[10:32:55.064]                           muffled <- TRUE
[10:32:55.064]                           break
[10:32:55.064]                         }
[10:32:55.064]                       }
[10:32:55.064]                     }
[10:32:55.064]                     invisible(muffled)
[10:32:55.064]                   }
[10:32:55.064]                   muffleCondition(cond)
[10:32:55.064]                 })
[10:32:55.064]             }))
[10:32:55.064]             future::FutureResult(value = ...future.value$value, 
[10:32:55.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:55.064]                   ...future.rng), globalenv = if (FALSE) 
[10:32:55.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:55.064]                     ...future.globalenv.names))
[10:32:55.064]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:55.064]         }, condition = base::local({
[10:32:55.064]             c <- base::c
[10:32:55.064]             inherits <- base::inherits
[10:32:55.064]             invokeRestart <- base::invokeRestart
[10:32:55.064]             length <- base::length
[10:32:55.064]             list <- base::list
[10:32:55.064]             seq.int <- base::seq.int
[10:32:55.064]             signalCondition <- base::signalCondition
[10:32:55.064]             sys.calls <- base::sys.calls
[10:32:55.064]             `[[` <- base::`[[`
[10:32:55.064]             `+` <- base::`+`
[10:32:55.064]             `<<-` <- base::`<<-`
[10:32:55.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:55.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:55.064]                   3L)]
[10:32:55.064]             }
[10:32:55.064]             function(cond) {
[10:32:55.064]                 is_error <- inherits(cond, "error")
[10:32:55.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:55.064]                   NULL)
[10:32:55.064]                 if (is_error) {
[10:32:55.064]                   sessionInformation <- function() {
[10:32:55.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:55.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:55.064]                       search = base::search(), system = base::Sys.info())
[10:32:55.064]                   }
[10:32:55.064]                   ...future.conditions[[length(...future.conditions) + 
[10:32:55.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:55.064]                     cond$call), session = sessionInformation(), 
[10:32:55.064]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:55.064]                   signalCondition(cond)
[10:32:55.064]                 }
[10:32:55.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:55.064]                 "immediateCondition"))) {
[10:32:55.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:55.064]                   ...future.conditions[[length(...future.conditions) + 
[10:32:55.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:55.064]                   if (TRUE && !signal) {
[10:32:55.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.064]                     {
[10:32:55.064]                       inherits <- base::inherits
[10:32:55.064]                       invokeRestart <- base::invokeRestart
[10:32:55.064]                       is.null <- base::is.null
[10:32:55.064]                       muffled <- FALSE
[10:32:55.064]                       if (inherits(cond, "message")) {
[10:32:55.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:55.064]                         if (muffled) 
[10:32:55.064]                           invokeRestart("muffleMessage")
[10:32:55.064]                       }
[10:32:55.064]                       else if (inherits(cond, "warning")) {
[10:32:55.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:55.064]                         if (muffled) 
[10:32:55.064]                           invokeRestart("muffleWarning")
[10:32:55.064]                       }
[10:32:55.064]                       else if (inherits(cond, "condition")) {
[10:32:55.064]                         if (!is.null(pattern)) {
[10:32:55.064]                           computeRestarts <- base::computeRestarts
[10:32:55.064]                           grepl <- base::grepl
[10:32:55.064]                           restarts <- computeRestarts(cond)
[10:32:55.064]                           for (restart in restarts) {
[10:32:55.064]                             name <- restart$name
[10:32:55.064]                             if (is.null(name)) 
[10:32:55.064]                               next
[10:32:55.064]                             if (!grepl(pattern, name)) 
[10:32:55.064]                               next
[10:32:55.064]                             invokeRestart(restart)
[10:32:55.064]                             muffled <- TRUE
[10:32:55.064]                             break
[10:32:55.064]                           }
[10:32:55.064]                         }
[10:32:55.064]                       }
[10:32:55.064]                       invisible(muffled)
[10:32:55.064]                     }
[10:32:55.064]                     muffleCondition(cond, pattern = "^muffle")
[10:32:55.064]                   }
[10:32:55.064]                 }
[10:32:55.064]                 else {
[10:32:55.064]                   if (TRUE) {
[10:32:55.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.064]                     {
[10:32:55.064]                       inherits <- base::inherits
[10:32:55.064]                       invokeRestart <- base::invokeRestart
[10:32:55.064]                       is.null <- base::is.null
[10:32:55.064]                       muffled <- FALSE
[10:32:55.064]                       if (inherits(cond, "message")) {
[10:32:55.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:55.064]                         if (muffled) 
[10:32:55.064]                           invokeRestart("muffleMessage")
[10:32:55.064]                       }
[10:32:55.064]                       else if (inherits(cond, "warning")) {
[10:32:55.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:55.064]                         if (muffled) 
[10:32:55.064]                           invokeRestart("muffleWarning")
[10:32:55.064]                       }
[10:32:55.064]                       else if (inherits(cond, "condition")) {
[10:32:55.064]                         if (!is.null(pattern)) {
[10:32:55.064]                           computeRestarts <- base::computeRestarts
[10:32:55.064]                           grepl <- base::grepl
[10:32:55.064]                           restarts <- computeRestarts(cond)
[10:32:55.064]                           for (restart in restarts) {
[10:32:55.064]                             name <- restart$name
[10:32:55.064]                             if (is.null(name)) 
[10:32:55.064]                               next
[10:32:55.064]                             if (!grepl(pattern, name)) 
[10:32:55.064]                               next
[10:32:55.064]                             invokeRestart(restart)
[10:32:55.064]                             muffled <- TRUE
[10:32:55.064]                             break
[10:32:55.064]                           }
[10:32:55.064]                         }
[10:32:55.064]                       }
[10:32:55.064]                       invisible(muffled)
[10:32:55.064]                     }
[10:32:55.064]                     muffleCondition(cond, pattern = "^muffle")
[10:32:55.064]                   }
[10:32:55.064]                 }
[10:32:55.064]             }
[10:32:55.064]         }))
[10:32:55.064]     }, error = function(ex) {
[10:32:55.064]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:55.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:55.064]                 ...future.rng), started = ...future.startTime, 
[10:32:55.064]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:55.064]             version = "1.8"), class = "FutureResult")
[10:32:55.064]     }, finally = {
[10:32:55.064]         if (!identical(...future.workdir, getwd())) 
[10:32:55.064]             setwd(...future.workdir)
[10:32:55.064]         {
[10:32:55.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:55.064]                 ...future.oldOptions$nwarnings <- NULL
[10:32:55.064]             }
[10:32:55.064]             base::options(...future.oldOptions)
[10:32:55.064]             if (.Platform$OS.type == "windows") {
[10:32:55.064]                 old_names <- names(...future.oldEnvVars)
[10:32:55.064]                 envs <- base::Sys.getenv()
[10:32:55.064]                 names <- names(envs)
[10:32:55.064]                 common <- intersect(names, old_names)
[10:32:55.064]                 added <- setdiff(names, old_names)
[10:32:55.064]                 removed <- setdiff(old_names, names)
[10:32:55.064]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:55.064]                   envs[common]]
[10:32:55.064]                 NAMES <- toupper(changed)
[10:32:55.064]                 args <- list()
[10:32:55.064]                 for (kk in seq_along(NAMES)) {
[10:32:55.064]                   name <- changed[[kk]]
[10:32:55.064]                   NAME <- NAMES[[kk]]
[10:32:55.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.064]                     next
[10:32:55.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:55.064]                 }
[10:32:55.064]                 NAMES <- toupper(added)
[10:32:55.064]                 for (kk in seq_along(NAMES)) {
[10:32:55.064]                   name <- added[[kk]]
[10:32:55.064]                   NAME <- NAMES[[kk]]
[10:32:55.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.064]                     next
[10:32:55.064]                   args[[name]] <- ""
[10:32:55.064]                 }
[10:32:55.064]                 NAMES <- toupper(removed)
[10:32:55.064]                 for (kk in seq_along(NAMES)) {
[10:32:55.064]                   name <- removed[[kk]]
[10:32:55.064]                   NAME <- NAMES[[kk]]
[10:32:55.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.064]                     next
[10:32:55.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:55.064]                 }
[10:32:55.064]                 if (length(args) > 0) 
[10:32:55.064]                   base::do.call(base::Sys.setenv, args = args)
[10:32:55.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:55.064]             }
[10:32:55.064]             else {
[10:32:55.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:55.064]             }
[10:32:55.064]             {
[10:32:55.064]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:55.064]                   0L) {
[10:32:55.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:55.064]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:55.064]                   base::options(opts)
[10:32:55.064]                 }
[10:32:55.064]                 {
[10:32:55.064]                   {
[10:32:55.064]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:55.064]                     NULL
[10:32:55.064]                   }
[10:32:55.064]                   options(future.plan = NULL)
[10:32:55.064]                   if (is.na(NA_character_)) 
[10:32:55.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:55.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:55.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:55.064]                     .init = FALSE)
[10:32:55.064]                 }
[10:32:55.064]             }
[10:32:55.064]         }
[10:32:55.064]     })
[10:32:55.064]     if (TRUE) {
[10:32:55.064]         base::sink(type = "output", split = FALSE)
[10:32:55.064]         if (TRUE) {
[10:32:55.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:55.064]         }
[10:32:55.064]         else {
[10:32:55.064]             ...future.result["stdout"] <- base::list(NULL)
[10:32:55.064]         }
[10:32:55.064]         base::close(...future.stdout)
[10:32:55.064]         ...future.stdout <- NULL
[10:32:55.064]     }
[10:32:55.064]     ...future.result$conditions <- ...future.conditions
[10:32:55.064]     ...future.result$finished <- base::Sys.time()
[10:32:55.064]     ...future.result
[10:32:55.064] }
[10:32:55.067] MultisessionFuture started
[10:32:55.067] - Launch lazy future ... done
[10:32:55.067] run() for ‘MultisessionFuture’ ... done
[10:32:55.068] getGlobalsAndPackages() ...
[10:32:55.068] Searching for globals...
[10:32:55.069] - globals found: [1] ‘{’
[10:32:55.069] Searching for globals ... DONE
[10:32:55.069] Resolving globals: FALSE
[10:32:55.069] 
[10:32:55.069] 
[10:32:55.069] getGlobalsAndPackages() ... DONE
[10:32:55.070] run() for ‘Future’ ...
[10:32:55.070] - state: ‘created’
[10:32:55.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:55.084] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:55.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:55.084]   - Field: ‘node’
[10:32:55.084]   - Field: ‘label’
[10:32:55.084]   - Field: ‘local’
[10:32:55.084]   - Field: ‘owner’
[10:32:55.084]   - Field: ‘envir’
[10:32:55.084]   - Field: ‘workers’
[10:32:55.084]   - Field: ‘packages’
[10:32:55.085]   - Field: ‘gc’
[10:32:55.085]   - Field: ‘conditions’
[10:32:55.085]   - Field: ‘persistent’
[10:32:55.085]   - Field: ‘expr’
[10:32:55.085]   - Field: ‘uuid’
[10:32:55.085]   - Field: ‘seed’
[10:32:55.085]   - Field: ‘version’
[10:32:55.085]   - Field: ‘result’
[10:32:55.085]   - Field: ‘asynchronous’
[10:32:55.085]   - Field: ‘calls’
[10:32:55.086]   - Field: ‘globals’
[10:32:55.086]   - Field: ‘stdout’
[10:32:55.086]   - Field: ‘earlySignal’
[10:32:55.086]   - Field: ‘lazy’
[10:32:55.086]   - Field: ‘state’
[10:32:55.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:55.086] - Launch lazy future ...
[10:32:55.086] Packages needed by the future expression (n = 0): <none>
[10:32:55.086] Packages needed by future strategies (n = 0): <none>
[10:32:55.087] {
[10:32:55.087]     {
[10:32:55.087]         {
[10:32:55.087]             ...future.startTime <- base::Sys.time()
[10:32:55.087]             {
[10:32:55.087]                 {
[10:32:55.087]                   {
[10:32:55.087]                     {
[10:32:55.087]                       base::local({
[10:32:55.087]                         has_future <- base::requireNamespace("future", 
[10:32:55.087]                           quietly = TRUE)
[10:32:55.087]                         if (has_future) {
[10:32:55.087]                           ns <- base::getNamespace("future")
[10:32:55.087]                           version <- ns[[".package"]][["version"]]
[10:32:55.087]                           if (is.null(version)) 
[10:32:55.087]                             version <- utils::packageVersion("future")
[10:32:55.087]                         }
[10:32:55.087]                         else {
[10:32:55.087]                           version <- NULL
[10:32:55.087]                         }
[10:32:55.087]                         if (!has_future || version < "1.8.0") {
[10:32:55.087]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:55.087]                             "", base::R.version$version.string), 
[10:32:55.087]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:55.087]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:55.087]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:55.087]                               "release", "version")], collapse = " "), 
[10:32:55.087]                             hostname = base::Sys.info()[["nodename"]])
[10:32:55.087]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:55.087]                             info)
[10:32:55.087]                           info <- base::paste(info, collapse = "; ")
[10:32:55.087]                           if (!has_future) {
[10:32:55.087]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:55.087]                               info)
[10:32:55.087]                           }
[10:32:55.087]                           else {
[10:32:55.087]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:55.087]                               info, version)
[10:32:55.087]                           }
[10:32:55.087]                           base::stop(msg)
[10:32:55.087]                         }
[10:32:55.087]                       })
[10:32:55.087]                     }
[10:32:55.087]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:55.087]                     base::options(mc.cores = 1L)
[10:32:55.087]                   }
[10:32:55.087]                   ...future.strategy.old <- future::plan("list")
[10:32:55.087]                   options(future.plan = NULL)
[10:32:55.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:55.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:55.087]                 }
[10:32:55.087]                 ...future.workdir <- getwd()
[10:32:55.087]             }
[10:32:55.087]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:55.087]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:55.087]         }
[10:32:55.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:55.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:55.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:55.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:55.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:55.087]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:55.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:55.087]             base::names(...future.oldOptions))
[10:32:55.087]     }
[10:32:55.087]     if (FALSE) {
[10:32:55.087]     }
[10:32:55.087]     else {
[10:32:55.087]         if (TRUE) {
[10:32:55.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:55.087]                 open = "w")
[10:32:55.087]         }
[10:32:55.087]         else {
[10:32:55.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:55.087]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:55.087]         }
[10:32:55.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:55.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:55.087]             base::sink(type = "output", split = FALSE)
[10:32:55.087]             base::close(...future.stdout)
[10:32:55.087]         }, add = TRUE)
[10:32:55.087]     }
[10:32:55.087]     ...future.frame <- base::sys.nframe()
[10:32:55.087]     ...future.conditions <- base::list()
[10:32:55.087]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:55.087]     if (FALSE) {
[10:32:55.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:55.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:55.087]     }
[10:32:55.087]     ...future.result <- base::tryCatch({
[10:32:55.087]         base::withCallingHandlers({
[10:32:55.087]             ...future.value <- base::withVisible(base::local({
[10:32:55.087]                 ...future.makeSendCondition <- base::local({
[10:32:55.087]                   sendCondition <- NULL
[10:32:55.087]                   function(frame = 1L) {
[10:32:55.087]                     if (is.function(sendCondition)) 
[10:32:55.087]                       return(sendCondition)
[10:32:55.087]                     ns <- getNamespace("parallel")
[10:32:55.087]                     if (exists("sendData", mode = "function", 
[10:32:55.087]                       envir = ns)) {
[10:32:55.087]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:55.087]                         envir = ns)
[10:32:55.087]                       envir <- sys.frame(frame)
[10:32:55.087]                       master <- NULL
[10:32:55.087]                       while (!identical(envir, .GlobalEnv) && 
[10:32:55.087]                         !identical(envir, emptyenv())) {
[10:32:55.087]                         if (exists("master", mode = "list", envir = envir, 
[10:32:55.087]                           inherits = FALSE)) {
[10:32:55.087]                           master <- get("master", mode = "list", 
[10:32:55.087]                             envir = envir, inherits = FALSE)
[10:32:55.087]                           if (inherits(master, c("SOCKnode", 
[10:32:55.087]                             "SOCK0node"))) {
[10:32:55.087]                             sendCondition <<- function(cond) {
[10:32:55.087]                               data <- list(type = "VALUE", value = cond, 
[10:32:55.087]                                 success = TRUE)
[10:32:55.087]                               parallel_sendData(master, data)
[10:32:55.087]                             }
[10:32:55.087]                             return(sendCondition)
[10:32:55.087]                           }
[10:32:55.087]                         }
[10:32:55.087]                         frame <- frame + 1L
[10:32:55.087]                         envir <- sys.frame(frame)
[10:32:55.087]                       }
[10:32:55.087]                     }
[10:32:55.087]                     sendCondition <<- function(cond) NULL
[10:32:55.087]                   }
[10:32:55.087]                 })
[10:32:55.087]                 withCallingHandlers({
[10:32:55.087]                   {
[10:32:55.087]                     4
[10:32:55.087]                   }
[10:32:55.087]                 }, immediateCondition = function(cond) {
[10:32:55.087]                   sendCondition <- ...future.makeSendCondition()
[10:32:55.087]                   sendCondition(cond)
[10:32:55.087]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.087]                   {
[10:32:55.087]                     inherits <- base::inherits
[10:32:55.087]                     invokeRestart <- base::invokeRestart
[10:32:55.087]                     is.null <- base::is.null
[10:32:55.087]                     muffled <- FALSE
[10:32:55.087]                     if (inherits(cond, "message")) {
[10:32:55.087]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:55.087]                       if (muffled) 
[10:32:55.087]                         invokeRestart("muffleMessage")
[10:32:55.087]                     }
[10:32:55.087]                     else if (inherits(cond, "warning")) {
[10:32:55.087]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:55.087]                       if (muffled) 
[10:32:55.087]                         invokeRestart("muffleWarning")
[10:32:55.087]                     }
[10:32:55.087]                     else if (inherits(cond, "condition")) {
[10:32:55.087]                       if (!is.null(pattern)) {
[10:32:55.087]                         computeRestarts <- base::computeRestarts
[10:32:55.087]                         grepl <- base::grepl
[10:32:55.087]                         restarts <- computeRestarts(cond)
[10:32:55.087]                         for (restart in restarts) {
[10:32:55.087]                           name <- restart$name
[10:32:55.087]                           if (is.null(name)) 
[10:32:55.087]                             next
[10:32:55.087]                           if (!grepl(pattern, name)) 
[10:32:55.087]                             next
[10:32:55.087]                           invokeRestart(restart)
[10:32:55.087]                           muffled <- TRUE
[10:32:55.087]                           break
[10:32:55.087]                         }
[10:32:55.087]                       }
[10:32:55.087]                     }
[10:32:55.087]                     invisible(muffled)
[10:32:55.087]                   }
[10:32:55.087]                   muffleCondition(cond)
[10:32:55.087]                 })
[10:32:55.087]             }))
[10:32:55.087]             future::FutureResult(value = ...future.value$value, 
[10:32:55.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:55.087]                   ...future.rng), globalenv = if (FALSE) 
[10:32:55.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:55.087]                     ...future.globalenv.names))
[10:32:55.087]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:55.087]         }, condition = base::local({
[10:32:55.087]             c <- base::c
[10:32:55.087]             inherits <- base::inherits
[10:32:55.087]             invokeRestart <- base::invokeRestart
[10:32:55.087]             length <- base::length
[10:32:55.087]             list <- base::list
[10:32:55.087]             seq.int <- base::seq.int
[10:32:55.087]             signalCondition <- base::signalCondition
[10:32:55.087]             sys.calls <- base::sys.calls
[10:32:55.087]             `[[` <- base::`[[`
[10:32:55.087]             `+` <- base::`+`
[10:32:55.087]             `<<-` <- base::`<<-`
[10:32:55.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:55.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:55.087]                   3L)]
[10:32:55.087]             }
[10:32:55.087]             function(cond) {
[10:32:55.087]                 is_error <- inherits(cond, "error")
[10:32:55.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:55.087]                   NULL)
[10:32:55.087]                 if (is_error) {
[10:32:55.087]                   sessionInformation <- function() {
[10:32:55.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:55.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:55.087]                       search = base::search(), system = base::Sys.info())
[10:32:55.087]                   }
[10:32:55.087]                   ...future.conditions[[length(...future.conditions) + 
[10:32:55.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:55.087]                     cond$call), session = sessionInformation(), 
[10:32:55.087]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:55.087]                   signalCondition(cond)
[10:32:55.087]                 }
[10:32:55.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:55.087]                 "immediateCondition"))) {
[10:32:55.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:55.087]                   ...future.conditions[[length(...future.conditions) + 
[10:32:55.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:55.087]                   if (TRUE && !signal) {
[10:32:55.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.087]                     {
[10:32:55.087]                       inherits <- base::inherits
[10:32:55.087]                       invokeRestart <- base::invokeRestart
[10:32:55.087]                       is.null <- base::is.null
[10:32:55.087]                       muffled <- FALSE
[10:32:55.087]                       if (inherits(cond, "message")) {
[10:32:55.087]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:55.087]                         if (muffled) 
[10:32:55.087]                           invokeRestart("muffleMessage")
[10:32:55.087]                       }
[10:32:55.087]                       else if (inherits(cond, "warning")) {
[10:32:55.087]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:55.087]                         if (muffled) 
[10:32:55.087]                           invokeRestart("muffleWarning")
[10:32:55.087]                       }
[10:32:55.087]                       else if (inherits(cond, "condition")) {
[10:32:55.087]                         if (!is.null(pattern)) {
[10:32:55.087]                           computeRestarts <- base::computeRestarts
[10:32:55.087]                           grepl <- base::grepl
[10:32:55.087]                           restarts <- computeRestarts(cond)
[10:32:55.087]                           for (restart in restarts) {
[10:32:55.087]                             name <- restart$name
[10:32:55.087]                             if (is.null(name)) 
[10:32:55.087]                               next
[10:32:55.087]                             if (!grepl(pattern, name)) 
[10:32:55.087]                               next
[10:32:55.087]                             invokeRestart(restart)
[10:32:55.087]                             muffled <- TRUE
[10:32:55.087]                             break
[10:32:55.087]                           }
[10:32:55.087]                         }
[10:32:55.087]                       }
[10:32:55.087]                       invisible(muffled)
[10:32:55.087]                     }
[10:32:55.087]                     muffleCondition(cond, pattern = "^muffle")
[10:32:55.087]                   }
[10:32:55.087]                 }
[10:32:55.087]                 else {
[10:32:55.087]                   if (TRUE) {
[10:32:55.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:55.087]                     {
[10:32:55.087]                       inherits <- base::inherits
[10:32:55.087]                       invokeRestart <- base::invokeRestart
[10:32:55.087]                       is.null <- base::is.null
[10:32:55.087]                       muffled <- FALSE
[10:32:55.087]                       if (inherits(cond, "message")) {
[10:32:55.087]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:55.087]                         if (muffled) 
[10:32:55.087]                           invokeRestart("muffleMessage")
[10:32:55.087]                       }
[10:32:55.087]                       else if (inherits(cond, "warning")) {
[10:32:55.087]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:55.087]                         if (muffled) 
[10:32:55.087]                           invokeRestart("muffleWarning")
[10:32:55.087]                       }
[10:32:55.087]                       else if (inherits(cond, "condition")) {
[10:32:55.087]                         if (!is.null(pattern)) {
[10:32:55.087]                           computeRestarts <- base::computeRestarts
[10:32:55.087]                           grepl <- base::grepl
[10:32:55.087]                           restarts <- computeRestarts(cond)
[10:32:55.087]                           for (restart in restarts) {
[10:32:55.087]                             name <- restart$name
[10:32:55.087]                             if (is.null(name)) 
[10:32:55.087]                               next
[10:32:55.087]                             if (!grepl(pattern, name)) 
[10:32:55.087]                               next
[10:32:55.087]                             invokeRestart(restart)
[10:32:55.087]                             muffled <- TRUE
[10:32:55.087]                             break
[10:32:55.087]                           }
[10:32:55.087]                         }
[10:32:55.087]                       }
[10:32:55.087]                       invisible(muffled)
[10:32:55.087]                     }
[10:32:55.087]                     muffleCondition(cond, pattern = "^muffle")
[10:32:55.087]                   }
[10:32:55.087]                 }
[10:32:55.087]             }
[10:32:55.087]         }))
[10:32:55.087]     }, error = function(ex) {
[10:32:55.087]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:55.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:55.087]                 ...future.rng), started = ...future.startTime, 
[10:32:55.087]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:55.087]             version = "1.8"), class = "FutureResult")
[10:32:55.087]     }, finally = {
[10:32:55.087]         if (!identical(...future.workdir, getwd())) 
[10:32:55.087]             setwd(...future.workdir)
[10:32:55.087]         {
[10:32:55.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:55.087]                 ...future.oldOptions$nwarnings <- NULL
[10:32:55.087]             }
[10:32:55.087]             base::options(...future.oldOptions)
[10:32:55.087]             if (.Platform$OS.type == "windows") {
[10:32:55.087]                 old_names <- names(...future.oldEnvVars)
[10:32:55.087]                 envs <- base::Sys.getenv()
[10:32:55.087]                 names <- names(envs)
[10:32:55.087]                 common <- intersect(names, old_names)
[10:32:55.087]                 added <- setdiff(names, old_names)
[10:32:55.087]                 removed <- setdiff(old_names, names)
[10:32:55.087]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:55.087]                   envs[common]]
[10:32:55.087]                 NAMES <- toupper(changed)
[10:32:55.087]                 args <- list()
[10:32:55.087]                 for (kk in seq_along(NAMES)) {
[10:32:55.087]                   name <- changed[[kk]]
[10:32:55.087]                   NAME <- NAMES[[kk]]
[10:32:55.087]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.087]                     next
[10:32:55.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:55.087]                 }
[10:32:55.087]                 NAMES <- toupper(added)
[10:32:55.087]                 for (kk in seq_along(NAMES)) {
[10:32:55.087]                   name <- added[[kk]]
[10:32:55.087]                   NAME <- NAMES[[kk]]
[10:32:55.087]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.087]                     next
[10:32:55.087]                   args[[name]] <- ""
[10:32:55.087]                 }
[10:32:55.087]                 NAMES <- toupper(removed)
[10:32:55.087]                 for (kk in seq_along(NAMES)) {
[10:32:55.087]                   name <- removed[[kk]]
[10:32:55.087]                   NAME <- NAMES[[kk]]
[10:32:55.087]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:55.087]                     next
[10:32:55.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:55.087]                 }
[10:32:55.087]                 if (length(args) > 0) 
[10:32:55.087]                   base::do.call(base::Sys.setenv, args = args)
[10:32:55.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:55.087]             }
[10:32:55.087]             else {
[10:32:55.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:55.087]             }
[10:32:55.087]             {
[10:32:55.087]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:55.087]                   0L) {
[10:32:55.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:55.087]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:55.087]                   base::options(opts)
[10:32:55.087]                 }
[10:32:55.087]                 {
[10:32:55.087]                   {
[10:32:55.087]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:55.087]                     NULL
[10:32:55.087]                   }
[10:32:55.087]                   options(future.plan = NULL)
[10:32:55.087]                   if (is.na(NA_character_)) 
[10:32:55.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:55.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:55.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:55.087]                     .init = FALSE)
[10:32:55.087]                 }
[10:32:55.087]             }
[10:32:55.087]         }
[10:32:55.087]     })
[10:32:55.087]     if (TRUE) {
[10:32:55.087]         base::sink(type = "output", split = FALSE)
[10:32:55.087]         if (TRUE) {
[10:32:55.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:55.087]         }
[10:32:55.087]         else {
[10:32:55.087]             ...future.result["stdout"] <- base::list(NULL)
[10:32:55.087]         }
[10:32:55.087]         base::close(...future.stdout)
[10:32:55.087]         ...future.stdout <- NULL
[10:32:55.087]     }
[10:32:55.087]     ...future.result$conditions <- ...future.conditions
[10:32:55.087]     ...future.result$finished <- base::Sys.time()
[10:32:55.087]     ...future.result
[10:32:55.087] }
[10:32:55.089] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:55.100] receiveMessageFromWorker() for ClusterFuture ...
[10:32:55.100] - Validating connection of MultisessionFuture
[10:32:55.100] - received message: FutureResult
[10:32:55.100] - Received FutureResult
[10:32:55.100] - Erased future from FutureRegistry
[10:32:55.101] result() for ClusterFuture ...
[10:32:55.101] - result already collected: FutureResult
[10:32:55.101] result() for ClusterFuture ... done
[10:32:55.101] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:55.101] result() for ClusterFuture ...
[10:32:55.101] - result already collected: FutureResult
[10:32:55.101] result() for ClusterFuture ... done
[10:32:55.101] result() for ClusterFuture ...
[10:32:55.101] - result already collected: FutureResult
[10:32:55.101] result() for ClusterFuture ... done
[10:32:55.102] MultisessionFuture started
[10:32:55.103] - Launch lazy future ... done
[10:32:55.103] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5652cf7ea200> 
Classes 'listenv', 'environment' <environment: 0x5652d28e6130> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:32:55.108] receiveMessageFromWorker() for ClusterFuture ...
[10:32:55.108] - Validating connection of MultisessionFuture
[10:32:55.108] - received message: FutureResult
[10:32:55.108] - Received FutureResult
[10:32:55.109] - Erased future from FutureRegistry
[10:32:55.109] result() for ClusterFuture ...
[10:32:55.109] - result already collected: FutureResult
[10:32:55.109] result() for ClusterFuture ... done
[10:32:55.109] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:55.109] receiveMessageFromWorker() for ClusterFuture ...
[10:32:55.110] - Validating connection of MultisessionFuture
[10:32:55.110] - received message: FutureResult
[10:32:55.110] - Received FutureResult
[10:32:55.110] - Erased future from FutureRegistry
[10:32:55.110] result() for ClusterFuture ...
[10:32:55.110] - result already collected: FutureResult
[10:32:55.110] result() for ClusterFuture ... done
[10:32:55.110] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:32:55.113] resolve() on list environment ...
[10:32:55.113]  recursive: 0
[10:32:55.114]  length: 6
[10:32:55.114]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:32:55.114] signalConditionsASAP(numeric, pos=1) ...
[10:32:55.114] - nx: 6
[10:32:55.115] - relay: TRUE
[10:32:55.115] - stdout: TRUE
[10:32:55.115] - signal: TRUE
[10:32:55.115] - resignal: FALSE
[10:32:55.118] - force: TRUE
[10:32:55.118] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.118]  - until=2
[10:32:55.118]  - relaying element #2
[10:32:55.118] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.119] signalConditionsASAP(NULL, pos=1) ... done
[10:32:55.119]  length: 5 (resolved future 1)
[10:32:55.119] Future #2
[10:32:55.119] result() for ClusterFuture ...
[10:32:55.119] - result already collected: FutureResult
[10:32:55.119] result() for ClusterFuture ... done
[10:32:55.119] result() for ClusterFuture ...
[10:32:55.119] - result already collected: FutureResult
[10:32:55.119] result() for ClusterFuture ... done
[10:32:55.119] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:32:55.120] - nx: 6
[10:32:55.120] - relay: TRUE
[10:32:55.120] - stdout: TRUE
[10:32:55.120] - signal: TRUE
[10:32:55.120] - resignal: FALSE
[10:32:55.120] - force: TRUE
[10:32:55.120] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.120] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:32:55.120]  - until=2
[10:32:55.120]  - relaying element #2
[10:32:55.120] result() for ClusterFuture ...
[10:32:55.120] - result already collected: FutureResult
[10:32:55.121] result() for ClusterFuture ... done
[10:32:55.121] result() for ClusterFuture ...
[10:32:55.121] - result already collected: FutureResult
[10:32:55.121] result() for ClusterFuture ... done
[10:32:55.121] result() for ClusterFuture ...
[10:32:55.121] - result already collected: FutureResult
[10:32:55.121] result() for ClusterFuture ... done
[10:32:55.121] result() for ClusterFuture ...
[10:32:55.121] - result already collected: FutureResult
[10:32:55.121] result() for ClusterFuture ... done
[10:32:55.121] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.122] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.122] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:32:55.122]  length: 4 (resolved future 2)
[10:32:55.122] Future #3
[10:32:55.122] result() for ClusterFuture ...
[10:32:55.122] - result already collected: FutureResult
[10:32:55.122] result() for ClusterFuture ... done
[10:32:55.122] result() for ClusterFuture ...
[10:32:55.122] - result already collected: FutureResult
[10:32:55.122] result() for ClusterFuture ... done
[10:32:55.122] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:32:55.123] - nx: 6
[10:32:55.123] - relay: TRUE
[10:32:55.123] - stdout: TRUE
[10:32:55.123] - signal: TRUE
[10:32:55.123] - resignal: FALSE
[10:32:55.123] - force: TRUE
[10:32:55.123] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.123] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:32:55.123]  - until=3
[10:32:55.123]  - relaying element #3
[10:32:55.123] result() for ClusterFuture ...
[10:32:55.123] - result already collected: FutureResult
[10:32:55.124] result() for ClusterFuture ... done
[10:32:55.124] result() for ClusterFuture ...
[10:32:55.124] - result already collected: FutureResult
[10:32:55.124] result() for ClusterFuture ... done
[10:32:55.124] result() for ClusterFuture ...
[10:32:55.124] - result already collected: FutureResult
[10:32:55.124] result() for ClusterFuture ... done
[10:32:55.124] result() for ClusterFuture ...
[10:32:55.124] - result already collected: FutureResult
[10:32:55.124] result() for ClusterFuture ... done
[10:32:55.124] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.124] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.125] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:32:55.125]  length: 3 (resolved future 3)
[10:32:55.125] Future #4
[10:32:55.125] result() for ClusterFuture ...
[10:32:55.125] - result already collected: FutureResult
[10:32:55.125] result() for ClusterFuture ... done
[10:32:55.125] result() for ClusterFuture ...
[10:32:55.125] - result already collected: FutureResult
[10:32:55.125] result() for ClusterFuture ... done
[10:32:55.125] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:32:55.126] - nx: 6
[10:32:55.126] - relay: TRUE
[10:32:55.126] - stdout: TRUE
[10:32:55.126] - signal: TRUE
[10:32:55.126] - resignal: FALSE
[10:32:55.126] - force: TRUE
[10:32:55.126] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.126] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:32:55.126]  - until=4
[10:32:55.126]  - relaying element #4
[10:32:55.126] result() for ClusterFuture ...
[10:32:55.126] - result already collected: FutureResult
[10:32:55.126] result() for ClusterFuture ... done
[10:32:55.127] result() for ClusterFuture ...
[10:32:55.127] - result already collected: FutureResult
[10:32:55.127] result() for ClusterFuture ... done
[10:32:55.127] result() for ClusterFuture ...
[10:32:55.127] - result already collected: FutureResult
[10:32:55.127] result() for ClusterFuture ... done
[10:32:55.127] result() for ClusterFuture ...
[10:32:55.127] - result already collected: FutureResult
[10:32:55.127] result() for ClusterFuture ... done
[10:32:55.127] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.127] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.128] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:32:55.128]  length: 2 (resolved future 4)
[10:32:55.128] signalConditionsASAP(NULL, pos=5) ...
[10:32:55.128] - nx: 6
[10:32:55.128] - relay: TRUE
[10:32:55.128] - stdout: TRUE
[10:32:55.128] - signal: TRUE
[10:32:55.128] - resignal: FALSE
[10:32:55.128] - force: TRUE
[10:32:55.128] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.128] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.128]  - until=6
[10:32:55.129]  - relaying element #6
[10:32:55.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:55.129] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.129] signalConditionsASAP(NULL, pos=5) ... done
[10:32:55.129]  length: 1 (resolved future 5)
[10:32:55.129] signalConditionsASAP(numeric, pos=6) ...
[10:32:55.129] - nx: 6
[10:32:55.129] - relay: TRUE
[10:32:55.129] - stdout: TRUE
[10:32:55.129] - signal: TRUE
[10:32:55.129] - resignal: FALSE
[10:32:55.130] - force: TRUE
[10:32:55.130] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:32:55.130] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.130]  - until=6
[10:32:55.130] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:55.130] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.130] signalConditionsASAP(numeric, pos=6) ... done
[10:32:55.130]  length: 0 (resolved future 6)
[10:32:55.130] Relaying remaining futures
[10:32:55.130] signalConditionsASAP(NULL, pos=0) ...
[10:32:55.130] - nx: 6
[10:32:55.130] - relay: TRUE
[10:32:55.131] - stdout: TRUE
[10:32:55.131] - signal: TRUE
[10:32:55.131] - resignal: FALSE
[10:32:55.131] - force: TRUE
[10:32:55.131] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:55.131] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:32:55.131] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:32:55.131] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:32:55.131] signalConditionsASAP(NULL, pos=0) ... done
[10:32:55.131] resolve() on list environment ... DONE
[10:32:55.131] result() for ClusterFuture ...
[10:32:55.132] - result already collected: FutureResult
[10:32:55.132] result() for ClusterFuture ... done
[10:32:55.132] result() for ClusterFuture ...
[10:32:55.132] - result already collected: FutureResult
[10:32:55.132] result() for ClusterFuture ... done
[10:32:55.132] result() for ClusterFuture ...
[10:32:55.132] - result already collected: FutureResult
[10:32:55.132] result() for ClusterFuture ... done
[10:32:55.132] result() for ClusterFuture ...
[10:32:55.132] - result already collected: FutureResult
[10:32:55.132] result() for ClusterFuture ... done
[10:32:55.133] result() for ClusterFuture ...
[10:32:55.133] - result already collected: FutureResult
[10:32:55.133] result() for ClusterFuture ... done
[10:32:55.133] result() for ClusterFuture ...
[10:32:55.133] - result already collected: FutureResult
[10:32:55.133] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5652d2cc6188> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[10:32:55.136] plan(): Setting new future strategy stack:
[10:32:55.136] List of future strategies:
[10:32:55.136] 1. FutureStrategy:
[10:32:55.136]    - args: function (..., envir = parent.frame())
[10:32:55.136]    - tweaked: FALSE
[10:32:55.136]    - call: future::plan(oplan)
[10:32:55.137] plan(): nbrOfWorkers() = 1
> 
