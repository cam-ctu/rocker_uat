
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:36:33.667] plan(): Setting new future strategy stack:
[13:36:33.668] List of future strategies:
[13:36:33.668] 1. sequential:
[13:36:33.668]    - args: function (..., envir = parent.frame())
[13:36:33.668]    - tweaked: FALSE
[13:36:33.668]    - call: future::plan("sequential")
[13:36:33.681] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[13:36:33.733] plan(): Setting new future strategy stack:
[13:36:33.733] List of future strategies:
[13:36:33.733] 1. sequential:
[13:36:33.733]    - args: function (..., envir = parent.frame())
[13:36:33.733]    - tweaked: FALSE
[13:36:33.733]    - call: plan(strategy)
[13:36:33.744] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:36:33.745] getGlobalsAndPackages() ...
[13:36:33.745] Searching for globals...
[13:36:33.748] 
[13:36:33.748] Searching for globals ... DONE
[13:36:33.748] - globals: [0] <none>
[13:36:33.748] getGlobalsAndPackages() ... DONE
[13:36:33.749] run() for ‘Future’ ...
[13:36:33.749] - state: ‘created’
[13:36:33.749] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.749] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.749] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.750]   - Field: ‘label’
[13:36:33.750]   - Field: ‘local’
[13:36:33.750]   - Field: ‘owner’
[13:36:33.750]   - Field: ‘envir’
[13:36:33.750]   - Field: ‘packages’
[13:36:33.750]   - Field: ‘gc’
[13:36:33.750]   - Field: ‘conditions’
[13:36:33.750]   - Field: ‘expr’
[13:36:33.750]   - Field: ‘uuid’
[13:36:33.750]   - Field: ‘seed’
[13:36:33.750]   - Field: ‘version’
[13:36:33.751]   - Field: ‘result’
[13:36:33.751]   - Field: ‘asynchronous’
[13:36:33.751]   - Field: ‘calls’
[13:36:33.751]   - Field: ‘globals’
[13:36:33.751]   - Field: ‘stdout’
[13:36:33.751]   - Field: ‘earlySignal’
[13:36:33.751]   - Field: ‘lazy’
[13:36:33.751]   - Field: ‘state’
[13:36:33.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.751] - Launch lazy future ...
[13:36:33.752] Packages needed by the future expression (n = 0): <none>
[13:36:33.752] Packages needed by future strategies (n = 0): <none>
[13:36:33.753] {
[13:36:33.753]     {
[13:36:33.753]         {
[13:36:33.753]             ...future.startTime <- base::Sys.time()
[13:36:33.753]             {
[13:36:33.753]                 {
[13:36:33.753]                   {
[13:36:33.753]                     base::local({
[13:36:33.753]                       has_future <- base::requireNamespace("future", 
[13:36:33.753]                         quietly = TRUE)
[13:36:33.753]                       if (has_future) {
[13:36:33.753]                         ns <- base::getNamespace("future")
[13:36:33.753]                         version <- ns[[".package"]][["version"]]
[13:36:33.753]                         if (is.null(version)) 
[13:36:33.753]                           version <- utils::packageVersion("future")
[13:36:33.753]                       }
[13:36:33.753]                       else {
[13:36:33.753]                         version <- NULL
[13:36:33.753]                       }
[13:36:33.753]                       if (!has_future || version < "1.8.0") {
[13:36:33.753]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.753]                           "", base::R.version$version.string), 
[13:36:33.753]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.753]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.753]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.753]                             "release", "version")], collapse = " "), 
[13:36:33.753]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.753]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.753]                           info)
[13:36:33.753]                         info <- base::paste(info, collapse = "; ")
[13:36:33.753]                         if (!has_future) {
[13:36:33.753]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.753]                             info)
[13:36:33.753]                         }
[13:36:33.753]                         else {
[13:36:33.753]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.753]                             info, version)
[13:36:33.753]                         }
[13:36:33.753]                         base::stop(msg)
[13:36:33.753]                       }
[13:36:33.753]                     })
[13:36:33.753]                   }
[13:36:33.753]                   ...future.strategy.old <- future::plan("list")
[13:36:33.753]                   options(future.plan = NULL)
[13:36:33.753]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.753]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.753]                 }
[13:36:33.753]                 ...future.workdir <- getwd()
[13:36:33.753]             }
[13:36:33.753]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.753]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.753]         }
[13:36:33.753]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.753]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.753]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.753]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.753]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.753]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.753]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.753]             base::names(...future.oldOptions))
[13:36:33.753]     }
[13:36:33.753]     if (FALSE) {
[13:36:33.753]     }
[13:36:33.753]     else {
[13:36:33.753]         if (TRUE) {
[13:36:33.753]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.753]                 open = "w")
[13:36:33.753]         }
[13:36:33.753]         else {
[13:36:33.753]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.753]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.753]         }
[13:36:33.753]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.753]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.753]             base::sink(type = "output", split = FALSE)
[13:36:33.753]             base::close(...future.stdout)
[13:36:33.753]         }, add = TRUE)
[13:36:33.753]     }
[13:36:33.753]     ...future.frame <- base::sys.nframe()
[13:36:33.753]     ...future.conditions <- base::list()
[13:36:33.753]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.753]     if (FALSE) {
[13:36:33.753]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.753]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.753]     }
[13:36:33.753]     ...future.result <- base::tryCatch({
[13:36:33.753]         base::withCallingHandlers({
[13:36:33.753]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.753]             future::FutureResult(value = ...future.value$value, 
[13:36:33.753]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.753]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.753]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.753]                     ...future.globalenv.names))
[13:36:33.753]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.753]         }, condition = base::local({
[13:36:33.753]             c <- base::c
[13:36:33.753]             inherits <- base::inherits
[13:36:33.753]             invokeRestart <- base::invokeRestart
[13:36:33.753]             length <- base::length
[13:36:33.753]             list <- base::list
[13:36:33.753]             seq.int <- base::seq.int
[13:36:33.753]             signalCondition <- base::signalCondition
[13:36:33.753]             sys.calls <- base::sys.calls
[13:36:33.753]             `[[` <- base::`[[`
[13:36:33.753]             `+` <- base::`+`
[13:36:33.753]             `<<-` <- base::`<<-`
[13:36:33.753]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.753]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.753]                   3L)]
[13:36:33.753]             }
[13:36:33.753]             function(cond) {
[13:36:33.753]                 is_error <- inherits(cond, "error")
[13:36:33.753]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.753]                   NULL)
[13:36:33.753]                 if (is_error) {
[13:36:33.753]                   sessionInformation <- function() {
[13:36:33.753]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.753]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.753]                       search = base::search(), system = base::Sys.info())
[13:36:33.753]                   }
[13:36:33.753]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.753]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.753]                     cond$call), session = sessionInformation(), 
[13:36:33.753]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.753]                   signalCondition(cond)
[13:36:33.753]                 }
[13:36:33.753]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.753]                 "immediateCondition"))) {
[13:36:33.753]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.753]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.753]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.753]                   if (TRUE && !signal) {
[13:36:33.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.753]                     {
[13:36:33.753]                       inherits <- base::inherits
[13:36:33.753]                       invokeRestart <- base::invokeRestart
[13:36:33.753]                       is.null <- base::is.null
[13:36:33.753]                       muffled <- FALSE
[13:36:33.753]                       if (inherits(cond, "message")) {
[13:36:33.753]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.753]                         if (muffled) 
[13:36:33.753]                           invokeRestart("muffleMessage")
[13:36:33.753]                       }
[13:36:33.753]                       else if (inherits(cond, "warning")) {
[13:36:33.753]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.753]                         if (muffled) 
[13:36:33.753]                           invokeRestart("muffleWarning")
[13:36:33.753]                       }
[13:36:33.753]                       else if (inherits(cond, "condition")) {
[13:36:33.753]                         if (!is.null(pattern)) {
[13:36:33.753]                           computeRestarts <- base::computeRestarts
[13:36:33.753]                           grepl <- base::grepl
[13:36:33.753]                           restarts <- computeRestarts(cond)
[13:36:33.753]                           for (restart in restarts) {
[13:36:33.753]                             name <- restart$name
[13:36:33.753]                             if (is.null(name)) 
[13:36:33.753]                               next
[13:36:33.753]                             if (!grepl(pattern, name)) 
[13:36:33.753]                               next
[13:36:33.753]                             invokeRestart(restart)
[13:36:33.753]                             muffled <- TRUE
[13:36:33.753]                             break
[13:36:33.753]                           }
[13:36:33.753]                         }
[13:36:33.753]                       }
[13:36:33.753]                       invisible(muffled)
[13:36:33.753]                     }
[13:36:33.753]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.753]                   }
[13:36:33.753]                 }
[13:36:33.753]                 else {
[13:36:33.753]                   if (TRUE) {
[13:36:33.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.753]                     {
[13:36:33.753]                       inherits <- base::inherits
[13:36:33.753]                       invokeRestart <- base::invokeRestart
[13:36:33.753]                       is.null <- base::is.null
[13:36:33.753]                       muffled <- FALSE
[13:36:33.753]                       if (inherits(cond, "message")) {
[13:36:33.753]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.753]                         if (muffled) 
[13:36:33.753]                           invokeRestart("muffleMessage")
[13:36:33.753]                       }
[13:36:33.753]                       else if (inherits(cond, "warning")) {
[13:36:33.753]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.753]                         if (muffled) 
[13:36:33.753]                           invokeRestart("muffleWarning")
[13:36:33.753]                       }
[13:36:33.753]                       else if (inherits(cond, "condition")) {
[13:36:33.753]                         if (!is.null(pattern)) {
[13:36:33.753]                           computeRestarts <- base::computeRestarts
[13:36:33.753]                           grepl <- base::grepl
[13:36:33.753]                           restarts <- computeRestarts(cond)
[13:36:33.753]                           for (restart in restarts) {
[13:36:33.753]                             name <- restart$name
[13:36:33.753]                             if (is.null(name)) 
[13:36:33.753]                               next
[13:36:33.753]                             if (!grepl(pattern, name)) 
[13:36:33.753]                               next
[13:36:33.753]                             invokeRestart(restart)
[13:36:33.753]                             muffled <- TRUE
[13:36:33.753]                             break
[13:36:33.753]                           }
[13:36:33.753]                         }
[13:36:33.753]                       }
[13:36:33.753]                       invisible(muffled)
[13:36:33.753]                     }
[13:36:33.753]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.753]                   }
[13:36:33.753]                 }
[13:36:33.753]             }
[13:36:33.753]         }))
[13:36:33.753]     }, error = function(ex) {
[13:36:33.753]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.753]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.753]                 ...future.rng), started = ...future.startTime, 
[13:36:33.753]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.753]             version = "1.8"), class = "FutureResult")
[13:36:33.753]     }, finally = {
[13:36:33.753]         if (!identical(...future.workdir, getwd())) 
[13:36:33.753]             setwd(...future.workdir)
[13:36:33.753]         {
[13:36:33.753]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.753]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.753]             }
[13:36:33.753]             base::options(...future.oldOptions)
[13:36:33.753]             if (.Platform$OS.type == "windows") {
[13:36:33.753]                 old_names <- names(...future.oldEnvVars)
[13:36:33.753]                 envs <- base::Sys.getenv()
[13:36:33.753]                 names <- names(envs)
[13:36:33.753]                 common <- intersect(names, old_names)
[13:36:33.753]                 added <- setdiff(names, old_names)
[13:36:33.753]                 removed <- setdiff(old_names, names)
[13:36:33.753]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.753]                   envs[common]]
[13:36:33.753]                 NAMES <- toupper(changed)
[13:36:33.753]                 args <- list()
[13:36:33.753]                 for (kk in seq_along(NAMES)) {
[13:36:33.753]                   name <- changed[[kk]]
[13:36:33.753]                   NAME <- NAMES[[kk]]
[13:36:33.753]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.753]                     next
[13:36:33.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.753]                 }
[13:36:33.753]                 NAMES <- toupper(added)
[13:36:33.753]                 for (kk in seq_along(NAMES)) {
[13:36:33.753]                   name <- added[[kk]]
[13:36:33.753]                   NAME <- NAMES[[kk]]
[13:36:33.753]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.753]                     next
[13:36:33.753]                   args[[name]] <- ""
[13:36:33.753]                 }
[13:36:33.753]                 NAMES <- toupper(removed)
[13:36:33.753]                 for (kk in seq_along(NAMES)) {
[13:36:33.753]                   name <- removed[[kk]]
[13:36:33.753]                   NAME <- NAMES[[kk]]
[13:36:33.753]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.753]                     next
[13:36:33.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.753]                 }
[13:36:33.753]                 if (length(args) > 0) 
[13:36:33.753]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.753]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.753]             }
[13:36:33.753]             else {
[13:36:33.753]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.753]             }
[13:36:33.753]             {
[13:36:33.753]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.753]                   0L) {
[13:36:33.753]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.753]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.753]                   base::options(opts)
[13:36:33.753]                 }
[13:36:33.753]                 {
[13:36:33.753]                   {
[13:36:33.753]                     NULL
[13:36:33.753]                     RNGkind("Mersenne-Twister")
[13:36:33.753]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.753]                       inherits = FALSE)
[13:36:33.753]                   }
[13:36:33.753]                   options(future.plan = NULL)
[13:36:33.753]                   if (is.na(NA_character_)) 
[13:36:33.753]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.753]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.753]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.753]                     .init = FALSE)
[13:36:33.753]                 }
[13:36:33.753]             }
[13:36:33.753]         }
[13:36:33.753]     })
[13:36:33.753]     if (TRUE) {
[13:36:33.753]         base::sink(type = "output", split = FALSE)
[13:36:33.753]         if (TRUE) {
[13:36:33.753]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.753]         }
[13:36:33.753]         else {
[13:36:33.753]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.753]         }
[13:36:33.753]         base::close(...future.stdout)
[13:36:33.753]         ...future.stdout <- NULL
[13:36:33.753]     }
[13:36:33.753]     ...future.result$conditions <- ...future.conditions
[13:36:33.753]     ...future.result$finished <- base::Sys.time()
[13:36:33.753]     ...future.result
[13:36:33.753] }
[13:36:33.755] plan(): Setting new future strategy stack:
[13:36:33.755] List of future strategies:
[13:36:33.755] 1. sequential:
[13:36:33.755]    - args: function (..., envir = parent.frame())
[13:36:33.755]    - tweaked: FALSE
[13:36:33.755]    - call: NULL
[13:36:33.755] plan(): nbrOfWorkers() = 1
[13:36:33.756] plan(): Setting new future strategy stack:
[13:36:33.757] List of future strategies:
[13:36:33.757] 1. sequential:
[13:36:33.757]    - args: function (..., envir = parent.frame())
[13:36:33.757]    - tweaked: FALSE
[13:36:33.757]    - call: plan(strategy)
[13:36:33.757] plan(): nbrOfWorkers() = 1
[13:36:33.757] SequentialFuture started (and completed)
[13:36:33.758] - Launch lazy future ... done
[13:36:33.758] run() for ‘SequentialFuture’ ... done
[13:36:33.758] getGlobalsAndPackages() ...
[13:36:33.758] Searching for globals...
[13:36:33.758] 
[13:36:33.758] Searching for globals ... DONE
[13:36:33.758] - globals: [0] <none>
[13:36:33.758] getGlobalsAndPackages() ... DONE
[13:36:33.759] run() for ‘Future’ ...
[13:36:33.759] - state: ‘created’
[13:36:33.759] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.759] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.759]   - Field: ‘label’
[13:36:33.759]   - Field: ‘local’
[13:36:33.759]   - Field: ‘owner’
[13:36:33.760]   - Field: ‘envir’
[13:36:33.760]   - Field: ‘packages’
[13:36:33.760]   - Field: ‘gc’
[13:36:33.760]   - Field: ‘conditions’
[13:36:33.760]   - Field: ‘expr’
[13:36:33.760]   - Field: ‘uuid’
[13:36:33.760]   - Field: ‘seed’
[13:36:33.760]   - Field: ‘version’
[13:36:33.760]   - Field: ‘result’
[13:36:33.760]   - Field: ‘asynchronous’
[13:36:33.760]   - Field: ‘calls’
[13:36:33.761]   - Field: ‘globals’
[13:36:33.761]   - Field: ‘stdout’
[13:36:33.761]   - Field: ‘earlySignal’
[13:36:33.761]   - Field: ‘lazy’
[13:36:33.761]   - Field: ‘state’
[13:36:33.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.761] - Launch lazy future ...
[13:36:33.761] Packages needed by the future expression (n = 0): <none>
[13:36:33.761] Packages needed by future strategies (n = 0): <none>
[13:36:33.762] {
[13:36:33.762]     {
[13:36:33.762]         {
[13:36:33.762]             ...future.startTime <- base::Sys.time()
[13:36:33.762]             {
[13:36:33.762]                 {
[13:36:33.762]                   {
[13:36:33.762]                     base::local({
[13:36:33.762]                       has_future <- base::requireNamespace("future", 
[13:36:33.762]                         quietly = TRUE)
[13:36:33.762]                       if (has_future) {
[13:36:33.762]                         ns <- base::getNamespace("future")
[13:36:33.762]                         version <- ns[[".package"]][["version"]]
[13:36:33.762]                         if (is.null(version)) 
[13:36:33.762]                           version <- utils::packageVersion("future")
[13:36:33.762]                       }
[13:36:33.762]                       else {
[13:36:33.762]                         version <- NULL
[13:36:33.762]                       }
[13:36:33.762]                       if (!has_future || version < "1.8.0") {
[13:36:33.762]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.762]                           "", base::R.version$version.string), 
[13:36:33.762]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.762]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.762]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.762]                             "release", "version")], collapse = " "), 
[13:36:33.762]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.762]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.762]                           info)
[13:36:33.762]                         info <- base::paste(info, collapse = "; ")
[13:36:33.762]                         if (!has_future) {
[13:36:33.762]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.762]                             info)
[13:36:33.762]                         }
[13:36:33.762]                         else {
[13:36:33.762]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.762]                             info, version)
[13:36:33.762]                         }
[13:36:33.762]                         base::stop(msg)
[13:36:33.762]                       }
[13:36:33.762]                     })
[13:36:33.762]                   }
[13:36:33.762]                   ...future.strategy.old <- future::plan("list")
[13:36:33.762]                   options(future.plan = NULL)
[13:36:33.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.762]                 }
[13:36:33.762]                 ...future.workdir <- getwd()
[13:36:33.762]             }
[13:36:33.762]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.762]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.762]         }
[13:36:33.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.762]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.762]             base::names(...future.oldOptions))
[13:36:33.762]     }
[13:36:33.762]     if (FALSE) {
[13:36:33.762]     }
[13:36:33.762]     else {
[13:36:33.762]         if (TRUE) {
[13:36:33.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.762]                 open = "w")
[13:36:33.762]         }
[13:36:33.762]         else {
[13:36:33.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.762]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.762]         }
[13:36:33.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.762]             base::sink(type = "output", split = FALSE)
[13:36:33.762]             base::close(...future.stdout)
[13:36:33.762]         }, add = TRUE)
[13:36:33.762]     }
[13:36:33.762]     ...future.frame <- base::sys.nframe()
[13:36:33.762]     ...future.conditions <- base::list()
[13:36:33.762]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.762]     if (FALSE) {
[13:36:33.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.762]     }
[13:36:33.762]     ...future.result <- base::tryCatch({
[13:36:33.762]         base::withCallingHandlers({
[13:36:33.762]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.762]             future::FutureResult(value = ...future.value$value, 
[13:36:33.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.762]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.762]                     ...future.globalenv.names))
[13:36:33.762]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.762]         }, condition = base::local({
[13:36:33.762]             c <- base::c
[13:36:33.762]             inherits <- base::inherits
[13:36:33.762]             invokeRestart <- base::invokeRestart
[13:36:33.762]             length <- base::length
[13:36:33.762]             list <- base::list
[13:36:33.762]             seq.int <- base::seq.int
[13:36:33.762]             signalCondition <- base::signalCondition
[13:36:33.762]             sys.calls <- base::sys.calls
[13:36:33.762]             `[[` <- base::`[[`
[13:36:33.762]             `+` <- base::`+`
[13:36:33.762]             `<<-` <- base::`<<-`
[13:36:33.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.762]                   3L)]
[13:36:33.762]             }
[13:36:33.762]             function(cond) {
[13:36:33.762]                 is_error <- inherits(cond, "error")
[13:36:33.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.762]                   NULL)
[13:36:33.762]                 if (is_error) {
[13:36:33.762]                   sessionInformation <- function() {
[13:36:33.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.762]                       search = base::search(), system = base::Sys.info())
[13:36:33.762]                   }
[13:36:33.762]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.762]                     cond$call), session = sessionInformation(), 
[13:36:33.762]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.762]                   signalCondition(cond)
[13:36:33.762]                 }
[13:36:33.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.762]                 "immediateCondition"))) {
[13:36:33.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.762]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.762]                   if (TRUE && !signal) {
[13:36:33.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.762]                     {
[13:36:33.762]                       inherits <- base::inherits
[13:36:33.762]                       invokeRestart <- base::invokeRestart
[13:36:33.762]                       is.null <- base::is.null
[13:36:33.762]                       muffled <- FALSE
[13:36:33.762]                       if (inherits(cond, "message")) {
[13:36:33.762]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.762]                         if (muffled) 
[13:36:33.762]                           invokeRestart("muffleMessage")
[13:36:33.762]                       }
[13:36:33.762]                       else if (inherits(cond, "warning")) {
[13:36:33.762]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.762]                         if (muffled) 
[13:36:33.762]                           invokeRestart("muffleWarning")
[13:36:33.762]                       }
[13:36:33.762]                       else if (inherits(cond, "condition")) {
[13:36:33.762]                         if (!is.null(pattern)) {
[13:36:33.762]                           computeRestarts <- base::computeRestarts
[13:36:33.762]                           grepl <- base::grepl
[13:36:33.762]                           restarts <- computeRestarts(cond)
[13:36:33.762]                           for (restart in restarts) {
[13:36:33.762]                             name <- restart$name
[13:36:33.762]                             if (is.null(name)) 
[13:36:33.762]                               next
[13:36:33.762]                             if (!grepl(pattern, name)) 
[13:36:33.762]                               next
[13:36:33.762]                             invokeRestart(restart)
[13:36:33.762]                             muffled <- TRUE
[13:36:33.762]                             break
[13:36:33.762]                           }
[13:36:33.762]                         }
[13:36:33.762]                       }
[13:36:33.762]                       invisible(muffled)
[13:36:33.762]                     }
[13:36:33.762]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.762]                   }
[13:36:33.762]                 }
[13:36:33.762]                 else {
[13:36:33.762]                   if (TRUE) {
[13:36:33.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.762]                     {
[13:36:33.762]                       inherits <- base::inherits
[13:36:33.762]                       invokeRestart <- base::invokeRestart
[13:36:33.762]                       is.null <- base::is.null
[13:36:33.762]                       muffled <- FALSE
[13:36:33.762]                       if (inherits(cond, "message")) {
[13:36:33.762]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.762]                         if (muffled) 
[13:36:33.762]                           invokeRestart("muffleMessage")
[13:36:33.762]                       }
[13:36:33.762]                       else if (inherits(cond, "warning")) {
[13:36:33.762]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.762]                         if (muffled) 
[13:36:33.762]                           invokeRestart("muffleWarning")
[13:36:33.762]                       }
[13:36:33.762]                       else if (inherits(cond, "condition")) {
[13:36:33.762]                         if (!is.null(pattern)) {
[13:36:33.762]                           computeRestarts <- base::computeRestarts
[13:36:33.762]                           grepl <- base::grepl
[13:36:33.762]                           restarts <- computeRestarts(cond)
[13:36:33.762]                           for (restart in restarts) {
[13:36:33.762]                             name <- restart$name
[13:36:33.762]                             if (is.null(name)) 
[13:36:33.762]                               next
[13:36:33.762]                             if (!grepl(pattern, name)) 
[13:36:33.762]                               next
[13:36:33.762]                             invokeRestart(restart)
[13:36:33.762]                             muffled <- TRUE
[13:36:33.762]                             break
[13:36:33.762]                           }
[13:36:33.762]                         }
[13:36:33.762]                       }
[13:36:33.762]                       invisible(muffled)
[13:36:33.762]                     }
[13:36:33.762]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.762]                   }
[13:36:33.762]                 }
[13:36:33.762]             }
[13:36:33.762]         }))
[13:36:33.762]     }, error = function(ex) {
[13:36:33.762]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.762]                 ...future.rng), started = ...future.startTime, 
[13:36:33.762]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.762]             version = "1.8"), class = "FutureResult")
[13:36:33.762]     }, finally = {
[13:36:33.762]         if (!identical(...future.workdir, getwd())) 
[13:36:33.762]             setwd(...future.workdir)
[13:36:33.762]         {
[13:36:33.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.762]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.762]             }
[13:36:33.762]             base::options(...future.oldOptions)
[13:36:33.762]             if (.Platform$OS.type == "windows") {
[13:36:33.762]                 old_names <- names(...future.oldEnvVars)
[13:36:33.762]                 envs <- base::Sys.getenv()
[13:36:33.762]                 names <- names(envs)
[13:36:33.762]                 common <- intersect(names, old_names)
[13:36:33.762]                 added <- setdiff(names, old_names)
[13:36:33.762]                 removed <- setdiff(old_names, names)
[13:36:33.762]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.762]                   envs[common]]
[13:36:33.762]                 NAMES <- toupper(changed)
[13:36:33.762]                 args <- list()
[13:36:33.762]                 for (kk in seq_along(NAMES)) {
[13:36:33.762]                   name <- changed[[kk]]
[13:36:33.762]                   NAME <- NAMES[[kk]]
[13:36:33.762]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.762]                     next
[13:36:33.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.762]                 }
[13:36:33.762]                 NAMES <- toupper(added)
[13:36:33.762]                 for (kk in seq_along(NAMES)) {
[13:36:33.762]                   name <- added[[kk]]
[13:36:33.762]                   NAME <- NAMES[[kk]]
[13:36:33.762]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.762]                     next
[13:36:33.762]                   args[[name]] <- ""
[13:36:33.762]                 }
[13:36:33.762]                 NAMES <- toupper(removed)
[13:36:33.762]                 for (kk in seq_along(NAMES)) {
[13:36:33.762]                   name <- removed[[kk]]
[13:36:33.762]                   NAME <- NAMES[[kk]]
[13:36:33.762]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.762]                     next
[13:36:33.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.762]                 }
[13:36:33.762]                 if (length(args) > 0) 
[13:36:33.762]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.762]             }
[13:36:33.762]             else {
[13:36:33.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.762]             }
[13:36:33.762]             {
[13:36:33.762]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.762]                   0L) {
[13:36:33.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.762]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.762]                   base::options(opts)
[13:36:33.762]                 }
[13:36:33.762]                 {
[13:36:33.762]                   {
[13:36:33.762]                     NULL
[13:36:33.762]                     RNGkind("Mersenne-Twister")
[13:36:33.762]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.762]                       inherits = FALSE)
[13:36:33.762]                   }
[13:36:33.762]                   options(future.plan = NULL)
[13:36:33.762]                   if (is.na(NA_character_)) 
[13:36:33.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.762]                     .init = FALSE)
[13:36:33.762]                 }
[13:36:33.762]             }
[13:36:33.762]         }
[13:36:33.762]     })
[13:36:33.762]     if (TRUE) {
[13:36:33.762]         base::sink(type = "output", split = FALSE)
[13:36:33.762]         if (TRUE) {
[13:36:33.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.762]         }
[13:36:33.762]         else {
[13:36:33.762]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.762]         }
[13:36:33.762]         base::close(...future.stdout)
[13:36:33.762]         ...future.stdout <- NULL
[13:36:33.762]     }
[13:36:33.762]     ...future.result$conditions <- ...future.conditions
[13:36:33.762]     ...future.result$finished <- base::Sys.time()
[13:36:33.762]     ...future.result
[13:36:33.762] }
[13:36:33.763] plan(): Setting new future strategy stack:
[13:36:33.764] List of future strategies:
[13:36:33.764] 1. sequential:
[13:36:33.764]    - args: function (..., envir = parent.frame())
[13:36:33.764]    - tweaked: FALSE
[13:36:33.764]    - call: NULL
[13:36:33.764] plan(): nbrOfWorkers() = 1
[13:36:33.765] plan(): Setting new future strategy stack:
[13:36:33.765] List of future strategies:
[13:36:33.765] 1. sequential:
[13:36:33.765]    - args: function (..., envir = parent.frame())
[13:36:33.765]    - tweaked: FALSE
[13:36:33.765]    - call: plan(strategy)
[13:36:33.765] plan(): nbrOfWorkers() = 1
[13:36:33.765] SequentialFuture started (and completed)
[13:36:33.765] - Launch lazy future ... done
[13:36:33.765] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a725fa8e8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a72ed5f80> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a725fa8e8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a72ed5f80> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:36:33.771] resolved() for ‘SequentialFuture’ ...
[13:36:33.772] - state: ‘finished’
[13:36:33.772] - run: TRUE
[13:36:33.772] - result: ‘FutureResult’
[13:36:33.772] resolved() for ‘SequentialFuture’ ... done
[13:36:33.772] resolved() for ‘SequentialFuture’ ...
[13:36:33.772] - state: ‘finished’
[13:36:33.772] - run: TRUE
[13:36:33.772] - result: ‘FutureResult’
[13:36:33.772] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:33.773] resolve() on list ...
[13:36:33.773]  recursive: 0
[13:36:33.774]  length: 6
[13:36:33.774]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:33.774] signalConditionsASAP(numeric, pos=1) ...
[13:36:33.774] - nx: 6
[13:36:33.774] - relay: TRUE
[13:36:33.774] - stdout: TRUE
[13:36:33.774] - signal: TRUE
[13:36:33.774] - resignal: FALSE
[13:36:33.775] - force: TRUE
[13:36:33.775] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.775] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.775]  - until=2
[13:36:33.775]  - relaying element #2
[13:36:33.775] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.775] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.775] signalConditionsASAP(NULL, pos=1) ... done
[13:36:33.775]  length: 5 (resolved future 1)
[13:36:33.775] resolved() for ‘SequentialFuture’ ...
[13:36:33.775] - state: ‘finished’
[13:36:33.776] - run: TRUE
[13:36:33.776] - result: ‘FutureResult’
[13:36:33.776] resolved() for ‘SequentialFuture’ ... done
[13:36:33.776] Future #2
[13:36:33.776] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:33.776] - nx: 6
[13:36:33.776] - relay: TRUE
[13:36:33.776] - stdout: TRUE
[13:36:33.777] - signal: TRUE
[13:36:33.777] - resignal: FALSE
[13:36:33.777] - force: TRUE
[13:36:33.777] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.777] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.777]  - until=2
[13:36:33.777]  - relaying element #2
[13:36:33.777] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.777] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.777] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:33.779]  length: 4 (resolved future 2)
[13:36:33.779] resolved() for ‘SequentialFuture’ ...
[13:36:33.779] - state: ‘finished’
[13:36:33.780] - run: TRUE
[13:36:33.780] - result: ‘FutureResult’
[13:36:33.780] resolved() for ‘SequentialFuture’ ... done
[13:36:33.780] Future #3
[13:36:33.780] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:33.780] - nx: 6
[13:36:33.780] - relay: TRUE
[13:36:33.780] - stdout: TRUE
[13:36:33.780] - signal: TRUE
[13:36:33.780] - resignal: FALSE
[13:36:33.780] - force: TRUE
[13:36:33.781] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.781] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.781]  - until=3
[13:36:33.781]  - relaying element #3
[13:36:33.781] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.781] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.781] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:33.781]  length: 3 (resolved future 3)
[13:36:33.781] signalConditionsASAP(NULL, pos=4) ...
[13:36:33.782] - nx: 6
[13:36:33.782] - relay: TRUE
[13:36:33.782] - stdout: TRUE
[13:36:33.782] - signal: TRUE
[13:36:33.782] - resignal: FALSE
[13:36:33.782] - force: TRUE
[13:36:33.782] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.782] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.782]  - until=5
[13:36:33.782]  - relaying element #5
[13:36:33.782] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.782] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.783] signalConditionsASAP(NULL, pos=4) ... done
[13:36:33.783]  length: 2 (resolved future 4)
[13:36:33.783] signalConditionsASAP(NULL, pos=5) ...
[13:36:33.783] - nx: 6
[13:36:33.783] - relay: TRUE
[13:36:33.783] - stdout: TRUE
[13:36:33.783] - signal: TRUE
[13:36:33.783] - resignal: FALSE
[13:36:33.783] - force: TRUE
[13:36:33.783] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.783] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.783]  - until=6
[13:36:33.784]  - relaying element #6
[13:36:33.784] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.784] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.784] signalConditionsASAP(NULL, pos=5) ... done
[13:36:33.784]  length: 1 (resolved future 5)
[13:36:33.784] signalConditionsASAP(numeric, pos=6) ...
[13:36:33.784] - nx: 6
[13:36:33.784] - relay: TRUE
[13:36:33.784] - stdout: TRUE
[13:36:33.784] - signal: TRUE
[13:36:33.784] - resignal: FALSE
[13:36:33.784] - force: TRUE
[13:36:33.785] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.785] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.785]  - until=6
[13:36:33.785] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.785] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.785] signalConditionsASAP(numeric, pos=6) ... done
[13:36:33.785]  length: 0 (resolved future 6)
[13:36:33.785] Relaying remaining futures
[13:36:33.785] signalConditionsASAP(NULL, pos=0) ...
[13:36:33.785] - nx: 6
[13:36:33.785] - relay: TRUE
[13:36:33.785] - stdout: TRUE
[13:36:33.786] - signal: TRUE
[13:36:33.786] - resignal: FALSE
[13:36:33.786] - force: TRUE
[13:36:33.786] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.786] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:33.786] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.786] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.786] signalConditionsASAP(NULL, pos=0) ... done
[13:36:33.786] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:36:33.788] getGlobalsAndPackages() ...
[13:36:33.788] Searching for globals...
[13:36:33.789] 
[13:36:33.789] Searching for globals ... DONE
[13:36:33.789] - globals: [0] <none>
[13:36:33.789] getGlobalsAndPackages() ... DONE
[13:36:33.789] run() for ‘Future’ ...
[13:36:33.789] - state: ‘created’
[13:36:33.789] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.790] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.790]   - Field: ‘label’
[13:36:33.790]   - Field: ‘local’
[13:36:33.790]   - Field: ‘owner’
[13:36:33.790]   - Field: ‘envir’
[13:36:33.790]   - Field: ‘packages’
[13:36:33.790]   - Field: ‘gc’
[13:36:33.790]   - Field: ‘conditions’
[13:36:33.791]   - Field: ‘expr’
[13:36:33.791]   - Field: ‘uuid’
[13:36:33.791]   - Field: ‘seed’
[13:36:33.791]   - Field: ‘version’
[13:36:33.791]   - Field: ‘result’
[13:36:33.791]   - Field: ‘asynchronous’
[13:36:33.791]   - Field: ‘calls’
[13:36:33.791]   - Field: ‘globals’
[13:36:33.791]   - Field: ‘stdout’
[13:36:33.791]   - Field: ‘earlySignal’
[13:36:33.791]   - Field: ‘lazy’
[13:36:33.792]   - Field: ‘state’
[13:36:33.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.792] - Launch lazy future ...
[13:36:33.792] Packages needed by the future expression (n = 0): <none>
[13:36:33.792] Packages needed by future strategies (n = 0): <none>
[13:36:33.792] {
[13:36:33.792]     {
[13:36:33.792]         {
[13:36:33.792]             ...future.startTime <- base::Sys.time()
[13:36:33.792]             {
[13:36:33.792]                 {
[13:36:33.792]                   {
[13:36:33.792]                     base::local({
[13:36:33.792]                       has_future <- base::requireNamespace("future", 
[13:36:33.792]                         quietly = TRUE)
[13:36:33.792]                       if (has_future) {
[13:36:33.792]                         ns <- base::getNamespace("future")
[13:36:33.792]                         version <- ns[[".package"]][["version"]]
[13:36:33.792]                         if (is.null(version)) 
[13:36:33.792]                           version <- utils::packageVersion("future")
[13:36:33.792]                       }
[13:36:33.792]                       else {
[13:36:33.792]                         version <- NULL
[13:36:33.792]                       }
[13:36:33.792]                       if (!has_future || version < "1.8.0") {
[13:36:33.792]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.792]                           "", base::R.version$version.string), 
[13:36:33.792]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.792]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.792]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.792]                             "release", "version")], collapse = " "), 
[13:36:33.792]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.792]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.792]                           info)
[13:36:33.792]                         info <- base::paste(info, collapse = "; ")
[13:36:33.792]                         if (!has_future) {
[13:36:33.792]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.792]                             info)
[13:36:33.792]                         }
[13:36:33.792]                         else {
[13:36:33.792]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.792]                             info, version)
[13:36:33.792]                         }
[13:36:33.792]                         base::stop(msg)
[13:36:33.792]                       }
[13:36:33.792]                     })
[13:36:33.792]                   }
[13:36:33.792]                   ...future.strategy.old <- future::plan("list")
[13:36:33.792]                   options(future.plan = NULL)
[13:36:33.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.792]                 }
[13:36:33.792]                 ...future.workdir <- getwd()
[13:36:33.792]             }
[13:36:33.792]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.792]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.792]         }
[13:36:33.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.792]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.792]             base::names(...future.oldOptions))
[13:36:33.792]     }
[13:36:33.792]     if (FALSE) {
[13:36:33.792]     }
[13:36:33.792]     else {
[13:36:33.792]         if (TRUE) {
[13:36:33.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.792]                 open = "w")
[13:36:33.792]         }
[13:36:33.792]         else {
[13:36:33.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.792]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.792]         }
[13:36:33.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.792]             base::sink(type = "output", split = FALSE)
[13:36:33.792]             base::close(...future.stdout)
[13:36:33.792]         }, add = TRUE)
[13:36:33.792]     }
[13:36:33.792]     ...future.frame <- base::sys.nframe()
[13:36:33.792]     ...future.conditions <- base::list()
[13:36:33.792]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.792]     if (FALSE) {
[13:36:33.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.792]     }
[13:36:33.792]     ...future.result <- base::tryCatch({
[13:36:33.792]         base::withCallingHandlers({
[13:36:33.792]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.792]             future::FutureResult(value = ...future.value$value, 
[13:36:33.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.792]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.792]                     ...future.globalenv.names))
[13:36:33.792]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.792]         }, condition = base::local({
[13:36:33.792]             c <- base::c
[13:36:33.792]             inherits <- base::inherits
[13:36:33.792]             invokeRestart <- base::invokeRestart
[13:36:33.792]             length <- base::length
[13:36:33.792]             list <- base::list
[13:36:33.792]             seq.int <- base::seq.int
[13:36:33.792]             signalCondition <- base::signalCondition
[13:36:33.792]             sys.calls <- base::sys.calls
[13:36:33.792]             `[[` <- base::`[[`
[13:36:33.792]             `+` <- base::`+`
[13:36:33.792]             `<<-` <- base::`<<-`
[13:36:33.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.792]                   3L)]
[13:36:33.792]             }
[13:36:33.792]             function(cond) {
[13:36:33.792]                 is_error <- inherits(cond, "error")
[13:36:33.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.792]                   NULL)
[13:36:33.792]                 if (is_error) {
[13:36:33.792]                   sessionInformation <- function() {
[13:36:33.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.792]                       search = base::search(), system = base::Sys.info())
[13:36:33.792]                   }
[13:36:33.792]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.792]                     cond$call), session = sessionInformation(), 
[13:36:33.792]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.792]                   signalCondition(cond)
[13:36:33.792]                 }
[13:36:33.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.792]                 "immediateCondition"))) {
[13:36:33.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.792]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.792]                   if (TRUE && !signal) {
[13:36:33.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.792]                     {
[13:36:33.792]                       inherits <- base::inherits
[13:36:33.792]                       invokeRestart <- base::invokeRestart
[13:36:33.792]                       is.null <- base::is.null
[13:36:33.792]                       muffled <- FALSE
[13:36:33.792]                       if (inherits(cond, "message")) {
[13:36:33.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.792]                         if (muffled) 
[13:36:33.792]                           invokeRestart("muffleMessage")
[13:36:33.792]                       }
[13:36:33.792]                       else if (inherits(cond, "warning")) {
[13:36:33.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.792]                         if (muffled) 
[13:36:33.792]                           invokeRestart("muffleWarning")
[13:36:33.792]                       }
[13:36:33.792]                       else if (inherits(cond, "condition")) {
[13:36:33.792]                         if (!is.null(pattern)) {
[13:36:33.792]                           computeRestarts <- base::computeRestarts
[13:36:33.792]                           grepl <- base::grepl
[13:36:33.792]                           restarts <- computeRestarts(cond)
[13:36:33.792]                           for (restart in restarts) {
[13:36:33.792]                             name <- restart$name
[13:36:33.792]                             if (is.null(name)) 
[13:36:33.792]                               next
[13:36:33.792]                             if (!grepl(pattern, name)) 
[13:36:33.792]                               next
[13:36:33.792]                             invokeRestart(restart)
[13:36:33.792]                             muffled <- TRUE
[13:36:33.792]                             break
[13:36:33.792]                           }
[13:36:33.792]                         }
[13:36:33.792]                       }
[13:36:33.792]                       invisible(muffled)
[13:36:33.792]                     }
[13:36:33.792]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.792]                   }
[13:36:33.792]                 }
[13:36:33.792]                 else {
[13:36:33.792]                   if (TRUE) {
[13:36:33.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.792]                     {
[13:36:33.792]                       inherits <- base::inherits
[13:36:33.792]                       invokeRestart <- base::invokeRestart
[13:36:33.792]                       is.null <- base::is.null
[13:36:33.792]                       muffled <- FALSE
[13:36:33.792]                       if (inherits(cond, "message")) {
[13:36:33.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.792]                         if (muffled) 
[13:36:33.792]                           invokeRestart("muffleMessage")
[13:36:33.792]                       }
[13:36:33.792]                       else if (inherits(cond, "warning")) {
[13:36:33.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.792]                         if (muffled) 
[13:36:33.792]                           invokeRestart("muffleWarning")
[13:36:33.792]                       }
[13:36:33.792]                       else if (inherits(cond, "condition")) {
[13:36:33.792]                         if (!is.null(pattern)) {
[13:36:33.792]                           computeRestarts <- base::computeRestarts
[13:36:33.792]                           grepl <- base::grepl
[13:36:33.792]                           restarts <- computeRestarts(cond)
[13:36:33.792]                           for (restart in restarts) {
[13:36:33.792]                             name <- restart$name
[13:36:33.792]                             if (is.null(name)) 
[13:36:33.792]                               next
[13:36:33.792]                             if (!grepl(pattern, name)) 
[13:36:33.792]                               next
[13:36:33.792]                             invokeRestart(restart)
[13:36:33.792]                             muffled <- TRUE
[13:36:33.792]                             break
[13:36:33.792]                           }
[13:36:33.792]                         }
[13:36:33.792]                       }
[13:36:33.792]                       invisible(muffled)
[13:36:33.792]                     }
[13:36:33.792]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.792]                   }
[13:36:33.792]                 }
[13:36:33.792]             }
[13:36:33.792]         }))
[13:36:33.792]     }, error = function(ex) {
[13:36:33.792]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.792]                 ...future.rng), started = ...future.startTime, 
[13:36:33.792]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.792]             version = "1.8"), class = "FutureResult")
[13:36:33.792]     }, finally = {
[13:36:33.792]         if (!identical(...future.workdir, getwd())) 
[13:36:33.792]             setwd(...future.workdir)
[13:36:33.792]         {
[13:36:33.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.792]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.792]             }
[13:36:33.792]             base::options(...future.oldOptions)
[13:36:33.792]             if (.Platform$OS.type == "windows") {
[13:36:33.792]                 old_names <- names(...future.oldEnvVars)
[13:36:33.792]                 envs <- base::Sys.getenv()
[13:36:33.792]                 names <- names(envs)
[13:36:33.792]                 common <- intersect(names, old_names)
[13:36:33.792]                 added <- setdiff(names, old_names)
[13:36:33.792]                 removed <- setdiff(old_names, names)
[13:36:33.792]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.792]                   envs[common]]
[13:36:33.792]                 NAMES <- toupper(changed)
[13:36:33.792]                 args <- list()
[13:36:33.792]                 for (kk in seq_along(NAMES)) {
[13:36:33.792]                   name <- changed[[kk]]
[13:36:33.792]                   NAME <- NAMES[[kk]]
[13:36:33.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.792]                     next
[13:36:33.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.792]                 }
[13:36:33.792]                 NAMES <- toupper(added)
[13:36:33.792]                 for (kk in seq_along(NAMES)) {
[13:36:33.792]                   name <- added[[kk]]
[13:36:33.792]                   NAME <- NAMES[[kk]]
[13:36:33.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.792]                     next
[13:36:33.792]                   args[[name]] <- ""
[13:36:33.792]                 }
[13:36:33.792]                 NAMES <- toupper(removed)
[13:36:33.792]                 for (kk in seq_along(NAMES)) {
[13:36:33.792]                   name <- removed[[kk]]
[13:36:33.792]                   NAME <- NAMES[[kk]]
[13:36:33.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.792]                     next
[13:36:33.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.792]                 }
[13:36:33.792]                 if (length(args) > 0) 
[13:36:33.792]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.792]             }
[13:36:33.792]             else {
[13:36:33.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.792]             }
[13:36:33.792]             {
[13:36:33.792]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.792]                   0L) {
[13:36:33.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.792]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.792]                   base::options(opts)
[13:36:33.792]                 }
[13:36:33.792]                 {
[13:36:33.792]                   {
[13:36:33.792]                     NULL
[13:36:33.792]                     RNGkind("Mersenne-Twister")
[13:36:33.792]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.792]                       inherits = FALSE)
[13:36:33.792]                   }
[13:36:33.792]                   options(future.plan = NULL)
[13:36:33.792]                   if (is.na(NA_character_)) 
[13:36:33.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.792]                     .init = FALSE)
[13:36:33.792]                 }
[13:36:33.792]             }
[13:36:33.792]         }
[13:36:33.792]     })
[13:36:33.792]     if (TRUE) {
[13:36:33.792]         base::sink(type = "output", split = FALSE)
[13:36:33.792]         if (TRUE) {
[13:36:33.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.792]         }
[13:36:33.792]         else {
[13:36:33.792]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.792]         }
[13:36:33.792]         base::close(...future.stdout)
[13:36:33.792]         ...future.stdout <- NULL
[13:36:33.792]     }
[13:36:33.792]     ...future.result$conditions <- ...future.conditions
[13:36:33.792]     ...future.result$finished <- base::Sys.time()
[13:36:33.792]     ...future.result
[13:36:33.792] }
[13:36:33.794] plan(): Setting new future strategy stack:
[13:36:33.794] List of future strategies:
[13:36:33.794] 1. sequential:
[13:36:33.794]    - args: function (..., envir = parent.frame())
[13:36:33.794]    - tweaked: FALSE
[13:36:33.794]    - call: NULL
[13:36:33.794] plan(): nbrOfWorkers() = 1
[13:36:33.795] plan(): Setting new future strategy stack:
[13:36:33.795] List of future strategies:
[13:36:33.795] 1. sequential:
[13:36:33.795]    - args: function (..., envir = parent.frame())
[13:36:33.795]    - tweaked: FALSE
[13:36:33.795]    - call: plan(strategy)
[13:36:33.796] plan(): nbrOfWorkers() = 1
[13:36:33.796] SequentialFuture started (and completed)
[13:36:33.796] - Launch lazy future ... done
[13:36:33.796] run() for ‘SequentialFuture’ ... done
[13:36:33.796] getGlobalsAndPackages() ...
[13:36:33.796] Searching for globals...
[13:36:33.796] 
[13:36:33.796] Searching for globals ... DONE
[13:36:33.797] - globals: [0] <none>
[13:36:33.797] getGlobalsAndPackages() ... DONE
[13:36:33.797] run() for ‘Future’ ...
[13:36:33.797] - state: ‘created’
[13:36:33.797] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.797] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.797]   - Field: ‘label’
[13:36:33.798]   - Field: ‘local’
[13:36:33.798]   - Field: ‘owner’
[13:36:33.798]   - Field: ‘envir’
[13:36:33.798]   - Field: ‘packages’
[13:36:33.798]   - Field: ‘gc’
[13:36:33.798]   - Field: ‘conditions’
[13:36:33.798]   - Field: ‘expr’
[13:36:33.798]   - Field: ‘uuid’
[13:36:33.798]   - Field: ‘seed’
[13:36:33.798]   - Field: ‘version’
[13:36:33.799]   - Field: ‘result’
[13:36:33.799]   - Field: ‘asynchronous’
[13:36:33.799]   - Field: ‘calls’
[13:36:33.799]   - Field: ‘globals’
[13:36:33.799]   - Field: ‘stdout’
[13:36:33.799]   - Field: ‘earlySignal’
[13:36:33.799]   - Field: ‘lazy’
[13:36:33.799]   - Field: ‘state’
[13:36:33.799] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.799] - Launch lazy future ...
[13:36:33.799] Packages needed by the future expression (n = 0): <none>
[13:36:33.800] Packages needed by future strategies (n = 0): <none>
[13:36:33.800] {
[13:36:33.800]     {
[13:36:33.800]         {
[13:36:33.800]             ...future.startTime <- base::Sys.time()
[13:36:33.800]             {
[13:36:33.800]                 {
[13:36:33.800]                   {
[13:36:33.800]                     base::local({
[13:36:33.800]                       has_future <- base::requireNamespace("future", 
[13:36:33.800]                         quietly = TRUE)
[13:36:33.800]                       if (has_future) {
[13:36:33.800]                         ns <- base::getNamespace("future")
[13:36:33.800]                         version <- ns[[".package"]][["version"]]
[13:36:33.800]                         if (is.null(version)) 
[13:36:33.800]                           version <- utils::packageVersion("future")
[13:36:33.800]                       }
[13:36:33.800]                       else {
[13:36:33.800]                         version <- NULL
[13:36:33.800]                       }
[13:36:33.800]                       if (!has_future || version < "1.8.0") {
[13:36:33.800]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.800]                           "", base::R.version$version.string), 
[13:36:33.800]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.800]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.800]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.800]                             "release", "version")], collapse = " "), 
[13:36:33.800]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.800]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.800]                           info)
[13:36:33.800]                         info <- base::paste(info, collapse = "; ")
[13:36:33.800]                         if (!has_future) {
[13:36:33.800]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.800]                             info)
[13:36:33.800]                         }
[13:36:33.800]                         else {
[13:36:33.800]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.800]                             info, version)
[13:36:33.800]                         }
[13:36:33.800]                         base::stop(msg)
[13:36:33.800]                       }
[13:36:33.800]                     })
[13:36:33.800]                   }
[13:36:33.800]                   ...future.strategy.old <- future::plan("list")
[13:36:33.800]                   options(future.plan = NULL)
[13:36:33.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.800]                 }
[13:36:33.800]                 ...future.workdir <- getwd()
[13:36:33.800]             }
[13:36:33.800]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.800]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.800]         }
[13:36:33.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.800]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.800]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.800]             base::names(...future.oldOptions))
[13:36:33.800]     }
[13:36:33.800]     if (FALSE) {
[13:36:33.800]     }
[13:36:33.800]     else {
[13:36:33.800]         if (TRUE) {
[13:36:33.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.800]                 open = "w")
[13:36:33.800]         }
[13:36:33.800]         else {
[13:36:33.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.800]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.800]         }
[13:36:33.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.800]             base::sink(type = "output", split = FALSE)
[13:36:33.800]             base::close(...future.stdout)
[13:36:33.800]         }, add = TRUE)
[13:36:33.800]     }
[13:36:33.800]     ...future.frame <- base::sys.nframe()
[13:36:33.800]     ...future.conditions <- base::list()
[13:36:33.800]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.800]     if (FALSE) {
[13:36:33.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.800]     }
[13:36:33.800]     ...future.result <- base::tryCatch({
[13:36:33.800]         base::withCallingHandlers({
[13:36:33.800]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.800]             future::FutureResult(value = ...future.value$value, 
[13:36:33.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.800]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.800]                     ...future.globalenv.names))
[13:36:33.800]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.800]         }, condition = base::local({
[13:36:33.800]             c <- base::c
[13:36:33.800]             inherits <- base::inherits
[13:36:33.800]             invokeRestart <- base::invokeRestart
[13:36:33.800]             length <- base::length
[13:36:33.800]             list <- base::list
[13:36:33.800]             seq.int <- base::seq.int
[13:36:33.800]             signalCondition <- base::signalCondition
[13:36:33.800]             sys.calls <- base::sys.calls
[13:36:33.800]             `[[` <- base::`[[`
[13:36:33.800]             `+` <- base::`+`
[13:36:33.800]             `<<-` <- base::`<<-`
[13:36:33.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.800]                   3L)]
[13:36:33.800]             }
[13:36:33.800]             function(cond) {
[13:36:33.800]                 is_error <- inherits(cond, "error")
[13:36:33.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.800]                   NULL)
[13:36:33.800]                 if (is_error) {
[13:36:33.800]                   sessionInformation <- function() {
[13:36:33.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.800]                       search = base::search(), system = base::Sys.info())
[13:36:33.800]                   }
[13:36:33.800]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.800]                     cond$call), session = sessionInformation(), 
[13:36:33.800]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.800]                   signalCondition(cond)
[13:36:33.800]                 }
[13:36:33.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.800]                 "immediateCondition"))) {
[13:36:33.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.800]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.800]                   if (TRUE && !signal) {
[13:36:33.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.800]                     {
[13:36:33.800]                       inherits <- base::inherits
[13:36:33.800]                       invokeRestart <- base::invokeRestart
[13:36:33.800]                       is.null <- base::is.null
[13:36:33.800]                       muffled <- FALSE
[13:36:33.800]                       if (inherits(cond, "message")) {
[13:36:33.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.800]                         if (muffled) 
[13:36:33.800]                           invokeRestart("muffleMessage")
[13:36:33.800]                       }
[13:36:33.800]                       else if (inherits(cond, "warning")) {
[13:36:33.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.800]                         if (muffled) 
[13:36:33.800]                           invokeRestart("muffleWarning")
[13:36:33.800]                       }
[13:36:33.800]                       else if (inherits(cond, "condition")) {
[13:36:33.800]                         if (!is.null(pattern)) {
[13:36:33.800]                           computeRestarts <- base::computeRestarts
[13:36:33.800]                           grepl <- base::grepl
[13:36:33.800]                           restarts <- computeRestarts(cond)
[13:36:33.800]                           for (restart in restarts) {
[13:36:33.800]                             name <- restart$name
[13:36:33.800]                             if (is.null(name)) 
[13:36:33.800]                               next
[13:36:33.800]                             if (!grepl(pattern, name)) 
[13:36:33.800]                               next
[13:36:33.800]                             invokeRestart(restart)
[13:36:33.800]                             muffled <- TRUE
[13:36:33.800]                             break
[13:36:33.800]                           }
[13:36:33.800]                         }
[13:36:33.800]                       }
[13:36:33.800]                       invisible(muffled)
[13:36:33.800]                     }
[13:36:33.800]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.800]                   }
[13:36:33.800]                 }
[13:36:33.800]                 else {
[13:36:33.800]                   if (TRUE) {
[13:36:33.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.800]                     {
[13:36:33.800]                       inherits <- base::inherits
[13:36:33.800]                       invokeRestart <- base::invokeRestart
[13:36:33.800]                       is.null <- base::is.null
[13:36:33.800]                       muffled <- FALSE
[13:36:33.800]                       if (inherits(cond, "message")) {
[13:36:33.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.800]                         if (muffled) 
[13:36:33.800]                           invokeRestart("muffleMessage")
[13:36:33.800]                       }
[13:36:33.800]                       else if (inherits(cond, "warning")) {
[13:36:33.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.800]                         if (muffled) 
[13:36:33.800]                           invokeRestart("muffleWarning")
[13:36:33.800]                       }
[13:36:33.800]                       else if (inherits(cond, "condition")) {
[13:36:33.800]                         if (!is.null(pattern)) {
[13:36:33.800]                           computeRestarts <- base::computeRestarts
[13:36:33.800]                           grepl <- base::grepl
[13:36:33.800]                           restarts <- computeRestarts(cond)
[13:36:33.800]                           for (restart in restarts) {
[13:36:33.800]                             name <- restart$name
[13:36:33.800]                             if (is.null(name)) 
[13:36:33.800]                               next
[13:36:33.800]                             if (!grepl(pattern, name)) 
[13:36:33.800]                               next
[13:36:33.800]                             invokeRestart(restart)
[13:36:33.800]                             muffled <- TRUE
[13:36:33.800]                             break
[13:36:33.800]                           }
[13:36:33.800]                         }
[13:36:33.800]                       }
[13:36:33.800]                       invisible(muffled)
[13:36:33.800]                     }
[13:36:33.800]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.800]                   }
[13:36:33.800]                 }
[13:36:33.800]             }
[13:36:33.800]         }))
[13:36:33.800]     }, error = function(ex) {
[13:36:33.800]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.800]                 ...future.rng), started = ...future.startTime, 
[13:36:33.800]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.800]             version = "1.8"), class = "FutureResult")
[13:36:33.800]     }, finally = {
[13:36:33.800]         if (!identical(...future.workdir, getwd())) 
[13:36:33.800]             setwd(...future.workdir)
[13:36:33.800]         {
[13:36:33.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.800]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.800]             }
[13:36:33.800]             base::options(...future.oldOptions)
[13:36:33.800]             if (.Platform$OS.type == "windows") {
[13:36:33.800]                 old_names <- names(...future.oldEnvVars)
[13:36:33.800]                 envs <- base::Sys.getenv()
[13:36:33.800]                 names <- names(envs)
[13:36:33.800]                 common <- intersect(names, old_names)
[13:36:33.800]                 added <- setdiff(names, old_names)
[13:36:33.800]                 removed <- setdiff(old_names, names)
[13:36:33.800]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.800]                   envs[common]]
[13:36:33.800]                 NAMES <- toupper(changed)
[13:36:33.800]                 args <- list()
[13:36:33.800]                 for (kk in seq_along(NAMES)) {
[13:36:33.800]                   name <- changed[[kk]]
[13:36:33.800]                   NAME <- NAMES[[kk]]
[13:36:33.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.800]                     next
[13:36:33.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.800]                 }
[13:36:33.800]                 NAMES <- toupper(added)
[13:36:33.800]                 for (kk in seq_along(NAMES)) {
[13:36:33.800]                   name <- added[[kk]]
[13:36:33.800]                   NAME <- NAMES[[kk]]
[13:36:33.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.800]                     next
[13:36:33.800]                   args[[name]] <- ""
[13:36:33.800]                 }
[13:36:33.800]                 NAMES <- toupper(removed)
[13:36:33.800]                 for (kk in seq_along(NAMES)) {
[13:36:33.800]                   name <- removed[[kk]]
[13:36:33.800]                   NAME <- NAMES[[kk]]
[13:36:33.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.800]                     next
[13:36:33.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.800]                 }
[13:36:33.800]                 if (length(args) > 0) 
[13:36:33.800]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.800]             }
[13:36:33.800]             else {
[13:36:33.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.800]             }
[13:36:33.800]             {
[13:36:33.800]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.800]                   0L) {
[13:36:33.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.800]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.800]                   base::options(opts)
[13:36:33.800]                 }
[13:36:33.800]                 {
[13:36:33.800]                   {
[13:36:33.800]                     NULL
[13:36:33.800]                     RNGkind("Mersenne-Twister")
[13:36:33.800]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.800]                       inherits = FALSE)
[13:36:33.800]                   }
[13:36:33.800]                   options(future.plan = NULL)
[13:36:33.800]                   if (is.na(NA_character_)) 
[13:36:33.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.800]                     .init = FALSE)
[13:36:33.800]                 }
[13:36:33.800]             }
[13:36:33.800]         }
[13:36:33.800]     })
[13:36:33.800]     if (TRUE) {
[13:36:33.800]         base::sink(type = "output", split = FALSE)
[13:36:33.800]         if (TRUE) {
[13:36:33.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.800]         }
[13:36:33.800]         else {
[13:36:33.800]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.800]         }
[13:36:33.800]         base::close(...future.stdout)
[13:36:33.800]         ...future.stdout <- NULL
[13:36:33.800]     }
[13:36:33.800]     ...future.result$conditions <- ...future.conditions
[13:36:33.800]     ...future.result$finished <- base::Sys.time()
[13:36:33.800]     ...future.result
[13:36:33.800] }
[13:36:33.802] plan(): Setting new future strategy stack:
[13:36:33.802] List of future strategies:
[13:36:33.802] 1. sequential:
[13:36:33.802]    - args: function (..., envir = parent.frame())
[13:36:33.802]    - tweaked: FALSE
[13:36:33.802]    - call: NULL
[13:36:33.802] plan(): nbrOfWorkers() = 1
[13:36:33.803] plan(): Setting new future strategy stack:
[13:36:33.803] List of future strategies:
[13:36:33.803] 1. sequential:
[13:36:33.803]    - args: function (..., envir = parent.frame())
[13:36:33.803]    - tweaked: FALSE
[13:36:33.803]    - call: plan(strategy)
[13:36:33.803] plan(): nbrOfWorkers() = 1
[13:36:33.803] SequentialFuture started (and completed)
[13:36:33.803] - Launch lazy future ... done
[13:36:33.803] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a72ea5f68> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a73296b18> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a72ea5f68> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a73296b18> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:36:33.809] resolved() for ‘SequentialFuture’ ...
[13:36:33.809] - state: ‘finished’
[13:36:33.809] - run: TRUE
[13:36:33.809] - result: ‘FutureResult’
[13:36:33.809] resolved() for ‘SequentialFuture’ ... done
[13:36:33.810] resolved() for ‘SequentialFuture’ ...
[13:36:33.810] - state: ‘finished’
[13:36:33.810] - run: TRUE
[13:36:33.810] - result: ‘FutureResult’
[13:36:33.810] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:33.812] resolve() on list ...
[13:36:33.812]  recursive: 0
[13:36:33.812]  length: 6
[13:36:33.812]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:33.812] signalConditionsASAP(numeric, pos=1) ...
[13:36:33.812] - nx: 6
[13:36:33.812] - relay: TRUE
[13:36:33.812] - stdout: TRUE
[13:36:33.812] - signal: TRUE
[13:36:33.813] - resignal: FALSE
[13:36:33.813] - force: TRUE
[13:36:33.813] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.813] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.813]  - until=2
[13:36:33.813]  - relaying element #2
[13:36:33.813] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.813] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.813] signalConditionsASAP(NULL, pos=1) ... done
[13:36:33.813]  length: 5 (resolved future 1)
[13:36:33.813] resolved() for ‘SequentialFuture’ ...
[13:36:33.814] - state: ‘finished’
[13:36:33.814] - run: TRUE
[13:36:33.814] - result: ‘FutureResult’
[13:36:33.814] resolved() for ‘SequentialFuture’ ... done
[13:36:33.814] Future #2
[13:36:33.814] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:33.814] - nx: 6
[13:36:33.814] - relay: TRUE
[13:36:33.814] - stdout: TRUE
[13:36:33.814] - signal: TRUE
[13:36:33.814] - resignal: FALSE
[13:36:33.815] - force: TRUE
[13:36:33.815] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.815] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.815]  - until=2
[13:36:33.815]  - relaying element #2
[13:36:33.815] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.815] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.815] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:33.815]  length: 4 (resolved future 2)
[13:36:33.815] resolved() for ‘SequentialFuture’ ...
[13:36:33.816] - state: ‘finished’
[13:36:33.816] - run: TRUE
[13:36:33.816] - result: ‘FutureResult’
[13:36:33.816] resolved() for ‘SequentialFuture’ ... done
[13:36:33.816] Future #3
[13:36:33.816] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:33.816] - nx: 6
[13:36:33.816] - relay: TRUE
[13:36:33.816] - stdout: TRUE
[13:36:33.816] - signal: TRUE
[13:36:33.816] - resignal: FALSE
[13:36:33.816] - force: TRUE
[13:36:33.817] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.817] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.817]  - until=3
[13:36:33.817]  - relaying element #3
[13:36:33.817] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.817] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.817] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:33.817]  length: 3 (resolved future 3)
[13:36:33.817] signalConditionsASAP(NULL, pos=4) ...
[13:36:33.817] - nx: 6
[13:36:33.817] - relay: TRUE
[13:36:33.818] - stdout: TRUE
[13:36:33.818] - signal: TRUE
[13:36:33.818] - resignal: FALSE
[13:36:33.818] - force: TRUE
[13:36:33.818] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.818] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.818]  - until=5
[13:36:33.818]  - relaying element #5
[13:36:33.818] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.818] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.818] signalConditionsASAP(NULL, pos=4) ... done
[13:36:33.818]  length: 2 (resolved future 4)
[13:36:33.819] signalConditionsASAP(NULL, pos=5) ...
[13:36:33.819] - nx: 6
[13:36:33.819] - relay: TRUE
[13:36:33.819] - stdout: TRUE
[13:36:33.819] - signal: TRUE
[13:36:33.819] - resignal: FALSE
[13:36:33.819] - force: TRUE
[13:36:33.819] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.819] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.819]  - until=6
[13:36:33.819]  - relaying element #6
[13:36:33.819] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.820] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.820] signalConditionsASAP(NULL, pos=5) ... done
[13:36:33.820]  length: 1 (resolved future 5)
[13:36:33.820] signalConditionsASAP(numeric, pos=6) ...
[13:36:33.820] - nx: 6
[13:36:33.820] - relay: TRUE
[13:36:33.820] - stdout: TRUE
[13:36:33.820] - signal: TRUE
[13:36:33.820] - resignal: FALSE
[13:36:33.820] - force: TRUE
[13:36:33.820] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.820] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.820]  - until=6
[13:36:33.821] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.821] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.821] signalConditionsASAP(numeric, pos=6) ... done
[13:36:33.821]  length: 0 (resolved future 6)
[13:36:33.821] Relaying remaining futures
[13:36:33.821] signalConditionsASAP(NULL, pos=0) ...
[13:36:33.821] - nx: 6
[13:36:33.821] - relay: TRUE
[13:36:33.821] - stdout: TRUE
[13:36:33.821] - signal: TRUE
[13:36:33.821] - resignal: FALSE
[13:36:33.821] - force: TRUE
[13:36:33.822] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.822] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:33.822] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.822] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.822] signalConditionsASAP(NULL, pos=0) ... done
[13:36:33.822] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:36:33.825] getGlobalsAndPackages() ...
[13:36:33.825] Searching for globals...
[13:36:33.825] 
[13:36:33.826] Searching for globals ... DONE
[13:36:33.826] - globals: [0] <none>
[13:36:33.826] getGlobalsAndPackages() ... DONE
[13:36:33.826] run() for ‘Future’ ...
[13:36:33.826] - state: ‘created’
[13:36:33.826] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.826] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.827]   - Field: ‘label’
[13:36:33.827]   - Field: ‘local’
[13:36:33.827]   - Field: ‘owner’
[13:36:33.827]   - Field: ‘envir’
[13:36:33.827]   - Field: ‘packages’
[13:36:33.827]   - Field: ‘gc’
[13:36:33.827]   - Field: ‘conditions’
[13:36:33.827]   - Field: ‘expr’
[13:36:33.827]   - Field: ‘uuid’
[13:36:33.827]   - Field: ‘seed’
[13:36:33.827]   - Field: ‘version’
[13:36:33.828]   - Field: ‘result’
[13:36:33.828]   - Field: ‘asynchronous’
[13:36:33.828]   - Field: ‘calls’
[13:36:33.828]   - Field: ‘globals’
[13:36:33.828]   - Field: ‘stdout’
[13:36:33.828]   - Field: ‘earlySignal’
[13:36:33.828]   - Field: ‘lazy’
[13:36:33.828]   - Field: ‘state’
[13:36:33.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.828] - Launch lazy future ...
[13:36:33.829] Packages needed by the future expression (n = 0): <none>
[13:36:33.829] Packages needed by future strategies (n = 0): <none>
[13:36:33.829] {
[13:36:33.829]     {
[13:36:33.829]         {
[13:36:33.829]             ...future.startTime <- base::Sys.time()
[13:36:33.829]             {
[13:36:33.829]                 {
[13:36:33.829]                   {
[13:36:33.829]                     base::local({
[13:36:33.829]                       has_future <- base::requireNamespace("future", 
[13:36:33.829]                         quietly = TRUE)
[13:36:33.829]                       if (has_future) {
[13:36:33.829]                         ns <- base::getNamespace("future")
[13:36:33.829]                         version <- ns[[".package"]][["version"]]
[13:36:33.829]                         if (is.null(version)) 
[13:36:33.829]                           version <- utils::packageVersion("future")
[13:36:33.829]                       }
[13:36:33.829]                       else {
[13:36:33.829]                         version <- NULL
[13:36:33.829]                       }
[13:36:33.829]                       if (!has_future || version < "1.8.0") {
[13:36:33.829]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.829]                           "", base::R.version$version.string), 
[13:36:33.829]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.829]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.829]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.829]                             "release", "version")], collapse = " "), 
[13:36:33.829]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.829]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.829]                           info)
[13:36:33.829]                         info <- base::paste(info, collapse = "; ")
[13:36:33.829]                         if (!has_future) {
[13:36:33.829]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.829]                             info)
[13:36:33.829]                         }
[13:36:33.829]                         else {
[13:36:33.829]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.829]                             info, version)
[13:36:33.829]                         }
[13:36:33.829]                         base::stop(msg)
[13:36:33.829]                       }
[13:36:33.829]                     })
[13:36:33.829]                   }
[13:36:33.829]                   ...future.strategy.old <- future::plan("list")
[13:36:33.829]                   options(future.plan = NULL)
[13:36:33.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.829]                 }
[13:36:33.829]                 ...future.workdir <- getwd()
[13:36:33.829]             }
[13:36:33.829]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.829]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.829]         }
[13:36:33.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.829]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.829]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.829]             base::names(...future.oldOptions))
[13:36:33.829]     }
[13:36:33.829]     if (FALSE) {
[13:36:33.829]     }
[13:36:33.829]     else {
[13:36:33.829]         if (TRUE) {
[13:36:33.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.829]                 open = "w")
[13:36:33.829]         }
[13:36:33.829]         else {
[13:36:33.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.829]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.829]         }
[13:36:33.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.829]             base::sink(type = "output", split = FALSE)
[13:36:33.829]             base::close(...future.stdout)
[13:36:33.829]         }, add = TRUE)
[13:36:33.829]     }
[13:36:33.829]     ...future.frame <- base::sys.nframe()
[13:36:33.829]     ...future.conditions <- base::list()
[13:36:33.829]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.829]     if (FALSE) {
[13:36:33.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.829]     }
[13:36:33.829]     ...future.result <- base::tryCatch({
[13:36:33.829]         base::withCallingHandlers({
[13:36:33.829]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.829]             future::FutureResult(value = ...future.value$value, 
[13:36:33.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.829]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.829]                     ...future.globalenv.names))
[13:36:33.829]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.829]         }, condition = base::local({
[13:36:33.829]             c <- base::c
[13:36:33.829]             inherits <- base::inherits
[13:36:33.829]             invokeRestart <- base::invokeRestart
[13:36:33.829]             length <- base::length
[13:36:33.829]             list <- base::list
[13:36:33.829]             seq.int <- base::seq.int
[13:36:33.829]             signalCondition <- base::signalCondition
[13:36:33.829]             sys.calls <- base::sys.calls
[13:36:33.829]             `[[` <- base::`[[`
[13:36:33.829]             `+` <- base::`+`
[13:36:33.829]             `<<-` <- base::`<<-`
[13:36:33.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.829]                   3L)]
[13:36:33.829]             }
[13:36:33.829]             function(cond) {
[13:36:33.829]                 is_error <- inherits(cond, "error")
[13:36:33.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.829]                   NULL)
[13:36:33.829]                 if (is_error) {
[13:36:33.829]                   sessionInformation <- function() {
[13:36:33.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.829]                       search = base::search(), system = base::Sys.info())
[13:36:33.829]                   }
[13:36:33.829]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.829]                     cond$call), session = sessionInformation(), 
[13:36:33.829]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.829]                   signalCondition(cond)
[13:36:33.829]                 }
[13:36:33.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.829]                 "immediateCondition"))) {
[13:36:33.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.829]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.829]                   if (TRUE && !signal) {
[13:36:33.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.829]                     {
[13:36:33.829]                       inherits <- base::inherits
[13:36:33.829]                       invokeRestart <- base::invokeRestart
[13:36:33.829]                       is.null <- base::is.null
[13:36:33.829]                       muffled <- FALSE
[13:36:33.829]                       if (inherits(cond, "message")) {
[13:36:33.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.829]                         if (muffled) 
[13:36:33.829]                           invokeRestart("muffleMessage")
[13:36:33.829]                       }
[13:36:33.829]                       else if (inherits(cond, "warning")) {
[13:36:33.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.829]                         if (muffled) 
[13:36:33.829]                           invokeRestart("muffleWarning")
[13:36:33.829]                       }
[13:36:33.829]                       else if (inherits(cond, "condition")) {
[13:36:33.829]                         if (!is.null(pattern)) {
[13:36:33.829]                           computeRestarts <- base::computeRestarts
[13:36:33.829]                           grepl <- base::grepl
[13:36:33.829]                           restarts <- computeRestarts(cond)
[13:36:33.829]                           for (restart in restarts) {
[13:36:33.829]                             name <- restart$name
[13:36:33.829]                             if (is.null(name)) 
[13:36:33.829]                               next
[13:36:33.829]                             if (!grepl(pattern, name)) 
[13:36:33.829]                               next
[13:36:33.829]                             invokeRestart(restart)
[13:36:33.829]                             muffled <- TRUE
[13:36:33.829]                             break
[13:36:33.829]                           }
[13:36:33.829]                         }
[13:36:33.829]                       }
[13:36:33.829]                       invisible(muffled)
[13:36:33.829]                     }
[13:36:33.829]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.829]                   }
[13:36:33.829]                 }
[13:36:33.829]                 else {
[13:36:33.829]                   if (TRUE) {
[13:36:33.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.829]                     {
[13:36:33.829]                       inherits <- base::inherits
[13:36:33.829]                       invokeRestart <- base::invokeRestart
[13:36:33.829]                       is.null <- base::is.null
[13:36:33.829]                       muffled <- FALSE
[13:36:33.829]                       if (inherits(cond, "message")) {
[13:36:33.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.829]                         if (muffled) 
[13:36:33.829]                           invokeRestart("muffleMessage")
[13:36:33.829]                       }
[13:36:33.829]                       else if (inherits(cond, "warning")) {
[13:36:33.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.829]                         if (muffled) 
[13:36:33.829]                           invokeRestart("muffleWarning")
[13:36:33.829]                       }
[13:36:33.829]                       else if (inherits(cond, "condition")) {
[13:36:33.829]                         if (!is.null(pattern)) {
[13:36:33.829]                           computeRestarts <- base::computeRestarts
[13:36:33.829]                           grepl <- base::grepl
[13:36:33.829]                           restarts <- computeRestarts(cond)
[13:36:33.829]                           for (restart in restarts) {
[13:36:33.829]                             name <- restart$name
[13:36:33.829]                             if (is.null(name)) 
[13:36:33.829]                               next
[13:36:33.829]                             if (!grepl(pattern, name)) 
[13:36:33.829]                               next
[13:36:33.829]                             invokeRestart(restart)
[13:36:33.829]                             muffled <- TRUE
[13:36:33.829]                             break
[13:36:33.829]                           }
[13:36:33.829]                         }
[13:36:33.829]                       }
[13:36:33.829]                       invisible(muffled)
[13:36:33.829]                     }
[13:36:33.829]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.829]                   }
[13:36:33.829]                 }
[13:36:33.829]             }
[13:36:33.829]         }))
[13:36:33.829]     }, error = function(ex) {
[13:36:33.829]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.829]                 ...future.rng), started = ...future.startTime, 
[13:36:33.829]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.829]             version = "1.8"), class = "FutureResult")
[13:36:33.829]     }, finally = {
[13:36:33.829]         if (!identical(...future.workdir, getwd())) 
[13:36:33.829]             setwd(...future.workdir)
[13:36:33.829]         {
[13:36:33.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.829]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.829]             }
[13:36:33.829]             base::options(...future.oldOptions)
[13:36:33.829]             if (.Platform$OS.type == "windows") {
[13:36:33.829]                 old_names <- names(...future.oldEnvVars)
[13:36:33.829]                 envs <- base::Sys.getenv()
[13:36:33.829]                 names <- names(envs)
[13:36:33.829]                 common <- intersect(names, old_names)
[13:36:33.829]                 added <- setdiff(names, old_names)
[13:36:33.829]                 removed <- setdiff(old_names, names)
[13:36:33.829]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.829]                   envs[common]]
[13:36:33.829]                 NAMES <- toupper(changed)
[13:36:33.829]                 args <- list()
[13:36:33.829]                 for (kk in seq_along(NAMES)) {
[13:36:33.829]                   name <- changed[[kk]]
[13:36:33.829]                   NAME <- NAMES[[kk]]
[13:36:33.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.829]                     next
[13:36:33.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.829]                 }
[13:36:33.829]                 NAMES <- toupper(added)
[13:36:33.829]                 for (kk in seq_along(NAMES)) {
[13:36:33.829]                   name <- added[[kk]]
[13:36:33.829]                   NAME <- NAMES[[kk]]
[13:36:33.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.829]                     next
[13:36:33.829]                   args[[name]] <- ""
[13:36:33.829]                 }
[13:36:33.829]                 NAMES <- toupper(removed)
[13:36:33.829]                 for (kk in seq_along(NAMES)) {
[13:36:33.829]                   name <- removed[[kk]]
[13:36:33.829]                   NAME <- NAMES[[kk]]
[13:36:33.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.829]                     next
[13:36:33.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.829]                 }
[13:36:33.829]                 if (length(args) > 0) 
[13:36:33.829]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.829]             }
[13:36:33.829]             else {
[13:36:33.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.829]             }
[13:36:33.829]             {
[13:36:33.829]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.829]                   0L) {
[13:36:33.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.829]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.829]                   base::options(opts)
[13:36:33.829]                 }
[13:36:33.829]                 {
[13:36:33.829]                   {
[13:36:33.829]                     NULL
[13:36:33.829]                     RNGkind("Mersenne-Twister")
[13:36:33.829]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.829]                       inherits = FALSE)
[13:36:33.829]                   }
[13:36:33.829]                   options(future.plan = NULL)
[13:36:33.829]                   if (is.na(NA_character_)) 
[13:36:33.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.829]                     .init = FALSE)
[13:36:33.829]                 }
[13:36:33.829]             }
[13:36:33.829]         }
[13:36:33.829]     })
[13:36:33.829]     if (TRUE) {
[13:36:33.829]         base::sink(type = "output", split = FALSE)
[13:36:33.829]         if (TRUE) {
[13:36:33.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.829]         }
[13:36:33.829]         else {
[13:36:33.829]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.829]         }
[13:36:33.829]         base::close(...future.stdout)
[13:36:33.829]         ...future.stdout <- NULL
[13:36:33.829]     }
[13:36:33.829]     ...future.result$conditions <- ...future.conditions
[13:36:33.829]     ...future.result$finished <- base::Sys.time()
[13:36:33.829]     ...future.result
[13:36:33.829] }
[13:36:33.831] plan(): Setting new future strategy stack:
[13:36:33.831] List of future strategies:
[13:36:33.831] 1. sequential:
[13:36:33.831]    - args: function (..., envir = parent.frame())
[13:36:33.831]    - tweaked: FALSE
[13:36:33.831]    - call: NULL
[13:36:33.831] plan(): nbrOfWorkers() = 1
[13:36:33.832] plan(): Setting new future strategy stack:
[13:36:33.832] List of future strategies:
[13:36:33.832] 1. sequential:
[13:36:33.832]    - args: function (..., envir = parent.frame())
[13:36:33.832]    - tweaked: FALSE
[13:36:33.832]    - call: plan(strategy)
[13:36:33.832] plan(): nbrOfWorkers() = 1
[13:36:33.832] SequentialFuture started (and completed)
[13:36:33.833] - Launch lazy future ... done
[13:36:33.833] run() for ‘SequentialFuture’ ... done
[13:36:33.833] getGlobalsAndPackages() ...
[13:36:33.833] Searching for globals...
[13:36:33.834] 
[13:36:33.834] Searching for globals ... DONE
[13:36:33.834] - globals: [0] <none>
[13:36:33.834] getGlobalsAndPackages() ... DONE
[13:36:33.834] run() for ‘Future’ ...
[13:36:33.835] - state: ‘created’
[13:36:33.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.835] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.835] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.835]   - Field: ‘label’
[13:36:33.835]   - Field: ‘local’
[13:36:33.835]   - Field: ‘owner’
[13:36:33.835]   - Field: ‘envir’
[13:36:33.835]   - Field: ‘packages’
[13:36:33.836]   - Field: ‘gc’
[13:36:33.836]   - Field: ‘conditions’
[13:36:33.836]   - Field: ‘expr’
[13:36:33.836]   - Field: ‘uuid’
[13:36:33.836]   - Field: ‘seed’
[13:36:33.836]   - Field: ‘version’
[13:36:33.836]   - Field: ‘result’
[13:36:33.836]   - Field: ‘asynchronous’
[13:36:33.836]   - Field: ‘calls’
[13:36:33.836]   - Field: ‘globals’
[13:36:33.836]   - Field: ‘stdout’
[13:36:33.837]   - Field: ‘earlySignal’
[13:36:33.837]   - Field: ‘lazy’
[13:36:33.837]   - Field: ‘state’
[13:36:33.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.837] - Launch lazy future ...
[13:36:33.837] Packages needed by the future expression (n = 0): <none>
[13:36:33.837] Packages needed by future strategies (n = 0): <none>
[13:36:33.838] {
[13:36:33.838]     {
[13:36:33.838]         {
[13:36:33.838]             ...future.startTime <- base::Sys.time()
[13:36:33.838]             {
[13:36:33.838]                 {
[13:36:33.838]                   {
[13:36:33.838]                     base::local({
[13:36:33.838]                       has_future <- base::requireNamespace("future", 
[13:36:33.838]                         quietly = TRUE)
[13:36:33.838]                       if (has_future) {
[13:36:33.838]                         ns <- base::getNamespace("future")
[13:36:33.838]                         version <- ns[[".package"]][["version"]]
[13:36:33.838]                         if (is.null(version)) 
[13:36:33.838]                           version <- utils::packageVersion("future")
[13:36:33.838]                       }
[13:36:33.838]                       else {
[13:36:33.838]                         version <- NULL
[13:36:33.838]                       }
[13:36:33.838]                       if (!has_future || version < "1.8.0") {
[13:36:33.838]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.838]                           "", base::R.version$version.string), 
[13:36:33.838]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.838]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.838]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.838]                             "release", "version")], collapse = " "), 
[13:36:33.838]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.838]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.838]                           info)
[13:36:33.838]                         info <- base::paste(info, collapse = "; ")
[13:36:33.838]                         if (!has_future) {
[13:36:33.838]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.838]                             info)
[13:36:33.838]                         }
[13:36:33.838]                         else {
[13:36:33.838]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.838]                             info, version)
[13:36:33.838]                         }
[13:36:33.838]                         base::stop(msg)
[13:36:33.838]                       }
[13:36:33.838]                     })
[13:36:33.838]                   }
[13:36:33.838]                   ...future.strategy.old <- future::plan("list")
[13:36:33.838]                   options(future.plan = NULL)
[13:36:33.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.838]                 }
[13:36:33.838]                 ...future.workdir <- getwd()
[13:36:33.838]             }
[13:36:33.838]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.838]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.838]         }
[13:36:33.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.838]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.838]             base::names(...future.oldOptions))
[13:36:33.838]     }
[13:36:33.838]     if (FALSE) {
[13:36:33.838]     }
[13:36:33.838]     else {
[13:36:33.838]         if (TRUE) {
[13:36:33.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.838]                 open = "w")
[13:36:33.838]         }
[13:36:33.838]         else {
[13:36:33.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.838]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.838]         }
[13:36:33.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.838]             base::sink(type = "output", split = FALSE)
[13:36:33.838]             base::close(...future.stdout)
[13:36:33.838]         }, add = TRUE)
[13:36:33.838]     }
[13:36:33.838]     ...future.frame <- base::sys.nframe()
[13:36:33.838]     ...future.conditions <- base::list()
[13:36:33.838]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.838]     if (FALSE) {
[13:36:33.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.838]     }
[13:36:33.838]     ...future.result <- base::tryCatch({
[13:36:33.838]         base::withCallingHandlers({
[13:36:33.838]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.838]             future::FutureResult(value = ...future.value$value, 
[13:36:33.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.838]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.838]                     ...future.globalenv.names))
[13:36:33.838]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.838]         }, condition = base::local({
[13:36:33.838]             c <- base::c
[13:36:33.838]             inherits <- base::inherits
[13:36:33.838]             invokeRestart <- base::invokeRestart
[13:36:33.838]             length <- base::length
[13:36:33.838]             list <- base::list
[13:36:33.838]             seq.int <- base::seq.int
[13:36:33.838]             signalCondition <- base::signalCondition
[13:36:33.838]             sys.calls <- base::sys.calls
[13:36:33.838]             `[[` <- base::`[[`
[13:36:33.838]             `+` <- base::`+`
[13:36:33.838]             `<<-` <- base::`<<-`
[13:36:33.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.838]                   3L)]
[13:36:33.838]             }
[13:36:33.838]             function(cond) {
[13:36:33.838]                 is_error <- inherits(cond, "error")
[13:36:33.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.838]                   NULL)
[13:36:33.838]                 if (is_error) {
[13:36:33.838]                   sessionInformation <- function() {
[13:36:33.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.838]                       search = base::search(), system = base::Sys.info())
[13:36:33.838]                   }
[13:36:33.838]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.838]                     cond$call), session = sessionInformation(), 
[13:36:33.838]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.838]                   signalCondition(cond)
[13:36:33.838]                 }
[13:36:33.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.838]                 "immediateCondition"))) {
[13:36:33.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.838]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.838]                   if (TRUE && !signal) {
[13:36:33.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.838]                     {
[13:36:33.838]                       inherits <- base::inherits
[13:36:33.838]                       invokeRestart <- base::invokeRestart
[13:36:33.838]                       is.null <- base::is.null
[13:36:33.838]                       muffled <- FALSE
[13:36:33.838]                       if (inherits(cond, "message")) {
[13:36:33.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.838]                         if (muffled) 
[13:36:33.838]                           invokeRestart("muffleMessage")
[13:36:33.838]                       }
[13:36:33.838]                       else if (inherits(cond, "warning")) {
[13:36:33.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.838]                         if (muffled) 
[13:36:33.838]                           invokeRestart("muffleWarning")
[13:36:33.838]                       }
[13:36:33.838]                       else if (inherits(cond, "condition")) {
[13:36:33.838]                         if (!is.null(pattern)) {
[13:36:33.838]                           computeRestarts <- base::computeRestarts
[13:36:33.838]                           grepl <- base::grepl
[13:36:33.838]                           restarts <- computeRestarts(cond)
[13:36:33.838]                           for (restart in restarts) {
[13:36:33.838]                             name <- restart$name
[13:36:33.838]                             if (is.null(name)) 
[13:36:33.838]                               next
[13:36:33.838]                             if (!grepl(pattern, name)) 
[13:36:33.838]                               next
[13:36:33.838]                             invokeRestart(restart)
[13:36:33.838]                             muffled <- TRUE
[13:36:33.838]                             break
[13:36:33.838]                           }
[13:36:33.838]                         }
[13:36:33.838]                       }
[13:36:33.838]                       invisible(muffled)
[13:36:33.838]                     }
[13:36:33.838]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.838]                   }
[13:36:33.838]                 }
[13:36:33.838]                 else {
[13:36:33.838]                   if (TRUE) {
[13:36:33.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.838]                     {
[13:36:33.838]                       inherits <- base::inherits
[13:36:33.838]                       invokeRestart <- base::invokeRestart
[13:36:33.838]                       is.null <- base::is.null
[13:36:33.838]                       muffled <- FALSE
[13:36:33.838]                       if (inherits(cond, "message")) {
[13:36:33.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.838]                         if (muffled) 
[13:36:33.838]                           invokeRestart("muffleMessage")
[13:36:33.838]                       }
[13:36:33.838]                       else if (inherits(cond, "warning")) {
[13:36:33.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.838]                         if (muffled) 
[13:36:33.838]                           invokeRestart("muffleWarning")
[13:36:33.838]                       }
[13:36:33.838]                       else if (inherits(cond, "condition")) {
[13:36:33.838]                         if (!is.null(pattern)) {
[13:36:33.838]                           computeRestarts <- base::computeRestarts
[13:36:33.838]                           grepl <- base::grepl
[13:36:33.838]                           restarts <- computeRestarts(cond)
[13:36:33.838]                           for (restart in restarts) {
[13:36:33.838]                             name <- restart$name
[13:36:33.838]                             if (is.null(name)) 
[13:36:33.838]                               next
[13:36:33.838]                             if (!grepl(pattern, name)) 
[13:36:33.838]                               next
[13:36:33.838]                             invokeRestart(restart)
[13:36:33.838]                             muffled <- TRUE
[13:36:33.838]                             break
[13:36:33.838]                           }
[13:36:33.838]                         }
[13:36:33.838]                       }
[13:36:33.838]                       invisible(muffled)
[13:36:33.838]                     }
[13:36:33.838]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.838]                   }
[13:36:33.838]                 }
[13:36:33.838]             }
[13:36:33.838]         }))
[13:36:33.838]     }, error = function(ex) {
[13:36:33.838]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.838]                 ...future.rng), started = ...future.startTime, 
[13:36:33.838]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.838]             version = "1.8"), class = "FutureResult")
[13:36:33.838]     }, finally = {
[13:36:33.838]         if (!identical(...future.workdir, getwd())) 
[13:36:33.838]             setwd(...future.workdir)
[13:36:33.838]         {
[13:36:33.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.838]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.838]             }
[13:36:33.838]             base::options(...future.oldOptions)
[13:36:33.838]             if (.Platform$OS.type == "windows") {
[13:36:33.838]                 old_names <- names(...future.oldEnvVars)
[13:36:33.838]                 envs <- base::Sys.getenv()
[13:36:33.838]                 names <- names(envs)
[13:36:33.838]                 common <- intersect(names, old_names)
[13:36:33.838]                 added <- setdiff(names, old_names)
[13:36:33.838]                 removed <- setdiff(old_names, names)
[13:36:33.838]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.838]                   envs[common]]
[13:36:33.838]                 NAMES <- toupper(changed)
[13:36:33.838]                 args <- list()
[13:36:33.838]                 for (kk in seq_along(NAMES)) {
[13:36:33.838]                   name <- changed[[kk]]
[13:36:33.838]                   NAME <- NAMES[[kk]]
[13:36:33.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.838]                     next
[13:36:33.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.838]                 }
[13:36:33.838]                 NAMES <- toupper(added)
[13:36:33.838]                 for (kk in seq_along(NAMES)) {
[13:36:33.838]                   name <- added[[kk]]
[13:36:33.838]                   NAME <- NAMES[[kk]]
[13:36:33.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.838]                     next
[13:36:33.838]                   args[[name]] <- ""
[13:36:33.838]                 }
[13:36:33.838]                 NAMES <- toupper(removed)
[13:36:33.838]                 for (kk in seq_along(NAMES)) {
[13:36:33.838]                   name <- removed[[kk]]
[13:36:33.838]                   NAME <- NAMES[[kk]]
[13:36:33.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.838]                     next
[13:36:33.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.838]                 }
[13:36:33.838]                 if (length(args) > 0) 
[13:36:33.838]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.838]             }
[13:36:33.838]             else {
[13:36:33.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.838]             }
[13:36:33.838]             {
[13:36:33.838]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.838]                   0L) {
[13:36:33.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.838]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.838]                   base::options(opts)
[13:36:33.838]                 }
[13:36:33.838]                 {
[13:36:33.838]                   {
[13:36:33.838]                     NULL
[13:36:33.838]                     RNGkind("Mersenne-Twister")
[13:36:33.838]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.838]                       inherits = FALSE)
[13:36:33.838]                   }
[13:36:33.838]                   options(future.plan = NULL)
[13:36:33.838]                   if (is.na(NA_character_)) 
[13:36:33.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.838]                     .init = FALSE)
[13:36:33.838]                 }
[13:36:33.838]             }
[13:36:33.838]         }
[13:36:33.838]     })
[13:36:33.838]     if (TRUE) {
[13:36:33.838]         base::sink(type = "output", split = FALSE)
[13:36:33.838]         if (TRUE) {
[13:36:33.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.838]         }
[13:36:33.838]         else {
[13:36:33.838]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.838]         }
[13:36:33.838]         base::close(...future.stdout)
[13:36:33.838]         ...future.stdout <- NULL
[13:36:33.838]     }
[13:36:33.838]     ...future.result$conditions <- ...future.conditions
[13:36:33.838]     ...future.result$finished <- base::Sys.time()
[13:36:33.838]     ...future.result
[13:36:33.838] }
[13:36:33.839] plan(): Setting new future strategy stack:
[13:36:33.839] List of future strategies:
[13:36:33.839] 1. sequential:
[13:36:33.839]    - args: function (..., envir = parent.frame())
[13:36:33.839]    - tweaked: FALSE
[13:36:33.839]    - call: NULL
[13:36:33.840] plan(): nbrOfWorkers() = 1
[13:36:33.840] plan(): Setting new future strategy stack:
[13:36:33.841] List of future strategies:
[13:36:33.841] 1. sequential:
[13:36:33.841]    - args: function (..., envir = parent.frame())
[13:36:33.841]    - tweaked: FALSE
[13:36:33.841]    - call: plan(strategy)
[13:36:33.841] plan(): nbrOfWorkers() = 1
[13:36:33.841] SequentialFuture started (and completed)
[13:36:33.841] - Launch lazy future ... done
[13:36:33.841] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a73466b08> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a7267ef90> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a73466b08> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a7267ef90> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:36:33.846] resolved() for ‘SequentialFuture’ ...
[13:36:33.846] - state: ‘finished’
[13:36:33.846] - run: TRUE
[13:36:33.846] - result: ‘FutureResult’
[13:36:33.846] resolved() for ‘SequentialFuture’ ... done
[13:36:33.846] resolved() for ‘SequentialFuture’ ...
[13:36:33.846] - state: ‘finished’
[13:36:33.847] - run: TRUE
[13:36:33.847] - result: ‘FutureResult’
[13:36:33.847] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:33.848] resolve() on list ...
[13:36:33.848]  recursive: 0
[13:36:33.848]  length: 6
[13:36:33.848]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:33.849] signalConditionsASAP(numeric, pos=1) ...
[13:36:33.849] - nx: 6
[13:36:33.849] - relay: TRUE
[13:36:33.849] - stdout: TRUE
[13:36:33.849] - signal: TRUE
[13:36:33.849] - resignal: FALSE
[13:36:33.849] - force: TRUE
[13:36:33.849] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.849] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.849]  - until=2
[13:36:33.849]  - relaying element #2
[13:36:33.849] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.850] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.850] signalConditionsASAP(NULL, pos=1) ... done
[13:36:33.850]  length: 5 (resolved future 1)
[13:36:33.850] resolved() for ‘SequentialFuture’ ...
[13:36:33.850] - state: ‘finished’
[13:36:33.850] - run: TRUE
[13:36:33.850] - result: ‘FutureResult’
[13:36:33.850] resolved() for ‘SequentialFuture’ ... done
[13:36:33.850] Future #2
[13:36:33.850] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:33.851] - nx: 6
[13:36:33.851] - relay: TRUE
[13:36:33.851] - stdout: TRUE
[13:36:33.851] - signal: TRUE
[13:36:33.851] - resignal: FALSE
[13:36:33.851] - force: TRUE
[13:36:33.851] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.851] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.851]  - until=2
[13:36:33.851]  - relaying element #2
[13:36:33.851] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.852] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.852] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:33.852]  length: 4 (resolved future 2)
[13:36:33.852] resolved() for ‘SequentialFuture’ ...
[13:36:33.852] - state: ‘finished’
[13:36:33.852] - run: TRUE
[13:36:33.852] - result: ‘FutureResult’
[13:36:33.852] resolved() for ‘SequentialFuture’ ... done
[13:36:33.852] Future #3
[13:36:33.852] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:33.853] - nx: 6
[13:36:33.853] - relay: TRUE
[13:36:33.853] - stdout: TRUE
[13:36:33.853] - signal: TRUE
[13:36:33.853] - resignal: FALSE
[13:36:33.853] - force: TRUE
[13:36:33.853] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.853] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.853]  - until=3
[13:36:33.853]  - relaying element #3
[13:36:33.853] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.853] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.854] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:33.854]  length: 3 (resolved future 3)
[13:36:33.854] signalConditionsASAP(NULL, pos=4) ...
[13:36:33.854] - nx: 6
[13:36:33.854] - relay: TRUE
[13:36:33.854] - stdout: TRUE
[13:36:33.854] - signal: TRUE
[13:36:33.854] - resignal: FALSE
[13:36:33.854] - force: TRUE
[13:36:33.854] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.854] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.855]  - until=5
[13:36:33.855]  - relaying element #5
[13:36:33.855] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.855] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.855] signalConditionsASAP(NULL, pos=4) ... done
[13:36:33.855]  length: 2 (resolved future 4)
[13:36:33.855] signalConditionsASAP(NULL, pos=5) ...
[13:36:33.855] - nx: 6
[13:36:33.855] - relay: TRUE
[13:36:33.855] - stdout: TRUE
[13:36:33.855] - signal: TRUE
[13:36:33.855] - resignal: FALSE
[13:36:33.856] - force: TRUE
[13:36:33.856] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.856] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.856]  - until=6
[13:36:33.856]  - relaying element #6
[13:36:33.856] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.856] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.856] signalConditionsASAP(NULL, pos=5) ... done
[13:36:33.856]  length: 1 (resolved future 5)
[13:36:33.856] signalConditionsASAP(numeric, pos=6) ...
[13:36:33.856] - nx: 6
[13:36:33.856] - relay: TRUE
[13:36:33.857] - stdout: TRUE
[13:36:33.857] - signal: TRUE
[13:36:33.857] - resignal: FALSE
[13:36:33.857] - force: TRUE
[13:36:33.857] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.857] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.857]  - until=6
[13:36:33.857] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.857] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.857] signalConditionsASAP(numeric, pos=6) ... done
[13:36:33.857]  length: 0 (resolved future 6)
[13:36:33.857] Relaying remaining futures
[13:36:33.857] signalConditionsASAP(NULL, pos=0) ...
[13:36:33.858] - nx: 6
[13:36:33.858] - relay: TRUE
[13:36:33.858] - stdout: TRUE
[13:36:33.858] - signal: TRUE
[13:36:33.858] - resignal: FALSE
[13:36:33.858] - force: TRUE
[13:36:33.858] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.858] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:33.858] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.858] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.858] signalConditionsASAP(NULL, pos=0) ... done
[13:36:33.859] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:36:33.863] getGlobalsAndPackages() ...
[13:36:33.863] Searching for globals...
[13:36:33.863] 
[13:36:33.863] Searching for globals ... DONE
[13:36:33.863] - globals: [0] <none>
[13:36:33.863] getGlobalsAndPackages() ... DONE
[13:36:33.864] run() for ‘Future’ ...
[13:36:33.864] - state: ‘created’
[13:36:33.864] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.864] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.864]   - Field: ‘label’
[13:36:33.864]   - Field: ‘local’
[13:36:33.864]   - Field: ‘owner’
[13:36:33.865]   - Field: ‘envir’
[13:36:33.865]   - Field: ‘packages’
[13:36:33.865]   - Field: ‘gc’
[13:36:33.865]   - Field: ‘conditions’
[13:36:33.865]   - Field: ‘expr’
[13:36:33.865]   - Field: ‘uuid’
[13:36:33.865]   - Field: ‘seed’
[13:36:33.865]   - Field: ‘version’
[13:36:33.865]   - Field: ‘result’
[13:36:33.865]   - Field: ‘asynchronous’
[13:36:33.865]   - Field: ‘calls’
[13:36:33.866]   - Field: ‘globals’
[13:36:33.866]   - Field: ‘stdout’
[13:36:33.866]   - Field: ‘earlySignal’
[13:36:33.866]   - Field: ‘lazy’
[13:36:33.866]   - Field: ‘state’
[13:36:33.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.866] - Launch lazy future ...
[13:36:33.866] Packages needed by the future expression (n = 0): <none>
[13:36:33.866] Packages needed by future strategies (n = 0): <none>
[13:36:33.867] {
[13:36:33.867]     {
[13:36:33.867]         {
[13:36:33.867]             ...future.startTime <- base::Sys.time()
[13:36:33.867]             {
[13:36:33.867]                 {
[13:36:33.867]                   {
[13:36:33.867]                     base::local({
[13:36:33.867]                       has_future <- base::requireNamespace("future", 
[13:36:33.867]                         quietly = TRUE)
[13:36:33.867]                       if (has_future) {
[13:36:33.867]                         ns <- base::getNamespace("future")
[13:36:33.867]                         version <- ns[[".package"]][["version"]]
[13:36:33.867]                         if (is.null(version)) 
[13:36:33.867]                           version <- utils::packageVersion("future")
[13:36:33.867]                       }
[13:36:33.867]                       else {
[13:36:33.867]                         version <- NULL
[13:36:33.867]                       }
[13:36:33.867]                       if (!has_future || version < "1.8.0") {
[13:36:33.867]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.867]                           "", base::R.version$version.string), 
[13:36:33.867]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.867]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.867]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.867]                             "release", "version")], collapse = " "), 
[13:36:33.867]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.867]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.867]                           info)
[13:36:33.867]                         info <- base::paste(info, collapse = "; ")
[13:36:33.867]                         if (!has_future) {
[13:36:33.867]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.867]                             info)
[13:36:33.867]                         }
[13:36:33.867]                         else {
[13:36:33.867]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.867]                             info, version)
[13:36:33.867]                         }
[13:36:33.867]                         base::stop(msg)
[13:36:33.867]                       }
[13:36:33.867]                     })
[13:36:33.867]                   }
[13:36:33.867]                   ...future.strategy.old <- future::plan("list")
[13:36:33.867]                   options(future.plan = NULL)
[13:36:33.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.867]                 }
[13:36:33.867]                 ...future.workdir <- getwd()
[13:36:33.867]             }
[13:36:33.867]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.867]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.867]         }
[13:36:33.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.867]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.867]             base::names(...future.oldOptions))
[13:36:33.867]     }
[13:36:33.867]     if (FALSE) {
[13:36:33.867]     }
[13:36:33.867]     else {
[13:36:33.867]         if (TRUE) {
[13:36:33.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.867]                 open = "w")
[13:36:33.867]         }
[13:36:33.867]         else {
[13:36:33.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.867]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.867]         }
[13:36:33.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.867]             base::sink(type = "output", split = FALSE)
[13:36:33.867]             base::close(...future.stdout)
[13:36:33.867]         }, add = TRUE)
[13:36:33.867]     }
[13:36:33.867]     ...future.frame <- base::sys.nframe()
[13:36:33.867]     ...future.conditions <- base::list()
[13:36:33.867]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.867]     if (FALSE) {
[13:36:33.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.867]     }
[13:36:33.867]     ...future.result <- base::tryCatch({
[13:36:33.867]         base::withCallingHandlers({
[13:36:33.867]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.867]             future::FutureResult(value = ...future.value$value, 
[13:36:33.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.867]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.867]                     ...future.globalenv.names))
[13:36:33.867]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.867]         }, condition = base::local({
[13:36:33.867]             c <- base::c
[13:36:33.867]             inherits <- base::inherits
[13:36:33.867]             invokeRestart <- base::invokeRestart
[13:36:33.867]             length <- base::length
[13:36:33.867]             list <- base::list
[13:36:33.867]             seq.int <- base::seq.int
[13:36:33.867]             signalCondition <- base::signalCondition
[13:36:33.867]             sys.calls <- base::sys.calls
[13:36:33.867]             `[[` <- base::`[[`
[13:36:33.867]             `+` <- base::`+`
[13:36:33.867]             `<<-` <- base::`<<-`
[13:36:33.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.867]                   3L)]
[13:36:33.867]             }
[13:36:33.867]             function(cond) {
[13:36:33.867]                 is_error <- inherits(cond, "error")
[13:36:33.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.867]                   NULL)
[13:36:33.867]                 if (is_error) {
[13:36:33.867]                   sessionInformation <- function() {
[13:36:33.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.867]                       search = base::search(), system = base::Sys.info())
[13:36:33.867]                   }
[13:36:33.867]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.867]                     cond$call), session = sessionInformation(), 
[13:36:33.867]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.867]                   signalCondition(cond)
[13:36:33.867]                 }
[13:36:33.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.867]                 "immediateCondition"))) {
[13:36:33.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.867]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.867]                   if (TRUE && !signal) {
[13:36:33.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.867]                     {
[13:36:33.867]                       inherits <- base::inherits
[13:36:33.867]                       invokeRestart <- base::invokeRestart
[13:36:33.867]                       is.null <- base::is.null
[13:36:33.867]                       muffled <- FALSE
[13:36:33.867]                       if (inherits(cond, "message")) {
[13:36:33.867]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.867]                         if (muffled) 
[13:36:33.867]                           invokeRestart("muffleMessage")
[13:36:33.867]                       }
[13:36:33.867]                       else if (inherits(cond, "warning")) {
[13:36:33.867]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.867]                         if (muffled) 
[13:36:33.867]                           invokeRestart("muffleWarning")
[13:36:33.867]                       }
[13:36:33.867]                       else if (inherits(cond, "condition")) {
[13:36:33.867]                         if (!is.null(pattern)) {
[13:36:33.867]                           computeRestarts <- base::computeRestarts
[13:36:33.867]                           grepl <- base::grepl
[13:36:33.867]                           restarts <- computeRestarts(cond)
[13:36:33.867]                           for (restart in restarts) {
[13:36:33.867]                             name <- restart$name
[13:36:33.867]                             if (is.null(name)) 
[13:36:33.867]                               next
[13:36:33.867]                             if (!grepl(pattern, name)) 
[13:36:33.867]                               next
[13:36:33.867]                             invokeRestart(restart)
[13:36:33.867]                             muffled <- TRUE
[13:36:33.867]                             break
[13:36:33.867]                           }
[13:36:33.867]                         }
[13:36:33.867]                       }
[13:36:33.867]                       invisible(muffled)
[13:36:33.867]                     }
[13:36:33.867]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.867]                   }
[13:36:33.867]                 }
[13:36:33.867]                 else {
[13:36:33.867]                   if (TRUE) {
[13:36:33.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.867]                     {
[13:36:33.867]                       inherits <- base::inherits
[13:36:33.867]                       invokeRestart <- base::invokeRestart
[13:36:33.867]                       is.null <- base::is.null
[13:36:33.867]                       muffled <- FALSE
[13:36:33.867]                       if (inherits(cond, "message")) {
[13:36:33.867]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.867]                         if (muffled) 
[13:36:33.867]                           invokeRestart("muffleMessage")
[13:36:33.867]                       }
[13:36:33.867]                       else if (inherits(cond, "warning")) {
[13:36:33.867]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.867]                         if (muffled) 
[13:36:33.867]                           invokeRestart("muffleWarning")
[13:36:33.867]                       }
[13:36:33.867]                       else if (inherits(cond, "condition")) {
[13:36:33.867]                         if (!is.null(pattern)) {
[13:36:33.867]                           computeRestarts <- base::computeRestarts
[13:36:33.867]                           grepl <- base::grepl
[13:36:33.867]                           restarts <- computeRestarts(cond)
[13:36:33.867]                           for (restart in restarts) {
[13:36:33.867]                             name <- restart$name
[13:36:33.867]                             if (is.null(name)) 
[13:36:33.867]                               next
[13:36:33.867]                             if (!grepl(pattern, name)) 
[13:36:33.867]                               next
[13:36:33.867]                             invokeRestart(restart)
[13:36:33.867]                             muffled <- TRUE
[13:36:33.867]                             break
[13:36:33.867]                           }
[13:36:33.867]                         }
[13:36:33.867]                       }
[13:36:33.867]                       invisible(muffled)
[13:36:33.867]                     }
[13:36:33.867]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.867]                   }
[13:36:33.867]                 }
[13:36:33.867]             }
[13:36:33.867]         }))
[13:36:33.867]     }, error = function(ex) {
[13:36:33.867]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.867]                 ...future.rng), started = ...future.startTime, 
[13:36:33.867]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.867]             version = "1.8"), class = "FutureResult")
[13:36:33.867]     }, finally = {
[13:36:33.867]         if (!identical(...future.workdir, getwd())) 
[13:36:33.867]             setwd(...future.workdir)
[13:36:33.867]         {
[13:36:33.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.867]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.867]             }
[13:36:33.867]             base::options(...future.oldOptions)
[13:36:33.867]             if (.Platform$OS.type == "windows") {
[13:36:33.867]                 old_names <- names(...future.oldEnvVars)
[13:36:33.867]                 envs <- base::Sys.getenv()
[13:36:33.867]                 names <- names(envs)
[13:36:33.867]                 common <- intersect(names, old_names)
[13:36:33.867]                 added <- setdiff(names, old_names)
[13:36:33.867]                 removed <- setdiff(old_names, names)
[13:36:33.867]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.867]                   envs[common]]
[13:36:33.867]                 NAMES <- toupper(changed)
[13:36:33.867]                 args <- list()
[13:36:33.867]                 for (kk in seq_along(NAMES)) {
[13:36:33.867]                   name <- changed[[kk]]
[13:36:33.867]                   NAME <- NAMES[[kk]]
[13:36:33.867]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.867]                     next
[13:36:33.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.867]                 }
[13:36:33.867]                 NAMES <- toupper(added)
[13:36:33.867]                 for (kk in seq_along(NAMES)) {
[13:36:33.867]                   name <- added[[kk]]
[13:36:33.867]                   NAME <- NAMES[[kk]]
[13:36:33.867]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.867]                     next
[13:36:33.867]                   args[[name]] <- ""
[13:36:33.867]                 }
[13:36:33.867]                 NAMES <- toupper(removed)
[13:36:33.867]                 for (kk in seq_along(NAMES)) {
[13:36:33.867]                   name <- removed[[kk]]
[13:36:33.867]                   NAME <- NAMES[[kk]]
[13:36:33.867]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.867]                     next
[13:36:33.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.867]                 }
[13:36:33.867]                 if (length(args) > 0) 
[13:36:33.867]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.867]             }
[13:36:33.867]             else {
[13:36:33.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.867]             }
[13:36:33.867]             {
[13:36:33.867]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.867]                   0L) {
[13:36:33.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.867]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.867]                   base::options(opts)
[13:36:33.867]                 }
[13:36:33.867]                 {
[13:36:33.867]                   {
[13:36:33.867]                     NULL
[13:36:33.867]                     RNGkind("Mersenne-Twister")
[13:36:33.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.867]                       inherits = FALSE)
[13:36:33.867]                   }
[13:36:33.867]                   options(future.plan = NULL)
[13:36:33.867]                   if (is.na(NA_character_)) 
[13:36:33.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.867]                     .init = FALSE)
[13:36:33.867]                 }
[13:36:33.867]             }
[13:36:33.867]         }
[13:36:33.867]     })
[13:36:33.867]     if (TRUE) {
[13:36:33.867]         base::sink(type = "output", split = FALSE)
[13:36:33.867]         if (TRUE) {
[13:36:33.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.867]         }
[13:36:33.867]         else {
[13:36:33.867]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.867]         }
[13:36:33.867]         base::close(...future.stdout)
[13:36:33.867]         ...future.stdout <- NULL
[13:36:33.867]     }
[13:36:33.867]     ...future.result$conditions <- ...future.conditions
[13:36:33.867]     ...future.result$finished <- base::Sys.time()
[13:36:33.867]     ...future.result
[13:36:33.867] }
[13:36:33.868] plan(): Setting new future strategy stack:
[13:36:33.869] List of future strategies:
[13:36:33.869] 1. sequential:
[13:36:33.869]    - args: function (..., envir = parent.frame())
[13:36:33.869]    - tweaked: FALSE
[13:36:33.869]    - call: NULL
[13:36:33.869] plan(): nbrOfWorkers() = 1
[13:36:33.870] plan(): Setting new future strategy stack:
[13:36:33.870] List of future strategies:
[13:36:33.870] 1. sequential:
[13:36:33.870]    - args: function (..., envir = parent.frame())
[13:36:33.870]    - tweaked: FALSE
[13:36:33.870]    - call: plan(strategy)
[13:36:33.870] plan(): nbrOfWorkers() = 1
[13:36:33.870] SequentialFuture started (and completed)
[13:36:33.870] - Launch lazy future ... done
[13:36:33.870] run() for ‘SequentialFuture’ ... done
[13:36:33.870] getGlobalsAndPackages() ...
[13:36:33.871] Searching for globals...
[13:36:33.871] 
[13:36:33.871] Searching for globals ... DONE
[13:36:33.871] - globals: [0] <none>
[13:36:33.871] getGlobalsAndPackages() ... DONE
[13:36:33.871] run() for ‘Future’ ...
[13:36:33.871] - state: ‘created’
[13:36:33.872] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.872] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.872]   - Field: ‘label’
[13:36:33.872]   - Field: ‘local’
[13:36:33.872]   - Field: ‘owner’
[13:36:33.872]   - Field: ‘envir’
[13:36:33.872]   - Field: ‘packages’
[13:36:33.872]   - Field: ‘gc’
[13:36:33.873]   - Field: ‘conditions’
[13:36:33.873]   - Field: ‘expr’
[13:36:33.873]   - Field: ‘uuid’
[13:36:33.873]   - Field: ‘seed’
[13:36:33.873]   - Field: ‘version’
[13:36:33.873]   - Field: ‘result’
[13:36:33.873]   - Field: ‘asynchronous’
[13:36:33.873]   - Field: ‘calls’
[13:36:33.873]   - Field: ‘globals’
[13:36:33.873]   - Field: ‘stdout’
[13:36:33.873]   - Field: ‘earlySignal’
[13:36:33.873]   - Field: ‘lazy’
[13:36:33.874]   - Field: ‘state’
[13:36:33.874] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.874] - Launch lazy future ...
[13:36:33.874] Packages needed by the future expression (n = 0): <none>
[13:36:33.874] Packages needed by future strategies (n = 0): <none>
[13:36:33.874] {
[13:36:33.874]     {
[13:36:33.874]         {
[13:36:33.874]             ...future.startTime <- base::Sys.time()
[13:36:33.874]             {
[13:36:33.874]                 {
[13:36:33.874]                   {
[13:36:33.874]                     base::local({
[13:36:33.874]                       has_future <- base::requireNamespace("future", 
[13:36:33.874]                         quietly = TRUE)
[13:36:33.874]                       if (has_future) {
[13:36:33.874]                         ns <- base::getNamespace("future")
[13:36:33.874]                         version <- ns[[".package"]][["version"]]
[13:36:33.874]                         if (is.null(version)) 
[13:36:33.874]                           version <- utils::packageVersion("future")
[13:36:33.874]                       }
[13:36:33.874]                       else {
[13:36:33.874]                         version <- NULL
[13:36:33.874]                       }
[13:36:33.874]                       if (!has_future || version < "1.8.0") {
[13:36:33.874]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.874]                           "", base::R.version$version.string), 
[13:36:33.874]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.874]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.874]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.874]                             "release", "version")], collapse = " "), 
[13:36:33.874]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.874]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.874]                           info)
[13:36:33.874]                         info <- base::paste(info, collapse = "; ")
[13:36:33.874]                         if (!has_future) {
[13:36:33.874]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.874]                             info)
[13:36:33.874]                         }
[13:36:33.874]                         else {
[13:36:33.874]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.874]                             info, version)
[13:36:33.874]                         }
[13:36:33.874]                         base::stop(msg)
[13:36:33.874]                       }
[13:36:33.874]                     })
[13:36:33.874]                   }
[13:36:33.874]                   ...future.strategy.old <- future::plan("list")
[13:36:33.874]                   options(future.plan = NULL)
[13:36:33.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.874]                 }
[13:36:33.874]                 ...future.workdir <- getwd()
[13:36:33.874]             }
[13:36:33.874]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.874]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.874]         }
[13:36:33.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.874]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.874]             base::names(...future.oldOptions))
[13:36:33.874]     }
[13:36:33.874]     if (FALSE) {
[13:36:33.874]     }
[13:36:33.874]     else {
[13:36:33.874]         if (TRUE) {
[13:36:33.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.874]                 open = "w")
[13:36:33.874]         }
[13:36:33.874]         else {
[13:36:33.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.874]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.874]         }
[13:36:33.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.874]             base::sink(type = "output", split = FALSE)
[13:36:33.874]             base::close(...future.stdout)
[13:36:33.874]         }, add = TRUE)
[13:36:33.874]     }
[13:36:33.874]     ...future.frame <- base::sys.nframe()
[13:36:33.874]     ...future.conditions <- base::list()
[13:36:33.874]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.874]     if (FALSE) {
[13:36:33.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.874]     }
[13:36:33.874]     ...future.result <- base::tryCatch({
[13:36:33.874]         base::withCallingHandlers({
[13:36:33.874]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.874]             future::FutureResult(value = ...future.value$value, 
[13:36:33.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.874]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.874]                     ...future.globalenv.names))
[13:36:33.874]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.874]         }, condition = base::local({
[13:36:33.874]             c <- base::c
[13:36:33.874]             inherits <- base::inherits
[13:36:33.874]             invokeRestart <- base::invokeRestart
[13:36:33.874]             length <- base::length
[13:36:33.874]             list <- base::list
[13:36:33.874]             seq.int <- base::seq.int
[13:36:33.874]             signalCondition <- base::signalCondition
[13:36:33.874]             sys.calls <- base::sys.calls
[13:36:33.874]             `[[` <- base::`[[`
[13:36:33.874]             `+` <- base::`+`
[13:36:33.874]             `<<-` <- base::`<<-`
[13:36:33.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.874]                   3L)]
[13:36:33.874]             }
[13:36:33.874]             function(cond) {
[13:36:33.874]                 is_error <- inherits(cond, "error")
[13:36:33.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.874]                   NULL)
[13:36:33.874]                 if (is_error) {
[13:36:33.874]                   sessionInformation <- function() {
[13:36:33.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.874]                       search = base::search(), system = base::Sys.info())
[13:36:33.874]                   }
[13:36:33.874]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.874]                     cond$call), session = sessionInformation(), 
[13:36:33.874]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.874]                   signalCondition(cond)
[13:36:33.874]                 }
[13:36:33.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.874]                 "immediateCondition"))) {
[13:36:33.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.874]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.874]                   if (TRUE && !signal) {
[13:36:33.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.874]                     {
[13:36:33.874]                       inherits <- base::inherits
[13:36:33.874]                       invokeRestart <- base::invokeRestart
[13:36:33.874]                       is.null <- base::is.null
[13:36:33.874]                       muffled <- FALSE
[13:36:33.874]                       if (inherits(cond, "message")) {
[13:36:33.874]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.874]                         if (muffled) 
[13:36:33.874]                           invokeRestart("muffleMessage")
[13:36:33.874]                       }
[13:36:33.874]                       else if (inherits(cond, "warning")) {
[13:36:33.874]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.874]                         if (muffled) 
[13:36:33.874]                           invokeRestart("muffleWarning")
[13:36:33.874]                       }
[13:36:33.874]                       else if (inherits(cond, "condition")) {
[13:36:33.874]                         if (!is.null(pattern)) {
[13:36:33.874]                           computeRestarts <- base::computeRestarts
[13:36:33.874]                           grepl <- base::grepl
[13:36:33.874]                           restarts <- computeRestarts(cond)
[13:36:33.874]                           for (restart in restarts) {
[13:36:33.874]                             name <- restart$name
[13:36:33.874]                             if (is.null(name)) 
[13:36:33.874]                               next
[13:36:33.874]                             if (!grepl(pattern, name)) 
[13:36:33.874]                               next
[13:36:33.874]                             invokeRestart(restart)
[13:36:33.874]                             muffled <- TRUE
[13:36:33.874]                             break
[13:36:33.874]                           }
[13:36:33.874]                         }
[13:36:33.874]                       }
[13:36:33.874]                       invisible(muffled)
[13:36:33.874]                     }
[13:36:33.874]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.874]                   }
[13:36:33.874]                 }
[13:36:33.874]                 else {
[13:36:33.874]                   if (TRUE) {
[13:36:33.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.874]                     {
[13:36:33.874]                       inherits <- base::inherits
[13:36:33.874]                       invokeRestart <- base::invokeRestart
[13:36:33.874]                       is.null <- base::is.null
[13:36:33.874]                       muffled <- FALSE
[13:36:33.874]                       if (inherits(cond, "message")) {
[13:36:33.874]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.874]                         if (muffled) 
[13:36:33.874]                           invokeRestart("muffleMessage")
[13:36:33.874]                       }
[13:36:33.874]                       else if (inherits(cond, "warning")) {
[13:36:33.874]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.874]                         if (muffled) 
[13:36:33.874]                           invokeRestart("muffleWarning")
[13:36:33.874]                       }
[13:36:33.874]                       else if (inherits(cond, "condition")) {
[13:36:33.874]                         if (!is.null(pattern)) {
[13:36:33.874]                           computeRestarts <- base::computeRestarts
[13:36:33.874]                           grepl <- base::grepl
[13:36:33.874]                           restarts <- computeRestarts(cond)
[13:36:33.874]                           for (restart in restarts) {
[13:36:33.874]                             name <- restart$name
[13:36:33.874]                             if (is.null(name)) 
[13:36:33.874]                               next
[13:36:33.874]                             if (!grepl(pattern, name)) 
[13:36:33.874]                               next
[13:36:33.874]                             invokeRestart(restart)
[13:36:33.874]                             muffled <- TRUE
[13:36:33.874]                             break
[13:36:33.874]                           }
[13:36:33.874]                         }
[13:36:33.874]                       }
[13:36:33.874]                       invisible(muffled)
[13:36:33.874]                     }
[13:36:33.874]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.874]                   }
[13:36:33.874]                 }
[13:36:33.874]             }
[13:36:33.874]         }))
[13:36:33.874]     }, error = function(ex) {
[13:36:33.874]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.874]                 ...future.rng), started = ...future.startTime, 
[13:36:33.874]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.874]             version = "1.8"), class = "FutureResult")
[13:36:33.874]     }, finally = {
[13:36:33.874]         if (!identical(...future.workdir, getwd())) 
[13:36:33.874]             setwd(...future.workdir)
[13:36:33.874]         {
[13:36:33.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.874]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.874]             }
[13:36:33.874]             base::options(...future.oldOptions)
[13:36:33.874]             if (.Platform$OS.type == "windows") {
[13:36:33.874]                 old_names <- names(...future.oldEnvVars)
[13:36:33.874]                 envs <- base::Sys.getenv()
[13:36:33.874]                 names <- names(envs)
[13:36:33.874]                 common <- intersect(names, old_names)
[13:36:33.874]                 added <- setdiff(names, old_names)
[13:36:33.874]                 removed <- setdiff(old_names, names)
[13:36:33.874]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.874]                   envs[common]]
[13:36:33.874]                 NAMES <- toupper(changed)
[13:36:33.874]                 args <- list()
[13:36:33.874]                 for (kk in seq_along(NAMES)) {
[13:36:33.874]                   name <- changed[[kk]]
[13:36:33.874]                   NAME <- NAMES[[kk]]
[13:36:33.874]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.874]                     next
[13:36:33.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.874]                 }
[13:36:33.874]                 NAMES <- toupper(added)
[13:36:33.874]                 for (kk in seq_along(NAMES)) {
[13:36:33.874]                   name <- added[[kk]]
[13:36:33.874]                   NAME <- NAMES[[kk]]
[13:36:33.874]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.874]                     next
[13:36:33.874]                   args[[name]] <- ""
[13:36:33.874]                 }
[13:36:33.874]                 NAMES <- toupper(removed)
[13:36:33.874]                 for (kk in seq_along(NAMES)) {
[13:36:33.874]                   name <- removed[[kk]]
[13:36:33.874]                   NAME <- NAMES[[kk]]
[13:36:33.874]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.874]                     next
[13:36:33.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.874]                 }
[13:36:33.874]                 if (length(args) > 0) 
[13:36:33.874]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.874]             }
[13:36:33.874]             else {
[13:36:33.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.874]             }
[13:36:33.874]             {
[13:36:33.874]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.874]                   0L) {
[13:36:33.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.874]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.874]                   base::options(opts)
[13:36:33.874]                 }
[13:36:33.874]                 {
[13:36:33.874]                   {
[13:36:33.874]                     NULL
[13:36:33.874]                     RNGkind("Mersenne-Twister")
[13:36:33.874]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.874]                       inherits = FALSE)
[13:36:33.874]                   }
[13:36:33.874]                   options(future.plan = NULL)
[13:36:33.874]                   if (is.na(NA_character_)) 
[13:36:33.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.874]                     .init = FALSE)
[13:36:33.874]                 }
[13:36:33.874]             }
[13:36:33.874]         }
[13:36:33.874]     })
[13:36:33.874]     if (TRUE) {
[13:36:33.874]         base::sink(type = "output", split = FALSE)
[13:36:33.874]         if (TRUE) {
[13:36:33.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.874]         }
[13:36:33.874]         else {
[13:36:33.874]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.874]         }
[13:36:33.874]         base::close(...future.stdout)
[13:36:33.874]         ...future.stdout <- NULL
[13:36:33.874]     }
[13:36:33.874]     ...future.result$conditions <- ...future.conditions
[13:36:33.874]     ...future.result$finished <- base::Sys.time()
[13:36:33.874]     ...future.result
[13:36:33.874] }
[13:36:33.876] plan(): Setting new future strategy stack:
[13:36:33.876] List of future strategies:
[13:36:33.876] 1. sequential:
[13:36:33.876]    - args: function (..., envir = parent.frame())
[13:36:33.876]    - tweaked: FALSE
[13:36:33.876]    - call: NULL
[13:36:33.877] plan(): nbrOfWorkers() = 1
[13:36:33.877] plan(): Setting new future strategy stack:
[13:36:33.877] List of future strategies:
[13:36:33.877] 1. sequential:
[13:36:33.877]    - args: function (..., envir = parent.frame())
[13:36:33.877]    - tweaked: FALSE
[13:36:33.877]    - call: plan(strategy)
[13:36:33.878] plan(): nbrOfWorkers() = 1
[13:36:33.878] SequentialFuture started (and completed)
[13:36:33.878] - Launch lazy future ... done
[13:36:33.878] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a712fb9e0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a72dc48b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a712fb9e0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a72dc48b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:33.883] resolved() for ‘SequentialFuture’ ...
[13:36:33.883] - state: ‘finished’
[13:36:33.883] - run: TRUE
[13:36:33.883] - result: ‘FutureResult’
[13:36:33.883] resolved() for ‘SequentialFuture’ ... done
[13:36:33.883] resolved() for ‘SequentialFuture’ ...
[13:36:33.883] - state: ‘finished’
[13:36:33.884] - run: TRUE
[13:36:33.884] - result: ‘FutureResult’
[13:36:33.884] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:33.885] resolve() on list ...
[13:36:33.885]  recursive: 0
[13:36:33.886]  length: 6
[13:36:33.886]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:33.886] signalConditionsASAP(numeric, pos=1) ...
[13:36:33.886] - nx: 6
[13:36:33.886] - relay: TRUE
[13:36:33.886] - stdout: TRUE
[13:36:33.886] - signal: TRUE
[13:36:33.886] - resignal: FALSE
[13:36:33.886] - force: TRUE
[13:36:33.886] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.886] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.887]  - until=2
[13:36:33.887]  - relaying element #2
[13:36:33.887] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.887] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.887] signalConditionsASAP(NULL, pos=1) ... done
[13:36:33.887]  length: 5 (resolved future 1)
[13:36:33.888] resolved() for ‘SequentialFuture’ ...
[13:36:33.888] - state: ‘finished’
[13:36:33.888] - run: TRUE
[13:36:33.888] - result: ‘FutureResult’
[13:36:33.889] resolved() for ‘SequentialFuture’ ... done
[13:36:33.889] Future #2
[13:36:33.889] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:33.889] - nx: 6
[13:36:33.889] - relay: TRUE
[13:36:33.889] - stdout: TRUE
[13:36:33.889] - signal: TRUE
[13:36:33.889] - resignal: FALSE
[13:36:33.889] - force: TRUE
[13:36:33.889] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.889] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.890]  - until=2
[13:36:33.890]  - relaying element #2
[13:36:33.890] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.890] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.890] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:33.890]  length: 4 (resolved future 2)
[13:36:33.890] resolved() for ‘SequentialFuture’ ...
[13:36:33.890] - state: ‘finished’
[13:36:33.890] - run: TRUE
[13:36:33.890] - result: ‘FutureResult’
[13:36:33.891] resolved() for ‘SequentialFuture’ ... done
[13:36:33.891] Future #3
[13:36:33.891] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:33.891] - nx: 6
[13:36:33.891] - relay: TRUE
[13:36:33.891] - stdout: TRUE
[13:36:33.891] - signal: TRUE
[13:36:33.891] - resignal: FALSE
[13:36:33.891] - force: TRUE
[13:36:33.891] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.891] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.891]  - until=3
[13:36:33.892]  - relaying element #3
[13:36:33.892] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.892] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.892] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:33.892]  length: 3 (resolved future 3)
[13:36:33.892] signalConditionsASAP(NULL, pos=4) ...
[13:36:33.892] - nx: 6
[13:36:33.892] - relay: TRUE
[13:36:33.892] - stdout: TRUE
[13:36:33.892] - signal: TRUE
[13:36:33.893] - resignal: FALSE
[13:36:33.893] - force: TRUE
[13:36:33.893] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.893] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.893]  - until=5
[13:36:33.893]  - relaying element #5
[13:36:33.893] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.893] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.893] signalConditionsASAP(NULL, pos=4) ... done
[13:36:33.893]  length: 2 (resolved future 4)
[13:36:33.893] signalConditionsASAP(NULL, pos=5) ...
[13:36:33.893] - nx: 6
[13:36:33.894] - relay: TRUE
[13:36:33.894] - stdout: TRUE
[13:36:33.894] - signal: TRUE
[13:36:33.894] - resignal: FALSE
[13:36:33.894] - force: TRUE
[13:36:33.894] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.894] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.894]  - until=6
[13:36:33.894]  - relaying element #6
[13:36:33.894] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.894] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.894] signalConditionsASAP(NULL, pos=5) ... done
[13:36:33.895]  length: 1 (resolved future 5)
[13:36:33.895] signalConditionsASAP(numeric, pos=6) ...
[13:36:33.895] - nx: 6
[13:36:33.895] - relay: TRUE
[13:36:33.895] - stdout: TRUE
[13:36:33.895] - signal: TRUE
[13:36:33.895] - resignal: FALSE
[13:36:33.895] - force: TRUE
[13:36:33.895] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.895] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.895]  - until=6
[13:36:33.895] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.895] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.896] signalConditionsASAP(numeric, pos=6) ... done
[13:36:33.896]  length: 0 (resolved future 6)
[13:36:33.896] Relaying remaining futures
[13:36:33.896] signalConditionsASAP(NULL, pos=0) ...
[13:36:33.896] - nx: 6
[13:36:33.896] - relay: TRUE
[13:36:33.896] - stdout: TRUE
[13:36:33.896] - signal: TRUE
[13:36:33.896] - resignal: FALSE
[13:36:33.896] - force: TRUE
[13:36:33.896] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.896] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:33.897] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.897] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.897] signalConditionsASAP(NULL, pos=0) ... done
[13:36:33.897] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:36:33.900] getGlobalsAndPackages() ...
[13:36:33.900] Searching for globals...
[13:36:33.901] 
[13:36:33.901] Searching for globals ... DONE
[13:36:33.901] - globals: [0] <none>
[13:36:33.901] getGlobalsAndPackages() ... DONE
[13:36:33.901] run() for ‘Future’ ...
[13:36:33.901] - state: ‘created’
[13:36:33.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.902]   - Field: ‘label’
[13:36:33.902]   - Field: ‘local’
[13:36:33.902]   - Field: ‘owner’
[13:36:33.902]   - Field: ‘envir’
[13:36:33.902]   - Field: ‘packages’
[13:36:33.902]   - Field: ‘gc’
[13:36:33.902]   - Field: ‘conditions’
[13:36:33.902]   - Field: ‘expr’
[13:36:33.902]   - Field: ‘uuid’
[13:36:33.903]   - Field: ‘seed’
[13:36:33.903]   - Field: ‘version’
[13:36:33.903]   - Field: ‘result’
[13:36:33.903]   - Field: ‘asynchronous’
[13:36:33.903]   - Field: ‘calls’
[13:36:33.903]   - Field: ‘globals’
[13:36:33.903]   - Field: ‘stdout’
[13:36:33.903]   - Field: ‘earlySignal’
[13:36:33.903]   - Field: ‘lazy’
[13:36:33.903]   - Field: ‘state’
[13:36:33.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.903] - Launch lazy future ...
[13:36:33.904] Packages needed by the future expression (n = 0): <none>
[13:36:33.904] Packages needed by future strategies (n = 0): <none>
[13:36:33.904] {
[13:36:33.904]     {
[13:36:33.904]         {
[13:36:33.904]             ...future.startTime <- base::Sys.time()
[13:36:33.904]             {
[13:36:33.904]                 {
[13:36:33.904]                   {
[13:36:33.904]                     base::local({
[13:36:33.904]                       has_future <- base::requireNamespace("future", 
[13:36:33.904]                         quietly = TRUE)
[13:36:33.904]                       if (has_future) {
[13:36:33.904]                         ns <- base::getNamespace("future")
[13:36:33.904]                         version <- ns[[".package"]][["version"]]
[13:36:33.904]                         if (is.null(version)) 
[13:36:33.904]                           version <- utils::packageVersion("future")
[13:36:33.904]                       }
[13:36:33.904]                       else {
[13:36:33.904]                         version <- NULL
[13:36:33.904]                       }
[13:36:33.904]                       if (!has_future || version < "1.8.0") {
[13:36:33.904]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.904]                           "", base::R.version$version.string), 
[13:36:33.904]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.904]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.904]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.904]                             "release", "version")], collapse = " "), 
[13:36:33.904]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.904]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.904]                           info)
[13:36:33.904]                         info <- base::paste(info, collapse = "; ")
[13:36:33.904]                         if (!has_future) {
[13:36:33.904]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.904]                             info)
[13:36:33.904]                         }
[13:36:33.904]                         else {
[13:36:33.904]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.904]                             info, version)
[13:36:33.904]                         }
[13:36:33.904]                         base::stop(msg)
[13:36:33.904]                       }
[13:36:33.904]                     })
[13:36:33.904]                   }
[13:36:33.904]                   ...future.strategy.old <- future::plan("list")
[13:36:33.904]                   options(future.plan = NULL)
[13:36:33.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.904]                 }
[13:36:33.904]                 ...future.workdir <- getwd()
[13:36:33.904]             }
[13:36:33.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.904]         }
[13:36:33.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.904]             base::names(...future.oldOptions))
[13:36:33.904]     }
[13:36:33.904]     if (FALSE) {
[13:36:33.904]     }
[13:36:33.904]     else {
[13:36:33.904]         if (TRUE) {
[13:36:33.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.904]                 open = "w")
[13:36:33.904]         }
[13:36:33.904]         else {
[13:36:33.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.904]         }
[13:36:33.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.904]             base::sink(type = "output", split = FALSE)
[13:36:33.904]             base::close(...future.stdout)
[13:36:33.904]         }, add = TRUE)
[13:36:33.904]     }
[13:36:33.904]     ...future.frame <- base::sys.nframe()
[13:36:33.904]     ...future.conditions <- base::list()
[13:36:33.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.904]     if (FALSE) {
[13:36:33.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.904]     }
[13:36:33.904]     ...future.result <- base::tryCatch({
[13:36:33.904]         base::withCallingHandlers({
[13:36:33.904]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.904]             future::FutureResult(value = ...future.value$value, 
[13:36:33.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.904]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.904]                     ...future.globalenv.names))
[13:36:33.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.904]         }, condition = base::local({
[13:36:33.904]             c <- base::c
[13:36:33.904]             inherits <- base::inherits
[13:36:33.904]             invokeRestart <- base::invokeRestart
[13:36:33.904]             length <- base::length
[13:36:33.904]             list <- base::list
[13:36:33.904]             seq.int <- base::seq.int
[13:36:33.904]             signalCondition <- base::signalCondition
[13:36:33.904]             sys.calls <- base::sys.calls
[13:36:33.904]             `[[` <- base::`[[`
[13:36:33.904]             `+` <- base::`+`
[13:36:33.904]             `<<-` <- base::`<<-`
[13:36:33.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.904]                   3L)]
[13:36:33.904]             }
[13:36:33.904]             function(cond) {
[13:36:33.904]                 is_error <- inherits(cond, "error")
[13:36:33.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.904]                   NULL)
[13:36:33.904]                 if (is_error) {
[13:36:33.904]                   sessionInformation <- function() {
[13:36:33.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.904]                       search = base::search(), system = base::Sys.info())
[13:36:33.904]                   }
[13:36:33.904]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.904]                     cond$call), session = sessionInformation(), 
[13:36:33.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.904]                   signalCondition(cond)
[13:36:33.904]                 }
[13:36:33.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.904]                 "immediateCondition"))) {
[13:36:33.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.904]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.904]                   if (TRUE && !signal) {
[13:36:33.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.904]                     {
[13:36:33.904]                       inherits <- base::inherits
[13:36:33.904]                       invokeRestart <- base::invokeRestart
[13:36:33.904]                       is.null <- base::is.null
[13:36:33.904]                       muffled <- FALSE
[13:36:33.904]                       if (inherits(cond, "message")) {
[13:36:33.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.904]                         if (muffled) 
[13:36:33.904]                           invokeRestart("muffleMessage")
[13:36:33.904]                       }
[13:36:33.904]                       else if (inherits(cond, "warning")) {
[13:36:33.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.904]                         if (muffled) 
[13:36:33.904]                           invokeRestart("muffleWarning")
[13:36:33.904]                       }
[13:36:33.904]                       else if (inherits(cond, "condition")) {
[13:36:33.904]                         if (!is.null(pattern)) {
[13:36:33.904]                           computeRestarts <- base::computeRestarts
[13:36:33.904]                           grepl <- base::grepl
[13:36:33.904]                           restarts <- computeRestarts(cond)
[13:36:33.904]                           for (restart in restarts) {
[13:36:33.904]                             name <- restart$name
[13:36:33.904]                             if (is.null(name)) 
[13:36:33.904]                               next
[13:36:33.904]                             if (!grepl(pattern, name)) 
[13:36:33.904]                               next
[13:36:33.904]                             invokeRestart(restart)
[13:36:33.904]                             muffled <- TRUE
[13:36:33.904]                             break
[13:36:33.904]                           }
[13:36:33.904]                         }
[13:36:33.904]                       }
[13:36:33.904]                       invisible(muffled)
[13:36:33.904]                     }
[13:36:33.904]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.904]                   }
[13:36:33.904]                 }
[13:36:33.904]                 else {
[13:36:33.904]                   if (TRUE) {
[13:36:33.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.904]                     {
[13:36:33.904]                       inherits <- base::inherits
[13:36:33.904]                       invokeRestart <- base::invokeRestart
[13:36:33.904]                       is.null <- base::is.null
[13:36:33.904]                       muffled <- FALSE
[13:36:33.904]                       if (inherits(cond, "message")) {
[13:36:33.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.904]                         if (muffled) 
[13:36:33.904]                           invokeRestart("muffleMessage")
[13:36:33.904]                       }
[13:36:33.904]                       else if (inherits(cond, "warning")) {
[13:36:33.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.904]                         if (muffled) 
[13:36:33.904]                           invokeRestart("muffleWarning")
[13:36:33.904]                       }
[13:36:33.904]                       else if (inherits(cond, "condition")) {
[13:36:33.904]                         if (!is.null(pattern)) {
[13:36:33.904]                           computeRestarts <- base::computeRestarts
[13:36:33.904]                           grepl <- base::grepl
[13:36:33.904]                           restarts <- computeRestarts(cond)
[13:36:33.904]                           for (restart in restarts) {
[13:36:33.904]                             name <- restart$name
[13:36:33.904]                             if (is.null(name)) 
[13:36:33.904]                               next
[13:36:33.904]                             if (!grepl(pattern, name)) 
[13:36:33.904]                               next
[13:36:33.904]                             invokeRestart(restart)
[13:36:33.904]                             muffled <- TRUE
[13:36:33.904]                             break
[13:36:33.904]                           }
[13:36:33.904]                         }
[13:36:33.904]                       }
[13:36:33.904]                       invisible(muffled)
[13:36:33.904]                     }
[13:36:33.904]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.904]                   }
[13:36:33.904]                 }
[13:36:33.904]             }
[13:36:33.904]         }))
[13:36:33.904]     }, error = function(ex) {
[13:36:33.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.904]                 ...future.rng), started = ...future.startTime, 
[13:36:33.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.904]             version = "1.8"), class = "FutureResult")
[13:36:33.904]     }, finally = {
[13:36:33.904]         if (!identical(...future.workdir, getwd())) 
[13:36:33.904]             setwd(...future.workdir)
[13:36:33.904]         {
[13:36:33.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.904]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.904]             }
[13:36:33.904]             base::options(...future.oldOptions)
[13:36:33.904]             if (.Platform$OS.type == "windows") {
[13:36:33.904]                 old_names <- names(...future.oldEnvVars)
[13:36:33.904]                 envs <- base::Sys.getenv()
[13:36:33.904]                 names <- names(envs)
[13:36:33.904]                 common <- intersect(names, old_names)
[13:36:33.904]                 added <- setdiff(names, old_names)
[13:36:33.904]                 removed <- setdiff(old_names, names)
[13:36:33.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.904]                   envs[common]]
[13:36:33.904]                 NAMES <- toupper(changed)
[13:36:33.904]                 args <- list()
[13:36:33.904]                 for (kk in seq_along(NAMES)) {
[13:36:33.904]                   name <- changed[[kk]]
[13:36:33.904]                   NAME <- NAMES[[kk]]
[13:36:33.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.904]                     next
[13:36:33.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.904]                 }
[13:36:33.904]                 NAMES <- toupper(added)
[13:36:33.904]                 for (kk in seq_along(NAMES)) {
[13:36:33.904]                   name <- added[[kk]]
[13:36:33.904]                   NAME <- NAMES[[kk]]
[13:36:33.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.904]                     next
[13:36:33.904]                   args[[name]] <- ""
[13:36:33.904]                 }
[13:36:33.904]                 NAMES <- toupper(removed)
[13:36:33.904]                 for (kk in seq_along(NAMES)) {
[13:36:33.904]                   name <- removed[[kk]]
[13:36:33.904]                   NAME <- NAMES[[kk]]
[13:36:33.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.904]                     next
[13:36:33.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.904]                 }
[13:36:33.904]                 if (length(args) > 0) 
[13:36:33.904]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.904]             }
[13:36:33.904]             else {
[13:36:33.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.904]             }
[13:36:33.904]             {
[13:36:33.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.904]                   0L) {
[13:36:33.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.904]                   base::options(opts)
[13:36:33.904]                 }
[13:36:33.904]                 {
[13:36:33.904]                   {
[13:36:33.904]                     NULL
[13:36:33.904]                     RNGkind("Mersenne-Twister")
[13:36:33.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.904]                       inherits = FALSE)
[13:36:33.904]                   }
[13:36:33.904]                   options(future.plan = NULL)
[13:36:33.904]                   if (is.na(NA_character_)) 
[13:36:33.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.904]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.904]                     .init = FALSE)
[13:36:33.904]                 }
[13:36:33.904]             }
[13:36:33.904]         }
[13:36:33.904]     })
[13:36:33.904]     if (TRUE) {
[13:36:33.904]         base::sink(type = "output", split = FALSE)
[13:36:33.904]         if (TRUE) {
[13:36:33.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.904]         }
[13:36:33.904]         else {
[13:36:33.904]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.904]         }
[13:36:33.904]         base::close(...future.stdout)
[13:36:33.904]         ...future.stdout <- NULL
[13:36:33.904]     }
[13:36:33.904]     ...future.result$conditions <- ...future.conditions
[13:36:33.904]     ...future.result$finished <- base::Sys.time()
[13:36:33.904]     ...future.result
[13:36:33.904] }
[13:36:33.906] plan(): Setting new future strategy stack:
[13:36:33.906] List of future strategies:
[13:36:33.906] 1. sequential:
[13:36:33.906]    - args: function (..., envir = parent.frame())
[13:36:33.906]    - tweaked: FALSE
[13:36:33.906]    - call: NULL
[13:36:33.906] plan(): nbrOfWorkers() = 1
[13:36:33.907] plan(): Setting new future strategy stack:
[13:36:33.907] List of future strategies:
[13:36:33.907] 1. sequential:
[13:36:33.907]    - args: function (..., envir = parent.frame())
[13:36:33.907]    - tweaked: FALSE
[13:36:33.907]    - call: plan(strategy)
[13:36:33.907] plan(): nbrOfWorkers() = 1
[13:36:33.908] SequentialFuture started (and completed)
[13:36:33.908] - Launch lazy future ... done
[13:36:33.908] run() for ‘SequentialFuture’ ... done
[13:36:33.908] getGlobalsAndPackages() ...
[13:36:33.908] Searching for globals...
[13:36:33.908] 
[13:36:33.908] Searching for globals ... DONE
[13:36:33.908] - globals: [0] <none>
[13:36:33.909] getGlobalsAndPackages() ... DONE
[13:36:33.909] run() for ‘Future’ ...
[13:36:33.909] - state: ‘created’
[13:36:33.909] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.909] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.909]   - Field: ‘label’
[13:36:33.910]   - Field: ‘local’
[13:36:33.910]   - Field: ‘owner’
[13:36:33.910]   - Field: ‘envir’
[13:36:33.910]   - Field: ‘packages’
[13:36:33.910]   - Field: ‘gc’
[13:36:33.910]   - Field: ‘conditions’
[13:36:33.910]   - Field: ‘expr’
[13:36:33.910]   - Field: ‘uuid’
[13:36:33.910]   - Field: ‘seed’
[13:36:33.910]   - Field: ‘version’
[13:36:33.910]   - Field: ‘result’
[13:36:33.911]   - Field: ‘asynchronous’
[13:36:33.911]   - Field: ‘calls’
[13:36:33.911]   - Field: ‘globals’
[13:36:33.911]   - Field: ‘stdout’
[13:36:33.911]   - Field: ‘earlySignal’
[13:36:33.911]   - Field: ‘lazy’
[13:36:33.911]   - Field: ‘state’
[13:36:33.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.911] - Launch lazy future ...
[13:36:33.911] Packages needed by the future expression (n = 0): <none>
[13:36:33.911] Packages needed by future strategies (n = 0): <none>
[13:36:33.912] {
[13:36:33.912]     {
[13:36:33.912]         {
[13:36:33.912]             ...future.startTime <- base::Sys.time()
[13:36:33.912]             {
[13:36:33.912]                 {
[13:36:33.912]                   {
[13:36:33.912]                     base::local({
[13:36:33.912]                       has_future <- base::requireNamespace("future", 
[13:36:33.912]                         quietly = TRUE)
[13:36:33.912]                       if (has_future) {
[13:36:33.912]                         ns <- base::getNamespace("future")
[13:36:33.912]                         version <- ns[[".package"]][["version"]]
[13:36:33.912]                         if (is.null(version)) 
[13:36:33.912]                           version <- utils::packageVersion("future")
[13:36:33.912]                       }
[13:36:33.912]                       else {
[13:36:33.912]                         version <- NULL
[13:36:33.912]                       }
[13:36:33.912]                       if (!has_future || version < "1.8.0") {
[13:36:33.912]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.912]                           "", base::R.version$version.string), 
[13:36:33.912]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.912]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.912]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.912]                             "release", "version")], collapse = " "), 
[13:36:33.912]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.912]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.912]                           info)
[13:36:33.912]                         info <- base::paste(info, collapse = "; ")
[13:36:33.912]                         if (!has_future) {
[13:36:33.912]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.912]                             info)
[13:36:33.912]                         }
[13:36:33.912]                         else {
[13:36:33.912]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.912]                             info, version)
[13:36:33.912]                         }
[13:36:33.912]                         base::stop(msg)
[13:36:33.912]                       }
[13:36:33.912]                     })
[13:36:33.912]                   }
[13:36:33.912]                   ...future.strategy.old <- future::plan("list")
[13:36:33.912]                   options(future.plan = NULL)
[13:36:33.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.912]                 }
[13:36:33.912]                 ...future.workdir <- getwd()
[13:36:33.912]             }
[13:36:33.912]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.912]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.912]         }
[13:36:33.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.912]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.912]             base::names(...future.oldOptions))
[13:36:33.912]     }
[13:36:33.912]     if (FALSE) {
[13:36:33.912]     }
[13:36:33.912]     else {
[13:36:33.912]         if (TRUE) {
[13:36:33.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.912]                 open = "w")
[13:36:33.912]         }
[13:36:33.912]         else {
[13:36:33.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.912]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.912]         }
[13:36:33.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.912]             base::sink(type = "output", split = FALSE)
[13:36:33.912]             base::close(...future.stdout)
[13:36:33.912]         }, add = TRUE)
[13:36:33.912]     }
[13:36:33.912]     ...future.frame <- base::sys.nframe()
[13:36:33.912]     ...future.conditions <- base::list()
[13:36:33.912]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.912]     if (FALSE) {
[13:36:33.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.912]     }
[13:36:33.912]     ...future.result <- base::tryCatch({
[13:36:33.912]         base::withCallingHandlers({
[13:36:33.912]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.912]             future::FutureResult(value = ...future.value$value, 
[13:36:33.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.912]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.912]                     ...future.globalenv.names))
[13:36:33.912]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.912]         }, condition = base::local({
[13:36:33.912]             c <- base::c
[13:36:33.912]             inherits <- base::inherits
[13:36:33.912]             invokeRestart <- base::invokeRestart
[13:36:33.912]             length <- base::length
[13:36:33.912]             list <- base::list
[13:36:33.912]             seq.int <- base::seq.int
[13:36:33.912]             signalCondition <- base::signalCondition
[13:36:33.912]             sys.calls <- base::sys.calls
[13:36:33.912]             `[[` <- base::`[[`
[13:36:33.912]             `+` <- base::`+`
[13:36:33.912]             `<<-` <- base::`<<-`
[13:36:33.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.912]                   3L)]
[13:36:33.912]             }
[13:36:33.912]             function(cond) {
[13:36:33.912]                 is_error <- inherits(cond, "error")
[13:36:33.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.912]                   NULL)
[13:36:33.912]                 if (is_error) {
[13:36:33.912]                   sessionInformation <- function() {
[13:36:33.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.912]                       search = base::search(), system = base::Sys.info())
[13:36:33.912]                   }
[13:36:33.912]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.912]                     cond$call), session = sessionInformation(), 
[13:36:33.912]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.912]                   signalCondition(cond)
[13:36:33.912]                 }
[13:36:33.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.912]                 "immediateCondition"))) {
[13:36:33.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.912]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.912]                   if (TRUE && !signal) {
[13:36:33.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.912]                     {
[13:36:33.912]                       inherits <- base::inherits
[13:36:33.912]                       invokeRestart <- base::invokeRestart
[13:36:33.912]                       is.null <- base::is.null
[13:36:33.912]                       muffled <- FALSE
[13:36:33.912]                       if (inherits(cond, "message")) {
[13:36:33.912]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.912]                         if (muffled) 
[13:36:33.912]                           invokeRestart("muffleMessage")
[13:36:33.912]                       }
[13:36:33.912]                       else if (inherits(cond, "warning")) {
[13:36:33.912]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.912]                         if (muffled) 
[13:36:33.912]                           invokeRestart("muffleWarning")
[13:36:33.912]                       }
[13:36:33.912]                       else if (inherits(cond, "condition")) {
[13:36:33.912]                         if (!is.null(pattern)) {
[13:36:33.912]                           computeRestarts <- base::computeRestarts
[13:36:33.912]                           grepl <- base::grepl
[13:36:33.912]                           restarts <- computeRestarts(cond)
[13:36:33.912]                           for (restart in restarts) {
[13:36:33.912]                             name <- restart$name
[13:36:33.912]                             if (is.null(name)) 
[13:36:33.912]                               next
[13:36:33.912]                             if (!grepl(pattern, name)) 
[13:36:33.912]                               next
[13:36:33.912]                             invokeRestart(restart)
[13:36:33.912]                             muffled <- TRUE
[13:36:33.912]                             break
[13:36:33.912]                           }
[13:36:33.912]                         }
[13:36:33.912]                       }
[13:36:33.912]                       invisible(muffled)
[13:36:33.912]                     }
[13:36:33.912]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.912]                   }
[13:36:33.912]                 }
[13:36:33.912]                 else {
[13:36:33.912]                   if (TRUE) {
[13:36:33.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.912]                     {
[13:36:33.912]                       inherits <- base::inherits
[13:36:33.912]                       invokeRestart <- base::invokeRestart
[13:36:33.912]                       is.null <- base::is.null
[13:36:33.912]                       muffled <- FALSE
[13:36:33.912]                       if (inherits(cond, "message")) {
[13:36:33.912]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.912]                         if (muffled) 
[13:36:33.912]                           invokeRestart("muffleMessage")
[13:36:33.912]                       }
[13:36:33.912]                       else if (inherits(cond, "warning")) {
[13:36:33.912]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.912]                         if (muffled) 
[13:36:33.912]                           invokeRestart("muffleWarning")
[13:36:33.912]                       }
[13:36:33.912]                       else if (inherits(cond, "condition")) {
[13:36:33.912]                         if (!is.null(pattern)) {
[13:36:33.912]                           computeRestarts <- base::computeRestarts
[13:36:33.912]                           grepl <- base::grepl
[13:36:33.912]                           restarts <- computeRestarts(cond)
[13:36:33.912]                           for (restart in restarts) {
[13:36:33.912]                             name <- restart$name
[13:36:33.912]                             if (is.null(name)) 
[13:36:33.912]                               next
[13:36:33.912]                             if (!grepl(pattern, name)) 
[13:36:33.912]                               next
[13:36:33.912]                             invokeRestart(restart)
[13:36:33.912]                             muffled <- TRUE
[13:36:33.912]                             break
[13:36:33.912]                           }
[13:36:33.912]                         }
[13:36:33.912]                       }
[13:36:33.912]                       invisible(muffled)
[13:36:33.912]                     }
[13:36:33.912]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.912]                   }
[13:36:33.912]                 }
[13:36:33.912]             }
[13:36:33.912]         }))
[13:36:33.912]     }, error = function(ex) {
[13:36:33.912]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.912]                 ...future.rng), started = ...future.startTime, 
[13:36:33.912]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.912]             version = "1.8"), class = "FutureResult")
[13:36:33.912]     }, finally = {
[13:36:33.912]         if (!identical(...future.workdir, getwd())) 
[13:36:33.912]             setwd(...future.workdir)
[13:36:33.912]         {
[13:36:33.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.912]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.912]             }
[13:36:33.912]             base::options(...future.oldOptions)
[13:36:33.912]             if (.Platform$OS.type == "windows") {
[13:36:33.912]                 old_names <- names(...future.oldEnvVars)
[13:36:33.912]                 envs <- base::Sys.getenv()
[13:36:33.912]                 names <- names(envs)
[13:36:33.912]                 common <- intersect(names, old_names)
[13:36:33.912]                 added <- setdiff(names, old_names)
[13:36:33.912]                 removed <- setdiff(old_names, names)
[13:36:33.912]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.912]                   envs[common]]
[13:36:33.912]                 NAMES <- toupper(changed)
[13:36:33.912]                 args <- list()
[13:36:33.912]                 for (kk in seq_along(NAMES)) {
[13:36:33.912]                   name <- changed[[kk]]
[13:36:33.912]                   NAME <- NAMES[[kk]]
[13:36:33.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.912]                     next
[13:36:33.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.912]                 }
[13:36:33.912]                 NAMES <- toupper(added)
[13:36:33.912]                 for (kk in seq_along(NAMES)) {
[13:36:33.912]                   name <- added[[kk]]
[13:36:33.912]                   NAME <- NAMES[[kk]]
[13:36:33.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.912]                     next
[13:36:33.912]                   args[[name]] <- ""
[13:36:33.912]                 }
[13:36:33.912]                 NAMES <- toupper(removed)
[13:36:33.912]                 for (kk in seq_along(NAMES)) {
[13:36:33.912]                   name <- removed[[kk]]
[13:36:33.912]                   NAME <- NAMES[[kk]]
[13:36:33.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.912]                     next
[13:36:33.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.912]                 }
[13:36:33.912]                 if (length(args) > 0) 
[13:36:33.912]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.912]             }
[13:36:33.912]             else {
[13:36:33.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.912]             }
[13:36:33.912]             {
[13:36:33.912]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.912]                   0L) {
[13:36:33.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.912]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.912]                   base::options(opts)
[13:36:33.912]                 }
[13:36:33.912]                 {
[13:36:33.912]                   {
[13:36:33.912]                     NULL
[13:36:33.912]                     RNGkind("Mersenne-Twister")
[13:36:33.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.912]                       inherits = FALSE)
[13:36:33.912]                   }
[13:36:33.912]                   options(future.plan = NULL)
[13:36:33.912]                   if (is.na(NA_character_)) 
[13:36:33.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.912]                     .init = FALSE)
[13:36:33.912]                 }
[13:36:33.912]             }
[13:36:33.912]         }
[13:36:33.912]     })
[13:36:33.912]     if (TRUE) {
[13:36:33.912]         base::sink(type = "output", split = FALSE)
[13:36:33.912]         if (TRUE) {
[13:36:33.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.912]         }
[13:36:33.912]         else {
[13:36:33.912]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.912]         }
[13:36:33.912]         base::close(...future.stdout)
[13:36:33.912]         ...future.stdout <- NULL
[13:36:33.912]     }
[13:36:33.912]     ...future.result$conditions <- ...future.conditions
[13:36:33.912]     ...future.result$finished <- base::Sys.time()
[13:36:33.912]     ...future.result
[13:36:33.912] }
[13:36:33.914] plan(): Setting new future strategy stack:
[13:36:33.914] List of future strategies:
[13:36:33.914] 1. sequential:
[13:36:33.914]    - args: function (..., envir = parent.frame())
[13:36:33.914]    - tweaked: FALSE
[13:36:33.914]    - call: NULL
[13:36:33.914] plan(): nbrOfWorkers() = 1
[13:36:33.916] plan(): Setting new future strategy stack:
[13:36:33.916] List of future strategies:
[13:36:33.916] 1. sequential:
[13:36:33.916]    - args: function (..., envir = parent.frame())
[13:36:33.916]    - tweaked: FALSE
[13:36:33.916]    - call: plan(strategy)
[13:36:33.916] plan(): nbrOfWorkers() = 1
[13:36:33.916] SequentialFuture started (and completed)
[13:36:33.917] - Launch lazy future ... done
[13:36:33.917] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a7309e2e8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a734f8890> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a7309e2e8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x564a734f8890> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:33.922] resolved() for ‘SequentialFuture’ ...
[13:36:33.922] - state: ‘finished’
[13:36:33.922] - run: TRUE
[13:36:33.922] - result: ‘FutureResult’
[13:36:33.922] resolved() for ‘SequentialFuture’ ... done
[13:36:33.922] resolved() for ‘SequentialFuture’ ...
[13:36:33.922] - state: ‘finished’
[13:36:33.922] - run: TRUE
[13:36:33.923] - result: ‘FutureResult’
[13:36:33.923] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:33.925] resolve() on list ...
[13:36:33.925]  recursive: 0
[13:36:33.925]  length: 6
[13:36:33.925]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:33.925] signalConditionsASAP(numeric, pos=1) ...
[13:36:33.925] - nx: 6
[13:36:33.925] - relay: TRUE
[13:36:33.925] - stdout: TRUE
[13:36:33.925] - signal: TRUE
[13:36:33.925] - resignal: FALSE
[13:36:33.925] - force: TRUE
[13:36:33.925] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.926] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.926]  - until=2
[13:36:33.926]  - relaying element #2
[13:36:33.926] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.926] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.926] signalConditionsASAP(NULL, pos=1) ... done
[13:36:33.926]  length: 5 (resolved future 1)
[13:36:33.926] resolved() for ‘SequentialFuture’ ...
[13:36:33.926] - state: ‘finished’
[13:36:33.926] - run: TRUE
[13:36:33.927] - result: ‘FutureResult’
[13:36:33.927] resolved() for ‘SequentialFuture’ ... done
[13:36:33.927] Future #2
[13:36:33.927] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:33.927] - nx: 6
[13:36:33.927] - relay: TRUE
[13:36:33.927] - stdout: TRUE
[13:36:33.927] - signal: TRUE
[13:36:33.927] - resignal: FALSE
[13:36:33.927] - force: TRUE
[13:36:33.927] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.927] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:33.928]  - until=2
[13:36:33.928]  - relaying element #2
[13:36:33.928] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.928] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.928] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:33.928]  length: 4 (resolved future 2)
[13:36:33.928] resolved() for ‘SequentialFuture’ ...
[13:36:33.928] - state: ‘finished’
[13:36:33.928] - run: TRUE
[13:36:33.928] - result: ‘FutureResult’
[13:36:33.929] resolved() for ‘SequentialFuture’ ... done
[13:36:33.929] Future #3
[13:36:33.929] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:33.929] - nx: 6
[13:36:33.929] - relay: TRUE
[13:36:33.929] - stdout: TRUE
[13:36:33.929] - signal: TRUE
[13:36:33.929] - resignal: FALSE
[13:36:33.929] - force: TRUE
[13:36:33.929] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.929] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:33.929]  - until=3
[13:36:33.930]  - relaying element #3
[13:36:33.930] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.930] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:33.930]  length: 3 (resolved future 3)
[13:36:33.930] signalConditionsASAP(NULL, pos=4) ...
[13:36:33.930] - nx: 6
[13:36:33.930] - relay: TRUE
[13:36:33.930] - stdout: TRUE
[13:36:33.930] - signal: TRUE
[13:36:33.931] - resignal: FALSE
[13:36:33.931] - force: TRUE
[13:36:33.931] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.931]  - until=5
[13:36:33.931]  - relaying element #5
[13:36:33.931] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.931] signalConditionsASAP(NULL, pos=4) ... done
[13:36:33.931]  length: 2 (resolved future 4)
[13:36:33.931] signalConditionsASAP(NULL, pos=5) ...
[13:36:33.931] - nx: 6
[13:36:33.932] - relay: TRUE
[13:36:33.932] - stdout: TRUE
[13:36:33.932] - signal: TRUE
[13:36:33.932] - resignal: FALSE
[13:36:33.932] - force: TRUE
[13:36:33.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:33.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.932]  - until=6
[13:36:33.932]  - relaying element #6
[13:36:33.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.932] signalConditionsASAP(NULL, pos=5) ... done
[13:36:33.932]  length: 1 (resolved future 5)
[13:36:33.933] signalConditionsASAP(numeric, pos=6) ...
[13:36:33.933] - nx: 6
[13:36:33.933] - relay: TRUE
[13:36:33.933] - stdout: TRUE
[13:36:33.933] - signal: TRUE
[13:36:33.933] - resignal: FALSE
[13:36:33.933] - force: TRUE
[13:36:33.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:33.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.933]  - until=6
[13:36:33.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.934] signalConditionsASAP(numeric, pos=6) ... done
[13:36:33.934]  length: 0 (resolved future 6)
[13:36:33.934] Relaying remaining futures
[13:36:33.934] signalConditionsASAP(NULL, pos=0) ...
[13:36:33.934] - nx: 6
[13:36:33.934] - relay: TRUE
[13:36:33.934] - stdout: TRUE
[13:36:33.934] - signal: TRUE
[13:36:33.934] - resignal: FALSE
[13:36:33.934] - force: TRUE
[13:36:33.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.934] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:33.935] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:33.935] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:33.935] signalConditionsASAP(NULL, pos=0) ... done
[13:36:33.935] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[13:36:33.944] plan(): Setting new future strategy stack:
[13:36:33.944] List of future strategies:
[13:36:33.944] 1. sequential:
[13:36:33.944]    - args: function (..., envir = parent.frame())
[13:36:33.944]    - tweaked: FALSE
[13:36:33.944]    - call: plan(strategy)
[13:36:33.945] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:36:33.945] getGlobalsAndPackages() ...
[13:36:33.945] Searching for globals...
[13:36:33.945] 
[13:36:33.945] Searching for globals ... DONE
[13:36:33.945] - globals: [0] <none>
[13:36:33.945] getGlobalsAndPackages() ... DONE
[13:36:33.946] run() for ‘Future’ ...
[13:36:33.946] - state: ‘created’
[13:36:33.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.946]   - Field: ‘label’
[13:36:33.946]   - Field: ‘local’
[13:36:33.946]   - Field: ‘owner’
[13:36:33.946]   - Field: ‘envir’
[13:36:33.947]   - Field: ‘packages’
[13:36:33.947]   - Field: ‘gc’
[13:36:33.947]   - Field: ‘conditions’
[13:36:33.947]   - Field: ‘expr’
[13:36:33.947]   - Field: ‘uuid’
[13:36:33.947]   - Field: ‘seed’
[13:36:33.947]   - Field: ‘version’
[13:36:33.947]   - Field: ‘result’
[13:36:33.947]   - Field: ‘asynchronous’
[13:36:33.947]   - Field: ‘calls’
[13:36:33.947]   - Field: ‘globals’
[13:36:33.948]   - Field: ‘stdout’
[13:36:33.948]   - Field: ‘earlySignal’
[13:36:33.948]   - Field: ‘lazy’
[13:36:33.948]   - Field: ‘state’
[13:36:33.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.948] - Launch lazy future ...
[13:36:33.948] Packages needed by the future expression (n = 0): <none>
[13:36:33.948] Packages needed by future strategies (n = 0): <none>
[13:36:33.949] {
[13:36:33.949]     {
[13:36:33.949]         {
[13:36:33.949]             ...future.startTime <- base::Sys.time()
[13:36:33.949]             {
[13:36:33.949]                 {
[13:36:33.949]                   {
[13:36:33.949]                     base::local({
[13:36:33.949]                       has_future <- base::requireNamespace("future", 
[13:36:33.949]                         quietly = TRUE)
[13:36:33.949]                       if (has_future) {
[13:36:33.949]                         ns <- base::getNamespace("future")
[13:36:33.949]                         version <- ns[[".package"]][["version"]]
[13:36:33.949]                         if (is.null(version)) 
[13:36:33.949]                           version <- utils::packageVersion("future")
[13:36:33.949]                       }
[13:36:33.949]                       else {
[13:36:33.949]                         version <- NULL
[13:36:33.949]                       }
[13:36:33.949]                       if (!has_future || version < "1.8.0") {
[13:36:33.949]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.949]                           "", base::R.version$version.string), 
[13:36:33.949]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.949]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.949]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.949]                             "release", "version")], collapse = " "), 
[13:36:33.949]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.949]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.949]                           info)
[13:36:33.949]                         info <- base::paste(info, collapse = "; ")
[13:36:33.949]                         if (!has_future) {
[13:36:33.949]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.949]                             info)
[13:36:33.949]                         }
[13:36:33.949]                         else {
[13:36:33.949]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.949]                             info, version)
[13:36:33.949]                         }
[13:36:33.949]                         base::stop(msg)
[13:36:33.949]                       }
[13:36:33.949]                     })
[13:36:33.949]                   }
[13:36:33.949]                   ...future.strategy.old <- future::plan("list")
[13:36:33.949]                   options(future.plan = NULL)
[13:36:33.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.949]                 }
[13:36:33.949]                 ...future.workdir <- getwd()
[13:36:33.949]             }
[13:36:33.949]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.949]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.949]         }
[13:36:33.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.949]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.949]             base::names(...future.oldOptions))
[13:36:33.949]     }
[13:36:33.949]     if (FALSE) {
[13:36:33.949]     }
[13:36:33.949]     else {
[13:36:33.949]         if (TRUE) {
[13:36:33.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.949]                 open = "w")
[13:36:33.949]         }
[13:36:33.949]         else {
[13:36:33.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.949]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.949]         }
[13:36:33.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.949]             base::sink(type = "output", split = FALSE)
[13:36:33.949]             base::close(...future.stdout)
[13:36:33.949]         }, add = TRUE)
[13:36:33.949]     }
[13:36:33.949]     ...future.frame <- base::sys.nframe()
[13:36:33.949]     ...future.conditions <- base::list()
[13:36:33.949]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.949]     if (FALSE) {
[13:36:33.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.949]     }
[13:36:33.949]     ...future.result <- base::tryCatch({
[13:36:33.949]         base::withCallingHandlers({
[13:36:33.949]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.949]             future::FutureResult(value = ...future.value$value, 
[13:36:33.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.949]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.949]                     ...future.globalenv.names))
[13:36:33.949]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.949]         }, condition = base::local({
[13:36:33.949]             c <- base::c
[13:36:33.949]             inherits <- base::inherits
[13:36:33.949]             invokeRestart <- base::invokeRestart
[13:36:33.949]             length <- base::length
[13:36:33.949]             list <- base::list
[13:36:33.949]             seq.int <- base::seq.int
[13:36:33.949]             signalCondition <- base::signalCondition
[13:36:33.949]             sys.calls <- base::sys.calls
[13:36:33.949]             `[[` <- base::`[[`
[13:36:33.949]             `+` <- base::`+`
[13:36:33.949]             `<<-` <- base::`<<-`
[13:36:33.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.949]                   3L)]
[13:36:33.949]             }
[13:36:33.949]             function(cond) {
[13:36:33.949]                 is_error <- inherits(cond, "error")
[13:36:33.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.949]                   NULL)
[13:36:33.949]                 if (is_error) {
[13:36:33.949]                   sessionInformation <- function() {
[13:36:33.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.949]                       search = base::search(), system = base::Sys.info())
[13:36:33.949]                   }
[13:36:33.949]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.949]                     cond$call), session = sessionInformation(), 
[13:36:33.949]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.949]                   signalCondition(cond)
[13:36:33.949]                 }
[13:36:33.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.949]                 "immediateCondition"))) {
[13:36:33.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.949]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.949]                   if (TRUE && !signal) {
[13:36:33.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.949]                     {
[13:36:33.949]                       inherits <- base::inherits
[13:36:33.949]                       invokeRestart <- base::invokeRestart
[13:36:33.949]                       is.null <- base::is.null
[13:36:33.949]                       muffled <- FALSE
[13:36:33.949]                       if (inherits(cond, "message")) {
[13:36:33.949]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.949]                         if (muffled) 
[13:36:33.949]                           invokeRestart("muffleMessage")
[13:36:33.949]                       }
[13:36:33.949]                       else if (inherits(cond, "warning")) {
[13:36:33.949]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.949]                         if (muffled) 
[13:36:33.949]                           invokeRestart("muffleWarning")
[13:36:33.949]                       }
[13:36:33.949]                       else if (inherits(cond, "condition")) {
[13:36:33.949]                         if (!is.null(pattern)) {
[13:36:33.949]                           computeRestarts <- base::computeRestarts
[13:36:33.949]                           grepl <- base::grepl
[13:36:33.949]                           restarts <- computeRestarts(cond)
[13:36:33.949]                           for (restart in restarts) {
[13:36:33.949]                             name <- restart$name
[13:36:33.949]                             if (is.null(name)) 
[13:36:33.949]                               next
[13:36:33.949]                             if (!grepl(pattern, name)) 
[13:36:33.949]                               next
[13:36:33.949]                             invokeRestart(restart)
[13:36:33.949]                             muffled <- TRUE
[13:36:33.949]                             break
[13:36:33.949]                           }
[13:36:33.949]                         }
[13:36:33.949]                       }
[13:36:33.949]                       invisible(muffled)
[13:36:33.949]                     }
[13:36:33.949]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.949]                   }
[13:36:33.949]                 }
[13:36:33.949]                 else {
[13:36:33.949]                   if (TRUE) {
[13:36:33.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.949]                     {
[13:36:33.949]                       inherits <- base::inherits
[13:36:33.949]                       invokeRestart <- base::invokeRestart
[13:36:33.949]                       is.null <- base::is.null
[13:36:33.949]                       muffled <- FALSE
[13:36:33.949]                       if (inherits(cond, "message")) {
[13:36:33.949]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.949]                         if (muffled) 
[13:36:33.949]                           invokeRestart("muffleMessage")
[13:36:33.949]                       }
[13:36:33.949]                       else if (inherits(cond, "warning")) {
[13:36:33.949]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.949]                         if (muffled) 
[13:36:33.949]                           invokeRestart("muffleWarning")
[13:36:33.949]                       }
[13:36:33.949]                       else if (inherits(cond, "condition")) {
[13:36:33.949]                         if (!is.null(pattern)) {
[13:36:33.949]                           computeRestarts <- base::computeRestarts
[13:36:33.949]                           grepl <- base::grepl
[13:36:33.949]                           restarts <- computeRestarts(cond)
[13:36:33.949]                           for (restart in restarts) {
[13:36:33.949]                             name <- restart$name
[13:36:33.949]                             if (is.null(name)) 
[13:36:33.949]                               next
[13:36:33.949]                             if (!grepl(pattern, name)) 
[13:36:33.949]                               next
[13:36:33.949]                             invokeRestart(restart)
[13:36:33.949]                             muffled <- TRUE
[13:36:33.949]                             break
[13:36:33.949]                           }
[13:36:33.949]                         }
[13:36:33.949]                       }
[13:36:33.949]                       invisible(muffled)
[13:36:33.949]                     }
[13:36:33.949]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.949]                   }
[13:36:33.949]                 }
[13:36:33.949]             }
[13:36:33.949]         }))
[13:36:33.949]     }, error = function(ex) {
[13:36:33.949]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.949]                 ...future.rng), started = ...future.startTime, 
[13:36:33.949]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.949]             version = "1.8"), class = "FutureResult")
[13:36:33.949]     }, finally = {
[13:36:33.949]         if (!identical(...future.workdir, getwd())) 
[13:36:33.949]             setwd(...future.workdir)
[13:36:33.949]         {
[13:36:33.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.949]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.949]             }
[13:36:33.949]             base::options(...future.oldOptions)
[13:36:33.949]             if (.Platform$OS.type == "windows") {
[13:36:33.949]                 old_names <- names(...future.oldEnvVars)
[13:36:33.949]                 envs <- base::Sys.getenv()
[13:36:33.949]                 names <- names(envs)
[13:36:33.949]                 common <- intersect(names, old_names)
[13:36:33.949]                 added <- setdiff(names, old_names)
[13:36:33.949]                 removed <- setdiff(old_names, names)
[13:36:33.949]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.949]                   envs[common]]
[13:36:33.949]                 NAMES <- toupper(changed)
[13:36:33.949]                 args <- list()
[13:36:33.949]                 for (kk in seq_along(NAMES)) {
[13:36:33.949]                   name <- changed[[kk]]
[13:36:33.949]                   NAME <- NAMES[[kk]]
[13:36:33.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.949]                     next
[13:36:33.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.949]                 }
[13:36:33.949]                 NAMES <- toupper(added)
[13:36:33.949]                 for (kk in seq_along(NAMES)) {
[13:36:33.949]                   name <- added[[kk]]
[13:36:33.949]                   NAME <- NAMES[[kk]]
[13:36:33.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.949]                     next
[13:36:33.949]                   args[[name]] <- ""
[13:36:33.949]                 }
[13:36:33.949]                 NAMES <- toupper(removed)
[13:36:33.949]                 for (kk in seq_along(NAMES)) {
[13:36:33.949]                   name <- removed[[kk]]
[13:36:33.949]                   NAME <- NAMES[[kk]]
[13:36:33.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.949]                     next
[13:36:33.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.949]                 }
[13:36:33.949]                 if (length(args) > 0) 
[13:36:33.949]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.949]             }
[13:36:33.949]             else {
[13:36:33.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.949]             }
[13:36:33.949]             {
[13:36:33.949]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.949]                   0L) {
[13:36:33.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.949]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.949]                   base::options(opts)
[13:36:33.949]                 }
[13:36:33.949]                 {
[13:36:33.949]                   {
[13:36:33.949]                     NULL
[13:36:33.949]                     RNGkind("Mersenne-Twister")
[13:36:33.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.949]                       inherits = FALSE)
[13:36:33.949]                   }
[13:36:33.949]                   options(future.plan = NULL)
[13:36:33.949]                   if (is.na(NA_character_)) 
[13:36:33.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.949]                     .init = FALSE)
[13:36:33.949]                 }
[13:36:33.949]             }
[13:36:33.949]         }
[13:36:33.949]     })
[13:36:33.949]     if (TRUE) {
[13:36:33.949]         base::sink(type = "output", split = FALSE)
[13:36:33.949]         if (TRUE) {
[13:36:33.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.949]         }
[13:36:33.949]         else {
[13:36:33.949]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.949]         }
[13:36:33.949]         base::close(...future.stdout)
[13:36:33.949]         ...future.stdout <- NULL
[13:36:33.949]     }
[13:36:33.949]     ...future.result$conditions <- ...future.conditions
[13:36:33.949]     ...future.result$finished <- base::Sys.time()
[13:36:33.949]     ...future.result
[13:36:33.949] }
[13:36:33.950] plan(): Setting new future strategy stack:
[13:36:33.950] List of future strategies:
[13:36:33.950] 1. sequential:
[13:36:33.950]    - args: function (..., envir = parent.frame())
[13:36:33.950]    - tweaked: FALSE
[13:36:33.950]    - call: NULL
[13:36:33.951] plan(): nbrOfWorkers() = 1
[13:36:33.951] plan(): Setting new future strategy stack:
[13:36:33.951] List of future strategies:
[13:36:33.951] 1. sequential:
[13:36:33.951]    - args: function (..., envir = parent.frame())
[13:36:33.951]    - tweaked: FALSE
[13:36:33.951]    - call: plan(strategy)
[13:36:33.952] plan(): nbrOfWorkers() = 1
[13:36:33.952] SequentialFuture started (and completed)
[13:36:33.952] - Launch lazy future ... done
[13:36:33.952] run() for ‘SequentialFuture’ ... done
[13:36:33.952] getGlobalsAndPackages() ...
[13:36:33.952] Searching for globals...
[13:36:33.953] 
[13:36:33.953] Searching for globals ... DONE
[13:36:33.953] - globals: [0] <none>
[13:36:33.953] getGlobalsAndPackages() ... DONE
[13:36:33.953] run() for ‘Future’ ...
[13:36:33.953] - state: ‘created’
[13:36:33.953] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.954] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.954]   - Field: ‘label’
[13:36:33.954]   - Field: ‘local’
[13:36:33.954]   - Field: ‘owner’
[13:36:33.954]   - Field: ‘envir’
[13:36:33.954]   - Field: ‘packages’
[13:36:33.954]   - Field: ‘gc’
[13:36:33.954]   - Field: ‘conditions’
[13:36:33.954]   - Field: ‘expr’
[13:36:33.954]   - Field: ‘uuid’
[13:36:33.955]   - Field: ‘seed’
[13:36:33.955]   - Field: ‘version’
[13:36:33.955]   - Field: ‘result’
[13:36:33.955]   - Field: ‘asynchronous’
[13:36:33.955]   - Field: ‘calls’
[13:36:33.955]   - Field: ‘globals’
[13:36:33.955]   - Field: ‘stdout’
[13:36:33.955]   - Field: ‘earlySignal’
[13:36:33.955]   - Field: ‘lazy’
[13:36:33.955]   - Field: ‘state’
[13:36:33.955] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.956] - Launch lazy future ...
[13:36:33.956] Packages needed by the future expression (n = 0): <none>
[13:36:33.956] Packages needed by future strategies (n = 0): <none>
[13:36:33.956] {
[13:36:33.956]     {
[13:36:33.956]         {
[13:36:33.956]             ...future.startTime <- base::Sys.time()
[13:36:33.956]             {
[13:36:33.956]                 {
[13:36:33.956]                   {
[13:36:33.956]                     base::local({
[13:36:33.956]                       has_future <- base::requireNamespace("future", 
[13:36:33.956]                         quietly = TRUE)
[13:36:33.956]                       if (has_future) {
[13:36:33.956]                         ns <- base::getNamespace("future")
[13:36:33.956]                         version <- ns[[".package"]][["version"]]
[13:36:33.956]                         if (is.null(version)) 
[13:36:33.956]                           version <- utils::packageVersion("future")
[13:36:33.956]                       }
[13:36:33.956]                       else {
[13:36:33.956]                         version <- NULL
[13:36:33.956]                       }
[13:36:33.956]                       if (!has_future || version < "1.8.0") {
[13:36:33.956]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.956]                           "", base::R.version$version.string), 
[13:36:33.956]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.956]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.956]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.956]                             "release", "version")], collapse = " "), 
[13:36:33.956]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.956]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.956]                           info)
[13:36:33.956]                         info <- base::paste(info, collapse = "; ")
[13:36:33.956]                         if (!has_future) {
[13:36:33.956]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.956]                             info)
[13:36:33.956]                         }
[13:36:33.956]                         else {
[13:36:33.956]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.956]                             info, version)
[13:36:33.956]                         }
[13:36:33.956]                         base::stop(msg)
[13:36:33.956]                       }
[13:36:33.956]                     })
[13:36:33.956]                   }
[13:36:33.956]                   ...future.strategy.old <- future::plan("list")
[13:36:33.956]                   options(future.plan = NULL)
[13:36:33.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.956]                 }
[13:36:33.956]                 ...future.workdir <- getwd()
[13:36:33.956]             }
[13:36:33.956]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.956]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.956]         }
[13:36:33.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.956]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.956]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.956]             base::names(...future.oldOptions))
[13:36:33.956]     }
[13:36:33.956]     if (FALSE) {
[13:36:33.956]     }
[13:36:33.956]     else {
[13:36:33.956]         if (TRUE) {
[13:36:33.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.956]                 open = "w")
[13:36:33.956]         }
[13:36:33.956]         else {
[13:36:33.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.956]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.956]         }
[13:36:33.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.956]             base::sink(type = "output", split = FALSE)
[13:36:33.956]             base::close(...future.stdout)
[13:36:33.956]         }, add = TRUE)
[13:36:33.956]     }
[13:36:33.956]     ...future.frame <- base::sys.nframe()
[13:36:33.956]     ...future.conditions <- base::list()
[13:36:33.956]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.956]     if (FALSE) {
[13:36:33.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.956]     }
[13:36:33.956]     ...future.result <- base::tryCatch({
[13:36:33.956]         base::withCallingHandlers({
[13:36:33.956]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.956]             future::FutureResult(value = ...future.value$value, 
[13:36:33.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.956]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.956]                     ...future.globalenv.names))
[13:36:33.956]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.956]         }, condition = base::local({
[13:36:33.956]             c <- base::c
[13:36:33.956]             inherits <- base::inherits
[13:36:33.956]             invokeRestart <- base::invokeRestart
[13:36:33.956]             length <- base::length
[13:36:33.956]             list <- base::list
[13:36:33.956]             seq.int <- base::seq.int
[13:36:33.956]             signalCondition <- base::signalCondition
[13:36:33.956]             sys.calls <- base::sys.calls
[13:36:33.956]             `[[` <- base::`[[`
[13:36:33.956]             `+` <- base::`+`
[13:36:33.956]             `<<-` <- base::`<<-`
[13:36:33.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.956]                   3L)]
[13:36:33.956]             }
[13:36:33.956]             function(cond) {
[13:36:33.956]                 is_error <- inherits(cond, "error")
[13:36:33.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.956]                   NULL)
[13:36:33.956]                 if (is_error) {
[13:36:33.956]                   sessionInformation <- function() {
[13:36:33.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.956]                       search = base::search(), system = base::Sys.info())
[13:36:33.956]                   }
[13:36:33.956]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.956]                     cond$call), session = sessionInformation(), 
[13:36:33.956]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.956]                   signalCondition(cond)
[13:36:33.956]                 }
[13:36:33.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.956]                 "immediateCondition"))) {
[13:36:33.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.956]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.956]                   if (TRUE && !signal) {
[13:36:33.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.956]                     {
[13:36:33.956]                       inherits <- base::inherits
[13:36:33.956]                       invokeRestart <- base::invokeRestart
[13:36:33.956]                       is.null <- base::is.null
[13:36:33.956]                       muffled <- FALSE
[13:36:33.956]                       if (inherits(cond, "message")) {
[13:36:33.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.956]                         if (muffled) 
[13:36:33.956]                           invokeRestart("muffleMessage")
[13:36:33.956]                       }
[13:36:33.956]                       else if (inherits(cond, "warning")) {
[13:36:33.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.956]                         if (muffled) 
[13:36:33.956]                           invokeRestart("muffleWarning")
[13:36:33.956]                       }
[13:36:33.956]                       else if (inherits(cond, "condition")) {
[13:36:33.956]                         if (!is.null(pattern)) {
[13:36:33.956]                           computeRestarts <- base::computeRestarts
[13:36:33.956]                           grepl <- base::grepl
[13:36:33.956]                           restarts <- computeRestarts(cond)
[13:36:33.956]                           for (restart in restarts) {
[13:36:33.956]                             name <- restart$name
[13:36:33.956]                             if (is.null(name)) 
[13:36:33.956]                               next
[13:36:33.956]                             if (!grepl(pattern, name)) 
[13:36:33.956]                               next
[13:36:33.956]                             invokeRestart(restart)
[13:36:33.956]                             muffled <- TRUE
[13:36:33.956]                             break
[13:36:33.956]                           }
[13:36:33.956]                         }
[13:36:33.956]                       }
[13:36:33.956]                       invisible(muffled)
[13:36:33.956]                     }
[13:36:33.956]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.956]                   }
[13:36:33.956]                 }
[13:36:33.956]                 else {
[13:36:33.956]                   if (TRUE) {
[13:36:33.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.956]                     {
[13:36:33.956]                       inherits <- base::inherits
[13:36:33.956]                       invokeRestart <- base::invokeRestart
[13:36:33.956]                       is.null <- base::is.null
[13:36:33.956]                       muffled <- FALSE
[13:36:33.956]                       if (inherits(cond, "message")) {
[13:36:33.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.956]                         if (muffled) 
[13:36:33.956]                           invokeRestart("muffleMessage")
[13:36:33.956]                       }
[13:36:33.956]                       else if (inherits(cond, "warning")) {
[13:36:33.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.956]                         if (muffled) 
[13:36:33.956]                           invokeRestart("muffleWarning")
[13:36:33.956]                       }
[13:36:33.956]                       else if (inherits(cond, "condition")) {
[13:36:33.956]                         if (!is.null(pattern)) {
[13:36:33.956]                           computeRestarts <- base::computeRestarts
[13:36:33.956]                           grepl <- base::grepl
[13:36:33.956]                           restarts <- computeRestarts(cond)
[13:36:33.956]                           for (restart in restarts) {
[13:36:33.956]                             name <- restart$name
[13:36:33.956]                             if (is.null(name)) 
[13:36:33.956]                               next
[13:36:33.956]                             if (!grepl(pattern, name)) 
[13:36:33.956]                               next
[13:36:33.956]                             invokeRestart(restart)
[13:36:33.956]                             muffled <- TRUE
[13:36:33.956]                             break
[13:36:33.956]                           }
[13:36:33.956]                         }
[13:36:33.956]                       }
[13:36:33.956]                       invisible(muffled)
[13:36:33.956]                     }
[13:36:33.956]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.956]                   }
[13:36:33.956]                 }
[13:36:33.956]             }
[13:36:33.956]         }))
[13:36:33.956]     }, error = function(ex) {
[13:36:33.956]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.956]                 ...future.rng), started = ...future.startTime, 
[13:36:33.956]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.956]             version = "1.8"), class = "FutureResult")
[13:36:33.956]     }, finally = {
[13:36:33.956]         if (!identical(...future.workdir, getwd())) 
[13:36:33.956]             setwd(...future.workdir)
[13:36:33.956]         {
[13:36:33.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.956]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.956]             }
[13:36:33.956]             base::options(...future.oldOptions)
[13:36:33.956]             if (.Platform$OS.type == "windows") {
[13:36:33.956]                 old_names <- names(...future.oldEnvVars)
[13:36:33.956]                 envs <- base::Sys.getenv()
[13:36:33.956]                 names <- names(envs)
[13:36:33.956]                 common <- intersect(names, old_names)
[13:36:33.956]                 added <- setdiff(names, old_names)
[13:36:33.956]                 removed <- setdiff(old_names, names)
[13:36:33.956]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.956]                   envs[common]]
[13:36:33.956]                 NAMES <- toupper(changed)
[13:36:33.956]                 args <- list()
[13:36:33.956]                 for (kk in seq_along(NAMES)) {
[13:36:33.956]                   name <- changed[[kk]]
[13:36:33.956]                   NAME <- NAMES[[kk]]
[13:36:33.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.956]                     next
[13:36:33.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.956]                 }
[13:36:33.956]                 NAMES <- toupper(added)
[13:36:33.956]                 for (kk in seq_along(NAMES)) {
[13:36:33.956]                   name <- added[[kk]]
[13:36:33.956]                   NAME <- NAMES[[kk]]
[13:36:33.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.956]                     next
[13:36:33.956]                   args[[name]] <- ""
[13:36:33.956]                 }
[13:36:33.956]                 NAMES <- toupper(removed)
[13:36:33.956]                 for (kk in seq_along(NAMES)) {
[13:36:33.956]                   name <- removed[[kk]]
[13:36:33.956]                   NAME <- NAMES[[kk]]
[13:36:33.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.956]                     next
[13:36:33.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.956]                 }
[13:36:33.956]                 if (length(args) > 0) 
[13:36:33.956]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.956]             }
[13:36:33.956]             else {
[13:36:33.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.956]             }
[13:36:33.956]             {
[13:36:33.956]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.956]                   0L) {
[13:36:33.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.956]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.956]                   base::options(opts)
[13:36:33.956]                 }
[13:36:33.956]                 {
[13:36:33.956]                   {
[13:36:33.956]                     NULL
[13:36:33.956]                     RNGkind("Mersenne-Twister")
[13:36:33.956]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.956]                       inherits = FALSE)
[13:36:33.956]                   }
[13:36:33.956]                   options(future.plan = NULL)
[13:36:33.956]                   if (is.na(NA_character_)) 
[13:36:33.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.956]                     .init = FALSE)
[13:36:33.956]                 }
[13:36:33.956]             }
[13:36:33.956]         }
[13:36:33.956]     })
[13:36:33.956]     if (TRUE) {
[13:36:33.956]         base::sink(type = "output", split = FALSE)
[13:36:33.956]         if (TRUE) {
[13:36:33.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.956]         }
[13:36:33.956]         else {
[13:36:33.956]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.956]         }
[13:36:33.956]         base::close(...future.stdout)
[13:36:33.956]         ...future.stdout <- NULL
[13:36:33.956]     }
[13:36:33.956]     ...future.result$conditions <- ...future.conditions
[13:36:33.956]     ...future.result$finished <- base::Sys.time()
[13:36:33.956]     ...future.result
[13:36:33.956] }
[13:36:33.958] plan(): Setting new future strategy stack:
[13:36:33.958] List of future strategies:
[13:36:33.958] 1. sequential:
[13:36:33.958]    - args: function (..., envir = parent.frame())
[13:36:33.958]    - tweaked: FALSE
[13:36:33.958]    - call: NULL
[13:36:33.958] plan(): nbrOfWorkers() = 1
[13:36:33.959] plan(): Setting new future strategy stack:
[13:36:33.959] List of future strategies:
[13:36:33.959] 1. sequential:
[13:36:33.959]    - args: function (..., envir = parent.frame())
[13:36:33.959]    - tweaked: FALSE
[13:36:33.959]    - call: plan(strategy)
[13:36:33.959] plan(): nbrOfWorkers() = 1
[13:36:33.959] SequentialFuture started (and completed)
[13:36:33.960] - Launch lazy future ... done
[13:36:33.960] run() for ‘SequentialFuture’ ... done
[13:36:33.961] getGlobalsAndPackages() ...
[13:36:33.961] Searching for globals...
[13:36:33.962] - globals found: [1] ‘{’
[13:36:33.962] Searching for globals ... DONE
[13:36:33.962] Resolving globals: FALSE
[13:36:33.963] 
[13:36:33.963] 
[13:36:33.963] getGlobalsAndPackages() ... DONE
[13:36:33.963] run() for ‘Future’ ...
[13:36:33.963] - state: ‘created’
[13:36:33.964] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.964]   - Field: ‘label’
[13:36:33.964]   - Field: ‘local’
[13:36:33.964]   - Field: ‘owner’
[13:36:33.964]   - Field: ‘envir’
[13:36:33.964]   - Field: ‘packages’
[13:36:33.964]   - Field: ‘gc’
[13:36:33.964]   - Field: ‘conditions’
[13:36:33.965]   - Field: ‘expr’
[13:36:33.965]   - Field: ‘uuid’
[13:36:33.965]   - Field: ‘seed’
[13:36:33.965]   - Field: ‘version’
[13:36:33.965]   - Field: ‘result’
[13:36:33.965]   - Field: ‘asynchronous’
[13:36:33.965]   - Field: ‘calls’
[13:36:33.965]   - Field: ‘globals’
[13:36:33.965]   - Field: ‘stdout’
[13:36:33.965]   - Field: ‘earlySignal’
[13:36:33.967]   - Field: ‘lazy’
[13:36:33.967]   - Field: ‘state’
[13:36:33.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.967] - Launch lazy future ...
[13:36:33.967] Packages needed by the future expression (n = 0): <none>
[13:36:33.967] Packages needed by future strategies (n = 0): <none>
[13:36:33.968] {
[13:36:33.968]     {
[13:36:33.968]         {
[13:36:33.968]             ...future.startTime <- base::Sys.time()
[13:36:33.968]             {
[13:36:33.968]                 {
[13:36:33.968]                   {
[13:36:33.968]                     base::local({
[13:36:33.968]                       has_future <- base::requireNamespace("future", 
[13:36:33.968]                         quietly = TRUE)
[13:36:33.968]                       if (has_future) {
[13:36:33.968]                         ns <- base::getNamespace("future")
[13:36:33.968]                         version <- ns[[".package"]][["version"]]
[13:36:33.968]                         if (is.null(version)) 
[13:36:33.968]                           version <- utils::packageVersion("future")
[13:36:33.968]                       }
[13:36:33.968]                       else {
[13:36:33.968]                         version <- NULL
[13:36:33.968]                       }
[13:36:33.968]                       if (!has_future || version < "1.8.0") {
[13:36:33.968]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.968]                           "", base::R.version$version.string), 
[13:36:33.968]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.968]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.968]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.968]                             "release", "version")], collapse = " "), 
[13:36:33.968]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.968]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.968]                           info)
[13:36:33.968]                         info <- base::paste(info, collapse = "; ")
[13:36:33.968]                         if (!has_future) {
[13:36:33.968]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.968]                             info)
[13:36:33.968]                         }
[13:36:33.968]                         else {
[13:36:33.968]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.968]                             info, version)
[13:36:33.968]                         }
[13:36:33.968]                         base::stop(msg)
[13:36:33.968]                       }
[13:36:33.968]                     })
[13:36:33.968]                   }
[13:36:33.968]                   ...future.strategy.old <- future::plan("list")
[13:36:33.968]                   options(future.plan = NULL)
[13:36:33.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.968]                 }
[13:36:33.968]                 ...future.workdir <- getwd()
[13:36:33.968]             }
[13:36:33.968]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.968]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.968]         }
[13:36:33.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.968]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.968]             base::names(...future.oldOptions))
[13:36:33.968]     }
[13:36:33.968]     if (FALSE) {
[13:36:33.968]     }
[13:36:33.968]     else {
[13:36:33.968]         if (TRUE) {
[13:36:33.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.968]                 open = "w")
[13:36:33.968]         }
[13:36:33.968]         else {
[13:36:33.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.968]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.968]         }
[13:36:33.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.968]             base::sink(type = "output", split = FALSE)
[13:36:33.968]             base::close(...future.stdout)
[13:36:33.968]         }, add = TRUE)
[13:36:33.968]     }
[13:36:33.968]     ...future.frame <- base::sys.nframe()
[13:36:33.968]     ...future.conditions <- base::list()
[13:36:33.968]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.968]     if (FALSE) {
[13:36:33.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.968]     }
[13:36:33.968]     ...future.result <- base::tryCatch({
[13:36:33.968]         base::withCallingHandlers({
[13:36:33.968]             ...future.value <- base::withVisible(base::local({
[13:36:33.968]                 4
[13:36:33.968]             }))
[13:36:33.968]             future::FutureResult(value = ...future.value$value, 
[13:36:33.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.968]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.968]                     ...future.globalenv.names))
[13:36:33.968]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.968]         }, condition = base::local({
[13:36:33.968]             c <- base::c
[13:36:33.968]             inherits <- base::inherits
[13:36:33.968]             invokeRestart <- base::invokeRestart
[13:36:33.968]             length <- base::length
[13:36:33.968]             list <- base::list
[13:36:33.968]             seq.int <- base::seq.int
[13:36:33.968]             signalCondition <- base::signalCondition
[13:36:33.968]             sys.calls <- base::sys.calls
[13:36:33.968]             `[[` <- base::`[[`
[13:36:33.968]             `+` <- base::`+`
[13:36:33.968]             `<<-` <- base::`<<-`
[13:36:33.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.968]                   3L)]
[13:36:33.968]             }
[13:36:33.968]             function(cond) {
[13:36:33.968]                 is_error <- inherits(cond, "error")
[13:36:33.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.968]                   NULL)
[13:36:33.968]                 if (is_error) {
[13:36:33.968]                   sessionInformation <- function() {
[13:36:33.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.968]                       search = base::search(), system = base::Sys.info())
[13:36:33.968]                   }
[13:36:33.968]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.968]                     cond$call), session = sessionInformation(), 
[13:36:33.968]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.968]                   signalCondition(cond)
[13:36:33.968]                 }
[13:36:33.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.968]                 "immediateCondition"))) {
[13:36:33.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.968]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.968]                   if (TRUE && !signal) {
[13:36:33.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.968]                     {
[13:36:33.968]                       inherits <- base::inherits
[13:36:33.968]                       invokeRestart <- base::invokeRestart
[13:36:33.968]                       is.null <- base::is.null
[13:36:33.968]                       muffled <- FALSE
[13:36:33.968]                       if (inherits(cond, "message")) {
[13:36:33.968]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.968]                         if (muffled) 
[13:36:33.968]                           invokeRestart("muffleMessage")
[13:36:33.968]                       }
[13:36:33.968]                       else if (inherits(cond, "warning")) {
[13:36:33.968]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.968]                         if (muffled) 
[13:36:33.968]                           invokeRestart("muffleWarning")
[13:36:33.968]                       }
[13:36:33.968]                       else if (inherits(cond, "condition")) {
[13:36:33.968]                         if (!is.null(pattern)) {
[13:36:33.968]                           computeRestarts <- base::computeRestarts
[13:36:33.968]                           grepl <- base::grepl
[13:36:33.968]                           restarts <- computeRestarts(cond)
[13:36:33.968]                           for (restart in restarts) {
[13:36:33.968]                             name <- restart$name
[13:36:33.968]                             if (is.null(name)) 
[13:36:33.968]                               next
[13:36:33.968]                             if (!grepl(pattern, name)) 
[13:36:33.968]                               next
[13:36:33.968]                             invokeRestart(restart)
[13:36:33.968]                             muffled <- TRUE
[13:36:33.968]                             break
[13:36:33.968]                           }
[13:36:33.968]                         }
[13:36:33.968]                       }
[13:36:33.968]                       invisible(muffled)
[13:36:33.968]                     }
[13:36:33.968]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.968]                   }
[13:36:33.968]                 }
[13:36:33.968]                 else {
[13:36:33.968]                   if (TRUE) {
[13:36:33.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.968]                     {
[13:36:33.968]                       inherits <- base::inherits
[13:36:33.968]                       invokeRestart <- base::invokeRestart
[13:36:33.968]                       is.null <- base::is.null
[13:36:33.968]                       muffled <- FALSE
[13:36:33.968]                       if (inherits(cond, "message")) {
[13:36:33.968]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.968]                         if (muffled) 
[13:36:33.968]                           invokeRestart("muffleMessage")
[13:36:33.968]                       }
[13:36:33.968]                       else if (inherits(cond, "warning")) {
[13:36:33.968]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.968]                         if (muffled) 
[13:36:33.968]                           invokeRestart("muffleWarning")
[13:36:33.968]                       }
[13:36:33.968]                       else if (inherits(cond, "condition")) {
[13:36:33.968]                         if (!is.null(pattern)) {
[13:36:33.968]                           computeRestarts <- base::computeRestarts
[13:36:33.968]                           grepl <- base::grepl
[13:36:33.968]                           restarts <- computeRestarts(cond)
[13:36:33.968]                           for (restart in restarts) {
[13:36:33.968]                             name <- restart$name
[13:36:33.968]                             if (is.null(name)) 
[13:36:33.968]                               next
[13:36:33.968]                             if (!grepl(pattern, name)) 
[13:36:33.968]                               next
[13:36:33.968]                             invokeRestart(restart)
[13:36:33.968]                             muffled <- TRUE
[13:36:33.968]                             break
[13:36:33.968]                           }
[13:36:33.968]                         }
[13:36:33.968]                       }
[13:36:33.968]                       invisible(muffled)
[13:36:33.968]                     }
[13:36:33.968]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.968]                   }
[13:36:33.968]                 }
[13:36:33.968]             }
[13:36:33.968]         }))
[13:36:33.968]     }, error = function(ex) {
[13:36:33.968]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.968]                 ...future.rng), started = ...future.startTime, 
[13:36:33.968]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.968]             version = "1.8"), class = "FutureResult")
[13:36:33.968]     }, finally = {
[13:36:33.968]         if (!identical(...future.workdir, getwd())) 
[13:36:33.968]             setwd(...future.workdir)
[13:36:33.968]         {
[13:36:33.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.968]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.968]             }
[13:36:33.968]             base::options(...future.oldOptions)
[13:36:33.968]             if (.Platform$OS.type == "windows") {
[13:36:33.968]                 old_names <- names(...future.oldEnvVars)
[13:36:33.968]                 envs <- base::Sys.getenv()
[13:36:33.968]                 names <- names(envs)
[13:36:33.968]                 common <- intersect(names, old_names)
[13:36:33.968]                 added <- setdiff(names, old_names)
[13:36:33.968]                 removed <- setdiff(old_names, names)
[13:36:33.968]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.968]                   envs[common]]
[13:36:33.968]                 NAMES <- toupper(changed)
[13:36:33.968]                 args <- list()
[13:36:33.968]                 for (kk in seq_along(NAMES)) {
[13:36:33.968]                   name <- changed[[kk]]
[13:36:33.968]                   NAME <- NAMES[[kk]]
[13:36:33.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.968]                     next
[13:36:33.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.968]                 }
[13:36:33.968]                 NAMES <- toupper(added)
[13:36:33.968]                 for (kk in seq_along(NAMES)) {
[13:36:33.968]                   name <- added[[kk]]
[13:36:33.968]                   NAME <- NAMES[[kk]]
[13:36:33.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.968]                     next
[13:36:33.968]                   args[[name]] <- ""
[13:36:33.968]                 }
[13:36:33.968]                 NAMES <- toupper(removed)
[13:36:33.968]                 for (kk in seq_along(NAMES)) {
[13:36:33.968]                   name <- removed[[kk]]
[13:36:33.968]                   NAME <- NAMES[[kk]]
[13:36:33.968]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.968]                     next
[13:36:33.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.968]                 }
[13:36:33.968]                 if (length(args) > 0) 
[13:36:33.968]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.968]             }
[13:36:33.968]             else {
[13:36:33.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.968]             }
[13:36:33.968]             {
[13:36:33.968]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.968]                   0L) {
[13:36:33.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.968]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.968]                   base::options(opts)
[13:36:33.968]                 }
[13:36:33.968]                 {
[13:36:33.968]                   {
[13:36:33.968]                     NULL
[13:36:33.968]                     RNGkind("Mersenne-Twister")
[13:36:33.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.968]                       inherits = FALSE)
[13:36:33.968]                   }
[13:36:33.968]                   options(future.plan = NULL)
[13:36:33.968]                   if (is.na(NA_character_)) 
[13:36:33.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.968]                     .init = FALSE)
[13:36:33.968]                 }
[13:36:33.968]             }
[13:36:33.968]         }
[13:36:33.968]     })
[13:36:33.968]     if (TRUE) {
[13:36:33.968]         base::sink(type = "output", split = FALSE)
[13:36:33.968]         if (TRUE) {
[13:36:33.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.968]         }
[13:36:33.968]         else {
[13:36:33.968]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.968]         }
[13:36:33.968]         base::close(...future.stdout)
[13:36:33.968]         ...future.stdout <- NULL
[13:36:33.968]     }
[13:36:33.968]     ...future.result$conditions <- ...future.conditions
[13:36:33.968]     ...future.result$finished <- base::Sys.time()
[13:36:33.968]     ...future.result
[13:36:33.968] }
[13:36:33.969] plan(): Setting new future strategy stack:
[13:36:33.969] List of future strategies:
[13:36:33.969] 1. sequential:
[13:36:33.969]    - args: function (..., envir = parent.frame())
[13:36:33.969]    - tweaked: FALSE
[13:36:33.969]    - call: NULL
[13:36:33.970] plan(): nbrOfWorkers() = 1
[13:36:33.970] plan(): Setting new future strategy stack:
[13:36:33.971] List of future strategies:
[13:36:33.971] 1. sequential:
[13:36:33.971]    - args: function (..., envir = parent.frame())
[13:36:33.971]    - tweaked: FALSE
[13:36:33.971]    - call: plan(strategy)
[13:36:33.971] plan(): nbrOfWorkers() = 1
[13:36:33.971] SequentialFuture started (and completed)
[13:36:33.971] - Launch lazy future ... done
[13:36:33.971] run() for ‘SequentialFuture’ ... done
<environment: 0x564a719b3450> 
<environment: 0x564a71333d68> 
[13:36:33.973] resolved() for ‘SequentialFuture’ ...
[13:36:33.973] - state: ‘finished’
[13:36:33.973] - run: TRUE
[13:36:33.973] - result: ‘FutureResult’
[13:36:33.973] resolved() for ‘SequentialFuture’ ... done
[13:36:33.973] resolved() for ‘SequentialFuture’ ...
[13:36:33.973] - state: ‘finished’
[13:36:33.973] - run: TRUE
[13:36:33.973] - result: ‘FutureResult’
[13:36:33.973] resolved() for ‘SequentialFuture’ ... done
[13:36:33.974] resolved() for ‘SequentialFuture’ ...
[13:36:33.974] - state: ‘finished’
[13:36:33.974] - run: TRUE
[13:36:33.974] - result: ‘FutureResult’
[13:36:33.974] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:33.975] resolve() on environment ...
[13:36:33.975]  recursive: 0
[13:36:33.976]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:33.976] signalConditionsASAP(numeric, pos=1) ...
[13:36:33.976] - nx: 4
[13:36:33.976] - relay: TRUE
[13:36:33.976] - stdout: TRUE
[13:36:33.976] - signal: TRUE
[13:36:33.976] - resignal: FALSE
[13:36:33.976] - force: TRUE
[13:36:33.977] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:33.977] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:33.977]  - until=2
[13:36:33.977]  - relaying element #2
[13:36:33.977] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:33.977] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:33.977] signalConditionsASAP(NULL, pos=1) ... done
[13:36:33.977]  length: 3 (resolved future 1)
[13:36:33.977] resolved() for ‘SequentialFuture’ ...
[13:36:33.977] - state: ‘finished’
[13:36:33.978] - run: TRUE
[13:36:33.978] - result: ‘FutureResult’
[13:36:33.978] resolved() for ‘SequentialFuture’ ... done
[13:36:33.978] Future #2
[13:36:33.978] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:33.978] - nx: 4
[13:36:33.978] - relay: TRUE
[13:36:33.978] - stdout: TRUE
[13:36:33.978] - signal: TRUE
[13:36:33.978] - resignal: FALSE
[13:36:33.978] - force: TRUE
[13:36:33.979] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:33.979] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:33.979]  - until=2
[13:36:33.979]  - relaying element #2
[13:36:33.979] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:33.979] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:33.979] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:33.979]  length: 2 (resolved future 2)
[13:36:33.979] resolved() for ‘SequentialFuture’ ...
[13:36:33.979] - state: ‘finished’
[13:36:33.980] - run: TRUE
[13:36:33.980] - result: ‘FutureResult’
[13:36:33.980] resolved() for ‘SequentialFuture’ ... done
[13:36:33.980] Future #3
[13:36:33.980] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:33.980] - nx: 4
[13:36:33.980] - relay: TRUE
[13:36:33.980] - stdout: TRUE
[13:36:33.980] - signal: TRUE
[13:36:33.980] - resignal: FALSE
[13:36:33.980] - force: TRUE
[13:36:33.981] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:33.981] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:33.981]  - until=3
[13:36:33.981]  - relaying element #3
[13:36:33.981] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:33.981] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:33.981] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:33.981]  length: 1 (resolved future 3)
[13:36:33.981] resolved() for ‘SequentialFuture’ ...
[13:36:33.981] - state: ‘finished’
[13:36:33.982] - run: TRUE
[13:36:33.982] - result: ‘FutureResult’
[13:36:33.982] resolved() for ‘SequentialFuture’ ... done
[13:36:33.982] Future #4
[13:36:33.982] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:33.982] - nx: 4
[13:36:33.982] - relay: TRUE
[13:36:33.982] - stdout: TRUE
[13:36:33.982] - signal: TRUE
[13:36:33.982] - resignal: FALSE
[13:36:33.982] - force: TRUE
[13:36:33.982] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:33.983] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:33.983]  - until=4
[13:36:33.983]  - relaying element #4
[13:36:33.983] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:33.983] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:33.983] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:33.983]  length: 0 (resolved future 4)
[13:36:33.983] Relaying remaining futures
[13:36:33.983] signalConditionsASAP(NULL, pos=0) ...
[13:36:33.983] - nx: 4
[13:36:33.984] - relay: TRUE
[13:36:33.984] - stdout: TRUE
[13:36:33.984] - signal: TRUE
[13:36:33.984] - resignal: FALSE
[13:36:33.984] - force: TRUE
[13:36:33.984] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:33.984] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:33.984] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:33.984] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:33.984] signalConditionsASAP(NULL, pos=0) ... done
[13:36:33.984] resolve() on environment ... DONE
<environment: 0x564a71be9398> 
Dimensions: c(1, 6)
[13:36:33.985] getGlobalsAndPackages() ...
[13:36:33.985] Searching for globals...
[13:36:33.985] 
[13:36:33.985] Searching for globals ... DONE
[13:36:33.985] - globals: [0] <none>
[13:36:33.986] getGlobalsAndPackages() ... DONE
[13:36:33.986] run() for ‘Future’ ...
[13:36:33.986] - state: ‘created’
[13:36:33.986] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.986] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.986]   - Field: ‘label’
[13:36:33.987]   - Field: ‘local’
[13:36:33.987]   - Field: ‘owner’
[13:36:33.987]   - Field: ‘envir’
[13:36:33.987]   - Field: ‘packages’
[13:36:33.987]   - Field: ‘gc’
[13:36:33.987]   - Field: ‘conditions’
[13:36:33.987]   - Field: ‘expr’
[13:36:33.987]   - Field: ‘uuid’
[13:36:33.987]   - Field: ‘seed’
[13:36:33.987]   - Field: ‘version’
[13:36:33.987]   - Field: ‘result’
[13:36:33.988]   - Field: ‘asynchronous’
[13:36:33.988]   - Field: ‘calls’
[13:36:33.988]   - Field: ‘globals’
[13:36:33.988]   - Field: ‘stdout’
[13:36:33.988]   - Field: ‘earlySignal’
[13:36:33.988]   - Field: ‘lazy’
[13:36:33.988]   - Field: ‘state’
[13:36:33.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.988] - Launch lazy future ...
[13:36:33.988] Packages needed by the future expression (n = 0): <none>
[13:36:33.989] Packages needed by future strategies (n = 0): <none>
[13:36:33.989] {
[13:36:33.989]     {
[13:36:33.989]         {
[13:36:33.989]             ...future.startTime <- base::Sys.time()
[13:36:33.989]             {
[13:36:33.989]                 {
[13:36:33.989]                   {
[13:36:33.989]                     base::local({
[13:36:33.989]                       has_future <- base::requireNamespace("future", 
[13:36:33.989]                         quietly = TRUE)
[13:36:33.989]                       if (has_future) {
[13:36:33.989]                         ns <- base::getNamespace("future")
[13:36:33.989]                         version <- ns[[".package"]][["version"]]
[13:36:33.989]                         if (is.null(version)) 
[13:36:33.989]                           version <- utils::packageVersion("future")
[13:36:33.989]                       }
[13:36:33.989]                       else {
[13:36:33.989]                         version <- NULL
[13:36:33.989]                       }
[13:36:33.989]                       if (!has_future || version < "1.8.0") {
[13:36:33.989]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.989]                           "", base::R.version$version.string), 
[13:36:33.989]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.989]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.989]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.989]                             "release", "version")], collapse = " "), 
[13:36:33.989]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.989]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.989]                           info)
[13:36:33.989]                         info <- base::paste(info, collapse = "; ")
[13:36:33.989]                         if (!has_future) {
[13:36:33.989]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.989]                             info)
[13:36:33.989]                         }
[13:36:33.989]                         else {
[13:36:33.989]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.989]                             info, version)
[13:36:33.989]                         }
[13:36:33.989]                         base::stop(msg)
[13:36:33.989]                       }
[13:36:33.989]                     })
[13:36:33.989]                   }
[13:36:33.989]                   ...future.strategy.old <- future::plan("list")
[13:36:33.989]                   options(future.plan = NULL)
[13:36:33.989]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.989]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.989]                 }
[13:36:33.989]                 ...future.workdir <- getwd()
[13:36:33.989]             }
[13:36:33.989]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.989]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.989]         }
[13:36:33.989]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.989]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.989]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.989]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.989]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.989]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.989]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.989]             base::names(...future.oldOptions))
[13:36:33.989]     }
[13:36:33.989]     if (FALSE) {
[13:36:33.989]     }
[13:36:33.989]     else {
[13:36:33.989]         if (TRUE) {
[13:36:33.989]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.989]                 open = "w")
[13:36:33.989]         }
[13:36:33.989]         else {
[13:36:33.989]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.989]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.989]         }
[13:36:33.989]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.989]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.989]             base::sink(type = "output", split = FALSE)
[13:36:33.989]             base::close(...future.stdout)
[13:36:33.989]         }, add = TRUE)
[13:36:33.989]     }
[13:36:33.989]     ...future.frame <- base::sys.nframe()
[13:36:33.989]     ...future.conditions <- base::list()
[13:36:33.989]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.989]     if (FALSE) {
[13:36:33.989]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.989]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.989]     }
[13:36:33.989]     ...future.result <- base::tryCatch({
[13:36:33.989]         base::withCallingHandlers({
[13:36:33.989]             ...future.value <- base::withVisible(base::local(2))
[13:36:33.989]             future::FutureResult(value = ...future.value$value, 
[13:36:33.989]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.989]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.989]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.989]                     ...future.globalenv.names))
[13:36:33.989]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.989]         }, condition = base::local({
[13:36:33.989]             c <- base::c
[13:36:33.989]             inherits <- base::inherits
[13:36:33.989]             invokeRestart <- base::invokeRestart
[13:36:33.989]             length <- base::length
[13:36:33.989]             list <- base::list
[13:36:33.989]             seq.int <- base::seq.int
[13:36:33.989]             signalCondition <- base::signalCondition
[13:36:33.989]             sys.calls <- base::sys.calls
[13:36:33.989]             `[[` <- base::`[[`
[13:36:33.989]             `+` <- base::`+`
[13:36:33.989]             `<<-` <- base::`<<-`
[13:36:33.989]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.989]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.989]                   3L)]
[13:36:33.989]             }
[13:36:33.989]             function(cond) {
[13:36:33.989]                 is_error <- inherits(cond, "error")
[13:36:33.989]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.989]                   NULL)
[13:36:33.989]                 if (is_error) {
[13:36:33.989]                   sessionInformation <- function() {
[13:36:33.989]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.989]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.989]                       search = base::search(), system = base::Sys.info())
[13:36:33.989]                   }
[13:36:33.989]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.989]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.989]                     cond$call), session = sessionInformation(), 
[13:36:33.989]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.989]                   signalCondition(cond)
[13:36:33.989]                 }
[13:36:33.989]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.989]                 "immediateCondition"))) {
[13:36:33.989]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.989]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.989]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.989]                   if (TRUE && !signal) {
[13:36:33.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.989]                     {
[13:36:33.989]                       inherits <- base::inherits
[13:36:33.989]                       invokeRestart <- base::invokeRestart
[13:36:33.989]                       is.null <- base::is.null
[13:36:33.989]                       muffled <- FALSE
[13:36:33.989]                       if (inherits(cond, "message")) {
[13:36:33.989]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.989]                         if (muffled) 
[13:36:33.989]                           invokeRestart("muffleMessage")
[13:36:33.989]                       }
[13:36:33.989]                       else if (inherits(cond, "warning")) {
[13:36:33.989]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.989]                         if (muffled) 
[13:36:33.989]                           invokeRestart("muffleWarning")
[13:36:33.989]                       }
[13:36:33.989]                       else if (inherits(cond, "condition")) {
[13:36:33.989]                         if (!is.null(pattern)) {
[13:36:33.989]                           computeRestarts <- base::computeRestarts
[13:36:33.989]                           grepl <- base::grepl
[13:36:33.989]                           restarts <- computeRestarts(cond)
[13:36:33.989]                           for (restart in restarts) {
[13:36:33.989]                             name <- restart$name
[13:36:33.989]                             if (is.null(name)) 
[13:36:33.989]                               next
[13:36:33.989]                             if (!grepl(pattern, name)) 
[13:36:33.989]                               next
[13:36:33.989]                             invokeRestart(restart)
[13:36:33.989]                             muffled <- TRUE
[13:36:33.989]                             break
[13:36:33.989]                           }
[13:36:33.989]                         }
[13:36:33.989]                       }
[13:36:33.989]                       invisible(muffled)
[13:36:33.989]                     }
[13:36:33.989]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.989]                   }
[13:36:33.989]                 }
[13:36:33.989]                 else {
[13:36:33.989]                   if (TRUE) {
[13:36:33.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.989]                     {
[13:36:33.989]                       inherits <- base::inherits
[13:36:33.989]                       invokeRestart <- base::invokeRestart
[13:36:33.989]                       is.null <- base::is.null
[13:36:33.989]                       muffled <- FALSE
[13:36:33.989]                       if (inherits(cond, "message")) {
[13:36:33.989]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.989]                         if (muffled) 
[13:36:33.989]                           invokeRestart("muffleMessage")
[13:36:33.989]                       }
[13:36:33.989]                       else if (inherits(cond, "warning")) {
[13:36:33.989]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.989]                         if (muffled) 
[13:36:33.989]                           invokeRestart("muffleWarning")
[13:36:33.989]                       }
[13:36:33.989]                       else if (inherits(cond, "condition")) {
[13:36:33.989]                         if (!is.null(pattern)) {
[13:36:33.989]                           computeRestarts <- base::computeRestarts
[13:36:33.989]                           grepl <- base::grepl
[13:36:33.989]                           restarts <- computeRestarts(cond)
[13:36:33.989]                           for (restart in restarts) {
[13:36:33.989]                             name <- restart$name
[13:36:33.989]                             if (is.null(name)) 
[13:36:33.989]                               next
[13:36:33.989]                             if (!grepl(pattern, name)) 
[13:36:33.989]                               next
[13:36:33.989]                             invokeRestart(restart)
[13:36:33.989]                             muffled <- TRUE
[13:36:33.989]                             break
[13:36:33.989]                           }
[13:36:33.989]                         }
[13:36:33.989]                       }
[13:36:33.989]                       invisible(muffled)
[13:36:33.989]                     }
[13:36:33.989]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.989]                   }
[13:36:33.989]                 }
[13:36:33.989]             }
[13:36:33.989]         }))
[13:36:33.989]     }, error = function(ex) {
[13:36:33.989]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.989]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.989]                 ...future.rng), started = ...future.startTime, 
[13:36:33.989]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.989]             version = "1.8"), class = "FutureResult")
[13:36:33.989]     }, finally = {
[13:36:33.989]         if (!identical(...future.workdir, getwd())) 
[13:36:33.989]             setwd(...future.workdir)
[13:36:33.989]         {
[13:36:33.989]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.989]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.989]             }
[13:36:33.989]             base::options(...future.oldOptions)
[13:36:33.989]             if (.Platform$OS.type == "windows") {
[13:36:33.989]                 old_names <- names(...future.oldEnvVars)
[13:36:33.989]                 envs <- base::Sys.getenv()
[13:36:33.989]                 names <- names(envs)
[13:36:33.989]                 common <- intersect(names, old_names)
[13:36:33.989]                 added <- setdiff(names, old_names)
[13:36:33.989]                 removed <- setdiff(old_names, names)
[13:36:33.989]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.989]                   envs[common]]
[13:36:33.989]                 NAMES <- toupper(changed)
[13:36:33.989]                 args <- list()
[13:36:33.989]                 for (kk in seq_along(NAMES)) {
[13:36:33.989]                   name <- changed[[kk]]
[13:36:33.989]                   NAME <- NAMES[[kk]]
[13:36:33.989]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.989]                     next
[13:36:33.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.989]                 }
[13:36:33.989]                 NAMES <- toupper(added)
[13:36:33.989]                 for (kk in seq_along(NAMES)) {
[13:36:33.989]                   name <- added[[kk]]
[13:36:33.989]                   NAME <- NAMES[[kk]]
[13:36:33.989]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.989]                     next
[13:36:33.989]                   args[[name]] <- ""
[13:36:33.989]                 }
[13:36:33.989]                 NAMES <- toupper(removed)
[13:36:33.989]                 for (kk in seq_along(NAMES)) {
[13:36:33.989]                   name <- removed[[kk]]
[13:36:33.989]                   NAME <- NAMES[[kk]]
[13:36:33.989]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.989]                     next
[13:36:33.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.989]                 }
[13:36:33.989]                 if (length(args) > 0) 
[13:36:33.989]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.989]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.989]             }
[13:36:33.989]             else {
[13:36:33.989]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.989]             }
[13:36:33.989]             {
[13:36:33.989]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.989]                   0L) {
[13:36:33.989]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.989]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.989]                   base::options(opts)
[13:36:33.989]                 }
[13:36:33.989]                 {
[13:36:33.989]                   {
[13:36:33.989]                     NULL
[13:36:33.989]                     RNGkind("Mersenne-Twister")
[13:36:33.989]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.989]                       inherits = FALSE)
[13:36:33.989]                   }
[13:36:33.989]                   options(future.plan = NULL)
[13:36:33.989]                   if (is.na(NA_character_)) 
[13:36:33.989]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.989]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.989]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.989]                     .init = FALSE)
[13:36:33.989]                 }
[13:36:33.989]             }
[13:36:33.989]         }
[13:36:33.989]     })
[13:36:33.989]     if (TRUE) {
[13:36:33.989]         base::sink(type = "output", split = FALSE)
[13:36:33.989]         if (TRUE) {
[13:36:33.989]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.989]         }
[13:36:33.989]         else {
[13:36:33.989]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.989]         }
[13:36:33.989]         base::close(...future.stdout)
[13:36:33.989]         ...future.stdout <- NULL
[13:36:33.989]     }
[13:36:33.989]     ...future.result$conditions <- ...future.conditions
[13:36:33.989]     ...future.result$finished <- base::Sys.time()
[13:36:33.989]     ...future.result
[13:36:33.989] }
[13:36:33.991] plan(): Setting new future strategy stack:
[13:36:33.991] List of future strategies:
[13:36:33.991] 1. sequential:
[13:36:33.991]    - args: function (..., envir = parent.frame())
[13:36:33.991]    - tweaked: FALSE
[13:36:33.991]    - call: NULL
[13:36:33.991] plan(): nbrOfWorkers() = 1
[13:36:33.992] plan(): Setting new future strategy stack:
[13:36:33.992] List of future strategies:
[13:36:33.992] 1. sequential:
[13:36:33.992]    - args: function (..., envir = parent.frame())
[13:36:33.992]    - tweaked: FALSE
[13:36:33.992]    - call: plan(strategy)
[13:36:33.992] plan(): nbrOfWorkers() = 1
[13:36:33.992] SequentialFuture started (and completed)
[13:36:33.992] - Launch lazy future ... done
[13:36:33.993] run() for ‘SequentialFuture’ ... done
[13:36:33.994] getGlobalsAndPackages() ...
[13:36:33.994] Searching for globals...
[13:36:33.995] 
[13:36:33.995] Searching for globals ... DONE
[13:36:33.995] - globals: [0] <none>
[13:36:33.995] getGlobalsAndPackages() ... DONE
[13:36:33.995] run() for ‘Future’ ...
[13:36:33.995] - state: ‘created’
[13:36:33.995] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:33.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:33.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:33.996]   - Field: ‘label’
[13:36:33.996]   - Field: ‘local’
[13:36:33.996]   - Field: ‘owner’
[13:36:33.996]   - Field: ‘envir’
[13:36:33.996]   - Field: ‘packages’
[13:36:33.996]   - Field: ‘gc’
[13:36:33.996]   - Field: ‘conditions’
[13:36:33.996]   - Field: ‘expr’
[13:36:33.997]   - Field: ‘uuid’
[13:36:33.997]   - Field: ‘seed’
[13:36:33.997]   - Field: ‘version’
[13:36:33.997]   - Field: ‘result’
[13:36:33.997]   - Field: ‘asynchronous’
[13:36:33.997]   - Field: ‘calls’
[13:36:33.997]   - Field: ‘globals’
[13:36:33.997]   - Field: ‘stdout’
[13:36:33.997]   - Field: ‘earlySignal’
[13:36:33.997]   - Field: ‘lazy’
[13:36:33.997]   - Field: ‘state’
[13:36:33.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:33.998] - Launch lazy future ...
[13:36:33.998] Packages needed by the future expression (n = 0): <none>
[13:36:33.998] Packages needed by future strategies (n = 0): <none>
[13:36:33.998] {
[13:36:33.998]     {
[13:36:33.998]         {
[13:36:33.998]             ...future.startTime <- base::Sys.time()
[13:36:33.998]             {
[13:36:33.998]                 {
[13:36:33.998]                   {
[13:36:33.998]                     base::local({
[13:36:33.998]                       has_future <- base::requireNamespace("future", 
[13:36:33.998]                         quietly = TRUE)
[13:36:33.998]                       if (has_future) {
[13:36:33.998]                         ns <- base::getNamespace("future")
[13:36:33.998]                         version <- ns[[".package"]][["version"]]
[13:36:33.998]                         if (is.null(version)) 
[13:36:33.998]                           version <- utils::packageVersion("future")
[13:36:33.998]                       }
[13:36:33.998]                       else {
[13:36:33.998]                         version <- NULL
[13:36:33.998]                       }
[13:36:33.998]                       if (!has_future || version < "1.8.0") {
[13:36:33.998]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:33.998]                           "", base::R.version$version.string), 
[13:36:33.998]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:33.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:33.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:33.998]                             "release", "version")], collapse = " "), 
[13:36:33.998]                           hostname = base::Sys.info()[["nodename"]])
[13:36:33.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:33.998]                           info)
[13:36:33.998]                         info <- base::paste(info, collapse = "; ")
[13:36:33.998]                         if (!has_future) {
[13:36:33.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:33.998]                             info)
[13:36:33.998]                         }
[13:36:33.998]                         else {
[13:36:33.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:33.998]                             info, version)
[13:36:33.998]                         }
[13:36:33.998]                         base::stop(msg)
[13:36:33.998]                       }
[13:36:33.998]                     })
[13:36:33.998]                   }
[13:36:33.998]                   ...future.strategy.old <- future::plan("list")
[13:36:33.998]                   options(future.plan = NULL)
[13:36:33.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:33.998]                 }
[13:36:33.998]                 ...future.workdir <- getwd()
[13:36:33.998]             }
[13:36:33.998]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:33.998]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:33.998]         }
[13:36:33.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:33.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:33.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:33.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:33.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:33.998]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:33.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:33.998]             base::names(...future.oldOptions))
[13:36:33.998]     }
[13:36:33.998]     if (FALSE) {
[13:36:33.998]     }
[13:36:33.998]     else {
[13:36:33.998]         if (TRUE) {
[13:36:33.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:33.998]                 open = "w")
[13:36:33.998]         }
[13:36:33.998]         else {
[13:36:33.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:33.998]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:33.998]         }
[13:36:33.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:33.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:33.998]             base::sink(type = "output", split = FALSE)
[13:36:33.998]             base::close(...future.stdout)
[13:36:33.998]         }, add = TRUE)
[13:36:33.998]     }
[13:36:33.998]     ...future.frame <- base::sys.nframe()
[13:36:33.998]     ...future.conditions <- base::list()
[13:36:33.998]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:33.998]     if (FALSE) {
[13:36:33.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:33.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:33.998]     }
[13:36:33.998]     ...future.result <- base::tryCatch({
[13:36:33.998]         base::withCallingHandlers({
[13:36:33.998]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:33.998]             future::FutureResult(value = ...future.value$value, 
[13:36:33.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.998]                   ...future.rng), globalenv = if (FALSE) 
[13:36:33.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:33.998]                     ...future.globalenv.names))
[13:36:33.998]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:33.998]         }, condition = base::local({
[13:36:33.998]             c <- base::c
[13:36:33.998]             inherits <- base::inherits
[13:36:33.998]             invokeRestart <- base::invokeRestart
[13:36:33.998]             length <- base::length
[13:36:33.998]             list <- base::list
[13:36:33.998]             seq.int <- base::seq.int
[13:36:33.998]             signalCondition <- base::signalCondition
[13:36:33.998]             sys.calls <- base::sys.calls
[13:36:33.998]             `[[` <- base::`[[`
[13:36:33.998]             `+` <- base::`+`
[13:36:33.998]             `<<-` <- base::`<<-`
[13:36:33.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:33.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:33.998]                   3L)]
[13:36:33.998]             }
[13:36:33.998]             function(cond) {
[13:36:33.998]                 is_error <- inherits(cond, "error")
[13:36:33.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:33.998]                   NULL)
[13:36:33.998]                 if (is_error) {
[13:36:33.998]                   sessionInformation <- function() {
[13:36:33.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:33.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:33.998]                       search = base::search(), system = base::Sys.info())
[13:36:33.998]                   }
[13:36:33.998]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:33.998]                     cond$call), session = sessionInformation(), 
[13:36:33.998]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:33.998]                   signalCondition(cond)
[13:36:33.998]                 }
[13:36:33.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:33.998]                 "immediateCondition"))) {
[13:36:33.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:33.998]                   ...future.conditions[[length(...future.conditions) + 
[13:36:33.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:33.998]                   if (TRUE && !signal) {
[13:36:33.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.998]                     {
[13:36:33.998]                       inherits <- base::inherits
[13:36:33.998]                       invokeRestart <- base::invokeRestart
[13:36:33.998]                       is.null <- base::is.null
[13:36:33.998]                       muffled <- FALSE
[13:36:33.998]                       if (inherits(cond, "message")) {
[13:36:33.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.998]                         if (muffled) 
[13:36:33.998]                           invokeRestart("muffleMessage")
[13:36:33.998]                       }
[13:36:33.998]                       else if (inherits(cond, "warning")) {
[13:36:33.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.998]                         if (muffled) 
[13:36:33.998]                           invokeRestart("muffleWarning")
[13:36:33.998]                       }
[13:36:33.998]                       else if (inherits(cond, "condition")) {
[13:36:33.998]                         if (!is.null(pattern)) {
[13:36:33.998]                           computeRestarts <- base::computeRestarts
[13:36:33.998]                           grepl <- base::grepl
[13:36:33.998]                           restarts <- computeRestarts(cond)
[13:36:33.998]                           for (restart in restarts) {
[13:36:33.998]                             name <- restart$name
[13:36:33.998]                             if (is.null(name)) 
[13:36:33.998]                               next
[13:36:33.998]                             if (!grepl(pattern, name)) 
[13:36:33.998]                               next
[13:36:33.998]                             invokeRestart(restart)
[13:36:33.998]                             muffled <- TRUE
[13:36:33.998]                             break
[13:36:33.998]                           }
[13:36:33.998]                         }
[13:36:33.998]                       }
[13:36:33.998]                       invisible(muffled)
[13:36:33.998]                     }
[13:36:33.998]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.998]                   }
[13:36:33.998]                 }
[13:36:33.998]                 else {
[13:36:33.998]                   if (TRUE) {
[13:36:33.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:33.998]                     {
[13:36:33.998]                       inherits <- base::inherits
[13:36:33.998]                       invokeRestart <- base::invokeRestart
[13:36:33.998]                       is.null <- base::is.null
[13:36:33.998]                       muffled <- FALSE
[13:36:33.998]                       if (inherits(cond, "message")) {
[13:36:33.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:33.998]                         if (muffled) 
[13:36:33.998]                           invokeRestart("muffleMessage")
[13:36:33.998]                       }
[13:36:33.998]                       else if (inherits(cond, "warning")) {
[13:36:33.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:33.998]                         if (muffled) 
[13:36:33.998]                           invokeRestart("muffleWarning")
[13:36:33.998]                       }
[13:36:33.998]                       else if (inherits(cond, "condition")) {
[13:36:33.998]                         if (!is.null(pattern)) {
[13:36:33.998]                           computeRestarts <- base::computeRestarts
[13:36:33.998]                           grepl <- base::grepl
[13:36:33.998]                           restarts <- computeRestarts(cond)
[13:36:33.998]                           for (restart in restarts) {
[13:36:33.998]                             name <- restart$name
[13:36:33.998]                             if (is.null(name)) 
[13:36:33.998]                               next
[13:36:33.998]                             if (!grepl(pattern, name)) 
[13:36:33.998]                               next
[13:36:33.998]                             invokeRestart(restart)
[13:36:33.998]                             muffled <- TRUE
[13:36:33.998]                             break
[13:36:33.998]                           }
[13:36:33.998]                         }
[13:36:33.998]                       }
[13:36:33.998]                       invisible(muffled)
[13:36:33.998]                     }
[13:36:33.998]                     muffleCondition(cond, pattern = "^muffle")
[13:36:33.998]                   }
[13:36:33.998]                 }
[13:36:33.998]             }
[13:36:33.998]         }))
[13:36:33.998]     }, error = function(ex) {
[13:36:33.998]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:33.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:33.998]                 ...future.rng), started = ...future.startTime, 
[13:36:33.998]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:33.998]             version = "1.8"), class = "FutureResult")
[13:36:33.998]     }, finally = {
[13:36:33.998]         if (!identical(...future.workdir, getwd())) 
[13:36:33.998]             setwd(...future.workdir)
[13:36:33.998]         {
[13:36:33.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:33.998]                 ...future.oldOptions$nwarnings <- NULL
[13:36:33.998]             }
[13:36:33.998]             base::options(...future.oldOptions)
[13:36:33.998]             if (.Platform$OS.type == "windows") {
[13:36:33.998]                 old_names <- names(...future.oldEnvVars)
[13:36:33.998]                 envs <- base::Sys.getenv()
[13:36:33.998]                 names <- names(envs)
[13:36:33.998]                 common <- intersect(names, old_names)
[13:36:33.998]                 added <- setdiff(names, old_names)
[13:36:33.998]                 removed <- setdiff(old_names, names)
[13:36:33.998]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:33.998]                   envs[common]]
[13:36:33.998]                 NAMES <- toupper(changed)
[13:36:33.998]                 args <- list()
[13:36:33.998]                 for (kk in seq_along(NAMES)) {
[13:36:33.998]                   name <- changed[[kk]]
[13:36:33.998]                   NAME <- NAMES[[kk]]
[13:36:33.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.998]                     next
[13:36:33.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.998]                 }
[13:36:33.998]                 NAMES <- toupper(added)
[13:36:33.998]                 for (kk in seq_along(NAMES)) {
[13:36:33.998]                   name <- added[[kk]]
[13:36:33.998]                   NAME <- NAMES[[kk]]
[13:36:33.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.998]                     next
[13:36:33.998]                   args[[name]] <- ""
[13:36:33.998]                 }
[13:36:33.998]                 NAMES <- toupper(removed)
[13:36:33.998]                 for (kk in seq_along(NAMES)) {
[13:36:33.998]                   name <- removed[[kk]]
[13:36:33.998]                   NAME <- NAMES[[kk]]
[13:36:33.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:33.998]                     next
[13:36:33.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:33.998]                 }
[13:36:33.998]                 if (length(args) > 0) 
[13:36:33.998]                   base::do.call(base::Sys.setenv, args = args)
[13:36:33.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:33.998]             }
[13:36:33.998]             else {
[13:36:33.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:33.998]             }
[13:36:33.998]             {
[13:36:33.998]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:33.998]                   0L) {
[13:36:33.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:33.998]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:33.998]                   base::options(opts)
[13:36:33.998]                 }
[13:36:33.998]                 {
[13:36:33.998]                   {
[13:36:33.998]                     NULL
[13:36:33.998]                     RNGkind("Mersenne-Twister")
[13:36:33.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:33.998]                       inherits = FALSE)
[13:36:33.998]                   }
[13:36:33.998]                   options(future.plan = NULL)
[13:36:33.998]                   if (is.na(NA_character_)) 
[13:36:33.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:33.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:33.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:33.998]                     .init = FALSE)
[13:36:33.998]                 }
[13:36:33.998]             }
[13:36:33.998]         }
[13:36:33.998]     })
[13:36:33.998]     if (TRUE) {
[13:36:33.998]         base::sink(type = "output", split = FALSE)
[13:36:33.998]         if (TRUE) {
[13:36:33.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:33.998]         }
[13:36:33.998]         else {
[13:36:33.998]             ...future.result["stdout"] <- base::list(NULL)
[13:36:33.998]         }
[13:36:33.998]         base::close(...future.stdout)
[13:36:33.998]         ...future.stdout <- NULL
[13:36:33.998]     }
[13:36:33.998]     ...future.result$conditions <- ...future.conditions
[13:36:33.998]     ...future.result$finished <- base::Sys.time()
[13:36:33.998]     ...future.result
[13:36:33.998] }
[13:36:34.000] plan(): Setting new future strategy stack:
[13:36:34.000] List of future strategies:
[13:36:34.000] 1. sequential:
[13:36:34.000]    - args: function (..., envir = parent.frame())
[13:36:34.000]    - tweaked: FALSE
[13:36:34.000]    - call: NULL
[13:36:34.000] plan(): nbrOfWorkers() = 1
[13:36:34.001] plan(): Setting new future strategy stack:
[13:36:34.001] List of future strategies:
[13:36:34.001] 1. sequential:
[13:36:34.001]    - args: function (..., envir = parent.frame())
[13:36:34.001]    - tweaked: FALSE
[13:36:34.001]    - call: plan(strategy)
[13:36:34.002] plan(): nbrOfWorkers() = 1
[13:36:34.002] SequentialFuture started (and completed)
[13:36:34.002] - Launch lazy future ... done
[13:36:34.002] run() for ‘SequentialFuture’ ... done
[13:36:34.002] getGlobalsAndPackages() ...
[13:36:34.002] Searching for globals...
[13:36:34.003] - globals found: [1] ‘{’
[13:36:34.003] Searching for globals ... DONE
[13:36:34.003] Resolving globals: FALSE
[13:36:34.003] 
[13:36:34.003] 
[13:36:34.004] getGlobalsAndPackages() ... DONE
[13:36:34.004] run() for ‘Future’ ...
[13:36:34.004] - state: ‘created’
[13:36:34.004] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.004] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.004]   - Field: ‘label’
[13:36:34.005]   - Field: ‘local’
[13:36:34.005]   - Field: ‘owner’
[13:36:34.005]   - Field: ‘envir’
[13:36:34.005]   - Field: ‘packages’
[13:36:34.005]   - Field: ‘gc’
[13:36:34.005]   - Field: ‘conditions’
[13:36:34.005]   - Field: ‘expr’
[13:36:34.005]   - Field: ‘uuid’
[13:36:34.005]   - Field: ‘seed’
[13:36:34.005]   - Field: ‘version’
[13:36:34.005]   - Field: ‘result’
[13:36:34.006]   - Field: ‘asynchronous’
[13:36:34.006]   - Field: ‘calls’
[13:36:34.006]   - Field: ‘globals’
[13:36:34.006]   - Field: ‘stdout’
[13:36:34.006]   - Field: ‘earlySignal’
[13:36:34.006]   - Field: ‘lazy’
[13:36:34.006]   - Field: ‘state’
[13:36:34.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.006] - Launch lazy future ...
[13:36:34.006] Packages needed by the future expression (n = 0): <none>
[13:36:34.007] Packages needed by future strategies (n = 0): <none>
[13:36:34.007] {
[13:36:34.007]     {
[13:36:34.007]         {
[13:36:34.007]             ...future.startTime <- base::Sys.time()
[13:36:34.007]             {
[13:36:34.007]                 {
[13:36:34.007]                   {
[13:36:34.007]                     base::local({
[13:36:34.007]                       has_future <- base::requireNamespace("future", 
[13:36:34.007]                         quietly = TRUE)
[13:36:34.007]                       if (has_future) {
[13:36:34.007]                         ns <- base::getNamespace("future")
[13:36:34.007]                         version <- ns[[".package"]][["version"]]
[13:36:34.007]                         if (is.null(version)) 
[13:36:34.007]                           version <- utils::packageVersion("future")
[13:36:34.007]                       }
[13:36:34.007]                       else {
[13:36:34.007]                         version <- NULL
[13:36:34.007]                       }
[13:36:34.007]                       if (!has_future || version < "1.8.0") {
[13:36:34.007]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.007]                           "", base::R.version$version.string), 
[13:36:34.007]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.007]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.007]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.007]                             "release", "version")], collapse = " "), 
[13:36:34.007]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.007]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.007]                           info)
[13:36:34.007]                         info <- base::paste(info, collapse = "; ")
[13:36:34.007]                         if (!has_future) {
[13:36:34.007]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.007]                             info)
[13:36:34.007]                         }
[13:36:34.007]                         else {
[13:36:34.007]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.007]                             info, version)
[13:36:34.007]                         }
[13:36:34.007]                         base::stop(msg)
[13:36:34.007]                       }
[13:36:34.007]                     })
[13:36:34.007]                   }
[13:36:34.007]                   ...future.strategy.old <- future::plan("list")
[13:36:34.007]                   options(future.plan = NULL)
[13:36:34.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.007]                 }
[13:36:34.007]                 ...future.workdir <- getwd()
[13:36:34.007]             }
[13:36:34.007]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.007]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.007]         }
[13:36:34.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.007]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.007]             base::names(...future.oldOptions))
[13:36:34.007]     }
[13:36:34.007]     if (FALSE) {
[13:36:34.007]     }
[13:36:34.007]     else {
[13:36:34.007]         if (TRUE) {
[13:36:34.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.007]                 open = "w")
[13:36:34.007]         }
[13:36:34.007]         else {
[13:36:34.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.007]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.007]         }
[13:36:34.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.007]             base::sink(type = "output", split = FALSE)
[13:36:34.007]             base::close(...future.stdout)
[13:36:34.007]         }, add = TRUE)
[13:36:34.007]     }
[13:36:34.007]     ...future.frame <- base::sys.nframe()
[13:36:34.007]     ...future.conditions <- base::list()
[13:36:34.007]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.007]     if (FALSE) {
[13:36:34.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.007]     }
[13:36:34.007]     ...future.result <- base::tryCatch({
[13:36:34.007]         base::withCallingHandlers({
[13:36:34.007]             ...future.value <- base::withVisible(base::local({
[13:36:34.007]                 4
[13:36:34.007]             }))
[13:36:34.007]             future::FutureResult(value = ...future.value$value, 
[13:36:34.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.007]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.007]                     ...future.globalenv.names))
[13:36:34.007]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.007]         }, condition = base::local({
[13:36:34.007]             c <- base::c
[13:36:34.007]             inherits <- base::inherits
[13:36:34.007]             invokeRestart <- base::invokeRestart
[13:36:34.007]             length <- base::length
[13:36:34.007]             list <- base::list
[13:36:34.007]             seq.int <- base::seq.int
[13:36:34.007]             signalCondition <- base::signalCondition
[13:36:34.007]             sys.calls <- base::sys.calls
[13:36:34.007]             `[[` <- base::`[[`
[13:36:34.007]             `+` <- base::`+`
[13:36:34.007]             `<<-` <- base::`<<-`
[13:36:34.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.007]                   3L)]
[13:36:34.007]             }
[13:36:34.007]             function(cond) {
[13:36:34.007]                 is_error <- inherits(cond, "error")
[13:36:34.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.007]                   NULL)
[13:36:34.007]                 if (is_error) {
[13:36:34.007]                   sessionInformation <- function() {
[13:36:34.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.007]                       search = base::search(), system = base::Sys.info())
[13:36:34.007]                   }
[13:36:34.007]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.007]                     cond$call), session = sessionInformation(), 
[13:36:34.007]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.007]                   signalCondition(cond)
[13:36:34.007]                 }
[13:36:34.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.007]                 "immediateCondition"))) {
[13:36:34.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.007]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.007]                   if (TRUE && !signal) {
[13:36:34.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.007]                     {
[13:36:34.007]                       inherits <- base::inherits
[13:36:34.007]                       invokeRestart <- base::invokeRestart
[13:36:34.007]                       is.null <- base::is.null
[13:36:34.007]                       muffled <- FALSE
[13:36:34.007]                       if (inherits(cond, "message")) {
[13:36:34.007]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.007]                         if (muffled) 
[13:36:34.007]                           invokeRestart("muffleMessage")
[13:36:34.007]                       }
[13:36:34.007]                       else if (inherits(cond, "warning")) {
[13:36:34.007]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.007]                         if (muffled) 
[13:36:34.007]                           invokeRestart("muffleWarning")
[13:36:34.007]                       }
[13:36:34.007]                       else if (inherits(cond, "condition")) {
[13:36:34.007]                         if (!is.null(pattern)) {
[13:36:34.007]                           computeRestarts <- base::computeRestarts
[13:36:34.007]                           grepl <- base::grepl
[13:36:34.007]                           restarts <- computeRestarts(cond)
[13:36:34.007]                           for (restart in restarts) {
[13:36:34.007]                             name <- restart$name
[13:36:34.007]                             if (is.null(name)) 
[13:36:34.007]                               next
[13:36:34.007]                             if (!grepl(pattern, name)) 
[13:36:34.007]                               next
[13:36:34.007]                             invokeRestart(restart)
[13:36:34.007]                             muffled <- TRUE
[13:36:34.007]                             break
[13:36:34.007]                           }
[13:36:34.007]                         }
[13:36:34.007]                       }
[13:36:34.007]                       invisible(muffled)
[13:36:34.007]                     }
[13:36:34.007]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.007]                   }
[13:36:34.007]                 }
[13:36:34.007]                 else {
[13:36:34.007]                   if (TRUE) {
[13:36:34.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.007]                     {
[13:36:34.007]                       inherits <- base::inherits
[13:36:34.007]                       invokeRestart <- base::invokeRestart
[13:36:34.007]                       is.null <- base::is.null
[13:36:34.007]                       muffled <- FALSE
[13:36:34.007]                       if (inherits(cond, "message")) {
[13:36:34.007]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.007]                         if (muffled) 
[13:36:34.007]                           invokeRestart("muffleMessage")
[13:36:34.007]                       }
[13:36:34.007]                       else if (inherits(cond, "warning")) {
[13:36:34.007]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.007]                         if (muffled) 
[13:36:34.007]                           invokeRestart("muffleWarning")
[13:36:34.007]                       }
[13:36:34.007]                       else if (inherits(cond, "condition")) {
[13:36:34.007]                         if (!is.null(pattern)) {
[13:36:34.007]                           computeRestarts <- base::computeRestarts
[13:36:34.007]                           grepl <- base::grepl
[13:36:34.007]                           restarts <- computeRestarts(cond)
[13:36:34.007]                           for (restart in restarts) {
[13:36:34.007]                             name <- restart$name
[13:36:34.007]                             if (is.null(name)) 
[13:36:34.007]                               next
[13:36:34.007]                             if (!grepl(pattern, name)) 
[13:36:34.007]                               next
[13:36:34.007]                             invokeRestart(restart)
[13:36:34.007]                             muffled <- TRUE
[13:36:34.007]                             break
[13:36:34.007]                           }
[13:36:34.007]                         }
[13:36:34.007]                       }
[13:36:34.007]                       invisible(muffled)
[13:36:34.007]                     }
[13:36:34.007]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.007]                   }
[13:36:34.007]                 }
[13:36:34.007]             }
[13:36:34.007]         }))
[13:36:34.007]     }, error = function(ex) {
[13:36:34.007]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.007]                 ...future.rng), started = ...future.startTime, 
[13:36:34.007]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.007]             version = "1.8"), class = "FutureResult")
[13:36:34.007]     }, finally = {
[13:36:34.007]         if (!identical(...future.workdir, getwd())) 
[13:36:34.007]             setwd(...future.workdir)
[13:36:34.007]         {
[13:36:34.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.007]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.007]             }
[13:36:34.007]             base::options(...future.oldOptions)
[13:36:34.007]             if (.Platform$OS.type == "windows") {
[13:36:34.007]                 old_names <- names(...future.oldEnvVars)
[13:36:34.007]                 envs <- base::Sys.getenv()
[13:36:34.007]                 names <- names(envs)
[13:36:34.007]                 common <- intersect(names, old_names)
[13:36:34.007]                 added <- setdiff(names, old_names)
[13:36:34.007]                 removed <- setdiff(old_names, names)
[13:36:34.007]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.007]                   envs[common]]
[13:36:34.007]                 NAMES <- toupper(changed)
[13:36:34.007]                 args <- list()
[13:36:34.007]                 for (kk in seq_along(NAMES)) {
[13:36:34.007]                   name <- changed[[kk]]
[13:36:34.007]                   NAME <- NAMES[[kk]]
[13:36:34.007]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.007]                     next
[13:36:34.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.007]                 }
[13:36:34.007]                 NAMES <- toupper(added)
[13:36:34.007]                 for (kk in seq_along(NAMES)) {
[13:36:34.007]                   name <- added[[kk]]
[13:36:34.007]                   NAME <- NAMES[[kk]]
[13:36:34.007]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.007]                     next
[13:36:34.007]                   args[[name]] <- ""
[13:36:34.007]                 }
[13:36:34.007]                 NAMES <- toupper(removed)
[13:36:34.007]                 for (kk in seq_along(NAMES)) {
[13:36:34.007]                   name <- removed[[kk]]
[13:36:34.007]                   NAME <- NAMES[[kk]]
[13:36:34.007]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.007]                     next
[13:36:34.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.007]                 }
[13:36:34.007]                 if (length(args) > 0) 
[13:36:34.007]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.007]             }
[13:36:34.007]             else {
[13:36:34.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.007]             }
[13:36:34.007]             {
[13:36:34.007]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.007]                   0L) {
[13:36:34.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.007]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.007]                   base::options(opts)
[13:36:34.007]                 }
[13:36:34.007]                 {
[13:36:34.007]                   {
[13:36:34.007]                     NULL
[13:36:34.007]                     RNGkind("Mersenne-Twister")
[13:36:34.007]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.007]                       inherits = FALSE)
[13:36:34.007]                   }
[13:36:34.007]                   options(future.plan = NULL)
[13:36:34.007]                   if (is.na(NA_character_)) 
[13:36:34.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.007]                     .init = FALSE)
[13:36:34.007]                 }
[13:36:34.007]             }
[13:36:34.007]         }
[13:36:34.007]     })
[13:36:34.007]     if (TRUE) {
[13:36:34.007]         base::sink(type = "output", split = FALSE)
[13:36:34.007]         if (TRUE) {
[13:36:34.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.007]         }
[13:36:34.007]         else {
[13:36:34.007]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.007]         }
[13:36:34.007]         base::close(...future.stdout)
[13:36:34.007]         ...future.stdout <- NULL
[13:36:34.007]     }
[13:36:34.007]     ...future.result$conditions <- ...future.conditions
[13:36:34.007]     ...future.result$finished <- base::Sys.time()
[13:36:34.007]     ...future.result
[13:36:34.007] }
[13:36:34.009] plan(): Setting new future strategy stack:
[13:36:34.009] List of future strategies:
[13:36:34.009] 1. sequential:
[13:36:34.009]    - args: function (..., envir = parent.frame())
[13:36:34.009]    - tweaked: FALSE
[13:36:34.009]    - call: NULL
[13:36:34.009] plan(): nbrOfWorkers() = 1
[13:36:34.010] plan(): Setting new future strategy stack:
[13:36:34.010] List of future strategies:
[13:36:34.010] 1. sequential:
[13:36:34.010]    - args: function (..., envir = parent.frame())
[13:36:34.010]    - tweaked: FALSE
[13:36:34.010]    - call: plan(strategy)
[13:36:34.010] plan(): nbrOfWorkers() = 1
[13:36:34.010] SequentialFuture started (and completed)
[13:36:34.010] - Launch lazy future ... done
[13:36:34.011] run() for ‘SequentialFuture’ ... done
<environment: 0x564a732e9ef0> 
<environment: 0x564a730b0b00> 
[13:36:34.012] resolved() for ‘SequentialFuture’ ...
[13:36:34.012] - state: ‘finished’
[13:36:34.012] - run: TRUE
[13:36:34.012] - result: ‘FutureResult’
[13:36:34.012] resolved() for ‘SequentialFuture’ ... done
[13:36:34.012] resolved() for ‘SequentialFuture’ ...
[13:36:34.012] - state: ‘finished’
[13:36:34.012] - run: TRUE
[13:36:34.013] - result: ‘FutureResult’
[13:36:34.013] resolved() for ‘SequentialFuture’ ... done
[13:36:34.013] resolved() for ‘SequentialFuture’ ...
[13:36:34.013] - state: ‘finished’
[13:36:34.013] - run: TRUE
[13:36:34.013] - result: ‘FutureResult’
[13:36:34.013] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:34.014] resolve() on environment ...
[13:36:34.014]  recursive: 0
[13:36:34.015]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:34.015] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.015] - nx: 4
[13:36:34.015] - relay: TRUE
[13:36:34.015] - stdout: TRUE
[13:36:34.015] - signal: TRUE
[13:36:34.015] - resignal: FALSE
[13:36:34.015] - force: TRUE
[13:36:34.015] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.016] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.016]  - until=2
[13:36:34.016]  - relaying element #2
[13:36:34.016] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.016] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.016] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.016]  length: 3 (resolved future 1)
[13:36:34.016] resolved() for ‘SequentialFuture’ ...
[13:36:34.016] - state: ‘finished’
[13:36:34.016] - run: TRUE
[13:36:34.016] - result: ‘FutureResult’
[13:36:34.017] resolved() for ‘SequentialFuture’ ... done
[13:36:34.017] Future #2
[13:36:34.017] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.017] - nx: 4
[13:36:34.017] - relay: TRUE
[13:36:34.017] - stdout: TRUE
[13:36:34.017] - signal: TRUE
[13:36:34.017] - resignal: FALSE
[13:36:34.017] - force: TRUE
[13:36:34.017] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.017] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.018]  - until=2
[13:36:34.018]  - relaying element #2
[13:36:34.018] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.018] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.018] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.018]  length: 2 (resolved future 2)
[13:36:34.018] resolved() for ‘SequentialFuture’ ...
[13:36:34.018] - state: ‘finished’
[13:36:34.018] - run: TRUE
[13:36:34.018] - result: ‘FutureResult’
[13:36:34.019] resolved() for ‘SequentialFuture’ ... done
[13:36:34.019] Future #3
[13:36:34.019] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.019] - nx: 4
[13:36:34.019] - relay: TRUE
[13:36:34.019] - stdout: TRUE
[13:36:34.019] - signal: TRUE
[13:36:34.019] - resignal: FALSE
[13:36:34.019] - force: TRUE
[13:36:34.019] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.019] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.020]  - until=3
[13:36:34.020]  - relaying element #3
[13:36:34.021] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.021] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.021] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.022]  length: 1 (resolved future 3)
[13:36:34.022] resolved() for ‘SequentialFuture’ ...
[13:36:34.022] - state: ‘finished’
[13:36:34.022] - run: TRUE
[13:36:34.022] - result: ‘FutureResult’
[13:36:34.022] resolved() for ‘SequentialFuture’ ... done
[13:36:34.022] Future #4
[13:36:34.022] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.022] - nx: 4
[13:36:34.022] - relay: TRUE
[13:36:34.023] - stdout: TRUE
[13:36:34.023] - signal: TRUE
[13:36:34.023] - resignal: FALSE
[13:36:34.023] - force: TRUE
[13:36:34.023] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.023] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.023]  - until=4
[13:36:34.023]  - relaying element #4
[13:36:34.023] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.023] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.024] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.024]  length: 0 (resolved future 4)
[13:36:34.024] Relaying remaining futures
[13:36:34.024] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.024] - nx: 4
[13:36:34.024] - relay: TRUE
[13:36:34.024] - stdout: TRUE
[13:36:34.024] - signal: TRUE
[13:36:34.024] - resignal: FALSE
[13:36:34.024] - force: TRUE
[13:36:34.024] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.024] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:34.025] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.025] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.025] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.025] resolve() on environment ... DONE
<environment: 0x564a732f5ae8> 
Dimensions: c(2, 3)
[13:36:34.025] getGlobalsAndPackages() ...
[13:36:34.025] Searching for globals...
[13:36:34.026] 
[13:36:34.026] Searching for globals ... DONE
[13:36:34.026] - globals: [0] <none>
[13:36:34.026] getGlobalsAndPackages() ... DONE
[13:36:34.026] run() for ‘Future’ ...
[13:36:34.026] - state: ‘created’
[13:36:34.026] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.027] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.027]   - Field: ‘label’
[13:36:34.027]   - Field: ‘local’
[13:36:34.027]   - Field: ‘owner’
[13:36:34.027]   - Field: ‘envir’
[13:36:34.027]   - Field: ‘packages’
[13:36:34.027]   - Field: ‘gc’
[13:36:34.027]   - Field: ‘conditions’
[13:36:34.028]   - Field: ‘expr’
[13:36:34.028]   - Field: ‘uuid’
[13:36:34.028]   - Field: ‘seed’
[13:36:34.028]   - Field: ‘version’
[13:36:34.028]   - Field: ‘result’
[13:36:34.028]   - Field: ‘asynchronous’
[13:36:34.028]   - Field: ‘calls’
[13:36:34.028]   - Field: ‘globals’
[13:36:34.028]   - Field: ‘stdout’
[13:36:34.028]   - Field: ‘earlySignal’
[13:36:34.028]   - Field: ‘lazy’
[13:36:34.029]   - Field: ‘state’
[13:36:34.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.029] - Launch lazy future ...
[13:36:34.029] Packages needed by the future expression (n = 0): <none>
[13:36:34.029] Packages needed by future strategies (n = 0): <none>
[13:36:34.029] {
[13:36:34.029]     {
[13:36:34.029]         {
[13:36:34.029]             ...future.startTime <- base::Sys.time()
[13:36:34.029]             {
[13:36:34.029]                 {
[13:36:34.029]                   {
[13:36:34.029]                     base::local({
[13:36:34.029]                       has_future <- base::requireNamespace("future", 
[13:36:34.029]                         quietly = TRUE)
[13:36:34.029]                       if (has_future) {
[13:36:34.029]                         ns <- base::getNamespace("future")
[13:36:34.029]                         version <- ns[[".package"]][["version"]]
[13:36:34.029]                         if (is.null(version)) 
[13:36:34.029]                           version <- utils::packageVersion("future")
[13:36:34.029]                       }
[13:36:34.029]                       else {
[13:36:34.029]                         version <- NULL
[13:36:34.029]                       }
[13:36:34.029]                       if (!has_future || version < "1.8.0") {
[13:36:34.029]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.029]                           "", base::R.version$version.string), 
[13:36:34.029]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.029]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.029]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.029]                             "release", "version")], collapse = " "), 
[13:36:34.029]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.029]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.029]                           info)
[13:36:34.029]                         info <- base::paste(info, collapse = "; ")
[13:36:34.029]                         if (!has_future) {
[13:36:34.029]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.029]                             info)
[13:36:34.029]                         }
[13:36:34.029]                         else {
[13:36:34.029]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.029]                             info, version)
[13:36:34.029]                         }
[13:36:34.029]                         base::stop(msg)
[13:36:34.029]                       }
[13:36:34.029]                     })
[13:36:34.029]                   }
[13:36:34.029]                   ...future.strategy.old <- future::plan("list")
[13:36:34.029]                   options(future.plan = NULL)
[13:36:34.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.029]                 }
[13:36:34.029]                 ...future.workdir <- getwd()
[13:36:34.029]             }
[13:36:34.029]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.029]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.029]         }
[13:36:34.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.029]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.029]             base::names(...future.oldOptions))
[13:36:34.029]     }
[13:36:34.029]     if (FALSE) {
[13:36:34.029]     }
[13:36:34.029]     else {
[13:36:34.029]         if (TRUE) {
[13:36:34.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.029]                 open = "w")
[13:36:34.029]         }
[13:36:34.029]         else {
[13:36:34.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.029]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.029]         }
[13:36:34.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.029]             base::sink(type = "output", split = FALSE)
[13:36:34.029]             base::close(...future.stdout)
[13:36:34.029]         }, add = TRUE)
[13:36:34.029]     }
[13:36:34.029]     ...future.frame <- base::sys.nframe()
[13:36:34.029]     ...future.conditions <- base::list()
[13:36:34.029]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.029]     if (FALSE) {
[13:36:34.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.029]     }
[13:36:34.029]     ...future.result <- base::tryCatch({
[13:36:34.029]         base::withCallingHandlers({
[13:36:34.029]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.029]             future::FutureResult(value = ...future.value$value, 
[13:36:34.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.029]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.029]                     ...future.globalenv.names))
[13:36:34.029]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.029]         }, condition = base::local({
[13:36:34.029]             c <- base::c
[13:36:34.029]             inherits <- base::inherits
[13:36:34.029]             invokeRestart <- base::invokeRestart
[13:36:34.029]             length <- base::length
[13:36:34.029]             list <- base::list
[13:36:34.029]             seq.int <- base::seq.int
[13:36:34.029]             signalCondition <- base::signalCondition
[13:36:34.029]             sys.calls <- base::sys.calls
[13:36:34.029]             `[[` <- base::`[[`
[13:36:34.029]             `+` <- base::`+`
[13:36:34.029]             `<<-` <- base::`<<-`
[13:36:34.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.029]                   3L)]
[13:36:34.029]             }
[13:36:34.029]             function(cond) {
[13:36:34.029]                 is_error <- inherits(cond, "error")
[13:36:34.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.029]                   NULL)
[13:36:34.029]                 if (is_error) {
[13:36:34.029]                   sessionInformation <- function() {
[13:36:34.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.029]                       search = base::search(), system = base::Sys.info())
[13:36:34.029]                   }
[13:36:34.029]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.029]                     cond$call), session = sessionInformation(), 
[13:36:34.029]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.029]                   signalCondition(cond)
[13:36:34.029]                 }
[13:36:34.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.029]                 "immediateCondition"))) {
[13:36:34.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.029]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.029]                   if (TRUE && !signal) {
[13:36:34.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.029]                     {
[13:36:34.029]                       inherits <- base::inherits
[13:36:34.029]                       invokeRestart <- base::invokeRestart
[13:36:34.029]                       is.null <- base::is.null
[13:36:34.029]                       muffled <- FALSE
[13:36:34.029]                       if (inherits(cond, "message")) {
[13:36:34.029]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.029]                         if (muffled) 
[13:36:34.029]                           invokeRestart("muffleMessage")
[13:36:34.029]                       }
[13:36:34.029]                       else if (inherits(cond, "warning")) {
[13:36:34.029]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.029]                         if (muffled) 
[13:36:34.029]                           invokeRestart("muffleWarning")
[13:36:34.029]                       }
[13:36:34.029]                       else if (inherits(cond, "condition")) {
[13:36:34.029]                         if (!is.null(pattern)) {
[13:36:34.029]                           computeRestarts <- base::computeRestarts
[13:36:34.029]                           grepl <- base::grepl
[13:36:34.029]                           restarts <- computeRestarts(cond)
[13:36:34.029]                           for (restart in restarts) {
[13:36:34.029]                             name <- restart$name
[13:36:34.029]                             if (is.null(name)) 
[13:36:34.029]                               next
[13:36:34.029]                             if (!grepl(pattern, name)) 
[13:36:34.029]                               next
[13:36:34.029]                             invokeRestart(restart)
[13:36:34.029]                             muffled <- TRUE
[13:36:34.029]                             break
[13:36:34.029]                           }
[13:36:34.029]                         }
[13:36:34.029]                       }
[13:36:34.029]                       invisible(muffled)
[13:36:34.029]                     }
[13:36:34.029]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.029]                   }
[13:36:34.029]                 }
[13:36:34.029]                 else {
[13:36:34.029]                   if (TRUE) {
[13:36:34.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.029]                     {
[13:36:34.029]                       inherits <- base::inherits
[13:36:34.029]                       invokeRestart <- base::invokeRestart
[13:36:34.029]                       is.null <- base::is.null
[13:36:34.029]                       muffled <- FALSE
[13:36:34.029]                       if (inherits(cond, "message")) {
[13:36:34.029]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.029]                         if (muffled) 
[13:36:34.029]                           invokeRestart("muffleMessage")
[13:36:34.029]                       }
[13:36:34.029]                       else if (inherits(cond, "warning")) {
[13:36:34.029]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.029]                         if (muffled) 
[13:36:34.029]                           invokeRestart("muffleWarning")
[13:36:34.029]                       }
[13:36:34.029]                       else if (inherits(cond, "condition")) {
[13:36:34.029]                         if (!is.null(pattern)) {
[13:36:34.029]                           computeRestarts <- base::computeRestarts
[13:36:34.029]                           grepl <- base::grepl
[13:36:34.029]                           restarts <- computeRestarts(cond)
[13:36:34.029]                           for (restart in restarts) {
[13:36:34.029]                             name <- restart$name
[13:36:34.029]                             if (is.null(name)) 
[13:36:34.029]                               next
[13:36:34.029]                             if (!grepl(pattern, name)) 
[13:36:34.029]                               next
[13:36:34.029]                             invokeRestart(restart)
[13:36:34.029]                             muffled <- TRUE
[13:36:34.029]                             break
[13:36:34.029]                           }
[13:36:34.029]                         }
[13:36:34.029]                       }
[13:36:34.029]                       invisible(muffled)
[13:36:34.029]                     }
[13:36:34.029]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.029]                   }
[13:36:34.029]                 }
[13:36:34.029]             }
[13:36:34.029]         }))
[13:36:34.029]     }, error = function(ex) {
[13:36:34.029]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.029]                 ...future.rng), started = ...future.startTime, 
[13:36:34.029]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.029]             version = "1.8"), class = "FutureResult")
[13:36:34.029]     }, finally = {
[13:36:34.029]         if (!identical(...future.workdir, getwd())) 
[13:36:34.029]             setwd(...future.workdir)
[13:36:34.029]         {
[13:36:34.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.029]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.029]             }
[13:36:34.029]             base::options(...future.oldOptions)
[13:36:34.029]             if (.Platform$OS.type == "windows") {
[13:36:34.029]                 old_names <- names(...future.oldEnvVars)
[13:36:34.029]                 envs <- base::Sys.getenv()
[13:36:34.029]                 names <- names(envs)
[13:36:34.029]                 common <- intersect(names, old_names)
[13:36:34.029]                 added <- setdiff(names, old_names)
[13:36:34.029]                 removed <- setdiff(old_names, names)
[13:36:34.029]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.029]                   envs[common]]
[13:36:34.029]                 NAMES <- toupper(changed)
[13:36:34.029]                 args <- list()
[13:36:34.029]                 for (kk in seq_along(NAMES)) {
[13:36:34.029]                   name <- changed[[kk]]
[13:36:34.029]                   NAME <- NAMES[[kk]]
[13:36:34.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.029]                     next
[13:36:34.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.029]                 }
[13:36:34.029]                 NAMES <- toupper(added)
[13:36:34.029]                 for (kk in seq_along(NAMES)) {
[13:36:34.029]                   name <- added[[kk]]
[13:36:34.029]                   NAME <- NAMES[[kk]]
[13:36:34.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.029]                     next
[13:36:34.029]                   args[[name]] <- ""
[13:36:34.029]                 }
[13:36:34.029]                 NAMES <- toupper(removed)
[13:36:34.029]                 for (kk in seq_along(NAMES)) {
[13:36:34.029]                   name <- removed[[kk]]
[13:36:34.029]                   NAME <- NAMES[[kk]]
[13:36:34.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.029]                     next
[13:36:34.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.029]                 }
[13:36:34.029]                 if (length(args) > 0) 
[13:36:34.029]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.029]             }
[13:36:34.029]             else {
[13:36:34.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.029]             }
[13:36:34.029]             {
[13:36:34.029]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.029]                   0L) {
[13:36:34.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.029]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.029]                   base::options(opts)
[13:36:34.029]                 }
[13:36:34.029]                 {
[13:36:34.029]                   {
[13:36:34.029]                     NULL
[13:36:34.029]                     RNGkind("Mersenne-Twister")
[13:36:34.029]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.029]                       inherits = FALSE)
[13:36:34.029]                   }
[13:36:34.029]                   options(future.plan = NULL)
[13:36:34.029]                   if (is.na(NA_character_)) 
[13:36:34.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.029]                     .init = FALSE)
[13:36:34.029]                 }
[13:36:34.029]             }
[13:36:34.029]         }
[13:36:34.029]     })
[13:36:34.029]     if (TRUE) {
[13:36:34.029]         base::sink(type = "output", split = FALSE)
[13:36:34.029]         if (TRUE) {
[13:36:34.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.029]         }
[13:36:34.029]         else {
[13:36:34.029]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.029]         }
[13:36:34.029]         base::close(...future.stdout)
[13:36:34.029]         ...future.stdout <- NULL
[13:36:34.029]     }
[13:36:34.029]     ...future.result$conditions <- ...future.conditions
[13:36:34.029]     ...future.result$finished <- base::Sys.time()
[13:36:34.029]     ...future.result
[13:36:34.029] }
[13:36:34.031] plan(): Setting new future strategy stack:
[13:36:34.031] List of future strategies:
[13:36:34.031] 1. sequential:
[13:36:34.031]    - args: function (..., envir = parent.frame())
[13:36:34.031]    - tweaked: FALSE
[13:36:34.031]    - call: NULL
[13:36:34.031] plan(): nbrOfWorkers() = 1
[13:36:34.032] plan(): Setting new future strategy stack:
[13:36:34.032] List of future strategies:
[13:36:34.032] 1. sequential:
[13:36:34.032]    - args: function (..., envir = parent.frame())
[13:36:34.032]    - tweaked: FALSE
[13:36:34.032]    - call: plan(strategy)
[13:36:34.033] plan(): nbrOfWorkers() = 1
[13:36:34.033] SequentialFuture started (and completed)
[13:36:34.033] - Launch lazy future ... done
[13:36:34.033] run() for ‘SequentialFuture’ ... done
[13:36:34.033] getGlobalsAndPackages() ...
[13:36:34.033] Searching for globals...
[13:36:34.033] 
[13:36:34.033] Searching for globals ... DONE
[13:36:34.034] - globals: [0] <none>
[13:36:34.034] getGlobalsAndPackages() ... DONE
[13:36:34.034] run() for ‘Future’ ...
[13:36:34.034] - state: ‘created’
[13:36:34.034] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.034] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.035]   - Field: ‘label’
[13:36:34.035]   - Field: ‘local’
[13:36:34.035]   - Field: ‘owner’
[13:36:34.035]   - Field: ‘envir’
[13:36:34.035]   - Field: ‘packages’
[13:36:34.035]   - Field: ‘gc’
[13:36:34.035]   - Field: ‘conditions’
[13:36:34.035]   - Field: ‘expr’
[13:36:34.035]   - Field: ‘uuid’
[13:36:34.035]   - Field: ‘seed’
[13:36:34.035]   - Field: ‘version’
[13:36:34.036]   - Field: ‘result’
[13:36:34.036]   - Field: ‘asynchronous’
[13:36:34.036]   - Field: ‘calls’
[13:36:34.036]   - Field: ‘globals’
[13:36:34.036]   - Field: ‘stdout’
[13:36:34.036]   - Field: ‘earlySignal’
[13:36:34.036]   - Field: ‘lazy’
[13:36:34.036]   - Field: ‘state’
[13:36:34.036] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.036] - Launch lazy future ...
[13:36:34.036] Packages needed by the future expression (n = 0): <none>
[13:36:34.037] Packages needed by future strategies (n = 0): <none>
[13:36:34.037] {
[13:36:34.037]     {
[13:36:34.037]         {
[13:36:34.037]             ...future.startTime <- base::Sys.time()
[13:36:34.037]             {
[13:36:34.037]                 {
[13:36:34.037]                   {
[13:36:34.037]                     base::local({
[13:36:34.037]                       has_future <- base::requireNamespace("future", 
[13:36:34.037]                         quietly = TRUE)
[13:36:34.037]                       if (has_future) {
[13:36:34.037]                         ns <- base::getNamespace("future")
[13:36:34.037]                         version <- ns[[".package"]][["version"]]
[13:36:34.037]                         if (is.null(version)) 
[13:36:34.037]                           version <- utils::packageVersion("future")
[13:36:34.037]                       }
[13:36:34.037]                       else {
[13:36:34.037]                         version <- NULL
[13:36:34.037]                       }
[13:36:34.037]                       if (!has_future || version < "1.8.0") {
[13:36:34.037]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.037]                           "", base::R.version$version.string), 
[13:36:34.037]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.037]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.037]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.037]                             "release", "version")], collapse = " "), 
[13:36:34.037]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.037]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.037]                           info)
[13:36:34.037]                         info <- base::paste(info, collapse = "; ")
[13:36:34.037]                         if (!has_future) {
[13:36:34.037]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.037]                             info)
[13:36:34.037]                         }
[13:36:34.037]                         else {
[13:36:34.037]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.037]                             info, version)
[13:36:34.037]                         }
[13:36:34.037]                         base::stop(msg)
[13:36:34.037]                       }
[13:36:34.037]                     })
[13:36:34.037]                   }
[13:36:34.037]                   ...future.strategy.old <- future::plan("list")
[13:36:34.037]                   options(future.plan = NULL)
[13:36:34.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.037]                 }
[13:36:34.037]                 ...future.workdir <- getwd()
[13:36:34.037]             }
[13:36:34.037]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.037]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.037]         }
[13:36:34.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.037]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.037]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.037]             base::names(...future.oldOptions))
[13:36:34.037]     }
[13:36:34.037]     if (FALSE) {
[13:36:34.037]     }
[13:36:34.037]     else {
[13:36:34.037]         if (TRUE) {
[13:36:34.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.037]                 open = "w")
[13:36:34.037]         }
[13:36:34.037]         else {
[13:36:34.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.037]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.037]         }
[13:36:34.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.037]             base::sink(type = "output", split = FALSE)
[13:36:34.037]             base::close(...future.stdout)
[13:36:34.037]         }, add = TRUE)
[13:36:34.037]     }
[13:36:34.037]     ...future.frame <- base::sys.nframe()
[13:36:34.037]     ...future.conditions <- base::list()
[13:36:34.037]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.037]     if (FALSE) {
[13:36:34.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.037]     }
[13:36:34.037]     ...future.result <- base::tryCatch({
[13:36:34.037]         base::withCallingHandlers({
[13:36:34.037]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.037]             future::FutureResult(value = ...future.value$value, 
[13:36:34.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.037]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.037]                     ...future.globalenv.names))
[13:36:34.037]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.037]         }, condition = base::local({
[13:36:34.037]             c <- base::c
[13:36:34.037]             inherits <- base::inherits
[13:36:34.037]             invokeRestart <- base::invokeRestart
[13:36:34.037]             length <- base::length
[13:36:34.037]             list <- base::list
[13:36:34.037]             seq.int <- base::seq.int
[13:36:34.037]             signalCondition <- base::signalCondition
[13:36:34.037]             sys.calls <- base::sys.calls
[13:36:34.037]             `[[` <- base::`[[`
[13:36:34.037]             `+` <- base::`+`
[13:36:34.037]             `<<-` <- base::`<<-`
[13:36:34.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.037]                   3L)]
[13:36:34.037]             }
[13:36:34.037]             function(cond) {
[13:36:34.037]                 is_error <- inherits(cond, "error")
[13:36:34.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.037]                   NULL)
[13:36:34.037]                 if (is_error) {
[13:36:34.037]                   sessionInformation <- function() {
[13:36:34.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.037]                       search = base::search(), system = base::Sys.info())
[13:36:34.037]                   }
[13:36:34.037]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.037]                     cond$call), session = sessionInformation(), 
[13:36:34.037]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.037]                   signalCondition(cond)
[13:36:34.037]                 }
[13:36:34.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.037]                 "immediateCondition"))) {
[13:36:34.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.037]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.037]                   if (TRUE && !signal) {
[13:36:34.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.037]                     {
[13:36:34.037]                       inherits <- base::inherits
[13:36:34.037]                       invokeRestart <- base::invokeRestart
[13:36:34.037]                       is.null <- base::is.null
[13:36:34.037]                       muffled <- FALSE
[13:36:34.037]                       if (inherits(cond, "message")) {
[13:36:34.037]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.037]                         if (muffled) 
[13:36:34.037]                           invokeRestart("muffleMessage")
[13:36:34.037]                       }
[13:36:34.037]                       else if (inherits(cond, "warning")) {
[13:36:34.037]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.037]                         if (muffled) 
[13:36:34.037]                           invokeRestart("muffleWarning")
[13:36:34.037]                       }
[13:36:34.037]                       else if (inherits(cond, "condition")) {
[13:36:34.037]                         if (!is.null(pattern)) {
[13:36:34.037]                           computeRestarts <- base::computeRestarts
[13:36:34.037]                           grepl <- base::grepl
[13:36:34.037]                           restarts <- computeRestarts(cond)
[13:36:34.037]                           for (restart in restarts) {
[13:36:34.037]                             name <- restart$name
[13:36:34.037]                             if (is.null(name)) 
[13:36:34.037]                               next
[13:36:34.037]                             if (!grepl(pattern, name)) 
[13:36:34.037]                               next
[13:36:34.037]                             invokeRestart(restart)
[13:36:34.037]                             muffled <- TRUE
[13:36:34.037]                             break
[13:36:34.037]                           }
[13:36:34.037]                         }
[13:36:34.037]                       }
[13:36:34.037]                       invisible(muffled)
[13:36:34.037]                     }
[13:36:34.037]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.037]                   }
[13:36:34.037]                 }
[13:36:34.037]                 else {
[13:36:34.037]                   if (TRUE) {
[13:36:34.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.037]                     {
[13:36:34.037]                       inherits <- base::inherits
[13:36:34.037]                       invokeRestart <- base::invokeRestart
[13:36:34.037]                       is.null <- base::is.null
[13:36:34.037]                       muffled <- FALSE
[13:36:34.037]                       if (inherits(cond, "message")) {
[13:36:34.037]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.037]                         if (muffled) 
[13:36:34.037]                           invokeRestart("muffleMessage")
[13:36:34.037]                       }
[13:36:34.037]                       else if (inherits(cond, "warning")) {
[13:36:34.037]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.037]                         if (muffled) 
[13:36:34.037]                           invokeRestart("muffleWarning")
[13:36:34.037]                       }
[13:36:34.037]                       else if (inherits(cond, "condition")) {
[13:36:34.037]                         if (!is.null(pattern)) {
[13:36:34.037]                           computeRestarts <- base::computeRestarts
[13:36:34.037]                           grepl <- base::grepl
[13:36:34.037]                           restarts <- computeRestarts(cond)
[13:36:34.037]                           for (restart in restarts) {
[13:36:34.037]                             name <- restart$name
[13:36:34.037]                             if (is.null(name)) 
[13:36:34.037]                               next
[13:36:34.037]                             if (!grepl(pattern, name)) 
[13:36:34.037]                               next
[13:36:34.037]                             invokeRestart(restart)
[13:36:34.037]                             muffled <- TRUE
[13:36:34.037]                             break
[13:36:34.037]                           }
[13:36:34.037]                         }
[13:36:34.037]                       }
[13:36:34.037]                       invisible(muffled)
[13:36:34.037]                     }
[13:36:34.037]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.037]                   }
[13:36:34.037]                 }
[13:36:34.037]             }
[13:36:34.037]         }))
[13:36:34.037]     }, error = function(ex) {
[13:36:34.037]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.037]                 ...future.rng), started = ...future.startTime, 
[13:36:34.037]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.037]             version = "1.8"), class = "FutureResult")
[13:36:34.037]     }, finally = {
[13:36:34.037]         if (!identical(...future.workdir, getwd())) 
[13:36:34.037]             setwd(...future.workdir)
[13:36:34.037]         {
[13:36:34.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.037]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.037]             }
[13:36:34.037]             base::options(...future.oldOptions)
[13:36:34.037]             if (.Platform$OS.type == "windows") {
[13:36:34.037]                 old_names <- names(...future.oldEnvVars)
[13:36:34.037]                 envs <- base::Sys.getenv()
[13:36:34.037]                 names <- names(envs)
[13:36:34.037]                 common <- intersect(names, old_names)
[13:36:34.037]                 added <- setdiff(names, old_names)
[13:36:34.037]                 removed <- setdiff(old_names, names)
[13:36:34.037]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.037]                   envs[common]]
[13:36:34.037]                 NAMES <- toupper(changed)
[13:36:34.037]                 args <- list()
[13:36:34.037]                 for (kk in seq_along(NAMES)) {
[13:36:34.037]                   name <- changed[[kk]]
[13:36:34.037]                   NAME <- NAMES[[kk]]
[13:36:34.037]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.037]                     next
[13:36:34.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.037]                 }
[13:36:34.037]                 NAMES <- toupper(added)
[13:36:34.037]                 for (kk in seq_along(NAMES)) {
[13:36:34.037]                   name <- added[[kk]]
[13:36:34.037]                   NAME <- NAMES[[kk]]
[13:36:34.037]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.037]                     next
[13:36:34.037]                   args[[name]] <- ""
[13:36:34.037]                 }
[13:36:34.037]                 NAMES <- toupper(removed)
[13:36:34.037]                 for (kk in seq_along(NAMES)) {
[13:36:34.037]                   name <- removed[[kk]]
[13:36:34.037]                   NAME <- NAMES[[kk]]
[13:36:34.037]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.037]                     next
[13:36:34.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.037]                 }
[13:36:34.037]                 if (length(args) > 0) 
[13:36:34.037]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.037]             }
[13:36:34.037]             else {
[13:36:34.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.037]             }
[13:36:34.037]             {
[13:36:34.037]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.037]                   0L) {
[13:36:34.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.037]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.037]                   base::options(opts)
[13:36:34.037]                 }
[13:36:34.037]                 {
[13:36:34.037]                   {
[13:36:34.037]                     NULL
[13:36:34.037]                     RNGkind("Mersenne-Twister")
[13:36:34.037]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.037]                       inherits = FALSE)
[13:36:34.037]                   }
[13:36:34.037]                   options(future.plan = NULL)
[13:36:34.037]                   if (is.na(NA_character_)) 
[13:36:34.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.037]                     .init = FALSE)
[13:36:34.037]                 }
[13:36:34.037]             }
[13:36:34.037]         }
[13:36:34.037]     })
[13:36:34.037]     if (TRUE) {
[13:36:34.037]         base::sink(type = "output", split = FALSE)
[13:36:34.037]         if (TRUE) {
[13:36:34.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.037]         }
[13:36:34.037]         else {
[13:36:34.037]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.037]         }
[13:36:34.037]         base::close(...future.stdout)
[13:36:34.037]         ...future.stdout <- NULL
[13:36:34.037]     }
[13:36:34.037]     ...future.result$conditions <- ...future.conditions
[13:36:34.037]     ...future.result$finished <- base::Sys.time()
[13:36:34.037]     ...future.result
[13:36:34.037] }
[13:36:34.039] plan(): Setting new future strategy stack:
[13:36:34.039] List of future strategies:
[13:36:34.039] 1. sequential:
[13:36:34.039]    - args: function (..., envir = parent.frame())
[13:36:34.039]    - tweaked: FALSE
[13:36:34.039]    - call: NULL
[13:36:34.039] plan(): nbrOfWorkers() = 1
[13:36:34.040] plan(): Setting new future strategy stack:
[13:36:34.040] List of future strategies:
[13:36:34.040] 1. sequential:
[13:36:34.040]    - args: function (..., envir = parent.frame())
[13:36:34.040]    - tweaked: FALSE
[13:36:34.040]    - call: plan(strategy)
[13:36:34.040] plan(): nbrOfWorkers() = 1
[13:36:34.040] SequentialFuture started (and completed)
[13:36:34.040] - Launch lazy future ... done
[13:36:34.041] run() for ‘SequentialFuture’ ... done
[13:36:34.041] getGlobalsAndPackages() ...
[13:36:34.041] Searching for globals...
[13:36:34.041] - globals found: [1] ‘{’
[13:36:34.042] Searching for globals ... DONE
[13:36:34.042] Resolving globals: FALSE
[13:36:34.042] 
[13:36:34.042] 
[13:36:34.042] getGlobalsAndPackages() ... DONE
[13:36:34.042] run() for ‘Future’ ...
[13:36:34.042] - state: ‘created’
[13:36:34.043] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.043] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.043]   - Field: ‘label’
[13:36:34.043]   - Field: ‘local’
[13:36:34.043]   - Field: ‘owner’
[13:36:34.043]   - Field: ‘envir’
[13:36:34.043]   - Field: ‘packages’
[13:36:34.043]   - Field: ‘gc’
[13:36:34.044]   - Field: ‘conditions’
[13:36:34.044]   - Field: ‘expr’
[13:36:34.044]   - Field: ‘uuid’
[13:36:34.044]   - Field: ‘seed’
[13:36:34.044]   - Field: ‘version’
[13:36:34.044]   - Field: ‘result’
[13:36:34.044]   - Field: ‘asynchronous’
[13:36:34.044]   - Field: ‘calls’
[13:36:34.044]   - Field: ‘globals’
[13:36:34.044]   - Field: ‘stdout’
[13:36:34.044]   - Field: ‘earlySignal’
[13:36:34.045]   - Field: ‘lazy’
[13:36:34.045]   - Field: ‘state’
[13:36:34.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.045] - Launch lazy future ...
[13:36:34.045] Packages needed by the future expression (n = 0): <none>
[13:36:34.045] Packages needed by future strategies (n = 0): <none>
[13:36:34.045] {
[13:36:34.045]     {
[13:36:34.045]         {
[13:36:34.045]             ...future.startTime <- base::Sys.time()
[13:36:34.045]             {
[13:36:34.045]                 {
[13:36:34.045]                   {
[13:36:34.045]                     base::local({
[13:36:34.045]                       has_future <- base::requireNamespace("future", 
[13:36:34.045]                         quietly = TRUE)
[13:36:34.045]                       if (has_future) {
[13:36:34.045]                         ns <- base::getNamespace("future")
[13:36:34.045]                         version <- ns[[".package"]][["version"]]
[13:36:34.045]                         if (is.null(version)) 
[13:36:34.045]                           version <- utils::packageVersion("future")
[13:36:34.045]                       }
[13:36:34.045]                       else {
[13:36:34.045]                         version <- NULL
[13:36:34.045]                       }
[13:36:34.045]                       if (!has_future || version < "1.8.0") {
[13:36:34.045]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.045]                           "", base::R.version$version.string), 
[13:36:34.045]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.045]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.045]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.045]                             "release", "version")], collapse = " "), 
[13:36:34.045]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.045]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.045]                           info)
[13:36:34.045]                         info <- base::paste(info, collapse = "; ")
[13:36:34.045]                         if (!has_future) {
[13:36:34.045]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.045]                             info)
[13:36:34.045]                         }
[13:36:34.045]                         else {
[13:36:34.045]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.045]                             info, version)
[13:36:34.045]                         }
[13:36:34.045]                         base::stop(msg)
[13:36:34.045]                       }
[13:36:34.045]                     })
[13:36:34.045]                   }
[13:36:34.045]                   ...future.strategy.old <- future::plan("list")
[13:36:34.045]                   options(future.plan = NULL)
[13:36:34.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.045]                 }
[13:36:34.045]                 ...future.workdir <- getwd()
[13:36:34.045]             }
[13:36:34.045]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.045]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.045]         }
[13:36:34.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.045]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.045]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.045]             base::names(...future.oldOptions))
[13:36:34.045]     }
[13:36:34.045]     if (FALSE) {
[13:36:34.045]     }
[13:36:34.045]     else {
[13:36:34.045]         if (TRUE) {
[13:36:34.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.045]                 open = "w")
[13:36:34.045]         }
[13:36:34.045]         else {
[13:36:34.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.045]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.045]         }
[13:36:34.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.045]             base::sink(type = "output", split = FALSE)
[13:36:34.045]             base::close(...future.stdout)
[13:36:34.045]         }, add = TRUE)
[13:36:34.045]     }
[13:36:34.045]     ...future.frame <- base::sys.nframe()
[13:36:34.045]     ...future.conditions <- base::list()
[13:36:34.045]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.045]     if (FALSE) {
[13:36:34.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.045]     }
[13:36:34.045]     ...future.result <- base::tryCatch({
[13:36:34.045]         base::withCallingHandlers({
[13:36:34.045]             ...future.value <- base::withVisible(base::local({
[13:36:34.045]                 4
[13:36:34.045]             }))
[13:36:34.045]             future::FutureResult(value = ...future.value$value, 
[13:36:34.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.045]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.045]                     ...future.globalenv.names))
[13:36:34.045]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.045]         }, condition = base::local({
[13:36:34.045]             c <- base::c
[13:36:34.045]             inherits <- base::inherits
[13:36:34.045]             invokeRestart <- base::invokeRestart
[13:36:34.045]             length <- base::length
[13:36:34.045]             list <- base::list
[13:36:34.045]             seq.int <- base::seq.int
[13:36:34.045]             signalCondition <- base::signalCondition
[13:36:34.045]             sys.calls <- base::sys.calls
[13:36:34.045]             `[[` <- base::`[[`
[13:36:34.045]             `+` <- base::`+`
[13:36:34.045]             `<<-` <- base::`<<-`
[13:36:34.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.045]                   3L)]
[13:36:34.045]             }
[13:36:34.045]             function(cond) {
[13:36:34.045]                 is_error <- inherits(cond, "error")
[13:36:34.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.045]                   NULL)
[13:36:34.045]                 if (is_error) {
[13:36:34.045]                   sessionInformation <- function() {
[13:36:34.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.045]                       search = base::search(), system = base::Sys.info())
[13:36:34.045]                   }
[13:36:34.045]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.045]                     cond$call), session = sessionInformation(), 
[13:36:34.045]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.045]                   signalCondition(cond)
[13:36:34.045]                 }
[13:36:34.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.045]                 "immediateCondition"))) {
[13:36:34.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.045]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.045]                   if (TRUE && !signal) {
[13:36:34.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.045]                     {
[13:36:34.045]                       inherits <- base::inherits
[13:36:34.045]                       invokeRestart <- base::invokeRestart
[13:36:34.045]                       is.null <- base::is.null
[13:36:34.045]                       muffled <- FALSE
[13:36:34.045]                       if (inherits(cond, "message")) {
[13:36:34.045]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.045]                         if (muffled) 
[13:36:34.045]                           invokeRestart("muffleMessage")
[13:36:34.045]                       }
[13:36:34.045]                       else if (inherits(cond, "warning")) {
[13:36:34.045]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.045]                         if (muffled) 
[13:36:34.045]                           invokeRestart("muffleWarning")
[13:36:34.045]                       }
[13:36:34.045]                       else if (inherits(cond, "condition")) {
[13:36:34.045]                         if (!is.null(pattern)) {
[13:36:34.045]                           computeRestarts <- base::computeRestarts
[13:36:34.045]                           grepl <- base::grepl
[13:36:34.045]                           restarts <- computeRestarts(cond)
[13:36:34.045]                           for (restart in restarts) {
[13:36:34.045]                             name <- restart$name
[13:36:34.045]                             if (is.null(name)) 
[13:36:34.045]                               next
[13:36:34.045]                             if (!grepl(pattern, name)) 
[13:36:34.045]                               next
[13:36:34.045]                             invokeRestart(restart)
[13:36:34.045]                             muffled <- TRUE
[13:36:34.045]                             break
[13:36:34.045]                           }
[13:36:34.045]                         }
[13:36:34.045]                       }
[13:36:34.045]                       invisible(muffled)
[13:36:34.045]                     }
[13:36:34.045]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.045]                   }
[13:36:34.045]                 }
[13:36:34.045]                 else {
[13:36:34.045]                   if (TRUE) {
[13:36:34.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.045]                     {
[13:36:34.045]                       inherits <- base::inherits
[13:36:34.045]                       invokeRestart <- base::invokeRestart
[13:36:34.045]                       is.null <- base::is.null
[13:36:34.045]                       muffled <- FALSE
[13:36:34.045]                       if (inherits(cond, "message")) {
[13:36:34.045]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.045]                         if (muffled) 
[13:36:34.045]                           invokeRestart("muffleMessage")
[13:36:34.045]                       }
[13:36:34.045]                       else if (inherits(cond, "warning")) {
[13:36:34.045]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.045]                         if (muffled) 
[13:36:34.045]                           invokeRestart("muffleWarning")
[13:36:34.045]                       }
[13:36:34.045]                       else if (inherits(cond, "condition")) {
[13:36:34.045]                         if (!is.null(pattern)) {
[13:36:34.045]                           computeRestarts <- base::computeRestarts
[13:36:34.045]                           grepl <- base::grepl
[13:36:34.045]                           restarts <- computeRestarts(cond)
[13:36:34.045]                           for (restart in restarts) {
[13:36:34.045]                             name <- restart$name
[13:36:34.045]                             if (is.null(name)) 
[13:36:34.045]                               next
[13:36:34.045]                             if (!grepl(pattern, name)) 
[13:36:34.045]                               next
[13:36:34.045]                             invokeRestart(restart)
[13:36:34.045]                             muffled <- TRUE
[13:36:34.045]                             break
[13:36:34.045]                           }
[13:36:34.045]                         }
[13:36:34.045]                       }
[13:36:34.045]                       invisible(muffled)
[13:36:34.045]                     }
[13:36:34.045]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.045]                   }
[13:36:34.045]                 }
[13:36:34.045]             }
[13:36:34.045]         }))
[13:36:34.045]     }, error = function(ex) {
[13:36:34.045]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.045]                 ...future.rng), started = ...future.startTime, 
[13:36:34.045]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.045]             version = "1.8"), class = "FutureResult")
[13:36:34.045]     }, finally = {
[13:36:34.045]         if (!identical(...future.workdir, getwd())) 
[13:36:34.045]             setwd(...future.workdir)
[13:36:34.045]         {
[13:36:34.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.045]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.045]             }
[13:36:34.045]             base::options(...future.oldOptions)
[13:36:34.045]             if (.Platform$OS.type == "windows") {
[13:36:34.045]                 old_names <- names(...future.oldEnvVars)
[13:36:34.045]                 envs <- base::Sys.getenv()
[13:36:34.045]                 names <- names(envs)
[13:36:34.045]                 common <- intersect(names, old_names)
[13:36:34.045]                 added <- setdiff(names, old_names)
[13:36:34.045]                 removed <- setdiff(old_names, names)
[13:36:34.045]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.045]                   envs[common]]
[13:36:34.045]                 NAMES <- toupper(changed)
[13:36:34.045]                 args <- list()
[13:36:34.045]                 for (kk in seq_along(NAMES)) {
[13:36:34.045]                   name <- changed[[kk]]
[13:36:34.045]                   NAME <- NAMES[[kk]]
[13:36:34.045]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.045]                     next
[13:36:34.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.045]                 }
[13:36:34.045]                 NAMES <- toupper(added)
[13:36:34.045]                 for (kk in seq_along(NAMES)) {
[13:36:34.045]                   name <- added[[kk]]
[13:36:34.045]                   NAME <- NAMES[[kk]]
[13:36:34.045]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.045]                     next
[13:36:34.045]                   args[[name]] <- ""
[13:36:34.045]                 }
[13:36:34.045]                 NAMES <- toupper(removed)
[13:36:34.045]                 for (kk in seq_along(NAMES)) {
[13:36:34.045]                   name <- removed[[kk]]
[13:36:34.045]                   NAME <- NAMES[[kk]]
[13:36:34.045]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.045]                     next
[13:36:34.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.045]                 }
[13:36:34.045]                 if (length(args) > 0) 
[13:36:34.045]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.045]             }
[13:36:34.045]             else {
[13:36:34.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.045]             }
[13:36:34.045]             {
[13:36:34.045]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.045]                   0L) {
[13:36:34.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.045]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.045]                   base::options(opts)
[13:36:34.045]                 }
[13:36:34.045]                 {
[13:36:34.045]                   {
[13:36:34.045]                     NULL
[13:36:34.045]                     RNGkind("Mersenne-Twister")
[13:36:34.045]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.045]                       inherits = FALSE)
[13:36:34.045]                   }
[13:36:34.045]                   options(future.plan = NULL)
[13:36:34.045]                   if (is.na(NA_character_)) 
[13:36:34.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.045]                     .init = FALSE)
[13:36:34.045]                 }
[13:36:34.045]             }
[13:36:34.045]         }
[13:36:34.045]     })
[13:36:34.045]     if (TRUE) {
[13:36:34.045]         base::sink(type = "output", split = FALSE)
[13:36:34.045]         if (TRUE) {
[13:36:34.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.045]         }
[13:36:34.045]         else {
[13:36:34.045]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.045]         }
[13:36:34.045]         base::close(...future.stdout)
[13:36:34.045]         ...future.stdout <- NULL
[13:36:34.045]     }
[13:36:34.045]     ...future.result$conditions <- ...future.conditions
[13:36:34.045]     ...future.result$finished <- base::Sys.time()
[13:36:34.045]     ...future.result
[13:36:34.045] }
[13:36:34.047] plan(): Setting new future strategy stack:
[13:36:34.047] List of future strategies:
[13:36:34.047] 1. sequential:
[13:36:34.047]    - args: function (..., envir = parent.frame())
[13:36:34.047]    - tweaked: FALSE
[13:36:34.047]    - call: NULL
[13:36:34.048] plan(): nbrOfWorkers() = 1
[13:36:34.050] plan(): Setting new future strategy stack:
[13:36:34.050] List of future strategies:
[13:36:34.050] 1. sequential:
[13:36:34.050]    - args: function (..., envir = parent.frame())
[13:36:34.050]    - tweaked: FALSE
[13:36:34.050]    - call: plan(strategy)
[13:36:34.050] plan(): nbrOfWorkers() = 1
[13:36:34.050] SequentialFuture started (and completed)
[13:36:34.050] - Launch lazy future ... done
[13:36:34.050] run() for ‘SequentialFuture’ ... done
<environment: 0x564a72702958> 
<environment: 0x564a71b22ba0> 
[13:36:34.052] resolved() for ‘SequentialFuture’ ...
[13:36:34.052] - state: ‘finished’
[13:36:34.052] - run: TRUE
[13:36:34.052] - result: ‘FutureResult’
[13:36:34.052] resolved() for ‘SequentialFuture’ ... done
[13:36:34.052] resolved() for ‘SequentialFuture’ ...
[13:36:34.052] - state: ‘finished’
[13:36:34.052] - run: TRUE
[13:36:34.052] - result: ‘FutureResult’
[13:36:34.052] resolved() for ‘SequentialFuture’ ... done
[13:36:34.053] resolved() for ‘SequentialFuture’ ...
[13:36:34.053] - state: ‘finished’
[13:36:34.053] - run: TRUE
[13:36:34.053] - result: ‘FutureResult’
[13:36:34.053] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:34.054] resolve() on environment ...
[13:36:34.054]  recursive: 0
[13:36:34.055]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:34.055] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.055] - nx: 4
[13:36:34.055] - relay: TRUE
[13:36:34.055] - stdout: TRUE
[13:36:34.055] - signal: TRUE
[13:36:34.055] - resignal: FALSE
[13:36:34.055] - force: TRUE
[13:36:34.055] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.055] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.055]  - until=2
[13:36:34.056]  - relaying element #2
[13:36:34.056] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.056] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.056] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.056]  length: 3 (resolved future 1)
[13:36:34.056] resolved() for ‘SequentialFuture’ ...
[13:36:34.056] - state: ‘finished’
[13:36:34.056] - run: TRUE
[13:36:34.056] - result: ‘FutureResult’
[13:36:34.056] resolved() for ‘SequentialFuture’ ... done
[13:36:34.056] Future #2
[13:36:34.057] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.057] - nx: 4
[13:36:34.057] - relay: TRUE
[13:36:34.057] - stdout: TRUE
[13:36:34.057] - signal: TRUE
[13:36:34.057] - resignal: FALSE
[13:36:34.057] - force: TRUE
[13:36:34.057] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.057] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.057]  - until=2
[13:36:34.057]  - relaying element #2
[13:36:34.058] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.058] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.058] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.058]  length: 2 (resolved future 2)
[13:36:34.058] resolved() for ‘SequentialFuture’ ...
[13:36:34.058] - state: ‘finished’
[13:36:34.058] - run: TRUE
[13:36:34.058] - result: ‘FutureResult’
[13:36:34.058] resolved() for ‘SequentialFuture’ ... done
[13:36:34.058] Future #3
[13:36:34.059] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.059] - nx: 4
[13:36:34.059] - relay: TRUE
[13:36:34.059] - stdout: TRUE
[13:36:34.059] - signal: TRUE
[13:36:34.059] - resignal: FALSE
[13:36:34.059] - force: TRUE
[13:36:34.059] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.059] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.059]  - until=3
[13:36:34.059]  - relaying element #3
[13:36:34.059] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.060] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.060] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.060]  length: 1 (resolved future 3)
[13:36:34.060] resolved() for ‘SequentialFuture’ ...
[13:36:34.060] - state: ‘finished’
[13:36:34.060] - run: TRUE
[13:36:34.060] - result: ‘FutureResult’
[13:36:34.060] resolved() for ‘SequentialFuture’ ... done
[13:36:34.060] Future #4
[13:36:34.060] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.061] - nx: 4
[13:36:34.061] - relay: TRUE
[13:36:34.061] - stdout: TRUE
[13:36:34.061] - signal: TRUE
[13:36:34.061] - resignal: FALSE
[13:36:34.061] - force: TRUE
[13:36:34.061] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.061] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.061]  - until=4
[13:36:34.061]  - relaying element #4
[13:36:34.061] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.061] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.062] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.062]  length: 0 (resolved future 4)
[13:36:34.062] Relaying remaining futures
[13:36:34.062] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.062] - nx: 4
[13:36:34.062] - relay: TRUE
[13:36:34.062] - stdout: TRUE
[13:36:34.062] - signal: TRUE
[13:36:34.062] - resignal: FALSE
[13:36:34.062] - force: TRUE
[13:36:34.062] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.062] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:34.063] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.063] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.063] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.063] resolve() on environment ... DONE
<environment: 0x564a714c5ef0> 
Dimensions: c(2, 3, 1)
[13:36:34.063] getGlobalsAndPackages() ...
[13:36:34.063] Searching for globals...
[13:36:34.064] 
[13:36:34.064] Searching for globals ... DONE
[13:36:34.064] - globals: [0] <none>
[13:36:34.064] getGlobalsAndPackages() ... DONE
[13:36:34.064] run() for ‘Future’ ...
[13:36:34.064] - state: ‘created’
[13:36:34.064] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.065] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.065]   - Field: ‘label’
[13:36:34.065]   - Field: ‘local’
[13:36:34.065]   - Field: ‘owner’
[13:36:34.065]   - Field: ‘envir’
[13:36:34.065]   - Field: ‘packages’
[13:36:34.065]   - Field: ‘gc’
[13:36:34.065]   - Field: ‘conditions’
[13:36:34.065]   - Field: ‘expr’
[13:36:34.066]   - Field: ‘uuid’
[13:36:34.066]   - Field: ‘seed’
[13:36:34.066]   - Field: ‘version’
[13:36:34.066]   - Field: ‘result’
[13:36:34.066]   - Field: ‘asynchronous’
[13:36:34.066]   - Field: ‘calls’
[13:36:34.066]   - Field: ‘globals’
[13:36:34.066]   - Field: ‘stdout’
[13:36:34.066]   - Field: ‘earlySignal’
[13:36:34.066]   - Field: ‘lazy’
[13:36:34.066]   - Field: ‘state’
[13:36:34.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.067] - Launch lazy future ...
[13:36:34.067] Packages needed by the future expression (n = 0): <none>
[13:36:34.067] Packages needed by future strategies (n = 0): <none>
[13:36:34.067] {
[13:36:34.067]     {
[13:36:34.067]         {
[13:36:34.067]             ...future.startTime <- base::Sys.time()
[13:36:34.067]             {
[13:36:34.067]                 {
[13:36:34.067]                   {
[13:36:34.067]                     base::local({
[13:36:34.067]                       has_future <- base::requireNamespace("future", 
[13:36:34.067]                         quietly = TRUE)
[13:36:34.067]                       if (has_future) {
[13:36:34.067]                         ns <- base::getNamespace("future")
[13:36:34.067]                         version <- ns[[".package"]][["version"]]
[13:36:34.067]                         if (is.null(version)) 
[13:36:34.067]                           version <- utils::packageVersion("future")
[13:36:34.067]                       }
[13:36:34.067]                       else {
[13:36:34.067]                         version <- NULL
[13:36:34.067]                       }
[13:36:34.067]                       if (!has_future || version < "1.8.0") {
[13:36:34.067]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.067]                           "", base::R.version$version.string), 
[13:36:34.067]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.067]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.067]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.067]                             "release", "version")], collapse = " "), 
[13:36:34.067]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.067]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.067]                           info)
[13:36:34.067]                         info <- base::paste(info, collapse = "; ")
[13:36:34.067]                         if (!has_future) {
[13:36:34.067]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.067]                             info)
[13:36:34.067]                         }
[13:36:34.067]                         else {
[13:36:34.067]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.067]                             info, version)
[13:36:34.067]                         }
[13:36:34.067]                         base::stop(msg)
[13:36:34.067]                       }
[13:36:34.067]                     })
[13:36:34.067]                   }
[13:36:34.067]                   ...future.strategy.old <- future::plan("list")
[13:36:34.067]                   options(future.plan = NULL)
[13:36:34.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.067]                 }
[13:36:34.067]                 ...future.workdir <- getwd()
[13:36:34.067]             }
[13:36:34.067]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.067]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.067]         }
[13:36:34.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.067]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.067]             base::names(...future.oldOptions))
[13:36:34.067]     }
[13:36:34.067]     if (FALSE) {
[13:36:34.067]     }
[13:36:34.067]     else {
[13:36:34.067]         if (TRUE) {
[13:36:34.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.067]                 open = "w")
[13:36:34.067]         }
[13:36:34.067]         else {
[13:36:34.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.067]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.067]         }
[13:36:34.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.067]             base::sink(type = "output", split = FALSE)
[13:36:34.067]             base::close(...future.stdout)
[13:36:34.067]         }, add = TRUE)
[13:36:34.067]     }
[13:36:34.067]     ...future.frame <- base::sys.nframe()
[13:36:34.067]     ...future.conditions <- base::list()
[13:36:34.067]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.067]     if (FALSE) {
[13:36:34.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.067]     }
[13:36:34.067]     ...future.result <- base::tryCatch({
[13:36:34.067]         base::withCallingHandlers({
[13:36:34.067]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.067]             future::FutureResult(value = ...future.value$value, 
[13:36:34.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.067]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.067]                     ...future.globalenv.names))
[13:36:34.067]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.067]         }, condition = base::local({
[13:36:34.067]             c <- base::c
[13:36:34.067]             inherits <- base::inherits
[13:36:34.067]             invokeRestart <- base::invokeRestart
[13:36:34.067]             length <- base::length
[13:36:34.067]             list <- base::list
[13:36:34.067]             seq.int <- base::seq.int
[13:36:34.067]             signalCondition <- base::signalCondition
[13:36:34.067]             sys.calls <- base::sys.calls
[13:36:34.067]             `[[` <- base::`[[`
[13:36:34.067]             `+` <- base::`+`
[13:36:34.067]             `<<-` <- base::`<<-`
[13:36:34.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.067]                   3L)]
[13:36:34.067]             }
[13:36:34.067]             function(cond) {
[13:36:34.067]                 is_error <- inherits(cond, "error")
[13:36:34.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.067]                   NULL)
[13:36:34.067]                 if (is_error) {
[13:36:34.067]                   sessionInformation <- function() {
[13:36:34.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.067]                       search = base::search(), system = base::Sys.info())
[13:36:34.067]                   }
[13:36:34.067]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.067]                     cond$call), session = sessionInformation(), 
[13:36:34.067]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.067]                   signalCondition(cond)
[13:36:34.067]                 }
[13:36:34.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.067]                 "immediateCondition"))) {
[13:36:34.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.067]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.067]                   if (TRUE && !signal) {
[13:36:34.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.067]                     {
[13:36:34.067]                       inherits <- base::inherits
[13:36:34.067]                       invokeRestart <- base::invokeRestart
[13:36:34.067]                       is.null <- base::is.null
[13:36:34.067]                       muffled <- FALSE
[13:36:34.067]                       if (inherits(cond, "message")) {
[13:36:34.067]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.067]                         if (muffled) 
[13:36:34.067]                           invokeRestart("muffleMessage")
[13:36:34.067]                       }
[13:36:34.067]                       else if (inherits(cond, "warning")) {
[13:36:34.067]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.067]                         if (muffled) 
[13:36:34.067]                           invokeRestart("muffleWarning")
[13:36:34.067]                       }
[13:36:34.067]                       else if (inherits(cond, "condition")) {
[13:36:34.067]                         if (!is.null(pattern)) {
[13:36:34.067]                           computeRestarts <- base::computeRestarts
[13:36:34.067]                           grepl <- base::grepl
[13:36:34.067]                           restarts <- computeRestarts(cond)
[13:36:34.067]                           for (restart in restarts) {
[13:36:34.067]                             name <- restart$name
[13:36:34.067]                             if (is.null(name)) 
[13:36:34.067]                               next
[13:36:34.067]                             if (!grepl(pattern, name)) 
[13:36:34.067]                               next
[13:36:34.067]                             invokeRestart(restart)
[13:36:34.067]                             muffled <- TRUE
[13:36:34.067]                             break
[13:36:34.067]                           }
[13:36:34.067]                         }
[13:36:34.067]                       }
[13:36:34.067]                       invisible(muffled)
[13:36:34.067]                     }
[13:36:34.067]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.067]                   }
[13:36:34.067]                 }
[13:36:34.067]                 else {
[13:36:34.067]                   if (TRUE) {
[13:36:34.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.067]                     {
[13:36:34.067]                       inherits <- base::inherits
[13:36:34.067]                       invokeRestart <- base::invokeRestart
[13:36:34.067]                       is.null <- base::is.null
[13:36:34.067]                       muffled <- FALSE
[13:36:34.067]                       if (inherits(cond, "message")) {
[13:36:34.067]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.067]                         if (muffled) 
[13:36:34.067]                           invokeRestart("muffleMessage")
[13:36:34.067]                       }
[13:36:34.067]                       else if (inherits(cond, "warning")) {
[13:36:34.067]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.067]                         if (muffled) 
[13:36:34.067]                           invokeRestart("muffleWarning")
[13:36:34.067]                       }
[13:36:34.067]                       else if (inherits(cond, "condition")) {
[13:36:34.067]                         if (!is.null(pattern)) {
[13:36:34.067]                           computeRestarts <- base::computeRestarts
[13:36:34.067]                           grepl <- base::grepl
[13:36:34.067]                           restarts <- computeRestarts(cond)
[13:36:34.067]                           for (restart in restarts) {
[13:36:34.067]                             name <- restart$name
[13:36:34.067]                             if (is.null(name)) 
[13:36:34.067]                               next
[13:36:34.067]                             if (!grepl(pattern, name)) 
[13:36:34.067]                               next
[13:36:34.067]                             invokeRestart(restart)
[13:36:34.067]                             muffled <- TRUE
[13:36:34.067]                             break
[13:36:34.067]                           }
[13:36:34.067]                         }
[13:36:34.067]                       }
[13:36:34.067]                       invisible(muffled)
[13:36:34.067]                     }
[13:36:34.067]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.067]                   }
[13:36:34.067]                 }
[13:36:34.067]             }
[13:36:34.067]         }))
[13:36:34.067]     }, error = function(ex) {
[13:36:34.067]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.067]                 ...future.rng), started = ...future.startTime, 
[13:36:34.067]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.067]             version = "1.8"), class = "FutureResult")
[13:36:34.067]     }, finally = {
[13:36:34.067]         if (!identical(...future.workdir, getwd())) 
[13:36:34.067]             setwd(...future.workdir)
[13:36:34.067]         {
[13:36:34.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.067]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.067]             }
[13:36:34.067]             base::options(...future.oldOptions)
[13:36:34.067]             if (.Platform$OS.type == "windows") {
[13:36:34.067]                 old_names <- names(...future.oldEnvVars)
[13:36:34.067]                 envs <- base::Sys.getenv()
[13:36:34.067]                 names <- names(envs)
[13:36:34.067]                 common <- intersect(names, old_names)
[13:36:34.067]                 added <- setdiff(names, old_names)
[13:36:34.067]                 removed <- setdiff(old_names, names)
[13:36:34.067]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.067]                   envs[common]]
[13:36:34.067]                 NAMES <- toupper(changed)
[13:36:34.067]                 args <- list()
[13:36:34.067]                 for (kk in seq_along(NAMES)) {
[13:36:34.067]                   name <- changed[[kk]]
[13:36:34.067]                   NAME <- NAMES[[kk]]
[13:36:34.067]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.067]                     next
[13:36:34.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.067]                 }
[13:36:34.067]                 NAMES <- toupper(added)
[13:36:34.067]                 for (kk in seq_along(NAMES)) {
[13:36:34.067]                   name <- added[[kk]]
[13:36:34.067]                   NAME <- NAMES[[kk]]
[13:36:34.067]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.067]                     next
[13:36:34.067]                   args[[name]] <- ""
[13:36:34.067]                 }
[13:36:34.067]                 NAMES <- toupper(removed)
[13:36:34.067]                 for (kk in seq_along(NAMES)) {
[13:36:34.067]                   name <- removed[[kk]]
[13:36:34.067]                   NAME <- NAMES[[kk]]
[13:36:34.067]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.067]                     next
[13:36:34.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.067]                 }
[13:36:34.067]                 if (length(args) > 0) 
[13:36:34.067]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.067]             }
[13:36:34.067]             else {
[13:36:34.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.067]             }
[13:36:34.067]             {
[13:36:34.067]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.067]                   0L) {
[13:36:34.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.067]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.067]                   base::options(opts)
[13:36:34.067]                 }
[13:36:34.067]                 {
[13:36:34.067]                   {
[13:36:34.067]                     NULL
[13:36:34.067]                     RNGkind("Mersenne-Twister")
[13:36:34.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.067]                       inherits = FALSE)
[13:36:34.067]                   }
[13:36:34.067]                   options(future.plan = NULL)
[13:36:34.067]                   if (is.na(NA_character_)) 
[13:36:34.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.067]                     .init = FALSE)
[13:36:34.067]                 }
[13:36:34.067]             }
[13:36:34.067]         }
[13:36:34.067]     })
[13:36:34.067]     if (TRUE) {
[13:36:34.067]         base::sink(type = "output", split = FALSE)
[13:36:34.067]         if (TRUE) {
[13:36:34.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.067]         }
[13:36:34.067]         else {
[13:36:34.067]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.067]         }
[13:36:34.067]         base::close(...future.stdout)
[13:36:34.067]         ...future.stdout <- NULL
[13:36:34.067]     }
[13:36:34.067]     ...future.result$conditions <- ...future.conditions
[13:36:34.067]     ...future.result$finished <- base::Sys.time()
[13:36:34.067]     ...future.result
[13:36:34.067] }
[13:36:34.069] plan(): Setting new future strategy stack:
[13:36:34.069] List of future strategies:
[13:36:34.069] 1. sequential:
[13:36:34.069]    - args: function (..., envir = parent.frame())
[13:36:34.069]    - tweaked: FALSE
[13:36:34.069]    - call: NULL
[13:36:34.069] plan(): nbrOfWorkers() = 1
[13:36:34.070] plan(): Setting new future strategy stack:
[13:36:34.070] List of future strategies:
[13:36:34.070] 1. sequential:
[13:36:34.070]    - args: function (..., envir = parent.frame())
[13:36:34.070]    - tweaked: FALSE
[13:36:34.070]    - call: plan(strategy)
[13:36:34.070] plan(): nbrOfWorkers() = 1
[13:36:34.071] SequentialFuture started (and completed)
[13:36:34.071] - Launch lazy future ... done
[13:36:34.071] run() for ‘SequentialFuture’ ... done
[13:36:34.071] getGlobalsAndPackages() ...
[13:36:34.071] Searching for globals...
[13:36:34.071] 
[13:36:34.071] Searching for globals ... DONE
[13:36:34.071] - globals: [0] <none>
[13:36:34.072] getGlobalsAndPackages() ... DONE
[13:36:34.072] run() for ‘Future’ ...
[13:36:34.072] - state: ‘created’
[13:36:34.072] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.074]   - Field: ‘label’
[13:36:34.074]   - Field: ‘local’
[13:36:34.074]   - Field: ‘owner’
[13:36:34.074]   - Field: ‘envir’
[13:36:34.074]   - Field: ‘packages’
[13:36:34.074]   - Field: ‘gc’
[13:36:34.074]   - Field: ‘conditions’
[13:36:34.074]   - Field: ‘expr’
[13:36:34.074]   - Field: ‘uuid’
[13:36:34.074]   - Field: ‘seed’
[13:36:34.075]   - Field: ‘version’
[13:36:34.075]   - Field: ‘result’
[13:36:34.075]   - Field: ‘asynchronous’
[13:36:34.075]   - Field: ‘calls’
[13:36:34.075]   - Field: ‘globals’
[13:36:34.075]   - Field: ‘stdout’
[13:36:34.075]   - Field: ‘earlySignal’
[13:36:34.075]   - Field: ‘lazy’
[13:36:34.075]   - Field: ‘state’
[13:36:34.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.075] - Launch lazy future ...
[13:36:34.076] Packages needed by the future expression (n = 0): <none>
[13:36:34.076] Packages needed by future strategies (n = 0): <none>
[13:36:34.076] {
[13:36:34.076]     {
[13:36:34.076]         {
[13:36:34.076]             ...future.startTime <- base::Sys.time()
[13:36:34.076]             {
[13:36:34.076]                 {
[13:36:34.076]                   {
[13:36:34.076]                     base::local({
[13:36:34.076]                       has_future <- base::requireNamespace("future", 
[13:36:34.076]                         quietly = TRUE)
[13:36:34.076]                       if (has_future) {
[13:36:34.076]                         ns <- base::getNamespace("future")
[13:36:34.076]                         version <- ns[[".package"]][["version"]]
[13:36:34.076]                         if (is.null(version)) 
[13:36:34.076]                           version <- utils::packageVersion("future")
[13:36:34.076]                       }
[13:36:34.076]                       else {
[13:36:34.076]                         version <- NULL
[13:36:34.076]                       }
[13:36:34.076]                       if (!has_future || version < "1.8.0") {
[13:36:34.076]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.076]                           "", base::R.version$version.string), 
[13:36:34.076]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.076]                             "release", "version")], collapse = " "), 
[13:36:34.076]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.076]                           info)
[13:36:34.076]                         info <- base::paste(info, collapse = "; ")
[13:36:34.076]                         if (!has_future) {
[13:36:34.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.076]                             info)
[13:36:34.076]                         }
[13:36:34.076]                         else {
[13:36:34.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.076]                             info, version)
[13:36:34.076]                         }
[13:36:34.076]                         base::stop(msg)
[13:36:34.076]                       }
[13:36:34.076]                     })
[13:36:34.076]                   }
[13:36:34.076]                   ...future.strategy.old <- future::plan("list")
[13:36:34.076]                   options(future.plan = NULL)
[13:36:34.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.076]                 }
[13:36:34.076]                 ...future.workdir <- getwd()
[13:36:34.076]             }
[13:36:34.076]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.076]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.076]         }
[13:36:34.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.076]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.076]             base::names(...future.oldOptions))
[13:36:34.076]     }
[13:36:34.076]     if (FALSE) {
[13:36:34.076]     }
[13:36:34.076]     else {
[13:36:34.076]         if (TRUE) {
[13:36:34.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.076]                 open = "w")
[13:36:34.076]         }
[13:36:34.076]         else {
[13:36:34.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.076]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.076]         }
[13:36:34.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.076]             base::sink(type = "output", split = FALSE)
[13:36:34.076]             base::close(...future.stdout)
[13:36:34.076]         }, add = TRUE)
[13:36:34.076]     }
[13:36:34.076]     ...future.frame <- base::sys.nframe()
[13:36:34.076]     ...future.conditions <- base::list()
[13:36:34.076]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.076]     if (FALSE) {
[13:36:34.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.076]     }
[13:36:34.076]     ...future.result <- base::tryCatch({
[13:36:34.076]         base::withCallingHandlers({
[13:36:34.076]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.076]             future::FutureResult(value = ...future.value$value, 
[13:36:34.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.076]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.076]                     ...future.globalenv.names))
[13:36:34.076]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.076]         }, condition = base::local({
[13:36:34.076]             c <- base::c
[13:36:34.076]             inherits <- base::inherits
[13:36:34.076]             invokeRestart <- base::invokeRestart
[13:36:34.076]             length <- base::length
[13:36:34.076]             list <- base::list
[13:36:34.076]             seq.int <- base::seq.int
[13:36:34.076]             signalCondition <- base::signalCondition
[13:36:34.076]             sys.calls <- base::sys.calls
[13:36:34.076]             `[[` <- base::`[[`
[13:36:34.076]             `+` <- base::`+`
[13:36:34.076]             `<<-` <- base::`<<-`
[13:36:34.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.076]                   3L)]
[13:36:34.076]             }
[13:36:34.076]             function(cond) {
[13:36:34.076]                 is_error <- inherits(cond, "error")
[13:36:34.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.076]                   NULL)
[13:36:34.076]                 if (is_error) {
[13:36:34.076]                   sessionInformation <- function() {
[13:36:34.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.076]                       search = base::search(), system = base::Sys.info())
[13:36:34.076]                   }
[13:36:34.076]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.076]                     cond$call), session = sessionInformation(), 
[13:36:34.076]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.076]                   signalCondition(cond)
[13:36:34.076]                 }
[13:36:34.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.076]                 "immediateCondition"))) {
[13:36:34.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.076]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.076]                   if (TRUE && !signal) {
[13:36:34.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.076]                     {
[13:36:34.076]                       inherits <- base::inherits
[13:36:34.076]                       invokeRestart <- base::invokeRestart
[13:36:34.076]                       is.null <- base::is.null
[13:36:34.076]                       muffled <- FALSE
[13:36:34.076]                       if (inherits(cond, "message")) {
[13:36:34.076]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.076]                         if (muffled) 
[13:36:34.076]                           invokeRestart("muffleMessage")
[13:36:34.076]                       }
[13:36:34.076]                       else if (inherits(cond, "warning")) {
[13:36:34.076]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.076]                         if (muffled) 
[13:36:34.076]                           invokeRestart("muffleWarning")
[13:36:34.076]                       }
[13:36:34.076]                       else if (inherits(cond, "condition")) {
[13:36:34.076]                         if (!is.null(pattern)) {
[13:36:34.076]                           computeRestarts <- base::computeRestarts
[13:36:34.076]                           grepl <- base::grepl
[13:36:34.076]                           restarts <- computeRestarts(cond)
[13:36:34.076]                           for (restart in restarts) {
[13:36:34.076]                             name <- restart$name
[13:36:34.076]                             if (is.null(name)) 
[13:36:34.076]                               next
[13:36:34.076]                             if (!grepl(pattern, name)) 
[13:36:34.076]                               next
[13:36:34.076]                             invokeRestart(restart)
[13:36:34.076]                             muffled <- TRUE
[13:36:34.076]                             break
[13:36:34.076]                           }
[13:36:34.076]                         }
[13:36:34.076]                       }
[13:36:34.076]                       invisible(muffled)
[13:36:34.076]                     }
[13:36:34.076]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.076]                   }
[13:36:34.076]                 }
[13:36:34.076]                 else {
[13:36:34.076]                   if (TRUE) {
[13:36:34.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.076]                     {
[13:36:34.076]                       inherits <- base::inherits
[13:36:34.076]                       invokeRestart <- base::invokeRestart
[13:36:34.076]                       is.null <- base::is.null
[13:36:34.076]                       muffled <- FALSE
[13:36:34.076]                       if (inherits(cond, "message")) {
[13:36:34.076]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.076]                         if (muffled) 
[13:36:34.076]                           invokeRestart("muffleMessage")
[13:36:34.076]                       }
[13:36:34.076]                       else if (inherits(cond, "warning")) {
[13:36:34.076]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.076]                         if (muffled) 
[13:36:34.076]                           invokeRestart("muffleWarning")
[13:36:34.076]                       }
[13:36:34.076]                       else if (inherits(cond, "condition")) {
[13:36:34.076]                         if (!is.null(pattern)) {
[13:36:34.076]                           computeRestarts <- base::computeRestarts
[13:36:34.076]                           grepl <- base::grepl
[13:36:34.076]                           restarts <- computeRestarts(cond)
[13:36:34.076]                           for (restart in restarts) {
[13:36:34.076]                             name <- restart$name
[13:36:34.076]                             if (is.null(name)) 
[13:36:34.076]                               next
[13:36:34.076]                             if (!grepl(pattern, name)) 
[13:36:34.076]                               next
[13:36:34.076]                             invokeRestart(restart)
[13:36:34.076]                             muffled <- TRUE
[13:36:34.076]                             break
[13:36:34.076]                           }
[13:36:34.076]                         }
[13:36:34.076]                       }
[13:36:34.076]                       invisible(muffled)
[13:36:34.076]                     }
[13:36:34.076]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.076]                   }
[13:36:34.076]                 }
[13:36:34.076]             }
[13:36:34.076]         }))
[13:36:34.076]     }, error = function(ex) {
[13:36:34.076]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.076]                 ...future.rng), started = ...future.startTime, 
[13:36:34.076]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.076]             version = "1.8"), class = "FutureResult")
[13:36:34.076]     }, finally = {
[13:36:34.076]         if (!identical(...future.workdir, getwd())) 
[13:36:34.076]             setwd(...future.workdir)
[13:36:34.076]         {
[13:36:34.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.076]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.076]             }
[13:36:34.076]             base::options(...future.oldOptions)
[13:36:34.076]             if (.Platform$OS.type == "windows") {
[13:36:34.076]                 old_names <- names(...future.oldEnvVars)
[13:36:34.076]                 envs <- base::Sys.getenv()
[13:36:34.076]                 names <- names(envs)
[13:36:34.076]                 common <- intersect(names, old_names)
[13:36:34.076]                 added <- setdiff(names, old_names)
[13:36:34.076]                 removed <- setdiff(old_names, names)
[13:36:34.076]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.076]                   envs[common]]
[13:36:34.076]                 NAMES <- toupper(changed)
[13:36:34.076]                 args <- list()
[13:36:34.076]                 for (kk in seq_along(NAMES)) {
[13:36:34.076]                   name <- changed[[kk]]
[13:36:34.076]                   NAME <- NAMES[[kk]]
[13:36:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.076]                     next
[13:36:34.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.076]                 }
[13:36:34.076]                 NAMES <- toupper(added)
[13:36:34.076]                 for (kk in seq_along(NAMES)) {
[13:36:34.076]                   name <- added[[kk]]
[13:36:34.076]                   NAME <- NAMES[[kk]]
[13:36:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.076]                     next
[13:36:34.076]                   args[[name]] <- ""
[13:36:34.076]                 }
[13:36:34.076]                 NAMES <- toupper(removed)
[13:36:34.076]                 for (kk in seq_along(NAMES)) {
[13:36:34.076]                   name <- removed[[kk]]
[13:36:34.076]                   NAME <- NAMES[[kk]]
[13:36:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.076]                     next
[13:36:34.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.076]                 }
[13:36:34.076]                 if (length(args) > 0) 
[13:36:34.076]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.076]             }
[13:36:34.076]             else {
[13:36:34.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.076]             }
[13:36:34.076]             {
[13:36:34.076]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.076]                   0L) {
[13:36:34.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.076]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.076]                   base::options(opts)
[13:36:34.076]                 }
[13:36:34.076]                 {
[13:36:34.076]                   {
[13:36:34.076]                     NULL
[13:36:34.076]                     RNGkind("Mersenne-Twister")
[13:36:34.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.076]                       inherits = FALSE)
[13:36:34.076]                   }
[13:36:34.076]                   options(future.plan = NULL)
[13:36:34.076]                   if (is.na(NA_character_)) 
[13:36:34.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.076]                     .init = FALSE)
[13:36:34.076]                 }
[13:36:34.076]             }
[13:36:34.076]         }
[13:36:34.076]     })
[13:36:34.076]     if (TRUE) {
[13:36:34.076]         base::sink(type = "output", split = FALSE)
[13:36:34.076]         if (TRUE) {
[13:36:34.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.076]         }
[13:36:34.076]         else {
[13:36:34.076]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.076]         }
[13:36:34.076]         base::close(...future.stdout)
[13:36:34.076]         ...future.stdout <- NULL
[13:36:34.076]     }
[13:36:34.076]     ...future.result$conditions <- ...future.conditions
[13:36:34.076]     ...future.result$finished <- base::Sys.time()
[13:36:34.076]     ...future.result
[13:36:34.076] }
[13:36:34.078] plan(): Setting new future strategy stack:
[13:36:34.078] List of future strategies:
[13:36:34.078] 1. sequential:
[13:36:34.078]    - args: function (..., envir = parent.frame())
[13:36:34.078]    - tweaked: FALSE
[13:36:34.078]    - call: NULL
[13:36:34.078] plan(): nbrOfWorkers() = 1
[13:36:34.079] plan(): Setting new future strategy stack:
[13:36:34.079] List of future strategies:
[13:36:34.079] 1. sequential:
[13:36:34.079]    - args: function (..., envir = parent.frame())
[13:36:34.079]    - tweaked: FALSE
[13:36:34.079]    - call: plan(strategy)
[13:36:34.079] plan(): nbrOfWorkers() = 1
[13:36:34.079] SequentialFuture started (and completed)
[13:36:34.080] - Launch lazy future ... done
[13:36:34.080] run() for ‘SequentialFuture’ ... done
[13:36:34.080] getGlobalsAndPackages() ...
[13:36:34.080] Searching for globals...
[13:36:34.081] - globals found: [1] ‘{’
[13:36:34.081] Searching for globals ... DONE
[13:36:34.081] Resolving globals: FALSE
[13:36:34.081] 
[13:36:34.081] 
[13:36:34.081] getGlobalsAndPackages() ... DONE
[13:36:34.081] run() for ‘Future’ ...
[13:36:34.081] - state: ‘created’
[13:36:34.082] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.082] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.082]   - Field: ‘label’
[13:36:34.082]   - Field: ‘local’
[13:36:34.082]   - Field: ‘owner’
[13:36:34.082]   - Field: ‘envir’
[13:36:34.082]   - Field: ‘packages’
[13:36:34.082]   - Field: ‘gc’
[13:36:34.083]   - Field: ‘conditions’
[13:36:34.083]   - Field: ‘expr’
[13:36:34.083]   - Field: ‘uuid’
[13:36:34.083]   - Field: ‘seed’
[13:36:34.083]   - Field: ‘version’
[13:36:34.083]   - Field: ‘result’
[13:36:34.083]   - Field: ‘asynchronous’
[13:36:34.083]   - Field: ‘calls’
[13:36:34.083]   - Field: ‘globals’
[13:36:34.083]   - Field: ‘stdout’
[13:36:34.083]   - Field: ‘earlySignal’
[13:36:34.084]   - Field: ‘lazy’
[13:36:34.084]   - Field: ‘state’
[13:36:34.084] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.084] - Launch lazy future ...
[13:36:34.084] Packages needed by the future expression (n = 0): <none>
[13:36:34.084] Packages needed by future strategies (n = 0): <none>
[13:36:34.084] {
[13:36:34.084]     {
[13:36:34.084]         {
[13:36:34.084]             ...future.startTime <- base::Sys.time()
[13:36:34.084]             {
[13:36:34.084]                 {
[13:36:34.084]                   {
[13:36:34.084]                     base::local({
[13:36:34.084]                       has_future <- base::requireNamespace("future", 
[13:36:34.084]                         quietly = TRUE)
[13:36:34.084]                       if (has_future) {
[13:36:34.084]                         ns <- base::getNamespace("future")
[13:36:34.084]                         version <- ns[[".package"]][["version"]]
[13:36:34.084]                         if (is.null(version)) 
[13:36:34.084]                           version <- utils::packageVersion("future")
[13:36:34.084]                       }
[13:36:34.084]                       else {
[13:36:34.084]                         version <- NULL
[13:36:34.084]                       }
[13:36:34.084]                       if (!has_future || version < "1.8.0") {
[13:36:34.084]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.084]                           "", base::R.version$version.string), 
[13:36:34.084]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.084]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.084]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.084]                             "release", "version")], collapse = " "), 
[13:36:34.084]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.084]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.084]                           info)
[13:36:34.084]                         info <- base::paste(info, collapse = "; ")
[13:36:34.084]                         if (!has_future) {
[13:36:34.084]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.084]                             info)
[13:36:34.084]                         }
[13:36:34.084]                         else {
[13:36:34.084]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.084]                             info, version)
[13:36:34.084]                         }
[13:36:34.084]                         base::stop(msg)
[13:36:34.084]                       }
[13:36:34.084]                     })
[13:36:34.084]                   }
[13:36:34.084]                   ...future.strategy.old <- future::plan("list")
[13:36:34.084]                   options(future.plan = NULL)
[13:36:34.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.084]                 }
[13:36:34.084]                 ...future.workdir <- getwd()
[13:36:34.084]             }
[13:36:34.084]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.084]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.084]         }
[13:36:34.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.084]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.084]             base::names(...future.oldOptions))
[13:36:34.084]     }
[13:36:34.084]     if (FALSE) {
[13:36:34.084]     }
[13:36:34.084]     else {
[13:36:34.084]         if (TRUE) {
[13:36:34.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.084]                 open = "w")
[13:36:34.084]         }
[13:36:34.084]         else {
[13:36:34.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.084]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.084]         }
[13:36:34.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.084]             base::sink(type = "output", split = FALSE)
[13:36:34.084]             base::close(...future.stdout)
[13:36:34.084]         }, add = TRUE)
[13:36:34.084]     }
[13:36:34.084]     ...future.frame <- base::sys.nframe()
[13:36:34.084]     ...future.conditions <- base::list()
[13:36:34.084]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.084]     if (FALSE) {
[13:36:34.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.084]     }
[13:36:34.084]     ...future.result <- base::tryCatch({
[13:36:34.084]         base::withCallingHandlers({
[13:36:34.084]             ...future.value <- base::withVisible(base::local({
[13:36:34.084]                 4
[13:36:34.084]             }))
[13:36:34.084]             future::FutureResult(value = ...future.value$value, 
[13:36:34.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.084]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.084]                     ...future.globalenv.names))
[13:36:34.084]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.084]         }, condition = base::local({
[13:36:34.084]             c <- base::c
[13:36:34.084]             inherits <- base::inherits
[13:36:34.084]             invokeRestart <- base::invokeRestart
[13:36:34.084]             length <- base::length
[13:36:34.084]             list <- base::list
[13:36:34.084]             seq.int <- base::seq.int
[13:36:34.084]             signalCondition <- base::signalCondition
[13:36:34.084]             sys.calls <- base::sys.calls
[13:36:34.084]             `[[` <- base::`[[`
[13:36:34.084]             `+` <- base::`+`
[13:36:34.084]             `<<-` <- base::`<<-`
[13:36:34.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.084]                   3L)]
[13:36:34.084]             }
[13:36:34.084]             function(cond) {
[13:36:34.084]                 is_error <- inherits(cond, "error")
[13:36:34.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.084]                   NULL)
[13:36:34.084]                 if (is_error) {
[13:36:34.084]                   sessionInformation <- function() {
[13:36:34.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.084]                       search = base::search(), system = base::Sys.info())
[13:36:34.084]                   }
[13:36:34.084]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.084]                     cond$call), session = sessionInformation(), 
[13:36:34.084]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.084]                   signalCondition(cond)
[13:36:34.084]                 }
[13:36:34.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.084]                 "immediateCondition"))) {
[13:36:34.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.084]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.084]                   if (TRUE && !signal) {
[13:36:34.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.084]                     {
[13:36:34.084]                       inherits <- base::inherits
[13:36:34.084]                       invokeRestart <- base::invokeRestart
[13:36:34.084]                       is.null <- base::is.null
[13:36:34.084]                       muffled <- FALSE
[13:36:34.084]                       if (inherits(cond, "message")) {
[13:36:34.084]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.084]                         if (muffled) 
[13:36:34.084]                           invokeRestart("muffleMessage")
[13:36:34.084]                       }
[13:36:34.084]                       else if (inherits(cond, "warning")) {
[13:36:34.084]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.084]                         if (muffled) 
[13:36:34.084]                           invokeRestart("muffleWarning")
[13:36:34.084]                       }
[13:36:34.084]                       else if (inherits(cond, "condition")) {
[13:36:34.084]                         if (!is.null(pattern)) {
[13:36:34.084]                           computeRestarts <- base::computeRestarts
[13:36:34.084]                           grepl <- base::grepl
[13:36:34.084]                           restarts <- computeRestarts(cond)
[13:36:34.084]                           for (restart in restarts) {
[13:36:34.084]                             name <- restart$name
[13:36:34.084]                             if (is.null(name)) 
[13:36:34.084]                               next
[13:36:34.084]                             if (!grepl(pattern, name)) 
[13:36:34.084]                               next
[13:36:34.084]                             invokeRestart(restart)
[13:36:34.084]                             muffled <- TRUE
[13:36:34.084]                             break
[13:36:34.084]                           }
[13:36:34.084]                         }
[13:36:34.084]                       }
[13:36:34.084]                       invisible(muffled)
[13:36:34.084]                     }
[13:36:34.084]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.084]                   }
[13:36:34.084]                 }
[13:36:34.084]                 else {
[13:36:34.084]                   if (TRUE) {
[13:36:34.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.084]                     {
[13:36:34.084]                       inherits <- base::inherits
[13:36:34.084]                       invokeRestart <- base::invokeRestart
[13:36:34.084]                       is.null <- base::is.null
[13:36:34.084]                       muffled <- FALSE
[13:36:34.084]                       if (inherits(cond, "message")) {
[13:36:34.084]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.084]                         if (muffled) 
[13:36:34.084]                           invokeRestart("muffleMessage")
[13:36:34.084]                       }
[13:36:34.084]                       else if (inherits(cond, "warning")) {
[13:36:34.084]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.084]                         if (muffled) 
[13:36:34.084]                           invokeRestart("muffleWarning")
[13:36:34.084]                       }
[13:36:34.084]                       else if (inherits(cond, "condition")) {
[13:36:34.084]                         if (!is.null(pattern)) {
[13:36:34.084]                           computeRestarts <- base::computeRestarts
[13:36:34.084]                           grepl <- base::grepl
[13:36:34.084]                           restarts <- computeRestarts(cond)
[13:36:34.084]                           for (restart in restarts) {
[13:36:34.084]                             name <- restart$name
[13:36:34.084]                             if (is.null(name)) 
[13:36:34.084]                               next
[13:36:34.084]                             if (!grepl(pattern, name)) 
[13:36:34.084]                               next
[13:36:34.084]                             invokeRestart(restart)
[13:36:34.084]                             muffled <- TRUE
[13:36:34.084]                             break
[13:36:34.084]                           }
[13:36:34.084]                         }
[13:36:34.084]                       }
[13:36:34.084]                       invisible(muffled)
[13:36:34.084]                     }
[13:36:34.084]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.084]                   }
[13:36:34.084]                 }
[13:36:34.084]             }
[13:36:34.084]         }))
[13:36:34.084]     }, error = function(ex) {
[13:36:34.084]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.084]                 ...future.rng), started = ...future.startTime, 
[13:36:34.084]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.084]             version = "1.8"), class = "FutureResult")
[13:36:34.084]     }, finally = {
[13:36:34.084]         if (!identical(...future.workdir, getwd())) 
[13:36:34.084]             setwd(...future.workdir)
[13:36:34.084]         {
[13:36:34.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.084]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.084]             }
[13:36:34.084]             base::options(...future.oldOptions)
[13:36:34.084]             if (.Platform$OS.type == "windows") {
[13:36:34.084]                 old_names <- names(...future.oldEnvVars)
[13:36:34.084]                 envs <- base::Sys.getenv()
[13:36:34.084]                 names <- names(envs)
[13:36:34.084]                 common <- intersect(names, old_names)
[13:36:34.084]                 added <- setdiff(names, old_names)
[13:36:34.084]                 removed <- setdiff(old_names, names)
[13:36:34.084]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.084]                   envs[common]]
[13:36:34.084]                 NAMES <- toupper(changed)
[13:36:34.084]                 args <- list()
[13:36:34.084]                 for (kk in seq_along(NAMES)) {
[13:36:34.084]                   name <- changed[[kk]]
[13:36:34.084]                   NAME <- NAMES[[kk]]
[13:36:34.084]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.084]                     next
[13:36:34.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.084]                 }
[13:36:34.084]                 NAMES <- toupper(added)
[13:36:34.084]                 for (kk in seq_along(NAMES)) {
[13:36:34.084]                   name <- added[[kk]]
[13:36:34.084]                   NAME <- NAMES[[kk]]
[13:36:34.084]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.084]                     next
[13:36:34.084]                   args[[name]] <- ""
[13:36:34.084]                 }
[13:36:34.084]                 NAMES <- toupper(removed)
[13:36:34.084]                 for (kk in seq_along(NAMES)) {
[13:36:34.084]                   name <- removed[[kk]]
[13:36:34.084]                   NAME <- NAMES[[kk]]
[13:36:34.084]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.084]                     next
[13:36:34.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.084]                 }
[13:36:34.084]                 if (length(args) > 0) 
[13:36:34.084]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.084]             }
[13:36:34.084]             else {
[13:36:34.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.084]             }
[13:36:34.084]             {
[13:36:34.084]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.084]                   0L) {
[13:36:34.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.084]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.084]                   base::options(opts)
[13:36:34.084]                 }
[13:36:34.084]                 {
[13:36:34.084]                   {
[13:36:34.084]                     NULL
[13:36:34.084]                     RNGkind("Mersenne-Twister")
[13:36:34.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.084]                       inherits = FALSE)
[13:36:34.084]                   }
[13:36:34.084]                   options(future.plan = NULL)
[13:36:34.084]                   if (is.na(NA_character_)) 
[13:36:34.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.084]                     .init = FALSE)
[13:36:34.084]                 }
[13:36:34.084]             }
[13:36:34.084]         }
[13:36:34.084]     })
[13:36:34.084]     if (TRUE) {
[13:36:34.084]         base::sink(type = "output", split = FALSE)
[13:36:34.084]         if (TRUE) {
[13:36:34.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.084]         }
[13:36:34.084]         else {
[13:36:34.084]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.084]         }
[13:36:34.084]         base::close(...future.stdout)
[13:36:34.084]         ...future.stdout <- NULL
[13:36:34.084]     }
[13:36:34.084]     ...future.result$conditions <- ...future.conditions
[13:36:34.084]     ...future.result$finished <- base::Sys.time()
[13:36:34.084]     ...future.result
[13:36:34.084] }
[13:36:34.086] plan(): Setting new future strategy stack:
[13:36:34.086] List of future strategies:
[13:36:34.086] 1. sequential:
[13:36:34.086]    - args: function (..., envir = parent.frame())
[13:36:34.086]    - tweaked: FALSE
[13:36:34.086]    - call: NULL
[13:36:34.087] plan(): nbrOfWorkers() = 1
[13:36:34.087] plan(): Setting new future strategy stack:
[13:36:34.087] List of future strategies:
[13:36:34.087] 1. sequential:
[13:36:34.087]    - args: function (..., envir = parent.frame())
[13:36:34.087]    - tweaked: FALSE
[13:36:34.087]    - call: plan(strategy)
[13:36:34.088] plan(): nbrOfWorkers() = 1
[13:36:34.088] SequentialFuture started (and completed)
[13:36:34.088] - Launch lazy future ... done
[13:36:34.088] run() for ‘SequentialFuture’ ... done
<environment: 0x564a731469c8> 
<environment: 0x564a730024e8> 
[13:36:34.089] resolved() for ‘SequentialFuture’ ...
[13:36:34.089] - state: ‘finished’
[13:36:34.089] - run: TRUE
[13:36:34.089] - result: ‘FutureResult’
[13:36:34.089] resolved() for ‘SequentialFuture’ ... done
[13:36:34.090] resolved() for ‘SequentialFuture’ ...
[13:36:34.090] - state: ‘finished’
[13:36:34.090] - run: TRUE
[13:36:34.090] - result: ‘FutureResult’
[13:36:34.090] resolved() for ‘SequentialFuture’ ... done
[13:36:34.090] resolved() for ‘SequentialFuture’ ...
[13:36:34.090] - state: ‘finished’
[13:36:34.090] - run: TRUE
[13:36:34.090] - result: ‘FutureResult’
[13:36:34.090] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:34.091] resolve() on environment ...
[13:36:34.092]  recursive: 0
[13:36:34.092]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:34.092] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.092] - nx: 4
[13:36:34.092] - relay: TRUE
[13:36:34.092] - stdout: TRUE
[13:36:34.092] - signal: TRUE
[13:36:34.093] - resignal: FALSE
[13:36:34.093] - force: TRUE
[13:36:34.093] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.093] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.093]  - until=2
[13:36:34.093]  - relaying element #2
[13:36:34.093] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.093] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.093] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.093]  length: 3 (resolved future 1)
[13:36:34.093] resolved() for ‘SequentialFuture’ ...
[13:36:34.093] - state: ‘finished’
[13:36:34.094] - run: TRUE
[13:36:34.094] - result: ‘FutureResult’
[13:36:34.094] resolved() for ‘SequentialFuture’ ... done
[13:36:34.094] Future #2
[13:36:34.094] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.094] - nx: 4
[13:36:34.094] - relay: TRUE
[13:36:34.094] - stdout: TRUE
[13:36:34.094] - signal: TRUE
[13:36:34.094] - resignal: FALSE
[13:36:34.094] - force: TRUE
[13:36:34.095] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.095] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.095]  - until=2
[13:36:34.095]  - relaying element #2
[13:36:34.095] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.095] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.095] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.095]  length: 2 (resolved future 2)
[13:36:34.095] resolved() for ‘SequentialFuture’ ...
[13:36:34.095] - state: ‘finished’
[13:36:34.096] - run: TRUE
[13:36:34.096] - result: ‘FutureResult’
[13:36:34.096] resolved() for ‘SequentialFuture’ ... done
[13:36:34.096] Future #3
[13:36:34.096] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.096] - nx: 4
[13:36:34.096] - relay: TRUE
[13:36:34.096] - stdout: TRUE
[13:36:34.096] - signal: TRUE
[13:36:34.096] - resignal: FALSE
[13:36:34.096] - force: TRUE
[13:36:34.096] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.097] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.097]  - until=3
[13:36:34.097]  - relaying element #3
[13:36:34.097] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.097] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.097] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.097]  length: 1 (resolved future 3)
[13:36:34.097] resolved() for ‘SequentialFuture’ ...
[13:36:34.097] - state: ‘finished’
[13:36:34.097] - run: TRUE
[13:36:34.098] - result: ‘FutureResult’
[13:36:34.098] resolved() for ‘SequentialFuture’ ... done
[13:36:34.099] Future #4
[13:36:34.099] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.099] - nx: 4
[13:36:34.099] - relay: TRUE
[13:36:34.100] - stdout: TRUE
[13:36:34.100] - signal: TRUE
[13:36:34.100] - resignal: FALSE
[13:36:34.100] - force: TRUE
[13:36:34.100] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.100] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.100]  - until=4
[13:36:34.100]  - relaying element #4
[13:36:34.100] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.100] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.100] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.101]  length: 0 (resolved future 4)
[13:36:34.101] Relaying remaining futures
[13:36:34.101] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.101] - nx: 4
[13:36:34.101] - relay: TRUE
[13:36:34.101] - stdout: TRUE
[13:36:34.101] - signal: TRUE
[13:36:34.101] - resignal: FALSE
[13:36:34.101] - force: TRUE
[13:36:34.101] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.101] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:34.102] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.102] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.102] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.102] resolve() on environment ... DONE
<environment: 0x564a731b0868> 
Dimensions: c(2, 1, 3, 1)
[13:36:34.102] getGlobalsAndPackages() ...
[13:36:34.102] Searching for globals...
[13:36:34.103] 
[13:36:34.103] Searching for globals ... DONE
[13:36:34.103] - globals: [0] <none>
[13:36:34.103] getGlobalsAndPackages() ... DONE
[13:36:34.103] run() for ‘Future’ ...
[13:36:34.103] - state: ‘created’
[13:36:34.103] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.104] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.104]   - Field: ‘label’
[13:36:34.104]   - Field: ‘local’
[13:36:34.104]   - Field: ‘owner’
[13:36:34.104]   - Field: ‘envir’
[13:36:34.104]   - Field: ‘packages’
[13:36:34.104]   - Field: ‘gc’
[13:36:34.104]   - Field: ‘conditions’
[13:36:34.104]   - Field: ‘expr’
[13:36:34.105]   - Field: ‘uuid’
[13:36:34.105]   - Field: ‘seed’
[13:36:34.105]   - Field: ‘version’
[13:36:34.105]   - Field: ‘result’
[13:36:34.105]   - Field: ‘asynchronous’
[13:36:34.105]   - Field: ‘calls’
[13:36:34.105]   - Field: ‘globals’
[13:36:34.105]   - Field: ‘stdout’
[13:36:34.105]   - Field: ‘earlySignal’
[13:36:34.105]   - Field: ‘lazy’
[13:36:34.105]   - Field: ‘state’
[13:36:34.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.106] - Launch lazy future ...
[13:36:34.106] Packages needed by the future expression (n = 0): <none>
[13:36:34.106] Packages needed by future strategies (n = 0): <none>
[13:36:34.106] {
[13:36:34.106]     {
[13:36:34.106]         {
[13:36:34.106]             ...future.startTime <- base::Sys.time()
[13:36:34.106]             {
[13:36:34.106]                 {
[13:36:34.106]                   {
[13:36:34.106]                     base::local({
[13:36:34.106]                       has_future <- base::requireNamespace("future", 
[13:36:34.106]                         quietly = TRUE)
[13:36:34.106]                       if (has_future) {
[13:36:34.106]                         ns <- base::getNamespace("future")
[13:36:34.106]                         version <- ns[[".package"]][["version"]]
[13:36:34.106]                         if (is.null(version)) 
[13:36:34.106]                           version <- utils::packageVersion("future")
[13:36:34.106]                       }
[13:36:34.106]                       else {
[13:36:34.106]                         version <- NULL
[13:36:34.106]                       }
[13:36:34.106]                       if (!has_future || version < "1.8.0") {
[13:36:34.106]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.106]                           "", base::R.version$version.string), 
[13:36:34.106]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.106]                             "release", "version")], collapse = " "), 
[13:36:34.106]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.106]                           info)
[13:36:34.106]                         info <- base::paste(info, collapse = "; ")
[13:36:34.106]                         if (!has_future) {
[13:36:34.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.106]                             info)
[13:36:34.106]                         }
[13:36:34.106]                         else {
[13:36:34.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.106]                             info, version)
[13:36:34.106]                         }
[13:36:34.106]                         base::stop(msg)
[13:36:34.106]                       }
[13:36:34.106]                     })
[13:36:34.106]                   }
[13:36:34.106]                   ...future.strategy.old <- future::plan("list")
[13:36:34.106]                   options(future.plan = NULL)
[13:36:34.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.106]                 }
[13:36:34.106]                 ...future.workdir <- getwd()
[13:36:34.106]             }
[13:36:34.106]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.106]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.106]         }
[13:36:34.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.106]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.106]             base::names(...future.oldOptions))
[13:36:34.106]     }
[13:36:34.106]     if (FALSE) {
[13:36:34.106]     }
[13:36:34.106]     else {
[13:36:34.106]         if (TRUE) {
[13:36:34.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.106]                 open = "w")
[13:36:34.106]         }
[13:36:34.106]         else {
[13:36:34.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.106]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.106]         }
[13:36:34.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.106]             base::sink(type = "output", split = FALSE)
[13:36:34.106]             base::close(...future.stdout)
[13:36:34.106]         }, add = TRUE)
[13:36:34.106]     }
[13:36:34.106]     ...future.frame <- base::sys.nframe()
[13:36:34.106]     ...future.conditions <- base::list()
[13:36:34.106]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.106]     if (FALSE) {
[13:36:34.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.106]     }
[13:36:34.106]     ...future.result <- base::tryCatch({
[13:36:34.106]         base::withCallingHandlers({
[13:36:34.106]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.106]             future::FutureResult(value = ...future.value$value, 
[13:36:34.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.106]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.106]                     ...future.globalenv.names))
[13:36:34.106]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.106]         }, condition = base::local({
[13:36:34.106]             c <- base::c
[13:36:34.106]             inherits <- base::inherits
[13:36:34.106]             invokeRestart <- base::invokeRestart
[13:36:34.106]             length <- base::length
[13:36:34.106]             list <- base::list
[13:36:34.106]             seq.int <- base::seq.int
[13:36:34.106]             signalCondition <- base::signalCondition
[13:36:34.106]             sys.calls <- base::sys.calls
[13:36:34.106]             `[[` <- base::`[[`
[13:36:34.106]             `+` <- base::`+`
[13:36:34.106]             `<<-` <- base::`<<-`
[13:36:34.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.106]                   3L)]
[13:36:34.106]             }
[13:36:34.106]             function(cond) {
[13:36:34.106]                 is_error <- inherits(cond, "error")
[13:36:34.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.106]                   NULL)
[13:36:34.106]                 if (is_error) {
[13:36:34.106]                   sessionInformation <- function() {
[13:36:34.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.106]                       search = base::search(), system = base::Sys.info())
[13:36:34.106]                   }
[13:36:34.106]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.106]                     cond$call), session = sessionInformation(), 
[13:36:34.106]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.106]                   signalCondition(cond)
[13:36:34.106]                 }
[13:36:34.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.106]                 "immediateCondition"))) {
[13:36:34.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.106]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.106]                   if (TRUE && !signal) {
[13:36:34.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.106]                     {
[13:36:34.106]                       inherits <- base::inherits
[13:36:34.106]                       invokeRestart <- base::invokeRestart
[13:36:34.106]                       is.null <- base::is.null
[13:36:34.106]                       muffled <- FALSE
[13:36:34.106]                       if (inherits(cond, "message")) {
[13:36:34.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.106]                         if (muffled) 
[13:36:34.106]                           invokeRestart("muffleMessage")
[13:36:34.106]                       }
[13:36:34.106]                       else if (inherits(cond, "warning")) {
[13:36:34.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.106]                         if (muffled) 
[13:36:34.106]                           invokeRestart("muffleWarning")
[13:36:34.106]                       }
[13:36:34.106]                       else if (inherits(cond, "condition")) {
[13:36:34.106]                         if (!is.null(pattern)) {
[13:36:34.106]                           computeRestarts <- base::computeRestarts
[13:36:34.106]                           grepl <- base::grepl
[13:36:34.106]                           restarts <- computeRestarts(cond)
[13:36:34.106]                           for (restart in restarts) {
[13:36:34.106]                             name <- restart$name
[13:36:34.106]                             if (is.null(name)) 
[13:36:34.106]                               next
[13:36:34.106]                             if (!grepl(pattern, name)) 
[13:36:34.106]                               next
[13:36:34.106]                             invokeRestart(restart)
[13:36:34.106]                             muffled <- TRUE
[13:36:34.106]                             break
[13:36:34.106]                           }
[13:36:34.106]                         }
[13:36:34.106]                       }
[13:36:34.106]                       invisible(muffled)
[13:36:34.106]                     }
[13:36:34.106]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.106]                   }
[13:36:34.106]                 }
[13:36:34.106]                 else {
[13:36:34.106]                   if (TRUE) {
[13:36:34.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.106]                     {
[13:36:34.106]                       inherits <- base::inherits
[13:36:34.106]                       invokeRestart <- base::invokeRestart
[13:36:34.106]                       is.null <- base::is.null
[13:36:34.106]                       muffled <- FALSE
[13:36:34.106]                       if (inherits(cond, "message")) {
[13:36:34.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.106]                         if (muffled) 
[13:36:34.106]                           invokeRestart("muffleMessage")
[13:36:34.106]                       }
[13:36:34.106]                       else if (inherits(cond, "warning")) {
[13:36:34.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.106]                         if (muffled) 
[13:36:34.106]                           invokeRestart("muffleWarning")
[13:36:34.106]                       }
[13:36:34.106]                       else if (inherits(cond, "condition")) {
[13:36:34.106]                         if (!is.null(pattern)) {
[13:36:34.106]                           computeRestarts <- base::computeRestarts
[13:36:34.106]                           grepl <- base::grepl
[13:36:34.106]                           restarts <- computeRestarts(cond)
[13:36:34.106]                           for (restart in restarts) {
[13:36:34.106]                             name <- restart$name
[13:36:34.106]                             if (is.null(name)) 
[13:36:34.106]                               next
[13:36:34.106]                             if (!grepl(pattern, name)) 
[13:36:34.106]                               next
[13:36:34.106]                             invokeRestart(restart)
[13:36:34.106]                             muffled <- TRUE
[13:36:34.106]                             break
[13:36:34.106]                           }
[13:36:34.106]                         }
[13:36:34.106]                       }
[13:36:34.106]                       invisible(muffled)
[13:36:34.106]                     }
[13:36:34.106]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.106]                   }
[13:36:34.106]                 }
[13:36:34.106]             }
[13:36:34.106]         }))
[13:36:34.106]     }, error = function(ex) {
[13:36:34.106]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.106]                 ...future.rng), started = ...future.startTime, 
[13:36:34.106]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.106]             version = "1.8"), class = "FutureResult")
[13:36:34.106]     }, finally = {
[13:36:34.106]         if (!identical(...future.workdir, getwd())) 
[13:36:34.106]             setwd(...future.workdir)
[13:36:34.106]         {
[13:36:34.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.106]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.106]             }
[13:36:34.106]             base::options(...future.oldOptions)
[13:36:34.106]             if (.Platform$OS.type == "windows") {
[13:36:34.106]                 old_names <- names(...future.oldEnvVars)
[13:36:34.106]                 envs <- base::Sys.getenv()
[13:36:34.106]                 names <- names(envs)
[13:36:34.106]                 common <- intersect(names, old_names)
[13:36:34.106]                 added <- setdiff(names, old_names)
[13:36:34.106]                 removed <- setdiff(old_names, names)
[13:36:34.106]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.106]                   envs[common]]
[13:36:34.106]                 NAMES <- toupper(changed)
[13:36:34.106]                 args <- list()
[13:36:34.106]                 for (kk in seq_along(NAMES)) {
[13:36:34.106]                   name <- changed[[kk]]
[13:36:34.106]                   NAME <- NAMES[[kk]]
[13:36:34.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.106]                     next
[13:36:34.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.106]                 }
[13:36:34.106]                 NAMES <- toupper(added)
[13:36:34.106]                 for (kk in seq_along(NAMES)) {
[13:36:34.106]                   name <- added[[kk]]
[13:36:34.106]                   NAME <- NAMES[[kk]]
[13:36:34.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.106]                     next
[13:36:34.106]                   args[[name]] <- ""
[13:36:34.106]                 }
[13:36:34.106]                 NAMES <- toupper(removed)
[13:36:34.106]                 for (kk in seq_along(NAMES)) {
[13:36:34.106]                   name <- removed[[kk]]
[13:36:34.106]                   NAME <- NAMES[[kk]]
[13:36:34.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.106]                     next
[13:36:34.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.106]                 }
[13:36:34.106]                 if (length(args) > 0) 
[13:36:34.106]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.106]             }
[13:36:34.106]             else {
[13:36:34.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.106]             }
[13:36:34.106]             {
[13:36:34.106]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.106]                   0L) {
[13:36:34.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.106]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.106]                   base::options(opts)
[13:36:34.106]                 }
[13:36:34.106]                 {
[13:36:34.106]                   {
[13:36:34.106]                     NULL
[13:36:34.106]                     RNGkind("Mersenne-Twister")
[13:36:34.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.106]                       inherits = FALSE)
[13:36:34.106]                   }
[13:36:34.106]                   options(future.plan = NULL)
[13:36:34.106]                   if (is.na(NA_character_)) 
[13:36:34.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.106]                     .init = FALSE)
[13:36:34.106]                 }
[13:36:34.106]             }
[13:36:34.106]         }
[13:36:34.106]     })
[13:36:34.106]     if (TRUE) {
[13:36:34.106]         base::sink(type = "output", split = FALSE)
[13:36:34.106]         if (TRUE) {
[13:36:34.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.106]         }
[13:36:34.106]         else {
[13:36:34.106]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.106]         }
[13:36:34.106]         base::close(...future.stdout)
[13:36:34.106]         ...future.stdout <- NULL
[13:36:34.106]     }
[13:36:34.106]     ...future.result$conditions <- ...future.conditions
[13:36:34.106]     ...future.result$finished <- base::Sys.time()
[13:36:34.106]     ...future.result
[13:36:34.106] }
[13:36:34.108] plan(): Setting new future strategy stack:
[13:36:34.108] List of future strategies:
[13:36:34.108] 1. sequential:
[13:36:34.108]    - args: function (..., envir = parent.frame())
[13:36:34.108]    - tweaked: FALSE
[13:36:34.108]    - call: NULL
[13:36:34.108] plan(): nbrOfWorkers() = 1
[13:36:34.109] plan(): Setting new future strategy stack:
[13:36:34.109] List of future strategies:
[13:36:34.109] 1. sequential:
[13:36:34.109]    - args: function (..., envir = parent.frame())
[13:36:34.109]    - tweaked: FALSE
[13:36:34.109]    - call: plan(strategy)
[13:36:34.109] plan(): nbrOfWorkers() = 1
[13:36:34.110] SequentialFuture started (and completed)
[13:36:34.110] - Launch lazy future ... done
[13:36:34.110] run() for ‘SequentialFuture’ ... done
[13:36:34.110] getGlobalsAndPackages() ...
[13:36:34.110] Searching for globals...
[13:36:34.110] 
[13:36:34.110] Searching for globals ... DONE
[13:36:34.110] - globals: [0] <none>
[13:36:34.110] getGlobalsAndPackages() ... DONE
[13:36:34.111] run() for ‘Future’ ...
[13:36:34.111] - state: ‘created’
[13:36:34.111] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.111]   - Field: ‘label’
[13:36:34.111]   - Field: ‘local’
[13:36:34.111]   - Field: ‘owner’
[13:36:34.112]   - Field: ‘envir’
[13:36:34.112]   - Field: ‘packages’
[13:36:34.112]   - Field: ‘gc’
[13:36:34.112]   - Field: ‘conditions’
[13:36:34.112]   - Field: ‘expr’
[13:36:34.112]   - Field: ‘uuid’
[13:36:34.112]   - Field: ‘seed’
[13:36:34.112]   - Field: ‘version’
[13:36:34.112]   - Field: ‘result’
[13:36:34.112]   - Field: ‘asynchronous’
[13:36:34.112]   - Field: ‘calls’
[13:36:34.113]   - Field: ‘globals’
[13:36:34.113]   - Field: ‘stdout’
[13:36:34.113]   - Field: ‘earlySignal’
[13:36:34.113]   - Field: ‘lazy’
[13:36:34.113]   - Field: ‘state’
[13:36:34.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.113] - Launch lazy future ...
[13:36:34.113] Packages needed by the future expression (n = 0): <none>
[13:36:34.113] Packages needed by future strategies (n = 0): <none>
[13:36:34.114] {
[13:36:34.114]     {
[13:36:34.114]         {
[13:36:34.114]             ...future.startTime <- base::Sys.time()
[13:36:34.114]             {
[13:36:34.114]                 {
[13:36:34.114]                   {
[13:36:34.114]                     base::local({
[13:36:34.114]                       has_future <- base::requireNamespace("future", 
[13:36:34.114]                         quietly = TRUE)
[13:36:34.114]                       if (has_future) {
[13:36:34.114]                         ns <- base::getNamespace("future")
[13:36:34.114]                         version <- ns[[".package"]][["version"]]
[13:36:34.114]                         if (is.null(version)) 
[13:36:34.114]                           version <- utils::packageVersion("future")
[13:36:34.114]                       }
[13:36:34.114]                       else {
[13:36:34.114]                         version <- NULL
[13:36:34.114]                       }
[13:36:34.114]                       if (!has_future || version < "1.8.0") {
[13:36:34.114]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.114]                           "", base::R.version$version.string), 
[13:36:34.114]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.114]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.114]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.114]                             "release", "version")], collapse = " "), 
[13:36:34.114]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.114]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.114]                           info)
[13:36:34.114]                         info <- base::paste(info, collapse = "; ")
[13:36:34.114]                         if (!has_future) {
[13:36:34.114]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.114]                             info)
[13:36:34.114]                         }
[13:36:34.114]                         else {
[13:36:34.114]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.114]                             info, version)
[13:36:34.114]                         }
[13:36:34.114]                         base::stop(msg)
[13:36:34.114]                       }
[13:36:34.114]                     })
[13:36:34.114]                   }
[13:36:34.114]                   ...future.strategy.old <- future::plan("list")
[13:36:34.114]                   options(future.plan = NULL)
[13:36:34.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.114]                 }
[13:36:34.114]                 ...future.workdir <- getwd()
[13:36:34.114]             }
[13:36:34.114]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.114]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.114]         }
[13:36:34.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.114]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.114]             base::names(...future.oldOptions))
[13:36:34.114]     }
[13:36:34.114]     if (FALSE) {
[13:36:34.114]     }
[13:36:34.114]     else {
[13:36:34.114]         if (TRUE) {
[13:36:34.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.114]                 open = "w")
[13:36:34.114]         }
[13:36:34.114]         else {
[13:36:34.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.114]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.114]         }
[13:36:34.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.114]             base::sink(type = "output", split = FALSE)
[13:36:34.114]             base::close(...future.stdout)
[13:36:34.114]         }, add = TRUE)
[13:36:34.114]     }
[13:36:34.114]     ...future.frame <- base::sys.nframe()
[13:36:34.114]     ...future.conditions <- base::list()
[13:36:34.114]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.114]     if (FALSE) {
[13:36:34.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.114]     }
[13:36:34.114]     ...future.result <- base::tryCatch({
[13:36:34.114]         base::withCallingHandlers({
[13:36:34.114]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.114]             future::FutureResult(value = ...future.value$value, 
[13:36:34.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.114]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.114]                     ...future.globalenv.names))
[13:36:34.114]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.114]         }, condition = base::local({
[13:36:34.114]             c <- base::c
[13:36:34.114]             inherits <- base::inherits
[13:36:34.114]             invokeRestart <- base::invokeRestart
[13:36:34.114]             length <- base::length
[13:36:34.114]             list <- base::list
[13:36:34.114]             seq.int <- base::seq.int
[13:36:34.114]             signalCondition <- base::signalCondition
[13:36:34.114]             sys.calls <- base::sys.calls
[13:36:34.114]             `[[` <- base::`[[`
[13:36:34.114]             `+` <- base::`+`
[13:36:34.114]             `<<-` <- base::`<<-`
[13:36:34.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.114]                   3L)]
[13:36:34.114]             }
[13:36:34.114]             function(cond) {
[13:36:34.114]                 is_error <- inherits(cond, "error")
[13:36:34.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.114]                   NULL)
[13:36:34.114]                 if (is_error) {
[13:36:34.114]                   sessionInformation <- function() {
[13:36:34.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.114]                       search = base::search(), system = base::Sys.info())
[13:36:34.114]                   }
[13:36:34.114]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.114]                     cond$call), session = sessionInformation(), 
[13:36:34.114]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.114]                   signalCondition(cond)
[13:36:34.114]                 }
[13:36:34.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.114]                 "immediateCondition"))) {
[13:36:34.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.114]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.114]                   if (TRUE && !signal) {
[13:36:34.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.114]                     {
[13:36:34.114]                       inherits <- base::inherits
[13:36:34.114]                       invokeRestart <- base::invokeRestart
[13:36:34.114]                       is.null <- base::is.null
[13:36:34.114]                       muffled <- FALSE
[13:36:34.114]                       if (inherits(cond, "message")) {
[13:36:34.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.114]                         if (muffled) 
[13:36:34.114]                           invokeRestart("muffleMessage")
[13:36:34.114]                       }
[13:36:34.114]                       else if (inherits(cond, "warning")) {
[13:36:34.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.114]                         if (muffled) 
[13:36:34.114]                           invokeRestart("muffleWarning")
[13:36:34.114]                       }
[13:36:34.114]                       else if (inherits(cond, "condition")) {
[13:36:34.114]                         if (!is.null(pattern)) {
[13:36:34.114]                           computeRestarts <- base::computeRestarts
[13:36:34.114]                           grepl <- base::grepl
[13:36:34.114]                           restarts <- computeRestarts(cond)
[13:36:34.114]                           for (restart in restarts) {
[13:36:34.114]                             name <- restart$name
[13:36:34.114]                             if (is.null(name)) 
[13:36:34.114]                               next
[13:36:34.114]                             if (!grepl(pattern, name)) 
[13:36:34.114]                               next
[13:36:34.114]                             invokeRestart(restart)
[13:36:34.114]                             muffled <- TRUE
[13:36:34.114]                             break
[13:36:34.114]                           }
[13:36:34.114]                         }
[13:36:34.114]                       }
[13:36:34.114]                       invisible(muffled)
[13:36:34.114]                     }
[13:36:34.114]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.114]                   }
[13:36:34.114]                 }
[13:36:34.114]                 else {
[13:36:34.114]                   if (TRUE) {
[13:36:34.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.114]                     {
[13:36:34.114]                       inherits <- base::inherits
[13:36:34.114]                       invokeRestart <- base::invokeRestart
[13:36:34.114]                       is.null <- base::is.null
[13:36:34.114]                       muffled <- FALSE
[13:36:34.114]                       if (inherits(cond, "message")) {
[13:36:34.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.114]                         if (muffled) 
[13:36:34.114]                           invokeRestart("muffleMessage")
[13:36:34.114]                       }
[13:36:34.114]                       else if (inherits(cond, "warning")) {
[13:36:34.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.114]                         if (muffled) 
[13:36:34.114]                           invokeRestart("muffleWarning")
[13:36:34.114]                       }
[13:36:34.114]                       else if (inherits(cond, "condition")) {
[13:36:34.114]                         if (!is.null(pattern)) {
[13:36:34.114]                           computeRestarts <- base::computeRestarts
[13:36:34.114]                           grepl <- base::grepl
[13:36:34.114]                           restarts <- computeRestarts(cond)
[13:36:34.114]                           for (restart in restarts) {
[13:36:34.114]                             name <- restart$name
[13:36:34.114]                             if (is.null(name)) 
[13:36:34.114]                               next
[13:36:34.114]                             if (!grepl(pattern, name)) 
[13:36:34.114]                               next
[13:36:34.114]                             invokeRestart(restart)
[13:36:34.114]                             muffled <- TRUE
[13:36:34.114]                             break
[13:36:34.114]                           }
[13:36:34.114]                         }
[13:36:34.114]                       }
[13:36:34.114]                       invisible(muffled)
[13:36:34.114]                     }
[13:36:34.114]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.114]                   }
[13:36:34.114]                 }
[13:36:34.114]             }
[13:36:34.114]         }))
[13:36:34.114]     }, error = function(ex) {
[13:36:34.114]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.114]                 ...future.rng), started = ...future.startTime, 
[13:36:34.114]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.114]             version = "1.8"), class = "FutureResult")
[13:36:34.114]     }, finally = {
[13:36:34.114]         if (!identical(...future.workdir, getwd())) 
[13:36:34.114]             setwd(...future.workdir)
[13:36:34.114]         {
[13:36:34.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.114]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.114]             }
[13:36:34.114]             base::options(...future.oldOptions)
[13:36:34.114]             if (.Platform$OS.type == "windows") {
[13:36:34.114]                 old_names <- names(...future.oldEnvVars)
[13:36:34.114]                 envs <- base::Sys.getenv()
[13:36:34.114]                 names <- names(envs)
[13:36:34.114]                 common <- intersect(names, old_names)
[13:36:34.114]                 added <- setdiff(names, old_names)
[13:36:34.114]                 removed <- setdiff(old_names, names)
[13:36:34.114]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.114]                   envs[common]]
[13:36:34.114]                 NAMES <- toupper(changed)
[13:36:34.114]                 args <- list()
[13:36:34.114]                 for (kk in seq_along(NAMES)) {
[13:36:34.114]                   name <- changed[[kk]]
[13:36:34.114]                   NAME <- NAMES[[kk]]
[13:36:34.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.114]                     next
[13:36:34.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.114]                 }
[13:36:34.114]                 NAMES <- toupper(added)
[13:36:34.114]                 for (kk in seq_along(NAMES)) {
[13:36:34.114]                   name <- added[[kk]]
[13:36:34.114]                   NAME <- NAMES[[kk]]
[13:36:34.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.114]                     next
[13:36:34.114]                   args[[name]] <- ""
[13:36:34.114]                 }
[13:36:34.114]                 NAMES <- toupper(removed)
[13:36:34.114]                 for (kk in seq_along(NAMES)) {
[13:36:34.114]                   name <- removed[[kk]]
[13:36:34.114]                   NAME <- NAMES[[kk]]
[13:36:34.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.114]                     next
[13:36:34.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.114]                 }
[13:36:34.114]                 if (length(args) > 0) 
[13:36:34.114]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.114]             }
[13:36:34.114]             else {
[13:36:34.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.114]             }
[13:36:34.114]             {
[13:36:34.114]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.114]                   0L) {
[13:36:34.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.114]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.114]                   base::options(opts)
[13:36:34.114]                 }
[13:36:34.114]                 {
[13:36:34.114]                   {
[13:36:34.114]                     NULL
[13:36:34.114]                     RNGkind("Mersenne-Twister")
[13:36:34.114]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.114]                       inherits = FALSE)
[13:36:34.114]                   }
[13:36:34.114]                   options(future.plan = NULL)
[13:36:34.114]                   if (is.na(NA_character_)) 
[13:36:34.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.114]                     .init = FALSE)
[13:36:34.114]                 }
[13:36:34.114]             }
[13:36:34.114]         }
[13:36:34.114]     })
[13:36:34.114]     if (TRUE) {
[13:36:34.114]         base::sink(type = "output", split = FALSE)
[13:36:34.114]         if (TRUE) {
[13:36:34.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.114]         }
[13:36:34.114]         else {
[13:36:34.114]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.114]         }
[13:36:34.114]         base::close(...future.stdout)
[13:36:34.114]         ...future.stdout <- NULL
[13:36:34.114]     }
[13:36:34.114]     ...future.result$conditions <- ...future.conditions
[13:36:34.114]     ...future.result$finished <- base::Sys.time()
[13:36:34.114]     ...future.result
[13:36:34.114] }
[13:36:34.115] plan(): Setting new future strategy stack:
[13:36:34.115] List of future strategies:
[13:36:34.115] 1. sequential:
[13:36:34.115]    - args: function (..., envir = parent.frame())
[13:36:34.115]    - tweaked: FALSE
[13:36:34.115]    - call: NULL
[13:36:34.116] plan(): nbrOfWorkers() = 1
[13:36:34.116] plan(): Setting new future strategy stack:
[13:36:34.117] List of future strategies:
[13:36:34.117] 1. sequential:
[13:36:34.117]    - args: function (..., envir = parent.frame())
[13:36:34.117]    - tweaked: FALSE
[13:36:34.117]    - call: plan(strategy)
[13:36:34.117] plan(): nbrOfWorkers() = 1
[13:36:34.117] SequentialFuture started (and completed)
[13:36:34.117] - Launch lazy future ... done
[13:36:34.117] run() for ‘SequentialFuture’ ... done
[13:36:34.117] getGlobalsAndPackages() ...
[13:36:34.118] Searching for globals...
[13:36:34.118] - globals found: [1] ‘{’
[13:36:34.118] Searching for globals ... DONE
[13:36:34.118] Resolving globals: FALSE
[13:36:34.119] 
[13:36:34.119] 
[13:36:34.119] getGlobalsAndPackages() ... DONE
[13:36:34.119] run() for ‘Future’ ...
[13:36:34.119] - state: ‘created’
[13:36:34.119] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.119] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.120]   - Field: ‘label’
[13:36:34.120]   - Field: ‘local’
[13:36:34.120]   - Field: ‘owner’
[13:36:34.120]   - Field: ‘envir’
[13:36:34.120]   - Field: ‘packages’
[13:36:34.120]   - Field: ‘gc’
[13:36:34.120]   - Field: ‘conditions’
[13:36:34.120]   - Field: ‘expr’
[13:36:34.120]   - Field: ‘uuid’
[13:36:34.120]   - Field: ‘seed’
[13:36:34.120]   - Field: ‘version’
[13:36:34.121]   - Field: ‘result’
[13:36:34.121]   - Field: ‘asynchronous’
[13:36:34.121]   - Field: ‘calls’
[13:36:34.121]   - Field: ‘globals’
[13:36:34.121]   - Field: ‘stdout’
[13:36:34.121]   - Field: ‘earlySignal’
[13:36:34.121]   - Field: ‘lazy’
[13:36:34.121]   - Field: ‘state’
[13:36:34.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.121] - Launch lazy future ...
[13:36:34.121] Packages needed by the future expression (n = 0): <none>
[13:36:34.122] Packages needed by future strategies (n = 0): <none>
[13:36:34.122] {
[13:36:34.122]     {
[13:36:34.122]         {
[13:36:34.122]             ...future.startTime <- base::Sys.time()
[13:36:34.122]             {
[13:36:34.122]                 {
[13:36:34.122]                   {
[13:36:34.122]                     base::local({
[13:36:34.122]                       has_future <- base::requireNamespace("future", 
[13:36:34.122]                         quietly = TRUE)
[13:36:34.122]                       if (has_future) {
[13:36:34.122]                         ns <- base::getNamespace("future")
[13:36:34.122]                         version <- ns[[".package"]][["version"]]
[13:36:34.122]                         if (is.null(version)) 
[13:36:34.122]                           version <- utils::packageVersion("future")
[13:36:34.122]                       }
[13:36:34.122]                       else {
[13:36:34.122]                         version <- NULL
[13:36:34.122]                       }
[13:36:34.122]                       if (!has_future || version < "1.8.0") {
[13:36:34.122]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.122]                           "", base::R.version$version.string), 
[13:36:34.122]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.122]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.122]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.122]                             "release", "version")], collapse = " "), 
[13:36:34.122]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.122]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.122]                           info)
[13:36:34.122]                         info <- base::paste(info, collapse = "; ")
[13:36:34.122]                         if (!has_future) {
[13:36:34.122]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.122]                             info)
[13:36:34.122]                         }
[13:36:34.122]                         else {
[13:36:34.122]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.122]                             info, version)
[13:36:34.122]                         }
[13:36:34.122]                         base::stop(msg)
[13:36:34.122]                       }
[13:36:34.122]                     })
[13:36:34.122]                   }
[13:36:34.122]                   ...future.strategy.old <- future::plan("list")
[13:36:34.122]                   options(future.plan = NULL)
[13:36:34.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.122]                 }
[13:36:34.122]                 ...future.workdir <- getwd()
[13:36:34.122]             }
[13:36:34.122]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.122]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.122]         }
[13:36:34.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.122]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.122]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.122]             base::names(...future.oldOptions))
[13:36:34.122]     }
[13:36:34.122]     if (FALSE) {
[13:36:34.122]     }
[13:36:34.122]     else {
[13:36:34.122]         if (TRUE) {
[13:36:34.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.122]                 open = "w")
[13:36:34.122]         }
[13:36:34.122]         else {
[13:36:34.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.122]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.122]         }
[13:36:34.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.122]             base::sink(type = "output", split = FALSE)
[13:36:34.122]             base::close(...future.stdout)
[13:36:34.122]         }, add = TRUE)
[13:36:34.122]     }
[13:36:34.122]     ...future.frame <- base::sys.nframe()
[13:36:34.122]     ...future.conditions <- base::list()
[13:36:34.122]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.122]     if (FALSE) {
[13:36:34.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.122]     }
[13:36:34.122]     ...future.result <- base::tryCatch({
[13:36:34.122]         base::withCallingHandlers({
[13:36:34.122]             ...future.value <- base::withVisible(base::local({
[13:36:34.122]                 4
[13:36:34.122]             }))
[13:36:34.122]             future::FutureResult(value = ...future.value$value, 
[13:36:34.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.122]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.122]                     ...future.globalenv.names))
[13:36:34.122]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.122]         }, condition = base::local({
[13:36:34.122]             c <- base::c
[13:36:34.122]             inherits <- base::inherits
[13:36:34.122]             invokeRestart <- base::invokeRestart
[13:36:34.122]             length <- base::length
[13:36:34.122]             list <- base::list
[13:36:34.122]             seq.int <- base::seq.int
[13:36:34.122]             signalCondition <- base::signalCondition
[13:36:34.122]             sys.calls <- base::sys.calls
[13:36:34.122]             `[[` <- base::`[[`
[13:36:34.122]             `+` <- base::`+`
[13:36:34.122]             `<<-` <- base::`<<-`
[13:36:34.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.122]                   3L)]
[13:36:34.122]             }
[13:36:34.122]             function(cond) {
[13:36:34.122]                 is_error <- inherits(cond, "error")
[13:36:34.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.122]                   NULL)
[13:36:34.122]                 if (is_error) {
[13:36:34.122]                   sessionInformation <- function() {
[13:36:34.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.122]                       search = base::search(), system = base::Sys.info())
[13:36:34.122]                   }
[13:36:34.122]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.122]                     cond$call), session = sessionInformation(), 
[13:36:34.122]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.122]                   signalCondition(cond)
[13:36:34.122]                 }
[13:36:34.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.122]                 "immediateCondition"))) {
[13:36:34.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.122]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.122]                   if (TRUE && !signal) {
[13:36:34.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.122]                     {
[13:36:34.122]                       inherits <- base::inherits
[13:36:34.122]                       invokeRestart <- base::invokeRestart
[13:36:34.122]                       is.null <- base::is.null
[13:36:34.122]                       muffled <- FALSE
[13:36:34.122]                       if (inherits(cond, "message")) {
[13:36:34.122]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.122]                         if (muffled) 
[13:36:34.122]                           invokeRestart("muffleMessage")
[13:36:34.122]                       }
[13:36:34.122]                       else if (inherits(cond, "warning")) {
[13:36:34.122]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.122]                         if (muffled) 
[13:36:34.122]                           invokeRestart("muffleWarning")
[13:36:34.122]                       }
[13:36:34.122]                       else if (inherits(cond, "condition")) {
[13:36:34.122]                         if (!is.null(pattern)) {
[13:36:34.122]                           computeRestarts <- base::computeRestarts
[13:36:34.122]                           grepl <- base::grepl
[13:36:34.122]                           restarts <- computeRestarts(cond)
[13:36:34.122]                           for (restart in restarts) {
[13:36:34.122]                             name <- restart$name
[13:36:34.122]                             if (is.null(name)) 
[13:36:34.122]                               next
[13:36:34.122]                             if (!grepl(pattern, name)) 
[13:36:34.122]                               next
[13:36:34.122]                             invokeRestart(restart)
[13:36:34.122]                             muffled <- TRUE
[13:36:34.122]                             break
[13:36:34.122]                           }
[13:36:34.122]                         }
[13:36:34.122]                       }
[13:36:34.122]                       invisible(muffled)
[13:36:34.122]                     }
[13:36:34.122]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.122]                   }
[13:36:34.122]                 }
[13:36:34.122]                 else {
[13:36:34.122]                   if (TRUE) {
[13:36:34.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.122]                     {
[13:36:34.122]                       inherits <- base::inherits
[13:36:34.122]                       invokeRestart <- base::invokeRestart
[13:36:34.122]                       is.null <- base::is.null
[13:36:34.122]                       muffled <- FALSE
[13:36:34.122]                       if (inherits(cond, "message")) {
[13:36:34.122]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.122]                         if (muffled) 
[13:36:34.122]                           invokeRestart("muffleMessage")
[13:36:34.122]                       }
[13:36:34.122]                       else if (inherits(cond, "warning")) {
[13:36:34.122]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.122]                         if (muffled) 
[13:36:34.122]                           invokeRestart("muffleWarning")
[13:36:34.122]                       }
[13:36:34.122]                       else if (inherits(cond, "condition")) {
[13:36:34.122]                         if (!is.null(pattern)) {
[13:36:34.122]                           computeRestarts <- base::computeRestarts
[13:36:34.122]                           grepl <- base::grepl
[13:36:34.122]                           restarts <- computeRestarts(cond)
[13:36:34.122]                           for (restart in restarts) {
[13:36:34.122]                             name <- restart$name
[13:36:34.122]                             if (is.null(name)) 
[13:36:34.122]                               next
[13:36:34.122]                             if (!grepl(pattern, name)) 
[13:36:34.122]                               next
[13:36:34.122]                             invokeRestart(restart)
[13:36:34.122]                             muffled <- TRUE
[13:36:34.122]                             break
[13:36:34.122]                           }
[13:36:34.122]                         }
[13:36:34.122]                       }
[13:36:34.122]                       invisible(muffled)
[13:36:34.122]                     }
[13:36:34.122]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.122]                   }
[13:36:34.122]                 }
[13:36:34.122]             }
[13:36:34.122]         }))
[13:36:34.122]     }, error = function(ex) {
[13:36:34.122]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.122]                 ...future.rng), started = ...future.startTime, 
[13:36:34.122]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.122]             version = "1.8"), class = "FutureResult")
[13:36:34.122]     }, finally = {
[13:36:34.122]         if (!identical(...future.workdir, getwd())) 
[13:36:34.122]             setwd(...future.workdir)
[13:36:34.122]         {
[13:36:34.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.122]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.122]             }
[13:36:34.122]             base::options(...future.oldOptions)
[13:36:34.122]             if (.Platform$OS.type == "windows") {
[13:36:34.122]                 old_names <- names(...future.oldEnvVars)
[13:36:34.122]                 envs <- base::Sys.getenv()
[13:36:34.122]                 names <- names(envs)
[13:36:34.122]                 common <- intersect(names, old_names)
[13:36:34.122]                 added <- setdiff(names, old_names)
[13:36:34.122]                 removed <- setdiff(old_names, names)
[13:36:34.122]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.122]                   envs[common]]
[13:36:34.122]                 NAMES <- toupper(changed)
[13:36:34.122]                 args <- list()
[13:36:34.122]                 for (kk in seq_along(NAMES)) {
[13:36:34.122]                   name <- changed[[kk]]
[13:36:34.122]                   NAME <- NAMES[[kk]]
[13:36:34.122]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.122]                     next
[13:36:34.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.122]                 }
[13:36:34.122]                 NAMES <- toupper(added)
[13:36:34.122]                 for (kk in seq_along(NAMES)) {
[13:36:34.122]                   name <- added[[kk]]
[13:36:34.122]                   NAME <- NAMES[[kk]]
[13:36:34.122]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.122]                     next
[13:36:34.122]                   args[[name]] <- ""
[13:36:34.122]                 }
[13:36:34.122]                 NAMES <- toupper(removed)
[13:36:34.122]                 for (kk in seq_along(NAMES)) {
[13:36:34.122]                   name <- removed[[kk]]
[13:36:34.122]                   NAME <- NAMES[[kk]]
[13:36:34.122]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.122]                     next
[13:36:34.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.122]                 }
[13:36:34.122]                 if (length(args) > 0) 
[13:36:34.122]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.122]             }
[13:36:34.122]             else {
[13:36:34.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.122]             }
[13:36:34.122]             {
[13:36:34.122]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.122]                   0L) {
[13:36:34.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.122]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.122]                   base::options(opts)
[13:36:34.122]                 }
[13:36:34.122]                 {
[13:36:34.122]                   {
[13:36:34.122]                     NULL
[13:36:34.122]                     RNGkind("Mersenne-Twister")
[13:36:34.122]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.122]                       inherits = FALSE)
[13:36:34.122]                   }
[13:36:34.122]                   options(future.plan = NULL)
[13:36:34.122]                   if (is.na(NA_character_)) 
[13:36:34.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.122]                     .init = FALSE)
[13:36:34.122]                 }
[13:36:34.122]             }
[13:36:34.122]         }
[13:36:34.122]     })
[13:36:34.122]     if (TRUE) {
[13:36:34.122]         base::sink(type = "output", split = FALSE)
[13:36:34.122]         if (TRUE) {
[13:36:34.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.122]         }
[13:36:34.122]         else {
[13:36:34.122]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.122]         }
[13:36:34.122]         base::close(...future.stdout)
[13:36:34.122]         ...future.stdout <- NULL
[13:36:34.122]     }
[13:36:34.122]     ...future.result$conditions <- ...future.conditions
[13:36:34.122]     ...future.result$finished <- base::Sys.time()
[13:36:34.122]     ...future.result
[13:36:34.122] }
[13:36:34.124] plan(): Setting new future strategy stack:
[13:36:34.124] List of future strategies:
[13:36:34.124] 1. sequential:
[13:36:34.124]    - args: function (..., envir = parent.frame())
[13:36:34.124]    - tweaked: FALSE
[13:36:34.124]    - call: NULL
[13:36:34.124] plan(): nbrOfWorkers() = 1
[13:36:34.126] plan(): Setting new future strategy stack:
[13:36:34.126] List of future strategies:
[13:36:34.126] 1. sequential:
[13:36:34.126]    - args: function (..., envir = parent.frame())
[13:36:34.126]    - tweaked: FALSE
[13:36:34.126]    - call: plan(strategy)
[13:36:34.127] plan(): nbrOfWorkers() = 1
[13:36:34.127] SequentialFuture started (and completed)
[13:36:34.127] - Launch lazy future ... done
[13:36:34.127] run() for ‘SequentialFuture’ ... done
<environment: 0x564a714f6570> 
<environment: 0x564a71c780d0> 
[13:36:34.128] resolved() for ‘SequentialFuture’ ...
[13:36:34.128] - state: ‘finished’
[13:36:34.128] - run: TRUE
[13:36:34.128] - result: ‘FutureResult’
[13:36:34.128] resolved() for ‘SequentialFuture’ ... done
[13:36:34.129] resolved() for ‘SequentialFuture’ ...
[13:36:34.129] - state: ‘finished’
[13:36:34.129] - run: TRUE
[13:36:34.129] - result: ‘FutureResult’
[13:36:34.129] resolved() for ‘SequentialFuture’ ... done
[13:36:34.129] resolved() for ‘SequentialFuture’ ...
[13:36:34.129] - state: ‘finished’
[13:36:34.129] - run: TRUE
[13:36:34.129] - result: ‘FutureResult’
[13:36:34.129] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:34.130] resolve() on environment ...
[13:36:34.131]  recursive: 0
[13:36:34.131]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:34.131] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.131] - nx: 4
[13:36:34.131] - relay: TRUE
[13:36:34.131] - stdout: TRUE
[13:36:34.131] - signal: TRUE
[13:36:34.131] - resignal: FALSE
[13:36:34.132] - force: TRUE
[13:36:34.132] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.132] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.132]  - until=2
[13:36:34.132]  - relaying element #2
[13:36:34.132] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.132] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.132] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.132]  length: 3 (resolved future 1)
[13:36:34.132] resolved() for ‘SequentialFuture’ ...
[13:36:34.132] - state: ‘finished’
[13:36:34.133] - run: TRUE
[13:36:34.133] - result: ‘FutureResult’
[13:36:34.133] resolved() for ‘SequentialFuture’ ... done
[13:36:34.133] Future #2
[13:36:34.133] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.133] - nx: 4
[13:36:34.133] - relay: TRUE
[13:36:34.133] - stdout: TRUE
[13:36:34.133] - signal: TRUE
[13:36:34.133] - resignal: FALSE
[13:36:34.133] - force: TRUE
[13:36:34.133] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:34.134] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:34.134]  - until=2
[13:36:34.134]  - relaying element #2
[13:36:34.134] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.134] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.134] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.134]  length: 2 (resolved future 2)
[13:36:34.134] resolved() for ‘SequentialFuture’ ...
[13:36:34.134] - state: ‘finished’
[13:36:34.135] - run: TRUE
[13:36:34.135] - result: ‘FutureResult’
[13:36:34.135] resolved() for ‘SequentialFuture’ ... done
[13:36:34.135] Future #3
[13:36:34.135] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.135] - nx: 4
[13:36:34.135] - relay: TRUE
[13:36:34.135] - stdout: TRUE
[13:36:34.135] - signal: TRUE
[13:36:34.135] - resignal: FALSE
[13:36:34.135] - force: TRUE
[13:36:34.135] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:34.136] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:34.136]  - until=3
[13:36:34.136]  - relaying element #3
[13:36:34.136] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.136] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.136] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.136]  length: 1 (resolved future 3)
[13:36:34.136] resolved() for ‘SequentialFuture’ ...
[13:36:34.136] - state: ‘finished’
[13:36:34.136] - run: TRUE
[13:36:34.136] - result: ‘FutureResult’
[13:36:34.137] resolved() for ‘SequentialFuture’ ... done
[13:36:34.137] Future #4
[13:36:34.137] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.137] - nx: 4
[13:36:34.137] - relay: TRUE
[13:36:34.137] - stdout: TRUE
[13:36:34.137] - signal: TRUE
[13:36:34.137] - resignal: FALSE
[13:36:34.137] - force: TRUE
[13:36:34.137] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:34.137] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:34.137]  - until=4
[13:36:34.138]  - relaying element #4
[13:36:34.138] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.138] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.138] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.138]  length: 0 (resolved future 4)
[13:36:34.138] Relaying remaining futures
[13:36:34.138] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.138] - nx: 4
[13:36:34.138] - relay: TRUE
[13:36:34.138] - stdout: TRUE
[13:36:34.138] - signal: TRUE
[13:36:34.139] - resignal: FALSE
[13:36:34.139] - force: TRUE
[13:36:34.139] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.139] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:34.139] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:34.139] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:34.139] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.139] resolve() on environment ... DONE
<environment: 0x564a71dacae0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[13:36:34.140] plan(): Setting new future strategy stack:
[13:36:34.140] List of future strategies:
[13:36:34.140] 1. sequential:
[13:36:34.140]    - args: function (..., envir = parent.frame())
[13:36:34.140]    - tweaked: FALSE
[13:36:34.140]    - call: plan(strategy)
[13:36:34.140] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:36:34.141] getGlobalsAndPackages() ...
[13:36:34.141] Searching for globals...
[13:36:34.141] 
[13:36:34.141] Searching for globals ... DONE
[13:36:34.141] - globals: [0] <none>
[13:36:34.141] getGlobalsAndPackages() ... DONE
[13:36:34.142] run() for ‘Future’ ...
[13:36:34.142] - state: ‘created’
[13:36:34.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.142] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.142] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.142]   - Field: ‘label’
[13:36:34.142]   - Field: ‘local’
[13:36:34.142]   - Field: ‘owner’
[13:36:34.143]   - Field: ‘envir’
[13:36:34.143]   - Field: ‘packages’
[13:36:34.143]   - Field: ‘gc’
[13:36:34.143]   - Field: ‘conditions’
[13:36:34.143]   - Field: ‘expr’
[13:36:34.143]   - Field: ‘uuid’
[13:36:34.143]   - Field: ‘seed’
[13:36:34.143]   - Field: ‘version’
[13:36:34.143]   - Field: ‘result’
[13:36:34.143]   - Field: ‘asynchronous’
[13:36:34.143]   - Field: ‘calls’
[13:36:34.144]   - Field: ‘globals’
[13:36:34.144]   - Field: ‘stdout’
[13:36:34.144]   - Field: ‘earlySignal’
[13:36:34.144]   - Field: ‘lazy’
[13:36:34.144]   - Field: ‘state’
[13:36:34.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.144] - Launch lazy future ...
[13:36:34.144] Packages needed by the future expression (n = 0): <none>
[13:36:34.144] Packages needed by future strategies (n = 0): <none>
[13:36:34.145] {
[13:36:34.145]     {
[13:36:34.145]         {
[13:36:34.145]             ...future.startTime <- base::Sys.time()
[13:36:34.145]             {
[13:36:34.145]                 {
[13:36:34.145]                   {
[13:36:34.145]                     base::local({
[13:36:34.145]                       has_future <- base::requireNamespace("future", 
[13:36:34.145]                         quietly = TRUE)
[13:36:34.145]                       if (has_future) {
[13:36:34.145]                         ns <- base::getNamespace("future")
[13:36:34.145]                         version <- ns[[".package"]][["version"]]
[13:36:34.145]                         if (is.null(version)) 
[13:36:34.145]                           version <- utils::packageVersion("future")
[13:36:34.145]                       }
[13:36:34.145]                       else {
[13:36:34.145]                         version <- NULL
[13:36:34.145]                       }
[13:36:34.145]                       if (!has_future || version < "1.8.0") {
[13:36:34.145]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.145]                           "", base::R.version$version.string), 
[13:36:34.145]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.145]                             "release", "version")], collapse = " "), 
[13:36:34.145]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.145]                           info)
[13:36:34.145]                         info <- base::paste(info, collapse = "; ")
[13:36:34.145]                         if (!has_future) {
[13:36:34.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.145]                             info)
[13:36:34.145]                         }
[13:36:34.145]                         else {
[13:36:34.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.145]                             info, version)
[13:36:34.145]                         }
[13:36:34.145]                         base::stop(msg)
[13:36:34.145]                       }
[13:36:34.145]                     })
[13:36:34.145]                   }
[13:36:34.145]                   ...future.strategy.old <- future::plan("list")
[13:36:34.145]                   options(future.plan = NULL)
[13:36:34.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.145]                 }
[13:36:34.145]                 ...future.workdir <- getwd()
[13:36:34.145]             }
[13:36:34.145]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.145]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.145]         }
[13:36:34.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.145]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.145]             base::names(...future.oldOptions))
[13:36:34.145]     }
[13:36:34.145]     if (FALSE) {
[13:36:34.145]     }
[13:36:34.145]     else {
[13:36:34.145]         if (TRUE) {
[13:36:34.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.145]                 open = "w")
[13:36:34.145]         }
[13:36:34.145]         else {
[13:36:34.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.145]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.145]         }
[13:36:34.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.145]             base::sink(type = "output", split = FALSE)
[13:36:34.145]             base::close(...future.stdout)
[13:36:34.145]         }, add = TRUE)
[13:36:34.145]     }
[13:36:34.145]     ...future.frame <- base::sys.nframe()
[13:36:34.145]     ...future.conditions <- base::list()
[13:36:34.145]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.145]     if (FALSE) {
[13:36:34.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.145]     }
[13:36:34.145]     ...future.result <- base::tryCatch({
[13:36:34.145]         base::withCallingHandlers({
[13:36:34.145]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.145]             future::FutureResult(value = ...future.value$value, 
[13:36:34.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.145]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.145]                     ...future.globalenv.names))
[13:36:34.145]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.145]         }, condition = base::local({
[13:36:34.145]             c <- base::c
[13:36:34.145]             inherits <- base::inherits
[13:36:34.145]             invokeRestart <- base::invokeRestart
[13:36:34.145]             length <- base::length
[13:36:34.145]             list <- base::list
[13:36:34.145]             seq.int <- base::seq.int
[13:36:34.145]             signalCondition <- base::signalCondition
[13:36:34.145]             sys.calls <- base::sys.calls
[13:36:34.145]             `[[` <- base::`[[`
[13:36:34.145]             `+` <- base::`+`
[13:36:34.145]             `<<-` <- base::`<<-`
[13:36:34.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.145]                   3L)]
[13:36:34.145]             }
[13:36:34.145]             function(cond) {
[13:36:34.145]                 is_error <- inherits(cond, "error")
[13:36:34.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.145]                   NULL)
[13:36:34.145]                 if (is_error) {
[13:36:34.145]                   sessionInformation <- function() {
[13:36:34.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.145]                       search = base::search(), system = base::Sys.info())
[13:36:34.145]                   }
[13:36:34.145]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.145]                     cond$call), session = sessionInformation(), 
[13:36:34.145]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.145]                   signalCondition(cond)
[13:36:34.145]                 }
[13:36:34.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.145]                 "immediateCondition"))) {
[13:36:34.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.145]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.145]                   if (TRUE && !signal) {
[13:36:34.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.145]                     {
[13:36:34.145]                       inherits <- base::inherits
[13:36:34.145]                       invokeRestart <- base::invokeRestart
[13:36:34.145]                       is.null <- base::is.null
[13:36:34.145]                       muffled <- FALSE
[13:36:34.145]                       if (inherits(cond, "message")) {
[13:36:34.145]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.145]                         if (muffled) 
[13:36:34.145]                           invokeRestart("muffleMessage")
[13:36:34.145]                       }
[13:36:34.145]                       else if (inherits(cond, "warning")) {
[13:36:34.145]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.145]                         if (muffled) 
[13:36:34.145]                           invokeRestart("muffleWarning")
[13:36:34.145]                       }
[13:36:34.145]                       else if (inherits(cond, "condition")) {
[13:36:34.145]                         if (!is.null(pattern)) {
[13:36:34.145]                           computeRestarts <- base::computeRestarts
[13:36:34.145]                           grepl <- base::grepl
[13:36:34.145]                           restarts <- computeRestarts(cond)
[13:36:34.145]                           for (restart in restarts) {
[13:36:34.145]                             name <- restart$name
[13:36:34.145]                             if (is.null(name)) 
[13:36:34.145]                               next
[13:36:34.145]                             if (!grepl(pattern, name)) 
[13:36:34.145]                               next
[13:36:34.145]                             invokeRestart(restart)
[13:36:34.145]                             muffled <- TRUE
[13:36:34.145]                             break
[13:36:34.145]                           }
[13:36:34.145]                         }
[13:36:34.145]                       }
[13:36:34.145]                       invisible(muffled)
[13:36:34.145]                     }
[13:36:34.145]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.145]                   }
[13:36:34.145]                 }
[13:36:34.145]                 else {
[13:36:34.145]                   if (TRUE) {
[13:36:34.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.145]                     {
[13:36:34.145]                       inherits <- base::inherits
[13:36:34.145]                       invokeRestart <- base::invokeRestart
[13:36:34.145]                       is.null <- base::is.null
[13:36:34.145]                       muffled <- FALSE
[13:36:34.145]                       if (inherits(cond, "message")) {
[13:36:34.145]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.145]                         if (muffled) 
[13:36:34.145]                           invokeRestart("muffleMessage")
[13:36:34.145]                       }
[13:36:34.145]                       else if (inherits(cond, "warning")) {
[13:36:34.145]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.145]                         if (muffled) 
[13:36:34.145]                           invokeRestart("muffleWarning")
[13:36:34.145]                       }
[13:36:34.145]                       else if (inherits(cond, "condition")) {
[13:36:34.145]                         if (!is.null(pattern)) {
[13:36:34.145]                           computeRestarts <- base::computeRestarts
[13:36:34.145]                           grepl <- base::grepl
[13:36:34.145]                           restarts <- computeRestarts(cond)
[13:36:34.145]                           for (restart in restarts) {
[13:36:34.145]                             name <- restart$name
[13:36:34.145]                             if (is.null(name)) 
[13:36:34.145]                               next
[13:36:34.145]                             if (!grepl(pattern, name)) 
[13:36:34.145]                               next
[13:36:34.145]                             invokeRestart(restart)
[13:36:34.145]                             muffled <- TRUE
[13:36:34.145]                             break
[13:36:34.145]                           }
[13:36:34.145]                         }
[13:36:34.145]                       }
[13:36:34.145]                       invisible(muffled)
[13:36:34.145]                     }
[13:36:34.145]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.145]                   }
[13:36:34.145]                 }
[13:36:34.145]             }
[13:36:34.145]         }))
[13:36:34.145]     }, error = function(ex) {
[13:36:34.145]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.145]                 ...future.rng), started = ...future.startTime, 
[13:36:34.145]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.145]             version = "1.8"), class = "FutureResult")
[13:36:34.145]     }, finally = {
[13:36:34.145]         if (!identical(...future.workdir, getwd())) 
[13:36:34.145]             setwd(...future.workdir)
[13:36:34.145]         {
[13:36:34.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.145]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.145]             }
[13:36:34.145]             base::options(...future.oldOptions)
[13:36:34.145]             if (.Platform$OS.type == "windows") {
[13:36:34.145]                 old_names <- names(...future.oldEnvVars)
[13:36:34.145]                 envs <- base::Sys.getenv()
[13:36:34.145]                 names <- names(envs)
[13:36:34.145]                 common <- intersect(names, old_names)
[13:36:34.145]                 added <- setdiff(names, old_names)
[13:36:34.145]                 removed <- setdiff(old_names, names)
[13:36:34.145]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.145]                   envs[common]]
[13:36:34.145]                 NAMES <- toupper(changed)
[13:36:34.145]                 args <- list()
[13:36:34.145]                 for (kk in seq_along(NAMES)) {
[13:36:34.145]                   name <- changed[[kk]]
[13:36:34.145]                   NAME <- NAMES[[kk]]
[13:36:34.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.145]                     next
[13:36:34.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.145]                 }
[13:36:34.145]                 NAMES <- toupper(added)
[13:36:34.145]                 for (kk in seq_along(NAMES)) {
[13:36:34.145]                   name <- added[[kk]]
[13:36:34.145]                   NAME <- NAMES[[kk]]
[13:36:34.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.145]                     next
[13:36:34.145]                   args[[name]] <- ""
[13:36:34.145]                 }
[13:36:34.145]                 NAMES <- toupper(removed)
[13:36:34.145]                 for (kk in seq_along(NAMES)) {
[13:36:34.145]                   name <- removed[[kk]]
[13:36:34.145]                   NAME <- NAMES[[kk]]
[13:36:34.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.145]                     next
[13:36:34.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.145]                 }
[13:36:34.145]                 if (length(args) > 0) 
[13:36:34.145]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.145]             }
[13:36:34.145]             else {
[13:36:34.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.145]             }
[13:36:34.145]             {
[13:36:34.145]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.145]                   0L) {
[13:36:34.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.145]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.145]                   base::options(opts)
[13:36:34.145]                 }
[13:36:34.145]                 {
[13:36:34.145]                   {
[13:36:34.145]                     NULL
[13:36:34.145]                     RNGkind("Mersenne-Twister")
[13:36:34.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.145]                       inherits = FALSE)
[13:36:34.145]                   }
[13:36:34.145]                   options(future.plan = NULL)
[13:36:34.145]                   if (is.na(NA_character_)) 
[13:36:34.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.145]                     .init = FALSE)
[13:36:34.145]                 }
[13:36:34.145]             }
[13:36:34.145]         }
[13:36:34.145]     })
[13:36:34.145]     if (TRUE) {
[13:36:34.145]         base::sink(type = "output", split = FALSE)
[13:36:34.145]         if (TRUE) {
[13:36:34.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.145]         }
[13:36:34.145]         else {
[13:36:34.145]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.145]         }
[13:36:34.145]         base::close(...future.stdout)
[13:36:34.145]         ...future.stdout <- NULL
[13:36:34.145]     }
[13:36:34.145]     ...future.result$conditions <- ...future.conditions
[13:36:34.145]     ...future.result$finished <- base::Sys.time()
[13:36:34.145]     ...future.result
[13:36:34.145] }
[13:36:34.146] plan(): Setting new future strategy stack:
[13:36:34.146] List of future strategies:
[13:36:34.146] 1. sequential:
[13:36:34.146]    - args: function (..., envir = parent.frame())
[13:36:34.146]    - tweaked: FALSE
[13:36:34.146]    - call: NULL
[13:36:34.147] plan(): nbrOfWorkers() = 1
[13:36:34.147] plan(): Setting new future strategy stack:
[13:36:34.147] List of future strategies:
[13:36:34.147] 1. sequential:
[13:36:34.147]    - args: function (..., envir = parent.frame())
[13:36:34.147]    - tweaked: FALSE
[13:36:34.147]    - call: plan(strategy)
[13:36:34.148] plan(): nbrOfWorkers() = 1
[13:36:34.148] SequentialFuture started (and completed)
[13:36:34.148] - Launch lazy future ... done
[13:36:34.148] run() for ‘SequentialFuture’ ... done
[13:36:34.148] getGlobalsAndPackages() ...
[13:36:34.148] Searching for globals...
[13:36:34.150] 
[13:36:34.150] Searching for globals ... DONE
[13:36:34.150] - globals: [0] <none>
[13:36:34.150] getGlobalsAndPackages() ... DONE
[13:36:34.150] run() for ‘Future’ ...
[13:36:34.150] - state: ‘created’
[13:36:34.151] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.151] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.151]   - Field: ‘label’
[13:36:34.151]   - Field: ‘local’
[13:36:34.151]   - Field: ‘owner’
[13:36:34.151]   - Field: ‘envir’
[13:36:34.151]   - Field: ‘packages’
[13:36:34.151]   - Field: ‘gc’
[13:36:34.152]   - Field: ‘conditions’
[13:36:34.152]   - Field: ‘expr’
[13:36:34.152]   - Field: ‘uuid’
[13:36:34.152]   - Field: ‘seed’
[13:36:34.152]   - Field: ‘version’
[13:36:34.152]   - Field: ‘result’
[13:36:34.152]   - Field: ‘asynchronous’
[13:36:34.152]   - Field: ‘calls’
[13:36:34.152]   - Field: ‘globals’
[13:36:34.152]   - Field: ‘stdout’
[13:36:34.152]   - Field: ‘earlySignal’
[13:36:34.152]   - Field: ‘lazy’
[13:36:34.153]   - Field: ‘state’
[13:36:34.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.153] - Launch lazy future ...
[13:36:34.153] Packages needed by the future expression (n = 0): <none>
[13:36:34.153] Packages needed by future strategies (n = 0): <none>
[13:36:34.153] {
[13:36:34.153]     {
[13:36:34.153]         {
[13:36:34.153]             ...future.startTime <- base::Sys.time()
[13:36:34.153]             {
[13:36:34.153]                 {
[13:36:34.153]                   {
[13:36:34.153]                     base::local({
[13:36:34.153]                       has_future <- base::requireNamespace("future", 
[13:36:34.153]                         quietly = TRUE)
[13:36:34.153]                       if (has_future) {
[13:36:34.153]                         ns <- base::getNamespace("future")
[13:36:34.153]                         version <- ns[[".package"]][["version"]]
[13:36:34.153]                         if (is.null(version)) 
[13:36:34.153]                           version <- utils::packageVersion("future")
[13:36:34.153]                       }
[13:36:34.153]                       else {
[13:36:34.153]                         version <- NULL
[13:36:34.153]                       }
[13:36:34.153]                       if (!has_future || version < "1.8.0") {
[13:36:34.153]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.153]                           "", base::R.version$version.string), 
[13:36:34.153]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.153]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.153]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.153]                             "release", "version")], collapse = " "), 
[13:36:34.153]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.153]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.153]                           info)
[13:36:34.153]                         info <- base::paste(info, collapse = "; ")
[13:36:34.153]                         if (!has_future) {
[13:36:34.153]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.153]                             info)
[13:36:34.153]                         }
[13:36:34.153]                         else {
[13:36:34.153]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.153]                             info, version)
[13:36:34.153]                         }
[13:36:34.153]                         base::stop(msg)
[13:36:34.153]                       }
[13:36:34.153]                     })
[13:36:34.153]                   }
[13:36:34.153]                   ...future.strategy.old <- future::plan("list")
[13:36:34.153]                   options(future.plan = NULL)
[13:36:34.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.153]                 }
[13:36:34.153]                 ...future.workdir <- getwd()
[13:36:34.153]             }
[13:36:34.153]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.153]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.153]         }
[13:36:34.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.153]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.153]             base::names(...future.oldOptions))
[13:36:34.153]     }
[13:36:34.153]     if (FALSE) {
[13:36:34.153]     }
[13:36:34.153]     else {
[13:36:34.153]         if (TRUE) {
[13:36:34.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.153]                 open = "w")
[13:36:34.153]         }
[13:36:34.153]         else {
[13:36:34.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.153]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.153]         }
[13:36:34.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.153]             base::sink(type = "output", split = FALSE)
[13:36:34.153]             base::close(...future.stdout)
[13:36:34.153]         }, add = TRUE)
[13:36:34.153]     }
[13:36:34.153]     ...future.frame <- base::sys.nframe()
[13:36:34.153]     ...future.conditions <- base::list()
[13:36:34.153]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.153]     if (FALSE) {
[13:36:34.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.153]     }
[13:36:34.153]     ...future.result <- base::tryCatch({
[13:36:34.153]         base::withCallingHandlers({
[13:36:34.153]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.153]             future::FutureResult(value = ...future.value$value, 
[13:36:34.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.153]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.153]                     ...future.globalenv.names))
[13:36:34.153]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.153]         }, condition = base::local({
[13:36:34.153]             c <- base::c
[13:36:34.153]             inherits <- base::inherits
[13:36:34.153]             invokeRestart <- base::invokeRestart
[13:36:34.153]             length <- base::length
[13:36:34.153]             list <- base::list
[13:36:34.153]             seq.int <- base::seq.int
[13:36:34.153]             signalCondition <- base::signalCondition
[13:36:34.153]             sys.calls <- base::sys.calls
[13:36:34.153]             `[[` <- base::`[[`
[13:36:34.153]             `+` <- base::`+`
[13:36:34.153]             `<<-` <- base::`<<-`
[13:36:34.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.153]                   3L)]
[13:36:34.153]             }
[13:36:34.153]             function(cond) {
[13:36:34.153]                 is_error <- inherits(cond, "error")
[13:36:34.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.153]                   NULL)
[13:36:34.153]                 if (is_error) {
[13:36:34.153]                   sessionInformation <- function() {
[13:36:34.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.153]                       search = base::search(), system = base::Sys.info())
[13:36:34.153]                   }
[13:36:34.153]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.153]                     cond$call), session = sessionInformation(), 
[13:36:34.153]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.153]                   signalCondition(cond)
[13:36:34.153]                 }
[13:36:34.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.153]                 "immediateCondition"))) {
[13:36:34.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.153]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.153]                   if (TRUE && !signal) {
[13:36:34.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.153]                     {
[13:36:34.153]                       inherits <- base::inherits
[13:36:34.153]                       invokeRestart <- base::invokeRestart
[13:36:34.153]                       is.null <- base::is.null
[13:36:34.153]                       muffled <- FALSE
[13:36:34.153]                       if (inherits(cond, "message")) {
[13:36:34.153]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.153]                         if (muffled) 
[13:36:34.153]                           invokeRestart("muffleMessage")
[13:36:34.153]                       }
[13:36:34.153]                       else if (inherits(cond, "warning")) {
[13:36:34.153]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.153]                         if (muffled) 
[13:36:34.153]                           invokeRestart("muffleWarning")
[13:36:34.153]                       }
[13:36:34.153]                       else if (inherits(cond, "condition")) {
[13:36:34.153]                         if (!is.null(pattern)) {
[13:36:34.153]                           computeRestarts <- base::computeRestarts
[13:36:34.153]                           grepl <- base::grepl
[13:36:34.153]                           restarts <- computeRestarts(cond)
[13:36:34.153]                           for (restart in restarts) {
[13:36:34.153]                             name <- restart$name
[13:36:34.153]                             if (is.null(name)) 
[13:36:34.153]                               next
[13:36:34.153]                             if (!grepl(pattern, name)) 
[13:36:34.153]                               next
[13:36:34.153]                             invokeRestart(restart)
[13:36:34.153]                             muffled <- TRUE
[13:36:34.153]                             break
[13:36:34.153]                           }
[13:36:34.153]                         }
[13:36:34.153]                       }
[13:36:34.153]                       invisible(muffled)
[13:36:34.153]                     }
[13:36:34.153]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.153]                   }
[13:36:34.153]                 }
[13:36:34.153]                 else {
[13:36:34.153]                   if (TRUE) {
[13:36:34.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.153]                     {
[13:36:34.153]                       inherits <- base::inherits
[13:36:34.153]                       invokeRestart <- base::invokeRestart
[13:36:34.153]                       is.null <- base::is.null
[13:36:34.153]                       muffled <- FALSE
[13:36:34.153]                       if (inherits(cond, "message")) {
[13:36:34.153]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.153]                         if (muffled) 
[13:36:34.153]                           invokeRestart("muffleMessage")
[13:36:34.153]                       }
[13:36:34.153]                       else if (inherits(cond, "warning")) {
[13:36:34.153]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.153]                         if (muffled) 
[13:36:34.153]                           invokeRestart("muffleWarning")
[13:36:34.153]                       }
[13:36:34.153]                       else if (inherits(cond, "condition")) {
[13:36:34.153]                         if (!is.null(pattern)) {
[13:36:34.153]                           computeRestarts <- base::computeRestarts
[13:36:34.153]                           grepl <- base::grepl
[13:36:34.153]                           restarts <- computeRestarts(cond)
[13:36:34.153]                           for (restart in restarts) {
[13:36:34.153]                             name <- restart$name
[13:36:34.153]                             if (is.null(name)) 
[13:36:34.153]                               next
[13:36:34.153]                             if (!grepl(pattern, name)) 
[13:36:34.153]                               next
[13:36:34.153]                             invokeRestart(restart)
[13:36:34.153]                             muffled <- TRUE
[13:36:34.153]                             break
[13:36:34.153]                           }
[13:36:34.153]                         }
[13:36:34.153]                       }
[13:36:34.153]                       invisible(muffled)
[13:36:34.153]                     }
[13:36:34.153]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.153]                   }
[13:36:34.153]                 }
[13:36:34.153]             }
[13:36:34.153]         }))
[13:36:34.153]     }, error = function(ex) {
[13:36:34.153]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.153]                 ...future.rng), started = ...future.startTime, 
[13:36:34.153]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.153]             version = "1.8"), class = "FutureResult")
[13:36:34.153]     }, finally = {
[13:36:34.153]         if (!identical(...future.workdir, getwd())) 
[13:36:34.153]             setwd(...future.workdir)
[13:36:34.153]         {
[13:36:34.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.153]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.153]             }
[13:36:34.153]             base::options(...future.oldOptions)
[13:36:34.153]             if (.Platform$OS.type == "windows") {
[13:36:34.153]                 old_names <- names(...future.oldEnvVars)
[13:36:34.153]                 envs <- base::Sys.getenv()
[13:36:34.153]                 names <- names(envs)
[13:36:34.153]                 common <- intersect(names, old_names)
[13:36:34.153]                 added <- setdiff(names, old_names)
[13:36:34.153]                 removed <- setdiff(old_names, names)
[13:36:34.153]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.153]                   envs[common]]
[13:36:34.153]                 NAMES <- toupper(changed)
[13:36:34.153]                 args <- list()
[13:36:34.153]                 for (kk in seq_along(NAMES)) {
[13:36:34.153]                   name <- changed[[kk]]
[13:36:34.153]                   NAME <- NAMES[[kk]]
[13:36:34.153]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.153]                     next
[13:36:34.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.153]                 }
[13:36:34.153]                 NAMES <- toupper(added)
[13:36:34.153]                 for (kk in seq_along(NAMES)) {
[13:36:34.153]                   name <- added[[kk]]
[13:36:34.153]                   NAME <- NAMES[[kk]]
[13:36:34.153]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.153]                     next
[13:36:34.153]                   args[[name]] <- ""
[13:36:34.153]                 }
[13:36:34.153]                 NAMES <- toupper(removed)
[13:36:34.153]                 for (kk in seq_along(NAMES)) {
[13:36:34.153]                   name <- removed[[kk]]
[13:36:34.153]                   NAME <- NAMES[[kk]]
[13:36:34.153]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.153]                     next
[13:36:34.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.153]                 }
[13:36:34.153]                 if (length(args) > 0) 
[13:36:34.153]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.153]             }
[13:36:34.153]             else {
[13:36:34.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.153]             }
[13:36:34.153]             {
[13:36:34.153]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.153]                   0L) {
[13:36:34.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.153]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.153]                   base::options(opts)
[13:36:34.153]                 }
[13:36:34.153]                 {
[13:36:34.153]                   {
[13:36:34.153]                     NULL
[13:36:34.153]                     RNGkind("Mersenne-Twister")
[13:36:34.153]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.153]                       inherits = FALSE)
[13:36:34.153]                   }
[13:36:34.153]                   options(future.plan = NULL)
[13:36:34.153]                   if (is.na(NA_character_)) 
[13:36:34.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.153]                     .init = FALSE)
[13:36:34.153]                 }
[13:36:34.153]             }
[13:36:34.153]         }
[13:36:34.153]     })
[13:36:34.153]     if (TRUE) {
[13:36:34.153]         base::sink(type = "output", split = FALSE)
[13:36:34.153]         if (TRUE) {
[13:36:34.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.153]         }
[13:36:34.153]         else {
[13:36:34.153]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.153]         }
[13:36:34.153]         base::close(...future.stdout)
[13:36:34.153]         ...future.stdout <- NULL
[13:36:34.153]     }
[13:36:34.153]     ...future.result$conditions <- ...future.conditions
[13:36:34.153]     ...future.result$finished <- base::Sys.time()
[13:36:34.153]     ...future.result
[13:36:34.153] }
[13:36:34.155] plan(): Setting new future strategy stack:
[13:36:34.155] List of future strategies:
[13:36:34.155] 1. sequential:
[13:36:34.155]    - args: function (..., envir = parent.frame())
[13:36:34.155]    - tweaked: FALSE
[13:36:34.155]    - call: NULL
[13:36:34.155] plan(): nbrOfWorkers() = 1
[13:36:34.156] plan(): Setting new future strategy stack:
[13:36:34.156] List of future strategies:
[13:36:34.156] 1. sequential:
[13:36:34.156]    - args: function (..., envir = parent.frame())
[13:36:34.156]    - tweaked: FALSE
[13:36:34.156]    - call: plan(strategy)
[13:36:34.157] plan(): nbrOfWorkers() = 1
[13:36:34.157] SequentialFuture started (and completed)
[13:36:34.157] - Launch lazy future ... done
[13:36:34.157] run() for ‘SequentialFuture’ ... done
[13:36:34.157] getGlobalsAndPackages() ...
[13:36:34.158] Searching for globals...
[13:36:34.158] - globals found: [1] ‘{’
[13:36:34.158] Searching for globals ... DONE
[13:36:34.158] Resolving globals: FALSE
[13:36:34.159] 
[13:36:34.159] 
[13:36:34.159] getGlobalsAndPackages() ... DONE
[13:36:34.159] run() for ‘Future’ ...
[13:36:34.159] - state: ‘created’
[13:36:34.159] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.159] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.160]   - Field: ‘label’
[13:36:34.160]   - Field: ‘local’
[13:36:34.160]   - Field: ‘owner’
[13:36:34.160]   - Field: ‘envir’
[13:36:34.160]   - Field: ‘packages’
[13:36:34.160]   - Field: ‘gc’
[13:36:34.160]   - Field: ‘conditions’
[13:36:34.160]   - Field: ‘expr’
[13:36:34.160]   - Field: ‘uuid’
[13:36:34.160]   - Field: ‘seed’
[13:36:34.160]   - Field: ‘version’
[13:36:34.161]   - Field: ‘result’
[13:36:34.161]   - Field: ‘asynchronous’
[13:36:34.161]   - Field: ‘calls’
[13:36:34.161]   - Field: ‘globals’
[13:36:34.161]   - Field: ‘stdout’
[13:36:34.161]   - Field: ‘earlySignal’
[13:36:34.161]   - Field: ‘lazy’
[13:36:34.161]   - Field: ‘state’
[13:36:34.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.161] - Launch lazy future ...
[13:36:34.161] Packages needed by the future expression (n = 0): <none>
[13:36:34.162] Packages needed by future strategies (n = 0): <none>
[13:36:34.162] {
[13:36:34.162]     {
[13:36:34.162]         {
[13:36:34.162]             ...future.startTime <- base::Sys.time()
[13:36:34.162]             {
[13:36:34.162]                 {
[13:36:34.162]                   {
[13:36:34.162]                     base::local({
[13:36:34.162]                       has_future <- base::requireNamespace("future", 
[13:36:34.162]                         quietly = TRUE)
[13:36:34.162]                       if (has_future) {
[13:36:34.162]                         ns <- base::getNamespace("future")
[13:36:34.162]                         version <- ns[[".package"]][["version"]]
[13:36:34.162]                         if (is.null(version)) 
[13:36:34.162]                           version <- utils::packageVersion("future")
[13:36:34.162]                       }
[13:36:34.162]                       else {
[13:36:34.162]                         version <- NULL
[13:36:34.162]                       }
[13:36:34.162]                       if (!has_future || version < "1.8.0") {
[13:36:34.162]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.162]                           "", base::R.version$version.string), 
[13:36:34.162]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.162]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.162]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.162]                             "release", "version")], collapse = " "), 
[13:36:34.162]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.162]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.162]                           info)
[13:36:34.162]                         info <- base::paste(info, collapse = "; ")
[13:36:34.162]                         if (!has_future) {
[13:36:34.162]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.162]                             info)
[13:36:34.162]                         }
[13:36:34.162]                         else {
[13:36:34.162]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.162]                             info, version)
[13:36:34.162]                         }
[13:36:34.162]                         base::stop(msg)
[13:36:34.162]                       }
[13:36:34.162]                     })
[13:36:34.162]                   }
[13:36:34.162]                   ...future.strategy.old <- future::plan("list")
[13:36:34.162]                   options(future.plan = NULL)
[13:36:34.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.162]                 }
[13:36:34.162]                 ...future.workdir <- getwd()
[13:36:34.162]             }
[13:36:34.162]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.162]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.162]         }
[13:36:34.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.162]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.162]             base::names(...future.oldOptions))
[13:36:34.162]     }
[13:36:34.162]     if (FALSE) {
[13:36:34.162]     }
[13:36:34.162]     else {
[13:36:34.162]         if (TRUE) {
[13:36:34.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.162]                 open = "w")
[13:36:34.162]         }
[13:36:34.162]         else {
[13:36:34.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.162]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.162]         }
[13:36:34.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.162]             base::sink(type = "output", split = FALSE)
[13:36:34.162]             base::close(...future.stdout)
[13:36:34.162]         }, add = TRUE)
[13:36:34.162]     }
[13:36:34.162]     ...future.frame <- base::sys.nframe()
[13:36:34.162]     ...future.conditions <- base::list()
[13:36:34.162]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.162]     if (FALSE) {
[13:36:34.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.162]     }
[13:36:34.162]     ...future.result <- base::tryCatch({
[13:36:34.162]         base::withCallingHandlers({
[13:36:34.162]             ...future.value <- base::withVisible(base::local({
[13:36:34.162]                 4
[13:36:34.162]             }))
[13:36:34.162]             future::FutureResult(value = ...future.value$value, 
[13:36:34.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.162]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.162]                     ...future.globalenv.names))
[13:36:34.162]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.162]         }, condition = base::local({
[13:36:34.162]             c <- base::c
[13:36:34.162]             inherits <- base::inherits
[13:36:34.162]             invokeRestart <- base::invokeRestart
[13:36:34.162]             length <- base::length
[13:36:34.162]             list <- base::list
[13:36:34.162]             seq.int <- base::seq.int
[13:36:34.162]             signalCondition <- base::signalCondition
[13:36:34.162]             sys.calls <- base::sys.calls
[13:36:34.162]             `[[` <- base::`[[`
[13:36:34.162]             `+` <- base::`+`
[13:36:34.162]             `<<-` <- base::`<<-`
[13:36:34.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.162]                   3L)]
[13:36:34.162]             }
[13:36:34.162]             function(cond) {
[13:36:34.162]                 is_error <- inherits(cond, "error")
[13:36:34.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.162]                   NULL)
[13:36:34.162]                 if (is_error) {
[13:36:34.162]                   sessionInformation <- function() {
[13:36:34.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.162]                       search = base::search(), system = base::Sys.info())
[13:36:34.162]                   }
[13:36:34.162]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.162]                     cond$call), session = sessionInformation(), 
[13:36:34.162]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.162]                   signalCondition(cond)
[13:36:34.162]                 }
[13:36:34.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.162]                 "immediateCondition"))) {
[13:36:34.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.162]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.162]                   if (TRUE && !signal) {
[13:36:34.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.162]                     {
[13:36:34.162]                       inherits <- base::inherits
[13:36:34.162]                       invokeRestart <- base::invokeRestart
[13:36:34.162]                       is.null <- base::is.null
[13:36:34.162]                       muffled <- FALSE
[13:36:34.162]                       if (inherits(cond, "message")) {
[13:36:34.162]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.162]                         if (muffled) 
[13:36:34.162]                           invokeRestart("muffleMessage")
[13:36:34.162]                       }
[13:36:34.162]                       else if (inherits(cond, "warning")) {
[13:36:34.162]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.162]                         if (muffled) 
[13:36:34.162]                           invokeRestart("muffleWarning")
[13:36:34.162]                       }
[13:36:34.162]                       else if (inherits(cond, "condition")) {
[13:36:34.162]                         if (!is.null(pattern)) {
[13:36:34.162]                           computeRestarts <- base::computeRestarts
[13:36:34.162]                           grepl <- base::grepl
[13:36:34.162]                           restarts <- computeRestarts(cond)
[13:36:34.162]                           for (restart in restarts) {
[13:36:34.162]                             name <- restart$name
[13:36:34.162]                             if (is.null(name)) 
[13:36:34.162]                               next
[13:36:34.162]                             if (!grepl(pattern, name)) 
[13:36:34.162]                               next
[13:36:34.162]                             invokeRestart(restart)
[13:36:34.162]                             muffled <- TRUE
[13:36:34.162]                             break
[13:36:34.162]                           }
[13:36:34.162]                         }
[13:36:34.162]                       }
[13:36:34.162]                       invisible(muffled)
[13:36:34.162]                     }
[13:36:34.162]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.162]                   }
[13:36:34.162]                 }
[13:36:34.162]                 else {
[13:36:34.162]                   if (TRUE) {
[13:36:34.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.162]                     {
[13:36:34.162]                       inherits <- base::inherits
[13:36:34.162]                       invokeRestart <- base::invokeRestart
[13:36:34.162]                       is.null <- base::is.null
[13:36:34.162]                       muffled <- FALSE
[13:36:34.162]                       if (inherits(cond, "message")) {
[13:36:34.162]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.162]                         if (muffled) 
[13:36:34.162]                           invokeRestart("muffleMessage")
[13:36:34.162]                       }
[13:36:34.162]                       else if (inherits(cond, "warning")) {
[13:36:34.162]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.162]                         if (muffled) 
[13:36:34.162]                           invokeRestart("muffleWarning")
[13:36:34.162]                       }
[13:36:34.162]                       else if (inherits(cond, "condition")) {
[13:36:34.162]                         if (!is.null(pattern)) {
[13:36:34.162]                           computeRestarts <- base::computeRestarts
[13:36:34.162]                           grepl <- base::grepl
[13:36:34.162]                           restarts <- computeRestarts(cond)
[13:36:34.162]                           for (restart in restarts) {
[13:36:34.162]                             name <- restart$name
[13:36:34.162]                             if (is.null(name)) 
[13:36:34.162]                               next
[13:36:34.162]                             if (!grepl(pattern, name)) 
[13:36:34.162]                               next
[13:36:34.162]                             invokeRestart(restart)
[13:36:34.162]                             muffled <- TRUE
[13:36:34.162]                             break
[13:36:34.162]                           }
[13:36:34.162]                         }
[13:36:34.162]                       }
[13:36:34.162]                       invisible(muffled)
[13:36:34.162]                     }
[13:36:34.162]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.162]                   }
[13:36:34.162]                 }
[13:36:34.162]             }
[13:36:34.162]         }))
[13:36:34.162]     }, error = function(ex) {
[13:36:34.162]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.162]                 ...future.rng), started = ...future.startTime, 
[13:36:34.162]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.162]             version = "1.8"), class = "FutureResult")
[13:36:34.162]     }, finally = {
[13:36:34.162]         if (!identical(...future.workdir, getwd())) 
[13:36:34.162]             setwd(...future.workdir)
[13:36:34.162]         {
[13:36:34.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.162]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.162]             }
[13:36:34.162]             base::options(...future.oldOptions)
[13:36:34.162]             if (.Platform$OS.type == "windows") {
[13:36:34.162]                 old_names <- names(...future.oldEnvVars)
[13:36:34.162]                 envs <- base::Sys.getenv()
[13:36:34.162]                 names <- names(envs)
[13:36:34.162]                 common <- intersect(names, old_names)
[13:36:34.162]                 added <- setdiff(names, old_names)
[13:36:34.162]                 removed <- setdiff(old_names, names)
[13:36:34.162]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.162]                   envs[common]]
[13:36:34.162]                 NAMES <- toupper(changed)
[13:36:34.162]                 args <- list()
[13:36:34.162]                 for (kk in seq_along(NAMES)) {
[13:36:34.162]                   name <- changed[[kk]]
[13:36:34.162]                   NAME <- NAMES[[kk]]
[13:36:34.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.162]                     next
[13:36:34.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.162]                 }
[13:36:34.162]                 NAMES <- toupper(added)
[13:36:34.162]                 for (kk in seq_along(NAMES)) {
[13:36:34.162]                   name <- added[[kk]]
[13:36:34.162]                   NAME <- NAMES[[kk]]
[13:36:34.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.162]                     next
[13:36:34.162]                   args[[name]] <- ""
[13:36:34.162]                 }
[13:36:34.162]                 NAMES <- toupper(removed)
[13:36:34.162]                 for (kk in seq_along(NAMES)) {
[13:36:34.162]                   name <- removed[[kk]]
[13:36:34.162]                   NAME <- NAMES[[kk]]
[13:36:34.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.162]                     next
[13:36:34.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.162]                 }
[13:36:34.162]                 if (length(args) > 0) 
[13:36:34.162]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.162]             }
[13:36:34.162]             else {
[13:36:34.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.162]             }
[13:36:34.162]             {
[13:36:34.162]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.162]                   0L) {
[13:36:34.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.162]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.162]                   base::options(opts)
[13:36:34.162]                 }
[13:36:34.162]                 {
[13:36:34.162]                   {
[13:36:34.162]                     NULL
[13:36:34.162]                     RNGkind("Mersenne-Twister")
[13:36:34.162]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.162]                       inherits = FALSE)
[13:36:34.162]                   }
[13:36:34.162]                   options(future.plan = NULL)
[13:36:34.162]                   if (is.na(NA_character_)) 
[13:36:34.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.162]                     .init = FALSE)
[13:36:34.162]                 }
[13:36:34.162]             }
[13:36:34.162]         }
[13:36:34.162]     })
[13:36:34.162]     if (TRUE) {
[13:36:34.162]         base::sink(type = "output", split = FALSE)
[13:36:34.162]         if (TRUE) {
[13:36:34.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.162]         }
[13:36:34.162]         else {
[13:36:34.162]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.162]         }
[13:36:34.162]         base::close(...future.stdout)
[13:36:34.162]         ...future.stdout <- NULL
[13:36:34.162]     }
[13:36:34.162]     ...future.result$conditions <- ...future.conditions
[13:36:34.162]     ...future.result$finished <- base::Sys.time()
[13:36:34.162]     ...future.result
[13:36:34.162] }
[13:36:34.164] plan(): Setting new future strategy stack:
[13:36:34.164] List of future strategies:
[13:36:34.164] 1. sequential:
[13:36:34.164]    - args: function (..., envir = parent.frame())
[13:36:34.164]    - tweaked: FALSE
[13:36:34.164]    - call: NULL
[13:36:34.164] plan(): nbrOfWorkers() = 1
[13:36:34.165] plan(): Setting new future strategy stack:
[13:36:34.165] List of future strategies:
[13:36:34.165] 1. sequential:
[13:36:34.165]    - args: function (..., envir = parent.frame())
[13:36:34.165]    - tweaked: FALSE
[13:36:34.165]    - call: plan(strategy)
[13:36:34.165] plan(): nbrOfWorkers() = 1
[13:36:34.165] SequentialFuture started (and completed)
[13:36:34.165] - Launch lazy future ... done
[13:36:34.166] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a731bb118> 
Classes 'listenv', 'environment' <environment: 0x564a730e2578> 
[13:36:34.169] resolved() for ‘SequentialFuture’ ...
[13:36:34.169] - state: ‘finished’
[13:36:34.169] - run: TRUE
[13:36:34.169] - result: ‘FutureResult’
[13:36:34.169] resolved() for ‘SequentialFuture’ ... done
[13:36:34.169] resolved() for ‘SequentialFuture’ ...
[13:36:34.169] - state: ‘finished’
[13:36:34.169] - run: TRUE
[13:36:34.169] - result: ‘FutureResult’
[13:36:34.169] resolved() for ‘SequentialFuture’ ... done
[13:36:34.169] resolved() for ‘SequentialFuture’ ...
[13:36:34.170] - state: ‘finished’
[13:36:34.170] - run: TRUE
[13:36:34.170] - result: ‘FutureResult’
[13:36:34.170] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:34.172] resolve() on list environment ...
[13:36:34.172]  recursive: 0
[13:36:34.173]  length: 6
[13:36:34.173]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:34.173] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.173] - nx: 6
[13:36:34.173] - relay: TRUE
[13:36:34.173] - stdout: TRUE
[13:36:34.173] - signal: TRUE
[13:36:34.173] - resignal: FALSE
[13:36:34.173] - force: TRUE
[13:36:34.173] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.173] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.174]  - until=2
[13:36:34.174]  - relaying element #2
[13:36:34.175] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.175] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.175] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.175]  length: 5 (resolved future 1)
[13:36:34.175] resolved() for ‘SequentialFuture’ ...
[13:36:34.175] - state: ‘finished’
[13:36:34.175] - run: TRUE
[13:36:34.176] - result: ‘FutureResult’
[13:36:34.176] resolved() for ‘SequentialFuture’ ... done
[13:36:34.176] Future #2
[13:36:34.176] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.176] - nx: 6
[13:36:34.176] - relay: TRUE
[13:36:34.176] - stdout: TRUE
[13:36:34.176] - signal: TRUE
[13:36:34.176] - resignal: FALSE
[13:36:34.176] - force: TRUE
[13:36:34.176] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.176] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.177]  - until=2
[13:36:34.177]  - relaying element #2
[13:36:34.177] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.177] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.177] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.177]  length: 4 (resolved future 2)
[13:36:34.177] resolved() for ‘SequentialFuture’ ...
[13:36:34.177] - state: ‘finished’
[13:36:34.177] - run: TRUE
[13:36:34.177] - result: ‘FutureResult’
[13:36:34.178] resolved() for ‘SequentialFuture’ ... done
[13:36:34.178] Future #3
[13:36:34.178] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.178] - nx: 6
[13:36:34.178] - relay: TRUE
[13:36:34.178] - stdout: TRUE
[13:36:34.178] - signal: TRUE
[13:36:34.178] - resignal: FALSE
[13:36:34.178] - force: TRUE
[13:36:34.178] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.178] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.179]  - until=3
[13:36:34.179]  - relaying element #3
[13:36:34.179] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.179] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.179] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.179]  length: 3 (resolved future 3)
[13:36:34.179] resolved() for ‘SequentialFuture’ ...
[13:36:34.179] - state: ‘finished’
[13:36:34.179] - run: TRUE
[13:36:34.179] - result: ‘FutureResult’
[13:36:34.180] resolved() for ‘SequentialFuture’ ... done
[13:36:34.180] Future #4
[13:36:34.180] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.180] - nx: 6
[13:36:34.180] - relay: TRUE
[13:36:34.180] - stdout: TRUE
[13:36:34.180] - signal: TRUE
[13:36:34.180] - resignal: FALSE
[13:36:34.180] - force: TRUE
[13:36:34.180] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.180] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.180]  - until=4
[13:36:34.181]  - relaying element #4
[13:36:34.181] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.181] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.181] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.181]  length: 2 (resolved future 4)
[13:36:34.181] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.181] - nx: 6
[13:36:34.181] - relay: TRUE
[13:36:34.181] - stdout: TRUE
[13:36:34.181] - signal: TRUE
[13:36:34.181] - resignal: FALSE
[13:36:34.182] - force: TRUE
[13:36:34.182] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.182] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.182]  - until=6
[13:36:34.182]  - relaying element #6
[13:36:34.182] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.182] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.182] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.182]  length: 1 (resolved future 5)
[13:36:34.182] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.182] - nx: 6
[13:36:34.183] - relay: TRUE
[13:36:34.183] - stdout: TRUE
[13:36:34.183] - signal: TRUE
[13:36:34.183] - resignal: FALSE
[13:36:34.183] - force: TRUE
[13:36:34.183] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.183] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.183]  - until=6
[13:36:34.183] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.183] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.183] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.183]  length: 0 (resolved future 6)
[13:36:34.184] Relaying remaining futures
[13:36:34.184] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.184] - nx: 6
[13:36:34.184] - relay: TRUE
[13:36:34.184] - stdout: TRUE
[13:36:34.184] - signal: TRUE
[13:36:34.184] - resignal: FALSE
[13:36:34.184] - force: TRUE
[13:36:34.184] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.184] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:34.184] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.184] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.185] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.185] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x564a73424f28> 
Dimensions: c(1, 6)
[13:36:34.185] getGlobalsAndPackages() ...
[13:36:34.185] Searching for globals...
[13:36:34.186] 
[13:36:34.186] Searching for globals ... DONE
[13:36:34.186] - globals: [0] <none>
[13:36:34.186] getGlobalsAndPackages() ... DONE
[13:36:34.186] run() for ‘Future’ ...
[13:36:34.186] - state: ‘created’
[13:36:34.186] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.187] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.187]   - Field: ‘label’
[13:36:34.187]   - Field: ‘local’
[13:36:34.187]   - Field: ‘owner’
[13:36:34.187]   - Field: ‘envir’
[13:36:34.187]   - Field: ‘packages’
[13:36:34.187]   - Field: ‘gc’
[13:36:34.187]   - Field: ‘conditions’
[13:36:34.188]   - Field: ‘expr’
[13:36:34.188]   - Field: ‘uuid’
[13:36:34.188]   - Field: ‘seed’
[13:36:34.188]   - Field: ‘version’
[13:36:34.188]   - Field: ‘result’
[13:36:34.188]   - Field: ‘asynchronous’
[13:36:34.188]   - Field: ‘calls’
[13:36:34.188]   - Field: ‘globals’
[13:36:34.188]   - Field: ‘stdout’
[13:36:34.188]   - Field: ‘earlySignal’
[13:36:34.188]   - Field: ‘lazy’
[13:36:34.189]   - Field: ‘state’
[13:36:34.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.189] - Launch lazy future ...
[13:36:34.189] Packages needed by the future expression (n = 0): <none>
[13:36:34.189] Packages needed by future strategies (n = 0): <none>
[13:36:34.189] {
[13:36:34.189]     {
[13:36:34.189]         {
[13:36:34.189]             ...future.startTime <- base::Sys.time()
[13:36:34.189]             {
[13:36:34.189]                 {
[13:36:34.189]                   {
[13:36:34.189]                     base::local({
[13:36:34.189]                       has_future <- base::requireNamespace("future", 
[13:36:34.189]                         quietly = TRUE)
[13:36:34.189]                       if (has_future) {
[13:36:34.189]                         ns <- base::getNamespace("future")
[13:36:34.189]                         version <- ns[[".package"]][["version"]]
[13:36:34.189]                         if (is.null(version)) 
[13:36:34.189]                           version <- utils::packageVersion("future")
[13:36:34.189]                       }
[13:36:34.189]                       else {
[13:36:34.189]                         version <- NULL
[13:36:34.189]                       }
[13:36:34.189]                       if (!has_future || version < "1.8.0") {
[13:36:34.189]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.189]                           "", base::R.version$version.string), 
[13:36:34.189]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.189]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.189]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.189]                             "release", "version")], collapse = " "), 
[13:36:34.189]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.189]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.189]                           info)
[13:36:34.189]                         info <- base::paste(info, collapse = "; ")
[13:36:34.189]                         if (!has_future) {
[13:36:34.189]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.189]                             info)
[13:36:34.189]                         }
[13:36:34.189]                         else {
[13:36:34.189]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.189]                             info, version)
[13:36:34.189]                         }
[13:36:34.189]                         base::stop(msg)
[13:36:34.189]                       }
[13:36:34.189]                     })
[13:36:34.189]                   }
[13:36:34.189]                   ...future.strategy.old <- future::plan("list")
[13:36:34.189]                   options(future.plan = NULL)
[13:36:34.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.189]                 }
[13:36:34.189]                 ...future.workdir <- getwd()
[13:36:34.189]             }
[13:36:34.189]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.189]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.189]         }
[13:36:34.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.189]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.189]             base::names(...future.oldOptions))
[13:36:34.189]     }
[13:36:34.189]     if (FALSE) {
[13:36:34.189]     }
[13:36:34.189]     else {
[13:36:34.189]         if (TRUE) {
[13:36:34.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.189]                 open = "w")
[13:36:34.189]         }
[13:36:34.189]         else {
[13:36:34.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.189]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.189]         }
[13:36:34.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.189]             base::sink(type = "output", split = FALSE)
[13:36:34.189]             base::close(...future.stdout)
[13:36:34.189]         }, add = TRUE)
[13:36:34.189]     }
[13:36:34.189]     ...future.frame <- base::sys.nframe()
[13:36:34.189]     ...future.conditions <- base::list()
[13:36:34.189]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.189]     if (FALSE) {
[13:36:34.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.189]     }
[13:36:34.189]     ...future.result <- base::tryCatch({
[13:36:34.189]         base::withCallingHandlers({
[13:36:34.189]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.189]             future::FutureResult(value = ...future.value$value, 
[13:36:34.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.189]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.189]                     ...future.globalenv.names))
[13:36:34.189]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.189]         }, condition = base::local({
[13:36:34.189]             c <- base::c
[13:36:34.189]             inherits <- base::inherits
[13:36:34.189]             invokeRestart <- base::invokeRestart
[13:36:34.189]             length <- base::length
[13:36:34.189]             list <- base::list
[13:36:34.189]             seq.int <- base::seq.int
[13:36:34.189]             signalCondition <- base::signalCondition
[13:36:34.189]             sys.calls <- base::sys.calls
[13:36:34.189]             `[[` <- base::`[[`
[13:36:34.189]             `+` <- base::`+`
[13:36:34.189]             `<<-` <- base::`<<-`
[13:36:34.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.189]                   3L)]
[13:36:34.189]             }
[13:36:34.189]             function(cond) {
[13:36:34.189]                 is_error <- inherits(cond, "error")
[13:36:34.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.189]                   NULL)
[13:36:34.189]                 if (is_error) {
[13:36:34.189]                   sessionInformation <- function() {
[13:36:34.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.189]                       search = base::search(), system = base::Sys.info())
[13:36:34.189]                   }
[13:36:34.189]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.189]                     cond$call), session = sessionInformation(), 
[13:36:34.189]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.189]                   signalCondition(cond)
[13:36:34.189]                 }
[13:36:34.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.189]                 "immediateCondition"))) {
[13:36:34.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.189]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.189]                   if (TRUE && !signal) {
[13:36:34.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.189]                     {
[13:36:34.189]                       inherits <- base::inherits
[13:36:34.189]                       invokeRestart <- base::invokeRestart
[13:36:34.189]                       is.null <- base::is.null
[13:36:34.189]                       muffled <- FALSE
[13:36:34.189]                       if (inherits(cond, "message")) {
[13:36:34.189]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.189]                         if (muffled) 
[13:36:34.189]                           invokeRestart("muffleMessage")
[13:36:34.189]                       }
[13:36:34.189]                       else if (inherits(cond, "warning")) {
[13:36:34.189]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.189]                         if (muffled) 
[13:36:34.189]                           invokeRestart("muffleWarning")
[13:36:34.189]                       }
[13:36:34.189]                       else if (inherits(cond, "condition")) {
[13:36:34.189]                         if (!is.null(pattern)) {
[13:36:34.189]                           computeRestarts <- base::computeRestarts
[13:36:34.189]                           grepl <- base::grepl
[13:36:34.189]                           restarts <- computeRestarts(cond)
[13:36:34.189]                           for (restart in restarts) {
[13:36:34.189]                             name <- restart$name
[13:36:34.189]                             if (is.null(name)) 
[13:36:34.189]                               next
[13:36:34.189]                             if (!grepl(pattern, name)) 
[13:36:34.189]                               next
[13:36:34.189]                             invokeRestart(restart)
[13:36:34.189]                             muffled <- TRUE
[13:36:34.189]                             break
[13:36:34.189]                           }
[13:36:34.189]                         }
[13:36:34.189]                       }
[13:36:34.189]                       invisible(muffled)
[13:36:34.189]                     }
[13:36:34.189]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.189]                   }
[13:36:34.189]                 }
[13:36:34.189]                 else {
[13:36:34.189]                   if (TRUE) {
[13:36:34.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.189]                     {
[13:36:34.189]                       inherits <- base::inherits
[13:36:34.189]                       invokeRestart <- base::invokeRestart
[13:36:34.189]                       is.null <- base::is.null
[13:36:34.189]                       muffled <- FALSE
[13:36:34.189]                       if (inherits(cond, "message")) {
[13:36:34.189]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.189]                         if (muffled) 
[13:36:34.189]                           invokeRestart("muffleMessage")
[13:36:34.189]                       }
[13:36:34.189]                       else if (inherits(cond, "warning")) {
[13:36:34.189]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.189]                         if (muffled) 
[13:36:34.189]                           invokeRestart("muffleWarning")
[13:36:34.189]                       }
[13:36:34.189]                       else if (inherits(cond, "condition")) {
[13:36:34.189]                         if (!is.null(pattern)) {
[13:36:34.189]                           computeRestarts <- base::computeRestarts
[13:36:34.189]                           grepl <- base::grepl
[13:36:34.189]                           restarts <- computeRestarts(cond)
[13:36:34.189]                           for (restart in restarts) {
[13:36:34.189]                             name <- restart$name
[13:36:34.189]                             if (is.null(name)) 
[13:36:34.189]                               next
[13:36:34.189]                             if (!grepl(pattern, name)) 
[13:36:34.189]                               next
[13:36:34.189]                             invokeRestart(restart)
[13:36:34.189]                             muffled <- TRUE
[13:36:34.189]                             break
[13:36:34.189]                           }
[13:36:34.189]                         }
[13:36:34.189]                       }
[13:36:34.189]                       invisible(muffled)
[13:36:34.189]                     }
[13:36:34.189]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.189]                   }
[13:36:34.189]                 }
[13:36:34.189]             }
[13:36:34.189]         }))
[13:36:34.189]     }, error = function(ex) {
[13:36:34.189]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.189]                 ...future.rng), started = ...future.startTime, 
[13:36:34.189]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.189]             version = "1.8"), class = "FutureResult")
[13:36:34.189]     }, finally = {
[13:36:34.189]         if (!identical(...future.workdir, getwd())) 
[13:36:34.189]             setwd(...future.workdir)
[13:36:34.189]         {
[13:36:34.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.189]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.189]             }
[13:36:34.189]             base::options(...future.oldOptions)
[13:36:34.189]             if (.Platform$OS.type == "windows") {
[13:36:34.189]                 old_names <- names(...future.oldEnvVars)
[13:36:34.189]                 envs <- base::Sys.getenv()
[13:36:34.189]                 names <- names(envs)
[13:36:34.189]                 common <- intersect(names, old_names)
[13:36:34.189]                 added <- setdiff(names, old_names)
[13:36:34.189]                 removed <- setdiff(old_names, names)
[13:36:34.189]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.189]                   envs[common]]
[13:36:34.189]                 NAMES <- toupper(changed)
[13:36:34.189]                 args <- list()
[13:36:34.189]                 for (kk in seq_along(NAMES)) {
[13:36:34.189]                   name <- changed[[kk]]
[13:36:34.189]                   NAME <- NAMES[[kk]]
[13:36:34.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.189]                     next
[13:36:34.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.189]                 }
[13:36:34.189]                 NAMES <- toupper(added)
[13:36:34.189]                 for (kk in seq_along(NAMES)) {
[13:36:34.189]                   name <- added[[kk]]
[13:36:34.189]                   NAME <- NAMES[[kk]]
[13:36:34.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.189]                     next
[13:36:34.189]                   args[[name]] <- ""
[13:36:34.189]                 }
[13:36:34.189]                 NAMES <- toupper(removed)
[13:36:34.189]                 for (kk in seq_along(NAMES)) {
[13:36:34.189]                   name <- removed[[kk]]
[13:36:34.189]                   NAME <- NAMES[[kk]]
[13:36:34.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.189]                     next
[13:36:34.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.189]                 }
[13:36:34.189]                 if (length(args) > 0) 
[13:36:34.189]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.189]             }
[13:36:34.189]             else {
[13:36:34.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.189]             }
[13:36:34.189]             {
[13:36:34.189]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.189]                   0L) {
[13:36:34.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.189]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.189]                   base::options(opts)
[13:36:34.189]                 }
[13:36:34.189]                 {
[13:36:34.189]                   {
[13:36:34.189]                     NULL
[13:36:34.189]                     RNGkind("Mersenne-Twister")
[13:36:34.189]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.189]                       inherits = FALSE)
[13:36:34.189]                   }
[13:36:34.189]                   options(future.plan = NULL)
[13:36:34.189]                   if (is.na(NA_character_)) 
[13:36:34.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.189]                     .init = FALSE)
[13:36:34.189]                 }
[13:36:34.189]             }
[13:36:34.189]         }
[13:36:34.189]     })
[13:36:34.189]     if (TRUE) {
[13:36:34.189]         base::sink(type = "output", split = FALSE)
[13:36:34.189]         if (TRUE) {
[13:36:34.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.189]         }
[13:36:34.189]         else {
[13:36:34.189]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.189]         }
[13:36:34.189]         base::close(...future.stdout)
[13:36:34.189]         ...future.stdout <- NULL
[13:36:34.189]     }
[13:36:34.189]     ...future.result$conditions <- ...future.conditions
[13:36:34.189]     ...future.result$finished <- base::Sys.time()
[13:36:34.189]     ...future.result
[13:36:34.189] }
[13:36:34.191] plan(): Setting new future strategy stack:
[13:36:34.191] List of future strategies:
[13:36:34.191] 1. sequential:
[13:36:34.191]    - args: function (..., envir = parent.frame())
[13:36:34.191]    - tweaked: FALSE
[13:36:34.191]    - call: NULL
[13:36:34.191] plan(): nbrOfWorkers() = 1
[13:36:34.192] plan(): Setting new future strategy stack:
[13:36:34.192] List of future strategies:
[13:36:34.192] 1. sequential:
[13:36:34.192]    - args: function (..., envir = parent.frame())
[13:36:34.192]    - tweaked: FALSE
[13:36:34.192]    - call: plan(strategy)
[13:36:34.193] plan(): nbrOfWorkers() = 1
[13:36:34.193] SequentialFuture started (and completed)
[13:36:34.193] - Launch lazy future ... done
[13:36:34.193] run() for ‘SequentialFuture’ ... done
[13:36:34.193] getGlobalsAndPackages() ...
[13:36:34.193] Searching for globals...
[13:36:34.193] 
[13:36:34.193] Searching for globals ... DONE
[13:36:34.194] - globals: [0] <none>
[13:36:34.194] getGlobalsAndPackages() ... DONE
[13:36:34.194] run() for ‘Future’ ...
[13:36:34.194] - state: ‘created’
[13:36:34.194] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.194] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.194]   - Field: ‘label’
[13:36:34.195]   - Field: ‘local’
[13:36:34.195]   - Field: ‘owner’
[13:36:34.195]   - Field: ‘envir’
[13:36:34.195]   - Field: ‘packages’
[13:36:34.195]   - Field: ‘gc’
[13:36:34.195]   - Field: ‘conditions’
[13:36:34.195]   - Field: ‘expr’
[13:36:34.195]   - Field: ‘uuid’
[13:36:34.195]   - Field: ‘seed’
[13:36:34.195]   - Field: ‘version’
[13:36:34.195]   - Field: ‘result’
[13:36:34.196]   - Field: ‘asynchronous’
[13:36:34.196]   - Field: ‘calls’
[13:36:34.196]   - Field: ‘globals’
[13:36:34.196]   - Field: ‘stdout’
[13:36:34.196]   - Field: ‘earlySignal’
[13:36:34.196]   - Field: ‘lazy’
[13:36:34.196]   - Field: ‘state’
[13:36:34.221] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.221] - Launch lazy future ...
[13:36:34.221] Packages needed by the future expression (n = 0): <none>
[13:36:34.221] Packages needed by future strategies (n = 0): <none>
[13:36:34.222] {
[13:36:34.222]     {
[13:36:34.222]         {
[13:36:34.222]             ...future.startTime <- base::Sys.time()
[13:36:34.222]             {
[13:36:34.222]                 {
[13:36:34.222]                   {
[13:36:34.222]                     base::local({
[13:36:34.222]                       has_future <- base::requireNamespace("future", 
[13:36:34.222]                         quietly = TRUE)
[13:36:34.222]                       if (has_future) {
[13:36:34.222]                         ns <- base::getNamespace("future")
[13:36:34.222]                         version <- ns[[".package"]][["version"]]
[13:36:34.222]                         if (is.null(version)) 
[13:36:34.222]                           version <- utils::packageVersion("future")
[13:36:34.222]                       }
[13:36:34.222]                       else {
[13:36:34.222]                         version <- NULL
[13:36:34.222]                       }
[13:36:34.222]                       if (!has_future || version < "1.8.0") {
[13:36:34.222]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.222]                           "", base::R.version$version.string), 
[13:36:34.222]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.222]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.222]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.222]                             "release", "version")], collapse = " "), 
[13:36:34.222]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.222]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.222]                           info)
[13:36:34.222]                         info <- base::paste(info, collapse = "; ")
[13:36:34.222]                         if (!has_future) {
[13:36:34.222]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.222]                             info)
[13:36:34.222]                         }
[13:36:34.222]                         else {
[13:36:34.222]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.222]                             info, version)
[13:36:34.222]                         }
[13:36:34.222]                         base::stop(msg)
[13:36:34.222]                       }
[13:36:34.222]                     })
[13:36:34.222]                   }
[13:36:34.222]                   ...future.strategy.old <- future::plan("list")
[13:36:34.222]                   options(future.plan = NULL)
[13:36:34.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.222]                 }
[13:36:34.222]                 ...future.workdir <- getwd()
[13:36:34.222]             }
[13:36:34.222]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.222]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.222]         }
[13:36:34.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.222]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.222]             base::names(...future.oldOptions))
[13:36:34.222]     }
[13:36:34.222]     if (FALSE) {
[13:36:34.222]     }
[13:36:34.222]     else {
[13:36:34.222]         if (TRUE) {
[13:36:34.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.222]                 open = "w")
[13:36:34.222]         }
[13:36:34.222]         else {
[13:36:34.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.222]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.222]         }
[13:36:34.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.222]             base::sink(type = "output", split = FALSE)
[13:36:34.222]             base::close(...future.stdout)
[13:36:34.222]         }, add = TRUE)
[13:36:34.222]     }
[13:36:34.222]     ...future.frame <- base::sys.nframe()
[13:36:34.222]     ...future.conditions <- base::list()
[13:36:34.222]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.222]     if (FALSE) {
[13:36:34.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.222]     }
[13:36:34.222]     ...future.result <- base::tryCatch({
[13:36:34.222]         base::withCallingHandlers({
[13:36:34.222]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.222]             future::FutureResult(value = ...future.value$value, 
[13:36:34.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.222]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.222]                     ...future.globalenv.names))
[13:36:34.222]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.222]         }, condition = base::local({
[13:36:34.222]             c <- base::c
[13:36:34.222]             inherits <- base::inherits
[13:36:34.222]             invokeRestart <- base::invokeRestart
[13:36:34.222]             length <- base::length
[13:36:34.222]             list <- base::list
[13:36:34.222]             seq.int <- base::seq.int
[13:36:34.222]             signalCondition <- base::signalCondition
[13:36:34.222]             sys.calls <- base::sys.calls
[13:36:34.222]             `[[` <- base::`[[`
[13:36:34.222]             `+` <- base::`+`
[13:36:34.222]             `<<-` <- base::`<<-`
[13:36:34.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.222]                   3L)]
[13:36:34.222]             }
[13:36:34.222]             function(cond) {
[13:36:34.222]                 is_error <- inherits(cond, "error")
[13:36:34.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.222]                   NULL)
[13:36:34.222]                 if (is_error) {
[13:36:34.222]                   sessionInformation <- function() {
[13:36:34.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.222]                       search = base::search(), system = base::Sys.info())
[13:36:34.222]                   }
[13:36:34.222]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.222]                     cond$call), session = sessionInformation(), 
[13:36:34.222]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.222]                   signalCondition(cond)
[13:36:34.222]                 }
[13:36:34.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.222]                 "immediateCondition"))) {
[13:36:34.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.222]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.222]                   if (TRUE && !signal) {
[13:36:34.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.222]                     {
[13:36:34.222]                       inherits <- base::inherits
[13:36:34.222]                       invokeRestart <- base::invokeRestart
[13:36:34.222]                       is.null <- base::is.null
[13:36:34.222]                       muffled <- FALSE
[13:36:34.222]                       if (inherits(cond, "message")) {
[13:36:34.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.222]                         if (muffled) 
[13:36:34.222]                           invokeRestart("muffleMessage")
[13:36:34.222]                       }
[13:36:34.222]                       else if (inherits(cond, "warning")) {
[13:36:34.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.222]                         if (muffled) 
[13:36:34.222]                           invokeRestart("muffleWarning")
[13:36:34.222]                       }
[13:36:34.222]                       else if (inherits(cond, "condition")) {
[13:36:34.222]                         if (!is.null(pattern)) {
[13:36:34.222]                           computeRestarts <- base::computeRestarts
[13:36:34.222]                           grepl <- base::grepl
[13:36:34.222]                           restarts <- computeRestarts(cond)
[13:36:34.222]                           for (restart in restarts) {
[13:36:34.222]                             name <- restart$name
[13:36:34.222]                             if (is.null(name)) 
[13:36:34.222]                               next
[13:36:34.222]                             if (!grepl(pattern, name)) 
[13:36:34.222]                               next
[13:36:34.222]                             invokeRestart(restart)
[13:36:34.222]                             muffled <- TRUE
[13:36:34.222]                             break
[13:36:34.222]                           }
[13:36:34.222]                         }
[13:36:34.222]                       }
[13:36:34.222]                       invisible(muffled)
[13:36:34.222]                     }
[13:36:34.222]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.222]                   }
[13:36:34.222]                 }
[13:36:34.222]                 else {
[13:36:34.222]                   if (TRUE) {
[13:36:34.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.222]                     {
[13:36:34.222]                       inherits <- base::inherits
[13:36:34.222]                       invokeRestart <- base::invokeRestart
[13:36:34.222]                       is.null <- base::is.null
[13:36:34.222]                       muffled <- FALSE
[13:36:34.222]                       if (inherits(cond, "message")) {
[13:36:34.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.222]                         if (muffled) 
[13:36:34.222]                           invokeRestart("muffleMessage")
[13:36:34.222]                       }
[13:36:34.222]                       else if (inherits(cond, "warning")) {
[13:36:34.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.222]                         if (muffled) 
[13:36:34.222]                           invokeRestart("muffleWarning")
[13:36:34.222]                       }
[13:36:34.222]                       else if (inherits(cond, "condition")) {
[13:36:34.222]                         if (!is.null(pattern)) {
[13:36:34.222]                           computeRestarts <- base::computeRestarts
[13:36:34.222]                           grepl <- base::grepl
[13:36:34.222]                           restarts <- computeRestarts(cond)
[13:36:34.222]                           for (restart in restarts) {
[13:36:34.222]                             name <- restart$name
[13:36:34.222]                             if (is.null(name)) 
[13:36:34.222]                               next
[13:36:34.222]                             if (!grepl(pattern, name)) 
[13:36:34.222]                               next
[13:36:34.222]                             invokeRestart(restart)
[13:36:34.222]                             muffled <- TRUE
[13:36:34.222]                             break
[13:36:34.222]                           }
[13:36:34.222]                         }
[13:36:34.222]                       }
[13:36:34.222]                       invisible(muffled)
[13:36:34.222]                     }
[13:36:34.222]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.222]                   }
[13:36:34.222]                 }
[13:36:34.222]             }
[13:36:34.222]         }))
[13:36:34.222]     }, error = function(ex) {
[13:36:34.222]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.222]                 ...future.rng), started = ...future.startTime, 
[13:36:34.222]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.222]             version = "1.8"), class = "FutureResult")
[13:36:34.222]     }, finally = {
[13:36:34.222]         if (!identical(...future.workdir, getwd())) 
[13:36:34.222]             setwd(...future.workdir)
[13:36:34.222]         {
[13:36:34.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.222]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.222]             }
[13:36:34.222]             base::options(...future.oldOptions)
[13:36:34.222]             if (.Platform$OS.type == "windows") {
[13:36:34.222]                 old_names <- names(...future.oldEnvVars)
[13:36:34.222]                 envs <- base::Sys.getenv()
[13:36:34.222]                 names <- names(envs)
[13:36:34.222]                 common <- intersect(names, old_names)
[13:36:34.222]                 added <- setdiff(names, old_names)
[13:36:34.222]                 removed <- setdiff(old_names, names)
[13:36:34.222]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.222]                   envs[common]]
[13:36:34.222]                 NAMES <- toupper(changed)
[13:36:34.222]                 args <- list()
[13:36:34.222]                 for (kk in seq_along(NAMES)) {
[13:36:34.222]                   name <- changed[[kk]]
[13:36:34.222]                   NAME <- NAMES[[kk]]
[13:36:34.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.222]                     next
[13:36:34.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.222]                 }
[13:36:34.222]                 NAMES <- toupper(added)
[13:36:34.222]                 for (kk in seq_along(NAMES)) {
[13:36:34.222]                   name <- added[[kk]]
[13:36:34.222]                   NAME <- NAMES[[kk]]
[13:36:34.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.222]                     next
[13:36:34.222]                   args[[name]] <- ""
[13:36:34.222]                 }
[13:36:34.222]                 NAMES <- toupper(removed)
[13:36:34.222]                 for (kk in seq_along(NAMES)) {
[13:36:34.222]                   name <- removed[[kk]]
[13:36:34.222]                   NAME <- NAMES[[kk]]
[13:36:34.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.222]                     next
[13:36:34.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.222]                 }
[13:36:34.222]                 if (length(args) > 0) 
[13:36:34.222]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.222]             }
[13:36:34.222]             else {
[13:36:34.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.222]             }
[13:36:34.222]             {
[13:36:34.222]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.222]                   0L) {
[13:36:34.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.222]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.222]                   base::options(opts)
[13:36:34.222]                 }
[13:36:34.222]                 {
[13:36:34.222]                   {
[13:36:34.222]                     NULL
[13:36:34.222]                     RNGkind("Mersenne-Twister")
[13:36:34.222]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.222]                       inherits = FALSE)
[13:36:34.222]                   }
[13:36:34.222]                   options(future.plan = NULL)
[13:36:34.222]                   if (is.na(NA_character_)) 
[13:36:34.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.222]                     .init = FALSE)
[13:36:34.222]                 }
[13:36:34.222]             }
[13:36:34.222]         }
[13:36:34.222]     })
[13:36:34.222]     if (TRUE) {
[13:36:34.222]         base::sink(type = "output", split = FALSE)
[13:36:34.222]         if (TRUE) {
[13:36:34.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.222]         }
[13:36:34.222]         else {
[13:36:34.222]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.222]         }
[13:36:34.222]         base::close(...future.stdout)
[13:36:34.222]         ...future.stdout <- NULL
[13:36:34.222]     }
[13:36:34.222]     ...future.result$conditions <- ...future.conditions
[13:36:34.222]     ...future.result$finished <- base::Sys.time()
[13:36:34.222]     ...future.result
[13:36:34.222] }
[13:36:34.224] plan(): Setting new future strategy stack:
[13:36:34.224] List of future strategies:
[13:36:34.224] 1. sequential:
[13:36:34.224]    - args: function (..., envir = parent.frame())
[13:36:34.224]    - tweaked: FALSE
[13:36:34.224]    - call: NULL
[13:36:34.224] plan(): nbrOfWorkers() = 1
[13:36:34.225] plan(): Setting new future strategy stack:
[13:36:34.225] List of future strategies:
[13:36:34.225] 1. sequential:
[13:36:34.225]    - args: function (..., envir = parent.frame())
[13:36:34.225]    - tweaked: FALSE
[13:36:34.225]    - call: plan(strategy)
[13:36:34.225] plan(): nbrOfWorkers() = 1
[13:36:34.225] SequentialFuture started (and completed)
[13:36:34.226] - Launch lazy future ... done
[13:36:34.226] run() for ‘SequentialFuture’ ... done
[13:36:34.226] getGlobalsAndPackages() ...
[13:36:34.226] Searching for globals...
[13:36:34.227] - globals found: [1] ‘{’
[13:36:34.227] Searching for globals ... DONE
[13:36:34.227] Resolving globals: FALSE
[13:36:34.227] 
[13:36:34.227] 
[13:36:34.227] getGlobalsAndPackages() ... DONE
[13:36:34.228] run() for ‘Future’ ...
[13:36:34.228] - state: ‘created’
[13:36:34.228] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.228] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.228]   - Field: ‘label’
[13:36:34.228]   - Field: ‘local’
[13:36:34.228]   - Field: ‘owner’
[13:36:34.229]   - Field: ‘envir’
[13:36:34.229]   - Field: ‘packages’
[13:36:34.229]   - Field: ‘gc’
[13:36:34.229]   - Field: ‘conditions’
[13:36:34.229]   - Field: ‘expr’
[13:36:34.229]   - Field: ‘uuid’
[13:36:34.229]   - Field: ‘seed’
[13:36:34.229]   - Field: ‘version’
[13:36:34.229]   - Field: ‘result’
[13:36:34.229]   - Field: ‘asynchronous’
[13:36:34.229]   - Field: ‘calls’
[13:36:34.230]   - Field: ‘globals’
[13:36:34.230]   - Field: ‘stdout’
[13:36:34.230]   - Field: ‘earlySignal’
[13:36:34.230]   - Field: ‘lazy’
[13:36:34.230]   - Field: ‘state’
[13:36:34.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.230] - Launch lazy future ...
[13:36:34.230] Packages needed by the future expression (n = 0): <none>
[13:36:34.230] Packages needed by future strategies (n = 0): <none>
[13:36:34.231] {
[13:36:34.231]     {
[13:36:34.231]         {
[13:36:34.231]             ...future.startTime <- base::Sys.time()
[13:36:34.231]             {
[13:36:34.231]                 {
[13:36:34.231]                   {
[13:36:34.231]                     base::local({
[13:36:34.231]                       has_future <- base::requireNamespace("future", 
[13:36:34.231]                         quietly = TRUE)
[13:36:34.231]                       if (has_future) {
[13:36:34.231]                         ns <- base::getNamespace("future")
[13:36:34.231]                         version <- ns[[".package"]][["version"]]
[13:36:34.231]                         if (is.null(version)) 
[13:36:34.231]                           version <- utils::packageVersion("future")
[13:36:34.231]                       }
[13:36:34.231]                       else {
[13:36:34.231]                         version <- NULL
[13:36:34.231]                       }
[13:36:34.231]                       if (!has_future || version < "1.8.0") {
[13:36:34.231]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.231]                           "", base::R.version$version.string), 
[13:36:34.231]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.231]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.231]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.231]                             "release", "version")], collapse = " "), 
[13:36:34.231]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.231]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.231]                           info)
[13:36:34.231]                         info <- base::paste(info, collapse = "; ")
[13:36:34.231]                         if (!has_future) {
[13:36:34.231]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.231]                             info)
[13:36:34.231]                         }
[13:36:34.231]                         else {
[13:36:34.231]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.231]                             info, version)
[13:36:34.231]                         }
[13:36:34.231]                         base::stop(msg)
[13:36:34.231]                       }
[13:36:34.231]                     })
[13:36:34.231]                   }
[13:36:34.231]                   ...future.strategy.old <- future::plan("list")
[13:36:34.231]                   options(future.plan = NULL)
[13:36:34.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.231]                 }
[13:36:34.231]                 ...future.workdir <- getwd()
[13:36:34.231]             }
[13:36:34.231]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.231]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.231]         }
[13:36:34.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.231]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.231]             base::names(...future.oldOptions))
[13:36:34.231]     }
[13:36:34.231]     if (FALSE) {
[13:36:34.231]     }
[13:36:34.231]     else {
[13:36:34.231]         if (TRUE) {
[13:36:34.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.231]                 open = "w")
[13:36:34.231]         }
[13:36:34.231]         else {
[13:36:34.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.231]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.231]         }
[13:36:34.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.231]             base::sink(type = "output", split = FALSE)
[13:36:34.231]             base::close(...future.stdout)
[13:36:34.231]         }, add = TRUE)
[13:36:34.231]     }
[13:36:34.231]     ...future.frame <- base::sys.nframe()
[13:36:34.231]     ...future.conditions <- base::list()
[13:36:34.231]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.231]     if (FALSE) {
[13:36:34.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.231]     }
[13:36:34.231]     ...future.result <- base::tryCatch({
[13:36:34.231]         base::withCallingHandlers({
[13:36:34.231]             ...future.value <- base::withVisible(base::local({
[13:36:34.231]                 4
[13:36:34.231]             }))
[13:36:34.231]             future::FutureResult(value = ...future.value$value, 
[13:36:34.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.231]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.231]                     ...future.globalenv.names))
[13:36:34.231]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.231]         }, condition = base::local({
[13:36:34.231]             c <- base::c
[13:36:34.231]             inherits <- base::inherits
[13:36:34.231]             invokeRestart <- base::invokeRestart
[13:36:34.231]             length <- base::length
[13:36:34.231]             list <- base::list
[13:36:34.231]             seq.int <- base::seq.int
[13:36:34.231]             signalCondition <- base::signalCondition
[13:36:34.231]             sys.calls <- base::sys.calls
[13:36:34.231]             `[[` <- base::`[[`
[13:36:34.231]             `+` <- base::`+`
[13:36:34.231]             `<<-` <- base::`<<-`
[13:36:34.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.231]                   3L)]
[13:36:34.231]             }
[13:36:34.231]             function(cond) {
[13:36:34.231]                 is_error <- inherits(cond, "error")
[13:36:34.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.231]                   NULL)
[13:36:34.231]                 if (is_error) {
[13:36:34.231]                   sessionInformation <- function() {
[13:36:34.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.231]                       search = base::search(), system = base::Sys.info())
[13:36:34.231]                   }
[13:36:34.231]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.231]                     cond$call), session = sessionInformation(), 
[13:36:34.231]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.231]                   signalCondition(cond)
[13:36:34.231]                 }
[13:36:34.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.231]                 "immediateCondition"))) {
[13:36:34.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.231]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.231]                   if (TRUE && !signal) {
[13:36:34.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.231]                     {
[13:36:34.231]                       inherits <- base::inherits
[13:36:34.231]                       invokeRestart <- base::invokeRestart
[13:36:34.231]                       is.null <- base::is.null
[13:36:34.231]                       muffled <- FALSE
[13:36:34.231]                       if (inherits(cond, "message")) {
[13:36:34.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.231]                         if (muffled) 
[13:36:34.231]                           invokeRestart("muffleMessage")
[13:36:34.231]                       }
[13:36:34.231]                       else if (inherits(cond, "warning")) {
[13:36:34.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.231]                         if (muffled) 
[13:36:34.231]                           invokeRestart("muffleWarning")
[13:36:34.231]                       }
[13:36:34.231]                       else if (inherits(cond, "condition")) {
[13:36:34.231]                         if (!is.null(pattern)) {
[13:36:34.231]                           computeRestarts <- base::computeRestarts
[13:36:34.231]                           grepl <- base::grepl
[13:36:34.231]                           restarts <- computeRestarts(cond)
[13:36:34.231]                           for (restart in restarts) {
[13:36:34.231]                             name <- restart$name
[13:36:34.231]                             if (is.null(name)) 
[13:36:34.231]                               next
[13:36:34.231]                             if (!grepl(pattern, name)) 
[13:36:34.231]                               next
[13:36:34.231]                             invokeRestart(restart)
[13:36:34.231]                             muffled <- TRUE
[13:36:34.231]                             break
[13:36:34.231]                           }
[13:36:34.231]                         }
[13:36:34.231]                       }
[13:36:34.231]                       invisible(muffled)
[13:36:34.231]                     }
[13:36:34.231]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.231]                   }
[13:36:34.231]                 }
[13:36:34.231]                 else {
[13:36:34.231]                   if (TRUE) {
[13:36:34.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.231]                     {
[13:36:34.231]                       inherits <- base::inherits
[13:36:34.231]                       invokeRestart <- base::invokeRestart
[13:36:34.231]                       is.null <- base::is.null
[13:36:34.231]                       muffled <- FALSE
[13:36:34.231]                       if (inherits(cond, "message")) {
[13:36:34.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.231]                         if (muffled) 
[13:36:34.231]                           invokeRestart("muffleMessage")
[13:36:34.231]                       }
[13:36:34.231]                       else if (inherits(cond, "warning")) {
[13:36:34.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.231]                         if (muffled) 
[13:36:34.231]                           invokeRestart("muffleWarning")
[13:36:34.231]                       }
[13:36:34.231]                       else if (inherits(cond, "condition")) {
[13:36:34.231]                         if (!is.null(pattern)) {
[13:36:34.231]                           computeRestarts <- base::computeRestarts
[13:36:34.231]                           grepl <- base::grepl
[13:36:34.231]                           restarts <- computeRestarts(cond)
[13:36:34.231]                           for (restart in restarts) {
[13:36:34.231]                             name <- restart$name
[13:36:34.231]                             if (is.null(name)) 
[13:36:34.231]                               next
[13:36:34.231]                             if (!grepl(pattern, name)) 
[13:36:34.231]                               next
[13:36:34.231]                             invokeRestart(restart)
[13:36:34.231]                             muffled <- TRUE
[13:36:34.231]                             break
[13:36:34.231]                           }
[13:36:34.231]                         }
[13:36:34.231]                       }
[13:36:34.231]                       invisible(muffled)
[13:36:34.231]                     }
[13:36:34.231]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.231]                   }
[13:36:34.231]                 }
[13:36:34.231]             }
[13:36:34.231]         }))
[13:36:34.231]     }, error = function(ex) {
[13:36:34.231]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.231]                 ...future.rng), started = ...future.startTime, 
[13:36:34.231]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.231]             version = "1.8"), class = "FutureResult")
[13:36:34.231]     }, finally = {
[13:36:34.231]         if (!identical(...future.workdir, getwd())) 
[13:36:34.231]             setwd(...future.workdir)
[13:36:34.231]         {
[13:36:34.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.231]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.231]             }
[13:36:34.231]             base::options(...future.oldOptions)
[13:36:34.231]             if (.Platform$OS.type == "windows") {
[13:36:34.231]                 old_names <- names(...future.oldEnvVars)
[13:36:34.231]                 envs <- base::Sys.getenv()
[13:36:34.231]                 names <- names(envs)
[13:36:34.231]                 common <- intersect(names, old_names)
[13:36:34.231]                 added <- setdiff(names, old_names)
[13:36:34.231]                 removed <- setdiff(old_names, names)
[13:36:34.231]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.231]                   envs[common]]
[13:36:34.231]                 NAMES <- toupper(changed)
[13:36:34.231]                 args <- list()
[13:36:34.231]                 for (kk in seq_along(NAMES)) {
[13:36:34.231]                   name <- changed[[kk]]
[13:36:34.231]                   NAME <- NAMES[[kk]]
[13:36:34.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.231]                     next
[13:36:34.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.231]                 }
[13:36:34.231]                 NAMES <- toupper(added)
[13:36:34.231]                 for (kk in seq_along(NAMES)) {
[13:36:34.231]                   name <- added[[kk]]
[13:36:34.231]                   NAME <- NAMES[[kk]]
[13:36:34.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.231]                     next
[13:36:34.231]                   args[[name]] <- ""
[13:36:34.231]                 }
[13:36:34.231]                 NAMES <- toupper(removed)
[13:36:34.231]                 for (kk in seq_along(NAMES)) {
[13:36:34.231]                   name <- removed[[kk]]
[13:36:34.231]                   NAME <- NAMES[[kk]]
[13:36:34.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.231]                     next
[13:36:34.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.231]                 }
[13:36:34.231]                 if (length(args) > 0) 
[13:36:34.231]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.231]             }
[13:36:34.231]             else {
[13:36:34.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.231]             }
[13:36:34.231]             {
[13:36:34.231]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.231]                   0L) {
[13:36:34.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.231]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.231]                   base::options(opts)
[13:36:34.231]                 }
[13:36:34.231]                 {
[13:36:34.231]                   {
[13:36:34.231]                     NULL
[13:36:34.231]                     RNGkind("Mersenne-Twister")
[13:36:34.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.231]                       inherits = FALSE)
[13:36:34.231]                   }
[13:36:34.231]                   options(future.plan = NULL)
[13:36:34.231]                   if (is.na(NA_character_)) 
[13:36:34.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.231]                     .init = FALSE)
[13:36:34.231]                 }
[13:36:34.231]             }
[13:36:34.231]         }
[13:36:34.231]     })
[13:36:34.231]     if (TRUE) {
[13:36:34.231]         base::sink(type = "output", split = FALSE)
[13:36:34.231]         if (TRUE) {
[13:36:34.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.231]         }
[13:36:34.231]         else {
[13:36:34.231]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.231]         }
[13:36:34.231]         base::close(...future.stdout)
[13:36:34.231]         ...future.stdout <- NULL
[13:36:34.231]     }
[13:36:34.231]     ...future.result$conditions <- ...future.conditions
[13:36:34.231]     ...future.result$finished <- base::Sys.time()
[13:36:34.231]     ...future.result
[13:36:34.231] }
[13:36:34.232] plan(): Setting new future strategy stack:
[13:36:34.233] List of future strategies:
[13:36:34.233] 1. sequential:
[13:36:34.233]    - args: function (..., envir = parent.frame())
[13:36:34.233]    - tweaked: FALSE
[13:36:34.233]    - call: NULL
[13:36:34.233] plan(): nbrOfWorkers() = 1
[13:36:34.234] plan(): Setting new future strategy stack:
[13:36:34.234] List of future strategies:
[13:36:34.234] 1. sequential:
[13:36:34.234]    - args: function (..., envir = parent.frame())
[13:36:34.234]    - tweaked: FALSE
[13:36:34.234]    - call: plan(strategy)
[13:36:34.234] plan(): nbrOfWorkers() = 1
[13:36:34.234] SequentialFuture started (and completed)
[13:36:34.234] - Launch lazy future ... done
[13:36:34.234] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a72f6b538> 
Classes 'listenv', 'environment' <environment: 0x564a72d3e6c0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:36:34.238] resolved() for ‘SequentialFuture’ ...
[13:36:34.238] - state: ‘finished’
[13:36:34.238] - run: TRUE
[13:36:34.238] - result: ‘FutureResult’
[13:36:34.238] resolved() for ‘SequentialFuture’ ... done
[13:36:34.238] resolved() for ‘SequentialFuture’ ...
[13:36:34.238] - state: ‘finished’
[13:36:34.239] - run: TRUE
[13:36:34.239] - result: ‘FutureResult’
[13:36:34.239] resolved() for ‘SequentialFuture’ ... done
[13:36:34.239] resolved() for ‘SequentialFuture’ ...
[13:36:34.239] - state: ‘finished’
[13:36:34.239] - run: TRUE
[13:36:34.239] - result: ‘FutureResult’
[13:36:34.239] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:34.242] resolve() on list environment ...
[13:36:34.242]  recursive: 0
[13:36:34.243]  length: 6
[13:36:34.243]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:34.243] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.243] - nx: 6
[13:36:34.243] - relay: TRUE
[13:36:34.243] - stdout: TRUE
[13:36:34.243] - signal: TRUE
[13:36:34.243] - resignal: FALSE
[13:36:34.243] - force: TRUE
[13:36:34.243] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.243] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.244]  - until=2
[13:36:34.244]  - relaying element #2
[13:36:34.244] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.244] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.244] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.244]  length: 5 (resolved future 1)
[13:36:34.244] resolved() for ‘SequentialFuture’ ...
[13:36:34.244] - state: ‘finished’
[13:36:34.244] - run: TRUE
[13:36:34.244] - result: ‘FutureResult’
[13:36:34.244] resolved() for ‘SequentialFuture’ ... done
[13:36:34.245] Future #2
[13:36:34.245] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.245] - nx: 6
[13:36:34.245] - relay: TRUE
[13:36:34.245] - stdout: TRUE
[13:36:34.245] - signal: TRUE
[13:36:34.245] - resignal: FALSE
[13:36:34.245] - force: TRUE
[13:36:34.245] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.245] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.245]  - until=2
[13:36:34.245]  - relaying element #2
[13:36:34.246] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.246] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.246] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.246]  length: 4 (resolved future 2)
[13:36:34.246] resolved() for ‘SequentialFuture’ ...
[13:36:34.246] - state: ‘finished’
[13:36:34.246] - run: TRUE
[13:36:34.246] - result: ‘FutureResult’
[13:36:34.246] resolved() for ‘SequentialFuture’ ... done
[13:36:34.247] Future #3
[13:36:34.247] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.247] - nx: 6
[13:36:34.247] - relay: TRUE
[13:36:34.247] - stdout: TRUE
[13:36:34.247] - signal: TRUE
[13:36:34.247] - resignal: FALSE
[13:36:34.247] - force: TRUE
[13:36:34.247] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.247] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.247]  - until=3
[13:36:34.248]  - relaying element #3
[13:36:34.249] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.249] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.249] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.249]  length: 3 (resolved future 3)
[13:36:34.249] resolved() for ‘SequentialFuture’ ...
[13:36:34.249] - state: ‘finished’
[13:36:34.249] - run: TRUE
[13:36:34.249] - result: ‘FutureResult’
[13:36:34.249] resolved() for ‘SequentialFuture’ ... done
[13:36:34.249] Future #4
[13:36:34.250] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.250] - nx: 6
[13:36:34.250] - relay: TRUE
[13:36:34.250] - stdout: TRUE
[13:36:34.250] - signal: TRUE
[13:36:34.250] - resignal: FALSE
[13:36:34.250] - force: TRUE
[13:36:34.250] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.250] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.250]  - until=4
[13:36:34.250]  - relaying element #4
[13:36:34.251] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.251] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.251] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.251]  length: 2 (resolved future 4)
[13:36:34.251] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.251] - nx: 6
[13:36:34.251] - relay: TRUE
[13:36:34.251] - stdout: TRUE
[13:36:34.251] - signal: TRUE
[13:36:34.251] - resignal: FALSE
[13:36:34.251] - force: TRUE
[13:36:34.252] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.252] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.252]  - until=6
[13:36:34.252]  - relaying element #6
[13:36:34.252] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.252] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.252] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.252]  length: 1 (resolved future 5)
[13:36:34.252] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.252] - nx: 6
[13:36:34.252] - relay: TRUE
[13:36:34.253] - stdout: TRUE
[13:36:34.253] - signal: TRUE
[13:36:34.253] - resignal: FALSE
[13:36:34.253] - force: TRUE
[13:36:34.253] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.253] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.253]  - until=6
[13:36:34.253] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.253] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.253] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.253]  length: 0 (resolved future 6)
[13:36:34.253] Relaying remaining futures
[13:36:34.254] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.254] - nx: 6
[13:36:34.254] - relay: TRUE
[13:36:34.254] - stdout: TRUE
[13:36:34.254] - signal: TRUE
[13:36:34.254] - resignal: FALSE
[13:36:34.254] - force: TRUE
[13:36:34.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.254] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:34.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.254] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.254] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.255] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x564a732c11e0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:36:34.256] getGlobalsAndPackages() ...
[13:36:34.256] Searching for globals...
[13:36:34.257] 
[13:36:34.257] Searching for globals ... DONE
[13:36:34.257] - globals: [0] <none>
[13:36:34.257] getGlobalsAndPackages() ... DONE
[13:36:34.257] run() for ‘Future’ ...
[13:36:34.257] - state: ‘created’
[13:36:34.257] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.258] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.258]   - Field: ‘label’
[13:36:34.258]   - Field: ‘local’
[13:36:34.258]   - Field: ‘owner’
[13:36:34.258]   - Field: ‘envir’
[13:36:34.258]   - Field: ‘packages’
[13:36:34.258]   - Field: ‘gc’
[13:36:34.258]   - Field: ‘conditions’
[13:36:34.259]   - Field: ‘expr’
[13:36:34.259]   - Field: ‘uuid’
[13:36:34.259]   - Field: ‘seed’
[13:36:34.259]   - Field: ‘version’
[13:36:34.259]   - Field: ‘result’
[13:36:34.259]   - Field: ‘asynchronous’
[13:36:34.259]   - Field: ‘calls’
[13:36:34.259]   - Field: ‘globals’
[13:36:34.259]   - Field: ‘stdout’
[13:36:34.259]   - Field: ‘earlySignal’
[13:36:34.259]   - Field: ‘lazy’
[13:36:34.260]   - Field: ‘state’
[13:36:34.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.260] - Launch lazy future ...
[13:36:34.260] Packages needed by the future expression (n = 0): <none>
[13:36:34.260] Packages needed by future strategies (n = 0): <none>
[13:36:34.260] {
[13:36:34.260]     {
[13:36:34.260]         {
[13:36:34.260]             ...future.startTime <- base::Sys.time()
[13:36:34.260]             {
[13:36:34.260]                 {
[13:36:34.260]                   {
[13:36:34.260]                     base::local({
[13:36:34.260]                       has_future <- base::requireNamespace("future", 
[13:36:34.260]                         quietly = TRUE)
[13:36:34.260]                       if (has_future) {
[13:36:34.260]                         ns <- base::getNamespace("future")
[13:36:34.260]                         version <- ns[[".package"]][["version"]]
[13:36:34.260]                         if (is.null(version)) 
[13:36:34.260]                           version <- utils::packageVersion("future")
[13:36:34.260]                       }
[13:36:34.260]                       else {
[13:36:34.260]                         version <- NULL
[13:36:34.260]                       }
[13:36:34.260]                       if (!has_future || version < "1.8.0") {
[13:36:34.260]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.260]                           "", base::R.version$version.string), 
[13:36:34.260]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.260]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.260]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.260]                             "release", "version")], collapse = " "), 
[13:36:34.260]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.260]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.260]                           info)
[13:36:34.260]                         info <- base::paste(info, collapse = "; ")
[13:36:34.260]                         if (!has_future) {
[13:36:34.260]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.260]                             info)
[13:36:34.260]                         }
[13:36:34.260]                         else {
[13:36:34.260]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.260]                             info, version)
[13:36:34.260]                         }
[13:36:34.260]                         base::stop(msg)
[13:36:34.260]                       }
[13:36:34.260]                     })
[13:36:34.260]                   }
[13:36:34.260]                   ...future.strategy.old <- future::plan("list")
[13:36:34.260]                   options(future.plan = NULL)
[13:36:34.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.260]                 }
[13:36:34.260]                 ...future.workdir <- getwd()
[13:36:34.260]             }
[13:36:34.260]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.260]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.260]         }
[13:36:34.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.260]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.260]             base::names(...future.oldOptions))
[13:36:34.260]     }
[13:36:34.260]     if (FALSE) {
[13:36:34.260]     }
[13:36:34.260]     else {
[13:36:34.260]         if (TRUE) {
[13:36:34.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.260]                 open = "w")
[13:36:34.260]         }
[13:36:34.260]         else {
[13:36:34.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.260]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.260]         }
[13:36:34.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.260]             base::sink(type = "output", split = FALSE)
[13:36:34.260]             base::close(...future.stdout)
[13:36:34.260]         }, add = TRUE)
[13:36:34.260]     }
[13:36:34.260]     ...future.frame <- base::sys.nframe()
[13:36:34.260]     ...future.conditions <- base::list()
[13:36:34.260]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.260]     if (FALSE) {
[13:36:34.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.260]     }
[13:36:34.260]     ...future.result <- base::tryCatch({
[13:36:34.260]         base::withCallingHandlers({
[13:36:34.260]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.260]             future::FutureResult(value = ...future.value$value, 
[13:36:34.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.260]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.260]                     ...future.globalenv.names))
[13:36:34.260]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.260]         }, condition = base::local({
[13:36:34.260]             c <- base::c
[13:36:34.260]             inherits <- base::inherits
[13:36:34.260]             invokeRestart <- base::invokeRestart
[13:36:34.260]             length <- base::length
[13:36:34.260]             list <- base::list
[13:36:34.260]             seq.int <- base::seq.int
[13:36:34.260]             signalCondition <- base::signalCondition
[13:36:34.260]             sys.calls <- base::sys.calls
[13:36:34.260]             `[[` <- base::`[[`
[13:36:34.260]             `+` <- base::`+`
[13:36:34.260]             `<<-` <- base::`<<-`
[13:36:34.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.260]                   3L)]
[13:36:34.260]             }
[13:36:34.260]             function(cond) {
[13:36:34.260]                 is_error <- inherits(cond, "error")
[13:36:34.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.260]                   NULL)
[13:36:34.260]                 if (is_error) {
[13:36:34.260]                   sessionInformation <- function() {
[13:36:34.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.260]                       search = base::search(), system = base::Sys.info())
[13:36:34.260]                   }
[13:36:34.260]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.260]                     cond$call), session = sessionInformation(), 
[13:36:34.260]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.260]                   signalCondition(cond)
[13:36:34.260]                 }
[13:36:34.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.260]                 "immediateCondition"))) {
[13:36:34.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.260]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.260]                   if (TRUE && !signal) {
[13:36:34.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.260]                     {
[13:36:34.260]                       inherits <- base::inherits
[13:36:34.260]                       invokeRestart <- base::invokeRestart
[13:36:34.260]                       is.null <- base::is.null
[13:36:34.260]                       muffled <- FALSE
[13:36:34.260]                       if (inherits(cond, "message")) {
[13:36:34.260]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.260]                         if (muffled) 
[13:36:34.260]                           invokeRestart("muffleMessage")
[13:36:34.260]                       }
[13:36:34.260]                       else if (inherits(cond, "warning")) {
[13:36:34.260]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.260]                         if (muffled) 
[13:36:34.260]                           invokeRestart("muffleWarning")
[13:36:34.260]                       }
[13:36:34.260]                       else if (inherits(cond, "condition")) {
[13:36:34.260]                         if (!is.null(pattern)) {
[13:36:34.260]                           computeRestarts <- base::computeRestarts
[13:36:34.260]                           grepl <- base::grepl
[13:36:34.260]                           restarts <- computeRestarts(cond)
[13:36:34.260]                           for (restart in restarts) {
[13:36:34.260]                             name <- restart$name
[13:36:34.260]                             if (is.null(name)) 
[13:36:34.260]                               next
[13:36:34.260]                             if (!grepl(pattern, name)) 
[13:36:34.260]                               next
[13:36:34.260]                             invokeRestart(restart)
[13:36:34.260]                             muffled <- TRUE
[13:36:34.260]                             break
[13:36:34.260]                           }
[13:36:34.260]                         }
[13:36:34.260]                       }
[13:36:34.260]                       invisible(muffled)
[13:36:34.260]                     }
[13:36:34.260]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.260]                   }
[13:36:34.260]                 }
[13:36:34.260]                 else {
[13:36:34.260]                   if (TRUE) {
[13:36:34.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.260]                     {
[13:36:34.260]                       inherits <- base::inherits
[13:36:34.260]                       invokeRestart <- base::invokeRestart
[13:36:34.260]                       is.null <- base::is.null
[13:36:34.260]                       muffled <- FALSE
[13:36:34.260]                       if (inherits(cond, "message")) {
[13:36:34.260]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.260]                         if (muffled) 
[13:36:34.260]                           invokeRestart("muffleMessage")
[13:36:34.260]                       }
[13:36:34.260]                       else if (inherits(cond, "warning")) {
[13:36:34.260]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.260]                         if (muffled) 
[13:36:34.260]                           invokeRestart("muffleWarning")
[13:36:34.260]                       }
[13:36:34.260]                       else if (inherits(cond, "condition")) {
[13:36:34.260]                         if (!is.null(pattern)) {
[13:36:34.260]                           computeRestarts <- base::computeRestarts
[13:36:34.260]                           grepl <- base::grepl
[13:36:34.260]                           restarts <- computeRestarts(cond)
[13:36:34.260]                           for (restart in restarts) {
[13:36:34.260]                             name <- restart$name
[13:36:34.260]                             if (is.null(name)) 
[13:36:34.260]                               next
[13:36:34.260]                             if (!grepl(pattern, name)) 
[13:36:34.260]                               next
[13:36:34.260]                             invokeRestart(restart)
[13:36:34.260]                             muffled <- TRUE
[13:36:34.260]                             break
[13:36:34.260]                           }
[13:36:34.260]                         }
[13:36:34.260]                       }
[13:36:34.260]                       invisible(muffled)
[13:36:34.260]                     }
[13:36:34.260]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.260]                   }
[13:36:34.260]                 }
[13:36:34.260]             }
[13:36:34.260]         }))
[13:36:34.260]     }, error = function(ex) {
[13:36:34.260]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.260]                 ...future.rng), started = ...future.startTime, 
[13:36:34.260]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.260]             version = "1.8"), class = "FutureResult")
[13:36:34.260]     }, finally = {
[13:36:34.260]         if (!identical(...future.workdir, getwd())) 
[13:36:34.260]             setwd(...future.workdir)
[13:36:34.260]         {
[13:36:34.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.260]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.260]             }
[13:36:34.260]             base::options(...future.oldOptions)
[13:36:34.260]             if (.Platform$OS.type == "windows") {
[13:36:34.260]                 old_names <- names(...future.oldEnvVars)
[13:36:34.260]                 envs <- base::Sys.getenv()
[13:36:34.260]                 names <- names(envs)
[13:36:34.260]                 common <- intersect(names, old_names)
[13:36:34.260]                 added <- setdiff(names, old_names)
[13:36:34.260]                 removed <- setdiff(old_names, names)
[13:36:34.260]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.260]                   envs[common]]
[13:36:34.260]                 NAMES <- toupper(changed)
[13:36:34.260]                 args <- list()
[13:36:34.260]                 for (kk in seq_along(NAMES)) {
[13:36:34.260]                   name <- changed[[kk]]
[13:36:34.260]                   NAME <- NAMES[[kk]]
[13:36:34.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.260]                     next
[13:36:34.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.260]                 }
[13:36:34.260]                 NAMES <- toupper(added)
[13:36:34.260]                 for (kk in seq_along(NAMES)) {
[13:36:34.260]                   name <- added[[kk]]
[13:36:34.260]                   NAME <- NAMES[[kk]]
[13:36:34.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.260]                     next
[13:36:34.260]                   args[[name]] <- ""
[13:36:34.260]                 }
[13:36:34.260]                 NAMES <- toupper(removed)
[13:36:34.260]                 for (kk in seq_along(NAMES)) {
[13:36:34.260]                   name <- removed[[kk]]
[13:36:34.260]                   NAME <- NAMES[[kk]]
[13:36:34.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.260]                     next
[13:36:34.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.260]                 }
[13:36:34.260]                 if (length(args) > 0) 
[13:36:34.260]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.260]             }
[13:36:34.260]             else {
[13:36:34.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.260]             }
[13:36:34.260]             {
[13:36:34.260]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.260]                   0L) {
[13:36:34.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.260]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.260]                   base::options(opts)
[13:36:34.260]                 }
[13:36:34.260]                 {
[13:36:34.260]                   {
[13:36:34.260]                     NULL
[13:36:34.260]                     RNGkind("Mersenne-Twister")
[13:36:34.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.260]                       inherits = FALSE)
[13:36:34.260]                   }
[13:36:34.260]                   options(future.plan = NULL)
[13:36:34.260]                   if (is.na(NA_character_)) 
[13:36:34.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.260]                     .init = FALSE)
[13:36:34.260]                 }
[13:36:34.260]             }
[13:36:34.260]         }
[13:36:34.260]     })
[13:36:34.260]     if (TRUE) {
[13:36:34.260]         base::sink(type = "output", split = FALSE)
[13:36:34.260]         if (TRUE) {
[13:36:34.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.260]         }
[13:36:34.260]         else {
[13:36:34.260]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.260]         }
[13:36:34.260]         base::close(...future.stdout)
[13:36:34.260]         ...future.stdout <- NULL
[13:36:34.260]     }
[13:36:34.260]     ...future.result$conditions <- ...future.conditions
[13:36:34.260]     ...future.result$finished <- base::Sys.time()
[13:36:34.260]     ...future.result
[13:36:34.260] }
[13:36:34.262] plan(): Setting new future strategy stack:
[13:36:34.262] List of future strategies:
[13:36:34.262] 1. sequential:
[13:36:34.262]    - args: function (..., envir = parent.frame())
[13:36:34.262]    - tweaked: FALSE
[13:36:34.262]    - call: NULL
[13:36:34.262] plan(): nbrOfWorkers() = 1
[13:36:34.263] plan(): Setting new future strategy stack:
[13:36:34.263] List of future strategies:
[13:36:34.263] 1. sequential:
[13:36:34.263]    - args: function (..., envir = parent.frame())
[13:36:34.263]    - tweaked: FALSE
[13:36:34.263]    - call: plan(strategy)
[13:36:34.264] plan(): nbrOfWorkers() = 1
[13:36:34.264] SequentialFuture started (and completed)
[13:36:34.264] - Launch lazy future ... done
[13:36:34.264] run() for ‘SequentialFuture’ ... done
[13:36:34.264] getGlobalsAndPackages() ...
[13:36:34.264] Searching for globals...
[13:36:34.264] 
[13:36:34.265] Searching for globals ... DONE
[13:36:34.265] - globals: [0] <none>
[13:36:34.265] getGlobalsAndPackages() ... DONE
[13:36:34.265] run() for ‘Future’ ...
[13:36:34.265] - state: ‘created’
[13:36:34.265] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.265] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.266]   - Field: ‘label’
[13:36:34.266]   - Field: ‘local’
[13:36:34.266]   - Field: ‘owner’
[13:36:34.266]   - Field: ‘envir’
[13:36:34.266]   - Field: ‘packages’
[13:36:34.266]   - Field: ‘gc’
[13:36:34.266]   - Field: ‘conditions’
[13:36:34.266]   - Field: ‘expr’
[13:36:34.266]   - Field: ‘uuid’
[13:36:34.266]   - Field: ‘seed’
[13:36:34.267]   - Field: ‘version’
[13:36:34.267]   - Field: ‘result’
[13:36:34.267]   - Field: ‘asynchronous’
[13:36:34.267]   - Field: ‘calls’
[13:36:34.267]   - Field: ‘globals’
[13:36:34.267]   - Field: ‘stdout’
[13:36:34.267]   - Field: ‘earlySignal’
[13:36:34.267]   - Field: ‘lazy’
[13:36:34.267]   - Field: ‘state’
[13:36:34.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.267] - Launch lazy future ...
[13:36:34.268] Packages needed by the future expression (n = 0): <none>
[13:36:34.268] Packages needed by future strategies (n = 0): <none>
[13:36:34.268] {
[13:36:34.268]     {
[13:36:34.268]         {
[13:36:34.268]             ...future.startTime <- base::Sys.time()
[13:36:34.268]             {
[13:36:34.268]                 {
[13:36:34.268]                   {
[13:36:34.268]                     base::local({
[13:36:34.268]                       has_future <- base::requireNamespace("future", 
[13:36:34.268]                         quietly = TRUE)
[13:36:34.268]                       if (has_future) {
[13:36:34.268]                         ns <- base::getNamespace("future")
[13:36:34.268]                         version <- ns[[".package"]][["version"]]
[13:36:34.268]                         if (is.null(version)) 
[13:36:34.268]                           version <- utils::packageVersion("future")
[13:36:34.268]                       }
[13:36:34.268]                       else {
[13:36:34.268]                         version <- NULL
[13:36:34.268]                       }
[13:36:34.268]                       if (!has_future || version < "1.8.0") {
[13:36:34.268]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.268]                           "", base::R.version$version.string), 
[13:36:34.268]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.268]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.268]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.268]                             "release", "version")], collapse = " "), 
[13:36:34.268]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.268]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.268]                           info)
[13:36:34.268]                         info <- base::paste(info, collapse = "; ")
[13:36:34.268]                         if (!has_future) {
[13:36:34.268]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.268]                             info)
[13:36:34.268]                         }
[13:36:34.268]                         else {
[13:36:34.268]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.268]                             info, version)
[13:36:34.268]                         }
[13:36:34.268]                         base::stop(msg)
[13:36:34.268]                       }
[13:36:34.268]                     })
[13:36:34.268]                   }
[13:36:34.268]                   ...future.strategy.old <- future::plan("list")
[13:36:34.268]                   options(future.plan = NULL)
[13:36:34.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.268]                 }
[13:36:34.268]                 ...future.workdir <- getwd()
[13:36:34.268]             }
[13:36:34.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.268]         }
[13:36:34.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.268]             base::names(...future.oldOptions))
[13:36:34.268]     }
[13:36:34.268]     if (FALSE) {
[13:36:34.268]     }
[13:36:34.268]     else {
[13:36:34.268]         if (TRUE) {
[13:36:34.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.268]                 open = "w")
[13:36:34.268]         }
[13:36:34.268]         else {
[13:36:34.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.268]         }
[13:36:34.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.268]             base::sink(type = "output", split = FALSE)
[13:36:34.268]             base::close(...future.stdout)
[13:36:34.268]         }, add = TRUE)
[13:36:34.268]     }
[13:36:34.268]     ...future.frame <- base::sys.nframe()
[13:36:34.268]     ...future.conditions <- base::list()
[13:36:34.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.268]     if (FALSE) {
[13:36:34.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.268]     }
[13:36:34.268]     ...future.result <- base::tryCatch({
[13:36:34.268]         base::withCallingHandlers({
[13:36:34.268]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.268]             future::FutureResult(value = ...future.value$value, 
[13:36:34.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.268]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.268]                     ...future.globalenv.names))
[13:36:34.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.268]         }, condition = base::local({
[13:36:34.268]             c <- base::c
[13:36:34.268]             inherits <- base::inherits
[13:36:34.268]             invokeRestart <- base::invokeRestart
[13:36:34.268]             length <- base::length
[13:36:34.268]             list <- base::list
[13:36:34.268]             seq.int <- base::seq.int
[13:36:34.268]             signalCondition <- base::signalCondition
[13:36:34.268]             sys.calls <- base::sys.calls
[13:36:34.268]             `[[` <- base::`[[`
[13:36:34.268]             `+` <- base::`+`
[13:36:34.268]             `<<-` <- base::`<<-`
[13:36:34.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.268]                   3L)]
[13:36:34.268]             }
[13:36:34.268]             function(cond) {
[13:36:34.268]                 is_error <- inherits(cond, "error")
[13:36:34.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.268]                   NULL)
[13:36:34.268]                 if (is_error) {
[13:36:34.268]                   sessionInformation <- function() {
[13:36:34.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.268]                       search = base::search(), system = base::Sys.info())
[13:36:34.268]                   }
[13:36:34.268]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.268]                     cond$call), session = sessionInformation(), 
[13:36:34.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.268]                   signalCondition(cond)
[13:36:34.268]                 }
[13:36:34.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.268]                 "immediateCondition"))) {
[13:36:34.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.268]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.268]                   if (TRUE && !signal) {
[13:36:34.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.268]                     {
[13:36:34.268]                       inherits <- base::inherits
[13:36:34.268]                       invokeRestart <- base::invokeRestart
[13:36:34.268]                       is.null <- base::is.null
[13:36:34.268]                       muffled <- FALSE
[13:36:34.268]                       if (inherits(cond, "message")) {
[13:36:34.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.268]                         if (muffled) 
[13:36:34.268]                           invokeRestart("muffleMessage")
[13:36:34.268]                       }
[13:36:34.268]                       else if (inherits(cond, "warning")) {
[13:36:34.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.268]                         if (muffled) 
[13:36:34.268]                           invokeRestart("muffleWarning")
[13:36:34.268]                       }
[13:36:34.268]                       else if (inherits(cond, "condition")) {
[13:36:34.268]                         if (!is.null(pattern)) {
[13:36:34.268]                           computeRestarts <- base::computeRestarts
[13:36:34.268]                           grepl <- base::grepl
[13:36:34.268]                           restarts <- computeRestarts(cond)
[13:36:34.268]                           for (restart in restarts) {
[13:36:34.268]                             name <- restart$name
[13:36:34.268]                             if (is.null(name)) 
[13:36:34.268]                               next
[13:36:34.268]                             if (!grepl(pattern, name)) 
[13:36:34.268]                               next
[13:36:34.268]                             invokeRestart(restart)
[13:36:34.268]                             muffled <- TRUE
[13:36:34.268]                             break
[13:36:34.268]                           }
[13:36:34.268]                         }
[13:36:34.268]                       }
[13:36:34.268]                       invisible(muffled)
[13:36:34.268]                     }
[13:36:34.268]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.268]                   }
[13:36:34.268]                 }
[13:36:34.268]                 else {
[13:36:34.268]                   if (TRUE) {
[13:36:34.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.268]                     {
[13:36:34.268]                       inherits <- base::inherits
[13:36:34.268]                       invokeRestart <- base::invokeRestart
[13:36:34.268]                       is.null <- base::is.null
[13:36:34.268]                       muffled <- FALSE
[13:36:34.268]                       if (inherits(cond, "message")) {
[13:36:34.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.268]                         if (muffled) 
[13:36:34.268]                           invokeRestart("muffleMessage")
[13:36:34.268]                       }
[13:36:34.268]                       else if (inherits(cond, "warning")) {
[13:36:34.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.268]                         if (muffled) 
[13:36:34.268]                           invokeRestart("muffleWarning")
[13:36:34.268]                       }
[13:36:34.268]                       else if (inherits(cond, "condition")) {
[13:36:34.268]                         if (!is.null(pattern)) {
[13:36:34.268]                           computeRestarts <- base::computeRestarts
[13:36:34.268]                           grepl <- base::grepl
[13:36:34.268]                           restarts <- computeRestarts(cond)
[13:36:34.268]                           for (restart in restarts) {
[13:36:34.268]                             name <- restart$name
[13:36:34.268]                             if (is.null(name)) 
[13:36:34.268]                               next
[13:36:34.268]                             if (!grepl(pattern, name)) 
[13:36:34.268]                               next
[13:36:34.268]                             invokeRestart(restart)
[13:36:34.268]                             muffled <- TRUE
[13:36:34.268]                             break
[13:36:34.268]                           }
[13:36:34.268]                         }
[13:36:34.268]                       }
[13:36:34.268]                       invisible(muffled)
[13:36:34.268]                     }
[13:36:34.268]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.268]                   }
[13:36:34.268]                 }
[13:36:34.268]             }
[13:36:34.268]         }))
[13:36:34.268]     }, error = function(ex) {
[13:36:34.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.268]                 ...future.rng), started = ...future.startTime, 
[13:36:34.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.268]             version = "1.8"), class = "FutureResult")
[13:36:34.268]     }, finally = {
[13:36:34.268]         if (!identical(...future.workdir, getwd())) 
[13:36:34.268]             setwd(...future.workdir)
[13:36:34.268]         {
[13:36:34.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.268]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.268]             }
[13:36:34.268]             base::options(...future.oldOptions)
[13:36:34.268]             if (.Platform$OS.type == "windows") {
[13:36:34.268]                 old_names <- names(...future.oldEnvVars)
[13:36:34.268]                 envs <- base::Sys.getenv()
[13:36:34.268]                 names <- names(envs)
[13:36:34.268]                 common <- intersect(names, old_names)
[13:36:34.268]                 added <- setdiff(names, old_names)
[13:36:34.268]                 removed <- setdiff(old_names, names)
[13:36:34.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.268]                   envs[common]]
[13:36:34.268]                 NAMES <- toupper(changed)
[13:36:34.268]                 args <- list()
[13:36:34.268]                 for (kk in seq_along(NAMES)) {
[13:36:34.268]                   name <- changed[[kk]]
[13:36:34.268]                   NAME <- NAMES[[kk]]
[13:36:34.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.268]                     next
[13:36:34.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.268]                 }
[13:36:34.268]                 NAMES <- toupper(added)
[13:36:34.268]                 for (kk in seq_along(NAMES)) {
[13:36:34.268]                   name <- added[[kk]]
[13:36:34.268]                   NAME <- NAMES[[kk]]
[13:36:34.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.268]                     next
[13:36:34.268]                   args[[name]] <- ""
[13:36:34.268]                 }
[13:36:34.268]                 NAMES <- toupper(removed)
[13:36:34.268]                 for (kk in seq_along(NAMES)) {
[13:36:34.268]                   name <- removed[[kk]]
[13:36:34.268]                   NAME <- NAMES[[kk]]
[13:36:34.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.268]                     next
[13:36:34.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.268]                 }
[13:36:34.268]                 if (length(args) > 0) 
[13:36:34.268]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.268]             }
[13:36:34.268]             else {
[13:36:34.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.268]             }
[13:36:34.268]             {
[13:36:34.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.268]                   0L) {
[13:36:34.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.268]                   base::options(opts)
[13:36:34.268]                 }
[13:36:34.268]                 {
[13:36:34.268]                   {
[13:36:34.268]                     NULL
[13:36:34.268]                     RNGkind("Mersenne-Twister")
[13:36:34.268]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.268]                       inherits = FALSE)
[13:36:34.268]                   }
[13:36:34.268]                   options(future.plan = NULL)
[13:36:34.268]                   if (is.na(NA_character_)) 
[13:36:34.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.268]                     .init = FALSE)
[13:36:34.268]                 }
[13:36:34.268]             }
[13:36:34.268]         }
[13:36:34.268]     })
[13:36:34.268]     if (TRUE) {
[13:36:34.268]         base::sink(type = "output", split = FALSE)
[13:36:34.268]         if (TRUE) {
[13:36:34.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.268]         }
[13:36:34.268]         else {
[13:36:34.268]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.268]         }
[13:36:34.268]         base::close(...future.stdout)
[13:36:34.268]         ...future.stdout <- NULL
[13:36:34.268]     }
[13:36:34.268]     ...future.result$conditions <- ...future.conditions
[13:36:34.268]     ...future.result$finished <- base::Sys.time()
[13:36:34.268]     ...future.result
[13:36:34.268] }
[13:36:34.270] plan(): Setting new future strategy stack:
[13:36:34.270] List of future strategies:
[13:36:34.270] 1. sequential:
[13:36:34.270]    - args: function (..., envir = parent.frame())
[13:36:34.270]    - tweaked: FALSE
[13:36:34.270]    - call: NULL
[13:36:34.270] plan(): nbrOfWorkers() = 1
[13:36:34.271] plan(): Setting new future strategy stack:
[13:36:34.271] List of future strategies:
[13:36:34.271] 1. sequential:
[13:36:34.271]    - args: function (..., envir = parent.frame())
[13:36:34.271]    - tweaked: FALSE
[13:36:34.271]    - call: plan(strategy)
[13:36:34.271] plan(): nbrOfWorkers() = 1
[13:36:34.271] SequentialFuture started (and completed)
[13:36:34.271] - Launch lazy future ... done
[13:36:34.272] run() for ‘SequentialFuture’ ... done
[13:36:34.272] getGlobalsAndPackages() ...
[13:36:34.272] Searching for globals...
[13:36:34.273] - globals found: [1] ‘{’
[13:36:34.273] Searching for globals ... DONE
[13:36:34.273] Resolving globals: FALSE
[13:36:34.273] 
[13:36:34.273] 
[13:36:34.273] getGlobalsAndPackages() ... DONE
[13:36:34.273] run() for ‘Future’ ...
[13:36:34.273] - state: ‘created’
[13:36:34.274] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.274]   - Field: ‘label’
[13:36:34.274]   - Field: ‘local’
[13:36:34.274]   - Field: ‘owner’
[13:36:34.274]   - Field: ‘envir’
[13:36:34.274]   - Field: ‘packages’
[13:36:34.275]   - Field: ‘gc’
[13:36:34.275]   - Field: ‘conditions’
[13:36:34.275]   - Field: ‘expr’
[13:36:34.275]   - Field: ‘uuid’
[13:36:34.276]   - Field: ‘seed’
[13:36:34.276]   - Field: ‘version’
[13:36:34.276]   - Field: ‘result’
[13:36:34.276]   - Field: ‘asynchronous’
[13:36:34.276]   - Field: ‘calls’
[13:36:34.276]   - Field: ‘globals’
[13:36:34.276]   - Field: ‘stdout’
[13:36:34.276]   - Field: ‘earlySignal’
[13:36:34.276]   - Field: ‘lazy’
[13:36:34.276]   - Field: ‘state’
[13:36:34.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.277] - Launch lazy future ...
[13:36:34.277] Packages needed by the future expression (n = 0): <none>
[13:36:34.277] Packages needed by future strategies (n = 0): <none>
[13:36:34.277] {
[13:36:34.277]     {
[13:36:34.277]         {
[13:36:34.277]             ...future.startTime <- base::Sys.time()
[13:36:34.277]             {
[13:36:34.277]                 {
[13:36:34.277]                   {
[13:36:34.277]                     base::local({
[13:36:34.277]                       has_future <- base::requireNamespace("future", 
[13:36:34.277]                         quietly = TRUE)
[13:36:34.277]                       if (has_future) {
[13:36:34.277]                         ns <- base::getNamespace("future")
[13:36:34.277]                         version <- ns[[".package"]][["version"]]
[13:36:34.277]                         if (is.null(version)) 
[13:36:34.277]                           version <- utils::packageVersion("future")
[13:36:34.277]                       }
[13:36:34.277]                       else {
[13:36:34.277]                         version <- NULL
[13:36:34.277]                       }
[13:36:34.277]                       if (!has_future || version < "1.8.0") {
[13:36:34.277]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.277]                           "", base::R.version$version.string), 
[13:36:34.277]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.277]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.277]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.277]                             "release", "version")], collapse = " "), 
[13:36:34.277]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.277]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.277]                           info)
[13:36:34.277]                         info <- base::paste(info, collapse = "; ")
[13:36:34.277]                         if (!has_future) {
[13:36:34.277]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.277]                             info)
[13:36:34.277]                         }
[13:36:34.277]                         else {
[13:36:34.277]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.277]                             info, version)
[13:36:34.277]                         }
[13:36:34.277]                         base::stop(msg)
[13:36:34.277]                       }
[13:36:34.277]                     })
[13:36:34.277]                   }
[13:36:34.277]                   ...future.strategy.old <- future::plan("list")
[13:36:34.277]                   options(future.plan = NULL)
[13:36:34.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.277]                 }
[13:36:34.277]                 ...future.workdir <- getwd()
[13:36:34.277]             }
[13:36:34.277]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.277]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.277]         }
[13:36:34.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.277]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.277]             base::names(...future.oldOptions))
[13:36:34.277]     }
[13:36:34.277]     if (FALSE) {
[13:36:34.277]     }
[13:36:34.277]     else {
[13:36:34.277]         if (TRUE) {
[13:36:34.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.277]                 open = "w")
[13:36:34.277]         }
[13:36:34.277]         else {
[13:36:34.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.277]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.277]         }
[13:36:34.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.277]             base::sink(type = "output", split = FALSE)
[13:36:34.277]             base::close(...future.stdout)
[13:36:34.277]         }, add = TRUE)
[13:36:34.277]     }
[13:36:34.277]     ...future.frame <- base::sys.nframe()
[13:36:34.277]     ...future.conditions <- base::list()
[13:36:34.277]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.277]     if (FALSE) {
[13:36:34.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.277]     }
[13:36:34.277]     ...future.result <- base::tryCatch({
[13:36:34.277]         base::withCallingHandlers({
[13:36:34.277]             ...future.value <- base::withVisible(base::local({
[13:36:34.277]                 4
[13:36:34.277]             }))
[13:36:34.277]             future::FutureResult(value = ...future.value$value, 
[13:36:34.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.277]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.277]                     ...future.globalenv.names))
[13:36:34.277]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.277]         }, condition = base::local({
[13:36:34.277]             c <- base::c
[13:36:34.277]             inherits <- base::inherits
[13:36:34.277]             invokeRestart <- base::invokeRestart
[13:36:34.277]             length <- base::length
[13:36:34.277]             list <- base::list
[13:36:34.277]             seq.int <- base::seq.int
[13:36:34.277]             signalCondition <- base::signalCondition
[13:36:34.277]             sys.calls <- base::sys.calls
[13:36:34.277]             `[[` <- base::`[[`
[13:36:34.277]             `+` <- base::`+`
[13:36:34.277]             `<<-` <- base::`<<-`
[13:36:34.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.277]                   3L)]
[13:36:34.277]             }
[13:36:34.277]             function(cond) {
[13:36:34.277]                 is_error <- inherits(cond, "error")
[13:36:34.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.277]                   NULL)
[13:36:34.277]                 if (is_error) {
[13:36:34.277]                   sessionInformation <- function() {
[13:36:34.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.277]                       search = base::search(), system = base::Sys.info())
[13:36:34.277]                   }
[13:36:34.277]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.277]                     cond$call), session = sessionInformation(), 
[13:36:34.277]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.277]                   signalCondition(cond)
[13:36:34.277]                 }
[13:36:34.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.277]                 "immediateCondition"))) {
[13:36:34.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.277]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.277]                   if (TRUE && !signal) {
[13:36:34.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.277]                     {
[13:36:34.277]                       inherits <- base::inherits
[13:36:34.277]                       invokeRestart <- base::invokeRestart
[13:36:34.277]                       is.null <- base::is.null
[13:36:34.277]                       muffled <- FALSE
[13:36:34.277]                       if (inherits(cond, "message")) {
[13:36:34.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.277]                         if (muffled) 
[13:36:34.277]                           invokeRestart("muffleMessage")
[13:36:34.277]                       }
[13:36:34.277]                       else if (inherits(cond, "warning")) {
[13:36:34.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.277]                         if (muffled) 
[13:36:34.277]                           invokeRestart("muffleWarning")
[13:36:34.277]                       }
[13:36:34.277]                       else if (inherits(cond, "condition")) {
[13:36:34.277]                         if (!is.null(pattern)) {
[13:36:34.277]                           computeRestarts <- base::computeRestarts
[13:36:34.277]                           grepl <- base::grepl
[13:36:34.277]                           restarts <- computeRestarts(cond)
[13:36:34.277]                           for (restart in restarts) {
[13:36:34.277]                             name <- restart$name
[13:36:34.277]                             if (is.null(name)) 
[13:36:34.277]                               next
[13:36:34.277]                             if (!grepl(pattern, name)) 
[13:36:34.277]                               next
[13:36:34.277]                             invokeRestart(restart)
[13:36:34.277]                             muffled <- TRUE
[13:36:34.277]                             break
[13:36:34.277]                           }
[13:36:34.277]                         }
[13:36:34.277]                       }
[13:36:34.277]                       invisible(muffled)
[13:36:34.277]                     }
[13:36:34.277]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.277]                   }
[13:36:34.277]                 }
[13:36:34.277]                 else {
[13:36:34.277]                   if (TRUE) {
[13:36:34.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.277]                     {
[13:36:34.277]                       inherits <- base::inherits
[13:36:34.277]                       invokeRestart <- base::invokeRestart
[13:36:34.277]                       is.null <- base::is.null
[13:36:34.277]                       muffled <- FALSE
[13:36:34.277]                       if (inherits(cond, "message")) {
[13:36:34.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.277]                         if (muffled) 
[13:36:34.277]                           invokeRestart("muffleMessage")
[13:36:34.277]                       }
[13:36:34.277]                       else if (inherits(cond, "warning")) {
[13:36:34.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.277]                         if (muffled) 
[13:36:34.277]                           invokeRestart("muffleWarning")
[13:36:34.277]                       }
[13:36:34.277]                       else if (inherits(cond, "condition")) {
[13:36:34.277]                         if (!is.null(pattern)) {
[13:36:34.277]                           computeRestarts <- base::computeRestarts
[13:36:34.277]                           grepl <- base::grepl
[13:36:34.277]                           restarts <- computeRestarts(cond)
[13:36:34.277]                           for (restart in restarts) {
[13:36:34.277]                             name <- restart$name
[13:36:34.277]                             if (is.null(name)) 
[13:36:34.277]                               next
[13:36:34.277]                             if (!grepl(pattern, name)) 
[13:36:34.277]                               next
[13:36:34.277]                             invokeRestart(restart)
[13:36:34.277]                             muffled <- TRUE
[13:36:34.277]                             break
[13:36:34.277]                           }
[13:36:34.277]                         }
[13:36:34.277]                       }
[13:36:34.277]                       invisible(muffled)
[13:36:34.277]                     }
[13:36:34.277]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.277]                   }
[13:36:34.277]                 }
[13:36:34.277]             }
[13:36:34.277]         }))
[13:36:34.277]     }, error = function(ex) {
[13:36:34.277]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.277]                 ...future.rng), started = ...future.startTime, 
[13:36:34.277]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.277]             version = "1.8"), class = "FutureResult")
[13:36:34.277]     }, finally = {
[13:36:34.277]         if (!identical(...future.workdir, getwd())) 
[13:36:34.277]             setwd(...future.workdir)
[13:36:34.277]         {
[13:36:34.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.277]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.277]             }
[13:36:34.277]             base::options(...future.oldOptions)
[13:36:34.277]             if (.Platform$OS.type == "windows") {
[13:36:34.277]                 old_names <- names(...future.oldEnvVars)
[13:36:34.277]                 envs <- base::Sys.getenv()
[13:36:34.277]                 names <- names(envs)
[13:36:34.277]                 common <- intersect(names, old_names)
[13:36:34.277]                 added <- setdiff(names, old_names)
[13:36:34.277]                 removed <- setdiff(old_names, names)
[13:36:34.277]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.277]                   envs[common]]
[13:36:34.277]                 NAMES <- toupper(changed)
[13:36:34.277]                 args <- list()
[13:36:34.277]                 for (kk in seq_along(NAMES)) {
[13:36:34.277]                   name <- changed[[kk]]
[13:36:34.277]                   NAME <- NAMES[[kk]]
[13:36:34.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.277]                     next
[13:36:34.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.277]                 }
[13:36:34.277]                 NAMES <- toupper(added)
[13:36:34.277]                 for (kk in seq_along(NAMES)) {
[13:36:34.277]                   name <- added[[kk]]
[13:36:34.277]                   NAME <- NAMES[[kk]]
[13:36:34.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.277]                     next
[13:36:34.277]                   args[[name]] <- ""
[13:36:34.277]                 }
[13:36:34.277]                 NAMES <- toupper(removed)
[13:36:34.277]                 for (kk in seq_along(NAMES)) {
[13:36:34.277]                   name <- removed[[kk]]
[13:36:34.277]                   NAME <- NAMES[[kk]]
[13:36:34.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.277]                     next
[13:36:34.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.277]                 }
[13:36:34.277]                 if (length(args) > 0) 
[13:36:34.277]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.277]             }
[13:36:34.277]             else {
[13:36:34.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.277]             }
[13:36:34.277]             {
[13:36:34.277]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.277]                   0L) {
[13:36:34.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.277]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.277]                   base::options(opts)
[13:36:34.277]                 }
[13:36:34.277]                 {
[13:36:34.277]                   {
[13:36:34.277]                     NULL
[13:36:34.277]                     RNGkind("Mersenne-Twister")
[13:36:34.277]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.277]                       inherits = FALSE)
[13:36:34.277]                   }
[13:36:34.277]                   options(future.plan = NULL)
[13:36:34.277]                   if (is.na(NA_character_)) 
[13:36:34.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.277]                     .init = FALSE)
[13:36:34.277]                 }
[13:36:34.277]             }
[13:36:34.277]         }
[13:36:34.277]     })
[13:36:34.277]     if (TRUE) {
[13:36:34.277]         base::sink(type = "output", split = FALSE)
[13:36:34.277]         if (TRUE) {
[13:36:34.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.277]         }
[13:36:34.277]         else {
[13:36:34.277]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.277]         }
[13:36:34.277]         base::close(...future.stdout)
[13:36:34.277]         ...future.stdout <- NULL
[13:36:34.277]     }
[13:36:34.277]     ...future.result$conditions <- ...future.conditions
[13:36:34.277]     ...future.result$finished <- base::Sys.time()
[13:36:34.277]     ...future.result
[13:36:34.277] }
[13:36:34.279] plan(): Setting new future strategy stack:
[13:36:34.279] List of future strategies:
[13:36:34.279] 1. sequential:
[13:36:34.279]    - args: function (..., envir = parent.frame())
[13:36:34.279]    - tweaked: FALSE
[13:36:34.279]    - call: NULL
[13:36:34.279] plan(): nbrOfWorkers() = 1
[13:36:34.280] plan(): Setting new future strategy stack:
[13:36:34.280] List of future strategies:
[13:36:34.280] 1. sequential:
[13:36:34.280]    - args: function (..., envir = parent.frame())
[13:36:34.280]    - tweaked: FALSE
[13:36:34.280]    - call: plan(strategy)
[13:36:34.280] plan(): nbrOfWorkers() = 1
[13:36:34.281] SequentialFuture started (and completed)
[13:36:34.281] - Launch lazy future ... done
[13:36:34.281] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a7134c5c0> 
Classes 'listenv', 'environment' <environment: 0x564a7178ff58> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:36:34.284] resolved() for ‘SequentialFuture’ ...
[13:36:34.284] - state: ‘finished’
[13:36:34.284] - run: TRUE
[13:36:34.284] - result: ‘FutureResult’
[13:36:34.285] resolved() for ‘SequentialFuture’ ... done
[13:36:34.285] resolved() for ‘SequentialFuture’ ...
[13:36:34.285] - state: ‘finished’
[13:36:34.285] - run: TRUE
[13:36:34.285] - result: ‘FutureResult’
[13:36:34.285] resolved() for ‘SequentialFuture’ ... done
[13:36:34.285] resolved() for ‘SequentialFuture’ ...
[13:36:34.285] - state: ‘finished’
[13:36:34.285] - run: TRUE
[13:36:34.285] - result: ‘FutureResult’
[13:36:34.285] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:34.288] resolve() on list environment ...
[13:36:34.288]  recursive: 0
[13:36:34.288]  length: 6
[13:36:34.289]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:34.289] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.289] - nx: 6
[13:36:34.289] - relay: TRUE
[13:36:34.289] - stdout: TRUE
[13:36:34.289] - signal: TRUE
[13:36:34.289] - resignal: FALSE
[13:36:34.289] - force: TRUE
[13:36:34.289] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.289] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.289]  - until=2
[13:36:34.290]  - relaying element #2
[13:36:34.290] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.290] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.290] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.290]  length: 5 (resolved future 1)
[13:36:34.290] resolved() for ‘SequentialFuture’ ...
[13:36:34.290] - state: ‘finished’
[13:36:34.290] - run: TRUE
[13:36:34.290] - result: ‘FutureResult’
[13:36:34.290] resolved() for ‘SequentialFuture’ ... done
[13:36:34.290] Future #2
[13:36:34.291] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.291] - nx: 6
[13:36:34.291] - relay: TRUE
[13:36:34.291] - stdout: TRUE
[13:36:34.291] - signal: TRUE
[13:36:34.291] - resignal: FALSE
[13:36:34.291] - force: TRUE
[13:36:34.291] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.291] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.291]  - until=2
[13:36:34.291]  - relaying element #2
[13:36:34.292] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.292] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.292] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.292]  length: 4 (resolved future 2)
[13:36:34.292] resolved() for ‘SequentialFuture’ ...
[13:36:34.292] - state: ‘finished’
[13:36:34.292] - run: TRUE
[13:36:34.292] - result: ‘FutureResult’
[13:36:34.292] resolved() for ‘SequentialFuture’ ... done
[13:36:34.292] Future #3
[13:36:34.292] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.293] - nx: 6
[13:36:34.293] - relay: TRUE
[13:36:34.293] - stdout: TRUE
[13:36:34.293] - signal: TRUE
[13:36:34.293] - resignal: FALSE
[13:36:34.293] - force: TRUE
[13:36:34.293] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.293] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.293]  - until=3
[13:36:34.293]  - relaying element #3
[13:36:34.293] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.294] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.294] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.294]  length: 3 (resolved future 3)
[13:36:34.294] resolved() for ‘SequentialFuture’ ...
[13:36:34.294] - state: ‘finished’
[13:36:34.294] - run: TRUE
[13:36:34.294] - result: ‘FutureResult’
[13:36:34.294] resolved() for ‘SequentialFuture’ ... done
[13:36:34.294] Future #4
[13:36:34.294] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.295] - nx: 6
[13:36:34.295] - relay: TRUE
[13:36:34.295] - stdout: TRUE
[13:36:34.295] - signal: TRUE
[13:36:34.295] - resignal: FALSE
[13:36:34.295] - force: TRUE
[13:36:34.295] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.295] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.295]  - until=4
[13:36:34.295]  - relaying element #4
[13:36:34.295] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.295] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.296] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.296]  length: 2 (resolved future 4)
[13:36:34.296] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.296] - nx: 6
[13:36:34.296] - relay: TRUE
[13:36:34.296] - stdout: TRUE
[13:36:34.296] - signal: TRUE
[13:36:34.296] - resignal: FALSE
[13:36:34.296] - force: TRUE
[13:36:34.296] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.296] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.296]  - until=6
[13:36:34.297]  - relaying element #6
[13:36:34.297] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.297] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.297] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.297]  length: 1 (resolved future 5)
[13:36:34.297] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.297] - nx: 6
[13:36:34.297] - relay: TRUE
[13:36:34.297] - stdout: TRUE
[13:36:34.297] - signal: TRUE
[13:36:34.297] - resignal: FALSE
[13:36:34.297] - force: TRUE
[13:36:34.298] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.298] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.298]  - until=6
[13:36:34.298] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.298] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.298] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.298]  length: 0 (resolved future 6)
[13:36:34.298] Relaying remaining futures
[13:36:34.298] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.298] - nx: 6
[13:36:34.298] - relay: TRUE
[13:36:34.298] - stdout: TRUE
[13:36:34.299] - signal: TRUE
[13:36:34.299] - resignal: FALSE
[13:36:34.299] - force: TRUE
[13:36:34.299] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.300] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:34.300] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.300] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.300] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.300] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x564a72dcae88> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:36:34.302] getGlobalsAndPackages() ...
[13:36:34.302] Searching for globals...
[13:36:34.302] 
[13:36:34.302] Searching for globals ... DONE
[13:36:34.302] - globals: [0] <none>
[13:36:34.302] getGlobalsAndPackages() ... DONE
[13:36:34.303] run() for ‘Future’ ...
[13:36:34.303] - state: ‘created’
[13:36:34.303] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.303]   - Field: ‘label’
[13:36:34.303]   - Field: ‘local’
[13:36:34.304]   - Field: ‘owner’
[13:36:34.304]   - Field: ‘envir’
[13:36:34.304]   - Field: ‘packages’
[13:36:34.304]   - Field: ‘gc’
[13:36:34.304]   - Field: ‘conditions’
[13:36:34.304]   - Field: ‘expr’
[13:36:34.304]   - Field: ‘uuid’
[13:36:34.304]   - Field: ‘seed’
[13:36:34.304]   - Field: ‘version’
[13:36:34.304]   - Field: ‘result’
[13:36:34.304]   - Field: ‘asynchronous’
[13:36:34.305]   - Field: ‘calls’
[13:36:34.305]   - Field: ‘globals’
[13:36:34.305]   - Field: ‘stdout’
[13:36:34.305]   - Field: ‘earlySignal’
[13:36:34.305]   - Field: ‘lazy’
[13:36:34.305]   - Field: ‘state’
[13:36:34.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.305] - Launch lazy future ...
[13:36:34.305] Packages needed by the future expression (n = 0): <none>
[13:36:34.305] Packages needed by future strategies (n = 0): <none>
[13:36:34.306] {
[13:36:34.306]     {
[13:36:34.306]         {
[13:36:34.306]             ...future.startTime <- base::Sys.time()
[13:36:34.306]             {
[13:36:34.306]                 {
[13:36:34.306]                   {
[13:36:34.306]                     base::local({
[13:36:34.306]                       has_future <- base::requireNamespace("future", 
[13:36:34.306]                         quietly = TRUE)
[13:36:34.306]                       if (has_future) {
[13:36:34.306]                         ns <- base::getNamespace("future")
[13:36:34.306]                         version <- ns[[".package"]][["version"]]
[13:36:34.306]                         if (is.null(version)) 
[13:36:34.306]                           version <- utils::packageVersion("future")
[13:36:34.306]                       }
[13:36:34.306]                       else {
[13:36:34.306]                         version <- NULL
[13:36:34.306]                       }
[13:36:34.306]                       if (!has_future || version < "1.8.0") {
[13:36:34.306]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.306]                           "", base::R.version$version.string), 
[13:36:34.306]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.306]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.306]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.306]                             "release", "version")], collapse = " "), 
[13:36:34.306]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.306]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.306]                           info)
[13:36:34.306]                         info <- base::paste(info, collapse = "; ")
[13:36:34.306]                         if (!has_future) {
[13:36:34.306]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.306]                             info)
[13:36:34.306]                         }
[13:36:34.306]                         else {
[13:36:34.306]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.306]                             info, version)
[13:36:34.306]                         }
[13:36:34.306]                         base::stop(msg)
[13:36:34.306]                       }
[13:36:34.306]                     })
[13:36:34.306]                   }
[13:36:34.306]                   ...future.strategy.old <- future::plan("list")
[13:36:34.306]                   options(future.plan = NULL)
[13:36:34.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.306]                 }
[13:36:34.306]                 ...future.workdir <- getwd()
[13:36:34.306]             }
[13:36:34.306]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.306]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.306]         }
[13:36:34.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.306]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.306]             base::names(...future.oldOptions))
[13:36:34.306]     }
[13:36:34.306]     if (FALSE) {
[13:36:34.306]     }
[13:36:34.306]     else {
[13:36:34.306]         if (TRUE) {
[13:36:34.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.306]                 open = "w")
[13:36:34.306]         }
[13:36:34.306]         else {
[13:36:34.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.306]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.306]         }
[13:36:34.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.306]             base::sink(type = "output", split = FALSE)
[13:36:34.306]             base::close(...future.stdout)
[13:36:34.306]         }, add = TRUE)
[13:36:34.306]     }
[13:36:34.306]     ...future.frame <- base::sys.nframe()
[13:36:34.306]     ...future.conditions <- base::list()
[13:36:34.306]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.306]     if (FALSE) {
[13:36:34.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.306]     }
[13:36:34.306]     ...future.result <- base::tryCatch({
[13:36:34.306]         base::withCallingHandlers({
[13:36:34.306]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.306]             future::FutureResult(value = ...future.value$value, 
[13:36:34.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.306]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.306]                     ...future.globalenv.names))
[13:36:34.306]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.306]         }, condition = base::local({
[13:36:34.306]             c <- base::c
[13:36:34.306]             inherits <- base::inherits
[13:36:34.306]             invokeRestart <- base::invokeRestart
[13:36:34.306]             length <- base::length
[13:36:34.306]             list <- base::list
[13:36:34.306]             seq.int <- base::seq.int
[13:36:34.306]             signalCondition <- base::signalCondition
[13:36:34.306]             sys.calls <- base::sys.calls
[13:36:34.306]             `[[` <- base::`[[`
[13:36:34.306]             `+` <- base::`+`
[13:36:34.306]             `<<-` <- base::`<<-`
[13:36:34.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.306]                   3L)]
[13:36:34.306]             }
[13:36:34.306]             function(cond) {
[13:36:34.306]                 is_error <- inherits(cond, "error")
[13:36:34.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.306]                   NULL)
[13:36:34.306]                 if (is_error) {
[13:36:34.306]                   sessionInformation <- function() {
[13:36:34.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.306]                       search = base::search(), system = base::Sys.info())
[13:36:34.306]                   }
[13:36:34.306]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.306]                     cond$call), session = sessionInformation(), 
[13:36:34.306]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.306]                   signalCondition(cond)
[13:36:34.306]                 }
[13:36:34.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.306]                 "immediateCondition"))) {
[13:36:34.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.306]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.306]                   if (TRUE && !signal) {
[13:36:34.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.306]                     {
[13:36:34.306]                       inherits <- base::inherits
[13:36:34.306]                       invokeRestart <- base::invokeRestart
[13:36:34.306]                       is.null <- base::is.null
[13:36:34.306]                       muffled <- FALSE
[13:36:34.306]                       if (inherits(cond, "message")) {
[13:36:34.306]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.306]                         if (muffled) 
[13:36:34.306]                           invokeRestart("muffleMessage")
[13:36:34.306]                       }
[13:36:34.306]                       else if (inherits(cond, "warning")) {
[13:36:34.306]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.306]                         if (muffled) 
[13:36:34.306]                           invokeRestart("muffleWarning")
[13:36:34.306]                       }
[13:36:34.306]                       else if (inherits(cond, "condition")) {
[13:36:34.306]                         if (!is.null(pattern)) {
[13:36:34.306]                           computeRestarts <- base::computeRestarts
[13:36:34.306]                           grepl <- base::grepl
[13:36:34.306]                           restarts <- computeRestarts(cond)
[13:36:34.306]                           for (restart in restarts) {
[13:36:34.306]                             name <- restart$name
[13:36:34.306]                             if (is.null(name)) 
[13:36:34.306]                               next
[13:36:34.306]                             if (!grepl(pattern, name)) 
[13:36:34.306]                               next
[13:36:34.306]                             invokeRestart(restart)
[13:36:34.306]                             muffled <- TRUE
[13:36:34.306]                             break
[13:36:34.306]                           }
[13:36:34.306]                         }
[13:36:34.306]                       }
[13:36:34.306]                       invisible(muffled)
[13:36:34.306]                     }
[13:36:34.306]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.306]                   }
[13:36:34.306]                 }
[13:36:34.306]                 else {
[13:36:34.306]                   if (TRUE) {
[13:36:34.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.306]                     {
[13:36:34.306]                       inherits <- base::inherits
[13:36:34.306]                       invokeRestart <- base::invokeRestart
[13:36:34.306]                       is.null <- base::is.null
[13:36:34.306]                       muffled <- FALSE
[13:36:34.306]                       if (inherits(cond, "message")) {
[13:36:34.306]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.306]                         if (muffled) 
[13:36:34.306]                           invokeRestart("muffleMessage")
[13:36:34.306]                       }
[13:36:34.306]                       else if (inherits(cond, "warning")) {
[13:36:34.306]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.306]                         if (muffled) 
[13:36:34.306]                           invokeRestart("muffleWarning")
[13:36:34.306]                       }
[13:36:34.306]                       else if (inherits(cond, "condition")) {
[13:36:34.306]                         if (!is.null(pattern)) {
[13:36:34.306]                           computeRestarts <- base::computeRestarts
[13:36:34.306]                           grepl <- base::grepl
[13:36:34.306]                           restarts <- computeRestarts(cond)
[13:36:34.306]                           for (restart in restarts) {
[13:36:34.306]                             name <- restart$name
[13:36:34.306]                             if (is.null(name)) 
[13:36:34.306]                               next
[13:36:34.306]                             if (!grepl(pattern, name)) 
[13:36:34.306]                               next
[13:36:34.306]                             invokeRestart(restart)
[13:36:34.306]                             muffled <- TRUE
[13:36:34.306]                             break
[13:36:34.306]                           }
[13:36:34.306]                         }
[13:36:34.306]                       }
[13:36:34.306]                       invisible(muffled)
[13:36:34.306]                     }
[13:36:34.306]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.306]                   }
[13:36:34.306]                 }
[13:36:34.306]             }
[13:36:34.306]         }))
[13:36:34.306]     }, error = function(ex) {
[13:36:34.306]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.306]                 ...future.rng), started = ...future.startTime, 
[13:36:34.306]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.306]             version = "1.8"), class = "FutureResult")
[13:36:34.306]     }, finally = {
[13:36:34.306]         if (!identical(...future.workdir, getwd())) 
[13:36:34.306]             setwd(...future.workdir)
[13:36:34.306]         {
[13:36:34.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.306]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.306]             }
[13:36:34.306]             base::options(...future.oldOptions)
[13:36:34.306]             if (.Platform$OS.type == "windows") {
[13:36:34.306]                 old_names <- names(...future.oldEnvVars)
[13:36:34.306]                 envs <- base::Sys.getenv()
[13:36:34.306]                 names <- names(envs)
[13:36:34.306]                 common <- intersect(names, old_names)
[13:36:34.306]                 added <- setdiff(names, old_names)
[13:36:34.306]                 removed <- setdiff(old_names, names)
[13:36:34.306]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.306]                   envs[common]]
[13:36:34.306]                 NAMES <- toupper(changed)
[13:36:34.306]                 args <- list()
[13:36:34.306]                 for (kk in seq_along(NAMES)) {
[13:36:34.306]                   name <- changed[[kk]]
[13:36:34.306]                   NAME <- NAMES[[kk]]
[13:36:34.306]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.306]                     next
[13:36:34.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.306]                 }
[13:36:34.306]                 NAMES <- toupper(added)
[13:36:34.306]                 for (kk in seq_along(NAMES)) {
[13:36:34.306]                   name <- added[[kk]]
[13:36:34.306]                   NAME <- NAMES[[kk]]
[13:36:34.306]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.306]                     next
[13:36:34.306]                   args[[name]] <- ""
[13:36:34.306]                 }
[13:36:34.306]                 NAMES <- toupper(removed)
[13:36:34.306]                 for (kk in seq_along(NAMES)) {
[13:36:34.306]                   name <- removed[[kk]]
[13:36:34.306]                   NAME <- NAMES[[kk]]
[13:36:34.306]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.306]                     next
[13:36:34.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.306]                 }
[13:36:34.306]                 if (length(args) > 0) 
[13:36:34.306]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.306]             }
[13:36:34.306]             else {
[13:36:34.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.306]             }
[13:36:34.306]             {
[13:36:34.306]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.306]                   0L) {
[13:36:34.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.306]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.306]                   base::options(opts)
[13:36:34.306]                 }
[13:36:34.306]                 {
[13:36:34.306]                   {
[13:36:34.306]                     NULL
[13:36:34.306]                     RNGkind("Mersenne-Twister")
[13:36:34.306]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.306]                       inherits = FALSE)
[13:36:34.306]                   }
[13:36:34.306]                   options(future.plan = NULL)
[13:36:34.306]                   if (is.na(NA_character_)) 
[13:36:34.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.306]                     .init = FALSE)
[13:36:34.306]                 }
[13:36:34.306]             }
[13:36:34.306]         }
[13:36:34.306]     })
[13:36:34.306]     if (TRUE) {
[13:36:34.306]         base::sink(type = "output", split = FALSE)
[13:36:34.306]         if (TRUE) {
[13:36:34.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.306]         }
[13:36:34.306]         else {
[13:36:34.306]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.306]         }
[13:36:34.306]         base::close(...future.stdout)
[13:36:34.306]         ...future.stdout <- NULL
[13:36:34.306]     }
[13:36:34.306]     ...future.result$conditions <- ...future.conditions
[13:36:34.306]     ...future.result$finished <- base::Sys.time()
[13:36:34.306]     ...future.result
[13:36:34.306] }
[13:36:34.307] plan(): Setting new future strategy stack:
[13:36:34.308] List of future strategies:
[13:36:34.308] 1. sequential:
[13:36:34.308]    - args: function (..., envir = parent.frame())
[13:36:34.308]    - tweaked: FALSE
[13:36:34.308]    - call: NULL
[13:36:34.308] plan(): nbrOfWorkers() = 1
[13:36:34.309] plan(): Setting new future strategy stack:
[13:36:34.309] List of future strategies:
[13:36:34.309] 1. sequential:
[13:36:34.309]    - args: function (..., envir = parent.frame())
[13:36:34.309]    - tweaked: FALSE
[13:36:34.309]    - call: plan(strategy)
[13:36:34.309] plan(): nbrOfWorkers() = 1
[13:36:34.309] SequentialFuture started (and completed)
[13:36:34.309] - Launch lazy future ... done
[13:36:34.309] run() for ‘SequentialFuture’ ... done
[13:36:34.309] getGlobalsAndPackages() ...
[13:36:34.310] Searching for globals...
[13:36:34.310] 
[13:36:34.310] Searching for globals ... DONE
[13:36:34.310] - globals: [0] <none>
[13:36:34.310] getGlobalsAndPackages() ... DONE
[13:36:34.310] run() for ‘Future’ ...
[13:36:34.310] - state: ‘created’
[13:36:34.311] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.311] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.311]   - Field: ‘label’
[13:36:34.311]   - Field: ‘local’
[13:36:34.311]   - Field: ‘owner’
[13:36:34.311]   - Field: ‘envir’
[13:36:34.311]   - Field: ‘packages’
[13:36:34.311]   - Field: ‘gc’
[13:36:34.311]   - Field: ‘conditions’
[13:36:34.312]   - Field: ‘expr’
[13:36:34.312]   - Field: ‘uuid’
[13:36:34.312]   - Field: ‘seed’
[13:36:34.312]   - Field: ‘version’
[13:36:34.312]   - Field: ‘result’
[13:36:34.312]   - Field: ‘asynchronous’
[13:36:34.312]   - Field: ‘calls’
[13:36:34.312]   - Field: ‘globals’
[13:36:34.312]   - Field: ‘stdout’
[13:36:34.312]   - Field: ‘earlySignal’
[13:36:34.312]   - Field: ‘lazy’
[13:36:34.313]   - Field: ‘state’
[13:36:34.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.313] - Launch lazy future ...
[13:36:34.313] Packages needed by the future expression (n = 0): <none>
[13:36:34.313] Packages needed by future strategies (n = 0): <none>
[13:36:34.313] {
[13:36:34.313]     {
[13:36:34.313]         {
[13:36:34.313]             ...future.startTime <- base::Sys.time()
[13:36:34.313]             {
[13:36:34.313]                 {
[13:36:34.313]                   {
[13:36:34.313]                     base::local({
[13:36:34.313]                       has_future <- base::requireNamespace("future", 
[13:36:34.313]                         quietly = TRUE)
[13:36:34.313]                       if (has_future) {
[13:36:34.313]                         ns <- base::getNamespace("future")
[13:36:34.313]                         version <- ns[[".package"]][["version"]]
[13:36:34.313]                         if (is.null(version)) 
[13:36:34.313]                           version <- utils::packageVersion("future")
[13:36:34.313]                       }
[13:36:34.313]                       else {
[13:36:34.313]                         version <- NULL
[13:36:34.313]                       }
[13:36:34.313]                       if (!has_future || version < "1.8.0") {
[13:36:34.313]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.313]                           "", base::R.version$version.string), 
[13:36:34.313]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.313]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.313]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.313]                             "release", "version")], collapse = " "), 
[13:36:34.313]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.313]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.313]                           info)
[13:36:34.313]                         info <- base::paste(info, collapse = "; ")
[13:36:34.313]                         if (!has_future) {
[13:36:34.313]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.313]                             info)
[13:36:34.313]                         }
[13:36:34.313]                         else {
[13:36:34.313]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.313]                             info, version)
[13:36:34.313]                         }
[13:36:34.313]                         base::stop(msg)
[13:36:34.313]                       }
[13:36:34.313]                     })
[13:36:34.313]                   }
[13:36:34.313]                   ...future.strategy.old <- future::plan("list")
[13:36:34.313]                   options(future.plan = NULL)
[13:36:34.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.313]                 }
[13:36:34.313]                 ...future.workdir <- getwd()
[13:36:34.313]             }
[13:36:34.313]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.313]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.313]         }
[13:36:34.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.313]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.313]             base::names(...future.oldOptions))
[13:36:34.313]     }
[13:36:34.313]     if (FALSE) {
[13:36:34.313]     }
[13:36:34.313]     else {
[13:36:34.313]         if (TRUE) {
[13:36:34.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.313]                 open = "w")
[13:36:34.313]         }
[13:36:34.313]         else {
[13:36:34.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.313]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.313]         }
[13:36:34.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.313]             base::sink(type = "output", split = FALSE)
[13:36:34.313]             base::close(...future.stdout)
[13:36:34.313]         }, add = TRUE)
[13:36:34.313]     }
[13:36:34.313]     ...future.frame <- base::sys.nframe()
[13:36:34.313]     ...future.conditions <- base::list()
[13:36:34.313]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.313]     if (FALSE) {
[13:36:34.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.313]     }
[13:36:34.313]     ...future.result <- base::tryCatch({
[13:36:34.313]         base::withCallingHandlers({
[13:36:34.313]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.313]             future::FutureResult(value = ...future.value$value, 
[13:36:34.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.313]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.313]                     ...future.globalenv.names))
[13:36:34.313]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.313]         }, condition = base::local({
[13:36:34.313]             c <- base::c
[13:36:34.313]             inherits <- base::inherits
[13:36:34.313]             invokeRestart <- base::invokeRestart
[13:36:34.313]             length <- base::length
[13:36:34.313]             list <- base::list
[13:36:34.313]             seq.int <- base::seq.int
[13:36:34.313]             signalCondition <- base::signalCondition
[13:36:34.313]             sys.calls <- base::sys.calls
[13:36:34.313]             `[[` <- base::`[[`
[13:36:34.313]             `+` <- base::`+`
[13:36:34.313]             `<<-` <- base::`<<-`
[13:36:34.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.313]                   3L)]
[13:36:34.313]             }
[13:36:34.313]             function(cond) {
[13:36:34.313]                 is_error <- inherits(cond, "error")
[13:36:34.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.313]                   NULL)
[13:36:34.313]                 if (is_error) {
[13:36:34.313]                   sessionInformation <- function() {
[13:36:34.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.313]                       search = base::search(), system = base::Sys.info())
[13:36:34.313]                   }
[13:36:34.313]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.313]                     cond$call), session = sessionInformation(), 
[13:36:34.313]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.313]                   signalCondition(cond)
[13:36:34.313]                 }
[13:36:34.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.313]                 "immediateCondition"))) {
[13:36:34.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.313]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.313]                   if (TRUE && !signal) {
[13:36:34.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.313]                     {
[13:36:34.313]                       inherits <- base::inherits
[13:36:34.313]                       invokeRestart <- base::invokeRestart
[13:36:34.313]                       is.null <- base::is.null
[13:36:34.313]                       muffled <- FALSE
[13:36:34.313]                       if (inherits(cond, "message")) {
[13:36:34.313]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.313]                         if (muffled) 
[13:36:34.313]                           invokeRestart("muffleMessage")
[13:36:34.313]                       }
[13:36:34.313]                       else if (inherits(cond, "warning")) {
[13:36:34.313]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.313]                         if (muffled) 
[13:36:34.313]                           invokeRestart("muffleWarning")
[13:36:34.313]                       }
[13:36:34.313]                       else if (inherits(cond, "condition")) {
[13:36:34.313]                         if (!is.null(pattern)) {
[13:36:34.313]                           computeRestarts <- base::computeRestarts
[13:36:34.313]                           grepl <- base::grepl
[13:36:34.313]                           restarts <- computeRestarts(cond)
[13:36:34.313]                           for (restart in restarts) {
[13:36:34.313]                             name <- restart$name
[13:36:34.313]                             if (is.null(name)) 
[13:36:34.313]                               next
[13:36:34.313]                             if (!grepl(pattern, name)) 
[13:36:34.313]                               next
[13:36:34.313]                             invokeRestart(restart)
[13:36:34.313]                             muffled <- TRUE
[13:36:34.313]                             break
[13:36:34.313]                           }
[13:36:34.313]                         }
[13:36:34.313]                       }
[13:36:34.313]                       invisible(muffled)
[13:36:34.313]                     }
[13:36:34.313]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.313]                   }
[13:36:34.313]                 }
[13:36:34.313]                 else {
[13:36:34.313]                   if (TRUE) {
[13:36:34.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.313]                     {
[13:36:34.313]                       inherits <- base::inherits
[13:36:34.313]                       invokeRestart <- base::invokeRestart
[13:36:34.313]                       is.null <- base::is.null
[13:36:34.313]                       muffled <- FALSE
[13:36:34.313]                       if (inherits(cond, "message")) {
[13:36:34.313]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.313]                         if (muffled) 
[13:36:34.313]                           invokeRestart("muffleMessage")
[13:36:34.313]                       }
[13:36:34.313]                       else if (inherits(cond, "warning")) {
[13:36:34.313]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.313]                         if (muffled) 
[13:36:34.313]                           invokeRestart("muffleWarning")
[13:36:34.313]                       }
[13:36:34.313]                       else if (inherits(cond, "condition")) {
[13:36:34.313]                         if (!is.null(pattern)) {
[13:36:34.313]                           computeRestarts <- base::computeRestarts
[13:36:34.313]                           grepl <- base::grepl
[13:36:34.313]                           restarts <- computeRestarts(cond)
[13:36:34.313]                           for (restart in restarts) {
[13:36:34.313]                             name <- restart$name
[13:36:34.313]                             if (is.null(name)) 
[13:36:34.313]                               next
[13:36:34.313]                             if (!grepl(pattern, name)) 
[13:36:34.313]                               next
[13:36:34.313]                             invokeRestart(restart)
[13:36:34.313]                             muffled <- TRUE
[13:36:34.313]                             break
[13:36:34.313]                           }
[13:36:34.313]                         }
[13:36:34.313]                       }
[13:36:34.313]                       invisible(muffled)
[13:36:34.313]                     }
[13:36:34.313]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.313]                   }
[13:36:34.313]                 }
[13:36:34.313]             }
[13:36:34.313]         }))
[13:36:34.313]     }, error = function(ex) {
[13:36:34.313]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.313]                 ...future.rng), started = ...future.startTime, 
[13:36:34.313]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.313]             version = "1.8"), class = "FutureResult")
[13:36:34.313]     }, finally = {
[13:36:34.313]         if (!identical(...future.workdir, getwd())) 
[13:36:34.313]             setwd(...future.workdir)
[13:36:34.313]         {
[13:36:34.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.313]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.313]             }
[13:36:34.313]             base::options(...future.oldOptions)
[13:36:34.313]             if (.Platform$OS.type == "windows") {
[13:36:34.313]                 old_names <- names(...future.oldEnvVars)
[13:36:34.313]                 envs <- base::Sys.getenv()
[13:36:34.313]                 names <- names(envs)
[13:36:34.313]                 common <- intersect(names, old_names)
[13:36:34.313]                 added <- setdiff(names, old_names)
[13:36:34.313]                 removed <- setdiff(old_names, names)
[13:36:34.313]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.313]                   envs[common]]
[13:36:34.313]                 NAMES <- toupper(changed)
[13:36:34.313]                 args <- list()
[13:36:34.313]                 for (kk in seq_along(NAMES)) {
[13:36:34.313]                   name <- changed[[kk]]
[13:36:34.313]                   NAME <- NAMES[[kk]]
[13:36:34.313]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.313]                     next
[13:36:34.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.313]                 }
[13:36:34.313]                 NAMES <- toupper(added)
[13:36:34.313]                 for (kk in seq_along(NAMES)) {
[13:36:34.313]                   name <- added[[kk]]
[13:36:34.313]                   NAME <- NAMES[[kk]]
[13:36:34.313]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.313]                     next
[13:36:34.313]                   args[[name]] <- ""
[13:36:34.313]                 }
[13:36:34.313]                 NAMES <- toupper(removed)
[13:36:34.313]                 for (kk in seq_along(NAMES)) {
[13:36:34.313]                   name <- removed[[kk]]
[13:36:34.313]                   NAME <- NAMES[[kk]]
[13:36:34.313]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.313]                     next
[13:36:34.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.313]                 }
[13:36:34.313]                 if (length(args) > 0) 
[13:36:34.313]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.313]             }
[13:36:34.313]             else {
[13:36:34.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.313]             }
[13:36:34.313]             {
[13:36:34.313]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.313]                   0L) {
[13:36:34.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.313]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.313]                   base::options(opts)
[13:36:34.313]                 }
[13:36:34.313]                 {
[13:36:34.313]                   {
[13:36:34.313]                     NULL
[13:36:34.313]                     RNGkind("Mersenne-Twister")
[13:36:34.313]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.313]                       inherits = FALSE)
[13:36:34.313]                   }
[13:36:34.313]                   options(future.plan = NULL)
[13:36:34.313]                   if (is.na(NA_character_)) 
[13:36:34.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.313]                     .init = FALSE)
[13:36:34.313]                 }
[13:36:34.313]             }
[13:36:34.313]         }
[13:36:34.313]     })
[13:36:34.313]     if (TRUE) {
[13:36:34.313]         base::sink(type = "output", split = FALSE)
[13:36:34.313]         if (TRUE) {
[13:36:34.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.313]         }
[13:36:34.313]         else {
[13:36:34.313]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.313]         }
[13:36:34.313]         base::close(...future.stdout)
[13:36:34.313]         ...future.stdout <- NULL
[13:36:34.313]     }
[13:36:34.313]     ...future.result$conditions <- ...future.conditions
[13:36:34.313]     ...future.result$finished <- base::Sys.time()
[13:36:34.313]     ...future.result
[13:36:34.313] }
[13:36:34.315] plan(): Setting new future strategy stack:
[13:36:34.315] List of future strategies:
[13:36:34.315] 1. sequential:
[13:36:34.315]    - args: function (..., envir = parent.frame())
[13:36:34.315]    - tweaked: FALSE
[13:36:34.315]    - call: NULL
[13:36:34.315] plan(): nbrOfWorkers() = 1
[13:36:34.316] plan(): Setting new future strategy stack:
[13:36:34.316] List of future strategies:
[13:36:34.316] 1. sequential:
[13:36:34.316]    - args: function (..., envir = parent.frame())
[13:36:34.316]    - tweaked: FALSE
[13:36:34.316]    - call: plan(strategy)
[13:36:34.317] plan(): nbrOfWorkers() = 1
[13:36:34.317] SequentialFuture started (and completed)
[13:36:34.317] - Launch lazy future ... done
[13:36:34.317] run() for ‘SequentialFuture’ ... done
[13:36:34.317] getGlobalsAndPackages() ...
[13:36:34.317] Searching for globals...
[13:36:34.318] - globals found: [1] ‘{’
[13:36:34.318] Searching for globals ... DONE
[13:36:34.318] Resolving globals: FALSE
[13:36:34.318] 
[13:36:34.318] 
[13:36:34.318] getGlobalsAndPackages() ... DONE
[13:36:34.319] run() for ‘Future’ ...
[13:36:34.319] - state: ‘created’
[13:36:34.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.319] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.319] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.319]   - Field: ‘label’
[13:36:34.319]   - Field: ‘local’
[13:36:34.319]   - Field: ‘owner’
[13:36:34.320]   - Field: ‘envir’
[13:36:34.320]   - Field: ‘packages’
[13:36:34.320]   - Field: ‘gc’
[13:36:34.320]   - Field: ‘conditions’
[13:36:34.320]   - Field: ‘expr’
[13:36:34.320]   - Field: ‘uuid’
[13:36:34.320]   - Field: ‘seed’
[13:36:34.320]   - Field: ‘version’
[13:36:34.320]   - Field: ‘result’
[13:36:34.320]   - Field: ‘asynchronous’
[13:36:34.320]   - Field: ‘calls’
[13:36:34.321]   - Field: ‘globals’
[13:36:34.321]   - Field: ‘stdout’
[13:36:34.321]   - Field: ‘earlySignal’
[13:36:34.321]   - Field: ‘lazy’
[13:36:34.321]   - Field: ‘state’
[13:36:34.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.321] - Launch lazy future ...
[13:36:34.321] Packages needed by the future expression (n = 0): <none>
[13:36:34.321] Packages needed by future strategies (n = 0): <none>
[13:36:34.322] {
[13:36:34.322]     {
[13:36:34.322]         {
[13:36:34.322]             ...future.startTime <- base::Sys.time()
[13:36:34.322]             {
[13:36:34.322]                 {
[13:36:34.322]                   {
[13:36:34.322]                     base::local({
[13:36:34.322]                       has_future <- base::requireNamespace("future", 
[13:36:34.322]                         quietly = TRUE)
[13:36:34.322]                       if (has_future) {
[13:36:34.322]                         ns <- base::getNamespace("future")
[13:36:34.322]                         version <- ns[[".package"]][["version"]]
[13:36:34.322]                         if (is.null(version)) 
[13:36:34.322]                           version <- utils::packageVersion("future")
[13:36:34.322]                       }
[13:36:34.322]                       else {
[13:36:34.322]                         version <- NULL
[13:36:34.322]                       }
[13:36:34.322]                       if (!has_future || version < "1.8.0") {
[13:36:34.322]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.322]                           "", base::R.version$version.string), 
[13:36:34.322]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.322]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.322]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.322]                             "release", "version")], collapse = " "), 
[13:36:34.322]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.322]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.322]                           info)
[13:36:34.322]                         info <- base::paste(info, collapse = "; ")
[13:36:34.322]                         if (!has_future) {
[13:36:34.322]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.322]                             info)
[13:36:34.322]                         }
[13:36:34.322]                         else {
[13:36:34.322]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.322]                             info, version)
[13:36:34.322]                         }
[13:36:34.322]                         base::stop(msg)
[13:36:34.322]                       }
[13:36:34.322]                     })
[13:36:34.322]                   }
[13:36:34.322]                   ...future.strategy.old <- future::plan("list")
[13:36:34.322]                   options(future.plan = NULL)
[13:36:34.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.322]                 }
[13:36:34.322]                 ...future.workdir <- getwd()
[13:36:34.322]             }
[13:36:34.322]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.322]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.322]         }
[13:36:34.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.322]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.322]             base::names(...future.oldOptions))
[13:36:34.322]     }
[13:36:34.322]     if (FALSE) {
[13:36:34.322]     }
[13:36:34.322]     else {
[13:36:34.322]         if (TRUE) {
[13:36:34.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.322]                 open = "w")
[13:36:34.322]         }
[13:36:34.322]         else {
[13:36:34.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.322]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.322]         }
[13:36:34.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.322]             base::sink(type = "output", split = FALSE)
[13:36:34.322]             base::close(...future.stdout)
[13:36:34.322]         }, add = TRUE)
[13:36:34.322]     }
[13:36:34.322]     ...future.frame <- base::sys.nframe()
[13:36:34.322]     ...future.conditions <- base::list()
[13:36:34.322]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.322]     if (FALSE) {
[13:36:34.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.322]     }
[13:36:34.322]     ...future.result <- base::tryCatch({
[13:36:34.322]         base::withCallingHandlers({
[13:36:34.322]             ...future.value <- base::withVisible(base::local({
[13:36:34.322]                 4
[13:36:34.322]             }))
[13:36:34.322]             future::FutureResult(value = ...future.value$value, 
[13:36:34.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.322]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.322]                     ...future.globalenv.names))
[13:36:34.322]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.322]         }, condition = base::local({
[13:36:34.322]             c <- base::c
[13:36:34.322]             inherits <- base::inherits
[13:36:34.322]             invokeRestart <- base::invokeRestart
[13:36:34.322]             length <- base::length
[13:36:34.322]             list <- base::list
[13:36:34.322]             seq.int <- base::seq.int
[13:36:34.322]             signalCondition <- base::signalCondition
[13:36:34.322]             sys.calls <- base::sys.calls
[13:36:34.322]             `[[` <- base::`[[`
[13:36:34.322]             `+` <- base::`+`
[13:36:34.322]             `<<-` <- base::`<<-`
[13:36:34.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.322]                   3L)]
[13:36:34.322]             }
[13:36:34.322]             function(cond) {
[13:36:34.322]                 is_error <- inherits(cond, "error")
[13:36:34.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.322]                   NULL)
[13:36:34.322]                 if (is_error) {
[13:36:34.322]                   sessionInformation <- function() {
[13:36:34.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.322]                       search = base::search(), system = base::Sys.info())
[13:36:34.322]                   }
[13:36:34.322]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.322]                     cond$call), session = sessionInformation(), 
[13:36:34.322]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.322]                   signalCondition(cond)
[13:36:34.322]                 }
[13:36:34.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.322]                 "immediateCondition"))) {
[13:36:34.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.322]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.322]                   if (TRUE && !signal) {
[13:36:34.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.322]                     {
[13:36:34.322]                       inherits <- base::inherits
[13:36:34.322]                       invokeRestart <- base::invokeRestart
[13:36:34.322]                       is.null <- base::is.null
[13:36:34.322]                       muffled <- FALSE
[13:36:34.322]                       if (inherits(cond, "message")) {
[13:36:34.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.322]                         if (muffled) 
[13:36:34.322]                           invokeRestart("muffleMessage")
[13:36:34.322]                       }
[13:36:34.322]                       else if (inherits(cond, "warning")) {
[13:36:34.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.322]                         if (muffled) 
[13:36:34.322]                           invokeRestart("muffleWarning")
[13:36:34.322]                       }
[13:36:34.322]                       else if (inherits(cond, "condition")) {
[13:36:34.322]                         if (!is.null(pattern)) {
[13:36:34.322]                           computeRestarts <- base::computeRestarts
[13:36:34.322]                           grepl <- base::grepl
[13:36:34.322]                           restarts <- computeRestarts(cond)
[13:36:34.322]                           for (restart in restarts) {
[13:36:34.322]                             name <- restart$name
[13:36:34.322]                             if (is.null(name)) 
[13:36:34.322]                               next
[13:36:34.322]                             if (!grepl(pattern, name)) 
[13:36:34.322]                               next
[13:36:34.322]                             invokeRestart(restart)
[13:36:34.322]                             muffled <- TRUE
[13:36:34.322]                             break
[13:36:34.322]                           }
[13:36:34.322]                         }
[13:36:34.322]                       }
[13:36:34.322]                       invisible(muffled)
[13:36:34.322]                     }
[13:36:34.322]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.322]                   }
[13:36:34.322]                 }
[13:36:34.322]                 else {
[13:36:34.322]                   if (TRUE) {
[13:36:34.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.322]                     {
[13:36:34.322]                       inherits <- base::inherits
[13:36:34.322]                       invokeRestart <- base::invokeRestart
[13:36:34.322]                       is.null <- base::is.null
[13:36:34.322]                       muffled <- FALSE
[13:36:34.322]                       if (inherits(cond, "message")) {
[13:36:34.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.322]                         if (muffled) 
[13:36:34.322]                           invokeRestart("muffleMessage")
[13:36:34.322]                       }
[13:36:34.322]                       else if (inherits(cond, "warning")) {
[13:36:34.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.322]                         if (muffled) 
[13:36:34.322]                           invokeRestart("muffleWarning")
[13:36:34.322]                       }
[13:36:34.322]                       else if (inherits(cond, "condition")) {
[13:36:34.322]                         if (!is.null(pattern)) {
[13:36:34.322]                           computeRestarts <- base::computeRestarts
[13:36:34.322]                           grepl <- base::grepl
[13:36:34.322]                           restarts <- computeRestarts(cond)
[13:36:34.322]                           for (restart in restarts) {
[13:36:34.322]                             name <- restart$name
[13:36:34.322]                             if (is.null(name)) 
[13:36:34.322]                               next
[13:36:34.322]                             if (!grepl(pattern, name)) 
[13:36:34.322]                               next
[13:36:34.322]                             invokeRestart(restart)
[13:36:34.322]                             muffled <- TRUE
[13:36:34.322]                             break
[13:36:34.322]                           }
[13:36:34.322]                         }
[13:36:34.322]                       }
[13:36:34.322]                       invisible(muffled)
[13:36:34.322]                     }
[13:36:34.322]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.322]                   }
[13:36:34.322]                 }
[13:36:34.322]             }
[13:36:34.322]         }))
[13:36:34.322]     }, error = function(ex) {
[13:36:34.322]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.322]                 ...future.rng), started = ...future.startTime, 
[13:36:34.322]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.322]             version = "1.8"), class = "FutureResult")
[13:36:34.322]     }, finally = {
[13:36:34.322]         if (!identical(...future.workdir, getwd())) 
[13:36:34.322]             setwd(...future.workdir)
[13:36:34.322]         {
[13:36:34.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.322]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.322]             }
[13:36:34.322]             base::options(...future.oldOptions)
[13:36:34.322]             if (.Platform$OS.type == "windows") {
[13:36:34.322]                 old_names <- names(...future.oldEnvVars)
[13:36:34.322]                 envs <- base::Sys.getenv()
[13:36:34.322]                 names <- names(envs)
[13:36:34.322]                 common <- intersect(names, old_names)
[13:36:34.322]                 added <- setdiff(names, old_names)
[13:36:34.322]                 removed <- setdiff(old_names, names)
[13:36:34.322]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.322]                   envs[common]]
[13:36:34.322]                 NAMES <- toupper(changed)
[13:36:34.322]                 args <- list()
[13:36:34.322]                 for (kk in seq_along(NAMES)) {
[13:36:34.322]                   name <- changed[[kk]]
[13:36:34.322]                   NAME <- NAMES[[kk]]
[13:36:34.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.322]                     next
[13:36:34.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.322]                 }
[13:36:34.322]                 NAMES <- toupper(added)
[13:36:34.322]                 for (kk in seq_along(NAMES)) {
[13:36:34.322]                   name <- added[[kk]]
[13:36:34.322]                   NAME <- NAMES[[kk]]
[13:36:34.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.322]                     next
[13:36:34.322]                   args[[name]] <- ""
[13:36:34.322]                 }
[13:36:34.322]                 NAMES <- toupper(removed)
[13:36:34.322]                 for (kk in seq_along(NAMES)) {
[13:36:34.322]                   name <- removed[[kk]]
[13:36:34.322]                   NAME <- NAMES[[kk]]
[13:36:34.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.322]                     next
[13:36:34.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.322]                 }
[13:36:34.322]                 if (length(args) > 0) 
[13:36:34.322]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.322]             }
[13:36:34.322]             else {
[13:36:34.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.322]             }
[13:36:34.322]             {
[13:36:34.322]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.322]                   0L) {
[13:36:34.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.322]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.322]                   base::options(opts)
[13:36:34.322]                 }
[13:36:34.322]                 {
[13:36:34.322]                   {
[13:36:34.322]                     NULL
[13:36:34.322]                     RNGkind("Mersenne-Twister")
[13:36:34.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.322]                       inherits = FALSE)
[13:36:34.322]                   }
[13:36:34.322]                   options(future.plan = NULL)
[13:36:34.322]                   if (is.na(NA_character_)) 
[13:36:34.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.322]                     .init = FALSE)
[13:36:34.322]                 }
[13:36:34.322]             }
[13:36:34.322]         }
[13:36:34.322]     })
[13:36:34.322]     if (TRUE) {
[13:36:34.322]         base::sink(type = "output", split = FALSE)
[13:36:34.322]         if (TRUE) {
[13:36:34.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.322]         }
[13:36:34.322]         else {
[13:36:34.322]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.322]         }
[13:36:34.322]         base::close(...future.stdout)
[13:36:34.322]         ...future.stdout <- NULL
[13:36:34.322]     }
[13:36:34.322]     ...future.result$conditions <- ...future.conditions
[13:36:34.322]     ...future.result$finished <- base::Sys.time()
[13:36:34.322]     ...future.result
[13:36:34.322] }
[13:36:34.323] plan(): Setting new future strategy stack:
[13:36:34.323] List of future strategies:
[13:36:34.323] 1. sequential:
[13:36:34.323]    - args: function (..., envir = parent.frame())
[13:36:34.323]    - tweaked: FALSE
[13:36:34.323]    - call: NULL
[13:36:34.324] plan(): nbrOfWorkers() = 1
[13:36:34.324] plan(): Setting new future strategy stack:
[13:36:34.325] List of future strategies:
[13:36:34.325] 1. sequential:
[13:36:34.325]    - args: function (..., envir = parent.frame())
[13:36:34.325]    - tweaked: FALSE
[13:36:34.325]    - call: plan(strategy)
[13:36:34.325] plan(): nbrOfWorkers() = 1
[13:36:34.325] SequentialFuture started (and completed)
[13:36:34.325] - Launch lazy future ... done
[13:36:34.325] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a71fd9eb0> 
Classes 'listenv', 'environment' <environment: 0x564a737909b0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:34.330] resolved() for ‘SequentialFuture’ ...
[13:36:34.330] - state: ‘finished’
[13:36:34.330] - run: TRUE
[13:36:34.330] - result: ‘FutureResult’
[13:36:34.330] resolved() for ‘SequentialFuture’ ... done
[13:36:34.330] resolved() for ‘SequentialFuture’ ...
[13:36:34.330] - state: ‘finished’
[13:36:34.330] - run: TRUE
[13:36:34.331] - result: ‘FutureResult’
[13:36:34.331] resolved() for ‘SequentialFuture’ ... done
[13:36:34.331] resolved() for ‘SequentialFuture’ ...
[13:36:34.331] - state: ‘finished’
[13:36:34.331] - run: TRUE
[13:36:34.331] - result: ‘FutureResult’
[13:36:34.331] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:34.334] resolve() on list environment ...
[13:36:34.334]  recursive: 0
[13:36:34.335]  length: 6
[13:36:34.335]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:34.335] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.335] - nx: 6
[13:36:34.336] - relay: TRUE
[13:36:34.336] - stdout: TRUE
[13:36:34.336] - signal: TRUE
[13:36:34.336] - resignal: FALSE
[13:36:34.336] - force: TRUE
[13:36:34.336] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.336] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.336]  - until=2
[13:36:34.336]  - relaying element #2
[13:36:34.337] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.337] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.337] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.337]  length: 5 (resolved future 1)
[13:36:34.337] resolved() for ‘SequentialFuture’ ...
[13:36:34.337] - state: ‘finished’
[13:36:34.337] - run: TRUE
[13:36:34.337] - result: ‘FutureResult’
[13:36:34.338] resolved() for ‘SequentialFuture’ ... done
[13:36:34.338] Future #2
[13:36:34.338] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.338] - nx: 6
[13:36:34.338] - relay: TRUE
[13:36:34.338] - stdout: TRUE
[13:36:34.338] - signal: TRUE
[13:36:34.338] - resignal: FALSE
[13:36:34.338] - force: TRUE
[13:36:34.339] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.339] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.339]  - until=2
[13:36:34.339]  - relaying element #2
[13:36:34.339] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.339] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.339] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.339]  length: 4 (resolved future 2)
[13:36:34.339] resolved() for ‘SequentialFuture’ ...
[13:36:34.340] - state: ‘finished’
[13:36:34.340] - run: TRUE
[13:36:34.340] - result: ‘FutureResult’
[13:36:34.340] resolved() for ‘SequentialFuture’ ... done
[13:36:34.340] Future #3
[13:36:34.340] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.340] - nx: 6
[13:36:34.340] - relay: TRUE
[13:36:34.341] - stdout: TRUE
[13:36:34.341] - signal: TRUE
[13:36:34.341] - resignal: FALSE
[13:36:34.341] - force: TRUE
[13:36:34.341] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.341] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.341]  - until=3
[13:36:34.341]  - relaying element #3
[13:36:34.341] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.342] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.342] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.342]  length: 3 (resolved future 3)
[13:36:34.342] resolved() for ‘SequentialFuture’ ...
[13:36:34.342] - state: ‘finished’
[13:36:34.342] - run: TRUE
[13:36:34.342] - result: ‘FutureResult’
[13:36:34.342] resolved() for ‘SequentialFuture’ ... done
[13:36:34.343] Future #4
[13:36:34.343] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.343] - nx: 6
[13:36:34.343] - relay: TRUE
[13:36:34.343] - stdout: TRUE
[13:36:34.343] - signal: TRUE
[13:36:34.343] - resignal: FALSE
[13:36:34.343] - force: TRUE
[13:36:34.343] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.344] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.344]  - until=4
[13:36:34.344]  - relaying element #4
[13:36:34.344] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.344] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.344] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.344]  length: 2 (resolved future 4)
[13:36:34.344] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.345] - nx: 6
[13:36:34.345] - relay: TRUE
[13:36:34.345] - stdout: TRUE
[13:36:34.345] - signal: TRUE
[13:36:34.345] - resignal: FALSE
[13:36:34.345] - force: TRUE
[13:36:34.345] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.345] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.345]  - until=6
[13:36:34.345]  - relaying element #6
[13:36:34.345] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.345] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.346] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.346]  length: 1 (resolved future 5)
[13:36:34.346] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.346] - nx: 6
[13:36:34.346] - relay: TRUE
[13:36:34.346] - stdout: TRUE
[13:36:34.346] - signal: TRUE
[13:36:34.346] - resignal: FALSE
[13:36:34.346] - force: TRUE
[13:36:34.346] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.347] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.347]  - until=6
[13:36:34.347] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.347] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.347] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.347]  length: 0 (resolved future 6)
[13:36:34.347] Relaying remaining futures
[13:36:34.347] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.347] - nx: 6
[13:36:34.347] - relay: TRUE
[13:36:34.347] - stdout: TRUE
[13:36:34.347] - signal: TRUE
[13:36:34.348] - resignal: FALSE
[13:36:34.348] - force: TRUE
[13:36:34.348] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.348] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:34.348] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.348] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.348] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.348] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x564a714c3a58> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:36:34.350] getGlobalsAndPackages() ...
[13:36:34.350] Searching for globals...
[13:36:34.351] 
[13:36:34.351] Searching for globals ... DONE
[13:36:34.351] - globals: [0] <none>
[13:36:34.351] getGlobalsAndPackages() ... DONE
[13:36:34.351] run() for ‘Future’ ...
[13:36:34.351] - state: ‘created’
[13:36:34.351] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.352] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.352]   - Field: ‘label’
[13:36:34.352]   - Field: ‘local’
[13:36:34.352]   - Field: ‘owner’
[13:36:34.352]   - Field: ‘envir’
[13:36:34.352]   - Field: ‘packages’
[13:36:34.353]   - Field: ‘gc’
[13:36:34.353]   - Field: ‘conditions’
[13:36:34.354]   - Field: ‘expr’
[13:36:34.354]   - Field: ‘uuid’
[13:36:34.354]   - Field: ‘seed’
[13:36:34.354]   - Field: ‘version’
[13:36:34.354]   - Field: ‘result’
[13:36:34.354]   - Field: ‘asynchronous’
[13:36:34.354]   - Field: ‘calls’
[13:36:34.354]   - Field: ‘globals’
[13:36:34.354]   - Field: ‘stdout’
[13:36:34.355]   - Field: ‘earlySignal’
[13:36:34.355]   - Field: ‘lazy’
[13:36:34.355]   - Field: ‘state’
[13:36:34.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.355] - Launch lazy future ...
[13:36:34.355] Packages needed by the future expression (n = 0): <none>
[13:36:34.355] Packages needed by future strategies (n = 0): <none>
[13:36:34.356] {
[13:36:34.356]     {
[13:36:34.356]         {
[13:36:34.356]             ...future.startTime <- base::Sys.time()
[13:36:34.356]             {
[13:36:34.356]                 {
[13:36:34.356]                   {
[13:36:34.356]                     base::local({
[13:36:34.356]                       has_future <- base::requireNamespace("future", 
[13:36:34.356]                         quietly = TRUE)
[13:36:34.356]                       if (has_future) {
[13:36:34.356]                         ns <- base::getNamespace("future")
[13:36:34.356]                         version <- ns[[".package"]][["version"]]
[13:36:34.356]                         if (is.null(version)) 
[13:36:34.356]                           version <- utils::packageVersion("future")
[13:36:34.356]                       }
[13:36:34.356]                       else {
[13:36:34.356]                         version <- NULL
[13:36:34.356]                       }
[13:36:34.356]                       if (!has_future || version < "1.8.0") {
[13:36:34.356]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.356]                           "", base::R.version$version.string), 
[13:36:34.356]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.356]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.356]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.356]                             "release", "version")], collapse = " "), 
[13:36:34.356]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.356]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.356]                           info)
[13:36:34.356]                         info <- base::paste(info, collapse = "; ")
[13:36:34.356]                         if (!has_future) {
[13:36:34.356]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.356]                             info)
[13:36:34.356]                         }
[13:36:34.356]                         else {
[13:36:34.356]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.356]                             info, version)
[13:36:34.356]                         }
[13:36:34.356]                         base::stop(msg)
[13:36:34.356]                       }
[13:36:34.356]                     })
[13:36:34.356]                   }
[13:36:34.356]                   ...future.strategy.old <- future::plan("list")
[13:36:34.356]                   options(future.plan = NULL)
[13:36:34.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.356]                 }
[13:36:34.356]                 ...future.workdir <- getwd()
[13:36:34.356]             }
[13:36:34.356]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.356]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.356]         }
[13:36:34.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.356]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.356]             base::names(...future.oldOptions))
[13:36:34.356]     }
[13:36:34.356]     if (FALSE) {
[13:36:34.356]     }
[13:36:34.356]     else {
[13:36:34.356]         if (TRUE) {
[13:36:34.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.356]                 open = "w")
[13:36:34.356]         }
[13:36:34.356]         else {
[13:36:34.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.356]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.356]         }
[13:36:34.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.356]             base::sink(type = "output", split = FALSE)
[13:36:34.356]             base::close(...future.stdout)
[13:36:34.356]         }, add = TRUE)
[13:36:34.356]     }
[13:36:34.356]     ...future.frame <- base::sys.nframe()
[13:36:34.356]     ...future.conditions <- base::list()
[13:36:34.356]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.356]     if (FALSE) {
[13:36:34.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.356]     }
[13:36:34.356]     ...future.result <- base::tryCatch({
[13:36:34.356]         base::withCallingHandlers({
[13:36:34.356]             ...future.value <- base::withVisible(base::local(2))
[13:36:34.356]             future::FutureResult(value = ...future.value$value, 
[13:36:34.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.356]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.356]                     ...future.globalenv.names))
[13:36:34.356]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.356]         }, condition = base::local({
[13:36:34.356]             c <- base::c
[13:36:34.356]             inherits <- base::inherits
[13:36:34.356]             invokeRestart <- base::invokeRestart
[13:36:34.356]             length <- base::length
[13:36:34.356]             list <- base::list
[13:36:34.356]             seq.int <- base::seq.int
[13:36:34.356]             signalCondition <- base::signalCondition
[13:36:34.356]             sys.calls <- base::sys.calls
[13:36:34.356]             `[[` <- base::`[[`
[13:36:34.356]             `+` <- base::`+`
[13:36:34.356]             `<<-` <- base::`<<-`
[13:36:34.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.356]                   3L)]
[13:36:34.356]             }
[13:36:34.356]             function(cond) {
[13:36:34.356]                 is_error <- inherits(cond, "error")
[13:36:34.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.356]                   NULL)
[13:36:34.356]                 if (is_error) {
[13:36:34.356]                   sessionInformation <- function() {
[13:36:34.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.356]                       search = base::search(), system = base::Sys.info())
[13:36:34.356]                   }
[13:36:34.356]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.356]                     cond$call), session = sessionInformation(), 
[13:36:34.356]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.356]                   signalCondition(cond)
[13:36:34.356]                 }
[13:36:34.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.356]                 "immediateCondition"))) {
[13:36:34.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.356]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.356]                   if (TRUE && !signal) {
[13:36:34.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.356]                     {
[13:36:34.356]                       inherits <- base::inherits
[13:36:34.356]                       invokeRestart <- base::invokeRestart
[13:36:34.356]                       is.null <- base::is.null
[13:36:34.356]                       muffled <- FALSE
[13:36:34.356]                       if (inherits(cond, "message")) {
[13:36:34.356]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.356]                         if (muffled) 
[13:36:34.356]                           invokeRestart("muffleMessage")
[13:36:34.356]                       }
[13:36:34.356]                       else if (inherits(cond, "warning")) {
[13:36:34.356]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.356]                         if (muffled) 
[13:36:34.356]                           invokeRestart("muffleWarning")
[13:36:34.356]                       }
[13:36:34.356]                       else if (inherits(cond, "condition")) {
[13:36:34.356]                         if (!is.null(pattern)) {
[13:36:34.356]                           computeRestarts <- base::computeRestarts
[13:36:34.356]                           grepl <- base::grepl
[13:36:34.356]                           restarts <- computeRestarts(cond)
[13:36:34.356]                           for (restart in restarts) {
[13:36:34.356]                             name <- restart$name
[13:36:34.356]                             if (is.null(name)) 
[13:36:34.356]                               next
[13:36:34.356]                             if (!grepl(pattern, name)) 
[13:36:34.356]                               next
[13:36:34.356]                             invokeRestart(restart)
[13:36:34.356]                             muffled <- TRUE
[13:36:34.356]                             break
[13:36:34.356]                           }
[13:36:34.356]                         }
[13:36:34.356]                       }
[13:36:34.356]                       invisible(muffled)
[13:36:34.356]                     }
[13:36:34.356]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.356]                   }
[13:36:34.356]                 }
[13:36:34.356]                 else {
[13:36:34.356]                   if (TRUE) {
[13:36:34.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.356]                     {
[13:36:34.356]                       inherits <- base::inherits
[13:36:34.356]                       invokeRestart <- base::invokeRestart
[13:36:34.356]                       is.null <- base::is.null
[13:36:34.356]                       muffled <- FALSE
[13:36:34.356]                       if (inherits(cond, "message")) {
[13:36:34.356]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.356]                         if (muffled) 
[13:36:34.356]                           invokeRestart("muffleMessage")
[13:36:34.356]                       }
[13:36:34.356]                       else if (inherits(cond, "warning")) {
[13:36:34.356]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.356]                         if (muffled) 
[13:36:34.356]                           invokeRestart("muffleWarning")
[13:36:34.356]                       }
[13:36:34.356]                       else if (inherits(cond, "condition")) {
[13:36:34.356]                         if (!is.null(pattern)) {
[13:36:34.356]                           computeRestarts <- base::computeRestarts
[13:36:34.356]                           grepl <- base::grepl
[13:36:34.356]                           restarts <- computeRestarts(cond)
[13:36:34.356]                           for (restart in restarts) {
[13:36:34.356]                             name <- restart$name
[13:36:34.356]                             if (is.null(name)) 
[13:36:34.356]                               next
[13:36:34.356]                             if (!grepl(pattern, name)) 
[13:36:34.356]                               next
[13:36:34.356]                             invokeRestart(restart)
[13:36:34.356]                             muffled <- TRUE
[13:36:34.356]                             break
[13:36:34.356]                           }
[13:36:34.356]                         }
[13:36:34.356]                       }
[13:36:34.356]                       invisible(muffled)
[13:36:34.356]                     }
[13:36:34.356]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.356]                   }
[13:36:34.356]                 }
[13:36:34.356]             }
[13:36:34.356]         }))
[13:36:34.356]     }, error = function(ex) {
[13:36:34.356]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.356]                 ...future.rng), started = ...future.startTime, 
[13:36:34.356]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.356]             version = "1.8"), class = "FutureResult")
[13:36:34.356]     }, finally = {
[13:36:34.356]         if (!identical(...future.workdir, getwd())) 
[13:36:34.356]             setwd(...future.workdir)
[13:36:34.356]         {
[13:36:34.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.356]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.356]             }
[13:36:34.356]             base::options(...future.oldOptions)
[13:36:34.356]             if (.Platform$OS.type == "windows") {
[13:36:34.356]                 old_names <- names(...future.oldEnvVars)
[13:36:34.356]                 envs <- base::Sys.getenv()
[13:36:34.356]                 names <- names(envs)
[13:36:34.356]                 common <- intersect(names, old_names)
[13:36:34.356]                 added <- setdiff(names, old_names)
[13:36:34.356]                 removed <- setdiff(old_names, names)
[13:36:34.356]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.356]                   envs[common]]
[13:36:34.356]                 NAMES <- toupper(changed)
[13:36:34.356]                 args <- list()
[13:36:34.356]                 for (kk in seq_along(NAMES)) {
[13:36:34.356]                   name <- changed[[kk]]
[13:36:34.356]                   NAME <- NAMES[[kk]]
[13:36:34.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.356]                     next
[13:36:34.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.356]                 }
[13:36:34.356]                 NAMES <- toupper(added)
[13:36:34.356]                 for (kk in seq_along(NAMES)) {
[13:36:34.356]                   name <- added[[kk]]
[13:36:34.356]                   NAME <- NAMES[[kk]]
[13:36:34.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.356]                     next
[13:36:34.356]                   args[[name]] <- ""
[13:36:34.356]                 }
[13:36:34.356]                 NAMES <- toupper(removed)
[13:36:34.356]                 for (kk in seq_along(NAMES)) {
[13:36:34.356]                   name <- removed[[kk]]
[13:36:34.356]                   NAME <- NAMES[[kk]]
[13:36:34.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.356]                     next
[13:36:34.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.356]                 }
[13:36:34.356]                 if (length(args) > 0) 
[13:36:34.356]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.356]             }
[13:36:34.356]             else {
[13:36:34.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.356]             }
[13:36:34.356]             {
[13:36:34.356]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.356]                   0L) {
[13:36:34.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.356]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.356]                   base::options(opts)
[13:36:34.356]                 }
[13:36:34.356]                 {
[13:36:34.356]                   {
[13:36:34.356]                     NULL
[13:36:34.356]                     RNGkind("Mersenne-Twister")
[13:36:34.356]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.356]                       inherits = FALSE)
[13:36:34.356]                   }
[13:36:34.356]                   options(future.plan = NULL)
[13:36:34.356]                   if (is.na(NA_character_)) 
[13:36:34.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.356]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.356]                     .init = FALSE)
[13:36:34.356]                 }
[13:36:34.356]             }
[13:36:34.356]         }
[13:36:34.356]     })
[13:36:34.356]     if (TRUE) {
[13:36:34.356]         base::sink(type = "output", split = FALSE)
[13:36:34.356]         if (TRUE) {
[13:36:34.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.356]         }
[13:36:34.356]         else {
[13:36:34.356]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.356]         }
[13:36:34.356]         base::close(...future.stdout)
[13:36:34.356]         ...future.stdout <- NULL
[13:36:34.356]     }
[13:36:34.356]     ...future.result$conditions <- ...future.conditions
[13:36:34.356]     ...future.result$finished <- base::Sys.time()
[13:36:34.356]     ...future.result
[13:36:34.356] }
[13:36:34.357] plan(): Setting new future strategy stack:
[13:36:34.357] List of future strategies:
[13:36:34.357] 1. sequential:
[13:36:34.357]    - args: function (..., envir = parent.frame())
[13:36:34.357]    - tweaked: FALSE
[13:36:34.357]    - call: NULL
[13:36:34.358] plan(): nbrOfWorkers() = 1
[13:36:34.358] plan(): Setting new future strategy stack:
[13:36:34.359] List of future strategies:
[13:36:34.359] 1. sequential:
[13:36:34.359]    - args: function (..., envir = parent.frame())
[13:36:34.359]    - tweaked: FALSE
[13:36:34.359]    - call: plan(strategy)
[13:36:34.359] plan(): nbrOfWorkers() = 1
[13:36:34.359] SequentialFuture started (and completed)
[13:36:34.359] - Launch lazy future ... done
[13:36:34.359] run() for ‘SequentialFuture’ ... done
[13:36:34.359] getGlobalsAndPackages() ...
[13:36:34.360] Searching for globals...
[13:36:34.360] 
[13:36:34.360] Searching for globals ... DONE
[13:36:34.360] - globals: [0] <none>
[13:36:34.360] getGlobalsAndPackages() ... DONE
[13:36:34.360] run() for ‘Future’ ...
[13:36:34.360] - state: ‘created’
[13:36:34.361] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.361] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.361]   - Field: ‘label’
[13:36:34.361]   - Field: ‘local’
[13:36:34.361]   - Field: ‘owner’
[13:36:34.361]   - Field: ‘envir’
[13:36:34.361]   - Field: ‘packages’
[13:36:34.361]   - Field: ‘gc’
[13:36:34.362]   - Field: ‘conditions’
[13:36:34.362]   - Field: ‘expr’
[13:36:34.362]   - Field: ‘uuid’
[13:36:34.362]   - Field: ‘seed’
[13:36:34.362]   - Field: ‘version’
[13:36:34.362]   - Field: ‘result’
[13:36:34.362]   - Field: ‘asynchronous’
[13:36:34.362]   - Field: ‘calls’
[13:36:34.362]   - Field: ‘globals’
[13:36:34.362]   - Field: ‘stdout’
[13:36:34.362]   - Field: ‘earlySignal’
[13:36:34.363]   - Field: ‘lazy’
[13:36:34.363]   - Field: ‘state’
[13:36:34.363] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.363] - Launch lazy future ...
[13:36:34.363] Packages needed by the future expression (n = 0): <none>
[13:36:34.363] Packages needed by future strategies (n = 0): <none>
[13:36:34.363] {
[13:36:34.363]     {
[13:36:34.363]         {
[13:36:34.363]             ...future.startTime <- base::Sys.time()
[13:36:34.363]             {
[13:36:34.363]                 {
[13:36:34.363]                   {
[13:36:34.363]                     base::local({
[13:36:34.363]                       has_future <- base::requireNamespace("future", 
[13:36:34.363]                         quietly = TRUE)
[13:36:34.363]                       if (has_future) {
[13:36:34.363]                         ns <- base::getNamespace("future")
[13:36:34.363]                         version <- ns[[".package"]][["version"]]
[13:36:34.363]                         if (is.null(version)) 
[13:36:34.363]                           version <- utils::packageVersion("future")
[13:36:34.363]                       }
[13:36:34.363]                       else {
[13:36:34.363]                         version <- NULL
[13:36:34.363]                       }
[13:36:34.363]                       if (!has_future || version < "1.8.0") {
[13:36:34.363]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.363]                           "", base::R.version$version.string), 
[13:36:34.363]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.363]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.363]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.363]                             "release", "version")], collapse = " "), 
[13:36:34.363]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.363]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.363]                           info)
[13:36:34.363]                         info <- base::paste(info, collapse = "; ")
[13:36:34.363]                         if (!has_future) {
[13:36:34.363]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.363]                             info)
[13:36:34.363]                         }
[13:36:34.363]                         else {
[13:36:34.363]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.363]                             info, version)
[13:36:34.363]                         }
[13:36:34.363]                         base::stop(msg)
[13:36:34.363]                       }
[13:36:34.363]                     })
[13:36:34.363]                   }
[13:36:34.363]                   ...future.strategy.old <- future::plan("list")
[13:36:34.363]                   options(future.plan = NULL)
[13:36:34.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.363]                 }
[13:36:34.363]                 ...future.workdir <- getwd()
[13:36:34.363]             }
[13:36:34.363]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.363]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.363]         }
[13:36:34.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.363]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.363]             base::names(...future.oldOptions))
[13:36:34.363]     }
[13:36:34.363]     if (FALSE) {
[13:36:34.363]     }
[13:36:34.363]     else {
[13:36:34.363]         if (TRUE) {
[13:36:34.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.363]                 open = "w")
[13:36:34.363]         }
[13:36:34.363]         else {
[13:36:34.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.363]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.363]         }
[13:36:34.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.363]             base::sink(type = "output", split = FALSE)
[13:36:34.363]             base::close(...future.stdout)
[13:36:34.363]         }, add = TRUE)
[13:36:34.363]     }
[13:36:34.363]     ...future.frame <- base::sys.nframe()
[13:36:34.363]     ...future.conditions <- base::list()
[13:36:34.363]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.363]     if (FALSE) {
[13:36:34.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.363]     }
[13:36:34.363]     ...future.result <- base::tryCatch({
[13:36:34.363]         base::withCallingHandlers({
[13:36:34.363]             ...future.value <- base::withVisible(base::local(NULL))
[13:36:34.363]             future::FutureResult(value = ...future.value$value, 
[13:36:34.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.363]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.363]                     ...future.globalenv.names))
[13:36:34.363]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.363]         }, condition = base::local({
[13:36:34.363]             c <- base::c
[13:36:34.363]             inherits <- base::inherits
[13:36:34.363]             invokeRestart <- base::invokeRestart
[13:36:34.363]             length <- base::length
[13:36:34.363]             list <- base::list
[13:36:34.363]             seq.int <- base::seq.int
[13:36:34.363]             signalCondition <- base::signalCondition
[13:36:34.363]             sys.calls <- base::sys.calls
[13:36:34.363]             `[[` <- base::`[[`
[13:36:34.363]             `+` <- base::`+`
[13:36:34.363]             `<<-` <- base::`<<-`
[13:36:34.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.363]                   3L)]
[13:36:34.363]             }
[13:36:34.363]             function(cond) {
[13:36:34.363]                 is_error <- inherits(cond, "error")
[13:36:34.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.363]                   NULL)
[13:36:34.363]                 if (is_error) {
[13:36:34.363]                   sessionInformation <- function() {
[13:36:34.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.363]                       search = base::search(), system = base::Sys.info())
[13:36:34.363]                   }
[13:36:34.363]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.363]                     cond$call), session = sessionInformation(), 
[13:36:34.363]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.363]                   signalCondition(cond)
[13:36:34.363]                 }
[13:36:34.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.363]                 "immediateCondition"))) {
[13:36:34.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.363]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.363]                   if (TRUE && !signal) {
[13:36:34.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.363]                     {
[13:36:34.363]                       inherits <- base::inherits
[13:36:34.363]                       invokeRestart <- base::invokeRestart
[13:36:34.363]                       is.null <- base::is.null
[13:36:34.363]                       muffled <- FALSE
[13:36:34.363]                       if (inherits(cond, "message")) {
[13:36:34.363]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.363]                         if (muffled) 
[13:36:34.363]                           invokeRestart("muffleMessage")
[13:36:34.363]                       }
[13:36:34.363]                       else if (inherits(cond, "warning")) {
[13:36:34.363]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.363]                         if (muffled) 
[13:36:34.363]                           invokeRestart("muffleWarning")
[13:36:34.363]                       }
[13:36:34.363]                       else if (inherits(cond, "condition")) {
[13:36:34.363]                         if (!is.null(pattern)) {
[13:36:34.363]                           computeRestarts <- base::computeRestarts
[13:36:34.363]                           grepl <- base::grepl
[13:36:34.363]                           restarts <- computeRestarts(cond)
[13:36:34.363]                           for (restart in restarts) {
[13:36:34.363]                             name <- restart$name
[13:36:34.363]                             if (is.null(name)) 
[13:36:34.363]                               next
[13:36:34.363]                             if (!grepl(pattern, name)) 
[13:36:34.363]                               next
[13:36:34.363]                             invokeRestart(restart)
[13:36:34.363]                             muffled <- TRUE
[13:36:34.363]                             break
[13:36:34.363]                           }
[13:36:34.363]                         }
[13:36:34.363]                       }
[13:36:34.363]                       invisible(muffled)
[13:36:34.363]                     }
[13:36:34.363]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.363]                   }
[13:36:34.363]                 }
[13:36:34.363]                 else {
[13:36:34.363]                   if (TRUE) {
[13:36:34.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.363]                     {
[13:36:34.363]                       inherits <- base::inherits
[13:36:34.363]                       invokeRestart <- base::invokeRestart
[13:36:34.363]                       is.null <- base::is.null
[13:36:34.363]                       muffled <- FALSE
[13:36:34.363]                       if (inherits(cond, "message")) {
[13:36:34.363]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.363]                         if (muffled) 
[13:36:34.363]                           invokeRestart("muffleMessage")
[13:36:34.363]                       }
[13:36:34.363]                       else if (inherits(cond, "warning")) {
[13:36:34.363]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.363]                         if (muffled) 
[13:36:34.363]                           invokeRestart("muffleWarning")
[13:36:34.363]                       }
[13:36:34.363]                       else if (inherits(cond, "condition")) {
[13:36:34.363]                         if (!is.null(pattern)) {
[13:36:34.363]                           computeRestarts <- base::computeRestarts
[13:36:34.363]                           grepl <- base::grepl
[13:36:34.363]                           restarts <- computeRestarts(cond)
[13:36:34.363]                           for (restart in restarts) {
[13:36:34.363]                             name <- restart$name
[13:36:34.363]                             if (is.null(name)) 
[13:36:34.363]                               next
[13:36:34.363]                             if (!grepl(pattern, name)) 
[13:36:34.363]                               next
[13:36:34.363]                             invokeRestart(restart)
[13:36:34.363]                             muffled <- TRUE
[13:36:34.363]                             break
[13:36:34.363]                           }
[13:36:34.363]                         }
[13:36:34.363]                       }
[13:36:34.363]                       invisible(muffled)
[13:36:34.363]                     }
[13:36:34.363]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.363]                   }
[13:36:34.363]                 }
[13:36:34.363]             }
[13:36:34.363]         }))
[13:36:34.363]     }, error = function(ex) {
[13:36:34.363]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.363]                 ...future.rng), started = ...future.startTime, 
[13:36:34.363]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.363]             version = "1.8"), class = "FutureResult")
[13:36:34.363]     }, finally = {
[13:36:34.363]         if (!identical(...future.workdir, getwd())) 
[13:36:34.363]             setwd(...future.workdir)
[13:36:34.363]         {
[13:36:34.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.363]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.363]             }
[13:36:34.363]             base::options(...future.oldOptions)
[13:36:34.363]             if (.Platform$OS.type == "windows") {
[13:36:34.363]                 old_names <- names(...future.oldEnvVars)
[13:36:34.363]                 envs <- base::Sys.getenv()
[13:36:34.363]                 names <- names(envs)
[13:36:34.363]                 common <- intersect(names, old_names)
[13:36:34.363]                 added <- setdiff(names, old_names)
[13:36:34.363]                 removed <- setdiff(old_names, names)
[13:36:34.363]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.363]                   envs[common]]
[13:36:34.363]                 NAMES <- toupper(changed)
[13:36:34.363]                 args <- list()
[13:36:34.363]                 for (kk in seq_along(NAMES)) {
[13:36:34.363]                   name <- changed[[kk]]
[13:36:34.363]                   NAME <- NAMES[[kk]]
[13:36:34.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.363]                     next
[13:36:34.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.363]                 }
[13:36:34.363]                 NAMES <- toupper(added)
[13:36:34.363]                 for (kk in seq_along(NAMES)) {
[13:36:34.363]                   name <- added[[kk]]
[13:36:34.363]                   NAME <- NAMES[[kk]]
[13:36:34.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.363]                     next
[13:36:34.363]                   args[[name]] <- ""
[13:36:34.363]                 }
[13:36:34.363]                 NAMES <- toupper(removed)
[13:36:34.363]                 for (kk in seq_along(NAMES)) {
[13:36:34.363]                   name <- removed[[kk]]
[13:36:34.363]                   NAME <- NAMES[[kk]]
[13:36:34.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.363]                     next
[13:36:34.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.363]                 }
[13:36:34.363]                 if (length(args) > 0) 
[13:36:34.363]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.363]             }
[13:36:34.363]             else {
[13:36:34.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.363]             }
[13:36:34.363]             {
[13:36:34.363]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.363]                   0L) {
[13:36:34.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.363]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.363]                   base::options(opts)
[13:36:34.363]                 }
[13:36:34.363]                 {
[13:36:34.363]                   {
[13:36:34.363]                     NULL
[13:36:34.363]                     RNGkind("Mersenne-Twister")
[13:36:34.363]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.363]                       inherits = FALSE)
[13:36:34.363]                   }
[13:36:34.363]                   options(future.plan = NULL)
[13:36:34.363]                   if (is.na(NA_character_)) 
[13:36:34.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.363]                     .init = FALSE)
[13:36:34.363]                 }
[13:36:34.363]             }
[13:36:34.363]         }
[13:36:34.363]     })
[13:36:34.363]     if (TRUE) {
[13:36:34.363]         base::sink(type = "output", split = FALSE)
[13:36:34.363]         if (TRUE) {
[13:36:34.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.363]         }
[13:36:34.363]         else {
[13:36:34.363]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.363]         }
[13:36:34.363]         base::close(...future.stdout)
[13:36:34.363]         ...future.stdout <- NULL
[13:36:34.363]     }
[13:36:34.363]     ...future.result$conditions <- ...future.conditions
[13:36:34.363]     ...future.result$finished <- base::Sys.time()
[13:36:34.363]     ...future.result
[13:36:34.363] }
[13:36:34.365] plan(): Setting new future strategy stack:
[13:36:34.365] List of future strategies:
[13:36:34.365] 1. sequential:
[13:36:34.365]    - args: function (..., envir = parent.frame())
[13:36:34.365]    - tweaked: FALSE
[13:36:34.365]    - call: NULL
[13:36:34.366] plan(): nbrOfWorkers() = 1
[13:36:34.366] plan(): Setting new future strategy stack:
[13:36:34.366] List of future strategies:
[13:36:34.366] 1. sequential:
[13:36:34.366]    - args: function (..., envir = parent.frame())
[13:36:34.366]    - tweaked: FALSE
[13:36:34.366]    - call: plan(strategy)
[13:36:34.367] plan(): nbrOfWorkers() = 1
[13:36:34.367] SequentialFuture started (and completed)
[13:36:34.367] - Launch lazy future ... done
[13:36:34.367] run() for ‘SequentialFuture’ ... done
[13:36:34.367] getGlobalsAndPackages() ...
[13:36:34.368] Searching for globals...
[13:36:34.368] - globals found: [1] ‘{’
[13:36:34.368] Searching for globals ... DONE
[13:36:34.368] Resolving globals: FALSE
[13:36:34.369] 
[13:36:34.369] 
[13:36:34.369] getGlobalsAndPackages() ... DONE
[13:36:34.369] run() for ‘Future’ ...
[13:36:34.369] - state: ‘created’
[13:36:34.369] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:34.369] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:34.370] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:34.370]   - Field: ‘label’
[13:36:34.370]   - Field: ‘local’
[13:36:34.370]   - Field: ‘owner’
[13:36:34.370]   - Field: ‘envir’
[13:36:34.370]   - Field: ‘packages’
[13:36:34.370]   - Field: ‘gc’
[13:36:34.370]   - Field: ‘conditions’
[13:36:34.370]   - Field: ‘expr’
[13:36:34.370]   - Field: ‘uuid’
[13:36:34.370]   - Field: ‘seed’
[13:36:34.371]   - Field: ‘version’
[13:36:34.371]   - Field: ‘result’
[13:36:34.371]   - Field: ‘asynchronous’
[13:36:34.371]   - Field: ‘calls’
[13:36:34.371]   - Field: ‘globals’
[13:36:34.371]   - Field: ‘stdout’
[13:36:34.371]   - Field: ‘earlySignal’
[13:36:34.371]   - Field: ‘lazy’
[13:36:34.371]   - Field: ‘state’
[13:36:34.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:34.371] - Launch lazy future ...
[13:36:34.372] Packages needed by the future expression (n = 0): <none>
[13:36:34.372] Packages needed by future strategies (n = 0): <none>
[13:36:34.372] {
[13:36:34.372]     {
[13:36:34.372]         {
[13:36:34.372]             ...future.startTime <- base::Sys.time()
[13:36:34.372]             {
[13:36:34.372]                 {
[13:36:34.372]                   {
[13:36:34.372]                     base::local({
[13:36:34.372]                       has_future <- base::requireNamespace("future", 
[13:36:34.372]                         quietly = TRUE)
[13:36:34.372]                       if (has_future) {
[13:36:34.372]                         ns <- base::getNamespace("future")
[13:36:34.372]                         version <- ns[[".package"]][["version"]]
[13:36:34.372]                         if (is.null(version)) 
[13:36:34.372]                           version <- utils::packageVersion("future")
[13:36:34.372]                       }
[13:36:34.372]                       else {
[13:36:34.372]                         version <- NULL
[13:36:34.372]                       }
[13:36:34.372]                       if (!has_future || version < "1.8.0") {
[13:36:34.372]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.372]                           "", base::R.version$version.string), 
[13:36:34.372]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:34.372]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.372]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.372]                             "release", "version")], collapse = " "), 
[13:36:34.372]                           hostname = base::Sys.info()[["nodename"]])
[13:36:34.372]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.372]                           info)
[13:36:34.372]                         info <- base::paste(info, collapse = "; ")
[13:36:34.372]                         if (!has_future) {
[13:36:34.372]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.372]                             info)
[13:36:34.372]                         }
[13:36:34.372]                         else {
[13:36:34.372]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.372]                             info, version)
[13:36:34.372]                         }
[13:36:34.372]                         base::stop(msg)
[13:36:34.372]                       }
[13:36:34.372]                     })
[13:36:34.372]                   }
[13:36:34.372]                   ...future.strategy.old <- future::plan("list")
[13:36:34.372]                   options(future.plan = NULL)
[13:36:34.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.372]                 }
[13:36:34.372]                 ...future.workdir <- getwd()
[13:36:34.372]             }
[13:36:34.372]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.372]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.372]         }
[13:36:34.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.372]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.372]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.372]             base::names(...future.oldOptions))
[13:36:34.372]     }
[13:36:34.372]     if (FALSE) {
[13:36:34.372]     }
[13:36:34.372]     else {
[13:36:34.372]         if (TRUE) {
[13:36:34.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.372]                 open = "w")
[13:36:34.372]         }
[13:36:34.372]         else {
[13:36:34.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.372]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.372]         }
[13:36:34.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.372]             base::sink(type = "output", split = FALSE)
[13:36:34.372]             base::close(...future.stdout)
[13:36:34.372]         }, add = TRUE)
[13:36:34.372]     }
[13:36:34.372]     ...future.frame <- base::sys.nframe()
[13:36:34.372]     ...future.conditions <- base::list()
[13:36:34.372]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.372]     if (FALSE) {
[13:36:34.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.372]     }
[13:36:34.372]     ...future.result <- base::tryCatch({
[13:36:34.372]         base::withCallingHandlers({
[13:36:34.372]             ...future.value <- base::withVisible(base::local({
[13:36:34.372]                 4
[13:36:34.372]             }))
[13:36:34.372]             future::FutureResult(value = ...future.value$value, 
[13:36:34.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.372]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.372]                     ...future.globalenv.names))
[13:36:34.372]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.372]         }, condition = base::local({
[13:36:34.372]             c <- base::c
[13:36:34.372]             inherits <- base::inherits
[13:36:34.372]             invokeRestart <- base::invokeRestart
[13:36:34.372]             length <- base::length
[13:36:34.372]             list <- base::list
[13:36:34.372]             seq.int <- base::seq.int
[13:36:34.372]             signalCondition <- base::signalCondition
[13:36:34.372]             sys.calls <- base::sys.calls
[13:36:34.372]             `[[` <- base::`[[`
[13:36:34.372]             `+` <- base::`+`
[13:36:34.372]             `<<-` <- base::`<<-`
[13:36:34.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.372]                   3L)]
[13:36:34.372]             }
[13:36:34.372]             function(cond) {
[13:36:34.372]                 is_error <- inherits(cond, "error")
[13:36:34.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.372]                   NULL)
[13:36:34.372]                 if (is_error) {
[13:36:34.372]                   sessionInformation <- function() {
[13:36:34.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.372]                       search = base::search(), system = base::Sys.info())
[13:36:34.372]                   }
[13:36:34.372]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.372]                     cond$call), session = sessionInformation(), 
[13:36:34.372]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.372]                   signalCondition(cond)
[13:36:34.372]                 }
[13:36:34.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.372]                 "immediateCondition"))) {
[13:36:34.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.372]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.372]                   if (TRUE && !signal) {
[13:36:34.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.372]                     {
[13:36:34.372]                       inherits <- base::inherits
[13:36:34.372]                       invokeRestart <- base::invokeRestart
[13:36:34.372]                       is.null <- base::is.null
[13:36:34.372]                       muffled <- FALSE
[13:36:34.372]                       if (inherits(cond, "message")) {
[13:36:34.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.372]                         if (muffled) 
[13:36:34.372]                           invokeRestart("muffleMessage")
[13:36:34.372]                       }
[13:36:34.372]                       else if (inherits(cond, "warning")) {
[13:36:34.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.372]                         if (muffled) 
[13:36:34.372]                           invokeRestart("muffleWarning")
[13:36:34.372]                       }
[13:36:34.372]                       else if (inherits(cond, "condition")) {
[13:36:34.372]                         if (!is.null(pattern)) {
[13:36:34.372]                           computeRestarts <- base::computeRestarts
[13:36:34.372]                           grepl <- base::grepl
[13:36:34.372]                           restarts <- computeRestarts(cond)
[13:36:34.372]                           for (restart in restarts) {
[13:36:34.372]                             name <- restart$name
[13:36:34.372]                             if (is.null(name)) 
[13:36:34.372]                               next
[13:36:34.372]                             if (!grepl(pattern, name)) 
[13:36:34.372]                               next
[13:36:34.372]                             invokeRestart(restart)
[13:36:34.372]                             muffled <- TRUE
[13:36:34.372]                             break
[13:36:34.372]                           }
[13:36:34.372]                         }
[13:36:34.372]                       }
[13:36:34.372]                       invisible(muffled)
[13:36:34.372]                     }
[13:36:34.372]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.372]                   }
[13:36:34.372]                 }
[13:36:34.372]                 else {
[13:36:34.372]                   if (TRUE) {
[13:36:34.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.372]                     {
[13:36:34.372]                       inherits <- base::inherits
[13:36:34.372]                       invokeRestart <- base::invokeRestart
[13:36:34.372]                       is.null <- base::is.null
[13:36:34.372]                       muffled <- FALSE
[13:36:34.372]                       if (inherits(cond, "message")) {
[13:36:34.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.372]                         if (muffled) 
[13:36:34.372]                           invokeRestart("muffleMessage")
[13:36:34.372]                       }
[13:36:34.372]                       else if (inherits(cond, "warning")) {
[13:36:34.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.372]                         if (muffled) 
[13:36:34.372]                           invokeRestart("muffleWarning")
[13:36:34.372]                       }
[13:36:34.372]                       else if (inherits(cond, "condition")) {
[13:36:34.372]                         if (!is.null(pattern)) {
[13:36:34.372]                           computeRestarts <- base::computeRestarts
[13:36:34.372]                           grepl <- base::grepl
[13:36:34.372]                           restarts <- computeRestarts(cond)
[13:36:34.372]                           for (restart in restarts) {
[13:36:34.372]                             name <- restart$name
[13:36:34.372]                             if (is.null(name)) 
[13:36:34.372]                               next
[13:36:34.372]                             if (!grepl(pattern, name)) 
[13:36:34.372]                               next
[13:36:34.372]                             invokeRestart(restart)
[13:36:34.372]                             muffled <- TRUE
[13:36:34.372]                             break
[13:36:34.372]                           }
[13:36:34.372]                         }
[13:36:34.372]                       }
[13:36:34.372]                       invisible(muffled)
[13:36:34.372]                     }
[13:36:34.372]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.372]                   }
[13:36:34.372]                 }
[13:36:34.372]             }
[13:36:34.372]         }))
[13:36:34.372]     }, error = function(ex) {
[13:36:34.372]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.372]                 ...future.rng), started = ...future.startTime, 
[13:36:34.372]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.372]             version = "1.8"), class = "FutureResult")
[13:36:34.372]     }, finally = {
[13:36:34.372]         if (!identical(...future.workdir, getwd())) 
[13:36:34.372]             setwd(...future.workdir)
[13:36:34.372]         {
[13:36:34.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.372]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.372]             }
[13:36:34.372]             base::options(...future.oldOptions)
[13:36:34.372]             if (.Platform$OS.type == "windows") {
[13:36:34.372]                 old_names <- names(...future.oldEnvVars)
[13:36:34.372]                 envs <- base::Sys.getenv()
[13:36:34.372]                 names <- names(envs)
[13:36:34.372]                 common <- intersect(names, old_names)
[13:36:34.372]                 added <- setdiff(names, old_names)
[13:36:34.372]                 removed <- setdiff(old_names, names)
[13:36:34.372]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.372]                   envs[common]]
[13:36:34.372]                 NAMES <- toupper(changed)
[13:36:34.372]                 args <- list()
[13:36:34.372]                 for (kk in seq_along(NAMES)) {
[13:36:34.372]                   name <- changed[[kk]]
[13:36:34.372]                   NAME <- NAMES[[kk]]
[13:36:34.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.372]                     next
[13:36:34.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.372]                 }
[13:36:34.372]                 NAMES <- toupper(added)
[13:36:34.372]                 for (kk in seq_along(NAMES)) {
[13:36:34.372]                   name <- added[[kk]]
[13:36:34.372]                   NAME <- NAMES[[kk]]
[13:36:34.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.372]                     next
[13:36:34.372]                   args[[name]] <- ""
[13:36:34.372]                 }
[13:36:34.372]                 NAMES <- toupper(removed)
[13:36:34.372]                 for (kk in seq_along(NAMES)) {
[13:36:34.372]                   name <- removed[[kk]]
[13:36:34.372]                   NAME <- NAMES[[kk]]
[13:36:34.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.372]                     next
[13:36:34.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.372]                 }
[13:36:34.372]                 if (length(args) > 0) 
[13:36:34.372]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.372]             }
[13:36:34.372]             else {
[13:36:34.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.372]             }
[13:36:34.372]             {
[13:36:34.372]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.372]                   0L) {
[13:36:34.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.372]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.372]                   base::options(opts)
[13:36:34.372]                 }
[13:36:34.372]                 {
[13:36:34.372]                   {
[13:36:34.372]                     NULL
[13:36:34.372]                     RNGkind("Mersenne-Twister")
[13:36:34.372]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:34.372]                       inherits = FALSE)
[13:36:34.372]                   }
[13:36:34.372]                   options(future.plan = NULL)
[13:36:34.372]                   if (is.na(NA_character_)) 
[13:36:34.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.372]                     .init = FALSE)
[13:36:34.372]                 }
[13:36:34.372]             }
[13:36:34.372]         }
[13:36:34.372]     })
[13:36:34.372]     if (TRUE) {
[13:36:34.372]         base::sink(type = "output", split = FALSE)
[13:36:34.372]         if (TRUE) {
[13:36:34.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.372]         }
[13:36:34.372]         else {
[13:36:34.372]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.372]         }
[13:36:34.372]         base::close(...future.stdout)
[13:36:34.372]         ...future.stdout <- NULL
[13:36:34.372]     }
[13:36:34.372]     ...future.result$conditions <- ...future.conditions
[13:36:34.372]     ...future.result$finished <- base::Sys.time()
[13:36:34.372]     ...future.result
[13:36:34.372] }
[13:36:34.374] plan(): Setting new future strategy stack:
[13:36:34.374] List of future strategies:
[13:36:34.374] 1. sequential:
[13:36:34.374]    - args: function (..., envir = parent.frame())
[13:36:34.374]    - tweaked: FALSE
[13:36:34.374]    - call: NULL
[13:36:34.374] plan(): nbrOfWorkers() = 1
[13:36:34.375] plan(): Setting new future strategy stack:
[13:36:34.375] List of future strategies:
[13:36:34.375] 1. sequential:
[13:36:34.375]    - args: function (..., envir = parent.frame())
[13:36:34.375]    - tweaked: FALSE
[13:36:34.375]    - call: plan(strategy)
[13:36:34.375] plan(): nbrOfWorkers() = 1
[13:36:34.376] SequentialFuture started (and completed)
[13:36:34.376] - Launch lazy future ... done
[13:36:34.376] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a736e3480> 
Classes 'listenv', 'environment' <environment: 0x564a7338a9c8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:34.380] resolved() for ‘SequentialFuture’ ...
[13:36:34.380] - state: ‘finished’
[13:36:34.380] - run: TRUE
[13:36:34.380] - result: ‘FutureResult’
[13:36:34.380] resolved() for ‘SequentialFuture’ ... done
[13:36:34.380] resolved() for ‘SequentialFuture’ ...
[13:36:34.380] - state: ‘finished’
[13:36:34.380] - run: TRUE
[13:36:34.380] - result: ‘FutureResult’
[13:36:34.380] resolved() for ‘SequentialFuture’ ... done
[13:36:34.381] resolved() for ‘SequentialFuture’ ...
[13:36:34.381] - state: ‘finished’
[13:36:34.381] - run: TRUE
[13:36:34.381] - result: ‘FutureResult’
[13:36:34.381] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:34.385] resolve() on list environment ...
[13:36:34.385]  recursive: 0
[13:36:34.386]  length: 6
[13:36:34.386]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:34.386] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.386] - nx: 6
[13:36:34.386] - relay: TRUE
[13:36:34.387] - stdout: TRUE
[13:36:34.387] - signal: TRUE
[13:36:34.387] - resignal: FALSE
[13:36:34.387] - force: TRUE
[13:36:34.387] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.387] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.387]  - until=2
[13:36:34.387]  - relaying element #2
[13:36:34.387] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.387] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.387] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.387]  length: 5 (resolved future 1)
[13:36:34.388] resolved() for ‘SequentialFuture’ ...
[13:36:34.388] - state: ‘finished’
[13:36:34.388] - run: TRUE
[13:36:34.388] - result: ‘FutureResult’
[13:36:34.388] resolved() for ‘SequentialFuture’ ... done
[13:36:34.388] Future #2
[13:36:34.388] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:36:34.388] - nx: 6
[13:36:34.388] - relay: TRUE
[13:36:34.388] - stdout: TRUE
[13:36:34.389] - signal: TRUE
[13:36:34.389] - resignal: FALSE
[13:36:34.389] - force: TRUE
[13:36:34.389] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.389] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.389]  - until=2
[13:36:34.389]  - relaying element #2
[13:36:34.389] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.389] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.389] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:36:34.389]  length: 4 (resolved future 2)
[13:36:34.390] resolved() for ‘SequentialFuture’ ...
[13:36:34.390] - state: ‘finished’
[13:36:34.390] - run: TRUE
[13:36:34.390] - result: ‘FutureResult’
[13:36:34.390] resolved() for ‘SequentialFuture’ ... done
[13:36:34.390] Future #3
[13:36:34.390] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:36:34.390] - nx: 6
[13:36:34.390] - relay: TRUE
[13:36:34.390] - stdout: TRUE
[13:36:34.391] - signal: TRUE
[13:36:34.391] - resignal: FALSE
[13:36:34.391] - force: TRUE
[13:36:34.391] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.391] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.391]  - until=3
[13:36:34.391]  - relaying element #3
[13:36:34.391] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.391] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.391] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:36:34.391]  length: 3 (resolved future 3)
[13:36:34.392] resolved() for ‘SequentialFuture’ ...
[13:36:34.392] - state: ‘finished’
[13:36:34.392] - run: TRUE
[13:36:34.392] - result: ‘FutureResult’
[13:36:34.392] resolved() for ‘SequentialFuture’ ... done
[13:36:34.392] Future #4
[13:36:34.392] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:36:34.392] - nx: 6
[13:36:34.392] - relay: TRUE
[13:36:34.392] - stdout: TRUE
[13:36:34.392] - signal: TRUE
[13:36:34.393] - resignal: FALSE
[13:36:34.393] - force: TRUE
[13:36:34.393] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.393] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.393]  - until=4
[13:36:34.393]  - relaying element #4
[13:36:34.393] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.393] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.393] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:36:34.393]  length: 2 (resolved future 4)
[13:36:34.393] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.394] - nx: 6
[13:36:34.394] - relay: TRUE
[13:36:34.394] - stdout: TRUE
[13:36:34.394] - signal: TRUE
[13:36:34.394] - resignal: FALSE
[13:36:34.394] - force: TRUE
[13:36:34.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.394] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.394]  - until=6
[13:36:34.394]  - relaying element #6
[13:36:34.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.394] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.395] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.395]  length: 1 (resolved future 5)
[13:36:34.395] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.395] - nx: 6
[13:36:34.395] - relay: TRUE
[13:36:34.395] - stdout: TRUE
[13:36:34.395] - signal: TRUE
[13:36:34.395] - resignal: FALSE
[13:36:34.395] - force: TRUE
[13:36:34.395] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.395] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.395]  - until=6
[13:36:34.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.396] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.396] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.396]  length: 0 (resolved future 6)
[13:36:34.396] Relaying remaining futures
[13:36:34.396] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.396] - nx: 6
[13:36:34.396] - relay: TRUE
[13:36:34.396] - stdout: TRUE
[13:36:34.396] - signal: TRUE
[13:36:34.396] - resignal: FALSE
[13:36:34.396] - force: TRUE
[13:36:34.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.397] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:34.397] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.397] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.397] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.397] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x564a71ef5ed8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[13:36:34.400] plan(): Setting new future strategy stack:
[13:36:34.400] List of future strategies:
[13:36:34.400] 1. multicore:
[13:36:34.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.400]    - tweaked: FALSE
[13:36:34.400]    - call: plan(strategy)
[13:36:34.404] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:36:34.404] getGlobalsAndPackages() ...
[13:36:34.404] Searching for globals...
[13:36:34.404] 
[13:36:34.404] Searching for globals ... DONE
[13:36:34.404] - globals: [0] <none>
[13:36:34.404] getGlobalsAndPackages() ... DONE
[13:36:34.405] run() for ‘Future’ ...
[13:36:34.405] - state: ‘created’
[13:36:34.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.409]   - Field: ‘label’
[13:36:34.409]   - Field: ‘local’
[13:36:34.409]   - Field: ‘owner’
[13:36:34.409]   - Field: ‘envir’
[13:36:34.409]   - Field: ‘workers’
[13:36:34.409]   - Field: ‘packages’
[13:36:34.410]   - Field: ‘gc’
[13:36:34.410]   - Field: ‘job’
[13:36:34.411]   - Field: ‘conditions’
[13:36:34.411]   - Field: ‘expr’
[13:36:34.411]   - Field: ‘uuid’
[13:36:34.411]   - Field: ‘seed’
[13:36:34.411]   - Field: ‘version’
[13:36:34.411]   - Field: ‘result’
[13:36:34.411]   - Field: ‘asynchronous’
[13:36:34.411]   - Field: ‘calls’
[13:36:34.411]   - Field: ‘globals’
[13:36:34.411]   - Field: ‘stdout’
[13:36:34.412]   - Field: ‘earlySignal’
[13:36:34.412]   - Field: ‘lazy’
[13:36:34.412]   - Field: ‘state’
[13:36:34.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.412] - Launch lazy future ...
[13:36:34.413] Packages needed by the future expression (n = 0): <none>
[13:36:34.413] Packages needed by future strategies (n = 0): <none>
[13:36:34.413] {
[13:36:34.413]     {
[13:36:34.413]         {
[13:36:34.413]             ...future.startTime <- base::Sys.time()
[13:36:34.413]             {
[13:36:34.413]                 {
[13:36:34.413]                   {
[13:36:34.413]                     {
[13:36:34.413]                       base::local({
[13:36:34.413]                         has_future <- base::requireNamespace("future", 
[13:36:34.413]                           quietly = TRUE)
[13:36:34.413]                         if (has_future) {
[13:36:34.413]                           ns <- base::getNamespace("future")
[13:36:34.413]                           version <- ns[[".package"]][["version"]]
[13:36:34.413]                           if (is.null(version)) 
[13:36:34.413]                             version <- utils::packageVersion("future")
[13:36:34.413]                         }
[13:36:34.413]                         else {
[13:36:34.413]                           version <- NULL
[13:36:34.413]                         }
[13:36:34.413]                         if (!has_future || version < "1.8.0") {
[13:36:34.413]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.413]                             "", base::R.version$version.string), 
[13:36:34.413]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.413]                               "release", "version")], collapse = " "), 
[13:36:34.413]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.413]                             info)
[13:36:34.413]                           info <- base::paste(info, collapse = "; ")
[13:36:34.413]                           if (!has_future) {
[13:36:34.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.413]                               info)
[13:36:34.413]                           }
[13:36:34.413]                           else {
[13:36:34.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.413]                               info, version)
[13:36:34.413]                           }
[13:36:34.413]                           base::stop(msg)
[13:36:34.413]                         }
[13:36:34.413]                       })
[13:36:34.413]                     }
[13:36:34.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.413]                     base::options(mc.cores = 1L)
[13:36:34.413]                   }
[13:36:34.413]                   ...future.strategy.old <- future::plan("list")
[13:36:34.413]                   options(future.plan = NULL)
[13:36:34.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.413]                 }
[13:36:34.413]                 ...future.workdir <- getwd()
[13:36:34.413]             }
[13:36:34.413]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.413]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.413]         }
[13:36:34.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.413]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.413]             base::names(...future.oldOptions))
[13:36:34.413]     }
[13:36:34.413]     if (FALSE) {
[13:36:34.413]     }
[13:36:34.413]     else {
[13:36:34.413]         if (TRUE) {
[13:36:34.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.413]                 open = "w")
[13:36:34.413]         }
[13:36:34.413]         else {
[13:36:34.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.413]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.413]         }
[13:36:34.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.413]             base::sink(type = "output", split = FALSE)
[13:36:34.413]             base::close(...future.stdout)
[13:36:34.413]         }, add = TRUE)
[13:36:34.413]     }
[13:36:34.413]     ...future.frame <- base::sys.nframe()
[13:36:34.413]     ...future.conditions <- base::list()
[13:36:34.413]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.413]     if (FALSE) {
[13:36:34.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.413]     }
[13:36:34.413]     ...future.result <- base::tryCatch({
[13:36:34.413]         base::withCallingHandlers({
[13:36:34.413]             ...future.value <- base::withVisible(base::local({
[13:36:34.413]                 withCallingHandlers({
[13:36:34.413]                   2
[13:36:34.413]                 }, immediateCondition = function(cond) {
[13:36:34.413]                   save_rds <- function (object, pathname, ...) 
[13:36:34.413]                   {
[13:36:34.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.413]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.413]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.413]                         fi_tmp[["mtime"]])
[13:36:34.413]                     }
[13:36:34.413]                     tryCatch({
[13:36:34.413]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.413]                     }, error = function(ex) {
[13:36:34.413]                       msg <- conditionMessage(ex)
[13:36:34.413]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.413]                         fi_tmp[["mtime"]], msg)
[13:36:34.413]                       ex$message <- msg
[13:36:34.413]                       stop(ex)
[13:36:34.413]                     })
[13:36:34.413]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.413]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.413]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.413]                       fi <- file.info(pathname)
[13:36:34.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.413]                         fi[["size"]], fi[["mtime"]])
[13:36:34.413]                       stop(msg)
[13:36:34.413]                     }
[13:36:34.413]                     invisible(pathname)
[13:36:34.413]                   }
[13:36:34.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.413]                     rootPath = tempdir()) 
[13:36:34.413]                   {
[13:36:34.413]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.413]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.413]                       tmpdir = path, fileext = ".rds")
[13:36:34.413]                     save_rds(obj, file)
[13:36:34.413]                   }
[13:36:34.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.413]                   {
[13:36:34.413]                     inherits <- base::inherits
[13:36:34.413]                     invokeRestart <- base::invokeRestart
[13:36:34.413]                     is.null <- base::is.null
[13:36:34.413]                     muffled <- FALSE
[13:36:34.413]                     if (inherits(cond, "message")) {
[13:36:34.413]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.413]                       if (muffled) 
[13:36:34.413]                         invokeRestart("muffleMessage")
[13:36:34.413]                     }
[13:36:34.413]                     else if (inherits(cond, "warning")) {
[13:36:34.413]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.413]                       if (muffled) 
[13:36:34.413]                         invokeRestart("muffleWarning")
[13:36:34.413]                     }
[13:36:34.413]                     else if (inherits(cond, "condition")) {
[13:36:34.413]                       if (!is.null(pattern)) {
[13:36:34.413]                         computeRestarts <- base::computeRestarts
[13:36:34.413]                         grepl <- base::grepl
[13:36:34.413]                         restarts <- computeRestarts(cond)
[13:36:34.413]                         for (restart in restarts) {
[13:36:34.413]                           name <- restart$name
[13:36:34.413]                           if (is.null(name)) 
[13:36:34.413]                             next
[13:36:34.413]                           if (!grepl(pattern, name)) 
[13:36:34.413]                             next
[13:36:34.413]                           invokeRestart(restart)
[13:36:34.413]                           muffled <- TRUE
[13:36:34.413]                           break
[13:36:34.413]                         }
[13:36:34.413]                       }
[13:36:34.413]                     }
[13:36:34.413]                     invisible(muffled)
[13:36:34.413]                   }
[13:36:34.413]                   muffleCondition(cond)
[13:36:34.413]                 })
[13:36:34.413]             }))
[13:36:34.413]             future::FutureResult(value = ...future.value$value, 
[13:36:34.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.413]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.413]                     ...future.globalenv.names))
[13:36:34.413]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.413]         }, condition = base::local({
[13:36:34.413]             c <- base::c
[13:36:34.413]             inherits <- base::inherits
[13:36:34.413]             invokeRestart <- base::invokeRestart
[13:36:34.413]             length <- base::length
[13:36:34.413]             list <- base::list
[13:36:34.413]             seq.int <- base::seq.int
[13:36:34.413]             signalCondition <- base::signalCondition
[13:36:34.413]             sys.calls <- base::sys.calls
[13:36:34.413]             `[[` <- base::`[[`
[13:36:34.413]             `+` <- base::`+`
[13:36:34.413]             `<<-` <- base::`<<-`
[13:36:34.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.413]                   3L)]
[13:36:34.413]             }
[13:36:34.413]             function(cond) {
[13:36:34.413]                 is_error <- inherits(cond, "error")
[13:36:34.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.413]                   NULL)
[13:36:34.413]                 if (is_error) {
[13:36:34.413]                   sessionInformation <- function() {
[13:36:34.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.413]                       search = base::search(), system = base::Sys.info())
[13:36:34.413]                   }
[13:36:34.413]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.413]                     cond$call), session = sessionInformation(), 
[13:36:34.413]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.413]                   signalCondition(cond)
[13:36:34.413]                 }
[13:36:34.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.413]                 "immediateCondition"))) {
[13:36:34.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.413]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.413]                   if (TRUE && !signal) {
[13:36:34.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.413]                     {
[13:36:34.413]                       inherits <- base::inherits
[13:36:34.413]                       invokeRestart <- base::invokeRestart
[13:36:34.413]                       is.null <- base::is.null
[13:36:34.413]                       muffled <- FALSE
[13:36:34.413]                       if (inherits(cond, "message")) {
[13:36:34.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.413]                         if (muffled) 
[13:36:34.413]                           invokeRestart("muffleMessage")
[13:36:34.413]                       }
[13:36:34.413]                       else if (inherits(cond, "warning")) {
[13:36:34.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.413]                         if (muffled) 
[13:36:34.413]                           invokeRestart("muffleWarning")
[13:36:34.413]                       }
[13:36:34.413]                       else if (inherits(cond, "condition")) {
[13:36:34.413]                         if (!is.null(pattern)) {
[13:36:34.413]                           computeRestarts <- base::computeRestarts
[13:36:34.413]                           grepl <- base::grepl
[13:36:34.413]                           restarts <- computeRestarts(cond)
[13:36:34.413]                           for (restart in restarts) {
[13:36:34.413]                             name <- restart$name
[13:36:34.413]                             if (is.null(name)) 
[13:36:34.413]                               next
[13:36:34.413]                             if (!grepl(pattern, name)) 
[13:36:34.413]                               next
[13:36:34.413]                             invokeRestart(restart)
[13:36:34.413]                             muffled <- TRUE
[13:36:34.413]                             break
[13:36:34.413]                           }
[13:36:34.413]                         }
[13:36:34.413]                       }
[13:36:34.413]                       invisible(muffled)
[13:36:34.413]                     }
[13:36:34.413]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.413]                   }
[13:36:34.413]                 }
[13:36:34.413]                 else {
[13:36:34.413]                   if (TRUE) {
[13:36:34.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.413]                     {
[13:36:34.413]                       inherits <- base::inherits
[13:36:34.413]                       invokeRestart <- base::invokeRestart
[13:36:34.413]                       is.null <- base::is.null
[13:36:34.413]                       muffled <- FALSE
[13:36:34.413]                       if (inherits(cond, "message")) {
[13:36:34.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.413]                         if (muffled) 
[13:36:34.413]                           invokeRestart("muffleMessage")
[13:36:34.413]                       }
[13:36:34.413]                       else if (inherits(cond, "warning")) {
[13:36:34.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.413]                         if (muffled) 
[13:36:34.413]                           invokeRestart("muffleWarning")
[13:36:34.413]                       }
[13:36:34.413]                       else if (inherits(cond, "condition")) {
[13:36:34.413]                         if (!is.null(pattern)) {
[13:36:34.413]                           computeRestarts <- base::computeRestarts
[13:36:34.413]                           grepl <- base::grepl
[13:36:34.413]                           restarts <- computeRestarts(cond)
[13:36:34.413]                           for (restart in restarts) {
[13:36:34.413]                             name <- restart$name
[13:36:34.413]                             if (is.null(name)) 
[13:36:34.413]                               next
[13:36:34.413]                             if (!grepl(pattern, name)) 
[13:36:34.413]                               next
[13:36:34.413]                             invokeRestart(restart)
[13:36:34.413]                             muffled <- TRUE
[13:36:34.413]                             break
[13:36:34.413]                           }
[13:36:34.413]                         }
[13:36:34.413]                       }
[13:36:34.413]                       invisible(muffled)
[13:36:34.413]                     }
[13:36:34.413]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.413]                   }
[13:36:34.413]                 }
[13:36:34.413]             }
[13:36:34.413]         }))
[13:36:34.413]     }, error = function(ex) {
[13:36:34.413]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.413]                 ...future.rng), started = ...future.startTime, 
[13:36:34.413]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.413]             version = "1.8"), class = "FutureResult")
[13:36:34.413]     }, finally = {
[13:36:34.413]         if (!identical(...future.workdir, getwd())) 
[13:36:34.413]             setwd(...future.workdir)
[13:36:34.413]         {
[13:36:34.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.413]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.413]             }
[13:36:34.413]             base::options(...future.oldOptions)
[13:36:34.413]             if (.Platform$OS.type == "windows") {
[13:36:34.413]                 old_names <- names(...future.oldEnvVars)
[13:36:34.413]                 envs <- base::Sys.getenv()
[13:36:34.413]                 names <- names(envs)
[13:36:34.413]                 common <- intersect(names, old_names)
[13:36:34.413]                 added <- setdiff(names, old_names)
[13:36:34.413]                 removed <- setdiff(old_names, names)
[13:36:34.413]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.413]                   envs[common]]
[13:36:34.413]                 NAMES <- toupper(changed)
[13:36:34.413]                 args <- list()
[13:36:34.413]                 for (kk in seq_along(NAMES)) {
[13:36:34.413]                   name <- changed[[kk]]
[13:36:34.413]                   NAME <- NAMES[[kk]]
[13:36:34.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.413]                     next
[13:36:34.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.413]                 }
[13:36:34.413]                 NAMES <- toupper(added)
[13:36:34.413]                 for (kk in seq_along(NAMES)) {
[13:36:34.413]                   name <- added[[kk]]
[13:36:34.413]                   NAME <- NAMES[[kk]]
[13:36:34.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.413]                     next
[13:36:34.413]                   args[[name]] <- ""
[13:36:34.413]                 }
[13:36:34.413]                 NAMES <- toupper(removed)
[13:36:34.413]                 for (kk in seq_along(NAMES)) {
[13:36:34.413]                   name <- removed[[kk]]
[13:36:34.413]                   NAME <- NAMES[[kk]]
[13:36:34.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.413]                     next
[13:36:34.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.413]                 }
[13:36:34.413]                 if (length(args) > 0) 
[13:36:34.413]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.413]             }
[13:36:34.413]             else {
[13:36:34.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.413]             }
[13:36:34.413]             {
[13:36:34.413]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.413]                   0L) {
[13:36:34.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.413]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.413]                   base::options(opts)
[13:36:34.413]                 }
[13:36:34.413]                 {
[13:36:34.413]                   {
[13:36:34.413]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.413]                     NULL
[13:36:34.413]                   }
[13:36:34.413]                   options(future.plan = NULL)
[13:36:34.413]                   if (is.na(NA_character_)) 
[13:36:34.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.413]                     .init = FALSE)
[13:36:34.413]                 }
[13:36:34.413]             }
[13:36:34.413]         }
[13:36:34.413]     })
[13:36:34.413]     if (TRUE) {
[13:36:34.413]         base::sink(type = "output", split = FALSE)
[13:36:34.413]         if (TRUE) {
[13:36:34.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.413]         }
[13:36:34.413]         else {
[13:36:34.413]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.413]         }
[13:36:34.413]         base::close(...future.stdout)
[13:36:34.413]         ...future.stdout <- NULL
[13:36:34.413]     }
[13:36:34.413]     ...future.result$conditions <- ...future.conditions
[13:36:34.413]     ...future.result$finished <- base::Sys.time()
[13:36:34.413]     ...future.result
[13:36:34.413] }
[13:36:34.416] requestCore(): workers = 2
[13:36:34.419] MulticoreFuture started
[13:36:34.420] - Launch lazy future ... done
[13:36:34.420] plan(): Setting new future strategy stack:
[13:36:34.420] run() for ‘MulticoreFuture’ ... done
[13:36:34.421] getGlobalsAndPackages() ...
[13:36:34.421] Searching for globals...
[13:36:34.421] List of future strategies:
[13:36:34.421] 1. sequential:
[13:36:34.421]    - args: function (..., envir = parent.frame())
[13:36:34.421]    - tweaked: FALSE
[13:36:34.421]    - call: NULL
[13:36:34.422] plan(): nbrOfWorkers() = 1
[13:36:34.423] 
[13:36:34.423] Searching for globals ... DONE
[13:36:34.423] - globals: [0] <none>
[13:36:34.424] getGlobalsAndPackages() ... DONE
[13:36:34.424] run() for ‘Future’ ...
[13:36:34.425] - state: ‘created’
[13:36:34.425] plan(): Setting new future strategy stack:
[13:36:34.425] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.425] List of future strategies:
[13:36:34.425] 1. multicore:
[13:36:34.425]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.425]    - tweaked: FALSE
[13:36:34.425]    - call: plan(strategy)
[13:36:34.431] plan(): nbrOfWorkers() = 2
[13:36:34.432] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.432]   - Field: ‘label’
[13:36:34.432]   - Field: ‘local’
[13:36:34.433]   - Field: ‘owner’
[13:36:34.433]   - Field: ‘envir’
[13:36:34.433]   - Field: ‘workers’
[13:36:34.433]   - Field: ‘packages’
[13:36:34.433]   - Field: ‘gc’
[13:36:34.433]   - Field: ‘job’
[13:36:34.434]   - Field: ‘conditions’
[13:36:34.434]   - Field: ‘expr’
[13:36:34.434]   - Field: ‘uuid’
[13:36:34.434]   - Field: ‘seed’
[13:36:34.434]   - Field: ‘version’
[13:36:34.434]   - Field: ‘result’
[13:36:34.434]   - Field: ‘asynchronous’
[13:36:34.435]   - Field: ‘calls’
[13:36:34.435]   - Field: ‘globals’
[13:36:34.435]   - Field: ‘stdout’
[13:36:34.435]   - Field: ‘earlySignal’
[13:36:34.435]   - Field: ‘lazy’
[13:36:34.435]   - Field: ‘state’
[13:36:34.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.436] - Launch lazy future ...
[13:36:34.436] Packages needed by the future expression (n = 0): <none>
[13:36:34.436] Packages needed by future strategies (n = 0): <none>
[13:36:34.437] {
[13:36:34.437]     {
[13:36:34.437]         {
[13:36:34.437]             ...future.startTime <- base::Sys.time()
[13:36:34.437]             {
[13:36:34.437]                 {
[13:36:34.437]                   {
[13:36:34.437]                     {
[13:36:34.437]                       base::local({
[13:36:34.437]                         has_future <- base::requireNamespace("future", 
[13:36:34.437]                           quietly = TRUE)
[13:36:34.437]                         if (has_future) {
[13:36:34.437]                           ns <- base::getNamespace("future")
[13:36:34.437]                           version <- ns[[".package"]][["version"]]
[13:36:34.437]                           if (is.null(version)) 
[13:36:34.437]                             version <- utils::packageVersion("future")
[13:36:34.437]                         }
[13:36:34.437]                         else {
[13:36:34.437]                           version <- NULL
[13:36:34.437]                         }
[13:36:34.437]                         if (!has_future || version < "1.8.0") {
[13:36:34.437]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.437]                             "", base::R.version$version.string), 
[13:36:34.437]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.437]                               "release", "version")], collapse = " "), 
[13:36:34.437]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.437]                             info)
[13:36:34.437]                           info <- base::paste(info, collapse = "; ")
[13:36:34.437]                           if (!has_future) {
[13:36:34.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.437]                               info)
[13:36:34.437]                           }
[13:36:34.437]                           else {
[13:36:34.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.437]                               info, version)
[13:36:34.437]                           }
[13:36:34.437]                           base::stop(msg)
[13:36:34.437]                         }
[13:36:34.437]                       })
[13:36:34.437]                     }
[13:36:34.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.437]                     base::options(mc.cores = 1L)
[13:36:34.437]                   }
[13:36:34.437]                   ...future.strategy.old <- future::plan("list")
[13:36:34.437]                   options(future.plan = NULL)
[13:36:34.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.437]                 }
[13:36:34.437]                 ...future.workdir <- getwd()
[13:36:34.437]             }
[13:36:34.437]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.437]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.437]         }
[13:36:34.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.437]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.437]             base::names(...future.oldOptions))
[13:36:34.437]     }
[13:36:34.437]     if (FALSE) {
[13:36:34.437]     }
[13:36:34.437]     else {
[13:36:34.437]         if (TRUE) {
[13:36:34.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.437]                 open = "w")
[13:36:34.437]         }
[13:36:34.437]         else {
[13:36:34.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.437]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.437]         }
[13:36:34.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.437]             base::sink(type = "output", split = FALSE)
[13:36:34.437]             base::close(...future.stdout)
[13:36:34.437]         }, add = TRUE)
[13:36:34.437]     }
[13:36:34.437]     ...future.frame <- base::sys.nframe()
[13:36:34.437]     ...future.conditions <- base::list()
[13:36:34.437]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.437]     if (FALSE) {
[13:36:34.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.437]     }
[13:36:34.437]     ...future.result <- base::tryCatch({
[13:36:34.437]         base::withCallingHandlers({
[13:36:34.437]             ...future.value <- base::withVisible(base::local({
[13:36:34.437]                 withCallingHandlers({
[13:36:34.437]                   NULL
[13:36:34.437]                 }, immediateCondition = function(cond) {
[13:36:34.437]                   save_rds <- function (object, pathname, ...) 
[13:36:34.437]                   {
[13:36:34.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.437]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.437]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.437]                         fi_tmp[["mtime"]])
[13:36:34.437]                     }
[13:36:34.437]                     tryCatch({
[13:36:34.437]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.437]                     }, error = function(ex) {
[13:36:34.437]                       msg <- conditionMessage(ex)
[13:36:34.437]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.437]                         fi_tmp[["mtime"]], msg)
[13:36:34.437]                       ex$message <- msg
[13:36:34.437]                       stop(ex)
[13:36:34.437]                     })
[13:36:34.437]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.437]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.437]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.437]                       fi <- file.info(pathname)
[13:36:34.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.437]                         fi[["size"]], fi[["mtime"]])
[13:36:34.437]                       stop(msg)
[13:36:34.437]                     }
[13:36:34.437]                     invisible(pathname)
[13:36:34.437]                   }
[13:36:34.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.437]                     rootPath = tempdir()) 
[13:36:34.437]                   {
[13:36:34.437]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.437]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.437]                       tmpdir = path, fileext = ".rds")
[13:36:34.437]                     save_rds(obj, file)
[13:36:34.437]                   }
[13:36:34.437]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.437]                   {
[13:36:34.437]                     inherits <- base::inherits
[13:36:34.437]                     invokeRestart <- base::invokeRestart
[13:36:34.437]                     is.null <- base::is.null
[13:36:34.437]                     muffled <- FALSE
[13:36:34.437]                     if (inherits(cond, "message")) {
[13:36:34.437]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.437]                       if (muffled) 
[13:36:34.437]                         invokeRestart("muffleMessage")
[13:36:34.437]                     }
[13:36:34.437]                     else if (inherits(cond, "warning")) {
[13:36:34.437]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.437]                       if (muffled) 
[13:36:34.437]                         invokeRestart("muffleWarning")
[13:36:34.437]                     }
[13:36:34.437]                     else if (inherits(cond, "condition")) {
[13:36:34.437]                       if (!is.null(pattern)) {
[13:36:34.437]                         computeRestarts <- base::computeRestarts
[13:36:34.437]                         grepl <- base::grepl
[13:36:34.437]                         restarts <- computeRestarts(cond)
[13:36:34.437]                         for (restart in restarts) {
[13:36:34.437]                           name <- restart$name
[13:36:34.437]                           if (is.null(name)) 
[13:36:34.437]                             next
[13:36:34.437]                           if (!grepl(pattern, name)) 
[13:36:34.437]                             next
[13:36:34.437]                           invokeRestart(restart)
[13:36:34.437]                           muffled <- TRUE
[13:36:34.437]                           break
[13:36:34.437]                         }
[13:36:34.437]                       }
[13:36:34.437]                     }
[13:36:34.437]                     invisible(muffled)
[13:36:34.437]                   }
[13:36:34.437]                   muffleCondition(cond)
[13:36:34.437]                 })
[13:36:34.437]             }))
[13:36:34.437]             future::FutureResult(value = ...future.value$value, 
[13:36:34.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.437]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.437]                     ...future.globalenv.names))
[13:36:34.437]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.437]         }, condition = base::local({
[13:36:34.437]             c <- base::c
[13:36:34.437]             inherits <- base::inherits
[13:36:34.437]             invokeRestart <- base::invokeRestart
[13:36:34.437]             length <- base::length
[13:36:34.437]             list <- base::list
[13:36:34.437]             seq.int <- base::seq.int
[13:36:34.437]             signalCondition <- base::signalCondition
[13:36:34.437]             sys.calls <- base::sys.calls
[13:36:34.437]             `[[` <- base::`[[`
[13:36:34.437]             `+` <- base::`+`
[13:36:34.437]             `<<-` <- base::`<<-`
[13:36:34.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.437]                   3L)]
[13:36:34.437]             }
[13:36:34.437]             function(cond) {
[13:36:34.437]                 is_error <- inherits(cond, "error")
[13:36:34.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.437]                   NULL)
[13:36:34.437]                 if (is_error) {
[13:36:34.437]                   sessionInformation <- function() {
[13:36:34.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.437]                       search = base::search(), system = base::Sys.info())
[13:36:34.437]                   }
[13:36:34.437]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.437]                     cond$call), session = sessionInformation(), 
[13:36:34.437]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.437]                   signalCondition(cond)
[13:36:34.437]                 }
[13:36:34.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.437]                 "immediateCondition"))) {
[13:36:34.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.437]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.437]                   if (TRUE && !signal) {
[13:36:34.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.437]                     {
[13:36:34.437]                       inherits <- base::inherits
[13:36:34.437]                       invokeRestart <- base::invokeRestart
[13:36:34.437]                       is.null <- base::is.null
[13:36:34.437]                       muffled <- FALSE
[13:36:34.437]                       if (inherits(cond, "message")) {
[13:36:34.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.437]                         if (muffled) 
[13:36:34.437]                           invokeRestart("muffleMessage")
[13:36:34.437]                       }
[13:36:34.437]                       else if (inherits(cond, "warning")) {
[13:36:34.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.437]                         if (muffled) 
[13:36:34.437]                           invokeRestart("muffleWarning")
[13:36:34.437]                       }
[13:36:34.437]                       else if (inherits(cond, "condition")) {
[13:36:34.437]                         if (!is.null(pattern)) {
[13:36:34.437]                           computeRestarts <- base::computeRestarts
[13:36:34.437]                           grepl <- base::grepl
[13:36:34.437]                           restarts <- computeRestarts(cond)
[13:36:34.437]                           for (restart in restarts) {
[13:36:34.437]                             name <- restart$name
[13:36:34.437]                             if (is.null(name)) 
[13:36:34.437]                               next
[13:36:34.437]                             if (!grepl(pattern, name)) 
[13:36:34.437]                               next
[13:36:34.437]                             invokeRestart(restart)
[13:36:34.437]                             muffled <- TRUE
[13:36:34.437]                             break
[13:36:34.437]                           }
[13:36:34.437]                         }
[13:36:34.437]                       }
[13:36:34.437]                       invisible(muffled)
[13:36:34.437]                     }
[13:36:34.437]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.437]                   }
[13:36:34.437]                 }
[13:36:34.437]                 else {
[13:36:34.437]                   if (TRUE) {
[13:36:34.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.437]                     {
[13:36:34.437]                       inherits <- base::inherits
[13:36:34.437]                       invokeRestart <- base::invokeRestart
[13:36:34.437]                       is.null <- base::is.null
[13:36:34.437]                       muffled <- FALSE
[13:36:34.437]                       if (inherits(cond, "message")) {
[13:36:34.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.437]                         if (muffled) 
[13:36:34.437]                           invokeRestart("muffleMessage")
[13:36:34.437]                       }
[13:36:34.437]                       else if (inherits(cond, "warning")) {
[13:36:34.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.437]                         if (muffled) 
[13:36:34.437]                           invokeRestart("muffleWarning")
[13:36:34.437]                       }
[13:36:34.437]                       else if (inherits(cond, "condition")) {
[13:36:34.437]                         if (!is.null(pattern)) {
[13:36:34.437]                           computeRestarts <- base::computeRestarts
[13:36:34.437]                           grepl <- base::grepl
[13:36:34.437]                           restarts <- computeRestarts(cond)
[13:36:34.437]                           for (restart in restarts) {
[13:36:34.437]                             name <- restart$name
[13:36:34.437]                             if (is.null(name)) 
[13:36:34.437]                               next
[13:36:34.437]                             if (!grepl(pattern, name)) 
[13:36:34.437]                               next
[13:36:34.437]                             invokeRestart(restart)
[13:36:34.437]                             muffled <- TRUE
[13:36:34.437]                             break
[13:36:34.437]                           }
[13:36:34.437]                         }
[13:36:34.437]                       }
[13:36:34.437]                       invisible(muffled)
[13:36:34.437]                     }
[13:36:34.437]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.437]                   }
[13:36:34.437]                 }
[13:36:34.437]             }
[13:36:34.437]         }))
[13:36:34.437]     }, error = function(ex) {
[13:36:34.437]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.437]                 ...future.rng), started = ...future.startTime, 
[13:36:34.437]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.437]             version = "1.8"), class = "FutureResult")
[13:36:34.437]     }, finally = {
[13:36:34.437]         if (!identical(...future.workdir, getwd())) 
[13:36:34.437]             setwd(...future.workdir)
[13:36:34.437]         {
[13:36:34.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.437]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.437]             }
[13:36:34.437]             base::options(...future.oldOptions)
[13:36:34.437]             if (.Platform$OS.type == "windows") {
[13:36:34.437]                 old_names <- names(...future.oldEnvVars)
[13:36:34.437]                 envs <- base::Sys.getenv()
[13:36:34.437]                 names <- names(envs)
[13:36:34.437]                 common <- intersect(names, old_names)
[13:36:34.437]                 added <- setdiff(names, old_names)
[13:36:34.437]                 removed <- setdiff(old_names, names)
[13:36:34.437]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.437]                   envs[common]]
[13:36:34.437]                 NAMES <- toupper(changed)
[13:36:34.437]                 args <- list()
[13:36:34.437]                 for (kk in seq_along(NAMES)) {
[13:36:34.437]                   name <- changed[[kk]]
[13:36:34.437]                   NAME <- NAMES[[kk]]
[13:36:34.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.437]                     next
[13:36:34.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.437]                 }
[13:36:34.437]                 NAMES <- toupper(added)
[13:36:34.437]                 for (kk in seq_along(NAMES)) {
[13:36:34.437]                   name <- added[[kk]]
[13:36:34.437]                   NAME <- NAMES[[kk]]
[13:36:34.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.437]                     next
[13:36:34.437]                   args[[name]] <- ""
[13:36:34.437]                 }
[13:36:34.437]                 NAMES <- toupper(removed)
[13:36:34.437]                 for (kk in seq_along(NAMES)) {
[13:36:34.437]                   name <- removed[[kk]]
[13:36:34.437]                   NAME <- NAMES[[kk]]
[13:36:34.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.437]                     next
[13:36:34.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.437]                 }
[13:36:34.437]                 if (length(args) > 0) 
[13:36:34.437]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.437]             }
[13:36:34.437]             else {
[13:36:34.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.437]             }
[13:36:34.437]             {
[13:36:34.437]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.437]                   0L) {
[13:36:34.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.437]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.437]                   base::options(opts)
[13:36:34.437]                 }
[13:36:34.437]                 {
[13:36:34.437]                   {
[13:36:34.437]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.437]                     NULL
[13:36:34.437]                   }
[13:36:34.437]                   options(future.plan = NULL)
[13:36:34.437]                   if (is.na(NA_character_)) 
[13:36:34.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.437]                     .init = FALSE)
[13:36:34.437]                 }
[13:36:34.437]             }
[13:36:34.437]         }
[13:36:34.437]     })
[13:36:34.437]     if (TRUE) {
[13:36:34.437]         base::sink(type = "output", split = FALSE)
[13:36:34.437]         if (TRUE) {
[13:36:34.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.437]         }
[13:36:34.437]         else {
[13:36:34.437]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.437]         }
[13:36:34.437]         base::close(...future.stdout)
[13:36:34.437]         ...future.stdout <- NULL
[13:36:34.437]     }
[13:36:34.437]     ...future.result$conditions <- ...future.conditions
[13:36:34.437]     ...future.result$finished <- base::Sys.time()
[13:36:34.437]     ...future.result
[13:36:34.437] }
[13:36:34.441] requestCore(): workers = 2
[13:36:34.447] MulticoreFuture started
[13:36:34.448] - Launch lazy future ... done
[13:36:34.448] run() for ‘MulticoreFuture’ ... done
List of 6
[13:36:34.449] plan(): Setting new future strategy stack:
 $ a:[13:36:34.449] List of future strategies:
[13:36:34.449] 1. sequential:
[13:36:34.449]    - args: function (..., envir = parent.frame())
[13:36:34.449]    - tweaked: FALSE
[13:36:34.449]    - call: NULL
[13:36:34.450] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a73692f38> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a71936a20> 
 $  : NULL
 $  : NULL
 $  :[13:36:34.453] plan(): Setting new future strategy stack:
 num 6
List of 6
[13:36:34.453] List of future strategies:
[13:36:34.453] 1. multicore:
[13:36:34.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.453]    - tweaked: FALSE
[13:36:34.453]    - call: plan(strategy)
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a73692f38> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a71936a20> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:36:34.460] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:34.462] resolve() on list ...
[13:36:34.462]  recursive: 0
[13:36:34.462]  length: 6
[13:36:34.462]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:34.462] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.462] - nx: 6
[13:36:34.463] - relay: TRUE
[13:36:34.463] - stdout: TRUE
[13:36:34.463] - signal: TRUE
[13:36:34.463] - resignal: FALSE
[13:36:34.463] - force: TRUE
[13:36:34.463] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.463] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.463]  - until=2
[13:36:34.464]  - relaying element #2
[13:36:34.464] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.464] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.464] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.464]  length: 5 (resolved future 1)
[13:36:34.464] Future #2
[13:36:34.465] result() for MulticoreFuture ...
[13:36:34.467] result() for MulticoreFuture ...
[13:36:34.467] result() for MulticoreFuture ... done
[13:36:34.467] result() for MulticoreFuture ... done
[13:36:34.467] result() for MulticoreFuture ...
[13:36:34.468] result() for MulticoreFuture ... done
[13:36:34.468] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:34.468] - nx: 6
[13:36:34.468] - relay: TRUE
[13:36:34.468] - stdout: TRUE
[13:36:34.469] - signal: TRUE
[13:36:34.469] - resignal: FALSE
[13:36:34.469] - force: TRUE
[13:36:34.469] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.469] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.469]  - until=2
[13:36:34.470]  - relaying element #2
[13:36:34.470] result() for MulticoreFuture ...
[13:36:34.470] result() for MulticoreFuture ... done
[13:36:34.470] result() for MulticoreFuture ...
[13:36:34.470] result() for MulticoreFuture ... done
[13:36:34.471] result() for MulticoreFuture ...
[13:36:34.471] result() for MulticoreFuture ... done
[13:36:34.471] result() for MulticoreFuture ...
[13:36:34.471] result() for MulticoreFuture ... done
[13:36:34.471] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.471] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.471] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:34.472]  length: 4 (resolved future 2)
[13:36:34.472] Future #3
[13:36:34.472] result() for MulticoreFuture ...
[13:36:34.473] result() for MulticoreFuture ...
[13:36:34.473] result() for MulticoreFuture ... done
[13:36:34.473] result() for MulticoreFuture ... done
[13:36:34.473] result() for MulticoreFuture ...
[13:36:34.474] result() for MulticoreFuture ... done
[13:36:34.474] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:34.478] - nx: 6
[13:36:34.478] - relay: TRUE
[13:36:34.478] - stdout: TRUE
[13:36:34.478] - signal: TRUE
[13:36:34.478] - resignal: FALSE
[13:36:34.479] - force: TRUE
[13:36:34.479] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.479] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.479]  - until=3
[13:36:34.479]  - relaying element #3
[13:36:34.479] result() for MulticoreFuture ...
[13:36:34.480] result() for MulticoreFuture ... done
[13:36:34.480] result() for MulticoreFuture ...
[13:36:34.480] result() for MulticoreFuture ... done
[13:36:34.480] result() for MulticoreFuture ...
[13:36:34.480] result() for MulticoreFuture ... done
[13:36:34.480] result() for MulticoreFuture ...
[13:36:34.481] result() for MulticoreFuture ... done
[13:36:34.481] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.481] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.481] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:34.481]  length: 3 (resolved future 3)
[13:36:34.481] signalConditionsASAP(NULL, pos=4) ...
[13:36:34.481] - nx: 6
[13:36:34.481] - relay: TRUE
[13:36:34.481] - stdout: TRUE
[13:36:34.482] - signal: TRUE
[13:36:34.482] - resignal: FALSE
[13:36:34.482] - force: TRUE
[13:36:34.482] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.482]  - until=5
[13:36:34.482]  - relaying element #5
[13:36:34.482] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.483] signalConditionsASAP(NULL, pos=4) ... done
[13:36:34.483]  length: 2 (resolved future 4)
[13:36:34.483] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.483] - nx: 6
[13:36:34.483] - relay: TRUE
[13:36:34.483] - stdout: TRUE
[13:36:34.483] - signal: TRUE
[13:36:34.483] - resignal: FALSE
[13:36:34.484] - force: TRUE
[13:36:34.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.484]  - until=6
[13:36:34.484]  - relaying element #6
[13:36:34.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.484] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.484]  length: 1 (resolved future 5)
[13:36:34.485] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.485] - nx: 6
[13:36:34.485] - relay: TRUE
[13:36:34.485] - stdout: TRUE
[13:36:34.485] - signal: TRUE
[13:36:34.485] - resignal: FALSE
[13:36:34.485] - force: TRUE
[13:36:34.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.486]  - until=6
[13:36:34.486] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.486] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.486] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.486]  length: 0 (resolved future 6)
[13:36:34.486] Relaying remaining futures
[13:36:34.486] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.486] - nx: 6
[13:36:34.486] - relay: TRUE
[13:36:34.486] - stdout: TRUE
[13:36:34.487] - signal: TRUE
[13:36:34.487] - resignal: FALSE
[13:36:34.487] - force: TRUE
[13:36:34.487] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.487] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:34.487] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.487] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.487] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.487] resolve() on list ... DONE
[13:36:34.488] result() for MulticoreFuture ...
[13:36:34.488] result() for MulticoreFuture ... done
[13:36:34.488] result() for MulticoreFuture ...
[13:36:34.488] result() for MulticoreFuture ... done
[13:36:34.488] result() for MulticoreFuture ...
[13:36:34.488] result() for MulticoreFuture ... done
[13:36:34.488] result() for MulticoreFuture ...
[13:36:34.488] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:36:34.491] getGlobalsAndPackages() ...
[13:36:34.491] Searching for globals...
[13:36:34.491] 
[13:36:34.491] Searching for globals ... DONE
[13:36:34.492] - globals: [0] <none>
[13:36:34.492] getGlobalsAndPackages() ... DONE
[13:36:34.492] run() for ‘Future’ ...
[13:36:34.492] - state: ‘created’
[13:36:34.492] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.496] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.496]   - Field: ‘label’
[13:36:34.496]   - Field: ‘local’
[13:36:34.496]   - Field: ‘owner’
[13:36:34.496]   - Field: ‘envir’
[13:36:34.497]   - Field: ‘workers’
[13:36:34.497]   - Field: ‘packages’
[13:36:34.497]   - Field: ‘gc’
[13:36:34.497]   - Field: ‘job’
[13:36:34.497]   - Field: ‘conditions’
[13:36:34.497]   - Field: ‘expr’
[13:36:34.497]   - Field: ‘uuid’
[13:36:34.497]   - Field: ‘seed’
[13:36:34.497]   - Field: ‘version’
[13:36:34.497]   - Field: ‘result’
[13:36:34.497]   - Field: ‘asynchronous’
[13:36:34.498]   - Field: ‘calls’
[13:36:34.498]   - Field: ‘globals’
[13:36:34.498]   - Field: ‘stdout’
[13:36:34.498]   - Field: ‘earlySignal’
[13:36:34.498]   - Field: ‘lazy’
[13:36:34.498]   - Field: ‘state’
[13:36:34.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.498] - Launch lazy future ...
[13:36:34.499] Packages needed by the future expression (n = 0): <none>
[13:36:34.499] Packages needed by future strategies (n = 0): <none>
[13:36:34.499] {
[13:36:34.499]     {
[13:36:34.499]         {
[13:36:34.499]             ...future.startTime <- base::Sys.time()
[13:36:34.499]             {
[13:36:34.499]                 {
[13:36:34.499]                   {
[13:36:34.499]                     {
[13:36:34.499]                       base::local({
[13:36:34.499]                         has_future <- base::requireNamespace("future", 
[13:36:34.499]                           quietly = TRUE)
[13:36:34.499]                         if (has_future) {
[13:36:34.499]                           ns <- base::getNamespace("future")
[13:36:34.499]                           version <- ns[[".package"]][["version"]]
[13:36:34.499]                           if (is.null(version)) 
[13:36:34.499]                             version <- utils::packageVersion("future")
[13:36:34.499]                         }
[13:36:34.499]                         else {
[13:36:34.499]                           version <- NULL
[13:36:34.499]                         }
[13:36:34.499]                         if (!has_future || version < "1.8.0") {
[13:36:34.499]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.499]                             "", base::R.version$version.string), 
[13:36:34.499]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.499]                               "release", "version")], collapse = " "), 
[13:36:34.499]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.499]                             info)
[13:36:34.499]                           info <- base::paste(info, collapse = "; ")
[13:36:34.499]                           if (!has_future) {
[13:36:34.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.499]                               info)
[13:36:34.499]                           }
[13:36:34.499]                           else {
[13:36:34.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.499]                               info, version)
[13:36:34.499]                           }
[13:36:34.499]                           base::stop(msg)
[13:36:34.499]                         }
[13:36:34.499]                       })
[13:36:34.499]                     }
[13:36:34.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.499]                     base::options(mc.cores = 1L)
[13:36:34.499]                   }
[13:36:34.499]                   ...future.strategy.old <- future::plan("list")
[13:36:34.499]                   options(future.plan = NULL)
[13:36:34.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.499]                 }
[13:36:34.499]                 ...future.workdir <- getwd()
[13:36:34.499]             }
[13:36:34.499]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.499]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.499]         }
[13:36:34.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.499]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.499]             base::names(...future.oldOptions))
[13:36:34.499]     }
[13:36:34.499]     if (FALSE) {
[13:36:34.499]     }
[13:36:34.499]     else {
[13:36:34.499]         if (TRUE) {
[13:36:34.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.499]                 open = "w")
[13:36:34.499]         }
[13:36:34.499]         else {
[13:36:34.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.499]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.499]         }
[13:36:34.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.499]             base::sink(type = "output", split = FALSE)
[13:36:34.499]             base::close(...future.stdout)
[13:36:34.499]         }, add = TRUE)
[13:36:34.499]     }
[13:36:34.499]     ...future.frame <- base::sys.nframe()
[13:36:34.499]     ...future.conditions <- base::list()
[13:36:34.499]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.499]     if (FALSE) {
[13:36:34.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.499]     }
[13:36:34.499]     ...future.result <- base::tryCatch({
[13:36:34.499]         base::withCallingHandlers({
[13:36:34.499]             ...future.value <- base::withVisible(base::local({
[13:36:34.499]                 withCallingHandlers({
[13:36:34.499]                   2
[13:36:34.499]                 }, immediateCondition = function(cond) {
[13:36:34.499]                   save_rds <- function (object, pathname, ...) 
[13:36:34.499]                   {
[13:36:34.499]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.499]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.499]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.499]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.499]                         fi_tmp[["mtime"]])
[13:36:34.499]                     }
[13:36:34.499]                     tryCatch({
[13:36:34.499]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.499]                     }, error = function(ex) {
[13:36:34.499]                       msg <- conditionMessage(ex)
[13:36:34.499]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.499]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.499]                         fi_tmp[["mtime"]], msg)
[13:36:34.499]                       ex$message <- msg
[13:36:34.499]                       stop(ex)
[13:36:34.499]                     })
[13:36:34.499]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.499]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.499]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.499]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.499]                       fi <- file.info(pathname)
[13:36:34.499]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.499]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.499]                         fi[["size"]], fi[["mtime"]])
[13:36:34.499]                       stop(msg)
[13:36:34.499]                     }
[13:36:34.499]                     invisible(pathname)
[13:36:34.499]                   }
[13:36:34.499]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.499]                     rootPath = tempdir()) 
[13:36:34.499]                   {
[13:36:34.499]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.499]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.499]                       tmpdir = path, fileext = ".rds")
[13:36:34.499]                     save_rds(obj, file)
[13:36:34.499]                   }
[13:36:34.499]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.499]                   {
[13:36:34.499]                     inherits <- base::inherits
[13:36:34.499]                     invokeRestart <- base::invokeRestart
[13:36:34.499]                     is.null <- base::is.null
[13:36:34.499]                     muffled <- FALSE
[13:36:34.499]                     if (inherits(cond, "message")) {
[13:36:34.499]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.499]                       if (muffled) 
[13:36:34.499]                         invokeRestart("muffleMessage")
[13:36:34.499]                     }
[13:36:34.499]                     else if (inherits(cond, "warning")) {
[13:36:34.499]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.499]                       if (muffled) 
[13:36:34.499]                         invokeRestart("muffleWarning")
[13:36:34.499]                     }
[13:36:34.499]                     else if (inherits(cond, "condition")) {
[13:36:34.499]                       if (!is.null(pattern)) {
[13:36:34.499]                         computeRestarts <- base::computeRestarts
[13:36:34.499]                         grepl <- base::grepl
[13:36:34.499]                         restarts <- computeRestarts(cond)
[13:36:34.499]                         for (restart in restarts) {
[13:36:34.499]                           name <- restart$name
[13:36:34.499]                           if (is.null(name)) 
[13:36:34.499]                             next
[13:36:34.499]                           if (!grepl(pattern, name)) 
[13:36:34.499]                             next
[13:36:34.499]                           invokeRestart(restart)
[13:36:34.499]                           muffled <- TRUE
[13:36:34.499]                           break
[13:36:34.499]                         }
[13:36:34.499]                       }
[13:36:34.499]                     }
[13:36:34.499]                     invisible(muffled)
[13:36:34.499]                   }
[13:36:34.499]                   muffleCondition(cond)
[13:36:34.499]                 })
[13:36:34.499]             }))
[13:36:34.499]             future::FutureResult(value = ...future.value$value, 
[13:36:34.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.499]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.499]                     ...future.globalenv.names))
[13:36:34.499]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.499]         }, condition = base::local({
[13:36:34.499]             c <- base::c
[13:36:34.499]             inherits <- base::inherits
[13:36:34.499]             invokeRestart <- base::invokeRestart
[13:36:34.499]             length <- base::length
[13:36:34.499]             list <- base::list
[13:36:34.499]             seq.int <- base::seq.int
[13:36:34.499]             signalCondition <- base::signalCondition
[13:36:34.499]             sys.calls <- base::sys.calls
[13:36:34.499]             `[[` <- base::`[[`
[13:36:34.499]             `+` <- base::`+`
[13:36:34.499]             `<<-` <- base::`<<-`
[13:36:34.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.499]                   3L)]
[13:36:34.499]             }
[13:36:34.499]             function(cond) {
[13:36:34.499]                 is_error <- inherits(cond, "error")
[13:36:34.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.499]                   NULL)
[13:36:34.499]                 if (is_error) {
[13:36:34.499]                   sessionInformation <- function() {
[13:36:34.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.499]                       search = base::search(), system = base::Sys.info())
[13:36:34.499]                   }
[13:36:34.499]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.499]                     cond$call), session = sessionInformation(), 
[13:36:34.499]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.499]                   signalCondition(cond)
[13:36:34.499]                 }
[13:36:34.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.499]                 "immediateCondition"))) {
[13:36:34.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.499]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.499]                   if (TRUE && !signal) {
[13:36:34.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.499]                     {
[13:36:34.499]                       inherits <- base::inherits
[13:36:34.499]                       invokeRestart <- base::invokeRestart
[13:36:34.499]                       is.null <- base::is.null
[13:36:34.499]                       muffled <- FALSE
[13:36:34.499]                       if (inherits(cond, "message")) {
[13:36:34.499]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.499]                         if (muffled) 
[13:36:34.499]                           invokeRestart("muffleMessage")
[13:36:34.499]                       }
[13:36:34.499]                       else if (inherits(cond, "warning")) {
[13:36:34.499]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.499]                         if (muffled) 
[13:36:34.499]                           invokeRestart("muffleWarning")
[13:36:34.499]                       }
[13:36:34.499]                       else if (inherits(cond, "condition")) {
[13:36:34.499]                         if (!is.null(pattern)) {
[13:36:34.499]                           computeRestarts <- base::computeRestarts
[13:36:34.499]                           grepl <- base::grepl
[13:36:34.499]                           restarts <- computeRestarts(cond)
[13:36:34.499]                           for (restart in restarts) {
[13:36:34.499]                             name <- restart$name
[13:36:34.499]                             if (is.null(name)) 
[13:36:34.499]                               next
[13:36:34.499]                             if (!grepl(pattern, name)) 
[13:36:34.499]                               next
[13:36:34.499]                             invokeRestart(restart)
[13:36:34.499]                             muffled <- TRUE
[13:36:34.499]                             break
[13:36:34.499]                           }
[13:36:34.499]                         }
[13:36:34.499]                       }
[13:36:34.499]                       invisible(muffled)
[13:36:34.499]                     }
[13:36:34.499]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.499]                   }
[13:36:34.499]                 }
[13:36:34.499]                 else {
[13:36:34.499]                   if (TRUE) {
[13:36:34.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.499]                     {
[13:36:34.499]                       inherits <- base::inherits
[13:36:34.499]                       invokeRestart <- base::invokeRestart
[13:36:34.499]                       is.null <- base::is.null
[13:36:34.499]                       muffled <- FALSE
[13:36:34.499]                       if (inherits(cond, "message")) {
[13:36:34.499]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.499]                         if (muffled) 
[13:36:34.499]                           invokeRestart("muffleMessage")
[13:36:34.499]                       }
[13:36:34.499]                       else if (inherits(cond, "warning")) {
[13:36:34.499]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.499]                         if (muffled) 
[13:36:34.499]                           invokeRestart("muffleWarning")
[13:36:34.499]                       }
[13:36:34.499]                       else if (inherits(cond, "condition")) {
[13:36:34.499]                         if (!is.null(pattern)) {
[13:36:34.499]                           computeRestarts <- base::computeRestarts
[13:36:34.499]                           grepl <- base::grepl
[13:36:34.499]                           restarts <- computeRestarts(cond)
[13:36:34.499]                           for (restart in restarts) {
[13:36:34.499]                             name <- restart$name
[13:36:34.499]                             if (is.null(name)) 
[13:36:34.499]                               next
[13:36:34.499]                             if (!grepl(pattern, name)) 
[13:36:34.499]                               next
[13:36:34.499]                             invokeRestart(restart)
[13:36:34.499]                             muffled <- TRUE
[13:36:34.499]                             break
[13:36:34.499]                           }
[13:36:34.499]                         }
[13:36:34.499]                       }
[13:36:34.499]                       invisible(muffled)
[13:36:34.499]                     }
[13:36:34.499]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.499]                   }
[13:36:34.499]                 }
[13:36:34.499]             }
[13:36:34.499]         }))
[13:36:34.499]     }, error = function(ex) {
[13:36:34.499]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.499]                 ...future.rng), started = ...future.startTime, 
[13:36:34.499]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.499]             version = "1.8"), class = "FutureResult")
[13:36:34.499]     }, finally = {
[13:36:34.499]         if (!identical(...future.workdir, getwd())) 
[13:36:34.499]             setwd(...future.workdir)
[13:36:34.499]         {
[13:36:34.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.499]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.499]             }
[13:36:34.499]             base::options(...future.oldOptions)
[13:36:34.499]             if (.Platform$OS.type == "windows") {
[13:36:34.499]                 old_names <- names(...future.oldEnvVars)
[13:36:34.499]                 envs <- base::Sys.getenv()
[13:36:34.499]                 names <- names(envs)
[13:36:34.499]                 common <- intersect(names, old_names)
[13:36:34.499]                 added <- setdiff(names, old_names)
[13:36:34.499]                 removed <- setdiff(old_names, names)
[13:36:34.499]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.499]                   envs[common]]
[13:36:34.499]                 NAMES <- toupper(changed)
[13:36:34.499]                 args <- list()
[13:36:34.499]                 for (kk in seq_along(NAMES)) {
[13:36:34.499]                   name <- changed[[kk]]
[13:36:34.499]                   NAME <- NAMES[[kk]]
[13:36:34.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.499]                     next
[13:36:34.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.499]                 }
[13:36:34.499]                 NAMES <- toupper(added)
[13:36:34.499]                 for (kk in seq_along(NAMES)) {
[13:36:34.499]                   name <- added[[kk]]
[13:36:34.499]                   NAME <- NAMES[[kk]]
[13:36:34.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.499]                     next
[13:36:34.499]                   args[[name]] <- ""
[13:36:34.499]                 }
[13:36:34.499]                 NAMES <- toupper(removed)
[13:36:34.499]                 for (kk in seq_along(NAMES)) {
[13:36:34.499]                   name <- removed[[kk]]
[13:36:34.499]                   NAME <- NAMES[[kk]]
[13:36:34.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.499]                     next
[13:36:34.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.499]                 }
[13:36:34.499]                 if (length(args) > 0) 
[13:36:34.499]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.499]             }
[13:36:34.499]             else {
[13:36:34.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.499]             }
[13:36:34.499]             {
[13:36:34.499]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.499]                   0L) {
[13:36:34.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.499]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.499]                   base::options(opts)
[13:36:34.499]                 }
[13:36:34.499]                 {
[13:36:34.499]                   {
[13:36:34.499]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.499]                     NULL
[13:36:34.499]                   }
[13:36:34.499]                   options(future.plan = NULL)
[13:36:34.499]                   if (is.na(NA_character_)) 
[13:36:34.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.499]                     .init = FALSE)
[13:36:34.499]                 }
[13:36:34.499]             }
[13:36:34.499]         }
[13:36:34.499]     })
[13:36:34.499]     if (TRUE) {
[13:36:34.499]         base::sink(type = "output", split = FALSE)
[13:36:34.499]         if (TRUE) {
[13:36:34.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.499]         }
[13:36:34.499]         else {
[13:36:34.499]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.499]         }
[13:36:34.499]         base::close(...future.stdout)
[13:36:34.499]         ...future.stdout <- NULL
[13:36:34.499]     }
[13:36:34.499]     ...future.result$conditions <- ...future.conditions
[13:36:34.499]     ...future.result$finished <- base::Sys.time()
[13:36:34.499]     ...future.result
[13:36:34.499] }
[13:36:34.502] requestCore(): workers = 2
[13:36:34.503] MulticoreFuture started
[13:36:34.504] - Launch lazy future ... done
[13:36:34.504] run() for ‘MulticoreFuture’ ... done
[13:36:34.504] getGlobalsAndPackages() ...
[13:36:34.504] Searching for globals...
[13:36:34.504] plan(): Setting new future strategy stack:
[13:36:34.505] List of future strategies:
[13:36:34.505] 1. sequential:
[13:36:34.505]    - args: function (..., envir = parent.frame())
[13:36:34.505]    - tweaked: FALSE
[13:36:34.505]    - call: NULL
[13:36:34.505] 
[13:36:34.506] Searching for globals ... DONE
[13:36:34.506] plan(): nbrOfWorkers() = 1
[13:36:34.506] - globals: [0] <none>
[13:36:34.506] getGlobalsAndPackages() ... DONE
[13:36:34.506] run() for ‘Future’ ...
[13:36:34.507] - state: ‘created’
[13:36:34.507] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.508] plan(): Setting new future strategy stack:
[13:36:34.508] List of future strategies:
[13:36:34.508] 1. multicore:
[13:36:34.508]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.508]    - tweaked: FALSE
[13:36:34.508]    - call: plan(strategy)
[13:36:34.512] plan(): nbrOfWorkers() = 2
[13:36:34.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.513]   - Field: ‘label’
[13:36:34.513]   - Field: ‘local’
[13:36:34.513]   - Field: ‘owner’
[13:36:34.513]   - Field: ‘envir’
[13:36:34.514]   - Field: ‘workers’
[13:36:34.514]   - Field: ‘packages’
[13:36:34.514]   - Field: ‘gc’
[13:36:34.514]   - Field: ‘job’
[13:36:34.514]   - Field: ‘conditions’
[13:36:34.515]   - Field: ‘expr’
[13:36:34.515]   - Field: ‘uuid’
[13:36:34.515]   - Field: ‘seed’
[13:36:34.515]   - Field: ‘version’
[13:36:34.515]   - Field: ‘result’
[13:36:34.515]   - Field: ‘asynchronous’
[13:36:34.516]   - Field: ‘calls’
[13:36:34.516]   - Field: ‘globals’
[13:36:34.516]   - Field: ‘stdout’
[13:36:34.516]   - Field: ‘earlySignal’
[13:36:34.516]   - Field: ‘lazy’
[13:36:34.516]   - Field: ‘state’
[13:36:34.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.517] - Launch lazy future ...
[13:36:34.517] Packages needed by the future expression (n = 0): <none>
[13:36:34.517] Packages needed by future strategies (n = 0): <none>
[13:36:34.518] {
[13:36:34.518]     {
[13:36:34.518]         {
[13:36:34.518]             ...future.startTime <- base::Sys.time()
[13:36:34.518]             {
[13:36:34.518]                 {
[13:36:34.518]                   {
[13:36:34.518]                     {
[13:36:34.518]                       base::local({
[13:36:34.518]                         has_future <- base::requireNamespace("future", 
[13:36:34.518]                           quietly = TRUE)
[13:36:34.518]                         if (has_future) {
[13:36:34.518]                           ns <- base::getNamespace("future")
[13:36:34.518]                           version <- ns[[".package"]][["version"]]
[13:36:34.518]                           if (is.null(version)) 
[13:36:34.518]                             version <- utils::packageVersion("future")
[13:36:34.518]                         }
[13:36:34.518]                         else {
[13:36:34.518]                           version <- NULL
[13:36:34.518]                         }
[13:36:34.518]                         if (!has_future || version < "1.8.0") {
[13:36:34.518]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.518]                             "", base::R.version$version.string), 
[13:36:34.518]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.518]                               "release", "version")], collapse = " "), 
[13:36:34.518]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.518]                             info)
[13:36:34.518]                           info <- base::paste(info, collapse = "; ")
[13:36:34.518]                           if (!has_future) {
[13:36:34.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.518]                               info)
[13:36:34.518]                           }
[13:36:34.518]                           else {
[13:36:34.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.518]                               info, version)
[13:36:34.518]                           }
[13:36:34.518]                           base::stop(msg)
[13:36:34.518]                         }
[13:36:34.518]                       })
[13:36:34.518]                     }
[13:36:34.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.518]                     base::options(mc.cores = 1L)
[13:36:34.518]                   }
[13:36:34.518]                   ...future.strategy.old <- future::plan("list")
[13:36:34.518]                   options(future.plan = NULL)
[13:36:34.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.518]                 }
[13:36:34.518]                 ...future.workdir <- getwd()
[13:36:34.518]             }
[13:36:34.518]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.518]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.518]         }
[13:36:34.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.518]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.518]             base::names(...future.oldOptions))
[13:36:34.518]     }
[13:36:34.518]     if (FALSE) {
[13:36:34.518]     }
[13:36:34.518]     else {
[13:36:34.518]         if (TRUE) {
[13:36:34.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.518]                 open = "w")
[13:36:34.518]         }
[13:36:34.518]         else {
[13:36:34.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.518]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.518]         }
[13:36:34.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.518]             base::sink(type = "output", split = FALSE)
[13:36:34.518]             base::close(...future.stdout)
[13:36:34.518]         }, add = TRUE)
[13:36:34.518]     }
[13:36:34.518]     ...future.frame <- base::sys.nframe()
[13:36:34.518]     ...future.conditions <- base::list()
[13:36:34.518]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.518]     if (FALSE) {
[13:36:34.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.518]     }
[13:36:34.518]     ...future.result <- base::tryCatch({
[13:36:34.518]         base::withCallingHandlers({
[13:36:34.518]             ...future.value <- base::withVisible(base::local({
[13:36:34.518]                 withCallingHandlers({
[13:36:34.518]                   NULL
[13:36:34.518]                 }, immediateCondition = function(cond) {
[13:36:34.518]                   save_rds <- function (object, pathname, ...) 
[13:36:34.518]                   {
[13:36:34.518]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.518]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.518]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.518]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.518]                         fi_tmp[["mtime"]])
[13:36:34.518]                     }
[13:36:34.518]                     tryCatch({
[13:36:34.518]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.518]                     }, error = function(ex) {
[13:36:34.518]                       msg <- conditionMessage(ex)
[13:36:34.518]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.518]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.518]                         fi_tmp[["mtime"]], msg)
[13:36:34.518]                       ex$message <- msg
[13:36:34.518]                       stop(ex)
[13:36:34.518]                     })
[13:36:34.518]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.518]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.518]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.518]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.518]                       fi <- file.info(pathname)
[13:36:34.518]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.518]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.518]                         fi[["size"]], fi[["mtime"]])
[13:36:34.518]                       stop(msg)
[13:36:34.518]                     }
[13:36:34.518]                     invisible(pathname)
[13:36:34.518]                   }
[13:36:34.518]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.518]                     rootPath = tempdir()) 
[13:36:34.518]                   {
[13:36:34.518]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.518]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.518]                       tmpdir = path, fileext = ".rds")
[13:36:34.518]                     save_rds(obj, file)
[13:36:34.518]                   }
[13:36:34.518]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.518]                   {
[13:36:34.518]                     inherits <- base::inherits
[13:36:34.518]                     invokeRestart <- base::invokeRestart
[13:36:34.518]                     is.null <- base::is.null
[13:36:34.518]                     muffled <- FALSE
[13:36:34.518]                     if (inherits(cond, "message")) {
[13:36:34.518]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.518]                       if (muffled) 
[13:36:34.518]                         invokeRestart("muffleMessage")
[13:36:34.518]                     }
[13:36:34.518]                     else if (inherits(cond, "warning")) {
[13:36:34.518]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.518]                       if (muffled) 
[13:36:34.518]                         invokeRestart("muffleWarning")
[13:36:34.518]                     }
[13:36:34.518]                     else if (inherits(cond, "condition")) {
[13:36:34.518]                       if (!is.null(pattern)) {
[13:36:34.518]                         computeRestarts <- base::computeRestarts
[13:36:34.518]                         grepl <- base::grepl
[13:36:34.518]                         restarts <- computeRestarts(cond)
[13:36:34.518]                         for (restart in restarts) {
[13:36:34.518]                           name <- restart$name
[13:36:34.518]                           if (is.null(name)) 
[13:36:34.518]                             next
[13:36:34.518]                           if (!grepl(pattern, name)) 
[13:36:34.518]                             next
[13:36:34.518]                           invokeRestart(restart)
[13:36:34.518]                           muffled <- TRUE
[13:36:34.518]                           break
[13:36:34.518]                         }
[13:36:34.518]                       }
[13:36:34.518]                     }
[13:36:34.518]                     invisible(muffled)
[13:36:34.518]                   }
[13:36:34.518]                   muffleCondition(cond)
[13:36:34.518]                 })
[13:36:34.518]             }))
[13:36:34.518]             future::FutureResult(value = ...future.value$value, 
[13:36:34.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.518]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.518]                     ...future.globalenv.names))
[13:36:34.518]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.518]         }, condition = base::local({
[13:36:34.518]             c <- base::c
[13:36:34.518]             inherits <- base::inherits
[13:36:34.518]             invokeRestart <- base::invokeRestart
[13:36:34.518]             length <- base::length
[13:36:34.518]             list <- base::list
[13:36:34.518]             seq.int <- base::seq.int
[13:36:34.518]             signalCondition <- base::signalCondition
[13:36:34.518]             sys.calls <- base::sys.calls
[13:36:34.518]             `[[` <- base::`[[`
[13:36:34.518]             `+` <- base::`+`
[13:36:34.518]             `<<-` <- base::`<<-`
[13:36:34.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.518]                   3L)]
[13:36:34.518]             }
[13:36:34.518]             function(cond) {
[13:36:34.518]                 is_error <- inherits(cond, "error")
[13:36:34.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.518]                   NULL)
[13:36:34.518]                 if (is_error) {
[13:36:34.518]                   sessionInformation <- function() {
[13:36:34.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.518]                       search = base::search(), system = base::Sys.info())
[13:36:34.518]                   }
[13:36:34.518]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.518]                     cond$call), session = sessionInformation(), 
[13:36:34.518]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.518]                   signalCondition(cond)
[13:36:34.518]                 }
[13:36:34.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.518]                 "immediateCondition"))) {
[13:36:34.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.518]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.518]                   if (TRUE && !signal) {
[13:36:34.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.518]                     {
[13:36:34.518]                       inherits <- base::inherits
[13:36:34.518]                       invokeRestart <- base::invokeRestart
[13:36:34.518]                       is.null <- base::is.null
[13:36:34.518]                       muffled <- FALSE
[13:36:34.518]                       if (inherits(cond, "message")) {
[13:36:34.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.518]                         if (muffled) 
[13:36:34.518]                           invokeRestart("muffleMessage")
[13:36:34.518]                       }
[13:36:34.518]                       else if (inherits(cond, "warning")) {
[13:36:34.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.518]                         if (muffled) 
[13:36:34.518]                           invokeRestart("muffleWarning")
[13:36:34.518]                       }
[13:36:34.518]                       else if (inherits(cond, "condition")) {
[13:36:34.518]                         if (!is.null(pattern)) {
[13:36:34.518]                           computeRestarts <- base::computeRestarts
[13:36:34.518]                           grepl <- base::grepl
[13:36:34.518]                           restarts <- computeRestarts(cond)
[13:36:34.518]                           for (restart in restarts) {
[13:36:34.518]                             name <- restart$name
[13:36:34.518]                             if (is.null(name)) 
[13:36:34.518]                               next
[13:36:34.518]                             if (!grepl(pattern, name)) 
[13:36:34.518]                               next
[13:36:34.518]                             invokeRestart(restart)
[13:36:34.518]                             muffled <- TRUE
[13:36:34.518]                             break
[13:36:34.518]                           }
[13:36:34.518]                         }
[13:36:34.518]                       }
[13:36:34.518]                       invisible(muffled)
[13:36:34.518]                     }
[13:36:34.518]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.518]                   }
[13:36:34.518]                 }
[13:36:34.518]                 else {
[13:36:34.518]                   if (TRUE) {
[13:36:34.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.518]                     {
[13:36:34.518]                       inherits <- base::inherits
[13:36:34.518]                       invokeRestart <- base::invokeRestart
[13:36:34.518]                       is.null <- base::is.null
[13:36:34.518]                       muffled <- FALSE
[13:36:34.518]                       if (inherits(cond, "message")) {
[13:36:34.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.518]                         if (muffled) 
[13:36:34.518]                           invokeRestart("muffleMessage")
[13:36:34.518]                       }
[13:36:34.518]                       else if (inherits(cond, "warning")) {
[13:36:34.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.518]                         if (muffled) 
[13:36:34.518]                           invokeRestart("muffleWarning")
[13:36:34.518]                       }
[13:36:34.518]                       else if (inherits(cond, "condition")) {
[13:36:34.518]                         if (!is.null(pattern)) {
[13:36:34.518]                           computeRestarts <- base::computeRestarts
[13:36:34.518]                           grepl <- base::grepl
[13:36:34.518]                           restarts <- computeRestarts(cond)
[13:36:34.518]                           for (restart in restarts) {
[13:36:34.518]                             name <- restart$name
[13:36:34.518]                             if (is.null(name)) 
[13:36:34.518]                               next
[13:36:34.518]                             if (!grepl(pattern, name)) 
[13:36:34.518]                               next
[13:36:34.518]                             invokeRestart(restart)
[13:36:34.518]                             muffled <- TRUE
[13:36:34.518]                             break
[13:36:34.518]                           }
[13:36:34.518]                         }
[13:36:34.518]                       }
[13:36:34.518]                       invisible(muffled)
[13:36:34.518]                     }
[13:36:34.518]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.518]                   }
[13:36:34.518]                 }
[13:36:34.518]             }
[13:36:34.518]         }))
[13:36:34.518]     }, error = function(ex) {
[13:36:34.518]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.518]                 ...future.rng), started = ...future.startTime, 
[13:36:34.518]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.518]             version = "1.8"), class = "FutureResult")
[13:36:34.518]     }, finally = {
[13:36:34.518]         if (!identical(...future.workdir, getwd())) 
[13:36:34.518]             setwd(...future.workdir)
[13:36:34.518]         {
[13:36:34.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.518]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.518]             }
[13:36:34.518]             base::options(...future.oldOptions)
[13:36:34.518]             if (.Platform$OS.type == "windows") {
[13:36:34.518]                 old_names <- names(...future.oldEnvVars)
[13:36:34.518]                 envs <- base::Sys.getenv()
[13:36:34.518]                 names <- names(envs)
[13:36:34.518]                 common <- intersect(names, old_names)
[13:36:34.518]                 added <- setdiff(names, old_names)
[13:36:34.518]                 removed <- setdiff(old_names, names)
[13:36:34.518]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.518]                   envs[common]]
[13:36:34.518]                 NAMES <- toupper(changed)
[13:36:34.518]                 args <- list()
[13:36:34.518]                 for (kk in seq_along(NAMES)) {
[13:36:34.518]                   name <- changed[[kk]]
[13:36:34.518]                   NAME <- NAMES[[kk]]
[13:36:34.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.518]                     next
[13:36:34.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.518]                 }
[13:36:34.518]                 NAMES <- toupper(added)
[13:36:34.518]                 for (kk in seq_along(NAMES)) {
[13:36:34.518]                   name <- added[[kk]]
[13:36:34.518]                   NAME <- NAMES[[kk]]
[13:36:34.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.518]                     next
[13:36:34.518]                   args[[name]] <- ""
[13:36:34.518]                 }
[13:36:34.518]                 NAMES <- toupper(removed)
[13:36:34.518]                 for (kk in seq_along(NAMES)) {
[13:36:34.518]                   name <- removed[[kk]]
[13:36:34.518]                   NAME <- NAMES[[kk]]
[13:36:34.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.518]                     next
[13:36:34.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.518]                 }
[13:36:34.518]                 if (length(args) > 0) 
[13:36:34.518]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.518]             }
[13:36:34.518]             else {
[13:36:34.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.518]             }
[13:36:34.518]             {
[13:36:34.518]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.518]                   0L) {
[13:36:34.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.518]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.518]                   base::options(opts)
[13:36:34.518]                 }
[13:36:34.518]                 {
[13:36:34.518]                   {
[13:36:34.518]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.518]                     NULL
[13:36:34.518]                   }
[13:36:34.518]                   options(future.plan = NULL)
[13:36:34.518]                   if (is.na(NA_character_)) 
[13:36:34.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.518]                     .init = FALSE)
[13:36:34.518]                 }
[13:36:34.518]             }
[13:36:34.518]         }
[13:36:34.518]     })
[13:36:34.518]     if (TRUE) {
[13:36:34.518]         base::sink(type = "output", split = FALSE)
[13:36:34.518]         if (TRUE) {
[13:36:34.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.518]         }
[13:36:34.518]         else {
[13:36:34.518]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.518]         }
[13:36:34.518]         base::close(...future.stdout)
[13:36:34.518]         ...future.stdout <- NULL
[13:36:34.518]     }
[13:36:34.518]     ...future.result$conditions <- ...future.conditions
[13:36:34.518]     ...future.result$finished <- base::Sys.time()
[13:36:34.518]     ...future.result
[13:36:34.518] }
[13:36:34.522] requestCore(): workers = 2
[13:36:34.524] MulticoreFuture started
[13:36:34.524] - Launch lazy future ... done
[13:36:34.529] plan(): Setting new future strategy stack:
[13:36:34.530] run() for ‘MulticoreFuture’ ... done
List of 6
[13:36:34.530] List of future strategies:
[13:36:34.530] 1. sequential:
[13:36:34.530]    - args: function (..., envir = parent.frame())
[13:36:34.530]    - tweaked: FALSE
[13:36:34.530]    - call: NULL
 $ a:[13:36:34.531] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72e8e098> 
 $ c:[13:36:34.535] plan(): Setting new future strategy stack:
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a732f9480> 
 $  :[13:36:34.535] List of future strategies:
[13:36:34.535] 1. multicore:
[13:36:34.535]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.535]    - tweaked: FALSE
[13:36:34.535]    - call: plan(strategy)
 NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72e8e098> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a732f9480> 
 $  : NULL
 $  : NULL
 $  :[13:36:34.541] plan(): nbrOfWorkers() = 2
 num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:34.547] resolve() on list ...
[13:36:34.547]  recursive: 0
[13:36:34.547]  length: 6
[13:36:34.547]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:34.548] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.548] - nx: 6
[13:36:34.548] - relay: TRUE
[13:36:34.548] - stdout: TRUE
[13:36:34.548] - signal: TRUE
[13:36:34.548] - resignal: FALSE
[13:36:34.548] - force: TRUE
[13:36:34.549] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.549] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.549]  - until=2
[13:36:34.549]  - relaying element #2
[13:36:34.549] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.549] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.549] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.549]  length: 5 (resolved future 1)
[13:36:34.550] Future #2
[13:36:34.550] result() for MulticoreFuture ...
[13:36:34.551] result() for MulticoreFuture ...
[13:36:34.551] result() for MulticoreFuture ... done
[13:36:34.551] result() for MulticoreFuture ... done
[13:36:34.551] result() for MulticoreFuture ...
[13:36:34.551] result() for MulticoreFuture ... done
[13:36:34.552] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:34.552] - nx: 6
[13:36:34.552] - relay: TRUE
[13:36:34.552] - stdout: TRUE
[13:36:34.552] - signal: TRUE
[13:36:34.552] - resignal: FALSE
[13:36:34.552] - force: TRUE
[13:36:34.552] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.553] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.553]  - until=2
[13:36:34.553]  - relaying element #2
[13:36:34.553] result() for MulticoreFuture ...
[13:36:34.553] result() for MulticoreFuture ... done
[13:36:34.553] result() for MulticoreFuture ...
[13:36:34.553] result() for MulticoreFuture ... done
[13:36:34.554] result() for MulticoreFuture ...
[13:36:34.554] result() for MulticoreFuture ... done
[13:36:34.554] result() for MulticoreFuture ...
[13:36:34.554] result() for MulticoreFuture ... done
[13:36:34.554] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.554] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.554] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:34.554]  length: 4 (resolved future 2)
[13:36:34.555] Future #3
[13:36:34.555] result() for MulticoreFuture ...
[13:36:34.556] result() for MulticoreFuture ...
[13:36:34.556] result() for MulticoreFuture ... done
[13:36:34.556] result() for MulticoreFuture ... done
[13:36:34.556] result() for MulticoreFuture ...
[13:36:34.556] result() for MulticoreFuture ... done
[13:36:34.556] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:34.557] - nx: 6
[13:36:34.557] - relay: TRUE
[13:36:34.557] - stdout: TRUE
[13:36:34.557] - signal: TRUE
[13:36:34.557] - resignal: FALSE
[13:36:34.557] - force: TRUE
[13:36:34.557] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.557] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.557]  - until=3
[13:36:34.557]  - relaying element #3
[13:36:34.558] result() for MulticoreFuture ...
[13:36:34.558] result() for MulticoreFuture ... done
[13:36:34.558] result() for MulticoreFuture ...
[13:36:34.558] result() for MulticoreFuture ... done
[13:36:34.558] result() for MulticoreFuture ...
[13:36:34.558] result() for MulticoreFuture ... done
[13:36:34.558] result() for MulticoreFuture ...
[13:36:34.558] result() for MulticoreFuture ... done
[13:36:34.559] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.559] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.559] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:34.559]  length: 3 (resolved future 3)
[13:36:34.559] signalConditionsASAP(NULL, pos=4) ...
[13:36:34.559] - nx: 6
[13:36:34.559] - relay: TRUE
[13:36:34.559] - stdout: TRUE
[13:36:34.559] - signal: TRUE
[13:36:34.559] - resignal: FALSE
[13:36:34.560] - force: TRUE
[13:36:34.560] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.560] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.560]  - until=5
[13:36:34.560]  - relaying element #5
[13:36:34.560] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.560] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.560] signalConditionsASAP(NULL, pos=4) ... done
[13:36:34.561]  length: 2 (resolved future 4)
[13:36:34.561] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.561] - nx: 6
[13:36:34.561] - relay: TRUE
[13:36:34.561] - stdout: TRUE
[13:36:34.561] - signal: TRUE
[13:36:34.561] - resignal: FALSE
[13:36:34.561] - force: TRUE
[13:36:34.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.561] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.561]  - until=6
[13:36:34.562]  - relaying element #6
[13:36:34.562] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.562] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.562] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.562]  length: 1 (resolved future 5)
[13:36:34.562] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.562] - nx: 6
[13:36:34.562] - relay: TRUE
[13:36:34.562] - stdout: TRUE
[13:36:34.563] - signal: TRUE
[13:36:34.563] - resignal: FALSE
[13:36:34.563] - force: TRUE
[13:36:34.563] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.563] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.563]  - until=6
[13:36:34.563] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.563] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.563] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.563]  length: 0 (resolved future 6)
[13:36:34.564] Relaying remaining futures
[13:36:34.564] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.564] - nx: 6
[13:36:34.564] - relay: TRUE
[13:36:34.564] - stdout: TRUE
[13:36:34.564] - signal: TRUE
[13:36:34.564] - resignal: FALSE
[13:36:34.564] - force: TRUE
[13:36:34.564] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.564] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:34.565] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.565] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.565] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.565] resolve() on list ... DONE
[13:36:34.565] result() for MulticoreFuture ...
[13:36:34.565] result() for MulticoreFuture ... done
[13:36:34.565] result() for MulticoreFuture ...
[13:36:34.565] result() for MulticoreFuture ... done
[13:36:34.565] result() for MulticoreFuture ...
[13:36:34.565] result() for MulticoreFuture ... done
[13:36:34.566] result() for MulticoreFuture ...
[13:36:34.566] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:36:34.571] getGlobalsAndPackages() ...
[13:36:34.571] Searching for globals...
[13:36:34.572] 
[13:36:34.572] Searching for globals ... DONE
[13:36:34.572] - globals: [0] <none>
[13:36:34.572] getGlobalsAndPackages() ... DONE
[13:36:34.572] run() for ‘Future’ ...
[13:36:34.573] - state: ‘created’
[13:36:34.573] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.576] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.577]   - Field: ‘label’
[13:36:34.577]   - Field: ‘local’
[13:36:34.577]   - Field: ‘owner’
[13:36:34.577]   - Field: ‘envir’
[13:36:34.577]   - Field: ‘workers’
[13:36:34.577]   - Field: ‘packages’
[13:36:34.577]   - Field: ‘gc’
[13:36:34.577]   - Field: ‘job’
[13:36:34.577]   - Field: ‘conditions’
[13:36:34.578]   - Field: ‘expr’
[13:36:34.578]   - Field: ‘uuid’
[13:36:34.578]   - Field: ‘seed’
[13:36:34.578]   - Field: ‘version’
[13:36:34.578]   - Field: ‘result’
[13:36:34.578]   - Field: ‘asynchronous’
[13:36:34.578]   - Field: ‘calls’
[13:36:34.578]   - Field: ‘globals’
[13:36:34.578]   - Field: ‘stdout’
[13:36:34.578]   - Field: ‘earlySignal’
[13:36:34.579]   - Field: ‘lazy’
[13:36:34.579]   - Field: ‘state’
[13:36:34.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.579] - Launch lazy future ...
[13:36:34.579] Packages needed by the future expression (n = 0): <none>
[13:36:34.579] Packages needed by future strategies (n = 0): <none>
[13:36:34.580] {
[13:36:34.580]     {
[13:36:34.580]         {
[13:36:34.580]             ...future.startTime <- base::Sys.time()
[13:36:34.580]             {
[13:36:34.580]                 {
[13:36:34.580]                   {
[13:36:34.580]                     {
[13:36:34.580]                       base::local({
[13:36:34.580]                         has_future <- base::requireNamespace("future", 
[13:36:34.580]                           quietly = TRUE)
[13:36:34.580]                         if (has_future) {
[13:36:34.580]                           ns <- base::getNamespace("future")
[13:36:34.580]                           version <- ns[[".package"]][["version"]]
[13:36:34.580]                           if (is.null(version)) 
[13:36:34.580]                             version <- utils::packageVersion("future")
[13:36:34.580]                         }
[13:36:34.580]                         else {
[13:36:34.580]                           version <- NULL
[13:36:34.580]                         }
[13:36:34.580]                         if (!has_future || version < "1.8.0") {
[13:36:34.580]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.580]                             "", base::R.version$version.string), 
[13:36:34.580]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.580]                               "release", "version")], collapse = " "), 
[13:36:34.580]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.580]                             info)
[13:36:34.580]                           info <- base::paste(info, collapse = "; ")
[13:36:34.580]                           if (!has_future) {
[13:36:34.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.580]                               info)
[13:36:34.580]                           }
[13:36:34.580]                           else {
[13:36:34.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.580]                               info, version)
[13:36:34.580]                           }
[13:36:34.580]                           base::stop(msg)
[13:36:34.580]                         }
[13:36:34.580]                       })
[13:36:34.580]                     }
[13:36:34.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.580]                     base::options(mc.cores = 1L)
[13:36:34.580]                   }
[13:36:34.580]                   ...future.strategy.old <- future::plan("list")
[13:36:34.580]                   options(future.plan = NULL)
[13:36:34.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.580]                 }
[13:36:34.580]                 ...future.workdir <- getwd()
[13:36:34.580]             }
[13:36:34.580]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.580]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.580]         }
[13:36:34.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.580]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.580]             base::names(...future.oldOptions))
[13:36:34.580]     }
[13:36:34.580]     if (FALSE) {
[13:36:34.580]     }
[13:36:34.580]     else {
[13:36:34.580]         if (TRUE) {
[13:36:34.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.580]                 open = "w")
[13:36:34.580]         }
[13:36:34.580]         else {
[13:36:34.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.580]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.580]         }
[13:36:34.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.580]             base::sink(type = "output", split = FALSE)
[13:36:34.580]             base::close(...future.stdout)
[13:36:34.580]         }, add = TRUE)
[13:36:34.580]     }
[13:36:34.580]     ...future.frame <- base::sys.nframe()
[13:36:34.580]     ...future.conditions <- base::list()
[13:36:34.580]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.580]     if (FALSE) {
[13:36:34.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.580]     }
[13:36:34.580]     ...future.result <- base::tryCatch({
[13:36:34.580]         base::withCallingHandlers({
[13:36:34.580]             ...future.value <- base::withVisible(base::local({
[13:36:34.580]                 withCallingHandlers({
[13:36:34.580]                   2
[13:36:34.580]                 }, immediateCondition = function(cond) {
[13:36:34.580]                   save_rds <- function (object, pathname, ...) 
[13:36:34.580]                   {
[13:36:34.580]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.580]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.580]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.580]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.580]                         fi_tmp[["mtime"]])
[13:36:34.580]                     }
[13:36:34.580]                     tryCatch({
[13:36:34.580]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.580]                     }, error = function(ex) {
[13:36:34.580]                       msg <- conditionMessage(ex)
[13:36:34.580]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.580]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.580]                         fi_tmp[["mtime"]], msg)
[13:36:34.580]                       ex$message <- msg
[13:36:34.580]                       stop(ex)
[13:36:34.580]                     })
[13:36:34.580]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.580]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.580]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.580]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.580]                       fi <- file.info(pathname)
[13:36:34.580]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.580]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.580]                         fi[["size"]], fi[["mtime"]])
[13:36:34.580]                       stop(msg)
[13:36:34.580]                     }
[13:36:34.580]                     invisible(pathname)
[13:36:34.580]                   }
[13:36:34.580]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.580]                     rootPath = tempdir()) 
[13:36:34.580]                   {
[13:36:34.580]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.580]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.580]                       tmpdir = path, fileext = ".rds")
[13:36:34.580]                     save_rds(obj, file)
[13:36:34.580]                   }
[13:36:34.580]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.580]                   {
[13:36:34.580]                     inherits <- base::inherits
[13:36:34.580]                     invokeRestart <- base::invokeRestart
[13:36:34.580]                     is.null <- base::is.null
[13:36:34.580]                     muffled <- FALSE
[13:36:34.580]                     if (inherits(cond, "message")) {
[13:36:34.580]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.580]                       if (muffled) 
[13:36:34.580]                         invokeRestart("muffleMessage")
[13:36:34.580]                     }
[13:36:34.580]                     else if (inherits(cond, "warning")) {
[13:36:34.580]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.580]                       if (muffled) 
[13:36:34.580]                         invokeRestart("muffleWarning")
[13:36:34.580]                     }
[13:36:34.580]                     else if (inherits(cond, "condition")) {
[13:36:34.580]                       if (!is.null(pattern)) {
[13:36:34.580]                         computeRestarts <- base::computeRestarts
[13:36:34.580]                         grepl <- base::grepl
[13:36:34.580]                         restarts <- computeRestarts(cond)
[13:36:34.580]                         for (restart in restarts) {
[13:36:34.580]                           name <- restart$name
[13:36:34.580]                           if (is.null(name)) 
[13:36:34.580]                             next
[13:36:34.580]                           if (!grepl(pattern, name)) 
[13:36:34.580]                             next
[13:36:34.580]                           invokeRestart(restart)
[13:36:34.580]                           muffled <- TRUE
[13:36:34.580]                           break
[13:36:34.580]                         }
[13:36:34.580]                       }
[13:36:34.580]                     }
[13:36:34.580]                     invisible(muffled)
[13:36:34.580]                   }
[13:36:34.580]                   muffleCondition(cond)
[13:36:34.580]                 })
[13:36:34.580]             }))
[13:36:34.580]             future::FutureResult(value = ...future.value$value, 
[13:36:34.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.580]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.580]                     ...future.globalenv.names))
[13:36:34.580]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.580]         }, condition = base::local({
[13:36:34.580]             c <- base::c
[13:36:34.580]             inherits <- base::inherits
[13:36:34.580]             invokeRestart <- base::invokeRestart
[13:36:34.580]             length <- base::length
[13:36:34.580]             list <- base::list
[13:36:34.580]             seq.int <- base::seq.int
[13:36:34.580]             signalCondition <- base::signalCondition
[13:36:34.580]             sys.calls <- base::sys.calls
[13:36:34.580]             `[[` <- base::`[[`
[13:36:34.580]             `+` <- base::`+`
[13:36:34.580]             `<<-` <- base::`<<-`
[13:36:34.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.580]                   3L)]
[13:36:34.580]             }
[13:36:34.580]             function(cond) {
[13:36:34.580]                 is_error <- inherits(cond, "error")
[13:36:34.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.580]                   NULL)
[13:36:34.580]                 if (is_error) {
[13:36:34.580]                   sessionInformation <- function() {
[13:36:34.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.580]                       search = base::search(), system = base::Sys.info())
[13:36:34.580]                   }
[13:36:34.580]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.580]                     cond$call), session = sessionInformation(), 
[13:36:34.580]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.580]                   signalCondition(cond)
[13:36:34.580]                 }
[13:36:34.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.580]                 "immediateCondition"))) {
[13:36:34.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.580]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.580]                   if (TRUE && !signal) {
[13:36:34.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.580]                     {
[13:36:34.580]                       inherits <- base::inherits
[13:36:34.580]                       invokeRestart <- base::invokeRestart
[13:36:34.580]                       is.null <- base::is.null
[13:36:34.580]                       muffled <- FALSE
[13:36:34.580]                       if (inherits(cond, "message")) {
[13:36:34.580]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.580]                         if (muffled) 
[13:36:34.580]                           invokeRestart("muffleMessage")
[13:36:34.580]                       }
[13:36:34.580]                       else if (inherits(cond, "warning")) {
[13:36:34.580]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.580]                         if (muffled) 
[13:36:34.580]                           invokeRestart("muffleWarning")
[13:36:34.580]                       }
[13:36:34.580]                       else if (inherits(cond, "condition")) {
[13:36:34.580]                         if (!is.null(pattern)) {
[13:36:34.580]                           computeRestarts <- base::computeRestarts
[13:36:34.580]                           grepl <- base::grepl
[13:36:34.580]                           restarts <- computeRestarts(cond)
[13:36:34.580]                           for (restart in restarts) {
[13:36:34.580]                             name <- restart$name
[13:36:34.580]                             if (is.null(name)) 
[13:36:34.580]                               next
[13:36:34.580]                             if (!grepl(pattern, name)) 
[13:36:34.580]                               next
[13:36:34.580]                             invokeRestart(restart)
[13:36:34.580]                             muffled <- TRUE
[13:36:34.580]                             break
[13:36:34.580]                           }
[13:36:34.580]                         }
[13:36:34.580]                       }
[13:36:34.580]                       invisible(muffled)
[13:36:34.580]                     }
[13:36:34.580]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.580]                   }
[13:36:34.580]                 }
[13:36:34.580]                 else {
[13:36:34.580]                   if (TRUE) {
[13:36:34.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.580]                     {
[13:36:34.580]                       inherits <- base::inherits
[13:36:34.580]                       invokeRestart <- base::invokeRestart
[13:36:34.580]                       is.null <- base::is.null
[13:36:34.580]                       muffled <- FALSE
[13:36:34.580]                       if (inherits(cond, "message")) {
[13:36:34.580]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.580]                         if (muffled) 
[13:36:34.580]                           invokeRestart("muffleMessage")
[13:36:34.580]                       }
[13:36:34.580]                       else if (inherits(cond, "warning")) {
[13:36:34.580]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.580]                         if (muffled) 
[13:36:34.580]                           invokeRestart("muffleWarning")
[13:36:34.580]                       }
[13:36:34.580]                       else if (inherits(cond, "condition")) {
[13:36:34.580]                         if (!is.null(pattern)) {
[13:36:34.580]                           computeRestarts <- base::computeRestarts
[13:36:34.580]                           grepl <- base::grepl
[13:36:34.580]                           restarts <- computeRestarts(cond)
[13:36:34.580]                           for (restart in restarts) {
[13:36:34.580]                             name <- restart$name
[13:36:34.580]                             if (is.null(name)) 
[13:36:34.580]                               next
[13:36:34.580]                             if (!grepl(pattern, name)) 
[13:36:34.580]                               next
[13:36:34.580]                             invokeRestart(restart)
[13:36:34.580]                             muffled <- TRUE
[13:36:34.580]                             break
[13:36:34.580]                           }
[13:36:34.580]                         }
[13:36:34.580]                       }
[13:36:34.580]                       invisible(muffled)
[13:36:34.580]                     }
[13:36:34.580]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.580]                   }
[13:36:34.580]                 }
[13:36:34.580]             }
[13:36:34.580]         }))
[13:36:34.580]     }, error = function(ex) {
[13:36:34.580]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.580]                 ...future.rng), started = ...future.startTime, 
[13:36:34.580]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.580]             version = "1.8"), class = "FutureResult")
[13:36:34.580]     }, finally = {
[13:36:34.580]         if (!identical(...future.workdir, getwd())) 
[13:36:34.580]             setwd(...future.workdir)
[13:36:34.580]         {
[13:36:34.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.580]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.580]             }
[13:36:34.580]             base::options(...future.oldOptions)
[13:36:34.580]             if (.Platform$OS.type == "windows") {
[13:36:34.580]                 old_names <- names(...future.oldEnvVars)
[13:36:34.580]                 envs <- base::Sys.getenv()
[13:36:34.580]                 names <- names(envs)
[13:36:34.580]                 common <- intersect(names, old_names)
[13:36:34.580]                 added <- setdiff(names, old_names)
[13:36:34.580]                 removed <- setdiff(old_names, names)
[13:36:34.580]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.580]                   envs[common]]
[13:36:34.580]                 NAMES <- toupper(changed)
[13:36:34.580]                 args <- list()
[13:36:34.580]                 for (kk in seq_along(NAMES)) {
[13:36:34.580]                   name <- changed[[kk]]
[13:36:34.580]                   NAME <- NAMES[[kk]]
[13:36:34.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.580]                     next
[13:36:34.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.580]                 }
[13:36:34.580]                 NAMES <- toupper(added)
[13:36:34.580]                 for (kk in seq_along(NAMES)) {
[13:36:34.580]                   name <- added[[kk]]
[13:36:34.580]                   NAME <- NAMES[[kk]]
[13:36:34.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.580]                     next
[13:36:34.580]                   args[[name]] <- ""
[13:36:34.580]                 }
[13:36:34.580]                 NAMES <- toupper(removed)
[13:36:34.580]                 for (kk in seq_along(NAMES)) {
[13:36:34.580]                   name <- removed[[kk]]
[13:36:34.580]                   NAME <- NAMES[[kk]]
[13:36:34.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.580]                     next
[13:36:34.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.580]                 }
[13:36:34.580]                 if (length(args) > 0) 
[13:36:34.580]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.580]             }
[13:36:34.580]             else {
[13:36:34.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.580]             }
[13:36:34.580]             {
[13:36:34.580]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.580]                   0L) {
[13:36:34.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.580]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.580]                   base::options(opts)
[13:36:34.580]                 }
[13:36:34.580]                 {
[13:36:34.580]                   {
[13:36:34.580]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.580]                     NULL
[13:36:34.580]                   }
[13:36:34.580]                   options(future.plan = NULL)
[13:36:34.580]                   if (is.na(NA_character_)) 
[13:36:34.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.580]                     .init = FALSE)
[13:36:34.580]                 }
[13:36:34.580]             }
[13:36:34.580]         }
[13:36:34.580]     })
[13:36:34.580]     if (TRUE) {
[13:36:34.580]         base::sink(type = "output", split = FALSE)
[13:36:34.580]         if (TRUE) {
[13:36:34.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.580]         }
[13:36:34.580]         else {
[13:36:34.580]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.580]         }
[13:36:34.580]         base::close(...future.stdout)
[13:36:34.580]         ...future.stdout <- NULL
[13:36:34.580]     }
[13:36:34.580]     ...future.result$conditions <- ...future.conditions
[13:36:34.580]     ...future.result$finished <- base::Sys.time()
[13:36:34.580]     ...future.result
[13:36:34.580] }
[13:36:34.582] requestCore(): workers = 2
[13:36:34.584] MulticoreFuture started
[13:36:34.585] - Launch lazy future ... done
[13:36:34.585] run() for ‘MulticoreFuture’ ... done
[13:36:34.585] getGlobalsAndPackages() ...
[13:36:34.585] Searching for globals...
[13:36:34.585] plan(): Setting new future strategy stack:
[13:36:34.586] List of future strategies:
[13:36:34.586] 1. sequential:
[13:36:34.586]    - args: function (..., envir = parent.frame())
[13:36:34.586]    - tweaked: FALSE
[13:36:34.586]    - call: NULL
[13:36:34.586] 
[13:36:34.586] Searching for globals ... DONE
[13:36:34.587] plan(): nbrOfWorkers() = 1
[13:36:34.587] - globals: [0] <none>
[13:36:34.587] getGlobalsAndPackages() ... DONE
[13:36:34.587] run() for ‘Future’ ...
[13:36:34.588] - state: ‘created’
[13:36:34.588] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.589] plan(): Setting new future strategy stack:
[13:36:34.589] List of future strategies:
[13:36:34.589] 1. multicore:
[13:36:34.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.589]    - tweaked: FALSE
[13:36:34.589]    - call: plan(strategy)
[13:36:34.593] plan(): nbrOfWorkers() = 2
[13:36:34.594] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.594]   - Field: ‘label’
[13:36:34.594]   - Field: ‘local’
[13:36:34.595]   - Field: ‘owner’
[13:36:34.595]   - Field: ‘envir’
[13:36:34.595]   - Field: ‘workers’
[13:36:34.595]   - Field: ‘packages’
[13:36:34.595]   - Field: ‘gc’
[13:36:34.595]   - Field: ‘job’
[13:36:34.596]   - Field: ‘conditions’
[13:36:34.596]   - Field: ‘expr’
[13:36:34.596]   - Field: ‘uuid’
[13:36:34.596]   - Field: ‘seed’
[13:36:34.596]   - Field: ‘version’
[13:36:34.597]   - Field: ‘result’
[13:36:34.597]   - Field: ‘asynchronous’
[13:36:34.597]   - Field: ‘calls’
[13:36:34.597]   - Field: ‘globals’
[13:36:34.597]   - Field: ‘stdout’
[13:36:34.597]   - Field: ‘earlySignal’
[13:36:34.597]   - Field: ‘lazy’
[13:36:34.598]   - Field: ‘state’
[13:36:34.598] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.598] - Launch lazy future ...
[13:36:34.598] Packages needed by the future expression (n = 0): <none>
[13:36:34.599] Packages needed by future strategies (n = 0): <none>
[13:36:34.599] {
[13:36:34.599]     {
[13:36:34.599]         {
[13:36:34.599]             ...future.startTime <- base::Sys.time()
[13:36:34.599]             {
[13:36:34.599]                 {
[13:36:34.599]                   {
[13:36:34.599]                     {
[13:36:34.599]                       base::local({
[13:36:34.599]                         has_future <- base::requireNamespace("future", 
[13:36:34.599]                           quietly = TRUE)
[13:36:34.599]                         if (has_future) {
[13:36:34.599]                           ns <- base::getNamespace("future")
[13:36:34.599]                           version <- ns[[".package"]][["version"]]
[13:36:34.599]                           if (is.null(version)) 
[13:36:34.599]                             version <- utils::packageVersion("future")
[13:36:34.599]                         }
[13:36:34.599]                         else {
[13:36:34.599]                           version <- NULL
[13:36:34.599]                         }
[13:36:34.599]                         if (!has_future || version < "1.8.0") {
[13:36:34.599]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.599]                             "", base::R.version$version.string), 
[13:36:34.599]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.599]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.599]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.599]                               "release", "version")], collapse = " "), 
[13:36:34.599]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.599]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.599]                             info)
[13:36:34.599]                           info <- base::paste(info, collapse = "; ")
[13:36:34.599]                           if (!has_future) {
[13:36:34.599]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.599]                               info)
[13:36:34.599]                           }
[13:36:34.599]                           else {
[13:36:34.599]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.599]                               info, version)
[13:36:34.599]                           }
[13:36:34.599]                           base::stop(msg)
[13:36:34.599]                         }
[13:36:34.599]                       })
[13:36:34.599]                     }
[13:36:34.599]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.599]                     base::options(mc.cores = 1L)
[13:36:34.599]                   }
[13:36:34.599]                   ...future.strategy.old <- future::plan("list")
[13:36:34.599]                   options(future.plan = NULL)
[13:36:34.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.599]                 }
[13:36:34.599]                 ...future.workdir <- getwd()
[13:36:34.599]             }
[13:36:34.599]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.599]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.599]         }
[13:36:34.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.599]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.599]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.599]             base::names(...future.oldOptions))
[13:36:34.599]     }
[13:36:34.599]     if (FALSE) {
[13:36:34.599]     }
[13:36:34.599]     else {
[13:36:34.599]         if (TRUE) {
[13:36:34.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.599]                 open = "w")
[13:36:34.599]         }
[13:36:34.599]         else {
[13:36:34.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.599]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.599]         }
[13:36:34.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.599]             base::sink(type = "output", split = FALSE)
[13:36:34.599]             base::close(...future.stdout)
[13:36:34.599]         }, add = TRUE)
[13:36:34.599]     }
[13:36:34.599]     ...future.frame <- base::sys.nframe()
[13:36:34.599]     ...future.conditions <- base::list()
[13:36:34.599]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.599]     if (FALSE) {
[13:36:34.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.599]     }
[13:36:34.599]     ...future.result <- base::tryCatch({
[13:36:34.599]         base::withCallingHandlers({
[13:36:34.599]             ...future.value <- base::withVisible(base::local({
[13:36:34.599]                 withCallingHandlers({
[13:36:34.599]                   NULL
[13:36:34.599]                 }, immediateCondition = function(cond) {
[13:36:34.599]                   save_rds <- function (object, pathname, ...) 
[13:36:34.599]                   {
[13:36:34.599]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.599]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.599]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.599]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.599]                         fi_tmp[["mtime"]])
[13:36:34.599]                     }
[13:36:34.599]                     tryCatch({
[13:36:34.599]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.599]                     }, error = function(ex) {
[13:36:34.599]                       msg <- conditionMessage(ex)
[13:36:34.599]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.599]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.599]                         fi_tmp[["mtime"]], msg)
[13:36:34.599]                       ex$message <- msg
[13:36:34.599]                       stop(ex)
[13:36:34.599]                     })
[13:36:34.599]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.599]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.599]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.599]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.599]                       fi <- file.info(pathname)
[13:36:34.599]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.599]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.599]                         fi[["size"]], fi[["mtime"]])
[13:36:34.599]                       stop(msg)
[13:36:34.599]                     }
[13:36:34.599]                     invisible(pathname)
[13:36:34.599]                   }
[13:36:34.599]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.599]                     rootPath = tempdir()) 
[13:36:34.599]                   {
[13:36:34.599]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.599]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.599]                       tmpdir = path, fileext = ".rds")
[13:36:34.599]                     save_rds(obj, file)
[13:36:34.599]                   }
[13:36:34.599]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.599]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.599]                   {
[13:36:34.599]                     inherits <- base::inherits
[13:36:34.599]                     invokeRestart <- base::invokeRestart
[13:36:34.599]                     is.null <- base::is.null
[13:36:34.599]                     muffled <- FALSE
[13:36:34.599]                     if (inherits(cond, "message")) {
[13:36:34.599]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.599]                       if (muffled) 
[13:36:34.599]                         invokeRestart("muffleMessage")
[13:36:34.599]                     }
[13:36:34.599]                     else if (inherits(cond, "warning")) {
[13:36:34.599]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.599]                       if (muffled) 
[13:36:34.599]                         invokeRestart("muffleWarning")
[13:36:34.599]                     }
[13:36:34.599]                     else if (inherits(cond, "condition")) {
[13:36:34.599]                       if (!is.null(pattern)) {
[13:36:34.599]                         computeRestarts <- base::computeRestarts
[13:36:34.599]                         grepl <- base::grepl
[13:36:34.599]                         restarts <- computeRestarts(cond)
[13:36:34.599]                         for (restart in restarts) {
[13:36:34.599]                           name <- restart$name
[13:36:34.599]                           if (is.null(name)) 
[13:36:34.599]                             next
[13:36:34.599]                           if (!grepl(pattern, name)) 
[13:36:34.599]                             next
[13:36:34.599]                           invokeRestart(restart)
[13:36:34.599]                           muffled <- TRUE
[13:36:34.599]                           break
[13:36:34.599]                         }
[13:36:34.599]                       }
[13:36:34.599]                     }
[13:36:34.599]                     invisible(muffled)
[13:36:34.599]                   }
[13:36:34.599]                   muffleCondition(cond)
[13:36:34.599]                 })
[13:36:34.599]             }))
[13:36:34.599]             future::FutureResult(value = ...future.value$value, 
[13:36:34.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.599]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.599]                     ...future.globalenv.names))
[13:36:34.599]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.599]         }, condition = base::local({
[13:36:34.599]             c <- base::c
[13:36:34.599]             inherits <- base::inherits
[13:36:34.599]             invokeRestart <- base::invokeRestart
[13:36:34.599]             length <- base::length
[13:36:34.599]             list <- base::list
[13:36:34.599]             seq.int <- base::seq.int
[13:36:34.599]             signalCondition <- base::signalCondition
[13:36:34.599]             sys.calls <- base::sys.calls
[13:36:34.599]             `[[` <- base::`[[`
[13:36:34.599]             `+` <- base::`+`
[13:36:34.599]             `<<-` <- base::`<<-`
[13:36:34.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.599]                   3L)]
[13:36:34.599]             }
[13:36:34.599]             function(cond) {
[13:36:34.599]                 is_error <- inherits(cond, "error")
[13:36:34.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.599]                   NULL)
[13:36:34.599]                 if (is_error) {
[13:36:34.599]                   sessionInformation <- function() {
[13:36:34.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.599]                       search = base::search(), system = base::Sys.info())
[13:36:34.599]                   }
[13:36:34.599]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.599]                     cond$call), session = sessionInformation(), 
[13:36:34.599]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.599]                   signalCondition(cond)
[13:36:34.599]                 }
[13:36:34.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.599]                 "immediateCondition"))) {
[13:36:34.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.599]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.599]                   if (TRUE && !signal) {
[13:36:34.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.599]                     {
[13:36:34.599]                       inherits <- base::inherits
[13:36:34.599]                       invokeRestart <- base::invokeRestart
[13:36:34.599]                       is.null <- base::is.null
[13:36:34.599]                       muffled <- FALSE
[13:36:34.599]                       if (inherits(cond, "message")) {
[13:36:34.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.599]                         if (muffled) 
[13:36:34.599]                           invokeRestart("muffleMessage")
[13:36:34.599]                       }
[13:36:34.599]                       else if (inherits(cond, "warning")) {
[13:36:34.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.599]                         if (muffled) 
[13:36:34.599]                           invokeRestart("muffleWarning")
[13:36:34.599]                       }
[13:36:34.599]                       else if (inherits(cond, "condition")) {
[13:36:34.599]                         if (!is.null(pattern)) {
[13:36:34.599]                           computeRestarts <- base::computeRestarts
[13:36:34.599]                           grepl <- base::grepl
[13:36:34.599]                           restarts <- computeRestarts(cond)
[13:36:34.599]                           for (restart in restarts) {
[13:36:34.599]                             name <- restart$name
[13:36:34.599]                             if (is.null(name)) 
[13:36:34.599]                               next
[13:36:34.599]                             if (!grepl(pattern, name)) 
[13:36:34.599]                               next
[13:36:34.599]                             invokeRestart(restart)
[13:36:34.599]                             muffled <- TRUE
[13:36:34.599]                             break
[13:36:34.599]                           }
[13:36:34.599]                         }
[13:36:34.599]                       }
[13:36:34.599]                       invisible(muffled)
[13:36:34.599]                     }
[13:36:34.599]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.599]                   }
[13:36:34.599]                 }
[13:36:34.599]                 else {
[13:36:34.599]                   if (TRUE) {
[13:36:34.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.599]                     {
[13:36:34.599]                       inherits <- base::inherits
[13:36:34.599]                       invokeRestart <- base::invokeRestart
[13:36:34.599]                       is.null <- base::is.null
[13:36:34.599]                       muffled <- FALSE
[13:36:34.599]                       if (inherits(cond, "message")) {
[13:36:34.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.599]                         if (muffled) 
[13:36:34.599]                           invokeRestart("muffleMessage")
[13:36:34.599]                       }
[13:36:34.599]                       else if (inherits(cond, "warning")) {
[13:36:34.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.599]                         if (muffled) 
[13:36:34.599]                           invokeRestart("muffleWarning")
[13:36:34.599]                       }
[13:36:34.599]                       else if (inherits(cond, "condition")) {
[13:36:34.599]                         if (!is.null(pattern)) {
[13:36:34.599]                           computeRestarts <- base::computeRestarts
[13:36:34.599]                           grepl <- base::grepl
[13:36:34.599]                           restarts <- computeRestarts(cond)
[13:36:34.599]                           for (restart in restarts) {
[13:36:34.599]                             name <- restart$name
[13:36:34.599]                             if (is.null(name)) 
[13:36:34.599]                               next
[13:36:34.599]                             if (!grepl(pattern, name)) 
[13:36:34.599]                               next
[13:36:34.599]                             invokeRestart(restart)
[13:36:34.599]                             muffled <- TRUE
[13:36:34.599]                             break
[13:36:34.599]                           }
[13:36:34.599]                         }
[13:36:34.599]                       }
[13:36:34.599]                       invisible(muffled)
[13:36:34.599]                     }
[13:36:34.599]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.599]                   }
[13:36:34.599]                 }
[13:36:34.599]             }
[13:36:34.599]         }))
[13:36:34.599]     }, error = function(ex) {
[13:36:34.599]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.599]                 ...future.rng), started = ...future.startTime, 
[13:36:34.599]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.599]             version = "1.8"), class = "FutureResult")
[13:36:34.599]     }, finally = {
[13:36:34.599]         if (!identical(...future.workdir, getwd())) 
[13:36:34.599]             setwd(...future.workdir)
[13:36:34.599]         {
[13:36:34.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.599]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.599]             }
[13:36:34.599]             base::options(...future.oldOptions)
[13:36:34.599]             if (.Platform$OS.type == "windows") {
[13:36:34.599]                 old_names <- names(...future.oldEnvVars)
[13:36:34.599]                 envs <- base::Sys.getenv()
[13:36:34.599]                 names <- names(envs)
[13:36:34.599]                 common <- intersect(names, old_names)
[13:36:34.599]                 added <- setdiff(names, old_names)
[13:36:34.599]                 removed <- setdiff(old_names, names)
[13:36:34.599]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.599]                   envs[common]]
[13:36:34.599]                 NAMES <- toupper(changed)
[13:36:34.599]                 args <- list()
[13:36:34.599]                 for (kk in seq_along(NAMES)) {
[13:36:34.599]                   name <- changed[[kk]]
[13:36:34.599]                   NAME <- NAMES[[kk]]
[13:36:34.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.599]                     next
[13:36:34.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.599]                 }
[13:36:34.599]                 NAMES <- toupper(added)
[13:36:34.599]                 for (kk in seq_along(NAMES)) {
[13:36:34.599]                   name <- added[[kk]]
[13:36:34.599]                   NAME <- NAMES[[kk]]
[13:36:34.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.599]                     next
[13:36:34.599]                   args[[name]] <- ""
[13:36:34.599]                 }
[13:36:34.599]                 NAMES <- toupper(removed)
[13:36:34.599]                 for (kk in seq_along(NAMES)) {
[13:36:34.599]                   name <- removed[[kk]]
[13:36:34.599]                   NAME <- NAMES[[kk]]
[13:36:34.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.599]                     next
[13:36:34.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.599]                 }
[13:36:34.599]                 if (length(args) > 0) 
[13:36:34.599]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.599]             }
[13:36:34.599]             else {
[13:36:34.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.599]             }
[13:36:34.599]             {
[13:36:34.599]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.599]                   0L) {
[13:36:34.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.599]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.599]                   base::options(opts)
[13:36:34.599]                 }
[13:36:34.599]                 {
[13:36:34.599]                   {
[13:36:34.599]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.599]                     NULL
[13:36:34.599]                   }
[13:36:34.599]                   options(future.plan = NULL)
[13:36:34.599]                   if (is.na(NA_character_)) 
[13:36:34.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.599]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.599]                     .init = FALSE)
[13:36:34.599]                 }
[13:36:34.599]             }
[13:36:34.599]         }
[13:36:34.599]     })
[13:36:34.599]     if (TRUE) {
[13:36:34.599]         base::sink(type = "output", split = FALSE)
[13:36:34.599]         if (TRUE) {
[13:36:34.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.599]         }
[13:36:34.599]         else {
[13:36:34.599]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.599]         }
[13:36:34.599]         base::close(...future.stdout)
[13:36:34.599]         ...future.stdout <- NULL
[13:36:34.599]     }
[13:36:34.599]     ...future.result$conditions <- ...future.conditions
[13:36:34.599]     ...future.result$finished <- base::Sys.time()
[13:36:34.599]     ...future.result
[13:36:34.599] }
[13:36:34.603] requestCore(): workers = 2
[13:36:34.605] MulticoreFuture started
[13:36:34.605] - Launch lazy future ... done
[13:36:34.605] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[13:36:34.606] plan(): Setting new future strategy stack:
[13:36:34.606] List of future strategies:
[13:36:34.606] 1. sequential:
[13:36:34.606]    - args: function (..., envir = parent.frame())
[13:36:34.606]    - tweaked: FALSE
[13:36:34.606]    - call: NULL
 num 1
 $ b:[13:36:34.607] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72604c80> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a717ffa40> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:36:34.609] plan(): Setting new future strategy stack:
List of 6
 $ a:[13:36:34.610] List of future strategies:
[13:36:34.610] 1. multicore:
[13:36:34.610]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.610]    - tweaked: FALSE
[13:36:34.610]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72604c80> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a717ffa40> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:36:34.615] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:34.618] resolve() on list ...
[13:36:34.618]  recursive: 0
[13:36:34.619]  length: 6
[13:36:34.619]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:34.619] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.619] - nx: 6
[13:36:34.619] - relay: TRUE
[13:36:34.619] - stdout: TRUE
[13:36:34.620] - signal: TRUE
[13:36:34.620] - resignal: FALSE
[13:36:34.620] - force: TRUE
[13:36:34.620] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.620] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.620]  - until=2
[13:36:34.620]  - relaying element #2
[13:36:34.621] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.621] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.621] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.621]  length: 5 (resolved future 1)
[13:36:34.621] Future #2
[13:36:34.621] result() for MulticoreFuture ...
[13:36:34.627] result() for MulticoreFuture ...
[13:36:34.627] result() for MulticoreFuture ... done
[13:36:34.628] result() for MulticoreFuture ... done
[13:36:34.628] result() for MulticoreFuture ...
[13:36:34.628] result() for MulticoreFuture ... done
[13:36:34.629] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:34.629] - nx: 6
[13:36:34.629] - relay: TRUE
[13:36:34.630] - stdout: TRUE
[13:36:34.630] - signal: TRUE
[13:36:34.630] - resignal: FALSE
[13:36:34.631] - force: TRUE
[13:36:34.631] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.631] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.631]  - until=2
[13:36:34.632]  - relaying element #2
[13:36:34.632] result() for MulticoreFuture ...
[13:36:34.632] result() for MulticoreFuture ... done
[13:36:34.632] result() for MulticoreFuture ...
[13:36:34.632] result() for MulticoreFuture ... done
[13:36:34.632] result() for MulticoreFuture ...
[13:36:34.633] result() for MulticoreFuture ... done
[13:36:34.633] result() for MulticoreFuture ...
[13:36:34.633] result() for MulticoreFuture ... done
[13:36:34.633] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.633] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.633] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:34.634]  length: 4 (resolved future 2)
[13:36:34.634] Future #3
[13:36:34.634] result() for MulticoreFuture ...
[13:36:34.635] result() for MulticoreFuture ...
[13:36:34.635] result() for MulticoreFuture ... done
[13:36:34.636] result() for MulticoreFuture ... done
[13:36:34.636] result() for MulticoreFuture ...
[13:36:34.636] result() for MulticoreFuture ... done
[13:36:34.636] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:34.636] - nx: 6
[13:36:34.636] - relay: TRUE
[13:36:34.636] - stdout: TRUE
[13:36:34.636] - signal: TRUE
[13:36:34.637] - resignal: FALSE
[13:36:34.637] - force: TRUE
[13:36:34.637] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.637] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.637]  - until=3
[13:36:34.637]  - relaying element #3
[13:36:34.637] result() for MulticoreFuture ...
[13:36:34.637] result() for MulticoreFuture ... done
[13:36:34.638] result() for MulticoreFuture ...
[13:36:34.638] result() for MulticoreFuture ... done
[13:36:34.638] result() for MulticoreFuture ...
[13:36:34.638] result() for MulticoreFuture ... done
[13:36:34.638] result() for MulticoreFuture ...
[13:36:34.638] result() for MulticoreFuture ... done
[13:36:34.638] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.638] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.639] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:34.639]  length: 3 (resolved future 3)
[13:36:34.639] signalConditionsASAP(NULL, pos=4) ...
[13:36:34.639] - nx: 6
[13:36:34.639] - relay: TRUE
[13:36:34.639] - stdout: TRUE
[13:36:34.639] - signal: TRUE
[13:36:34.639] - resignal: FALSE
[13:36:34.639] - force: TRUE
[13:36:34.640] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.640] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.640]  - until=5
[13:36:34.640]  - relaying element #5
[13:36:34.640] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.640] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.640] signalConditionsASAP(NULL, pos=4) ... done
[13:36:34.640]  length: 2 (resolved future 4)
[13:36:34.641] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.641] - nx: 6
[13:36:34.641] - relay: TRUE
[13:36:34.641] - stdout: TRUE
[13:36:34.641] - signal: TRUE
[13:36:34.641] - resignal: FALSE
[13:36:34.641] - force: TRUE
[13:36:34.641] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.641] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.641]  - until=6
[13:36:34.642]  - relaying element #6
[13:36:34.642] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.642] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.642] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.642]  length: 1 (resolved future 5)
[13:36:34.642] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.642] - nx: 6
[13:36:34.642] - relay: TRUE
[13:36:34.642] - stdout: TRUE
[13:36:34.643] - signal: TRUE
[13:36:34.643] - resignal: FALSE
[13:36:34.643] - force: TRUE
[13:36:34.643] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.643] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.643]  - until=6
[13:36:34.643] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.643] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.643] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.643]  length: 0 (resolved future 6)
[13:36:34.644] Relaying remaining futures
[13:36:34.644] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.644] - nx: 6
[13:36:34.644] - relay: TRUE
[13:36:34.644] - stdout: TRUE
[13:36:34.644] - signal: TRUE
[13:36:34.644] - resignal: FALSE
[13:36:34.644] - force: TRUE
[13:36:34.644] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.644] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:34.645] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.645] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.645] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.645] resolve() on list ... DONE
[13:36:34.645] result() for MulticoreFuture ...
[13:36:34.645] result() for MulticoreFuture ... done
[13:36:34.645] result() for MulticoreFuture ...
[13:36:34.645] result() for MulticoreFuture ... done
[13:36:34.645] result() for MulticoreFuture ...
[13:36:34.645] result() for MulticoreFuture ... done
[13:36:34.646] result() for MulticoreFuture ...
[13:36:34.646] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:36:34.649] getGlobalsAndPackages() ...
[13:36:34.649] Searching for globals...
[13:36:34.649] 
[13:36:34.650] Searching for globals ... DONE
[13:36:34.650] - globals: [0] <none>
[13:36:34.650] getGlobalsAndPackages() ... DONE
[13:36:34.650] run() for ‘Future’ ...
[13:36:34.650] - state: ‘created’
[13:36:34.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.654] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.654]   - Field: ‘label’
[13:36:34.654]   - Field: ‘local’
[13:36:34.654]   - Field: ‘owner’
[13:36:34.655]   - Field: ‘envir’
[13:36:34.655]   - Field: ‘workers’
[13:36:34.655]   - Field: ‘packages’
[13:36:34.655]   - Field: ‘gc’
[13:36:34.655]   - Field: ‘job’
[13:36:34.655]   - Field: ‘conditions’
[13:36:34.655]   - Field: ‘expr’
[13:36:34.655]   - Field: ‘uuid’
[13:36:34.655]   - Field: ‘seed’
[13:36:34.655]   - Field: ‘version’
[13:36:34.656]   - Field: ‘result’
[13:36:34.656]   - Field: ‘asynchronous’
[13:36:34.656]   - Field: ‘calls’
[13:36:34.656]   - Field: ‘globals’
[13:36:34.656]   - Field: ‘stdout’
[13:36:34.656]   - Field: ‘earlySignal’
[13:36:34.656]   - Field: ‘lazy’
[13:36:34.656]   - Field: ‘state’
[13:36:34.656] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.656] - Launch lazy future ...
[13:36:34.657] Packages needed by the future expression (n = 0): <none>
[13:36:34.657] Packages needed by future strategies (n = 0): <none>
[13:36:34.657] {
[13:36:34.657]     {
[13:36:34.657]         {
[13:36:34.657]             ...future.startTime <- base::Sys.time()
[13:36:34.657]             {
[13:36:34.657]                 {
[13:36:34.657]                   {
[13:36:34.657]                     {
[13:36:34.657]                       base::local({
[13:36:34.657]                         has_future <- base::requireNamespace("future", 
[13:36:34.657]                           quietly = TRUE)
[13:36:34.657]                         if (has_future) {
[13:36:34.657]                           ns <- base::getNamespace("future")
[13:36:34.657]                           version <- ns[[".package"]][["version"]]
[13:36:34.657]                           if (is.null(version)) 
[13:36:34.657]                             version <- utils::packageVersion("future")
[13:36:34.657]                         }
[13:36:34.657]                         else {
[13:36:34.657]                           version <- NULL
[13:36:34.657]                         }
[13:36:34.657]                         if (!has_future || version < "1.8.0") {
[13:36:34.657]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.657]                             "", base::R.version$version.string), 
[13:36:34.657]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.657]                               "release", "version")], collapse = " "), 
[13:36:34.657]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.657]                             info)
[13:36:34.657]                           info <- base::paste(info, collapse = "; ")
[13:36:34.657]                           if (!has_future) {
[13:36:34.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.657]                               info)
[13:36:34.657]                           }
[13:36:34.657]                           else {
[13:36:34.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.657]                               info, version)
[13:36:34.657]                           }
[13:36:34.657]                           base::stop(msg)
[13:36:34.657]                         }
[13:36:34.657]                       })
[13:36:34.657]                     }
[13:36:34.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.657]                     base::options(mc.cores = 1L)
[13:36:34.657]                   }
[13:36:34.657]                   ...future.strategy.old <- future::plan("list")
[13:36:34.657]                   options(future.plan = NULL)
[13:36:34.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.657]                 }
[13:36:34.657]                 ...future.workdir <- getwd()
[13:36:34.657]             }
[13:36:34.657]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.657]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.657]         }
[13:36:34.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.657]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.657]             base::names(...future.oldOptions))
[13:36:34.657]     }
[13:36:34.657]     if (FALSE) {
[13:36:34.657]     }
[13:36:34.657]     else {
[13:36:34.657]         if (TRUE) {
[13:36:34.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.657]                 open = "w")
[13:36:34.657]         }
[13:36:34.657]         else {
[13:36:34.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.657]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.657]         }
[13:36:34.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.657]             base::sink(type = "output", split = FALSE)
[13:36:34.657]             base::close(...future.stdout)
[13:36:34.657]         }, add = TRUE)
[13:36:34.657]     }
[13:36:34.657]     ...future.frame <- base::sys.nframe()
[13:36:34.657]     ...future.conditions <- base::list()
[13:36:34.657]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.657]     if (FALSE) {
[13:36:34.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.657]     }
[13:36:34.657]     ...future.result <- base::tryCatch({
[13:36:34.657]         base::withCallingHandlers({
[13:36:34.657]             ...future.value <- base::withVisible(base::local({
[13:36:34.657]                 withCallingHandlers({
[13:36:34.657]                   2
[13:36:34.657]                 }, immediateCondition = function(cond) {
[13:36:34.657]                   save_rds <- function (object, pathname, ...) 
[13:36:34.657]                   {
[13:36:34.657]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.657]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.657]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.657]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.657]                         fi_tmp[["mtime"]])
[13:36:34.657]                     }
[13:36:34.657]                     tryCatch({
[13:36:34.657]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.657]                     }, error = function(ex) {
[13:36:34.657]                       msg <- conditionMessage(ex)
[13:36:34.657]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.657]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.657]                         fi_tmp[["mtime"]], msg)
[13:36:34.657]                       ex$message <- msg
[13:36:34.657]                       stop(ex)
[13:36:34.657]                     })
[13:36:34.657]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.657]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.657]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.657]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.657]                       fi <- file.info(pathname)
[13:36:34.657]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.657]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.657]                         fi[["size"]], fi[["mtime"]])
[13:36:34.657]                       stop(msg)
[13:36:34.657]                     }
[13:36:34.657]                     invisible(pathname)
[13:36:34.657]                   }
[13:36:34.657]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.657]                     rootPath = tempdir()) 
[13:36:34.657]                   {
[13:36:34.657]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.657]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.657]                       tmpdir = path, fileext = ".rds")
[13:36:34.657]                     save_rds(obj, file)
[13:36:34.657]                   }
[13:36:34.657]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.657]                   {
[13:36:34.657]                     inherits <- base::inherits
[13:36:34.657]                     invokeRestart <- base::invokeRestart
[13:36:34.657]                     is.null <- base::is.null
[13:36:34.657]                     muffled <- FALSE
[13:36:34.657]                     if (inherits(cond, "message")) {
[13:36:34.657]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.657]                       if (muffled) 
[13:36:34.657]                         invokeRestart("muffleMessage")
[13:36:34.657]                     }
[13:36:34.657]                     else if (inherits(cond, "warning")) {
[13:36:34.657]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.657]                       if (muffled) 
[13:36:34.657]                         invokeRestart("muffleWarning")
[13:36:34.657]                     }
[13:36:34.657]                     else if (inherits(cond, "condition")) {
[13:36:34.657]                       if (!is.null(pattern)) {
[13:36:34.657]                         computeRestarts <- base::computeRestarts
[13:36:34.657]                         grepl <- base::grepl
[13:36:34.657]                         restarts <- computeRestarts(cond)
[13:36:34.657]                         for (restart in restarts) {
[13:36:34.657]                           name <- restart$name
[13:36:34.657]                           if (is.null(name)) 
[13:36:34.657]                             next
[13:36:34.657]                           if (!grepl(pattern, name)) 
[13:36:34.657]                             next
[13:36:34.657]                           invokeRestart(restart)
[13:36:34.657]                           muffled <- TRUE
[13:36:34.657]                           break
[13:36:34.657]                         }
[13:36:34.657]                       }
[13:36:34.657]                     }
[13:36:34.657]                     invisible(muffled)
[13:36:34.657]                   }
[13:36:34.657]                   muffleCondition(cond)
[13:36:34.657]                 })
[13:36:34.657]             }))
[13:36:34.657]             future::FutureResult(value = ...future.value$value, 
[13:36:34.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.657]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.657]                     ...future.globalenv.names))
[13:36:34.657]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.657]         }, condition = base::local({
[13:36:34.657]             c <- base::c
[13:36:34.657]             inherits <- base::inherits
[13:36:34.657]             invokeRestart <- base::invokeRestart
[13:36:34.657]             length <- base::length
[13:36:34.657]             list <- base::list
[13:36:34.657]             seq.int <- base::seq.int
[13:36:34.657]             signalCondition <- base::signalCondition
[13:36:34.657]             sys.calls <- base::sys.calls
[13:36:34.657]             `[[` <- base::`[[`
[13:36:34.657]             `+` <- base::`+`
[13:36:34.657]             `<<-` <- base::`<<-`
[13:36:34.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.657]                   3L)]
[13:36:34.657]             }
[13:36:34.657]             function(cond) {
[13:36:34.657]                 is_error <- inherits(cond, "error")
[13:36:34.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.657]                   NULL)
[13:36:34.657]                 if (is_error) {
[13:36:34.657]                   sessionInformation <- function() {
[13:36:34.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.657]                       search = base::search(), system = base::Sys.info())
[13:36:34.657]                   }
[13:36:34.657]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.657]                     cond$call), session = sessionInformation(), 
[13:36:34.657]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.657]                   signalCondition(cond)
[13:36:34.657]                 }
[13:36:34.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.657]                 "immediateCondition"))) {
[13:36:34.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.657]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.657]                   if (TRUE && !signal) {
[13:36:34.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.657]                     {
[13:36:34.657]                       inherits <- base::inherits
[13:36:34.657]                       invokeRestart <- base::invokeRestart
[13:36:34.657]                       is.null <- base::is.null
[13:36:34.657]                       muffled <- FALSE
[13:36:34.657]                       if (inherits(cond, "message")) {
[13:36:34.657]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.657]                         if (muffled) 
[13:36:34.657]                           invokeRestart("muffleMessage")
[13:36:34.657]                       }
[13:36:34.657]                       else if (inherits(cond, "warning")) {
[13:36:34.657]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.657]                         if (muffled) 
[13:36:34.657]                           invokeRestart("muffleWarning")
[13:36:34.657]                       }
[13:36:34.657]                       else if (inherits(cond, "condition")) {
[13:36:34.657]                         if (!is.null(pattern)) {
[13:36:34.657]                           computeRestarts <- base::computeRestarts
[13:36:34.657]                           grepl <- base::grepl
[13:36:34.657]                           restarts <- computeRestarts(cond)
[13:36:34.657]                           for (restart in restarts) {
[13:36:34.657]                             name <- restart$name
[13:36:34.657]                             if (is.null(name)) 
[13:36:34.657]                               next
[13:36:34.657]                             if (!grepl(pattern, name)) 
[13:36:34.657]                               next
[13:36:34.657]                             invokeRestart(restart)
[13:36:34.657]                             muffled <- TRUE
[13:36:34.657]                             break
[13:36:34.657]                           }
[13:36:34.657]                         }
[13:36:34.657]                       }
[13:36:34.657]                       invisible(muffled)
[13:36:34.657]                     }
[13:36:34.657]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.657]                   }
[13:36:34.657]                 }
[13:36:34.657]                 else {
[13:36:34.657]                   if (TRUE) {
[13:36:34.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.657]                     {
[13:36:34.657]                       inherits <- base::inherits
[13:36:34.657]                       invokeRestart <- base::invokeRestart
[13:36:34.657]                       is.null <- base::is.null
[13:36:34.657]                       muffled <- FALSE
[13:36:34.657]                       if (inherits(cond, "message")) {
[13:36:34.657]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.657]                         if (muffled) 
[13:36:34.657]                           invokeRestart("muffleMessage")
[13:36:34.657]                       }
[13:36:34.657]                       else if (inherits(cond, "warning")) {
[13:36:34.657]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.657]                         if (muffled) 
[13:36:34.657]                           invokeRestart("muffleWarning")
[13:36:34.657]                       }
[13:36:34.657]                       else if (inherits(cond, "condition")) {
[13:36:34.657]                         if (!is.null(pattern)) {
[13:36:34.657]                           computeRestarts <- base::computeRestarts
[13:36:34.657]                           grepl <- base::grepl
[13:36:34.657]                           restarts <- computeRestarts(cond)
[13:36:34.657]                           for (restart in restarts) {
[13:36:34.657]                             name <- restart$name
[13:36:34.657]                             if (is.null(name)) 
[13:36:34.657]                               next
[13:36:34.657]                             if (!grepl(pattern, name)) 
[13:36:34.657]                               next
[13:36:34.657]                             invokeRestart(restart)
[13:36:34.657]                             muffled <- TRUE
[13:36:34.657]                             break
[13:36:34.657]                           }
[13:36:34.657]                         }
[13:36:34.657]                       }
[13:36:34.657]                       invisible(muffled)
[13:36:34.657]                     }
[13:36:34.657]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.657]                   }
[13:36:34.657]                 }
[13:36:34.657]             }
[13:36:34.657]         }))
[13:36:34.657]     }, error = function(ex) {
[13:36:34.657]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.657]                 ...future.rng), started = ...future.startTime, 
[13:36:34.657]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.657]             version = "1.8"), class = "FutureResult")
[13:36:34.657]     }, finally = {
[13:36:34.657]         if (!identical(...future.workdir, getwd())) 
[13:36:34.657]             setwd(...future.workdir)
[13:36:34.657]         {
[13:36:34.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.657]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.657]             }
[13:36:34.657]             base::options(...future.oldOptions)
[13:36:34.657]             if (.Platform$OS.type == "windows") {
[13:36:34.657]                 old_names <- names(...future.oldEnvVars)
[13:36:34.657]                 envs <- base::Sys.getenv()
[13:36:34.657]                 names <- names(envs)
[13:36:34.657]                 common <- intersect(names, old_names)
[13:36:34.657]                 added <- setdiff(names, old_names)
[13:36:34.657]                 removed <- setdiff(old_names, names)
[13:36:34.657]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.657]                   envs[common]]
[13:36:34.657]                 NAMES <- toupper(changed)
[13:36:34.657]                 args <- list()
[13:36:34.657]                 for (kk in seq_along(NAMES)) {
[13:36:34.657]                   name <- changed[[kk]]
[13:36:34.657]                   NAME <- NAMES[[kk]]
[13:36:34.657]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.657]                     next
[13:36:34.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.657]                 }
[13:36:34.657]                 NAMES <- toupper(added)
[13:36:34.657]                 for (kk in seq_along(NAMES)) {
[13:36:34.657]                   name <- added[[kk]]
[13:36:34.657]                   NAME <- NAMES[[kk]]
[13:36:34.657]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.657]                     next
[13:36:34.657]                   args[[name]] <- ""
[13:36:34.657]                 }
[13:36:34.657]                 NAMES <- toupper(removed)
[13:36:34.657]                 for (kk in seq_along(NAMES)) {
[13:36:34.657]                   name <- removed[[kk]]
[13:36:34.657]                   NAME <- NAMES[[kk]]
[13:36:34.657]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.657]                     next
[13:36:34.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.657]                 }
[13:36:34.657]                 if (length(args) > 0) 
[13:36:34.657]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.657]             }
[13:36:34.657]             else {
[13:36:34.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.657]             }
[13:36:34.657]             {
[13:36:34.657]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.657]                   0L) {
[13:36:34.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.657]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.657]                   base::options(opts)
[13:36:34.657]                 }
[13:36:34.657]                 {
[13:36:34.657]                   {
[13:36:34.657]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.657]                     NULL
[13:36:34.657]                   }
[13:36:34.657]                   options(future.plan = NULL)
[13:36:34.657]                   if (is.na(NA_character_)) 
[13:36:34.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.657]                     .init = FALSE)
[13:36:34.657]                 }
[13:36:34.657]             }
[13:36:34.657]         }
[13:36:34.657]     })
[13:36:34.657]     if (TRUE) {
[13:36:34.657]         base::sink(type = "output", split = FALSE)
[13:36:34.657]         if (TRUE) {
[13:36:34.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.657]         }
[13:36:34.657]         else {
[13:36:34.657]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.657]         }
[13:36:34.657]         base::close(...future.stdout)
[13:36:34.657]         ...future.stdout <- NULL
[13:36:34.657]     }
[13:36:34.657]     ...future.result$conditions <- ...future.conditions
[13:36:34.657]     ...future.result$finished <- base::Sys.time()
[13:36:34.657]     ...future.result
[13:36:34.657] }
[13:36:34.660] requestCore(): workers = 2
[13:36:34.661] MulticoreFuture started
[13:36:34.662] - Launch lazy future ... done
[13:36:34.662] run() for ‘MulticoreFuture’ ... done
[13:36:34.662] getGlobalsAndPackages() ...
[13:36:34.662] Searching for globals...
[13:36:34.663] plan(): Setting new future strategy stack:
[13:36:34.663] 
[13:36:34.663] List of future strategies:
[13:36:34.663] 1. sequential:
[13:36:34.663]    - args: function (..., envir = parent.frame())
[13:36:34.663]    - tweaked: FALSE
[13:36:34.663]    - call: NULL
[13:36:34.664] Searching for globals ... DONE
[13:36:34.664] - globals: [0] <none>
[13:36:34.664] plan(): nbrOfWorkers() = 1
[13:36:34.664] getGlobalsAndPackages() ... DONE
[13:36:34.669] plan(): Setting new future strategy stack:
[13:36:34.668] run() for ‘Future’ ...
[13:36:34.669] - state: ‘created’
[13:36:34.669] List of future strategies:
[13:36:34.669] 1. multicore:
[13:36:34.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.669]    - tweaked: FALSE
[13:36:34.669]    - call: plan(strategy)
[13:36:34.669] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.675] plan(): nbrOfWorkers() = 2
[13:36:34.675] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.676]   - Field: ‘label’
[13:36:34.676]   - Field: ‘local’
[13:36:34.676]   - Field: ‘owner’
[13:36:34.677]   - Field: ‘envir’
[13:36:34.677]   - Field: ‘workers’
[13:36:34.677]   - Field: ‘packages’
[13:36:34.677]   - Field: ‘gc’
[13:36:34.677]   - Field: ‘job’
[13:36:34.678]   - Field: ‘conditions’
[13:36:34.678]   - Field: ‘expr’
[13:36:34.678]   - Field: ‘uuid’
[13:36:34.678]   - Field: ‘seed’
[13:36:34.678]   - Field: ‘version’
[13:36:34.678]   - Field: ‘result’
[13:36:34.679]   - Field: ‘asynchronous’
[13:36:34.679]   - Field: ‘calls’
[13:36:34.679]   - Field: ‘globals’
[13:36:34.679]   - Field: ‘stdout’
[13:36:34.679]   - Field: ‘earlySignal’
[13:36:34.680]   - Field: ‘lazy’
[13:36:34.680]   - Field: ‘state’
[13:36:34.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.680] - Launch lazy future ...
[13:36:34.681] Packages needed by the future expression (n = 0): <none>
[13:36:34.681] Packages needed by future strategies (n = 0): <none>
[13:36:34.682] {
[13:36:34.682]     {
[13:36:34.682]         {
[13:36:34.682]             ...future.startTime <- base::Sys.time()
[13:36:34.682]             {
[13:36:34.682]                 {
[13:36:34.682]                   {
[13:36:34.682]                     {
[13:36:34.682]                       base::local({
[13:36:34.682]                         has_future <- base::requireNamespace("future", 
[13:36:34.682]                           quietly = TRUE)
[13:36:34.682]                         if (has_future) {
[13:36:34.682]                           ns <- base::getNamespace("future")
[13:36:34.682]                           version <- ns[[".package"]][["version"]]
[13:36:34.682]                           if (is.null(version)) 
[13:36:34.682]                             version <- utils::packageVersion("future")
[13:36:34.682]                         }
[13:36:34.682]                         else {
[13:36:34.682]                           version <- NULL
[13:36:34.682]                         }
[13:36:34.682]                         if (!has_future || version < "1.8.0") {
[13:36:34.682]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.682]                             "", base::R.version$version.string), 
[13:36:34.682]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.682]                               "release", "version")], collapse = " "), 
[13:36:34.682]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.682]                             info)
[13:36:34.682]                           info <- base::paste(info, collapse = "; ")
[13:36:34.682]                           if (!has_future) {
[13:36:34.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.682]                               info)
[13:36:34.682]                           }
[13:36:34.682]                           else {
[13:36:34.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.682]                               info, version)
[13:36:34.682]                           }
[13:36:34.682]                           base::stop(msg)
[13:36:34.682]                         }
[13:36:34.682]                       })
[13:36:34.682]                     }
[13:36:34.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.682]                     base::options(mc.cores = 1L)
[13:36:34.682]                   }
[13:36:34.682]                   ...future.strategy.old <- future::plan("list")
[13:36:34.682]                   options(future.plan = NULL)
[13:36:34.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.682]                 }
[13:36:34.682]                 ...future.workdir <- getwd()
[13:36:34.682]             }
[13:36:34.682]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.682]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.682]         }
[13:36:34.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.682]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.682]             base::names(...future.oldOptions))
[13:36:34.682]     }
[13:36:34.682]     if (FALSE) {
[13:36:34.682]     }
[13:36:34.682]     else {
[13:36:34.682]         if (TRUE) {
[13:36:34.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.682]                 open = "w")
[13:36:34.682]         }
[13:36:34.682]         else {
[13:36:34.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.682]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.682]         }
[13:36:34.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.682]             base::sink(type = "output", split = FALSE)
[13:36:34.682]             base::close(...future.stdout)
[13:36:34.682]         }, add = TRUE)
[13:36:34.682]     }
[13:36:34.682]     ...future.frame <- base::sys.nframe()
[13:36:34.682]     ...future.conditions <- base::list()
[13:36:34.682]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.682]     if (FALSE) {
[13:36:34.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.682]     }
[13:36:34.682]     ...future.result <- base::tryCatch({
[13:36:34.682]         base::withCallingHandlers({
[13:36:34.682]             ...future.value <- base::withVisible(base::local({
[13:36:34.682]                 withCallingHandlers({
[13:36:34.682]                   NULL
[13:36:34.682]                 }, immediateCondition = function(cond) {
[13:36:34.682]                   save_rds <- function (object, pathname, ...) 
[13:36:34.682]                   {
[13:36:34.682]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.682]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.682]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.682]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.682]                         fi_tmp[["mtime"]])
[13:36:34.682]                     }
[13:36:34.682]                     tryCatch({
[13:36:34.682]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.682]                     }, error = function(ex) {
[13:36:34.682]                       msg <- conditionMessage(ex)
[13:36:34.682]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.682]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.682]                         fi_tmp[["mtime"]], msg)
[13:36:34.682]                       ex$message <- msg
[13:36:34.682]                       stop(ex)
[13:36:34.682]                     })
[13:36:34.682]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.682]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.682]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.682]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.682]                       fi <- file.info(pathname)
[13:36:34.682]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.682]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.682]                         fi[["size"]], fi[["mtime"]])
[13:36:34.682]                       stop(msg)
[13:36:34.682]                     }
[13:36:34.682]                     invisible(pathname)
[13:36:34.682]                   }
[13:36:34.682]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.682]                     rootPath = tempdir()) 
[13:36:34.682]                   {
[13:36:34.682]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.682]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.682]                       tmpdir = path, fileext = ".rds")
[13:36:34.682]                     save_rds(obj, file)
[13:36:34.682]                   }
[13:36:34.682]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.682]                   {
[13:36:34.682]                     inherits <- base::inherits
[13:36:34.682]                     invokeRestart <- base::invokeRestart
[13:36:34.682]                     is.null <- base::is.null
[13:36:34.682]                     muffled <- FALSE
[13:36:34.682]                     if (inherits(cond, "message")) {
[13:36:34.682]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.682]                       if (muffled) 
[13:36:34.682]                         invokeRestart("muffleMessage")
[13:36:34.682]                     }
[13:36:34.682]                     else if (inherits(cond, "warning")) {
[13:36:34.682]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.682]                       if (muffled) 
[13:36:34.682]                         invokeRestart("muffleWarning")
[13:36:34.682]                     }
[13:36:34.682]                     else if (inherits(cond, "condition")) {
[13:36:34.682]                       if (!is.null(pattern)) {
[13:36:34.682]                         computeRestarts <- base::computeRestarts
[13:36:34.682]                         grepl <- base::grepl
[13:36:34.682]                         restarts <- computeRestarts(cond)
[13:36:34.682]                         for (restart in restarts) {
[13:36:34.682]                           name <- restart$name
[13:36:34.682]                           if (is.null(name)) 
[13:36:34.682]                             next
[13:36:34.682]                           if (!grepl(pattern, name)) 
[13:36:34.682]                             next
[13:36:34.682]                           invokeRestart(restart)
[13:36:34.682]                           muffled <- TRUE
[13:36:34.682]                           break
[13:36:34.682]                         }
[13:36:34.682]                       }
[13:36:34.682]                     }
[13:36:34.682]                     invisible(muffled)
[13:36:34.682]                   }
[13:36:34.682]                   muffleCondition(cond)
[13:36:34.682]                 })
[13:36:34.682]             }))
[13:36:34.682]             future::FutureResult(value = ...future.value$value, 
[13:36:34.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.682]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.682]                     ...future.globalenv.names))
[13:36:34.682]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.682]         }, condition = base::local({
[13:36:34.682]             c <- base::c
[13:36:34.682]             inherits <- base::inherits
[13:36:34.682]             invokeRestart <- base::invokeRestart
[13:36:34.682]             length <- base::length
[13:36:34.682]             list <- base::list
[13:36:34.682]             seq.int <- base::seq.int
[13:36:34.682]             signalCondition <- base::signalCondition
[13:36:34.682]             sys.calls <- base::sys.calls
[13:36:34.682]             `[[` <- base::`[[`
[13:36:34.682]             `+` <- base::`+`
[13:36:34.682]             `<<-` <- base::`<<-`
[13:36:34.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.682]                   3L)]
[13:36:34.682]             }
[13:36:34.682]             function(cond) {
[13:36:34.682]                 is_error <- inherits(cond, "error")
[13:36:34.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.682]                   NULL)
[13:36:34.682]                 if (is_error) {
[13:36:34.682]                   sessionInformation <- function() {
[13:36:34.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.682]                       search = base::search(), system = base::Sys.info())
[13:36:34.682]                   }
[13:36:34.682]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.682]                     cond$call), session = sessionInformation(), 
[13:36:34.682]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.682]                   signalCondition(cond)
[13:36:34.682]                 }
[13:36:34.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.682]                 "immediateCondition"))) {
[13:36:34.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.682]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.682]                   if (TRUE && !signal) {
[13:36:34.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.682]                     {
[13:36:34.682]                       inherits <- base::inherits
[13:36:34.682]                       invokeRestart <- base::invokeRestart
[13:36:34.682]                       is.null <- base::is.null
[13:36:34.682]                       muffled <- FALSE
[13:36:34.682]                       if (inherits(cond, "message")) {
[13:36:34.682]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.682]                         if (muffled) 
[13:36:34.682]                           invokeRestart("muffleMessage")
[13:36:34.682]                       }
[13:36:34.682]                       else if (inherits(cond, "warning")) {
[13:36:34.682]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.682]                         if (muffled) 
[13:36:34.682]                           invokeRestart("muffleWarning")
[13:36:34.682]                       }
[13:36:34.682]                       else if (inherits(cond, "condition")) {
[13:36:34.682]                         if (!is.null(pattern)) {
[13:36:34.682]                           computeRestarts <- base::computeRestarts
[13:36:34.682]                           grepl <- base::grepl
[13:36:34.682]                           restarts <- computeRestarts(cond)
[13:36:34.682]                           for (restart in restarts) {
[13:36:34.682]                             name <- restart$name
[13:36:34.682]                             if (is.null(name)) 
[13:36:34.682]                               next
[13:36:34.682]                             if (!grepl(pattern, name)) 
[13:36:34.682]                               next
[13:36:34.682]                             invokeRestart(restart)
[13:36:34.682]                             muffled <- TRUE
[13:36:34.682]                             break
[13:36:34.682]                           }
[13:36:34.682]                         }
[13:36:34.682]                       }
[13:36:34.682]                       invisible(muffled)
[13:36:34.682]                     }
[13:36:34.682]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.682]                   }
[13:36:34.682]                 }
[13:36:34.682]                 else {
[13:36:34.682]                   if (TRUE) {
[13:36:34.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.682]                     {
[13:36:34.682]                       inherits <- base::inherits
[13:36:34.682]                       invokeRestart <- base::invokeRestart
[13:36:34.682]                       is.null <- base::is.null
[13:36:34.682]                       muffled <- FALSE
[13:36:34.682]                       if (inherits(cond, "message")) {
[13:36:34.682]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.682]                         if (muffled) 
[13:36:34.682]                           invokeRestart("muffleMessage")
[13:36:34.682]                       }
[13:36:34.682]                       else if (inherits(cond, "warning")) {
[13:36:34.682]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.682]                         if (muffled) 
[13:36:34.682]                           invokeRestart("muffleWarning")
[13:36:34.682]                       }
[13:36:34.682]                       else if (inherits(cond, "condition")) {
[13:36:34.682]                         if (!is.null(pattern)) {
[13:36:34.682]                           computeRestarts <- base::computeRestarts
[13:36:34.682]                           grepl <- base::grepl
[13:36:34.682]                           restarts <- computeRestarts(cond)
[13:36:34.682]                           for (restart in restarts) {
[13:36:34.682]                             name <- restart$name
[13:36:34.682]                             if (is.null(name)) 
[13:36:34.682]                               next
[13:36:34.682]                             if (!grepl(pattern, name)) 
[13:36:34.682]                               next
[13:36:34.682]                             invokeRestart(restart)
[13:36:34.682]                             muffled <- TRUE
[13:36:34.682]                             break
[13:36:34.682]                           }
[13:36:34.682]                         }
[13:36:34.682]                       }
[13:36:34.682]                       invisible(muffled)
[13:36:34.682]                     }
[13:36:34.682]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.682]                   }
[13:36:34.682]                 }
[13:36:34.682]             }
[13:36:34.682]         }))
[13:36:34.682]     }, error = function(ex) {
[13:36:34.682]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.682]                 ...future.rng), started = ...future.startTime, 
[13:36:34.682]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.682]             version = "1.8"), class = "FutureResult")
[13:36:34.682]     }, finally = {
[13:36:34.682]         if (!identical(...future.workdir, getwd())) 
[13:36:34.682]             setwd(...future.workdir)
[13:36:34.682]         {
[13:36:34.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.682]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.682]             }
[13:36:34.682]             base::options(...future.oldOptions)
[13:36:34.682]             if (.Platform$OS.type == "windows") {
[13:36:34.682]                 old_names <- names(...future.oldEnvVars)
[13:36:34.682]                 envs <- base::Sys.getenv()
[13:36:34.682]                 names <- names(envs)
[13:36:34.682]                 common <- intersect(names, old_names)
[13:36:34.682]                 added <- setdiff(names, old_names)
[13:36:34.682]                 removed <- setdiff(old_names, names)
[13:36:34.682]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.682]                   envs[common]]
[13:36:34.682]                 NAMES <- toupper(changed)
[13:36:34.682]                 args <- list()
[13:36:34.682]                 for (kk in seq_along(NAMES)) {
[13:36:34.682]                   name <- changed[[kk]]
[13:36:34.682]                   NAME <- NAMES[[kk]]
[13:36:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.682]                     next
[13:36:34.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.682]                 }
[13:36:34.682]                 NAMES <- toupper(added)
[13:36:34.682]                 for (kk in seq_along(NAMES)) {
[13:36:34.682]                   name <- added[[kk]]
[13:36:34.682]                   NAME <- NAMES[[kk]]
[13:36:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.682]                     next
[13:36:34.682]                   args[[name]] <- ""
[13:36:34.682]                 }
[13:36:34.682]                 NAMES <- toupper(removed)
[13:36:34.682]                 for (kk in seq_along(NAMES)) {
[13:36:34.682]                   name <- removed[[kk]]
[13:36:34.682]                   NAME <- NAMES[[kk]]
[13:36:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.682]                     next
[13:36:34.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.682]                 }
[13:36:34.682]                 if (length(args) > 0) 
[13:36:34.682]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.682]             }
[13:36:34.682]             else {
[13:36:34.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.682]             }
[13:36:34.682]             {
[13:36:34.682]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.682]                   0L) {
[13:36:34.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.682]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.682]                   base::options(opts)
[13:36:34.682]                 }
[13:36:34.682]                 {
[13:36:34.682]                   {
[13:36:34.682]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.682]                     NULL
[13:36:34.682]                   }
[13:36:34.682]                   options(future.plan = NULL)
[13:36:34.682]                   if (is.na(NA_character_)) 
[13:36:34.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.682]                     .init = FALSE)
[13:36:34.682]                 }
[13:36:34.682]             }
[13:36:34.682]         }
[13:36:34.682]     })
[13:36:34.682]     if (TRUE) {
[13:36:34.682]         base::sink(type = "output", split = FALSE)
[13:36:34.682]         if (TRUE) {
[13:36:34.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.682]         }
[13:36:34.682]         else {
[13:36:34.682]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.682]         }
[13:36:34.682]         base::close(...future.stdout)
[13:36:34.682]         ...future.stdout <- NULL
[13:36:34.682]     }
[13:36:34.682]     ...future.result$conditions <- ...future.conditions
[13:36:34.682]     ...future.result$finished <- base::Sys.time()
[13:36:34.682]     ...future.result
[13:36:34.682] }
[13:36:34.685] requestCore(): workers = 2
[13:36:34.687] MulticoreFuture started
[13:36:34.687] - Launch lazy future ... done
[13:36:34.687] run() for ‘MulticoreFuture’ ... done
List of 6
[13:36:34.688] plan(): Setting new future strategy stack:
 $ a:[13:36:34.688] List of future strategies:
[13:36:34.688] 1. sequential:
[13:36:34.688]    - args: function (..., envir = parent.frame())
[13:36:34.688]    - tweaked: FALSE
[13:36:34.688]    - call: NULL
 num 1
 $ b:[13:36:34.689] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a731bf2b0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a71df98f8> 
 $  : NULL
 $  : NULL
 $  :[13:36:34.691] plan(): Setting new future strategy stack:
 num 6
List of 6
[13:36:34.692] List of future strategies:
[13:36:34.692] 1. multicore:
[13:36:34.692]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.692]    - tweaked: FALSE
[13:36:34.692]    - call: plan(strategy)
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a731bf2b0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a71df98f8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ :[13:36:34.696] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:34.701] resolve() on list ...
[13:36:34.701]  recursive: 0
[13:36:34.701]  length: 6
[13:36:34.701]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:34.701] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.701] - nx: 6
[13:36:34.702] - relay: TRUE
[13:36:34.702] - stdout: TRUE
[13:36:34.702] - signal: TRUE
[13:36:34.702] - resignal: FALSE
[13:36:34.702] - force: TRUE
[13:36:34.702] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.702] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.703]  - until=2
[13:36:34.703]  - relaying element #2
[13:36:34.703] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.703] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.703] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.703]  length: 5 (resolved future 1)
[13:36:34.704] Future #2
[13:36:34.704] result() for MulticoreFuture ...
[13:36:34.705] result() for MulticoreFuture ...
[13:36:34.705] result() for MulticoreFuture ... done
[13:36:34.705] result() for MulticoreFuture ... done
[13:36:34.705] result() for MulticoreFuture ...
[13:36:34.705] result() for MulticoreFuture ... done
[13:36:34.705] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:34.706] - nx: 6
[13:36:34.706] - relay: TRUE
[13:36:34.706] - stdout: TRUE
[13:36:34.706] - signal: TRUE
[13:36:34.706] - resignal: FALSE
[13:36:34.706] - force: TRUE
[13:36:34.707] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.707] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.707]  - until=2
[13:36:34.707]  - relaying element #2
[13:36:34.707] result() for MulticoreFuture ...
[13:36:34.707] result() for MulticoreFuture ... done
[13:36:34.708] result() for MulticoreFuture ...
[13:36:34.708] result() for MulticoreFuture ... done
[13:36:34.708] result() for MulticoreFuture ...
[13:36:34.708] result() for MulticoreFuture ... done
[13:36:34.709] result() for MulticoreFuture ...
[13:36:34.709] result() for MulticoreFuture ... done
[13:36:34.709] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.709] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.709] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:34.709]  length: 4 (resolved future 2)
[13:36:34.710] Future #3
[13:36:34.710] result() for MulticoreFuture ...
[13:36:34.711] result() for MulticoreFuture ...
[13:36:34.711] result() for MulticoreFuture ... done
[13:36:34.711] result() for MulticoreFuture ... done
[13:36:34.711] result() for MulticoreFuture ...
[13:36:34.711] result() for MulticoreFuture ... done
[13:36:34.711] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:34.711] - nx: 6
[13:36:34.712] - relay: TRUE
[13:36:34.712] - stdout: TRUE
[13:36:34.712] - signal: TRUE
[13:36:34.712] - resignal: FALSE
[13:36:34.712] - force: TRUE
[13:36:34.712] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.712] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.712]  - until=3
[13:36:34.713]  - relaying element #3
[13:36:34.713] result() for MulticoreFuture ...
[13:36:34.713] result() for MulticoreFuture ... done
[13:36:34.713] result() for MulticoreFuture ...
[13:36:34.713] result() for MulticoreFuture ... done
[13:36:34.713] result() for MulticoreFuture ...
[13:36:34.713] result() for MulticoreFuture ... done
[13:36:34.714] result() for MulticoreFuture ...
[13:36:34.714] result() for MulticoreFuture ... done
[13:36:34.714] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.714] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.714] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:34.714]  length: 3 (resolved future 3)
[13:36:34.714] signalConditionsASAP(NULL, pos=4) ...
[13:36:34.714] - nx: 6
[13:36:34.714] - relay: TRUE
[13:36:34.715] - stdout: TRUE
[13:36:34.715] - signal: TRUE
[13:36:34.715] - resignal: FALSE
[13:36:34.715] - force: TRUE
[13:36:34.715] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.715] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.715]  - until=5
[13:36:34.715]  - relaying element #5
[13:36:34.715] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.715] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.716] signalConditionsASAP(NULL, pos=4) ... done
[13:36:34.716]  length: 2 (resolved future 4)
[13:36:34.716] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.716] - nx: 6
[13:36:34.716] - relay: TRUE
[13:36:34.719] - stdout: TRUE
[13:36:34.719] - signal: TRUE
[13:36:34.719] - resignal: FALSE
[13:36:34.719] - force: TRUE
[13:36:34.719] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.719] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.720]  - until=6
[13:36:34.720]  - relaying element #6
[13:36:34.720] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.720] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.720] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.720]  length: 1 (resolved future 5)
[13:36:34.720] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.721] - nx: 6
[13:36:34.721] - relay: TRUE
[13:36:34.721] - stdout: TRUE
[13:36:34.721] - signal: TRUE
[13:36:34.721] - resignal: FALSE
[13:36:34.721] - force: TRUE
[13:36:34.721] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.721] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.721]  - until=6
[13:36:34.722] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.722] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.722] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.722]  length: 0 (resolved future 6)
[13:36:34.722] Relaying remaining futures
[13:36:34.722] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.722] - nx: 6
[13:36:34.722] - relay: TRUE
[13:36:34.722] - stdout: TRUE
[13:36:34.723] - signal: TRUE
[13:36:34.723] - resignal: FALSE
[13:36:34.723] - force: TRUE
[13:36:34.723] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.723] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:34.723] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.723] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.724] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.724] resolve() on list ... DONE
[13:36:34.724] result() for MulticoreFuture ...
[13:36:34.724] result() for MulticoreFuture ... done
[13:36:34.724] result() for MulticoreFuture ...
[13:36:34.724] result() for MulticoreFuture ... done
[13:36:34.724] result() for MulticoreFuture ...
[13:36:34.724] result() for MulticoreFuture ... done
[13:36:34.725] result() for MulticoreFuture ...
[13:36:34.725] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:36:34.728] getGlobalsAndPackages() ...
[13:36:34.728] Searching for globals...
[13:36:34.729] 
[13:36:34.729] Searching for globals ... DONE
[13:36:34.729] - globals: [0] <none>
[13:36:34.729] getGlobalsAndPackages() ... DONE
[13:36:34.729] run() for ‘Future’ ...
[13:36:34.729] - state: ‘created’
[13:36:34.730] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.733] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.734]   - Field: ‘label’
[13:36:34.734]   - Field: ‘local’
[13:36:34.734]   - Field: ‘owner’
[13:36:34.734]   - Field: ‘envir’
[13:36:34.734]   - Field: ‘workers’
[13:36:34.734]   - Field: ‘packages’
[13:36:34.734]   - Field: ‘gc’
[13:36:34.734]   - Field: ‘job’
[13:36:34.734]   - Field: ‘conditions’
[13:36:34.734]   - Field: ‘expr’
[13:36:34.735]   - Field: ‘uuid’
[13:36:34.735]   - Field: ‘seed’
[13:36:34.735]   - Field: ‘version’
[13:36:34.735]   - Field: ‘result’
[13:36:34.735]   - Field: ‘asynchronous’
[13:36:34.735]   - Field: ‘calls’
[13:36:34.735]   - Field: ‘globals’
[13:36:34.735]   - Field: ‘stdout’
[13:36:34.735]   - Field: ‘earlySignal’
[13:36:34.735]   - Field: ‘lazy’
[13:36:34.735]   - Field: ‘state’
[13:36:34.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.736] - Launch lazy future ...
[13:36:34.736] Packages needed by the future expression (n = 0): <none>
[13:36:34.736] Packages needed by future strategies (n = 0): <none>
[13:36:34.737] {
[13:36:34.737]     {
[13:36:34.737]         {
[13:36:34.737]             ...future.startTime <- base::Sys.time()
[13:36:34.737]             {
[13:36:34.737]                 {
[13:36:34.737]                   {
[13:36:34.737]                     {
[13:36:34.737]                       base::local({
[13:36:34.737]                         has_future <- base::requireNamespace("future", 
[13:36:34.737]                           quietly = TRUE)
[13:36:34.737]                         if (has_future) {
[13:36:34.737]                           ns <- base::getNamespace("future")
[13:36:34.737]                           version <- ns[[".package"]][["version"]]
[13:36:34.737]                           if (is.null(version)) 
[13:36:34.737]                             version <- utils::packageVersion("future")
[13:36:34.737]                         }
[13:36:34.737]                         else {
[13:36:34.737]                           version <- NULL
[13:36:34.737]                         }
[13:36:34.737]                         if (!has_future || version < "1.8.0") {
[13:36:34.737]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.737]                             "", base::R.version$version.string), 
[13:36:34.737]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.737]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.737]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.737]                               "release", "version")], collapse = " "), 
[13:36:34.737]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.737]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.737]                             info)
[13:36:34.737]                           info <- base::paste(info, collapse = "; ")
[13:36:34.737]                           if (!has_future) {
[13:36:34.737]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.737]                               info)
[13:36:34.737]                           }
[13:36:34.737]                           else {
[13:36:34.737]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.737]                               info, version)
[13:36:34.737]                           }
[13:36:34.737]                           base::stop(msg)
[13:36:34.737]                         }
[13:36:34.737]                       })
[13:36:34.737]                     }
[13:36:34.737]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.737]                     base::options(mc.cores = 1L)
[13:36:34.737]                   }
[13:36:34.737]                   ...future.strategy.old <- future::plan("list")
[13:36:34.737]                   options(future.plan = NULL)
[13:36:34.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.737]                 }
[13:36:34.737]                 ...future.workdir <- getwd()
[13:36:34.737]             }
[13:36:34.737]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.737]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.737]         }
[13:36:34.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.737]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.737]             base::names(...future.oldOptions))
[13:36:34.737]     }
[13:36:34.737]     if (FALSE) {
[13:36:34.737]     }
[13:36:34.737]     else {
[13:36:34.737]         if (TRUE) {
[13:36:34.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.737]                 open = "w")
[13:36:34.737]         }
[13:36:34.737]         else {
[13:36:34.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.737]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.737]         }
[13:36:34.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.737]             base::sink(type = "output", split = FALSE)
[13:36:34.737]             base::close(...future.stdout)
[13:36:34.737]         }, add = TRUE)
[13:36:34.737]     }
[13:36:34.737]     ...future.frame <- base::sys.nframe()
[13:36:34.737]     ...future.conditions <- base::list()
[13:36:34.737]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.737]     if (FALSE) {
[13:36:34.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.737]     }
[13:36:34.737]     ...future.result <- base::tryCatch({
[13:36:34.737]         base::withCallingHandlers({
[13:36:34.737]             ...future.value <- base::withVisible(base::local({
[13:36:34.737]                 withCallingHandlers({
[13:36:34.737]                   2
[13:36:34.737]                 }, immediateCondition = function(cond) {
[13:36:34.737]                   save_rds <- function (object, pathname, ...) 
[13:36:34.737]                   {
[13:36:34.737]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.737]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.737]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.737]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.737]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.737]                         fi_tmp[["mtime"]])
[13:36:34.737]                     }
[13:36:34.737]                     tryCatch({
[13:36:34.737]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.737]                     }, error = function(ex) {
[13:36:34.737]                       msg <- conditionMessage(ex)
[13:36:34.737]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.737]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.737]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.737]                         fi_tmp[["mtime"]], msg)
[13:36:34.737]                       ex$message <- msg
[13:36:34.737]                       stop(ex)
[13:36:34.737]                     })
[13:36:34.737]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.737]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.737]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.737]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.737]                       fi <- file.info(pathname)
[13:36:34.737]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.737]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.737]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.737]                         fi[["size"]], fi[["mtime"]])
[13:36:34.737]                       stop(msg)
[13:36:34.737]                     }
[13:36:34.737]                     invisible(pathname)
[13:36:34.737]                   }
[13:36:34.737]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.737]                     rootPath = tempdir()) 
[13:36:34.737]                   {
[13:36:34.737]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.737]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.737]                       tmpdir = path, fileext = ".rds")
[13:36:34.737]                     save_rds(obj, file)
[13:36:34.737]                   }
[13:36:34.737]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.737]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.737]                   {
[13:36:34.737]                     inherits <- base::inherits
[13:36:34.737]                     invokeRestart <- base::invokeRestart
[13:36:34.737]                     is.null <- base::is.null
[13:36:34.737]                     muffled <- FALSE
[13:36:34.737]                     if (inherits(cond, "message")) {
[13:36:34.737]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.737]                       if (muffled) 
[13:36:34.737]                         invokeRestart("muffleMessage")
[13:36:34.737]                     }
[13:36:34.737]                     else if (inherits(cond, "warning")) {
[13:36:34.737]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.737]                       if (muffled) 
[13:36:34.737]                         invokeRestart("muffleWarning")
[13:36:34.737]                     }
[13:36:34.737]                     else if (inherits(cond, "condition")) {
[13:36:34.737]                       if (!is.null(pattern)) {
[13:36:34.737]                         computeRestarts <- base::computeRestarts
[13:36:34.737]                         grepl <- base::grepl
[13:36:34.737]                         restarts <- computeRestarts(cond)
[13:36:34.737]                         for (restart in restarts) {
[13:36:34.737]                           name <- restart$name
[13:36:34.737]                           if (is.null(name)) 
[13:36:34.737]                             next
[13:36:34.737]                           if (!grepl(pattern, name)) 
[13:36:34.737]                             next
[13:36:34.737]                           invokeRestart(restart)
[13:36:34.737]                           muffled <- TRUE
[13:36:34.737]                           break
[13:36:34.737]                         }
[13:36:34.737]                       }
[13:36:34.737]                     }
[13:36:34.737]                     invisible(muffled)
[13:36:34.737]                   }
[13:36:34.737]                   muffleCondition(cond)
[13:36:34.737]                 })
[13:36:34.737]             }))
[13:36:34.737]             future::FutureResult(value = ...future.value$value, 
[13:36:34.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.737]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.737]                     ...future.globalenv.names))
[13:36:34.737]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.737]         }, condition = base::local({
[13:36:34.737]             c <- base::c
[13:36:34.737]             inherits <- base::inherits
[13:36:34.737]             invokeRestart <- base::invokeRestart
[13:36:34.737]             length <- base::length
[13:36:34.737]             list <- base::list
[13:36:34.737]             seq.int <- base::seq.int
[13:36:34.737]             signalCondition <- base::signalCondition
[13:36:34.737]             sys.calls <- base::sys.calls
[13:36:34.737]             `[[` <- base::`[[`
[13:36:34.737]             `+` <- base::`+`
[13:36:34.737]             `<<-` <- base::`<<-`
[13:36:34.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.737]                   3L)]
[13:36:34.737]             }
[13:36:34.737]             function(cond) {
[13:36:34.737]                 is_error <- inherits(cond, "error")
[13:36:34.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.737]                   NULL)
[13:36:34.737]                 if (is_error) {
[13:36:34.737]                   sessionInformation <- function() {
[13:36:34.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.737]                       search = base::search(), system = base::Sys.info())
[13:36:34.737]                   }
[13:36:34.737]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.737]                     cond$call), session = sessionInformation(), 
[13:36:34.737]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.737]                   signalCondition(cond)
[13:36:34.737]                 }
[13:36:34.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.737]                 "immediateCondition"))) {
[13:36:34.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.737]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.737]                   if (TRUE && !signal) {
[13:36:34.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.737]                     {
[13:36:34.737]                       inherits <- base::inherits
[13:36:34.737]                       invokeRestart <- base::invokeRestart
[13:36:34.737]                       is.null <- base::is.null
[13:36:34.737]                       muffled <- FALSE
[13:36:34.737]                       if (inherits(cond, "message")) {
[13:36:34.737]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.737]                         if (muffled) 
[13:36:34.737]                           invokeRestart("muffleMessage")
[13:36:34.737]                       }
[13:36:34.737]                       else if (inherits(cond, "warning")) {
[13:36:34.737]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.737]                         if (muffled) 
[13:36:34.737]                           invokeRestart("muffleWarning")
[13:36:34.737]                       }
[13:36:34.737]                       else if (inherits(cond, "condition")) {
[13:36:34.737]                         if (!is.null(pattern)) {
[13:36:34.737]                           computeRestarts <- base::computeRestarts
[13:36:34.737]                           grepl <- base::grepl
[13:36:34.737]                           restarts <- computeRestarts(cond)
[13:36:34.737]                           for (restart in restarts) {
[13:36:34.737]                             name <- restart$name
[13:36:34.737]                             if (is.null(name)) 
[13:36:34.737]                               next
[13:36:34.737]                             if (!grepl(pattern, name)) 
[13:36:34.737]                               next
[13:36:34.737]                             invokeRestart(restart)
[13:36:34.737]                             muffled <- TRUE
[13:36:34.737]                             break
[13:36:34.737]                           }
[13:36:34.737]                         }
[13:36:34.737]                       }
[13:36:34.737]                       invisible(muffled)
[13:36:34.737]                     }
[13:36:34.737]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.737]                   }
[13:36:34.737]                 }
[13:36:34.737]                 else {
[13:36:34.737]                   if (TRUE) {
[13:36:34.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.737]                     {
[13:36:34.737]                       inherits <- base::inherits
[13:36:34.737]                       invokeRestart <- base::invokeRestart
[13:36:34.737]                       is.null <- base::is.null
[13:36:34.737]                       muffled <- FALSE
[13:36:34.737]                       if (inherits(cond, "message")) {
[13:36:34.737]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.737]                         if (muffled) 
[13:36:34.737]                           invokeRestart("muffleMessage")
[13:36:34.737]                       }
[13:36:34.737]                       else if (inherits(cond, "warning")) {
[13:36:34.737]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.737]                         if (muffled) 
[13:36:34.737]                           invokeRestart("muffleWarning")
[13:36:34.737]                       }
[13:36:34.737]                       else if (inherits(cond, "condition")) {
[13:36:34.737]                         if (!is.null(pattern)) {
[13:36:34.737]                           computeRestarts <- base::computeRestarts
[13:36:34.737]                           grepl <- base::grepl
[13:36:34.737]                           restarts <- computeRestarts(cond)
[13:36:34.737]                           for (restart in restarts) {
[13:36:34.737]                             name <- restart$name
[13:36:34.737]                             if (is.null(name)) 
[13:36:34.737]                               next
[13:36:34.737]                             if (!grepl(pattern, name)) 
[13:36:34.737]                               next
[13:36:34.737]                             invokeRestart(restart)
[13:36:34.737]                             muffled <- TRUE
[13:36:34.737]                             break
[13:36:34.737]                           }
[13:36:34.737]                         }
[13:36:34.737]                       }
[13:36:34.737]                       invisible(muffled)
[13:36:34.737]                     }
[13:36:34.737]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.737]                   }
[13:36:34.737]                 }
[13:36:34.737]             }
[13:36:34.737]         }))
[13:36:34.737]     }, error = function(ex) {
[13:36:34.737]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.737]                 ...future.rng), started = ...future.startTime, 
[13:36:34.737]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.737]             version = "1.8"), class = "FutureResult")
[13:36:34.737]     }, finally = {
[13:36:34.737]         if (!identical(...future.workdir, getwd())) 
[13:36:34.737]             setwd(...future.workdir)
[13:36:34.737]         {
[13:36:34.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.737]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.737]             }
[13:36:34.737]             base::options(...future.oldOptions)
[13:36:34.737]             if (.Platform$OS.type == "windows") {
[13:36:34.737]                 old_names <- names(...future.oldEnvVars)
[13:36:34.737]                 envs <- base::Sys.getenv()
[13:36:34.737]                 names <- names(envs)
[13:36:34.737]                 common <- intersect(names, old_names)
[13:36:34.737]                 added <- setdiff(names, old_names)
[13:36:34.737]                 removed <- setdiff(old_names, names)
[13:36:34.737]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.737]                   envs[common]]
[13:36:34.737]                 NAMES <- toupper(changed)
[13:36:34.737]                 args <- list()
[13:36:34.737]                 for (kk in seq_along(NAMES)) {
[13:36:34.737]                   name <- changed[[kk]]
[13:36:34.737]                   NAME <- NAMES[[kk]]
[13:36:34.737]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.737]                     next
[13:36:34.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.737]                 }
[13:36:34.737]                 NAMES <- toupper(added)
[13:36:34.737]                 for (kk in seq_along(NAMES)) {
[13:36:34.737]                   name <- added[[kk]]
[13:36:34.737]                   NAME <- NAMES[[kk]]
[13:36:34.737]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.737]                     next
[13:36:34.737]                   args[[name]] <- ""
[13:36:34.737]                 }
[13:36:34.737]                 NAMES <- toupper(removed)
[13:36:34.737]                 for (kk in seq_along(NAMES)) {
[13:36:34.737]                   name <- removed[[kk]]
[13:36:34.737]                   NAME <- NAMES[[kk]]
[13:36:34.737]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.737]                     next
[13:36:34.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.737]                 }
[13:36:34.737]                 if (length(args) > 0) 
[13:36:34.737]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.737]             }
[13:36:34.737]             else {
[13:36:34.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.737]             }
[13:36:34.737]             {
[13:36:34.737]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.737]                   0L) {
[13:36:34.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.737]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.737]                   base::options(opts)
[13:36:34.737]                 }
[13:36:34.737]                 {
[13:36:34.737]                   {
[13:36:34.737]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.737]                     NULL
[13:36:34.737]                   }
[13:36:34.737]                   options(future.plan = NULL)
[13:36:34.737]                   if (is.na(NA_character_)) 
[13:36:34.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.737]                     .init = FALSE)
[13:36:34.737]                 }
[13:36:34.737]             }
[13:36:34.737]         }
[13:36:34.737]     })
[13:36:34.737]     if (TRUE) {
[13:36:34.737]         base::sink(type = "output", split = FALSE)
[13:36:34.737]         if (TRUE) {
[13:36:34.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.737]         }
[13:36:34.737]         else {
[13:36:34.737]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.737]         }
[13:36:34.737]         base::close(...future.stdout)
[13:36:34.737]         ...future.stdout <- NULL
[13:36:34.737]     }
[13:36:34.737]     ...future.result$conditions <- ...future.conditions
[13:36:34.737]     ...future.result$finished <- base::Sys.time()
[13:36:34.737]     ...future.result
[13:36:34.737] }
[13:36:34.739] requestCore(): workers = 2
[13:36:34.741] MulticoreFuture started
[13:36:34.741] - Launch lazy future ... done
[13:36:34.741] run() for ‘MulticoreFuture’ ... done
[13:36:34.741] getGlobalsAndPackages() ...
[13:36:34.742] Searching for globals...
[13:36:34.742] plan(): Setting new future strategy stack:
[13:36:34.742] 
[13:36:34.742] List of future strategies:
[13:36:34.742] 1. sequential:
[13:36:34.742]    - args: function (..., envir = parent.frame())
[13:36:34.742]    - tweaked: FALSE
[13:36:34.742]    - call: NULL
[13:36:34.743] Searching for globals ... DONE
[13:36:34.743] - globals: [0] <none>
[13:36:34.743] plan(): nbrOfWorkers() = 1
[13:36:34.743] getGlobalsAndPackages() ... DONE
[13:36:34.744] run() for ‘Future’ ...
[13:36:34.744] - state: ‘created’
[13:36:34.744] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:34.745] plan(): Setting new future strategy stack:
[13:36:34.745] List of future strategies:
[13:36:34.745] 1. multicore:
[13:36:34.745]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.745]    - tweaked: FALSE
[13:36:34.745]    - call: plan(strategy)
[13:36:34.749] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:34.749] plan(): nbrOfWorkers() = 2
[13:36:34.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:34.749]   - Field: ‘label’
[13:36:34.750]   - Field: ‘local’
[13:36:34.750]   - Field: ‘owner’
[13:36:34.750]   - Field: ‘envir’
[13:36:34.750]   - Field: ‘workers’
[13:36:34.750]   - Field: ‘packages’
[13:36:34.751]   - Field: ‘gc’
[13:36:34.751]   - Field: ‘job’
[13:36:34.751]   - Field: ‘conditions’
[13:36:34.751]   - Field: ‘expr’
[13:36:34.751]   - Field: ‘uuid’
[13:36:34.751]   - Field: ‘seed’
[13:36:34.751]   - Field: ‘version’
[13:36:34.752]   - Field: ‘result’
[13:36:34.752]   - Field: ‘asynchronous’
[13:36:34.752]   - Field: ‘calls’
[13:36:34.752]   - Field: ‘globals’
[13:36:34.752]   - Field: ‘stdout’
[13:36:34.752]   - Field: ‘earlySignal’
[13:36:34.753]   - Field: ‘lazy’
[13:36:34.753]   - Field: ‘state’
[13:36:34.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:34.753] - Launch lazy future ...
[13:36:34.753] Packages needed by the future expression (n = 0): <none>
[13:36:34.754] Packages needed by future strategies (n = 0): <none>
[13:36:34.754] {
[13:36:34.754]     {
[13:36:34.754]         {
[13:36:34.754]             ...future.startTime <- base::Sys.time()
[13:36:34.754]             {
[13:36:34.754]                 {
[13:36:34.754]                   {
[13:36:34.754]                     {
[13:36:34.754]                       base::local({
[13:36:34.754]                         has_future <- base::requireNamespace("future", 
[13:36:34.754]                           quietly = TRUE)
[13:36:34.754]                         if (has_future) {
[13:36:34.754]                           ns <- base::getNamespace("future")
[13:36:34.754]                           version <- ns[[".package"]][["version"]]
[13:36:34.754]                           if (is.null(version)) 
[13:36:34.754]                             version <- utils::packageVersion("future")
[13:36:34.754]                         }
[13:36:34.754]                         else {
[13:36:34.754]                           version <- NULL
[13:36:34.754]                         }
[13:36:34.754]                         if (!has_future || version < "1.8.0") {
[13:36:34.754]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:34.754]                             "", base::R.version$version.string), 
[13:36:34.754]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:34.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:34.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:34.754]                               "release", "version")], collapse = " "), 
[13:36:34.754]                             hostname = base::Sys.info()[["nodename"]])
[13:36:34.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:34.754]                             info)
[13:36:34.754]                           info <- base::paste(info, collapse = "; ")
[13:36:34.754]                           if (!has_future) {
[13:36:34.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:34.754]                               info)
[13:36:34.754]                           }
[13:36:34.754]                           else {
[13:36:34.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:34.754]                               info, version)
[13:36:34.754]                           }
[13:36:34.754]                           base::stop(msg)
[13:36:34.754]                         }
[13:36:34.754]                       })
[13:36:34.754]                     }
[13:36:34.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:34.754]                     base::options(mc.cores = 1L)
[13:36:34.754]                   }
[13:36:34.754]                   ...future.strategy.old <- future::plan("list")
[13:36:34.754]                   options(future.plan = NULL)
[13:36:34.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:34.754]                 }
[13:36:34.754]                 ...future.workdir <- getwd()
[13:36:34.754]             }
[13:36:34.754]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:34.754]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:34.754]         }
[13:36:34.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:34.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:34.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:34.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:34.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:34.754]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:34.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:34.754]             base::names(...future.oldOptions))
[13:36:34.754]     }
[13:36:34.754]     if (FALSE) {
[13:36:34.754]     }
[13:36:34.754]     else {
[13:36:34.754]         if (TRUE) {
[13:36:34.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:34.754]                 open = "w")
[13:36:34.754]         }
[13:36:34.754]         else {
[13:36:34.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:34.754]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:34.754]         }
[13:36:34.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:34.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:34.754]             base::sink(type = "output", split = FALSE)
[13:36:34.754]             base::close(...future.stdout)
[13:36:34.754]         }, add = TRUE)
[13:36:34.754]     }
[13:36:34.754]     ...future.frame <- base::sys.nframe()
[13:36:34.754]     ...future.conditions <- base::list()
[13:36:34.754]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:34.754]     if (FALSE) {
[13:36:34.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:34.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:34.754]     }
[13:36:34.754]     ...future.result <- base::tryCatch({
[13:36:34.754]         base::withCallingHandlers({
[13:36:34.754]             ...future.value <- base::withVisible(base::local({
[13:36:34.754]                 withCallingHandlers({
[13:36:34.754]                   NULL
[13:36:34.754]                 }, immediateCondition = function(cond) {
[13:36:34.754]                   save_rds <- function (object, pathname, ...) 
[13:36:34.754]                   {
[13:36:34.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:34.754]                     if (file_test("-f", pathname_tmp)) {
[13:36:34.754]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:34.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.754]                         fi_tmp[["mtime"]])
[13:36:34.754]                     }
[13:36:34.754]                     tryCatch({
[13:36:34.754]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:34.754]                     }, error = function(ex) {
[13:36:34.754]                       msg <- conditionMessage(ex)
[13:36:34.754]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:34.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.754]                         fi_tmp[["mtime"]], msg)
[13:36:34.754]                       ex$message <- msg
[13:36:34.754]                       stop(ex)
[13:36:34.754]                     })
[13:36:34.754]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:34.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:34.754]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:34.754]                       fi_tmp <- file.info(pathname_tmp)
[13:36:34.754]                       fi <- file.info(pathname)
[13:36:34.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:34.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:34.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:34.754]                         fi[["size"]], fi[["mtime"]])
[13:36:34.754]                       stop(msg)
[13:36:34.754]                     }
[13:36:34.754]                     invisible(pathname)
[13:36:34.754]                   }
[13:36:34.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:34.754]                     rootPath = tempdir()) 
[13:36:34.754]                   {
[13:36:34.754]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:34.754]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:34.754]                       tmpdir = path, fileext = ".rds")
[13:36:34.754]                     save_rds(obj, file)
[13:36:34.754]                   }
[13:36:34.754]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:34.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.754]                   {
[13:36:34.754]                     inherits <- base::inherits
[13:36:34.754]                     invokeRestart <- base::invokeRestart
[13:36:34.754]                     is.null <- base::is.null
[13:36:34.754]                     muffled <- FALSE
[13:36:34.754]                     if (inherits(cond, "message")) {
[13:36:34.754]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:34.754]                       if (muffled) 
[13:36:34.754]                         invokeRestart("muffleMessage")
[13:36:34.754]                     }
[13:36:34.754]                     else if (inherits(cond, "warning")) {
[13:36:34.754]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:34.754]                       if (muffled) 
[13:36:34.754]                         invokeRestart("muffleWarning")
[13:36:34.754]                     }
[13:36:34.754]                     else if (inherits(cond, "condition")) {
[13:36:34.754]                       if (!is.null(pattern)) {
[13:36:34.754]                         computeRestarts <- base::computeRestarts
[13:36:34.754]                         grepl <- base::grepl
[13:36:34.754]                         restarts <- computeRestarts(cond)
[13:36:34.754]                         for (restart in restarts) {
[13:36:34.754]                           name <- restart$name
[13:36:34.754]                           if (is.null(name)) 
[13:36:34.754]                             next
[13:36:34.754]                           if (!grepl(pattern, name)) 
[13:36:34.754]                             next
[13:36:34.754]                           invokeRestart(restart)
[13:36:34.754]                           muffled <- TRUE
[13:36:34.754]                           break
[13:36:34.754]                         }
[13:36:34.754]                       }
[13:36:34.754]                     }
[13:36:34.754]                     invisible(muffled)
[13:36:34.754]                   }
[13:36:34.754]                   muffleCondition(cond)
[13:36:34.754]                 })
[13:36:34.754]             }))
[13:36:34.754]             future::FutureResult(value = ...future.value$value, 
[13:36:34.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.754]                   ...future.rng), globalenv = if (FALSE) 
[13:36:34.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:34.754]                     ...future.globalenv.names))
[13:36:34.754]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:34.754]         }, condition = base::local({
[13:36:34.754]             c <- base::c
[13:36:34.754]             inherits <- base::inherits
[13:36:34.754]             invokeRestart <- base::invokeRestart
[13:36:34.754]             length <- base::length
[13:36:34.754]             list <- base::list
[13:36:34.754]             seq.int <- base::seq.int
[13:36:34.754]             signalCondition <- base::signalCondition
[13:36:34.754]             sys.calls <- base::sys.calls
[13:36:34.754]             `[[` <- base::`[[`
[13:36:34.754]             `+` <- base::`+`
[13:36:34.754]             `<<-` <- base::`<<-`
[13:36:34.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:34.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:34.754]                   3L)]
[13:36:34.754]             }
[13:36:34.754]             function(cond) {
[13:36:34.754]                 is_error <- inherits(cond, "error")
[13:36:34.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:34.754]                   NULL)
[13:36:34.754]                 if (is_error) {
[13:36:34.754]                   sessionInformation <- function() {
[13:36:34.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:34.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:34.754]                       search = base::search(), system = base::Sys.info())
[13:36:34.754]                   }
[13:36:34.754]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:34.754]                     cond$call), session = sessionInformation(), 
[13:36:34.754]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:34.754]                   signalCondition(cond)
[13:36:34.754]                 }
[13:36:34.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:34.754]                 "immediateCondition"))) {
[13:36:34.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:34.754]                   ...future.conditions[[length(...future.conditions) + 
[13:36:34.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:34.754]                   if (TRUE && !signal) {
[13:36:34.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.754]                     {
[13:36:34.754]                       inherits <- base::inherits
[13:36:34.754]                       invokeRestart <- base::invokeRestart
[13:36:34.754]                       is.null <- base::is.null
[13:36:34.754]                       muffled <- FALSE
[13:36:34.754]                       if (inherits(cond, "message")) {
[13:36:34.754]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.754]                         if (muffled) 
[13:36:34.754]                           invokeRestart("muffleMessage")
[13:36:34.754]                       }
[13:36:34.754]                       else if (inherits(cond, "warning")) {
[13:36:34.754]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.754]                         if (muffled) 
[13:36:34.754]                           invokeRestart("muffleWarning")
[13:36:34.754]                       }
[13:36:34.754]                       else if (inherits(cond, "condition")) {
[13:36:34.754]                         if (!is.null(pattern)) {
[13:36:34.754]                           computeRestarts <- base::computeRestarts
[13:36:34.754]                           grepl <- base::grepl
[13:36:34.754]                           restarts <- computeRestarts(cond)
[13:36:34.754]                           for (restart in restarts) {
[13:36:34.754]                             name <- restart$name
[13:36:34.754]                             if (is.null(name)) 
[13:36:34.754]                               next
[13:36:34.754]                             if (!grepl(pattern, name)) 
[13:36:34.754]                               next
[13:36:34.754]                             invokeRestart(restart)
[13:36:34.754]                             muffled <- TRUE
[13:36:34.754]                             break
[13:36:34.754]                           }
[13:36:34.754]                         }
[13:36:34.754]                       }
[13:36:34.754]                       invisible(muffled)
[13:36:34.754]                     }
[13:36:34.754]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.754]                   }
[13:36:34.754]                 }
[13:36:34.754]                 else {
[13:36:34.754]                   if (TRUE) {
[13:36:34.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:34.754]                     {
[13:36:34.754]                       inherits <- base::inherits
[13:36:34.754]                       invokeRestart <- base::invokeRestart
[13:36:34.754]                       is.null <- base::is.null
[13:36:34.754]                       muffled <- FALSE
[13:36:34.754]                       if (inherits(cond, "message")) {
[13:36:34.754]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:34.754]                         if (muffled) 
[13:36:34.754]                           invokeRestart("muffleMessage")
[13:36:34.754]                       }
[13:36:34.754]                       else if (inherits(cond, "warning")) {
[13:36:34.754]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:34.754]                         if (muffled) 
[13:36:34.754]                           invokeRestart("muffleWarning")
[13:36:34.754]                       }
[13:36:34.754]                       else if (inherits(cond, "condition")) {
[13:36:34.754]                         if (!is.null(pattern)) {
[13:36:34.754]                           computeRestarts <- base::computeRestarts
[13:36:34.754]                           grepl <- base::grepl
[13:36:34.754]                           restarts <- computeRestarts(cond)
[13:36:34.754]                           for (restart in restarts) {
[13:36:34.754]                             name <- restart$name
[13:36:34.754]                             if (is.null(name)) 
[13:36:34.754]                               next
[13:36:34.754]                             if (!grepl(pattern, name)) 
[13:36:34.754]                               next
[13:36:34.754]                             invokeRestart(restart)
[13:36:34.754]                             muffled <- TRUE
[13:36:34.754]                             break
[13:36:34.754]                           }
[13:36:34.754]                         }
[13:36:34.754]                       }
[13:36:34.754]                       invisible(muffled)
[13:36:34.754]                     }
[13:36:34.754]                     muffleCondition(cond, pattern = "^muffle")
[13:36:34.754]                   }
[13:36:34.754]                 }
[13:36:34.754]             }
[13:36:34.754]         }))
[13:36:34.754]     }, error = function(ex) {
[13:36:34.754]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:34.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:34.754]                 ...future.rng), started = ...future.startTime, 
[13:36:34.754]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:34.754]             version = "1.8"), class = "FutureResult")
[13:36:34.754]     }, finally = {
[13:36:34.754]         if (!identical(...future.workdir, getwd())) 
[13:36:34.754]             setwd(...future.workdir)
[13:36:34.754]         {
[13:36:34.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:34.754]                 ...future.oldOptions$nwarnings <- NULL
[13:36:34.754]             }
[13:36:34.754]             base::options(...future.oldOptions)
[13:36:34.754]             if (.Platform$OS.type == "windows") {
[13:36:34.754]                 old_names <- names(...future.oldEnvVars)
[13:36:34.754]                 envs <- base::Sys.getenv()
[13:36:34.754]                 names <- names(envs)
[13:36:34.754]                 common <- intersect(names, old_names)
[13:36:34.754]                 added <- setdiff(names, old_names)
[13:36:34.754]                 removed <- setdiff(old_names, names)
[13:36:34.754]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:34.754]                   envs[common]]
[13:36:34.754]                 NAMES <- toupper(changed)
[13:36:34.754]                 args <- list()
[13:36:34.754]                 for (kk in seq_along(NAMES)) {
[13:36:34.754]                   name <- changed[[kk]]
[13:36:34.754]                   NAME <- NAMES[[kk]]
[13:36:34.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.754]                     next
[13:36:34.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.754]                 }
[13:36:34.754]                 NAMES <- toupper(added)
[13:36:34.754]                 for (kk in seq_along(NAMES)) {
[13:36:34.754]                   name <- added[[kk]]
[13:36:34.754]                   NAME <- NAMES[[kk]]
[13:36:34.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.754]                     next
[13:36:34.754]                   args[[name]] <- ""
[13:36:34.754]                 }
[13:36:34.754]                 NAMES <- toupper(removed)
[13:36:34.754]                 for (kk in seq_along(NAMES)) {
[13:36:34.754]                   name <- removed[[kk]]
[13:36:34.754]                   NAME <- NAMES[[kk]]
[13:36:34.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:34.754]                     next
[13:36:34.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:34.754]                 }
[13:36:34.754]                 if (length(args) > 0) 
[13:36:34.754]                   base::do.call(base::Sys.setenv, args = args)
[13:36:34.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:34.754]             }
[13:36:34.754]             else {
[13:36:34.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:34.754]             }
[13:36:34.754]             {
[13:36:34.754]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:34.754]                   0L) {
[13:36:34.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:34.754]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:34.754]                   base::options(opts)
[13:36:34.754]                 }
[13:36:34.754]                 {
[13:36:34.754]                   {
[13:36:34.754]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:34.754]                     NULL
[13:36:34.754]                   }
[13:36:34.754]                   options(future.plan = NULL)
[13:36:34.754]                   if (is.na(NA_character_)) 
[13:36:34.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:34.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:34.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:34.754]                     .init = FALSE)
[13:36:34.754]                 }
[13:36:34.754]             }
[13:36:34.754]         }
[13:36:34.754]     })
[13:36:34.754]     if (TRUE) {
[13:36:34.754]         base::sink(type = "output", split = FALSE)
[13:36:34.754]         if (TRUE) {
[13:36:34.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:34.754]         }
[13:36:34.754]         else {
[13:36:34.754]             ...future.result["stdout"] <- base::list(NULL)
[13:36:34.754]         }
[13:36:34.754]         base::close(...future.stdout)
[13:36:34.754]         ...future.stdout <- NULL
[13:36:34.754]     }
[13:36:34.754]     ...future.result$conditions <- ...future.conditions
[13:36:34.754]     ...future.result$finished <- base::Sys.time()
[13:36:34.754]     ...future.result
[13:36:34.754] }
[13:36:34.758] requestCore(): workers = 2
[13:36:34.760] MulticoreFuture started
[13:36:34.760] - Launch lazy future ... done
[13:36:34.761] run() for ‘MulticoreFuture’ ... done
List of 6
[13:36:34.761] plan(): Setting new future strategy stack:
 $ a:[13:36:34.761] List of future strategies:
[13:36:34.761] 1. sequential:
[13:36:34.761]    - args: function (..., envir = parent.frame())
[13:36:34.761]    - tweaked: FALSE
[13:36:34.761]    - call: NULL
 num 1
 $ b:[13:36:34.762] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72bc6380> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a730c51c0> 
 $  : NULL
 $  : NULL
 $  :[13:36:34.765] plan(): Setting new future strategy stack:
[13:36:34.765] List of future strategies:
[13:36:34.765] 1. multicore:
[13:36:34.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:34.765]    - tweaked: FALSE
[13:36:34.765]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72bc6380> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a730c51c0> 
 $  : NULL
 $  :[13:36:34.774] plan(): nbrOfWorkers() = 2
 NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:34.782] resolve() on list ...
[13:36:34.783]  recursive: 0
[13:36:34.783]  length: 6
[13:36:34.783]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:34.783] signalConditionsASAP(numeric, pos=1) ...
[13:36:34.783] - nx: 6
[13:36:34.783] - relay: TRUE
[13:36:34.784] - stdout: TRUE
[13:36:34.784] - signal: TRUE
[13:36:34.784] - resignal: FALSE
[13:36:34.784] - force: TRUE
[13:36:34.784] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.784] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.784]  - until=2
[13:36:34.785]  - relaying element #2
[13:36:34.785] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.785] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.785] signalConditionsASAP(NULL, pos=1) ... done
[13:36:34.785]  length: 5 (resolved future 1)
[13:36:34.785] Future #2
[13:36:34.786] result() for MulticoreFuture ...
[13:36:34.786] result() for MulticoreFuture ...
[13:36:34.787] result() for MulticoreFuture ... done
[13:36:34.787] result() for MulticoreFuture ... done
[13:36:34.787] result() for MulticoreFuture ...
[13:36:34.787] result() for MulticoreFuture ... done
[13:36:34.787] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:34.787] - nx: 6
[13:36:34.787] - relay: TRUE
[13:36:34.788] - stdout: TRUE
[13:36:34.788] - signal: TRUE
[13:36:34.788] - resignal: FALSE
[13:36:34.788] - force: TRUE
[13:36:34.788] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.788] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:34.788]  - until=2
[13:36:34.788]  - relaying element #2
[13:36:34.789] result() for MulticoreFuture ...
[13:36:34.789] result() for MulticoreFuture ... done
[13:36:34.789] result() for MulticoreFuture ...
[13:36:34.789] result() for MulticoreFuture ... done
[13:36:34.789] result() for MulticoreFuture ...
[13:36:34.789] result() for MulticoreFuture ... done
[13:36:34.789] result() for MulticoreFuture ...
[13:36:34.790] result() for MulticoreFuture ... done
[13:36:34.790] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.790] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.790] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:34.790]  length: 4 (resolved future 2)
[13:36:34.790] Future #3
[13:36:34.790] result() for MulticoreFuture ...
[13:36:34.791] result() for MulticoreFuture ...
[13:36:34.791] result() for MulticoreFuture ... done
[13:36:34.791] result() for MulticoreFuture ... done
[13:36:34.791] result() for MulticoreFuture ...
[13:36:34.792] result() for MulticoreFuture ... done
[13:36:34.792] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:34.792] - nx: 6
[13:36:34.792] - relay: TRUE
[13:36:34.792] - stdout: TRUE
[13:36:34.792] - signal: TRUE
[13:36:34.792] - resignal: FALSE
[13:36:34.792] - force: TRUE
[13:36:34.792] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.793] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:34.793]  - until=3
[13:36:34.793]  - relaying element #3
[13:36:34.793] result() for MulticoreFuture ...
[13:36:34.793] result() for MulticoreFuture ... done
[13:36:34.793] result() for MulticoreFuture ...
[13:36:34.793] result() for MulticoreFuture ... done
[13:36:34.793] result() for MulticoreFuture ...
[13:36:34.793] result() for MulticoreFuture ... done
[13:36:34.794] result() for MulticoreFuture ...
[13:36:34.794] result() for MulticoreFuture ... done
[13:36:34.794] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.794] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.794] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:34.794]  length: 3 (resolved future 3)
[13:36:34.794] signalConditionsASAP(NULL, pos=4) ...
[13:36:34.794] - nx: 6
[13:36:34.794] - relay: TRUE
[13:36:34.795] - stdout: TRUE
[13:36:34.795] - signal: TRUE
[13:36:34.795] - resignal: FALSE
[13:36:34.795] - force: TRUE
[13:36:34.795] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.795] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.795]  - until=5
[13:36:34.795]  - relaying element #5
[13:36:34.795] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.795] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.796] signalConditionsASAP(NULL, pos=4) ... done
[13:36:34.796]  length: 2 (resolved future 4)
[13:36:34.796] signalConditionsASAP(NULL, pos=5) ...
[13:36:34.796] - nx: 6
[13:36:34.796] - relay: TRUE
[13:36:34.796] - stdout: TRUE
[13:36:34.796] - signal: TRUE
[13:36:34.796] - resignal: FALSE
[13:36:34.796] - force: TRUE
[13:36:34.796] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:34.797] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.797]  - until=6
[13:36:34.797]  - relaying element #6
[13:36:34.797] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.797] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.797] signalConditionsASAP(NULL, pos=5) ... done
[13:36:34.797]  length: 1 (resolved future 5)
[13:36:34.797] signalConditionsASAP(numeric, pos=6) ...
[13:36:34.797] - nx: 6
[13:36:34.797] - relay: TRUE
[13:36:34.798] - stdout: TRUE
[13:36:34.798] - signal: TRUE
[13:36:34.798] - resignal: FALSE
[13:36:34.798] - force: TRUE
[13:36:34.798] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:34.798] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.798]  - until=6
[13:36:34.798] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.798] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.798] signalConditionsASAP(numeric, pos=6) ... done
[13:36:34.799]  length: 0 (resolved future 6)
[13:36:34.799] Relaying remaining futures
[13:36:34.799] signalConditionsASAP(NULL, pos=0) ...
[13:36:34.799] - nx: 6
[13:36:34.799] - relay: TRUE
[13:36:34.799] - stdout: TRUE
[13:36:34.799] - signal: TRUE
[13:36:34.799] - resignal: FALSE
[13:36:34.799] - force: TRUE
[13:36:34.799] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.800] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:34.800] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:34.800] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:34.800] signalConditionsASAP(NULL, pos=0) ... done
[13:36:34.800] resolve() on list ... DONE
[13:36:34.800] result() for MulticoreFuture ...
[13:36:34.800] result() for MulticoreFuture ... done
[13:36:34.800] result() for MulticoreFuture ...
[13:36:34.800] result() for MulticoreFuture ... done
[13:36:34.801] result() for MulticoreFuture ...
[13:36:34.801] result() for MulticoreFuture ... done
[13:36:34.801] result() for MulticoreFuture ...
[13:36:34.801] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[13:36:34.807] plan(): Setting new future strategy stack:
[13:36:34.807] List of future strategies:
[13:36:34.807] 1. multisession:
[13:36:34.807]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:34.807]    - tweaked: FALSE
[13:36:34.807]    - call: plan(strategy)
[13:36:34.808] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:36:34.808] multisession:
[13:36:34.808] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:34.808] - tweaked: FALSE
[13:36:34.808] - call: plan(strategy)
[13:36:34.815] getGlobalsAndPackages() ...
[13:36:34.815] Not searching for globals
[13:36:34.815] - globals: [0] <none>
[13:36:34.815] getGlobalsAndPackages() ... DONE
[13:36:34.816] [local output] makeClusterPSOCK() ...
[13:36:34.860] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:36:34.861] [local output] Base port: 11384
[13:36:34.861] [local output] Getting setup options for 2 cluster nodes ...
[13:36:34.861] [local output]  - Node 1 of 2 ...
[13:36:34.862] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:34.862] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af31cf939.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af31cf939.pid")'’
[13:36:35.053] - Possible to infer worker's PID: TRUE
[13:36:35.053] [local output] Rscript port: 11384

[13:36:35.053] [local output]  - Node 2 of 2 ...
[13:36:35.054] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:35.054] [local output] Rscript port: 11384

[13:36:35.055] [local output] Getting setup options for 2 cluster nodes ... done
[13:36:35.055] [local output]  - Parallel setup requested for some PSOCK nodes
[13:36:35.055] [local output] Setting up PSOCK nodes in parallel
[13:36:35.056] List of 36
[13:36:35.056]  $ worker          : chr "localhost"
[13:36:35.056]   ..- attr(*, "localhost")= logi TRUE
[13:36:35.056]  $ master          : chr "localhost"
[13:36:35.056]  $ port            : int 11384
[13:36:35.056]  $ connectTimeout  : num 120
[13:36:35.056]  $ timeout         : num 2592000
[13:36:35.056]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:36:35.056]  $ homogeneous     : logi TRUE
[13:36:35.056]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:36:35.056]  $ rscript_envs    : NULL
[13:36:35.056]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:35.056]  $ rscript_startup : NULL
[13:36:35.056]  $ rscript_sh      : chr "sh"
[13:36:35.056]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:35.056]  $ methods         : logi TRUE
[13:36:35.056]  $ socketOptions   : chr "no-delay"
[13:36:35.056]  $ useXDR          : logi FALSE
[13:36:35.056]  $ outfile         : chr "/dev/null"
[13:36:35.056]  $ renice          : int NA
[13:36:35.056]  $ rshcmd          : NULL
[13:36:35.056]  $ user            : chr(0) 
[13:36:35.056]  $ revtunnel       : logi FALSE
[13:36:35.056]  $ rshlogfile      : NULL
[13:36:35.056]  $ rshopts         : chr(0) 
[13:36:35.056]  $ rank            : int 1
[13:36:35.056]  $ manual          : logi FALSE
[13:36:35.056]  $ dryrun          : logi FALSE
[13:36:35.056]  $ quiet           : logi FALSE
[13:36:35.056]  $ setup_strategy  : chr "parallel"
[13:36:35.056]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:35.056]  $ pidfile         : chr "/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af31cf939.pid"
[13:36:35.056]  $ rshcmd_label    : NULL
[13:36:35.056]  $ rsh_call        : NULL
[13:36:35.056]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:35.056]  $ localMachine    : logi TRUE
[13:36:35.056]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:36:35.056]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:36:35.056]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:36:35.056]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:36:35.056]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:36:35.056]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:36:35.056]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:36:35.056]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:36:35.056]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:36:35.056]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:36:35.056]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:36:35.056]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:36:35.056]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:36:35.056]  $ arguments       :List of 28
[13:36:35.056]   ..$ worker          : chr "localhost"
[13:36:35.056]   ..$ master          : NULL
[13:36:35.056]   ..$ port            : int 11384
[13:36:35.056]   ..$ connectTimeout  : num 120
[13:36:35.056]   ..$ timeout         : num 2592000
[13:36:35.056]   ..$ rscript         : NULL
[13:36:35.056]   ..$ homogeneous     : NULL
[13:36:35.056]   ..$ rscript_args    : NULL
[13:36:35.056]   ..$ rscript_envs    : NULL
[13:36:35.056]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:35.056]   ..$ rscript_startup : NULL
[13:36:35.056]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:36:35.056]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:35.056]   ..$ methods         : logi TRUE
[13:36:35.056]   ..$ socketOptions   : chr "no-delay"
[13:36:35.056]   ..$ useXDR          : logi FALSE
[13:36:35.056]   ..$ outfile         : chr "/dev/null"
[13:36:35.056]   ..$ renice          : int NA
[13:36:35.056]   ..$ rshcmd          : NULL
[13:36:35.056]   ..$ user            : NULL
[13:36:35.056]   ..$ revtunnel       : logi NA
[13:36:35.056]   ..$ rshlogfile      : NULL
[13:36:35.056]   ..$ rshopts         : NULL
[13:36:35.056]   ..$ rank            : int 1
[13:36:35.056]   ..$ manual          : logi FALSE
[13:36:35.056]   ..$ dryrun          : logi FALSE
[13:36:35.056]   ..$ quiet           : logi FALSE
[13:36:35.056]   ..$ setup_strategy  : chr "parallel"
[13:36:35.056]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:36:35.072] [local output] System call to launch all workers:
[13:36:35.072] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af31cf939.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11384 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:36:35.073] [local output] Starting PSOCK main server
[13:36:35.078] [local output] Workers launched
[13:36:35.078] [local output] Waiting for workers to connect back
[13:36:35.079]  - [local output] 0 workers out of 2 ready
[13:36:35.339]  - [local output] 0 workers out of 2 ready
[13:36:35.339]  - [local output] 1 workers out of 2 ready
[13:36:35.351]  - [local output] 1 workers out of 2 ready
[13:36:35.352]  - [local output] 2 workers out of 2 ready
[13:36:35.352] [local output] Launching of workers completed
[13:36:35.352] [local output] Collecting session information from workers
[13:36:35.353] [local output]  - Worker #1 of 2
[13:36:35.353] [local output]  - Worker #2 of 2
[13:36:35.353] [local output] makeClusterPSOCK() ... done
[13:36:35.365] Packages needed by the future expression (n = 0): <none>
[13:36:35.365] Packages needed by future strategies (n = 0): <none>
[13:36:35.365] {
[13:36:35.365]     {
[13:36:35.365]         {
[13:36:35.365]             ...future.startTime <- base::Sys.time()
[13:36:35.365]             {
[13:36:35.365]                 {
[13:36:35.365]                   {
[13:36:35.365]                     {
[13:36:35.365]                       base::local({
[13:36:35.365]                         has_future <- base::requireNamespace("future", 
[13:36:35.365]                           quietly = TRUE)
[13:36:35.365]                         if (has_future) {
[13:36:35.365]                           ns <- base::getNamespace("future")
[13:36:35.365]                           version <- ns[[".package"]][["version"]]
[13:36:35.365]                           if (is.null(version)) 
[13:36:35.365]                             version <- utils::packageVersion("future")
[13:36:35.365]                         }
[13:36:35.365]                         else {
[13:36:35.365]                           version <- NULL
[13:36:35.365]                         }
[13:36:35.365]                         if (!has_future || version < "1.8.0") {
[13:36:35.365]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.365]                             "", base::R.version$version.string), 
[13:36:35.365]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.365]                               "release", "version")], collapse = " "), 
[13:36:35.365]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.365]                             info)
[13:36:35.365]                           info <- base::paste(info, collapse = "; ")
[13:36:35.365]                           if (!has_future) {
[13:36:35.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.365]                               info)
[13:36:35.365]                           }
[13:36:35.365]                           else {
[13:36:35.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.365]                               info, version)
[13:36:35.365]                           }
[13:36:35.365]                           base::stop(msg)
[13:36:35.365]                         }
[13:36:35.365]                       })
[13:36:35.365]                     }
[13:36:35.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.365]                     base::options(mc.cores = 1L)
[13:36:35.365]                   }
[13:36:35.365]                   ...future.strategy.old <- future::plan("list")
[13:36:35.365]                   options(future.plan = NULL)
[13:36:35.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.365]                 }
[13:36:35.365]                 ...future.workdir <- getwd()
[13:36:35.365]             }
[13:36:35.365]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.365]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.365]         }
[13:36:35.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.365]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.365]             base::names(...future.oldOptions))
[13:36:35.365]     }
[13:36:35.365]     if (FALSE) {
[13:36:35.365]     }
[13:36:35.365]     else {
[13:36:35.365]         if (TRUE) {
[13:36:35.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.365]                 open = "w")
[13:36:35.365]         }
[13:36:35.365]         else {
[13:36:35.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.365]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.365]         }
[13:36:35.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.365]             base::sink(type = "output", split = FALSE)
[13:36:35.365]             base::close(...future.stdout)
[13:36:35.365]         }, add = TRUE)
[13:36:35.365]     }
[13:36:35.365]     ...future.frame <- base::sys.nframe()
[13:36:35.365]     ...future.conditions <- base::list()
[13:36:35.365]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.365]     if (FALSE) {
[13:36:35.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.365]     }
[13:36:35.365]     ...future.result <- base::tryCatch({
[13:36:35.365]         base::withCallingHandlers({
[13:36:35.365]             ...future.value <- base::withVisible(base::local({
[13:36:35.365]                 ...future.makeSendCondition <- base::local({
[13:36:35.365]                   sendCondition <- NULL
[13:36:35.365]                   function(frame = 1L) {
[13:36:35.365]                     if (is.function(sendCondition)) 
[13:36:35.365]                       return(sendCondition)
[13:36:35.365]                     ns <- getNamespace("parallel")
[13:36:35.365]                     if (exists("sendData", mode = "function", 
[13:36:35.365]                       envir = ns)) {
[13:36:35.365]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.365]                         envir = ns)
[13:36:35.365]                       envir <- sys.frame(frame)
[13:36:35.365]                       master <- NULL
[13:36:35.365]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.365]                         !identical(envir, emptyenv())) {
[13:36:35.365]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.365]                           inherits = FALSE)) {
[13:36:35.365]                           master <- get("master", mode = "list", 
[13:36:35.365]                             envir = envir, inherits = FALSE)
[13:36:35.365]                           if (inherits(master, c("SOCKnode", 
[13:36:35.365]                             "SOCK0node"))) {
[13:36:35.365]                             sendCondition <<- function(cond) {
[13:36:35.365]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.365]                                 success = TRUE)
[13:36:35.365]                               parallel_sendData(master, data)
[13:36:35.365]                             }
[13:36:35.365]                             return(sendCondition)
[13:36:35.365]                           }
[13:36:35.365]                         }
[13:36:35.365]                         frame <- frame + 1L
[13:36:35.365]                         envir <- sys.frame(frame)
[13:36:35.365]                       }
[13:36:35.365]                     }
[13:36:35.365]                     sendCondition <<- function(cond) NULL
[13:36:35.365]                   }
[13:36:35.365]                 })
[13:36:35.365]                 withCallingHandlers({
[13:36:35.365]                   NA
[13:36:35.365]                 }, immediateCondition = function(cond) {
[13:36:35.365]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.365]                   sendCondition(cond)
[13:36:35.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.365]                   {
[13:36:35.365]                     inherits <- base::inherits
[13:36:35.365]                     invokeRestart <- base::invokeRestart
[13:36:35.365]                     is.null <- base::is.null
[13:36:35.365]                     muffled <- FALSE
[13:36:35.365]                     if (inherits(cond, "message")) {
[13:36:35.365]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.365]                       if (muffled) 
[13:36:35.365]                         invokeRestart("muffleMessage")
[13:36:35.365]                     }
[13:36:35.365]                     else if (inherits(cond, "warning")) {
[13:36:35.365]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.365]                       if (muffled) 
[13:36:35.365]                         invokeRestart("muffleWarning")
[13:36:35.365]                     }
[13:36:35.365]                     else if (inherits(cond, "condition")) {
[13:36:35.365]                       if (!is.null(pattern)) {
[13:36:35.365]                         computeRestarts <- base::computeRestarts
[13:36:35.365]                         grepl <- base::grepl
[13:36:35.365]                         restarts <- computeRestarts(cond)
[13:36:35.365]                         for (restart in restarts) {
[13:36:35.365]                           name <- restart$name
[13:36:35.365]                           if (is.null(name)) 
[13:36:35.365]                             next
[13:36:35.365]                           if (!grepl(pattern, name)) 
[13:36:35.365]                             next
[13:36:35.365]                           invokeRestart(restart)
[13:36:35.365]                           muffled <- TRUE
[13:36:35.365]                           break
[13:36:35.365]                         }
[13:36:35.365]                       }
[13:36:35.365]                     }
[13:36:35.365]                     invisible(muffled)
[13:36:35.365]                   }
[13:36:35.365]                   muffleCondition(cond)
[13:36:35.365]                 })
[13:36:35.365]             }))
[13:36:35.365]             future::FutureResult(value = ...future.value$value, 
[13:36:35.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.365]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.365]                     ...future.globalenv.names))
[13:36:35.365]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.365]         }, condition = base::local({
[13:36:35.365]             c <- base::c
[13:36:35.365]             inherits <- base::inherits
[13:36:35.365]             invokeRestart <- base::invokeRestart
[13:36:35.365]             length <- base::length
[13:36:35.365]             list <- base::list
[13:36:35.365]             seq.int <- base::seq.int
[13:36:35.365]             signalCondition <- base::signalCondition
[13:36:35.365]             sys.calls <- base::sys.calls
[13:36:35.365]             `[[` <- base::`[[`
[13:36:35.365]             `+` <- base::`+`
[13:36:35.365]             `<<-` <- base::`<<-`
[13:36:35.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.365]                   3L)]
[13:36:35.365]             }
[13:36:35.365]             function(cond) {
[13:36:35.365]                 is_error <- inherits(cond, "error")
[13:36:35.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.365]                   NULL)
[13:36:35.365]                 if (is_error) {
[13:36:35.365]                   sessionInformation <- function() {
[13:36:35.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.365]                       search = base::search(), system = base::Sys.info())
[13:36:35.365]                   }
[13:36:35.365]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.365]                     cond$call), session = sessionInformation(), 
[13:36:35.365]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.365]                   signalCondition(cond)
[13:36:35.365]                 }
[13:36:35.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.365]                 "immediateCondition"))) {
[13:36:35.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.365]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.365]                   if (TRUE && !signal) {
[13:36:35.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.365]                     {
[13:36:35.365]                       inherits <- base::inherits
[13:36:35.365]                       invokeRestart <- base::invokeRestart
[13:36:35.365]                       is.null <- base::is.null
[13:36:35.365]                       muffled <- FALSE
[13:36:35.365]                       if (inherits(cond, "message")) {
[13:36:35.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.365]                         if (muffled) 
[13:36:35.365]                           invokeRestart("muffleMessage")
[13:36:35.365]                       }
[13:36:35.365]                       else if (inherits(cond, "warning")) {
[13:36:35.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.365]                         if (muffled) 
[13:36:35.365]                           invokeRestart("muffleWarning")
[13:36:35.365]                       }
[13:36:35.365]                       else if (inherits(cond, "condition")) {
[13:36:35.365]                         if (!is.null(pattern)) {
[13:36:35.365]                           computeRestarts <- base::computeRestarts
[13:36:35.365]                           grepl <- base::grepl
[13:36:35.365]                           restarts <- computeRestarts(cond)
[13:36:35.365]                           for (restart in restarts) {
[13:36:35.365]                             name <- restart$name
[13:36:35.365]                             if (is.null(name)) 
[13:36:35.365]                               next
[13:36:35.365]                             if (!grepl(pattern, name)) 
[13:36:35.365]                               next
[13:36:35.365]                             invokeRestart(restart)
[13:36:35.365]                             muffled <- TRUE
[13:36:35.365]                             break
[13:36:35.365]                           }
[13:36:35.365]                         }
[13:36:35.365]                       }
[13:36:35.365]                       invisible(muffled)
[13:36:35.365]                     }
[13:36:35.365]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.365]                   }
[13:36:35.365]                 }
[13:36:35.365]                 else {
[13:36:35.365]                   if (TRUE) {
[13:36:35.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.365]                     {
[13:36:35.365]                       inherits <- base::inherits
[13:36:35.365]                       invokeRestart <- base::invokeRestart
[13:36:35.365]                       is.null <- base::is.null
[13:36:35.365]                       muffled <- FALSE
[13:36:35.365]                       if (inherits(cond, "message")) {
[13:36:35.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.365]                         if (muffled) 
[13:36:35.365]                           invokeRestart("muffleMessage")
[13:36:35.365]                       }
[13:36:35.365]                       else if (inherits(cond, "warning")) {
[13:36:35.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.365]                         if (muffled) 
[13:36:35.365]                           invokeRestart("muffleWarning")
[13:36:35.365]                       }
[13:36:35.365]                       else if (inherits(cond, "condition")) {
[13:36:35.365]                         if (!is.null(pattern)) {
[13:36:35.365]                           computeRestarts <- base::computeRestarts
[13:36:35.365]                           grepl <- base::grepl
[13:36:35.365]                           restarts <- computeRestarts(cond)
[13:36:35.365]                           for (restart in restarts) {
[13:36:35.365]                             name <- restart$name
[13:36:35.365]                             if (is.null(name)) 
[13:36:35.365]                               next
[13:36:35.365]                             if (!grepl(pattern, name)) 
[13:36:35.365]                               next
[13:36:35.365]                             invokeRestart(restart)
[13:36:35.365]                             muffled <- TRUE
[13:36:35.365]                             break
[13:36:35.365]                           }
[13:36:35.365]                         }
[13:36:35.365]                       }
[13:36:35.365]                       invisible(muffled)
[13:36:35.365]                     }
[13:36:35.365]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.365]                   }
[13:36:35.365]                 }
[13:36:35.365]             }
[13:36:35.365]         }))
[13:36:35.365]     }, error = function(ex) {
[13:36:35.365]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.365]                 ...future.rng), started = ...future.startTime, 
[13:36:35.365]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.365]             version = "1.8"), class = "FutureResult")
[13:36:35.365]     }, finally = {
[13:36:35.365]         if (!identical(...future.workdir, getwd())) 
[13:36:35.365]             setwd(...future.workdir)
[13:36:35.365]         {
[13:36:35.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.365]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.365]             }
[13:36:35.365]             base::options(...future.oldOptions)
[13:36:35.365]             if (.Platform$OS.type == "windows") {
[13:36:35.365]                 old_names <- names(...future.oldEnvVars)
[13:36:35.365]                 envs <- base::Sys.getenv()
[13:36:35.365]                 names <- names(envs)
[13:36:35.365]                 common <- intersect(names, old_names)
[13:36:35.365]                 added <- setdiff(names, old_names)
[13:36:35.365]                 removed <- setdiff(old_names, names)
[13:36:35.365]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.365]                   envs[common]]
[13:36:35.365]                 NAMES <- toupper(changed)
[13:36:35.365]                 args <- list()
[13:36:35.365]                 for (kk in seq_along(NAMES)) {
[13:36:35.365]                   name <- changed[[kk]]
[13:36:35.365]                   NAME <- NAMES[[kk]]
[13:36:35.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.365]                     next
[13:36:35.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.365]                 }
[13:36:35.365]                 NAMES <- toupper(added)
[13:36:35.365]                 for (kk in seq_along(NAMES)) {
[13:36:35.365]                   name <- added[[kk]]
[13:36:35.365]                   NAME <- NAMES[[kk]]
[13:36:35.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.365]                     next
[13:36:35.365]                   args[[name]] <- ""
[13:36:35.365]                 }
[13:36:35.365]                 NAMES <- toupper(removed)
[13:36:35.365]                 for (kk in seq_along(NAMES)) {
[13:36:35.365]                   name <- removed[[kk]]
[13:36:35.365]                   NAME <- NAMES[[kk]]
[13:36:35.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.365]                     next
[13:36:35.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.365]                 }
[13:36:35.365]                 if (length(args) > 0) 
[13:36:35.365]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.365]             }
[13:36:35.365]             else {
[13:36:35.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.365]             }
[13:36:35.365]             {
[13:36:35.365]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.365]                   0L) {
[13:36:35.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.365]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.365]                   base::options(opts)
[13:36:35.365]                 }
[13:36:35.365]                 {
[13:36:35.365]                   {
[13:36:35.365]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.365]                     NULL
[13:36:35.365]                   }
[13:36:35.365]                   options(future.plan = NULL)
[13:36:35.365]                   if (is.na(NA_character_)) 
[13:36:35.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.365]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.365]                     .init = FALSE)
[13:36:35.365]                 }
[13:36:35.365]             }
[13:36:35.365]         }
[13:36:35.365]     })
[13:36:35.365]     if (TRUE) {
[13:36:35.365]         base::sink(type = "output", split = FALSE)
[13:36:35.365]         if (TRUE) {
[13:36:35.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.365]         }
[13:36:35.365]         else {
[13:36:35.365]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.365]         }
[13:36:35.365]         base::close(...future.stdout)
[13:36:35.365]         ...future.stdout <- NULL
[13:36:35.365]     }
[13:36:35.365]     ...future.result$conditions <- ...future.conditions
[13:36:35.365]     ...future.result$finished <- base::Sys.time()
[13:36:35.365]     ...future.result
[13:36:35.365] }
[13:36:35.419] MultisessionFuture started
[13:36:35.420] result() for ClusterFuture ...
[13:36:35.420] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.421] - Validating connection of MultisessionFuture
[13:36:35.453] - received message: FutureResult
[13:36:35.454] - Received FutureResult
[13:36:35.454] - Erased future from FutureRegistry
[13:36:35.454] result() for ClusterFuture ...
[13:36:35.454] - result already collected: FutureResult
[13:36:35.454] result() for ClusterFuture ... done
[13:36:35.454] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:35.454] result() for ClusterFuture ... done
[13:36:35.455] result() for ClusterFuture ...
[13:36:35.455] - result already collected: FutureResult
[13:36:35.455] result() for ClusterFuture ... done
[13:36:35.455] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:36:35.459] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:36:35.460] getGlobalsAndPackages() ...
[13:36:35.460] Searching for globals...
[13:36:35.460] 
[13:36:35.460] Searching for globals ... DONE
[13:36:35.461] - globals: [0] <none>
[13:36:35.461] getGlobalsAndPackages() ... DONE
[13:36:35.461] run() for ‘Future’ ...
[13:36:35.461] - state: ‘created’
[13:36:35.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.476]   - Field: ‘node’
[13:36:35.476]   - Field: ‘label’
[13:36:35.476]   - Field: ‘local’
[13:36:35.476]   - Field: ‘owner’
[13:36:35.476]   - Field: ‘envir’
[13:36:35.476]   - Field: ‘workers’
[13:36:35.477]   - Field: ‘packages’
[13:36:35.477]   - Field: ‘gc’
[13:36:35.477]   - Field: ‘conditions’
[13:36:35.477]   - Field: ‘persistent’
[13:36:35.477]   - Field: ‘expr’
[13:36:35.477]   - Field: ‘uuid’
[13:36:35.477]   - Field: ‘seed’
[13:36:35.477]   - Field: ‘version’
[13:36:35.477]   - Field: ‘result’
[13:36:35.478]   - Field: ‘asynchronous’
[13:36:35.478]   - Field: ‘calls’
[13:36:35.478]   - Field: ‘globals’
[13:36:35.478]   - Field: ‘stdout’
[13:36:35.478]   - Field: ‘earlySignal’
[13:36:35.478]   - Field: ‘lazy’
[13:36:35.478]   - Field: ‘state’
[13:36:35.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.479] - Launch lazy future ...
[13:36:35.479] Packages needed by the future expression (n = 0): <none>
[13:36:35.479] Packages needed by future strategies (n = 0): <none>
[13:36:35.480] {
[13:36:35.480]     {
[13:36:35.480]         {
[13:36:35.480]             ...future.startTime <- base::Sys.time()
[13:36:35.480]             {
[13:36:35.480]                 {
[13:36:35.480]                   {
[13:36:35.480]                     {
[13:36:35.480]                       base::local({
[13:36:35.480]                         has_future <- base::requireNamespace("future", 
[13:36:35.480]                           quietly = TRUE)
[13:36:35.480]                         if (has_future) {
[13:36:35.480]                           ns <- base::getNamespace("future")
[13:36:35.480]                           version <- ns[[".package"]][["version"]]
[13:36:35.480]                           if (is.null(version)) 
[13:36:35.480]                             version <- utils::packageVersion("future")
[13:36:35.480]                         }
[13:36:35.480]                         else {
[13:36:35.480]                           version <- NULL
[13:36:35.480]                         }
[13:36:35.480]                         if (!has_future || version < "1.8.0") {
[13:36:35.480]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.480]                             "", base::R.version$version.string), 
[13:36:35.480]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.480]                               "release", "version")], collapse = " "), 
[13:36:35.480]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.480]                             info)
[13:36:35.480]                           info <- base::paste(info, collapse = "; ")
[13:36:35.480]                           if (!has_future) {
[13:36:35.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.480]                               info)
[13:36:35.480]                           }
[13:36:35.480]                           else {
[13:36:35.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.480]                               info, version)
[13:36:35.480]                           }
[13:36:35.480]                           base::stop(msg)
[13:36:35.480]                         }
[13:36:35.480]                       })
[13:36:35.480]                     }
[13:36:35.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.480]                     base::options(mc.cores = 1L)
[13:36:35.480]                   }
[13:36:35.480]                   ...future.strategy.old <- future::plan("list")
[13:36:35.480]                   options(future.plan = NULL)
[13:36:35.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.480]                 }
[13:36:35.480]                 ...future.workdir <- getwd()
[13:36:35.480]             }
[13:36:35.480]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.480]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.480]         }
[13:36:35.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.480]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.480]             base::names(...future.oldOptions))
[13:36:35.480]     }
[13:36:35.480]     if (FALSE) {
[13:36:35.480]     }
[13:36:35.480]     else {
[13:36:35.480]         if (TRUE) {
[13:36:35.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.480]                 open = "w")
[13:36:35.480]         }
[13:36:35.480]         else {
[13:36:35.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.480]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.480]         }
[13:36:35.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.480]             base::sink(type = "output", split = FALSE)
[13:36:35.480]             base::close(...future.stdout)
[13:36:35.480]         }, add = TRUE)
[13:36:35.480]     }
[13:36:35.480]     ...future.frame <- base::sys.nframe()
[13:36:35.480]     ...future.conditions <- base::list()
[13:36:35.480]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.480]     if (FALSE) {
[13:36:35.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.480]     }
[13:36:35.480]     ...future.result <- base::tryCatch({
[13:36:35.480]         base::withCallingHandlers({
[13:36:35.480]             ...future.value <- base::withVisible(base::local({
[13:36:35.480]                 ...future.makeSendCondition <- base::local({
[13:36:35.480]                   sendCondition <- NULL
[13:36:35.480]                   function(frame = 1L) {
[13:36:35.480]                     if (is.function(sendCondition)) 
[13:36:35.480]                       return(sendCondition)
[13:36:35.480]                     ns <- getNamespace("parallel")
[13:36:35.480]                     if (exists("sendData", mode = "function", 
[13:36:35.480]                       envir = ns)) {
[13:36:35.480]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.480]                         envir = ns)
[13:36:35.480]                       envir <- sys.frame(frame)
[13:36:35.480]                       master <- NULL
[13:36:35.480]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.480]                         !identical(envir, emptyenv())) {
[13:36:35.480]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.480]                           inherits = FALSE)) {
[13:36:35.480]                           master <- get("master", mode = "list", 
[13:36:35.480]                             envir = envir, inherits = FALSE)
[13:36:35.480]                           if (inherits(master, c("SOCKnode", 
[13:36:35.480]                             "SOCK0node"))) {
[13:36:35.480]                             sendCondition <<- function(cond) {
[13:36:35.480]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.480]                                 success = TRUE)
[13:36:35.480]                               parallel_sendData(master, data)
[13:36:35.480]                             }
[13:36:35.480]                             return(sendCondition)
[13:36:35.480]                           }
[13:36:35.480]                         }
[13:36:35.480]                         frame <- frame + 1L
[13:36:35.480]                         envir <- sys.frame(frame)
[13:36:35.480]                       }
[13:36:35.480]                     }
[13:36:35.480]                     sendCondition <<- function(cond) NULL
[13:36:35.480]                   }
[13:36:35.480]                 })
[13:36:35.480]                 withCallingHandlers({
[13:36:35.480]                   2
[13:36:35.480]                 }, immediateCondition = function(cond) {
[13:36:35.480]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.480]                   sendCondition(cond)
[13:36:35.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.480]                   {
[13:36:35.480]                     inherits <- base::inherits
[13:36:35.480]                     invokeRestart <- base::invokeRestart
[13:36:35.480]                     is.null <- base::is.null
[13:36:35.480]                     muffled <- FALSE
[13:36:35.480]                     if (inherits(cond, "message")) {
[13:36:35.480]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.480]                       if (muffled) 
[13:36:35.480]                         invokeRestart("muffleMessage")
[13:36:35.480]                     }
[13:36:35.480]                     else if (inherits(cond, "warning")) {
[13:36:35.480]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.480]                       if (muffled) 
[13:36:35.480]                         invokeRestart("muffleWarning")
[13:36:35.480]                     }
[13:36:35.480]                     else if (inherits(cond, "condition")) {
[13:36:35.480]                       if (!is.null(pattern)) {
[13:36:35.480]                         computeRestarts <- base::computeRestarts
[13:36:35.480]                         grepl <- base::grepl
[13:36:35.480]                         restarts <- computeRestarts(cond)
[13:36:35.480]                         for (restart in restarts) {
[13:36:35.480]                           name <- restart$name
[13:36:35.480]                           if (is.null(name)) 
[13:36:35.480]                             next
[13:36:35.480]                           if (!grepl(pattern, name)) 
[13:36:35.480]                             next
[13:36:35.480]                           invokeRestart(restart)
[13:36:35.480]                           muffled <- TRUE
[13:36:35.480]                           break
[13:36:35.480]                         }
[13:36:35.480]                       }
[13:36:35.480]                     }
[13:36:35.480]                     invisible(muffled)
[13:36:35.480]                   }
[13:36:35.480]                   muffleCondition(cond)
[13:36:35.480]                 })
[13:36:35.480]             }))
[13:36:35.480]             future::FutureResult(value = ...future.value$value, 
[13:36:35.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.480]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.480]                     ...future.globalenv.names))
[13:36:35.480]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.480]         }, condition = base::local({
[13:36:35.480]             c <- base::c
[13:36:35.480]             inherits <- base::inherits
[13:36:35.480]             invokeRestart <- base::invokeRestart
[13:36:35.480]             length <- base::length
[13:36:35.480]             list <- base::list
[13:36:35.480]             seq.int <- base::seq.int
[13:36:35.480]             signalCondition <- base::signalCondition
[13:36:35.480]             sys.calls <- base::sys.calls
[13:36:35.480]             `[[` <- base::`[[`
[13:36:35.480]             `+` <- base::`+`
[13:36:35.480]             `<<-` <- base::`<<-`
[13:36:35.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.480]                   3L)]
[13:36:35.480]             }
[13:36:35.480]             function(cond) {
[13:36:35.480]                 is_error <- inherits(cond, "error")
[13:36:35.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.480]                   NULL)
[13:36:35.480]                 if (is_error) {
[13:36:35.480]                   sessionInformation <- function() {
[13:36:35.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.480]                       search = base::search(), system = base::Sys.info())
[13:36:35.480]                   }
[13:36:35.480]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.480]                     cond$call), session = sessionInformation(), 
[13:36:35.480]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.480]                   signalCondition(cond)
[13:36:35.480]                 }
[13:36:35.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.480]                 "immediateCondition"))) {
[13:36:35.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.480]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.480]                   if (TRUE && !signal) {
[13:36:35.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.480]                     {
[13:36:35.480]                       inherits <- base::inherits
[13:36:35.480]                       invokeRestart <- base::invokeRestart
[13:36:35.480]                       is.null <- base::is.null
[13:36:35.480]                       muffled <- FALSE
[13:36:35.480]                       if (inherits(cond, "message")) {
[13:36:35.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.480]                         if (muffled) 
[13:36:35.480]                           invokeRestart("muffleMessage")
[13:36:35.480]                       }
[13:36:35.480]                       else if (inherits(cond, "warning")) {
[13:36:35.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.480]                         if (muffled) 
[13:36:35.480]                           invokeRestart("muffleWarning")
[13:36:35.480]                       }
[13:36:35.480]                       else if (inherits(cond, "condition")) {
[13:36:35.480]                         if (!is.null(pattern)) {
[13:36:35.480]                           computeRestarts <- base::computeRestarts
[13:36:35.480]                           grepl <- base::grepl
[13:36:35.480]                           restarts <- computeRestarts(cond)
[13:36:35.480]                           for (restart in restarts) {
[13:36:35.480]                             name <- restart$name
[13:36:35.480]                             if (is.null(name)) 
[13:36:35.480]                               next
[13:36:35.480]                             if (!grepl(pattern, name)) 
[13:36:35.480]                               next
[13:36:35.480]                             invokeRestart(restart)
[13:36:35.480]                             muffled <- TRUE
[13:36:35.480]                             break
[13:36:35.480]                           }
[13:36:35.480]                         }
[13:36:35.480]                       }
[13:36:35.480]                       invisible(muffled)
[13:36:35.480]                     }
[13:36:35.480]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.480]                   }
[13:36:35.480]                 }
[13:36:35.480]                 else {
[13:36:35.480]                   if (TRUE) {
[13:36:35.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.480]                     {
[13:36:35.480]                       inherits <- base::inherits
[13:36:35.480]                       invokeRestart <- base::invokeRestart
[13:36:35.480]                       is.null <- base::is.null
[13:36:35.480]                       muffled <- FALSE
[13:36:35.480]                       if (inherits(cond, "message")) {
[13:36:35.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.480]                         if (muffled) 
[13:36:35.480]                           invokeRestart("muffleMessage")
[13:36:35.480]                       }
[13:36:35.480]                       else if (inherits(cond, "warning")) {
[13:36:35.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.480]                         if (muffled) 
[13:36:35.480]                           invokeRestart("muffleWarning")
[13:36:35.480]                       }
[13:36:35.480]                       else if (inherits(cond, "condition")) {
[13:36:35.480]                         if (!is.null(pattern)) {
[13:36:35.480]                           computeRestarts <- base::computeRestarts
[13:36:35.480]                           grepl <- base::grepl
[13:36:35.480]                           restarts <- computeRestarts(cond)
[13:36:35.480]                           for (restart in restarts) {
[13:36:35.480]                             name <- restart$name
[13:36:35.480]                             if (is.null(name)) 
[13:36:35.480]                               next
[13:36:35.480]                             if (!grepl(pattern, name)) 
[13:36:35.480]                               next
[13:36:35.480]                             invokeRestart(restart)
[13:36:35.480]                             muffled <- TRUE
[13:36:35.480]                             break
[13:36:35.480]                           }
[13:36:35.480]                         }
[13:36:35.480]                       }
[13:36:35.480]                       invisible(muffled)
[13:36:35.480]                     }
[13:36:35.480]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.480]                   }
[13:36:35.480]                 }
[13:36:35.480]             }
[13:36:35.480]         }))
[13:36:35.480]     }, error = function(ex) {
[13:36:35.480]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.480]                 ...future.rng), started = ...future.startTime, 
[13:36:35.480]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.480]             version = "1.8"), class = "FutureResult")
[13:36:35.480]     }, finally = {
[13:36:35.480]         if (!identical(...future.workdir, getwd())) 
[13:36:35.480]             setwd(...future.workdir)
[13:36:35.480]         {
[13:36:35.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.480]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.480]             }
[13:36:35.480]             base::options(...future.oldOptions)
[13:36:35.480]             if (.Platform$OS.type == "windows") {
[13:36:35.480]                 old_names <- names(...future.oldEnvVars)
[13:36:35.480]                 envs <- base::Sys.getenv()
[13:36:35.480]                 names <- names(envs)
[13:36:35.480]                 common <- intersect(names, old_names)
[13:36:35.480]                 added <- setdiff(names, old_names)
[13:36:35.480]                 removed <- setdiff(old_names, names)
[13:36:35.480]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.480]                   envs[common]]
[13:36:35.480]                 NAMES <- toupper(changed)
[13:36:35.480]                 args <- list()
[13:36:35.480]                 for (kk in seq_along(NAMES)) {
[13:36:35.480]                   name <- changed[[kk]]
[13:36:35.480]                   NAME <- NAMES[[kk]]
[13:36:35.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.480]                     next
[13:36:35.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.480]                 }
[13:36:35.480]                 NAMES <- toupper(added)
[13:36:35.480]                 for (kk in seq_along(NAMES)) {
[13:36:35.480]                   name <- added[[kk]]
[13:36:35.480]                   NAME <- NAMES[[kk]]
[13:36:35.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.480]                     next
[13:36:35.480]                   args[[name]] <- ""
[13:36:35.480]                 }
[13:36:35.480]                 NAMES <- toupper(removed)
[13:36:35.480]                 for (kk in seq_along(NAMES)) {
[13:36:35.480]                   name <- removed[[kk]]
[13:36:35.480]                   NAME <- NAMES[[kk]]
[13:36:35.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.480]                     next
[13:36:35.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.480]                 }
[13:36:35.480]                 if (length(args) > 0) 
[13:36:35.480]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.480]             }
[13:36:35.480]             else {
[13:36:35.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.480]             }
[13:36:35.480]             {
[13:36:35.480]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.480]                   0L) {
[13:36:35.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.480]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.480]                   base::options(opts)
[13:36:35.480]                 }
[13:36:35.480]                 {
[13:36:35.480]                   {
[13:36:35.480]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.480]                     NULL
[13:36:35.480]                   }
[13:36:35.480]                   options(future.plan = NULL)
[13:36:35.480]                   if (is.na(NA_character_)) 
[13:36:35.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.480]                     .init = FALSE)
[13:36:35.480]                 }
[13:36:35.480]             }
[13:36:35.480]         }
[13:36:35.480]     })
[13:36:35.480]     if (TRUE) {
[13:36:35.480]         base::sink(type = "output", split = FALSE)
[13:36:35.480]         if (TRUE) {
[13:36:35.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.480]         }
[13:36:35.480]         else {
[13:36:35.480]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.480]         }
[13:36:35.480]         base::close(...future.stdout)
[13:36:35.480]         ...future.stdout <- NULL
[13:36:35.480]     }
[13:36:35.480]     ...future.result$conditions <- ...future.conditions
[13:36:35.480]     ...future.result$finished <- base::Sys.time()
[13:36:35.480]     ...future.result
[13:36:35.480] }
[13:36:35.483] MultisessionFuture started
[13:36:35.483] - Launch lazy future ... done
[13:36:35.483] run() for ‘MultisessionFuture’ ... done
[13:36:35.483] getGlobalsAndPackages() ...
[13:36:35.483] Searching for globals...
[13:36:35.484] 
[13:36:35.484] Searching for globals ... DONE
[13:36:35.484] - globals: [0] <none>
[13:36:35.484] getGlobalsAndPackages() ... DONE
[13:36:35.484] run() for ‘Future’ ...
[13:36:35.484] - state: ‘created’
[13:36:35.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.499]   - Field: ‘node’
[13:36:35.499]   - Field: ‘label’
[13:36:35.499]   - Field: ‘local’
[13:36:35.499]   - Field: ‘owner’
[13:36:35.499]   - Field: ‘envir’
[13:36:35.499]   - Field: ‘workers’
[13:36:35.500]   - Field: ‘packages’
[13:36:35.500]   - Field: ‘gc’
[13:36:35.500]   - Field: ‘conditions’
[13:36:35.500]   - Field: ‘persistent’
[13:36:35.500]   - Field: ‘expr’
[13:36:35.500]   - Field: ‘uuid’
[13:36:35.500]   - Field: ‘seed’
[13:36:35.500]   - Field: ‘version’
[13:36:35.500]   - Field: ‘result’
[13:36:35.501]   - Field: ‘asynchronous’
[13:36:35.501]   - Field: ‘calls’
[13:36:35.501]   - Field: ‘globals’
[13:36:35.501]   - Field: ‘stdout’
[13:36:35.501]   - Field: ‘earlySignal’
[13:36:35.501]   - Field: ‘lazy’
[13:36:35.501]   - Field: ‘state’
[13:36:35.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.502] - Launch lazy future ...
[13:36:35.502] Packages needed by the future expression (n = 0): <none>
[13:36:35.502] Packages needed by future strategies (n = 0): <none>
[13:36:35.502] {
[13:36:35.502]     {
[13:36:35.502]         {
[13:36:35.502]             ...future.startTime <- base::Sys.time()
[13:36:35.502]             {
[13:36:35.502]                 {
[13:36:35.502]                   {
[13:36:35.502]                     {
[13:36:35.502]                       base::local({
[13:36:35.502]                         has_future <- base::requireNamespace("future", 
[13:36:35.502]                           quietly = TRUE)
[13:36:35.502]                         if (has_future) {
[13:36:35.502]                           ns <- base::getNamespace("future")
[13:36:35.502]                           version <- ns[[".package"]][["version"]]
[13:36:35.502]                           if (is.null(version)) 
[13:36:35.502]                             version <- utils::packageVersion("future")
[13:36:35.502]                         }
[13:36:35.502]                         else {
[13:36:35.502]                           version <- NULL
[13:36:35.502]                         }
[13:36:35.502]                         if (!has_future || version < "1.8.0") {
[13:36:35.502]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.502]                             "", base::R.version$version.string), 
[13:36:35.502]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.502]                               "release", "version")], collapse = " "), 
[13:36:35.502]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.502]                             info)
[13:36:35.502]                           info <- base::paste(info, collapse = "; ")
[13:36:35.502]                           if (!has_future) {
[13:36:35.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.502]                               info)
[13:36:35.502]                           }
[13:36:35.502]                           else {
[13:36:35.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.502]                               info, version)
[13:36:35.502]                           }
[13:36:35.502]                           base::stop(msg)
[13:36:35.502]                         }
[13:36:35.502]                       })
[13:36:35.502]                     }
[13:36:35.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.502]                     base::options(mc.cores = 1L)
[13:36:35.502]                   }
[13:36:35.502]                   ...future.strategy.old <- future::plan("list")
[13:36:35.502]                   options(future.plan = NULL)
[13:36:35.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.502]                 }
[13:36:35.502]                 ...future.workdir <- getwd()
[13:36:35.502]             }
[13:36:35.502]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.502]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.502]         }
[13:36:35.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.502]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.502]             base::names(...future.oldOptions))
[13:36:35.502]     }
[13:36:35.502]     if (FALSE) {
[13:36:35.502]     }
[13:36:35.502]     else {
[13:36:35.502]         if (TRUE) {
[13:36:35.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.502]                 open = "w")
[13:36:35.502]         }
[13:36:35.502]         else {
[13:36:35.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.502]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.502]         }
[13:36:35.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.502]             base::sink(type = "output", split = FALSE)
[13:36:35.502]             base::close(...future.stdout)
[13:36:35.502]         }, add = TRUE)
[13:36:35.502]     }
[13:36:35.502]     ...future.frame <- base::sys.nframe()
[13:36:35.502]     ...future.conditions <- base::list()
[13:36:35.502]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.502]     if (FALSE) {
[13:36:35.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.502]     }
[13:36:35.502]     ...future.result <- base::tryCatch({
[13:36:35.502]         base::withCallingHandlers({
[13:36:35.502]             ...future.value <- base::withVisible(base::local({
[13:36:35.502]                 ...future.makeSendCondition <- base::local({
[13:36:35.502]                   sendCondition <- NULL
[13:36:35.502]                   function(frame = 1L) {
[13:36:35.502]                     if (is.function(sendCondition)) 
[13:36:35.502]                       return(sendCondition)
[13:36:35.502]                     ns <- getNamespace("parallel")
[13:36:35.502]                     if (exists("sendData", mode = "function", 
[13:36:35.502]                       envir = ns)) {
[13:36:35.502]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.502]                         envir = ns)
[13:36:35.502]                       envir <- sys.frame(frame)
[13:36:35.502]                       master <- NULL
[13:36:35.502]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.502]                         !identical(envir, emptyenv())) {
[13:36:35.502]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.502]                           inherits = FALSE)) {
[13:36:35.502]                           master <- get("master", mode = "list", 
[13:36:35.502]                             envir = envir, inherits = FALSE)
[13:36:35.502]                           if (inherits(master, c("SOCKnode", 
[13:36:35.502]                             "SOCK0node"))) {
[13:36:35.502]                             sendCondition <<- function(cond) {
[13:36:35.502]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.502]                                 success = TRUE)
[13:36:35.502]                               parallel_sendData(master, data)
[13:36:35.502]                             }
[13:36:35.502]                             return(sendCondition)
[13:36:35.502]                           }
[13:36:35.502]                         }
[13:36:35.502]                         frame <- frame + 1L
[13:36:35.502]                         envir <- sys.frame(frame)
[13:36:35.502]                       }
[13:36:35.502]                     }
[13:36:35.502]                     sendCondition <<- function(cond) NULL
[13:36:35.502]                   }
[13:36:35.502]                 })
[13:36:35.502]                 withCallingHandlers({
[13:36:35.502]                   NULL
[13:36:35.502]                 }, immediateCondition = function(cond) {
[13:36:35.502]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.502]                   sendCondition(cond)
[13:36:35.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.502]                   {
[13:36:35.502]                     inherits <- base::inherits
[13:36:35.502]                     invokeRestart <- base::invokeRestart
[13:36:35.502]                     is.null <- base::is.null
[13:36:35.502]                     muffled <- FALSE
[13:36:35.502]                     if (inherits(cond, "message")) {
[13:36:35.502]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.502]                       if (muffled) 
[13:36:35.502]                         invokeRestart("muffleMessage")
[13:36:35.502]                     }
[13:36:35.502]                     else if (inherits(cond, "warning")) {
[13:36:35.502]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.502]                       if (muffled) 
[13:36:35.502]                         invokeRestart("muffleWarning")
[13:36:35.502]                     }
[13:36:35.502]                     else if (inherits(cond, "condition")) {
[13:36:35.502]                       if (!is.null(pattern)) {
[13:36:35.502]                         computeRestarts <- base::computeRestarts
[13:36:35.502]                         grepl <- base::grepl
[13:36:35.502]                         restarts <- computeRestarts(cond)
[13:36:35.502]                         for (restart in restarts) {
[13:36:35.502]                           name <- restart$name
[13:36:35.502]                           if (is.null(name)) 
[13:36:35.502]                             next
[13:36:35.502]                           if (!grepl(pattern, name)) 
[13:36:35.502]                             next
[13:36:35.502]                           invokeRestart(restart)
[13:36:35.502]                           muffled <- TRUE
[13:36:35.502]                           break
[13:36:35.502]                         }
[13:36:35.502]                       }
[13:36:35.502]                     }
[13:36:35.502]                     invisible(muffled)
[13:36:35.502]                   }
[13:36:35.502]                   muffleCondition(cond)
[13:36:35.502]                 })
[13:36:35.502]             }))
[13:36:35.502]             future::FutureResult(value = ...future.value$value, 
[13:36:35.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.502]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.502]                     ...future.globalenv.names))
[13:36:35.502]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.502]         }, condition = base::local({
[13:36:35.502]             c <- base::c
[13:36:35.502]             inherits <- base::inherits
[13:36:35.502]             invokeRestart <- base::invokeRestart
[13:36:35.502]             length <- base::length
[13:36:35.502]             list <- base::list
[13:36:35.502]             seq.int <- base::seq.int
[13:36:35.502]             signalCondition <- base::signalCondition
[13:36:35.502]             sys.calls <- base::sys.calls
[13:36:35.502]             `[[` <- base::`[[`
[13:36:35.502]             `+` <- base::`+`
[13:36:35.502]             `<<-` <- base::`<<-`
[13:36:35.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.502]                   3L)]
[13:36:35.502]             }
[13:36:35.502]             function(cond) {
[13:36:35.502]                 is_error <- inherits(cond, "error")
[13:36:35.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.502]                   NULL)
[13:36:35.502]                 if (is_error) {
[13:36:35.502]                   sessionInformation <- function() {
[13:36:35.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.502]                       search = base::search(), system = base::Sys.info())
[13:36:35.502]                   }
[13:36:35.502]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.502]                     cond$call), session = sessionInformation(), 
[13:36:35.502]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.502]                   signalCondition(cond)
[13:36:35.502]                 }
[13:36:35.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.502]                 "immediateCondition"))) {
[13:36:35.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.502]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.502]                   if (TRUE && !signal) {
[13:36:35.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.502]                     {
[13:36:35.502]                       inherits <- base::inherits
[13:36:35.502]                       invokeRestart <- base::invokeRestart
[13:36:35.502]                       is.null <- base::is.null
[13:36:35.502]                       muffled <- FALSE
[13:36:35.502]                       if (inherits(cond, "message")) {
[13:36:35.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.502]                         if (muffled) 
[13:36:35.502]                           invokeRestart("muffleMessage")
[13:36:35.502]                       }
[13:36:35.502]                       else if (inherits(cond, "warning")) {
[13:36:35.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.502]                         if (muffled) 
[13:36:35.502]                           invokeRestart("muffleWarning")
[13:36:35.502]                       }
[13:36:35.502]                       else if (inherits(cond, "condition")) {
[13:36:35.502]                         if (!is.null(pattern)) {
[13:36:35.502]                           computeRestarts <- base::computeRestarts
[13:36:35.502]                           grepl <- base::grepl
[13:36:35.502]                           restarts <- computeRestarts(cond)
[13:36:35.502]                           for (restart in restarts) {
[13:36:35.502]                             name <- restart$name
[13:36:35.502]                             if (is.null(name)) 
[13:36:35.502]                               next
[13:36:35.502]                             if (!grepl(pattern, name)) 
[13:36:35.502]                               next
[13:36:35.502]                             invokeRestart(restart)
[13:36:35.502]                             muffled <- TRUE
[13:36:35.502]                             break
[13:36:35.502]                           }
[13:36:35.502]                         }
[13:36:35.502]                       }
[13:36:35.502]                       invisible(muffled)
[13:36:35.502]                     }
[13:36:35.502]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.502]                   }
[13:36:35.502]                 }
[13:36:35.502]                 else {
[13:36:35.502]                   if (TRUE) {
[13:36:35.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.502]                     {
[13:36:35.502]                       inherits <- base::inherits
[13:36:35.502]                       invokeRestart <- base::invokeRestart
[13:36:35.502]                       is.null <- base::is.null
[13:36:35.502]                       muffled <- FALSE
[13:36:35.502]                       if (inherits(cond, "message")) {
[13:36:35.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.502]                         if (muffled) 
[13:36:35.502]                           invokeRestart("muffleMessage")
[13:36:35.502]                       }
[13:36:35.502]                       else if (inherits(cond, "warning")) {
[13:36:35.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.502]                         if (muffled) 
[13:36:35.502]                           invokeRestart("muffleWarning")
[13:36:35.502]                       }
[13:36:35.502]                       else if (inherits(cond, "condition")) {
[13:36:35.502]                         if (!is.null(pattern)) {
[13:36:35.502]                           computeRestarts <- base::computeRestarts
[13:36:35.502]                           grepl <- base::grepl
[13:36:35.502]                           restarts <- computeRestarts(cond)
[13:36:35.502]                           for (restart in restarts) {
[13:36:35.502]                             name <- restart$name
[13:36:35.502]                             if (is.null(name)) 
[13:36:35.502]                               next
[13:36:35.502]                             if (!grepl(pattern, name)) 
[13:36:35.502]                               next
[13:36:35.502]                             invokeRestart(restart)
[13:36:35.502]                             muffled <- TRUE
[13:36:35.502]                             break
[13:36:35.502]                           }
[13:36:35.502]                         }
[13:36:35.502]                       }
[13:36:35.502]                       invisible(muffled)
[13:36:35.502]                     }
[13:36:35.502]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.502]                   }
[13:36:35.502]                 }
[13:36:35.502]             }
[13:36:35.502]         }))
[13:36:35.502]     }, error = function(ex) {
[13:36:35.502]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.502]                 ...future.rng), started = ...future.startTime, 
[13:36:35.502]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.502]             version = "1.8"), class = "FutureResult")
[13:36:35.502]     }, finally = {
[13:36:35.502]         if (!identical(...future.workdir, getwd())) 
[13:36:35.502]             setwd(...future.workdir)
[13:36:35.502]         {
[13:36:35.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.502]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.502]             }
[13:36:35.502]             base::options(...future.oldOptions)
[13:36:35.502]             if (.Platform$OS.type == "windows") {
[13:36:35.502]                 old_names <- names(...future.oldEnvVars)
[13:36:35.502]                 envs <- base::Sys.getenv()
[13:36:35.502]                 names <- names(envs)
[13:36:35.502]                 common <- intersect(names, old_names)
[13:36:35.502]                 added <- setdiff(names, old_names)
[13:36:35.502]                 removed <- setdiff(old_names, names)
[13:36:35.502]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.502]                   envs[common]]
[13:36:35.502]                 NAMES <- toupper(changed)
[13:36:35.502]                 args <- list()
[13:36:35.502]                 for (kk in seq_along(NAMES)) {
[13:36:35.502]                   name <- changed[[kk]]
[13:36:35.502]                   NAME <- NAMES[[kk]]
[13:36:35.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.502]                     next
[13:36:35.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.502]                 }
[13:36:35.502]                 NAMES <- toupper(added)
[13:36:35.502]                 for (kk in seq_along(NAMES)) {
[13:36:35.502]                   name <- added[[kk]]
[13:36:35.502]                   NAME <- NAMES[[kk]]
[13:36:35.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.502]                     next
[13:36:35.502]                   args[[name]] <- ""
[13:36:35.502]                 }
[13:36:35.502]                 NAMES <- toupper(removed)
[13:36:35.502]                 for (kk in seq_along(NAMES)) {
[13:36:35.502]                   name <- removed[[kk]]
[13:36:35.502]                   NAME <- NAMES[[kk]]
[13:36:35.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.502]                     next
[13:36:35.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.502]                 }
[13:36:35.502]                 if (length(args) > 0) 
[13:36:35.502]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.502]             }
[13:36:35.502]             else {
[13:36:35.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.502]             }
[13:36:35.502]             {
[13:36:35.502]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.502]                   0L) {
[13:36:35.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.502]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.502]                   base::options(opts)
[13:36:35.502]                 }
[13:36:35.502]                 {
[13:36:35.502]                   {
[13:36:35.502]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.502]                     NULL
[13:36:35.502]                   }
[13:36:35.502]                   options(future.plan = NULL)
[13:36:35.502]                   if (is.na(NA_character_)) 
[13:36:35.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.502]                     .init = FALSE)
[13:36:35.502]                 }
[13:36:35.502]             }
[13:36:35.502]         }
[13:36:35.502]     })
[13:36:35.502]     if (TRUE) {
[13:36:35.502]         base::sink(type = "output", split = FALSE)
[13:36:35.502]         if (TRUE) {
[13:36:35.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.502]         }
[13:36:35.502]         else {
[13:36:35.502]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.502]         }
[13:36:35.502]         base::close(...future.stdout)
[13:36:35.502]         ...future.stdout <- NULL
[13:36:35.502]     }
[13:36:35.502]     ...future.result$conditions <- ...future.conditions
[13:36:35.502]     ...future.result$finished <- base::Sys.time()
[13:36:35.502]     ...future.result
[13:36:35.502] }
[13:36:35.558] MultisessionFuture started
[13:36:35.558] - Launch lazy future ... done
[13:36:35.558] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a742591d8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a746bc658> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a742591d8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a746bc658> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:36:35.564] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.564] - Validating connection of MultisessionFuture
[13:36:35.564] - received message: FutureResult
[13:36:35.564] - Received FutureResult
[13:36:35.564] - Erased future from FutureRegistry
[13:36:35.565] result() for ClusterFuture ...
[13:36:35.565] - result already collected: FutureResult
[13:36:35.565] result() for ClusterFuture ... done
[13:36:35.565] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:35.576] resolve() on list ...
[13:36:35.576]  recursive: 0
[13:36:35.576]  length: 6
[13:36:35.577]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:35.577] signalConditionsASAP(numeric, pos=1) ...
[13:36:35.577] - nx: 6
[13:36:35.577] - relay: TRUE
[13:36:35.577] - stdout: TRUE
[13:36:35.577] - signal: TRUE
[13:36:35.577] - resignal: FALSE
[13:36:35.577] - force: TRUE
[13:36:35.577] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.578] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.578]  - until=2
[13:36:35.578]  - relaying element #2
[13:36:35.578] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.578] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.578] signalConditionsASAP(NULL, pos=1) ... done
[13:36:35.578]  length: 5 (resolved future 1)
[13:36:35.578] Future #2
[13:36:35.579] result() for ClusterFuture ...
[13:36:35.579] - result already collected: FutureResult
[13:36:35.579] result() for ClusterFuture ... done
[13:36:35.579] result() for ClusterFuture ...
[13:36:35.579] - result already collected: FutureResult
[13:36:35.579] result() for ClusterFuture ... done
[13:36:35.579] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:35.579] - nx: 6
[13:36:35.579] - relay: TRUE
[13:36:35.580] - stdout: TRUE
[13:36:35.580] - signal: TRUE
[13:36:35.580] - resignal: FALSE
[13:36:35.580] - force: TRUE
[13:36:35.580] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.580] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.580]  - until=2
[13:36:35.580]  - relaying element #2
[13:36:35.580] result() for ClusterFuture ...
[13:36:35.581] - result already collected: FutureResult
[13:36:35.581] result() for ClusterFuture ... done
[13:36:35.581] result() for ClusterFuture ...
[13:36:35.581] - result already collected: FutureResult
[13:36:35.581] result() for ClusterFuture ... done
[13:36:35.581] result() for ClusterFuture ...
[13:36:35.581] - result already collected: FutureResult
[13:36:35.581] result() for ClusterFuture ... done
[13:36:35.581] result() for ClusterFuture ...
[13:36:35.582] - result already collected: FutureResult
[13:36:35.582] result() for ClusterFuture ... done
[13:36:35.582] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.582] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.582] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:35.582]  length: 4 (resolved future 2)
[13:36:35.592] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.592] - Validating connection of MultisessionFuture
[13:36:35.592] - received message: FutureResult
[13:36:35.592] - Received FutureResult
[13:36:35.592] - Erased future from FutureRegistry
[13:36:35.593] result() for ClusterFuture ...
[13:36:35.593] - result already collected: FutureResult
[13:36:35.593] result() for ClusterFuture ... done
[13:36:35.593] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:35.593] Future #3
[13:36:35.593] result() for ClusterFuture ...
[13:36:35.593] - result already collected: FutureResult
[13:36:35.593] result() for ClusterFuture ... done
[13:36:35.594] result() for ClusterFuture ...
[13:36:35.594] - result already collected: FutureResult
[13:36:35.594] result() for ClusterFuture ... done
[13:36:35.594] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:35.594] - nx: 6
[13:36:35.594] - relay: TRUE
[13:36:35.594] - stdout: TRUE
[13:36:35.594] - signal: TRUE
[13:36:35.594] - resignal: FALSE
[13:36:35.595] - force: TRUE
[13:36:35.595] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.595] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.595]  - until=3
[13:36:35.595]  - relaying element #3
[13:36:35.595] result() for ClusterFuture ...
[13:36:35.595] - result already collected: FutureResult
[13:36:35.595] result() for ClusterFuture ... done
[13:36:35.596] result() for ClusterFuture ...
[13:36:35.596] - result already collected: FutureResult
[13:36:35.596] result() for ClusterFuture ... done
[13:36:35.596] result() for ClusterFuture ...
[13:36:35.596] - result already collected: FutureResult
[13:36:35.596] result() for ClusterFuture ... done
[13:36:35.596] result() for ClusterFuture ...
[13:36:35.596] - result already collected: FutureResult
[13:36:35.596] result() for ClusterFuture ... done
[13:36:35.597] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.597] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.597] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:35.597]  length: 3 (resolved future 3)
[13:36:35.597] signalConditionsASAP(NULL, pos=4) ...
[13:36:35.597] - nx: 6
[13:36:35.597] - relay: TRUE
[13:36:35.597] - stdout: TRUE
[13:36:35.597] - signal: TRUE
[13:36:35.598] - resignal: FALSE
[13:36:35.598] - force: TRUE
[13:36:35.598] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.598] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.598]  - until=5
[13:36:35.598]  - relaying element #5
[13:36:35.598] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.598] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.599] signalConditionsASAP(NULL, pos=4) ... done
[13:36:35.599]  length: 2 (resolved future 4)
[13:36:35.599] signalConditionsASAP(NULL, pos=5) ...
[13:36:35.599] - nx: 6
[13:36:35.599] - relay: TRUE
[13:36:35.599] - stdout: TRUE
[13:36:35.599] - signal: TRUE
[13:36:35.599] - resignal: FALSE
[13:36:35.599] - force: TRUE
[13:36:35.599] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.600] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.600]  - until=6
[13:36:35.600]  - relaying element #6
[13:36:35.600] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.600] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.600] signalConditionsASAP(NULL, pos=5) ... done
[13:36:35.600]  length: 1 (resolved future 5)
[13:36:35.600] signalConditionsASAP(numeric, pos=6) ...
[13:36:35.600] - nx: 6
[13:36:35.601] - relay: TRUE
[13:36:35.601] - stdout: TRUE
[13:36:35.601] - signal: TRUE
[13:36:35.601] - resignal: FALSE
[13:36:35.601] - force: TRUE
[13:36:35.601] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.601] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.601]  - until=6
[13:36:35.601] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.602] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.602] signalConditionsASAP(numeric, pos=6) ... done
[13:36:35.602]  length: 0 (resolved future 6)
[13:36:35.602] Relaying remaining futures
[13:36:35.602] signalConditionsASAP(NULL, pos=0) ...
[13:36:35.602] - nx: 6
[13:36:35.602] - relay: TRUE
[13:36:35.602] - stdout: TRUE
[13:36:35.602] - signal: TRUE
[13:36:35.603] - resignal: FALSE
[13:36:35.603] - force: TRUE
[13:36:35.605] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.605] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:35.606] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.606] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.606] signalConditionsASAP(NULL, pos=0) ... done
[13:36:35.606] resolve() on list ... DONE
[13:36:35.606] result() for ClusterFuture ...
[13:36:35.606] - result already collected: FutureResult
[13:36:35.606] result() for ClusterFuture ... done
[13:36:35.606] result() for ClusterFuture ...
[13:36:35.606] - result already collected: FutureResult
[13:36:35.606] result() for ClusterFuture ... done
[13:36:35.607] result() for ClusterFuture ...
[13:36:35.607] - result already collected: FutureResult
[13:36:35.607] result() for ClusterFuture ... done
[13:36:35.607] result() for ClusterFuture ...
[13:36:35.607] - result already collected: FutureResult
[13:36:35.607] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:36:35.609] getGlobalsAndPackages() ...
[13:36:35.609] Searching for globals...
[13:36:35.609] 
[13:36:35.610] Searching for globals ... DONE
[13:36:35.610] - globals: [0] <none>
[13:36:35.610] getGlobalsAndPackages() ... DONE
[13:36:35.610] run() for ‘Future’ ...
[13:36:35.610] - state: ‘created’
[13:36:35.610] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.624] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.625]   - Field: ‘node’
[13:36:35.625]   - Field: ‘label’
[13:36:35.625]   - Field: ‘local’
[13:36:35.625]   - Field: ‘owner’
[13:36:35.625]   - Field: ‘envir’
[13:36:35.625]   - Field: ‘workers’
[13:36:35.625]   - Field: ‘packages’
[13:36:35.625]   - Field: ‘gc’
[13:36:35.625]   - Field: ‘conditions’
[13:36:35.625]   - Field: ‘persistent’
[13:36:35.625]   - Field: ‘expr’
[13:36:35.626]   - Field: ‘uuid’
[13:36:35.626]   - Field: ‘seed’
[13:36:35.626]   - Field: ‘version’
[13:36:35.626]   - Field: ‘result’
[13:36:35.626]   - Field: ‘asynchronous’
[13:36:35.626]   - Field: ‘calls’
[13:36:35.626]   - Field: ‘globals’
[13:36:35.626]   - Field: ‘stdout’
[13:36:35.626]   - Field: ‘earlySignal’
[13:36:35.627]   - Field: ‘lazy’
[13:36:35.627]   - Field: ‘state’
[13:36:35.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.627] - Launch lazy future ...
[13:36:35.627] Packages needed by the future expression (n = 0): <none>
[13:36:35.627] Packages needed by future strategies (n = 0): <none>
[13:36:35.628] {
[13:36:35.628]     {
[13:36:35.628]         {
[13:36:35.628]             ...future.startTime <- base::Sys.time()
[13:36:35.628]             {
[13:36:35.628]                 {
[13:36:35.628]                   {
[13:36:35.628]                     {
[13:36:35.628]                       base::local({
[13:36:35.628]                         has_future <- base::requireNamespace("future", 
[13:36:35.628]                           quietly = TRUE)
[13:36:35.628]                         if (has_future) {
[13:36:35.628]                           ns <- base::getNamespace("future")
[13:36:35.628]                           version <- ns[[".package"]][["version"]]
[13:36:35.628]                           if (is.null(version)) 
[13:36:35.628]                             version <- utils::packageVersion("future")
[13:36:35.628]                         }
[13:36:35.628]                         else {
[13:36:35.628]                           version <- NULL
[13:36:35.628]                         }
[13:36:35.628]                         if (!has_future || version < "1.8.0") {
[13:36:35.628]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.628]                             "", base::R.version$version.string), 
[13:36:35.628]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.628]                               "release", "version")], collapse = " "), 
[13:36:35.628]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.628]                             info)
[13:36:35.628]                           info <- base::paste(info, collapse = "; ")
[13:36:35.628]                           if (!has_future) {
[13:36:35.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.628]                               info)
[13:36:35.628]                           }
[13:36:35.628]                           else {
[13:36:35.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.628]                               info, version)
[13:36:35.628]                           }
[13:36:35.628]                           base::stop(msg)
[13:36:35.628]                         }
[13:36:35.628]                       })
[13:36:35.628]                     }
[13:36:35.628]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.628]                     base::options(mc.cores = 1L)
[13:36:35.628]                   }
[13:36:35.628]                   ...future.strategy.old <- future::plan("list")
[13:36:35.628]                   options(future.plan = NULL)
[13:36:35.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.628]                 }
[13:36:35.628]                 ...future.workdir <- getwd()
[13:36:35.628]             }
[13:36:35.628]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.628]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.628]         }
[13:36:35.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.628]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.628]             base::names(...future.oldOptions))
[13:36:35.628]     }
[13:36:35.628]     if (FALSE) {
[13:36:35.628]     }
[13:36:35.628]     else {
[13:36:35.628]         if (TRUE) {
[13:36:35.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.628]                 open = "w")
[13:36:35.628]         }
[13:36:35.628]         else {
[13:36:35.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.628]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.628]         }
[13:36:35.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.628]             base::sink(type = "output", split = FALSE)
[13:36:35.628]             base::close(...future.stdout)
[13:36:35.628]         }, add = TRUE)
[13:36:35.628]     }
[13:36:35.628]     ...future.frame <- base::sys.nframe()
[13:36:35.628]     ...future.conditions <- base::list()
[13:36:35.628]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.628]     if (FALSE) {
[13:36:35.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.628]     }
[13:36:35.628]     ...future.result <- base::tryCatch({
[13:36:35.628]         base::withCallingHandlers({
[13:36:35.628]             ...future.value <- base::withVisible(base::local({
[13:36:35.628]                 ...future.makeSendCondition <- base::local({
[13:36:35.628]                   sendCondition <- NULL
[13:36:35.628]                   function(frame = 1L) {
[13:36:35.628]                     if (is.function(sendCondition)) 
[13:36:35.628]                       return(sendCondition)
[13:36:35.628]                     ns <- getNamespace("parallel")
[13:36:35.628]                     if (exists("sendData", mode = "function", 
[13:36:35.628]                       envir = ns)) {
[13:36:35.628]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.628]                         envir = ns)
[13:36:35.628]                       envir <- sys.frame(frame)
[13:36:35.628]                       master <- NULL
[13:36:35.628]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.628]                         !identical(envir, emptyenv())) {
[13:36:35.628]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.628]                           inherits = FALSE)) {
[13:36:35.628]                           master <- get("master", mode = "list", 
[13:36:35.628]                             envir = envir, inherits = FALSE)
[13:36:35.628]                           if (inherits(master, c("SOCKnode", 
[13:36:35.628]                             "SOCK0node"))) {
[13:36:35.628]                             sendCondition <<- function(cond) {
[13:36:35.628]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.628]                                 success = TRUE)
[13:36:35.628]                               parallel_sendData(master, data)
[13:36:35.628]                             }
[13:36:35.628]                             return(sendCondition)
[13:36:35.628]                           }
[13:36:35.628]                         }
[13:36:35.628]                         frame <- frame + 1L
[13:36:35.628]                         envir <- sys.frame(frame)
[13:36:35.628]                       }
[13:36:35.628]                     }
[13:36:35.628]                     sendCondition <<- function(cond) NULL
[13:36:35.628]                   }
[13:36:35.628]                 })
[13:36:35.628]                 withCallingHandlers({
[13:36:35.628]                   2
[13:36:35.628]                 }, immediateCondition = function(cond) {
[13:36:35.628]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.628]                   sendCondition(cond)
[13:36:35.628]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.628]                   {
[13:36:35.628]                     inherits <- base::inherits
[13:36:35.628]                     invokeRestart <- base::invokeRestart
[13:36:35.628]                     is.null <- base::is.null
[13:36:35.628]                     muffled <- FALSE
[13:36:35.628]                     if (inherits(cond, "message")) {
[13:36:35.628]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.628]                       if (muffled) 
[13:36:35.628]                         invokeRestart("muffleMessage")
[13:36:35.628]                     }
[13:36:35.628]                     else if (inherits(cond, "warning")) {
[13:36:35.628]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.628]                       if (muffled) 
[13:36:35.628]                         invokeRestart("muffleWarning")
[13:36:35.628]                     }
[13:36:35.628]                     else if (inherits(cond, "condition")) {
[13:36:35.628]                       if (!is.null(pattern)) {
[13:36:35.628]                         computeRestarts <- base::computeRestarts
[13:36:35.628]                         grepl <- base::grepl
[13:36:35.628]                         restarts <- computeRestarts(cond)
[13:36:35.628]                         for (restart in restarts) {
[13:36:35.628]                           name <- restart$name
[13:36:35.628]                           if (is.null(name)) 
[13:36:35.628]                             next
[13:36:35.628]                           if (!grepl(pattern, name)) 
[13:36:35.628]                             next
[13:36:35.628]                           invokeRestart(restart)
[13:36:35.628]                           muffled <- TRUE
[13:36:35.628]                           break
[13:36:35.628]                         }
[13:36:35.628]                       }
[13:36:35.628]                     }
[13:36:35.628]                     invisible(muffled)
[13:36:35.628]                   }
[13:36:35.628]                   muffleCondition(cond)
[13:36:35.628]                 })
[13:36:35.628]             }))
[13:36:35.628]             future::FutureResult(value = ...future.value$value, 
[13:36:35.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.628]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.628]                     ...future.globalenv.names))
[13:36:35.628]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.628]         }, condition = base::local({
[13:36:35.628]             c <- base::c
[13:36:35.628]             inherits <- base::inherits
[13:36:35.628]             invokeRestart <- base::invokeRestart
[13:36:35.628]             length <- base::length
[13:36:35.628]             list <- base::list
[13:36:35.628]             seq.int <- base::seq.int
[13:36:35.628]             signalCondition <- base::signalCondition
[13:36:35.628]             sys.calls <- base::sys.calls
[13:36:35.628]             `[[` <- base::`[[`
[13:36:35.628]             `+` <- base::`+`
[13:36:35.628]             `<<-` <- base::`<<-`
[13:36:35.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.628]                   3L)]
[13:36:35.628]             }
[13:36:35.628]             function(cond) {
[13:36:35.628]                 is_error <- inherits(cond, "error")
[13:36:35.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.628]                   NULL)
[13:36:35.628]                 if (is_error) {
[13:36:35.628]                   sessionInformation <- function() {
[13:36:35.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.628]                       search = base::search(), system = base::Sys.info())
[13:36:35.628]                   }
[13:36:35.628]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.628]                     cond$call), session = sessionInformation(), 
[13:36:35.628]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.628]                   signalCondition(cond)
[13:36:35.628]                 }
[13:36:35.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.628]                 "immediateCondition"))) {
[13:36:35.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.628]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.628]                   if (TRUE && !signal) {
[13:36:35.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.628]                     {
[13:36:35.628]                       inherits <- base::inherits
[13:36:35.628]                       invokeRestart <- base::invokeRestart
[13:36:35.628]                       is.null <- base::is.null
[13:36:35.628]                       muffled <- FALSE
[13:36:35.628]                       if (inherits(cond, "message")) {
[13:36:35.628]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.628]                         if (muffled) 
[13:36:35.628]                           invokeRestart("muffleMessage")
[13:36:35.628]                       }
[13:36:35.628]                       else if (inherits(cond, "warning")) {
[13:36:35.628]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.628]                         if (muffled) 
[13:36:35.628]                           invokeRestart("muffleWarning")
[13:36:35.628]                       }
[13:36:35.628]                       else if (inherits(cond, "condition")) {
[13:36:35.628]                         if (!is.null(pattern)) {
[13:36:35.628]                           computeRestarts <- base::computeRestarts
[13:36:35.628]                           grepl <- base::grepl
[13:36:35.628]                           restarts <- computeRestarts(cond)
[13:36:35.628]                           for (restart in restarts) {
[13:36:35.628]                             name <- restart$name
[13:36:35.628]                             if (is.null(name)) 
[13:36:35.628]                               next
[13:36:35.628]                             if (!grepl(pattern, name)) 
[13:36:35.628]                               next
[13:36:35.628]                             invokeRestart(restart)
[13:36:35.628]                             muffled <- TRUE
[13:36:35.628]                             break
[13:36:35.628]                           }
[13:36:35.628]                         }
[13:36:35.628]                       }
[13:36:35.628]                       invisible(muffled)
[13:36:35.628]                     }
[13:36:35.628]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.628]                   }
[13:36:35.628]                 }
[13:36:35.628]                 else {
[13:36:35.628]                   if (TRUE) {
[13:36:35.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.628]                     {
[13:36:35.628]                       inherits <- base::inherits
[13:36:35.628]                       invokeRestart <- base::invokeRestart
[13:36:35.628]                       is.null <- base::is.null
[13:36:35.628]                       muffled <- FALSE
[13:36:35.628]                       if (inherits(cond, "message")) {
[13:36:35.628]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.628]                         if (muffled) 
[13:36:35.628]                           invokeRestart("muffleMessage")
[13:36:35.628]                       }
[13:36:35.628]                       else if (inherits(cond, "warning")) {
[13:36:35.628]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.628]                         if (muffled) 
[13:36:35.628]                           invokeRestart("muffleWarning")
[13:36:35.628]                       }
[13:36:35.628]                       else if (inherits(cond, "condition")) {
[13:36:35.628]                         if (!is.null(pattern)) {
[13:36:35.628]                           computeRestarts <- base::computeRestarts
[13:36:35.628]                           grepl <- base::grepl
[13:36:35.628]                           restarts <- computeRestarts(cond)
[13:36:35.628]                           for (restart in restarts) {
[13:36:35.628]                             name <- restart$name
[13:36:35.628]                             if (is.null(name)) 
[13:36:35.628]                               next
[13:36:35.628]                             if (!grepl(pattern, name)) 
[13:36:35.628]                               next
[13:36:35.628]                             invokeRestart(restart)
[13:36:35.628]                             muffled <- TRUE
[13:36:35.628]                             break
[13:36:35.628]                           }
[13:36:35.628]                         }
[13:36:35.628]                       }
[13:36:35.628]                       invisible(muffled)
[13:36:35.628]                     }
[13:36:35.628]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.628]                   }
[13:36:35.628]                 }
[13:36:35.628]             }
[13:36:35.628]         }))
[13:36:35.628]     }, error = function(ex) {
[13:36:35.628]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.628]                 ...future.rng), started = ...future.startTime, 
[13:36:35.628]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.628]             version = "1.8"), class = "FutureResult")
[13:36:35.628]     }, finally = {
[13:36:35.628]         if (!identical(...future.workdir, getwd())) 
[13:36:35.628]             setwd(...future.workdir)
[13:36:35.628]         {
[13:36:35.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.628]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.628]             }
[13:36:35.628]             base::options(...future.oldOptions)
[13:36:35.628]             if (.Platform$OS.type == "windows") {
[13:36:35.628]                 old_names <- names(...future.oldEnvVars)
[13:36:35.628]                 envs <- base::Sys.getenv()
[13:36:35.628]                 names <- names(envs)
[13:36:35.628]                 common <- intersect(names, old_names)
[13:36:35.628]                 added <- setdiff(names, old_names)
[13:36:35.628]                 removed <- setdiff(old_names, names)
[13:36:35.628]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.628]                   envs[common]]
[13:36:35.628]                 NAMES <- toupper(changed)
[13:36:35.628]                 args <- list()
[13:36:35.628]                 for (kk in seq_along(NAMES)) {
[13:36:35.628]                   name <- changed[[kk]]
[13:36:35.628]                   NAME <- NAMES[[kk]]
[13:36:35.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.628]                     next
[13:36:35.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.628]                 }
[13:36:35.628]                 NAMES <- toupper(added)
[13:36:35.628]                 for (kk in seq_along(NAMES)) {
[13:36:35.628]                   name <- added[[kk]]
[13:36:35.628]                   NAME <- NAMES[[kk]]
[13:36:35.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.628]                     next
[13:36:35.628]                   args[[name]] <- ""
[13:36:35.628]                 }
[13:36:35.628]                 NAMES <- toupper(removed)
[13:36:35.628]                 for (kk in seq_along(NAMES)) {
[13:36:35.628]                   name <- removed[[kk]]
[13:36:35.628]                   NAME <- NAMES[[kk]]
[13:36:35.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.628]                     next
[13:36:35.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.628]                 }
[13:36:35.628]                 if (length(args) > 0) 
[13:36:35.628]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.628]             }
[13:36:35.628]             else {
[13:36:35.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.628]             }
[13:36:35.628]             {
[13:36:35.628]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.628]                   0L) {
[13:36:35.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.628]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.628]                   base::options(opts)
[13:36:35.628]                 }
[13:36:35.628]                 {
[13:36:35.628]                   {
[13:36:35.628]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.628]                     NULL
[13:36:35.628]                   }
[13:36:35.628]                   options(future.plan = NULL)
[13:36:35.628]                   if (is.na(NA_character_)) 
[13:36:35.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.628]                     .init = FALSE)
[13:36:35.628]                 }
[13:36:35.628]             }
[13:36:35.628]         }
[13:36:35.628]     })
[13:36:35.628]     if (TRUE) {
[13:36:35.628]         base::sink(type = "output", split = FALSE)
[13:36:35.628]         if (TRUE) {
[13:36:35.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.628]         }
[13:36:35.628]         else {
[13:36:35.628]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.628]         }
[13:36:35.628]         base::close(...future.stdout)
[13:36:35.628]         ...future.stdout <- NULL
[13:36:35.628]     }
[13:36:35.628]     ...future.result$conditions <- ...future.conditions
[13:36:35.628]     ...future.result$finished <- base::Sys.time()
[13:36:35.628]     ...future.result
[13:36:35.628] }
[13:36:35.631] MultisessionFuture started
[13:36:35.631] - Launch lazy future ... done
[13:36:35.631] run() for ‘MultisessionFuture’ ... done
[13:36:35.631] getGlobalsAndPackages() ...
[13:36:35.631] Searching for globals...
[13:36:35.631] 
[13:36:35.631] Searching for globals ... DONE
[13:36:35.632] - globals: [0] <none>
[13:36:35.632] getGlobalsAndPackages() ... DONE
[13:36:35.632] run() for ‘Future’ ...
[13:36:35.632] - state: ‘created’
[13:36:35.632] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.646] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.646]   - Field: ‘node’
[13:36:35.646]   - Field: ‘label’
[13:36:35.646]   - Field: ‘local’
[13:36:35.646]   - Field: ‘owner’
[13:36:35.646]   - Field: ‘envir’
[13:36:35.647]   - Field: ‘workers’
[13:36:35.647]   - Field: ‘packages’
[13:36:35.647]   - Field: ‘gc’
[13:36:35.647]   - Field: ‘conditions’
[13:36:35.647]   - Field: ‘persistent’
[13:36:35.647]   - Field: ‘expr’
[13:36:35.647]   - Field: ‘uuid’
[13:36:35.647]   - Field: ‘seed’
[13:36:35.647]   - Field: ‘version’
[13:36:35.647]   - Field: ‘result’
[13:36:35.647]   - Field: ‘asynchronous’
[13:36:35.648]   - Field: ‘calls’
[13:36:35.648]   - Field: ‘globals’
[13:36:35.648]   - Field: ‘stdout’
[13:36:35.648]   - Field: ‘earlySignal’
[13:36:35.648]   - Field: ‘lazy’
[13:36:35.648]   - Field: ‘state’
[13:36:35.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.648] - Launch lazy future ...
[13:36:35.648] Packages needed by the future expression (n = 0): <none>
[13:36:35.649] Packages needed by future strategies (n = 0): <none>
[13:36:35.649] {
[13:36:35.649]     {
[13:36:35.649]         {
[13:36:35.649]             ...future.startTime <- base::Sys.time()
[13:36:35.649]             {
[13:36:35.649]                 {
[13:36:35.649]                   {
[13:36:35.649]                     {
[13:36:35.649]                       base::local({
[13:36:35.649]                         has_future <- base::requireNamespace("future", 
[13:36:35.649]                           quietly = TRUE)
[13:36:35.649]                         if (has_future) {
[13:36:35.649]                           ns <- base::getNamespace("future")
[13:36:35.649]                           version <- ns[[".package"]][["version"]]
[13:36:35.649]                           if (is.null(version)) 
[13:36:35.649]                             version <- utils::packageVersion("future")
[13:36:35.649]                         }
[13:36:35.649]                         else {
[13:36:35.649]                           version <- NULL
[13:36:35.649]                         }
[13:36:35.649]                         if (!has_future || version < "1.8.0") {
[13:36:35.649]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.649]                             "", base::R.version$version.string), 
[13:36:35.649]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.649]                               "release", "version")], collapse = " "), 
[13:36:35.649]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.649]                             info)
[13:36:35.649]                           info <- base::paste(info, collapse = "; ")
[13:36:35.649]                           if (!has_future) {
[13:36:35.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.649]                               info)
[13:36:35.649]                           }
[13:36:35.649]                           else {
[13:36:35.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.649]                               info, version)
[13:36:35.649]                           }
[13:36:35.649]                           base::stop(msg)
[13:36:35.649]                         }
[13:36:35.649]                       })
[13:36:35.649]                     }
[13:36:35.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.649]                     base::options(mc.cores = 1L)
[13:36:35.649]                   }
[13:36:35.649]                   ...future.strategy.old <- future::plan("list")
[13:36:35.649]                   options(future.plan = NULL)
[13:36:35.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.649]                 }
[13:36:35.649]                 ...future.workdir <- getwd()
[13:36:35.649]             }
[13:36:35.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.649]         }
[13:36:35.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.649]             base::names(...future.oldOptions))
[13:36:35.649]     }
[13:36:35.649]     if (FALSE) {
[13:36:35.649]     }
[13:36:35.649]     else {
[13:36:35.649]         if (TRUE) {
[13:36:35.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.649]                 open = "w")
[13:36:35.649]         }
[13:36:35.649]         else {
[13:36:35.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.649]         }
[13:36:35.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.649]             base::sink(type = "output", split = FALSE)
[13:36:35.649]             base::close(...future.stdout)
[13:36:35.649]         }, add = TRUE)
[13:36:35.649]     }
[13:36:35.649]     ...future.frame <- base::sys.nframe()
[13:36:35.649]     ...future.conditions <- base::list()
[13:36:35.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.649]     if (FALSE) {
[13:36:35.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.649]     }
[13:36:35.649]     ...future.result <- base::tryCatch({
[13:36:35.649]         base::withCallingHandlers({
[13:36:35.649]             ...future.value <- base::withVisible(base::local({
[13:36:35.649]                 ...future.makeSendCondition <- base::local({
[13:36:35.649]                   sendCondition <- NULL
[13:36:35.649]                   function(frame = 1L) {
[13:36:35.649]                     if (is.function(sendCondition)) 
[13:36:35.649]                       return(sendCondition)
[13:36:35.649]                     ns <- getNamespace("parallel")
[13:36:35.649]                     if (exists("sendData", mode = "function", 
[13:36:35.649]                       envir = ns)) {
[13:36:35.649]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.649]                         envir = ns)
[13:36:35.649]                       envir <- sys.frame(frame)
[13:36:35.649]                       master <- NULL
[13:36:35.649]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.649]                         !identical(envir, emptyenv())) {
[13:36:35.649]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.649]                           inherits = FALSE)) {
[13:36:35.649]                           master <- get("master", mode = "list", 
[13:36:35.649]                             envir = envir, inherits = FALSE)
[13:36:35.649]                           if (inherits(master, c("SOCKnode", 
[13:36:35.649]                             "SOCK0node"))) {
[13:36:35.649]                             sendCondition <<- function(cond) {
[13:36:35.649]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.649]                                 success = TRUE)
[13:36:35.649]                               parallel_sendData(master, data)
[13:36:35.649]                             }
[13:36:35.649]                             return(sendCondition)
[13:36:35.649]                           }
[13:36:35.649]                         }
[13:36:35.649]                         frame <- frame + 1L
[13:36:35.649]                         envir <- sys.frame(frame)
[13:36:35.649]                       }
[13:36:35.649]                     }
[13:36:35.649]                     sendCondition <<- function(cond) NULL
[13:36:35.649]                   }
[13:36:35.649]                 })
[13:36:35.649]                 withCallingHandlers({
[13:36:35.649]                   NULL
[13:36:35.649]                 }, immediateCondition = function(cond) {
[13:36:35.649]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.649]                   sendCondition(cond)
[13:36:35.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.649]                   {
[13:36:35.649]                     inherits <- base::inherits
[13:36:35.649]                     invokeRestart <- base::invokeRestart
[13:36:35.649]                     is.null <- base::is.null
[13:36:35.649]                     muffled <- FALSE
[13:36:35.649]                     if (inherits(cond, "message")) {
[13:36:35.649]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.649]                       if (muffled) 
[13:36:35.649]                         invokeRestart("muffleMessage")
[13:36:35.649]                     }
[13:36:35.649]                     else if (inherits(cond, "warning")) {
[13:36:35.649]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.649]                       if (muffled) 
[13:36:35.649]                         invokeRestart("muffleWarning")
[13:36:35.649]                     }
[13:36:35.649]                     else if (inherits(cond, "condition")) {
[13:36:35.649]                       if (!is.null(pattern)) {
[13:36:35.649]                         computeRestarts <- base::computeRestarts
[13:36:35.649]                         grepl <- base::grepl
[13:36:35.649]                         restarts <- computeRestarts(cond)
[13:36:35.649]                         for (restart in restarts) {
[13:36:35.649]                           name <- restart$name
[13:36:35.649]                           if (is.null(name)) 
[13:36:35.649]                             next
[13:36:35.649]                           if (!grepl(pattern, name)) 
[13:36:35.649]                             next
[13:36:35.649]                           invokeRestart(restart)
[13:36:35.649]                           muffled <- TRUE
[13:36:35.649]                           break
[13:36:35.649]                         }
[13:36:35.649]                       }
[13:36:35.649]                     }
[13:36:35.649]                     invisible(muffled)
[13:36:35.649]                   }
[13:36:35.649]                   muffleCondition(cond)
[13:36:35.649]                 })
[13:36:35.649]             }))
[13:36:35.649]             future::FutureResult(value = ...future.value$value, 
[13:36:35.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.649]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.649]                     ...future.globalenv.names))
[13:36:35.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.649]         }, condition = base::local({
[13:36:35.649]             c <- base::c
[13:36:35.649]             inherits <- base::inherits
[13:36:35.649]             invokeRestart <- base::invokeRestart
[13:36:35.649]             length <- base::length
[13:36:35.649]             list <- base::list
[13:36:35.649]             seq.int <- base::seq.int
[13:36:35.649]             signalCondition <- base::signalCondition
[13:36:35.649]             sys.calls <- base::sys.calls
[13:36:35.649]             `[[` <- base::`[[`
[13:36:35.649]             `+` <- base::`+`
[13:36:35.649]             `<<-` <- base::`<<-`
[13:36:35.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.649]                   3L)]
[13:36:35.649]             }
[13:36:35.649]             function(cond) {
[13:36:35.649]                 is_error <- inherits(cond, "error")
[13:36:35.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.649]                   NULL)
[13:36:35.649]                 if (is_error) {
[13:36:35.649]                   sessionInformation <- function() {
[13:36:35.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.649]                       search = base::search(), system = base::Sys.info())
[13:36:35.649]                   }
[13:36:35.649]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.649]                     cond$call), session = sessionInformation(), 
[13:36:35.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.649]                   signalCondition(cond)
[13:36:35.649]                 }
[13:36:35.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.649]                 "immediateCondition"))) {
[13:36:35.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.649]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.649]                   if (TRUE && !signal) {
[13:36:35.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.649]                     {
[13:36:35.649]                       inherits <- base::inherits
[13:36:35.649]                       invokeRestart <- base::invokeRestart
[13:36:35.649]                       is.null <- base::is.null
[13:36:35.649]                       muffled <- FALSE
[13:36:35.649]                       if (inherits(cond, "message")) {
[13:36:35.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.649]                         if (muffled) 
[13:36:35.649]                           invokeRestart("muffleMessage")
[13:36:35.649]                       }
[13:36:35.649]                       else if (inherits(cond, "warning")) {
[13:36:35.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.649]                         if (muffled) 
[13:36:35.649]                           invokeRestart("muffleWarning")
[13:36:35.649]                       }
[13:36:35.649]                       else if (inherits(cond, "condition")) {
[13:36:35.649]                         if (!is.null(pattern)) {
[13:36:35.649]                           computeRestarts <- base::computeRestarts
[13:36:35.649]                           grepl <- base::grepl
[13:36:35.649]                           restarts <- computeRestarts(cond)
[13:36:35.649]                           for (restart in restarts) {
[13:36:35.649]                             name <- restart$name
[13:36:35.649]                             if (is.null(name)) 
[13:36:35.649]                               next
[13:36:35.649]                             if (!grepl(pattern, name)) 
[13:36:35.649]                               next
[13:36:35.649]                             invokeRestart(restart)
[13:36:35.649]                             muffled <- TRUE
[13:36:35.649]                             break
[13:36:35.649]                           }
[13:36:35.649]                         }
[13:36:35.649]                       }
[13:36:35.649]                       invisible(muffled)
[13:36:35.649]                     }
[13:36:35.649]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.649]                   }
[13:36:35.649]                 }
[13:36:35.649]                 else {
[13:36:35.649]                   if (TRUE) {
[13:36:35.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.649]                     {
[13:36:35.649]                       inherits <- base::inherits
[13:36:35.649]                       invokeRestart <- base::invokeRestart
[13:36:35.649]                       is.null <- base::is.null
[13:36:35.649]                       muffled <- FALSE
[13:36:35.649]                       if (inherits(cond, "message")) {
[13:36:35.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.649]                         if (muffled) 
[13:36:35.649]                           invokeRestart("muffleMessage")
[13:36:35.649]                       }
[13:36:35.649]                       else if (inherits(cond, "warning")) {
[13:36:35.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.649]                         if (muffled) 
[13:36:35.649]                           invokeRestart("muffleWarning")
[13:36:35.649]                       }
[13:36:35.649]                       else if (inherits(cond, "condition")) {
[13:36:35.649]                         if (!is.null(pattern)) {
[13:36:35.649]                           computeRestarts <- base::computeRestarts
[13:36:35.649]                           grepl <- base::grepl
[13:36:35.649]                           restarts <- computeRestarts(cond)
[13:36:35.649]                           for (restart in restarts) {
[13:36:35.649]                             name <- restart$name
[13:36:35.649]                             if (is.null(name)) 
[13:36:35.649]                               next
[13:36:35.649]                             if (!grepl(pattern, name)) 
[13:36:35.649]                               next
[13:36:35.649]                             invokeRestart(restart)
[13:36:35.649]                             muffled <- TRUE
[13:36:35.649]                             break
[13:36:35.649]                           }
[13:36:35.649]                         }
[13:36:35.649]                       }
[13:36:35.649]                       invisible(muffled)
[13:36:35.649]                     }
[13:36:35.649]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.649]                   }
[13:36:35.649]                 }
[13:36:35.649]             }
[13:36:35.649]         }))
[13:36:35.649]     }, error = function(ex) {
[13:36:35.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.649]                 ...future.rng), started = ...future.startTime, 
[13:36:35.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.649]             version = "1.8"), class = "FutureResult")
[13:36:35.649]     }, finally = {
[13:36:35.649]         if (!identical(...future.workdir, getwd())) 
[13:36:35.649]             setwd(...future.workdir)
[13:36:35.649]         {
[13:36:35.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.649]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.649]             }
[13:36:35.649]             base::options(...future.oldOptions)
[13:36:35.649]             if (.Platform$OS.type == "windows") {
[13:36:35.649]                 old_names <- names(...future.oldEnvVars)
[13:36:35.649]                 envs <- base::Sys.getenv()
[13:36:35.649]                 names <- names(envs)
[13:36:35.649]                 common <- intersect(names, old_names)
[13:36:35.649]                 added <- setdiff(names, old_names)
[13:36:35.649]                 removed <- setdiff(old_names, names)
[13:36:35.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.649]                   envs[common]]
[13:36:35.649]                 NAMES <- toupper(changed)
[13:36:35.649]                 args <- list()
[13:36:35.649]                 for (kk in seq_along(NAMES)) {
[13:36:35.649]                   name <- changed[[kk]]
[13:36:35.649]                   NAME <- NAMES[[kk]]
[13:36:35.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.649]                     next
[13:36:35.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.649]                 }
[13:36:35.649]                 NAMES <- toupper(added)
[13:36:35.649]                 for (kk in seq_along(NAMES)) {
[13:36:35.649]                   name <- added[[kk]]
[13:36:35.649]                   NAME <- NAMES[[kk]]
[13:36:35.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.649]                     next
[13:36:35.649]                   args[[name]] <- ""
[13:36:35.649]                 }
[13:36:35.649]                 NAMES <- toupper(removed)
[13:36:35.649]                 for (kk in seq_along(NAMES)) {
[13:36:35.649]                   name <- removed[[kk]]
[13:36:35.649]                   NAME <- NAMES[[kk]]
[13:36:35.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.649]                     next
[13:36:35.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.649]                 }
[13:36:35.649]                 if (length(args) > 0) 
[13:36:35.649]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.649]             }
[13:36:35.649]             else {
[13:36:35.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.649]             }
[13:36:35.649]             {
[13:36:35.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.649]                   0L) {
[13:36:35.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.649]                   base::options(opts)
[13:36:35.649]                 }
[13:36:35.649]                 {
[13:36:35.649]                   {
[13:36:35.649]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.649]                     NULL
[13:36:35.649]                   }
[13:36:35.649]                   options(future.plan = NULL)
[13:36:35.649]                   if (is.na(NA_character_)) 
[13:36:35.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.649]                     .init = FALSE)
[13:36:35.649]                 }
[13:36:35.649]             }
[13:36:35.649]         }
[13:36:35.649]     })
[13:36:35.649]     if (TRUE) {
[13:36:35.649]         base::sink(type = "output", split = FALSE)
[13:36:35.649]         if (TRUE) {
[13:36:35.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.649]         }
[13:36:35.649]         else {
[13:36:35.649]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.649]         }
[13:36:35.649]         base::close(...future.stdout)
[13:36:35.649]         ...future.stdout <- NULL
[13:36:35.649]     }
[13:36:35.649]     ...future.result$conditions <- ...future.conditions
[13:36:35.649]     ...future.result$finished <- base::Sys.time()
[13:36:35.649]     ...future.result
[13:36:35.649] }
[13:36:35.652] MultisessionFuture started
[13:36:35.652] - Launch lazy future ... done
[13:36:35.652] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a736ded00> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a7303dba0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a736ded00> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a7303dba0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:36:35.657] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.657] - Validating connection of MultisessionFuture
[13:36:35.658] - received message: FutureResult
[13:36:35.658] - Received FutureResult
[13:36:35.658] - Erased future from FutureRegistry
[13:36:35.658] result() for ClusterFuture ...
[13:36:35.658] - result already collected: FutureResult
[13:36:35.658] result() for ClusterFuture ... done
[13:36:35.658] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:35.659] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.659] - Validating connection of MultisessionFuture
[13:36:35.659] - received message: FutureResult
[13:36:35.659] - Received FutureResult
[13:36:35.659] - Erased future from FutureRegistry
[13:36:35.659] result() for ClusterFuture ...
[13:36:35.659] - result already collected: FutureResult
[13:36:35.659] result() for ClusterFuture ... done
[13:36:35.660] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:35.661] resolve() on list ...
[13:36:35.661]  recursive: 0
[13:36:35.661]  length: 6
[13:36:35.661]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:35.661] signalConditionsASAP(numeric, pos=1) ...
[13:36:35.662] - nx: 6
[13:36:35.662] - relay: TRUE
[13:36:35.662] - stdout: TRUE
[13:36:35.662] - signal: TRUE
[13:36:35.662] - resignal: FALSE
[13:36:35.662] - force: TRUE
[13:36:35.662] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.662] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.662]  - until=2
[13:36:35.662]  - relaying element #2
[13:36:35.662] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.663] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.663] signalConditionsASAP(NULL, pos=1) ... done
[13:36:35.663]  length: 5 (resolved future 1)
[13:36:35.663] Future #2
[13:36:35.663] result() for ClusterFuture ...
[13:36:35.663] - result already collected: FutureResult
[13:36:35.663] result() for ClusterFuture ... done
[13:36:35.663] result() for ClusterFuture ...
[13:36:35.663] - result already collected: FutureResult
[13:36:35.663] result() for ClusterFuture ... done
[13:36:35.664] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:35.664] - nx: 6
[13:36:35.664] - relay: TRUE
[13:36:35.664] - stdout: TRUE
[13:36:35.664] - signal: TRUE
[13:36:35.664] - resignal: FALSE
[13:36:35.664] - force: TRUE
[13:36:35.664] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.664] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.664]  - until=2
[13:36:35.664]  - relaying element #2
[13:36:35.664] result() for ClusterFuture ...
[13:36:35.665] - result already collected: FutureResult
[13:36:35.665] result() for ClusterFuture ... done
[13:36:35.665] result() for ClusterFuture ...
[13:36:35.665] - result already collected: FutureResult
[13:36:35.665] result() for ClusterFuture ... done
[13:36:35.665] result() for ClusterFuture ...
[13:36:35.665] - result already collected: FutureResult
[13:36:35.665] result() for ClusterFuture ... done
[13:36:35.665] result() for ClusterFuture ...
[13:36:35.665] - result already collected: FutureResult
[13:36:35.665] result() for ClusterFuture ... done
[13:36:35.666] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.666] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.666] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:35.666]  length: 4 (resolved future 2)
[13:36:35.666] Future #3
[13:36:35.666] result() for ClusterFuture ...
[13:36:35.666] - result already collected: FutureResult
[13:36:35.666] result() for ClusterFuture ... done
[13:36:35.666] result() for ClusterFuture ...
[13:36:35.666] - result already collected: FutureResult
[13:36:35.666] result() for ClusterFuture ... done
[13:36:35.667] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:35.667] - nx: 6
[13:36:35.667] - relay: TRUE
[13:36:35.667] - stdout: TRUE
[13:36:35.667] - signal: TRUE
[13:36:35.667] - resignal: FALSE
[13:36:35.667] - force: TRUE
[13:36:35.667] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.667] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.667]  - until=3
[13:36:35.667]  - relaying element #3
[13:36:35.668] result() for ClusterFuture ...
[13:36:35.668] - result already collected: FutureResult
[13:36:35.668] result() for ClusterFuture ... done
[13:36:35.668] result() for ClusterFuture ...
[13:36:35.668] - result already collected: FutureResult
[13:36:35.668] result() for ClusterFuture ... done
[13:36:35.668] result() for ClusterFuture ...
[13:36:35.668] - result already collected: FutureResult
[13:36:35.668] result() for ClusterFuture ... done
[13:36:35.668] result() for ClusterFuture ...
[13:36:35.668] - result already collected: FutureResult
[13:36:35.668] result() for ClusterFuture ... done
[13:36:35.669] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.669] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.669] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:35.669]  length: 3 (resolved future 3)
[13:36:35.669] signalConditionsASAP(NULL, pos=4) ...
[13:36:35.669] - nx: 6
[13:36:35.669] - relay: TRUE
[13:36:35.669] - stdout: TRUE
[13:36:35.669] - signal: TRUE
[13:36:35.669] - resignal: FALSE
[13:36:35.669] - force: TRUE
[13:36:35.669] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.670] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.670]  - until=5
[13:36:35.670]  - relaying element #5
[13:36:35.670] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.670] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.670] signalConditionsASAP(NULL, pos=4) ... done
[13:36:35.670]  length: 2 (resolved future 4)
[13:36:35.670] signalConditionsASAP(NULL, pos=5) ...
[13:36:35.670] - nx: 6
[13:36:35.670] - relay: TRUE
[13:36:35.670] - stdout: TRUE
[13:36:35.670] - signal: TRUE
[13:36:35.671] - resignal: FALSE
[13:36:35.671] - force: TRUE
[13:36:35.671] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.671] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.671]  - until=6
[13:36:35.671]  - relaying element #6
[13:36:35.671] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.671] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.671] signalConditionsASAP(NULL, pos=5) ... done
[13:36:35.671]  length: 1 (resolved future 5)
[13:36:35.671] signalConditionsASAP(numeric, pos=6) ...
[13:36:35.672] - nx: 6
[13:36:35.672] - relay: TRUE
[13:36:35.672] - stdout: TRUE
[13:36:35.672] - signal: TRUE
[13:36:35.672] - resignal: FALSE
[13:36:35.672] - force: TRUE
[13:36:35.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.672] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.672]  - until=6
[13:36:35.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.672] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.672] signalConditionsASAP(numeric, pos=6) ... done
[13:36:35.672]  length: 0 (resolved future 6)
[13:36:35.673] Relaying remaining futures
[13:36:35.673] signalConditionsASAP(NULL, pos=0) ...
[13:36:35.673] - nx: 6
[13:36:35.673] - relay: TRUE
[13:36:35.673] - stdout: TRUE
[13:36:35.673] - signal: TRUE
[13:36:35.673] - resignal: FALSE
[13:36:35.673] - force: TRUE
[13:36:35.673] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.673] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:35.673] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.674] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.674] signalConditionsASAP(NULL, pos=0) ... done
[13:36:35.674] resolve() on list ... DONE
[13:36:35.674] result() for ClusterFuture ...
[13:36:35.674] - result already collected: FutureResult
[13:36:35.674] result() for ClusterFuture ... done
[13:36:35.674] result() for ClusterFuture ...
[13:36:35.674] - result already collected: FutureResult
[13:36:35.674] result() for ClusterFuture ... done
[13:36:35.674] result() for ClusterFuture ...
[13:36:35.674] - result already collected: FutureResult
[13:36:35.675] result() for ClusterFuture ... done
[13:36:35.675] result() for ClusterFuture ...
[13:36:35.675] - result already collected: FutureResult
[13:36:35.675] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:36:35.678] getGlobalsAndPackages() ...
[13:36:35.678] Searching for globals...
[13:36:35.678] 
[13:36:35.678] Searching for globals ... DONE
[13:36:35.678] - globals: [0] <none>
[13:36:35.679] getGlobalsAndPackages() ... DONE
[13:36:35.679] run() for ‘Future’ ...
[13:36:35.679] - state: ‘created’
[13:36:35.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.693]   - Field: ‘node’
[13:36:35.693]   - Field: ‘label’
[13:36:35.693]   - Field: ‘local’
[13:36:35.693]   - Field: ‘owner’
[13:36:35.693]   - Field: ‘envir’
[13:36:35.693]   - Field: ‘workers’
[13:36:35.693]   - Field: ‘packages’
[13:36:35.693]   - Field: ‘gc’
[13:36:35.694]   - Field: ‘conditions’
[13:36:35.694]   - Field: ‘persistent’
[13:36:35.694]   - Field: ‘expr’
[13:36:35.694]   - Field: ‘uuid’
[13:36:35.694]   - Field: ‘seed’
[13:36:35.694]   - Field: ‘version’
[13:36:35.694]   - Field: ‘result’
[13:36:35.694]   - Field: ‘asynchronous’
[13:36:35.694]   - Field: ‘calls’
[13:36:35.694]   - Field: ‘globals’
[13:36:35.695]   - Field: ‘stdout’
[13:36:35.695]   - Field: ‘earlySignal’
[13:36:35.695]   - Field: ‘lazy’
[13:36:35.695]   - Field: ‘state’
[13:36:35.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.695] - Launch lazy future ...
[13:36:35.695] Packages needed by the future expression (n = 0): <none>
[13:36:35.695] Packages needed by future strategies (n = 0): <none>
[13:36:35.696] {
[13:36:35.696]     {
[13:36:35.696]         {
[13:36:35.696]             ...future.startTime <- base::Sys.time()
[13:36:35.696]             {
[13:36:35.696]                 {
[13:36:35.696]                   {
[13:36:35.696]                     {
[13:36:35.696]                       base::local({
[13:36:35.696]                         has_future <- base::requireNamespace("future", 
[13:36:35.696]                           quietly = TRUE)
[13:36:35.696]                         if (has_future) {
[13:36:35.696]                           ns <- base::getNamespace("future")
[13:36:35.696]                           version <- ns[[".package"]][["version"]]
[13:36:35.696]                           if (is.null(version)) 
[13:36:35.696]                             version <- utils::packageVersion("future")
[13:36:35.696]                         }
[13:36:35.696]                         else {
[13:36:35.696]                           version <- NULL
[13:36:35.696]                         }
[13:36:35.696]                         if (!has_future || version < "1.8.0") {
[13:36:35.696]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.696]                             "", base::R.version$version.string), 
[13:36:35.696]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.696]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.696]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.696]                               "release", "version")], collapse = " "), 
[13:36:35.696]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.696]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.696]                             info)
[13:36:35.696]                           info <- base::paste(info, collapse = "; ")
[13:36:35.696]                           if (!has_future) {
[13:36:35.696]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.696]                               info)
[13:36:35.696]                           }
[13:36:35.696]                           else {
[13:36:35.696]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.696]                               info, version)
[13:36:35.696]                           }
[13:36:35.696]                           base::stop(msg)
[13:36:35.696]                         }
[13:36:35.696]                       })
[13:36:35.696]                     }
[13:36:35.696]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.696]                     base::options(mc.cores = 1L)
[13:36:35.696]                   }
[13:36:35.696]                   ...future.strategy.old <- future::plan("list")
[13:36:35.696]                   options(future.plan = NULL)
[13:36:35.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.696]                 }
[13:36:35.696]                 ...future.workdir <- getwd()
[13:36:35.696]             }
[13:36:35.696]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.696]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.696]         }
[13:36:35.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.696]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.696]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.696]             base::names(...future.oldOptions))
[13:36:35.696]     }
[13:36:35.696]     if (FALSE) {
[13:36:35.696]     }
[13:36:35.696]     else {
[13:36:35.696]         if (TRUE) {
[13:36:35.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.696]                 open = "w")
[13:36:35.696]         }
[13:36:35.696]         else {
[13:36:35.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.696]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.696]         }
[13:36:35.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.696]             base::sink(type = "output", split = FALSE)
[13:36:35.696]             base::close(...future.stdout)
[13:36:35.696]         }, add = TRUE)
[13:36:35.696]     }
[13:36:35.696]     ...future.frame <- base::sys.nframe()
[13:36:35.696]     ...future.conditions <- base::list()
[13:36:35.696]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.696]     if (FALSE) {
[13:36:35.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.696]     }
[13:36:35.696]     ...future.result <- base::tryCatch({
[13:36:35.696]         base::withCallingHandlers({
[13:36:35.696]             ...future.value <- base::withVisible(base::local({
[13:36:35.696]                 ...future.makeSendCondition <- base::local({
[13:36:35.696]                   sendCondition <- NULL
[13:36:35.696]                   function(frame = 1L) {
[13:36:35.696]                     if (is.function(sendCondition)) 
[13:36:35.696]                       return(sendCondition)
[13:36:35.696]                     ns <- getNamespace("parallel")
[13:36:35.696]                     if (exists("sendData", mode = "function", 
[13:36:35.696]                       envir = ns)) {
[13:36:35.696]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.696]                         envir = ns)
[13:36:35.696]                       envir <- sys.frame(frame)
[13:36:35.696]                       master <- NULL
[13:36:35.696]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.696]                         !identical(envir, emptyenv())) {
[13:36:35.696]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.696]                           inherits = FALSE)) {
[13:36:35.696]                           master <- get("master", mode = "list", 
[13:36:35.696]                             envir = envir, inherits = FALSE)
[13:36:35.696]                           if (inherits(master, c("SOCKnode", 
[13:36:35.696]                             "SOCK0node"))) {
[13:36:35.696]                             sendCondition <<- function(cond) {
[13:36:35.696]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.696]                                 success = TRUE)
[13:36:35.696]                               parallel_sendData(master, data)
[13:36:35.696]                             }
[13:36:35.696]                             return(sendCondition)
[13:36:35.696]                           }
[13:36:35.696]                         }
[13:36:35.696]                         frame <- frame + 1L
[13:36:35.696]                         envir <- sys.frame(frame)
[13:36:35.696]                       }
[13:36:35.696]                     }
[13:36:35.696]                     sendCondition <<- function(cond) NULL
[13:36:35.696]                   }
[13:36:35.696]                 })
[13:36:35.696]                 withCallingHandlers({
[13:36:35.696]                   2
[13:36:35.696]                 }, immediateCondition = function(cond) {
[13:36:35.696]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.696]                   sendCondition(cond)
[13:36:35.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.696]                   {
[13:36:35.696]                     inherits <- base::inherits
[13:36:35.696]                     invokeRestart <- base::invokeRestart
[13:36:35.696]                     is.null <- base::is.null
[13:36:35.696]                     muffled <- FALSE
[13:36:35.696]                     if (inherits(cond, "message")) {
[13:36:35.696]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.696]                       if (muffled) 
[13:36:35.696]                         invokeRestart("muffleMessage")
[13:36:35.696]                     }
[13:36:35.696]                     else if (inherits(cond, "warning")) {
[13:36:35.696]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.696]                       if (muffled) 
[13:36:35.696]                         invokeRestart("muffleWarning")
[13:36:35.696]                     }
[13:36:35.696]                     else if (inherits(cond, "condition")) {
[13:36:35.696]                       if (!is.null(pattern)) {
[13:36:35.696]                         computeRestarts <- base::computeRestarts
[13:36:35.696]                         grepl <- base::grepl
[13:36:35.696]                         restarts <- computeRestarts(cond)
[13:36:35.696]                         for (restart in restarts) {
[13:36:35.696]                           name <- restart$name
[13:36:35.696]                           if (is.null(name)) 
[13:36:35.696]                             next
[13:36:35.696]                           if (!grepl(pattern, name)) 
[13:36:35.696]                             next
[13:36:35.696]                           invokeRestart(restart)
[13:36:35.696]                           muffled <- TRUE
[13:36:35.696]                           break
[13:36:35.696]                         }
[13:36:35.696]                       }
[13:36:35.696]                     }
[13:36:35.696]                     invisible(muffled)
[13:36:35.696]                   }
[13:36:35.696]                   muffleCondition(cond)
[13:36:35.696]                 })
[13:36:35.696]             }))
[13:36:35.696]             future::FutureResult(value = ...future.value$value, 
[13:36:35.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.696]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.696]                     ...future.globalenv.names))
[13:36:35.696]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.696]         }, condition = base::local({
[13:36:35.696]             c <- base::c
[13:36:35.696]             inherits <- base::inherits
[13:36:35.696]             invokeRestart <- base::invokeRestart
[13:36:35.696]             length <- base::length
[13:36:35.696]             list <- base::list
[13:36:35.696]             seq.int <- base::seq.int
[13:36:35.696]             signalCondition <- base::signalCondition
[13:36:35.696]             sys.calls <- base::sys.calls
[13:36:35.696]             `[[` <- base::`[[`
[13:36:35.696]             `+` <- base::`+`
[13:36:35.696]             `<<-` <- base::`<<-`
[13:36:35.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.696]                   3L)]
[13:36:35.696]             }
[13:36:35.696]             function(cond) {
[13:36:35.696]                 is_error <- inherits(cond, "error")
[13:36:35.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.696]                   NULL)
[13:36:35.696]                 if (is_error) {
[13:36:35.696]                   sessionInformation <- function() {
[13:36:35.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.696]                       search = base::search(), system = base::Sys.info())
[13:36:35.696]                   }
[13:36:35.696]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.696]                     cond$call), session = sessionInformation(), 
[13:36:35.696]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.696]                   signalCondition(cond)
[13:36:35.696]                 }
[13:36:35.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.696]                 "immediateCondition"))) {
[13:36:35.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.696]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.696]                   if (TRUE && !signal) {
[13:36:35.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.696]                     {
[13:36:35.696]                       inherits <- base::inherits
[13:36:35.696]                       invokeRestart <- base::invokeRestart
[13:36:35.696]                       is.null <- base::is.null
[13:36:35.696]                       muffled <- FALSE
[13:36:35.696]                       if (inherits(cond, "message")) {
[13:36:35.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.696]                         if (muffled) 
[13:36:35.696]                           invokeRestart("muffleMessage")
[13:36:35.696]                       }
[13:36:35.696]                       else if (inherits(cond, "warning")) {
[13:36:35.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.696]                         if (muffled) 
[13:36:35.696]                           invokeRestart("muffleWarning")
[13:36:35.696]                       }
[13:36:35.696]                       else if (inherits(cond, "condition")) {
[13:36:35.696]                         if (!is.null(pattern)) {
[13:36:35.696]                           computeRestarts <- base::computeRestarts
[13:36:35.696]                           grepl <- base::grepl
[13:36:35.696]                           restarts <- computeRestarts(cond)
[13:36:35.696]                           for (restart in restarts) {
[13:36:35.696]                             name <- restart$name
[13:36:35.696]                             if (is.null(name)) 
[13:36:35.696]                               next
[13:36:35.696]                             if (!grepl(pattern, name)) 
[13:36:35.696]                               next
[13:36:35.696]                             invokeRestart(restart)
[13:36:35.696]                             muffled <- TRUE
[13:36:35.696]                             break
[13:36:35.696]                           }
[13:36:35.696]                         }
[13:36:35.696]                       }
[13:36:35.696]                       invisible(muffled)
[13:36:35.696]                     }
[13:36:35.696]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.696]                   }
[13:36:35.696]                 }
[13:36:35.696]                 else {
[13:36:35.696]                   if (TRUE) {
[13:36:35.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.696]                     {
[13:36:35.696]                       inherits <- base::inherits
[13:36:35.696]                       invokeRestart <- base::invokeRestart
[13:36:35.696]                       is.null <- base::is.null
[13:36:35.696]                       muffled <- FALSE
[13:36:35.696]                       if (inherits(cond, "message")) {
[13:36:35.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.696]                         if (muffled) 
[13:36:35.696]                           invokeRestart("muffleMessage")
[13:36:35.696]                       }
[13:36:35.696]                       else if (inherits(cond, "warning")) {
[13:36:35.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.696]                         if (muffled) 
[13:36:35.696]                           invokeRestart("muffleWarning")
[13:36:35.696]                       }
[13:36:35.696]                       else if (inherits(cond, "condition")) {
[13:36:35.696]                         if (!is.null(pattern)) {
[13:36:35.696]                           computeRestarts <- base::computeRestarts
[13:36:35.696]                           grepl <- base::grepl
[13:36:35.696]                           restarts <- computeRestarts(cond)
[13:36:35.696]                           for (restart in restarts) {
[13:36:35.696]                             name <- restart$name
[13:36:35.696]                             if (is.null(name)) 
[13:36:35.696]                               next
[13:36:35.696]                             if (!grepl(pattern, name)) 
[13:36:35.696]                               next
[13:36:35.696]                             invokeRestart(restart)
[13:36:35.696]                             muffled <- TRUE
[13:36:35.696]                             break
[13:36:35.696]                           }
[13:36:35.696]                         }
[13:36:35.696]                       }
[13:36:35.696]                       invisible(muffled)
[13:36:35.696]                     }
[13:36:35.696]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.696]                   }
[13:36:35.696]                 }
[13:36:35.696]             }
[13:36:35.696]         }))
[13:36:35.696]     }, error = function(ex) {
[13:36:35.696]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.696]                 ...future.rng), started = ...future.startTime, 
[13:36:35.696]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.696]             version = "1.8"), class = "FutureResult")
[13:36:35.696]     }, finally = {
[13:36:35.696]         if (!identical(...future.workdir, getwd())) 
[13:36:35.696]             setwd(...future.workdir)
[13:36:35.696]         {
[13:36:35.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.696]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.696]             }
[13:36:35.696]             base::options(...future.oldOptions)
[13:36:35.696]             if (.Platform$OS.type == "windows") {
[13:36:35.696]                 old_names <- names(...future.oldEnvVars)
[13:36:35.696]                 envs <- base::Sys.getenv()
[13:36:35.696]                 names <- names(envs)
[13:36:35.696]                 common <- intersect(names, old_names)
[13:36:35.696]                 added <- setdiff(names, old_names)
[13:36:35.696]                 removed <- setdiff(old_names, names)
[13:36:35.696]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.696]                   envs[common]]
[13:36:35.696]                 NAMES <- toupper(changed)
[13:36:35.696]                 args <- list()
[13:36:35.696]                 for (kk in seq_along(NAMES)) {
[13:36:35.696]                   name <- changed[[kk]]
[13:36:35.696]                   NAME <- NAMES[[kk]]
[13:36:35.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.696]                     next
[13:36:35.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.696]                 }
[13:36:35.696]                 NAMES <- toupper(added)
[13:36:35.696]                 for (kk in seq_along(NAMES)) {
[13:36:35.696]                   name <- added[[kk]]
[13:36:35.696]                   NAME <- NAMES[[kk]]
[13:36:35.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.696]                     next
[13:36:35.696]                   args[[name]] <- ""
[13:36:35.696]                 }
[13:36:35.696]                 NAMES <- toupper(removed)
[13:36:35.696]                 for (kk in seq_along(NAMES)) {
[13:36:35.696]                   name <- removed[[kk]]
[13:36:35.696]                   NAME <- NAMES[[kk]]
[13:36:35.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.696]                     next
[13:36:35.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.696]                 }
[13:36:35.696]                 if (length(args) > 0) 
[13:36:35.696]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.696]             }
[13:36:35.696]             else {
[13:36:35.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.696]             }
[13:36:35.696]             {
[13:36:35.696]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.696]                   0L) {
[13:36:35.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.696]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.696]                   base::options(opts)
[13:36:35.696]                 }
[13:36:35.696]                 {
[13:36:35.696]                   {
[13:36:35.696]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.696]                     NULL
[13:36:35.696]                   }
[13:36:35.696]                   options(future.plan = NULL)
[13:36:35.696]                   if (is.na(NA_character_)) 
[13:36:35.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.696]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.696]                     .init = FALSE)
[13:36:35.696]                 }
[13:36:35.696]             }
[13:36:35.696]         }
[13:36:35.696]     })
[13:36:35.696]     if (TRUE) {
[13:36:35.696]         base::sink(type = "output", split = FALSE)
[13:36:35.696]         if (TRUE) {
[13:36:35.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.696]         }
[13:36:35.696]         else {
[13:36:35.696]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.696]         }
[13:36:35.696]         base::close(...future.stdout)
[13:36:35.696]         ...future.stdout <- NULL
[13:36:35.696]     }
[13:36:35.696]     ...future.result$conditions <- ...future.conditions
[13:36:35.696]     ...future.result$finished <- base::Sys.time()
[13:36:35.696]     ...future.result
[13:36:35.696] }
[13:36:35.699] MultisessionFuture started
[13:36:35.699] - Launch lazy future ... done
[13:36:35.699] run() for ‘MultisessionFuture’ ... done
[13:36:35.699] getGlobalsAndPackages() ...
[13:36:35.699] Searching for globals...
[13:36:35.699] 
[13:36:35.699] Searching for globals ... DONE
[13:36:35.699] - globals: [0] <none>
[13:36:35.700] getGlobalsAndPackages() ... DONE
[13:36:35.700] run() for ‘Future’ ...
[13:36:35.700] - state: ‘created’
[13:36:35.700] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.713] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.714]   - Field: ‘node’
[13:36:35.714]   - Field: ‘label’
[13:36:35.714]   - Field: ‘local’
[13:36:35.714]   - Field: ‘owner’
[13:36:35.714]   - Field: ‘envir’
[13:36:35.714]   - Field: ‘workers’
[13:36:35.714]   - Field: ‘packages’
[13:36:35.714]   - Field: ‘gc’
[13:36:35.715]   - Field: ‘conditions’
[13:36:35.715]   - Field: ‘persistent’
[13:36:35.715]   - Field: ‘expr’
[13:36:35.715]   - Field: ‘uuid’
[13:36:35.715]   - Field: ‘seed’
[13:36:35.715]   - Field: ‘version’
[13:36:35.715]   - Field: ‘result’
[13:36:35.715]   - Field: ‘asynchronous’
[13:36:35.715]   - Field: ‘calls’
[13:36:35.715]   - Field: ‘globals’
[13:36:35.715]   - Field: ‘stdout’
[13:36:35.716]   - Field: ‘earlySignal’
[13:36:35.716]   - Field: ‘lazy’
[13:36:35.716]   - Field: ‘state’
[13:36:35.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.716] - Launch lazy future ...
[13:36:35.716] Packages needed by the future expression (n = 0): <none>
[13:36:35.716] Packages needed by future strategies (n = 0): <none>
[13:36:35.717] {
[13:36:35.717]     {
[13:36:35.717]         {
[13:36:35.717]             ...future.startTime <- base::Sys.time()
[13:36:35.717]             {
[13:36:35.717]                 {
[13:36:35.717]                   {
[13:36:35.717]                     {
[13:36:35.717]                       base::local({
[13:36:35.717]                         has_future <- base::requireNamespace("future", 
[13:36:35.717]                           quietly = TRUE)
[13:36:35.717]                         if (has_future) {
[13:36:35.717]                           ns <- base::getNamespace("future")
[13:36:35.717]                           version <- ns[[".package"]][["version"]]
[13:36:35.717]                           if (is.null(version)) 
[13:36:35.717]                             version <- utils::packageVersion("future")
[13:36:35.717]                         }
[13:36:35.717]                         else {
[13:36:35.717]                           version <- NULL
[13:36:35.717]                         }
[13:36:35.717]                         if (!has_future || version < "1.8.0") {
[13:36:35.717]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.717]                             "", base::R.version$version.string), 
[13:36:35.717]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.717]                               "release", "version")], collapse = " "), 
[13:36:35.717]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.717]                             info)
[13:36:35.717]                           info <- base::paste(info, collapse = "; ")
[13:36:35.717]                           if (!has_future) {
[13:36:35.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.717]                               info)
[13:36:35.717]                           }
[13:36:35.717]                           else {
[13:36:35.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.717]                               info, version)
[13:36:35.717]                           }
[13:36:35.717]                           base::stop(msg)
[13:36:35.717]                         }
[13:36:35.717]                       })
[13:36:35.717]                     }
[13:36:35.717]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.717]                     base::options(mc.cores = 1L)
[13:36:35.717]                   }
[13:36:35.717]                   ...future.strategy.old <- future::plan("list")
[13:36:35.717]                   options(future.plan = NULL)
[13:36:35.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.717]                 }
[13:36:35.717]                 ...future.workdir <- getwd()
[13:36:35.717]             }
[13:36:35.717]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.717]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.717]         }
[13:36:35.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.717]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.717]             base::names(...future.oldOptions))
[13:36:35.717]     }
[13:36:35.717]     if (FALSE) {
[13:36:35.717]     }
[13:36:35.717]     else {
[13:36:35.717]         if (TRUE) {
[13:36:35.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.717]                 open = "w")
[13:36:35.717]         }
[13:36:35.717]         else {
[13:36:35.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.717]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.717]         }
[13:36:35.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.717]             base::sink(type = "output", split = FALSE)
[13:36:35.717]             base::close(...future.stdout)
[13:36:35.717]         }, add = TRUE)
[13:36:35.717]     }
[13:36:35.717]     ...future.frame <- base::sys.nframe()
[13:36:35.717]     ...future.conditions <- base::list()
[13:36:35.717]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.717]     if (FALSE) {
[13:36:35.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.717]     }
[13:36:35.717]     ...future.result <- base::tryCatch({
[13:36:35.717]         base::withCallingHandlers({
[13:36:35.717]             ...future.value <- base::withVisible(base::local({
[13:36:35.717]                 ...future.makeSendCondition <- base::local({
[13:36:35.717]                   sendCondition <- NULL
[13:36:35.717]                   function(frame = 1L) {
[13:36:35.717]                     if (is.function(sendCondition)) 
[13:36:35.717]                       return(sendCondition)
[13:36:35.717]                     ns <- getNamespace("parallel")
[13:36:35.717]                     if (exists("sendData", mode = "function", 
[13:36:35.717]                       envir = ns)) {
[13:36:35.717]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.717]                         envir = ns)
[13:36:35.717]                       envir <- sys.frame(frame)
[13:36:35.717]                       master <- NULL
[13:36:35.717]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.717]                         !identical(envir, emptyenv())) {
[13:36:35.717]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.717]                           inherits = FALSE)) {
[13:36:35.717]                           master <- get("master", mode = "list", 
[13:36:35.717]                             envir = envir, inherits = FALSE)
[13:36:35.717]                           if (inherits(master, c("SOCKnode", 
[13:36:35.717]                             "SOCK0node"))) {
[13:36:35.717]                             sendCondition <<- function(cond) {
[13:36:35.717]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.717]                                 success = TRUE)
[13:36:35.717]                               parallel_sendData(master, data)
[13:36:35.717]                             }
[13:36:35.717]                             return(sendCondition)
[13:36:35.717]                           }
[13:36:35.717]                         }
[13:36:35.717]                         frame <- frame + 1L
[13:36:35.717]                         envir <- sys.frame(frame)
[13:36:35.717]                       }
[13:36:35.717]                     }
[13:36:35.717]                     sendCondition <<- function(cond) NULL
[13:36:35.717]                   }
[13:36:35.717]                 })
[13:36:35.717]                 withCallingHandlers({
[13:36:35.717]                   NULL
[13:36:35.717]                 }, immediateCondition = function(cond) {
[13:36:35.717]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.717]                   sendCondition(cond)
[13:36:35.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.717]                   {
[13:36:35.717]                     inherits <- base::inherits
[13:36:35.717]                     invokeRestart <- base::invokeRestart
[13:36:35.717]                     is.null <- base::is.null
[13:36:35.717]                     muffled <- FALSE
[13:36:35.717]                     if (inherits(cond, "message")) {
[13:36:35.717]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.717]                       if (muffled) 
[13:36:35.717]                         invokeRestart("muffleMessage")
[13:36:35.717]                     }
[13:36:35.717]                     else if (inherits(cond, "warning")) {
[13:36:35.717]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.717]                       if (muffled) 
[13:36:35.717]                         invokeRestart("muffleWarning")
[13:36:35.717]                     }
[13:36:35.717]                     else if (inherits(cond, "condition")) {
[13:36:35.717]                       if (!is.null(pattern)) {
[13:36:35.717]                         computeRestarts <- base::computeRestarts
[13:36:35.717]                         grepl <- base::grepl
[13:36:35.717]                         restarts <- computeRestarts(cond)
[13:36:35.717]                         for (restart in restarts) {
[13:36:35.717]                           name <- restart$name
[13:36:35.717]                           if (is.null(name)) 
[13:36:35.717]                             next
[13:36:35.717]                           if (!grepl(pattern, name)) 
[13:36:35.717]                             next
[13:36:35.717]                           invokeRestart(restart)
[13:36:35.717]                           muffled <- TRUE
[13:36:35.717]                           break
[13:36:35.717]                         }
[13:36:35.717]                       }
[13:36:35.717]                     }
[13:36:35.717]                     invisible(muffled)
[13:36:35.717]                   }
[13:36:35.717]                   muffleCondition(cond)
[13:36:35.717]                 })
[13:36:35.717]             }))
[13:36:35.717]             future::FutureResult(value = ...future.value$value, 
[13:36:35.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.717]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.717]                     ...future.globalenv.names))
[13:36:35.717]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.717]         }, condition = base::local({
[13:36:35.717]             c <- base::c
[13:36:35.717]             inherits <- base::inherits
[13:36:35.717]             invokeRestart <- base::invokeRestart
[13:36:35.717]             length <- base::length
[13:36:35.717]             list <- base::list
[13:36:35.717]             seq.int <- base::seq.int
[13:36:35.717]             signalCondition <- base::signalCondition
[13:36:35.717]             sys.calls <- base::sys.calls
[13:36:35.717]             `[[` <- base::`[[`
[13:36:35.717]             `+` <- base::`+`
[13:36:35.717]             `<<-` <- base::`<<-`
[13:36:35.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.717]                   3L)]
[13:36:35.717]             }
[13:36:35.717]             function(cond) {
[13:36:35.717]                 is_error <- inherits(cond, "error")
[13:36:35.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.717]                   NULL)
[13:36:35.717]                 if (is_error) {
[13:36:35.717]                   sessionInformation <- function() {
[13:36:35.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.717]                       search = base::search(), system = base::Sys.info())
[13:36:35.717]                   }
[13:36:35.717]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.717]                     cond$call), session = sessionInformation(), 
[13:36:35.717]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.717]                   signalCondition(cond)
[13:36:35.717]                 }
[13:36:35.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.717]                 "immediateCondition"))) {
[13:36:35.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.717]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.717]                   if (TRUE && !signal) {
[13:36:35.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.717]                     {
[13:36:35.717]                       inherits <- base::inherits
[13:36:35.717]                       invokeRestart <- base::invokeRestart
[13:36:35.717]                       is.null <- base::is.null
[13:36:35.717]                       muffled <- FALSE
[13:36:35.717]                       if (inherits(cond, "message")) {
[13:36:35.717]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.717]                         if (muffled) 
[13:36:35.717]                           invokeRestart("muffleMessage")
[13:36:35.717]                       }
[13:36:35.717]                       else if (inherits(cond, "warning")) {
[13:36:35.717]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.717]                         if (muffled) 
[13:36:35.717]                           invokeRestart("muffleWarning")
[13:36:35.717]                       }
[13:36:35.717]                       else if (inherits(cond, "condition")) {
[13:36:35.717]                         if (!is.null(pattern)) {
[13:36:35.717]                           computeRestarts <- base::computeRestarts
[13:36:35.717]                           grepl <- base::grepl
[13:36:35.717]                           restarts <- computeRestarts(cond)
[13:36:35.717]                           for (restart in restarts) {
[13:36:35.717]                             name <- restart$name
[13:36:35.717]                             if (is.null(name)) 
[13:36:35.717]                               next
[13:36:35.717]                             if (!grepl(pattern, name)) 
[13:36:35.717]                               next
[13:36:35.717]                             invokeRestart(restart)
[13:36:35.717]                             muffled <- TRUE
[13:36:35.717]                             break
[13:36:35.717]                           }
[13:36:35.717]                         }
[13:36:35.717]                       }
[13:36:35.717]                       invisible(muffled)
[13:36:35.717]                     }
[13:36:35.717]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.717]                   }
[13:36:35.717]                 }
[13:36:35.717]                 else {
[13:36:35.717]                   if (TRUE) {
[13:36:35.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.717]                     {
[13:36:35.717]                       inherits <- base::inherits
[13:36:35.717]                       invokeRestart <- base::invokeRestart
[13:36:35.717]                       is.null <- base::is.null
[13:36:35.717]                       muffled <- FALSE
[13:36:35.717]                       if (inherits(cond, "message")) {
[13:36:35.717]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.717]                         if (muffled) 
[13:36:35.717]                           invokeRestart("muffleMessage")
[13:36:35.717]                       }
[13:36:35.717]                       else if (inherits(cond, "warning")) {
[13:36:35.717]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.717]                         if (muffled) 
[13:36:35.717]                           invokeRestart("muffleWarning")
[13:36:35.717]                       }
[13:36:35.717]                       else if (inherits(cond, "condition")) {
[13:36:35.717]                         if (!is.null(pattern)) {
[13:36:35.717]                           computeRestarts <- base::computeRestarts
[13:36:35.717]                           grepl <- base::grepl
[13:36:35.717]                           restarts <- computeRestarts(cond)
[13:36:35.717]                           for (restart in restarts) {
[13:36:35.717]                             name <- restart$name
[13:36:35.717]                             if (is.null(name)) 
[13:36:35.717]                               next
[13:36:35.717]                             if (!grepl(pattern, name)) 
[13:36:35.717]                               next
[13:36:35.717]                             invokeRestart(restart)
[13:36:35.717]                             muffled <- TRUE
[13:36:35.717]                             break
[13:36:35.717]                           }
[13:36:35.717]                         }
[13:36:35.717]                       }
[13:36:35.717]                       invisible(muffled)
[13:36:35.717]                     }
[13:36:35.717]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.717]                   }
[13:36:35.717]                 }
[13:36:35.717]             }
[13:36:35.717]         }))
[13:36:35.717]     }, error = function(ex) {
[13:36:35.717]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.717]                 ...future.rng), started = ...future.startTime, 
[13:36:35.717]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.717]             version = "1.8"), class = "FutureResult")
[13:36:35.717]     }, finally = {
[13:36:35.717]         if (!identical(...future.workdir, getwd())) 
[13:36:35.717]             setwd(...future.workdir)
[13:36:35.717]         {
[13:36:35.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.717]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.717]             }
[13:36:35.717]             base::options(...future.oldOptions)
[13:36:35.717]             if (.Platform$OS.type == "windows") {
[13:36:35.717]                 old_names <- names(...future.oldEnvVars)
[13:36:35.717]                 envs <- base::Sys.getenv()
[13:36:35.717]                 names <- names(envs)
[13:36:35.717]                 common <- intersect(names, old_names)
[13:36:35.717]                 added <- setdiff(names, old_names)
[13:36:35.717]                 removed <- setdiff(old_names, names)
[13:36:35.717]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.717]                   envs[common]]
[13:36:35.717]                 NAMES <- toupper(changed)
[13:36:35.717]                 args <- list()
[13:36:35.717]                 for (kk in seq_along(NAMES)) {
[13:36:35.717]                   name <- changed[[kk]]
[13:36:35.717]                   NAME <- NAMES[[kk]]
[13:36:35.717]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.717]                     next
[13:36:35.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.717]                 }
[13:36:35.717]                 NAMES <- toupper(added)
[13:36:35.717]                 for (kk in seq_along(NAMES)) {
[13:36:35.717]                   name <- added[[kk]]
[13:36:35.717]                   NAME <- NAMES[[kk]]
[13:36:35.717]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.717]                     next
[13:36:35.717]                   args[[name]] <- ""
[13:36:35.717]                 }
[13:36:35.717]                 NAMES <- toupper(removed)
[13:36:35.717]                 for (kk in seq_along(NAMES)) {
[13:36:35.717]                   name <- removed[[kk]]
[13:36:35.717]                   NAME <- NAMES[[kk]]
[13:36:35.717]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.717]                     next
[13:36:35.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.717]                 }
[13:36:35.717]                 if (length(args) > 0) 
[13:36:35.717]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.717]             }
[13:36:35.717]             else {
[13:36:35.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.717]             }
[13:36:35.717]             {
[13:36:35.717]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.717]                   0L) {
[13:36:35.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.717]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.717]                   base::options(opts)
[13:36:35.717]                 }
[13:36:35.717]                 {
[13:36:35.717]                   {
[13:36:35.717]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.717]                     NULL
[13:36:35.717]                   }
[13:36:35.717]                   options(future.plan = NULL)
[13:36:35.717]                   if (is.na(NA_character_)) 
[13:36:35.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.717]                     .init = FALSE)
[13:36:35.717]                 }
[13:36:35.717]             }
[13:36:35.717]         }
[13:36:35.717]     })
[13:36:35.717]     if (TRUE) {
[13:36:35.717]         base::sink(type = "output", split = FALSE)
[13:36:35.717]         if (TRUE) {
[13:36:35.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.717]         }
[13:36:35.717]         else {
[13:36:35.717]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.717]         }
[13:36:35.717]         base::close(...future.stdout)
[13:36:35.717]         ...future.stdout <- NULL
[13:36:35.717]     }
[13:36:35.717]     ...future.result$conditions <- ...future.conditions
[13:36:35.717]     ...future.result$finished <- base::Sys.time()
[13:36:35.717]     ...future.result
[13:36:35.717] }
[13:36:35.720] MultisessionFuture started
[13:36:35.720] - Launch lazy future ... done
[13:36:35.720] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a749a4168> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a74dab3d8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a749a4168> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a74dab3d8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:36:35.725] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.725] - Validating connection of MultisessionFuture
[13:36:35.726] - received message: FutureResult
[13:36:35.726] - Received FutureResult
[13:36:35.726] - Erased future from FutureRegistry
[13:36:35.726] result() for ClusterFuture ...
[13:36:35.728] - result already collected: FutureResult
[13:36:35.728] result() for ClusterFuture ... done
[13:36:35.728] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:35.729] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.729] - Validating connection of MultisessionFuture
[13:36:35.729] - received message: FutureResult
[13:36:35.729] - Received FutureResult
[13:36:35.729] - Erased future from FutureRegistry
[13:36:35.729] result() for ClusterFuture ...
[13:36:35.729] - result already collected: FutureResult
[13:36:35.729] result() for ClusterFuture ... done
[13:36:35.730] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:35.731] resolve() on list ...
[13:36:35.731]  recursive: 0
[13:36:35.731]  length: 6
[13:36:35.731]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:35.732] signalConditionsASAP(numeric, pos=1) ...
[13:36:35.732] - nx: 6
[13:36:35.732] - relay: TRUE
[13:36:35.732] - stdout: TRUE
[13:36:35.732] - signal: TRUE
[13:36:35.732] - resignal: FALSE
[13:36:35.732] - force: TRUE
[13:36:35.732] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.732] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.732]  - until=2
[13:36:35.732]  - relaying element #2
[13:36:35.732] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.733] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.733] signalConditionsASAP(NULL, pos=1) ... done
[13:36:35.733]  length: 5 (resolved future 1)
[13:36:35.733] Future #2
[13:36:35.733] result() for ClusterFuture ...
[13:36:35.733] - result already collected: FutureResult
[13:36:35.733] result() for ClusterFuture ... done
[13:36:35.733] result() for ClusterFuture ...
[13:36:35.733] - result already collected: FutureResult
[13:36:35.733] result() for ClusterFuture ... done
[13:36:35.733] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:35.734] - nx: 6
[13:36:35.734] - relay: TRUE
[13:36:35.734] - stdout: TRUE
[13:36:35.734] - signal: TRUE
[13:36:35.734] - resignal: FALSE
[13:36:35.734] - force: TRUE
[13:36:35.734] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.734] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.734]  - until=2
[13:36:35.734]  - relaying element #2
[13:36:35.734] result() for ClusterFuture ...
[13:36:35.734] - result already collected: FutureResult
[13:36:35.735] result() for ClusterFuture ... done
[13:36:35.735] result() for ClusterFuture ...
[13:36:35.735] - result already collected: FutureResult
[13:36:35.735] result() for ClusterFuture ... done
[13:36:35.735] result() for ClusterFuture ...
[13:36:35.735] - result already collected: FutureResult
[13:36:35.735] result() for ClusterFuture ... done
[13:36:35.735] result() for ClusterFuture ...
[13:36:35.735] - result already collected: FutureResult
[13:36:35.735] result() for ClusterFuture ... done
[13:36:35.735] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.736] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.736] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:35.736]  length: 4 (resolved future 2)
[13:36:35.736] Future #3
[13:36:35.736] result() for ClusterFuture ...
[13:36:35.736] - result already collected: FutureResult
[13:36:35.736] result() for ClusterFuture ... done
[13:36:35.736] result() for ClusterFuture ...
[13:36:35.736] - result already collected: FutureResult
[13:36:35.736] result() for ClusterFuture ... done
[13:36:35.736] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:35.737] - nx: 6
[13:36:35.737] - relay: TRUE
[13:36:35.737] - stdout: TRUE
[13:36:35.737] - signal: TRUE
[13:36:35.737] - resignal: FALSE
[13:36:35.737] - force: TRUE
[13:36:35.737] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.737] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.737]  - until=3
[13:36:35.737]  - relaying element #3
[13:36:35.737] result() for ClusterFuture ...
[13:36:35.737] - result already collected: FutureResult
[13:36:35.737] result() for ClusterFuture ... done
[13:36:35.738] result() for ClusterFuture ...
[13:36:35.738] - result already collected: FutureResult
[13:36:35.738] result() for ClusterFuture ... done
[13:36:35.738] result() for ClusterFuture ...
[13:36:35.738] - result already collected: FutureResult
[13:36:35.738] result() for ClusterFuture ... done
[13:36:35.738] result() for ClusterFuture ...
[13:36:35.738] - result already collected: FutureResult
[13:36:35.738] result() for ClusterFuture ... done
[13:36:35.738] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.738] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.739] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:35.739]  length: 3 (resolved future 3)
[13:36:35.739] signalConditionsASAP(NULL, pos=4) ...
[13:36:35.739] - nx: 6
[13:36:35.739] - relay: TRUE
[13:36:35.739] - stdout: TRUE
[13:36:35.739] - signal: TRUE
[13:36:35.739] - resignal: FALSE
[13:36:35.739] - force: TRUE
[13:36:35.739] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.739] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.739]  - until=5
[13:36:35.740]  - relaying element #5
[13:36:35.740] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.740] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.740] signalConditionsASAP(NULL, pos=4) ... done
[13:36:35.740]  length: 2 (resolved future 4)
[13:36:35.740] signalConditionsASAP(NULL, pos=5) ...
[13:36:35.740] - nx: 6
[13:36:35.740] - relay: TRUE
[13:36:35.740] - stdout: TRUE
[13:36:35.740] - signal: TRUE
[13:36:35.740] - resignal: FALSE
[13:36:35.740] - force: TRUE
[13:36:35.741] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.741] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.741]  - until=6
[13:36:35.741]  - relaying element #6
[13:36:35.741] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.741] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.741] signalConditionsASAP(NULL, pos=5) ... done
[13:36:35.741]  length: 1 (resolved future 5)
[13:36:35.741] signalConditionsASAP(numeric, pos=6) ...
[13:36:35.741] - nx: 6
[13:36:35.741] - relay: TRUE
[13:36:35.741] - stdout: TRUE
[13:36:35.742] - signal: TRUE
[13:36:35.742] - resignal: FALSE
[13:36:35.742] - force: TRUE
[13:36:35.742] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.742] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.742]  - until=6
[13:36:35.742] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.742] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.742] signalConditionsASAP(numeric, pos=6) ... done
[13:36:35.742]  length: 0 (resolved future 6)
[13:36:35.742] Relaying remaining futures
[13:36:35.743] signalConditionsASAP(NULL, pos=0) ...
[13:36:35.743] - nx: 6
[13:36:35.743] - relay: TRUE
[13:36:35.743] - stdout: TRUE
[13:36:35.743] - signal: TRUE
[13:36:35.743] - resignal: FALSE
[13:36:35.743] - force: TRUE
[13:36:35.743] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.743] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:35.743] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.743] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.744] signalConditionsASAP(NULL, pos=0) ... done
[13:36:35.744] resolve() on list ... DONE
[13:36:35.744] result() for ClusterFuture ...
[13:36:35.744] - result already collected: FutureResult
[13:36:35.744] result() for ClusterFuture ... done
[13:36:35.744] result() for ClusterFuture ...
[13:36:35.744] - result already collected: FutureResult
[13:36:35.744] result() for ClusterFuture ... done
[13:36:35.744] result() for ClusterFuture ...
[13:36:35.744] - result already collected: FutureResult
[13:36:35.744] result() for ClusterFuture ... done
[13:36:35.744] result() for ClusterFuture ...
[13:36:35.745] - result already collected: FutureResult
[13:36:35.745] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:36:35.748] getGlobalsAndPackages() ...
[13:36:35.748] Searching for globals...
[13:36:35.748] 
[13:36:35.748] Searching for globals ... DONE
[13:36:35.748] - globals: [0] <none>
[13:36:35.748] getGlobalsAndPackages() ... DONE
[13:36:35.749] run() for ‘Future’ ...
[13:36:35.749] - state: ‘created’
[13:36:35.749] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.764]   - Field: ‘node’
[13:36:35.764]   - Field: ‘label’
[13:36:35.764]   - Field: ‘local’
[13:36:35.765]   - Field: ‘owner’
[13:36:35.765]   - Field: ‘envir’
[13:36:35.765]   - Field: ‘workers’
[13:36:35.765]   - Field: ‘packages’
[13:36:35.765]   - Field: ‘gc’
[13:36:35.765]   - Field: ‘conditions’
[13:36:35.765]   - Field: ‘persistent’
[13:36:35.765]   - Field: ‘expr’
[13:36:35.765]   - Field: ‘uuid’
[13:36:35.765]   - Field: ‘seed’
[13:36:35.766]   - Field: ‘version’
[13:36:35.766]   - Field: ‘result’
[13:36:35.766]   - Field: ‘asynchronous’
[13:36:35.766]   - Field: ‘calls’
[13:36:35.766]   - Field: ‘globals’
[13:36:35.766]   - Field: ‘stdout’
[13:36:35.766]   - Field: ‘earlySignal’
[13:36:35.766]   - Field: ‘lazy’
[13:36:35.766]   - Field: ‘state’
[13:36:35.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.766] - Launch lazy future ...
[13:36:35.767] Packages needed by the future expression (n = 0): <none>
[13:36:35.767] Packages needed by future strategies (n = 0): <none>
[13:36:35.767] {
[13:36:35.767]     {
[13:36:35.767]         {
[13:36:35.767]             ...future.startTime <- base::Sys.time()
[13:36:35.767]             {
[13:36:35.767]                 {
[13:36:35.767]                   {
[13:36:35.767]                     {
[13:36:35.767]                       base::local({
[13:36:35.767]                         has_future <- base::requireNamespace("future", 
[13:36:35.767]                           quietly = TRUE)
[13:36:35.767]                         if (has_future) {
[13:36:35.767]                           ns <- base::getNamespace("future")
[13:36:35.767]                           version <- ns[[".package"]][["version"]]
[13:36:35.767]                           if (is.null(version)) 
[13:36:35.767]                             version <- utils::packageVersion("future")
[13:36:35.767]                         }
[13:36:35.767]                         else {
[13:36:35.767]                           version <- NULL
[13:36:35.767]                         }
[13:36:35.767]                         if (!has_future || version < "1.8.0") {
[13:36:35.767]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.767]                             "", base::R.version$version.string), 
[13:36:35.767]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.767]                               "release", "version")], collapse = " "), 
[13:36:35.767]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.767]                             info)
[13:36:35.767]                           info <- base::paste(info, collapse = "; ")
[13:36:35.767]                           if (!has_future) {
[13:36:35.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.767]                               info)
[13:36:35.767]                           }
[13:36:35.767]                           else {
[13:36:35.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.767]                               info, version)
[13:36:35.767]                           }
[13:36:35.767]                           base::stop(msg)
[13:36:35.767]                         }
[13:36:35.767]                       })
[13:36:35.767]                     }
[13:36:35.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.767]                     base::options(mc.cores = 1L)
[13:36:35.767]                   }
[13:36:35.767]                   ...future.strategy.old <- future::plan("list")
[13:36:35.767]                   options(future.plan = NULL)
[13:36:35.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.767]                 }
[13:36:35.767]                 ...future.workdir <- getwd()
[13:36:35.767]             }
[13:36:35.767]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.767]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.767]         }
[13:36:35.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.767]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.767]             base::names(...future.oldOptions))
[13:36:35.767]     }
[13:36:35.767]     if (FALSE) {
[13:36:35.767]     }
[13:36:35.767]     else {
[13:36:35.767]         if (TRUE) {
[13:36:35.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.767]                 open = "w")
[13:36:35.767]         }
[13:36:35.767]         else {
[13:36:35.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.767]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.767]         }
[13:36:35.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.767]             base::sink(type = "output", split = FALSE)
[13:36:35.767]             base::close(...future.stdout)
[13:36:35.767]         }, add = TRUE)
[13:36:35.767]     }
[13:36:35.767]     ...future.frame <- base::sys.nframe()
[13:36:35.767]     ...future.conditions <- base::list()
[13:36:35.767]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.767]     if (FALSE) {
[13:36:35.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.767]     }
[13:36:35.767]     ...future.result <- base::tryCatch({
[13:36:35.767]         base::withCallingHandlers({
[13:36:35.767]             ...future.value <- base::withVisible(base::local({
[13:36:35.767]                 ...future.makeSendCondition <- base::local({
[13:36:35.767]                   sendCondition <- NULL
[13:36:35.767]                   function(frame = 1L) {
[13:36:35.767]                     if (is.function(sendCondition)) 
[13:36:35.767]                       return(sendCondition)
[13:36:35.767]                     ns <- getNamespace("parallel")
[13:36:35.767]                     if (exists("sendData", mode = "function", 
[13:36:35.767]                       envir = ns)) {
[13:36:35.767]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.767]                         envir = ns)
[13:36:35.767]                       envir <- sys.frame(frame)
[13:36:35.767]                       master <- NULL
[13:36:35.767]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.767]                         !identical(envir, emptyenv())) {
[13:36:35.767]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.767]                           inherits = FALSE)) {
[13:36:35.767]                           master <- get("master", mode = "list", 
[13:36:35.767]                             envir = envir, inherits = FALSE)
[13:36:35.767]                           if (inherits(master, c("SOCKnode", 
[13:36:35.767]                             "SOCK0node"))) {
[13:36:35.767]                             sendCondition <<- function(cond) {
[13:36:35.767]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.767]                                 success = TRUE)
[13:36:35.767]                               parallel_sendData(master, data)
[13:36:35.767]                             }
[13:36:35.767]                             return(sendCondition)
[13:36:35.767]                           }
[13:36:35.767]                         }
[13:36:35.767]                         frame <- frame + 1L
[13:36:35.767]                         envir <- sys.frame(frame)
[13:36:35.767]                       }
[13:36:35.767]                     }
[13:36:35.767]                     sendCondition <<- function(cond) NULL
[13:36:35.767]                   }
[13:36:35.767]                 })
[13:36:35.767]                 withCallingHandlers({
[13:36:35.767]                   2
[13:36:35.767]                 }, immediateCondition = function(cond) {
[13:36:35.767]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.767]                   sendCondition(cond)
[13:36:35.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.767]                   {
[13:36:35.767]                     inherits <- base::inherits
[13:36:35.767]                     invokeRestart <- base::invokeRestart
[13:36:35.767]                     is.null <- base::is.null
[13:36:35.767]                     muffled <- FALSE
[13:36:35.767]                     if (inherits(cond, "message")) {
[13:36:35.767]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.767]                       if (muffled) 
[13:36:35.767]                         invokeRestart("muffleMessage")
[13:36:35.767]                     }
[13:36:35.767]                     else if (inherits(cond, "warning")) {
[13:36:35.767]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.767]                       if (muffled) 
[13:36:35.767]                         invokeRestart("muffleWarning")
[13:36:35.767]                     }
[13:36:35.767]                     else if (inherits(cond, "condition")) {
[13:36:35.767]                       if (!is.null(pattern)) {
[13:36:35.767]                         computeRestarts <- base::computeRestarts
[13:36:35.767]                         grepl <- base::grepl
[13:36:35.767]                         restarts <- computeRestarts(cond)
[13:36:35.767]                         for (restart in restarts) {
[13:36:35.767]                           name <- restart$name
[13:36:35.767]                           if (is.null(name)) 
[13:36:35.767]                             next
[13:36:35.767]                           if (!grepl(pattern, name)) 
[13:36:35.767]                             next
[13:36:35.767]                           invokeRestart(restart)
[13:36:35.767]                           muffled <- TRUE
[13:36:35.767]                           break
[13:36:35.767]                         }
[13:36:35.767]                       }
[13:36:35.767]                     }
[13:36:35.767]                     invisible(muffled)
[13:36:35.767]                   }
[13:36:35.767]                   muffleCondition(cond)
[13:36:35.767]                 })
[13:36:35.767]             }))
[13:36:35.767]             future::FutureResult(value = ...future.value$value, 
[13:36:35.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.767]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.767]                     ...future.globalenv.names))
[13:36:35.767]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.767]         }, condition = base::local({
[13:36:35.767]             c <- base::c
[13:36:35.767]             inherits <- base::inherits
[13:36:35.767]             invokeRestart <- base::invokeRestart
[13:36:35.767]             length <- base::length
[13:36:35.767]             list <- base::list
[13:36:35.767]             seq.int <- base::seq.int
[13:36:35.767]             signalCondition <- base::signalCondition
[13:36:35.767]             sys.calls <- base::sys.calls
[13:36:35.767]             `[[` <- base::`[[`
[13:36:35.767]             `+` <- base::`+`
[13:36:35.767]             `<<-` <- base::`<<-`
[13:36:35.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.767]                   3L)]
[13:36:35.767]             }
[13:36:35.767]             function(cond) {
[13:36:35.767]                 is_error <- inherits(cond, "error")
[13:36:35.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.767]                   NULL)
[13:36:35.767]                 if (is_error) {
[13:36:35.767]                   sessionInformation <- function() {
[13:36:35.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.767]                       search = base::search(), system = base::Sys.info())
[13:36:35.767]                   }
[13:36:35.767]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.767]                     cond$call), session = sessionInformation(), 
[13:36:35.767]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.767]                   signalCondition(cond)
[13:36:35.767]                 }
[13:36:35.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.767]                 "immediateCondition"))) {
[13:36:35.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.767]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.767]                   if (TRUE && !signal) {
[13:36:35.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.767]                     {
[13:36:35.767]                       inherits <- base::inherits
[13:36:35.767]                       invokeRestart <- base::invokeRestart
[13:36:35.767]                       is.null <- base::is.null
[13:36:35.767]                       muffled <- FALSE
[13:36:35.767]                       if (inherits(cond, "message")) {
[13:36:35.767]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.767]                         if (muffled) 
[13:36:35.767]                           invokeRestart("muffleMessage")
[13:36:35.767]                       }
[13:36:35.767]                       else if (inherits(cond, "warning")) {
[13:36:35.767]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.767]                         if (muffled) 
[13:36:35.767]                           invokeRestart("muffleWarning")
[13:36:35.767]                       }
[13:36:35.767]                       else if (inherits(cond, "condition")) {
[13:36:35.767]                         if (!is.null(pattern)) {
[13:36:35.767]                           computeRestarts <- base::computeRestarts
[13:36:35.767]                           grepl <- base::grepl
[13:36:35.767]                           restarts <- computeRestarts(cond)
[13:36:35.767]                           for (restart in restarts) {
[13:36:35.767]                             name <- restart$name
[13:36:35.767]                             if (is.null(name)) 
[13:36:35.767]                               next
[13:36:35.767]                             if (!grepl(pattern, name)) 
[13:36:35.767]                               next
[13:36:35.767]                             invokeRestart(restart)
[13:36:35.767]                             muffled <- TRUE
[13:36:35.767]                             break
[13:36:35.767]                           }
[13:36:35.767]                         }
[13:36:35.767]                       }
[13:36:35.767]                       invisible(muffled)
[13:36:35.767]                     }
[13:36:35.767]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.767]                   }
[13:36:35.767]                 }
[13:36:35.767]                 else {
[13:36:35.767]                   if (TRUE) {
[13:36:35.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.767]                     {
[13:36:35.767]                       inherits <- base::inherits
[13:36:35.767]                       invokeRestart <- base::invokeRestart
[13:36:35.767]                       is.null <- base::is.null
[13:36:35.767]                       muffled <- FALSE
[13:36:35.767]                       if (inherits(cond, "message")) {
[13:36:35.767]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.767]                         if (muffled) 
[13:36:35.767]                           invokeRestart("muffleMessage")
[13:36:35.767]                       }
[13:36:35.767]                       else if (inherits(cond, "warning")) {
[13:36:35.767]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.767]                         if (muffled) 
[13:36:35.767]                           invokeRestart("muffleWarning")
[13:36:35.767]                       }
[13:36:35.767]                       else if (inherits(cond, "condition")) {
[13:36:35.767]                         if (!is.null(pattern)) {
[13:36:35.767]                           computeRestarts <- base::computeRestarts
[13:36:35.767]                           grepl <- base::grepl
[13:36:35.767]                           restarts <- computeRestarts(cond)
[13:36:35.767]                           for (restart in restarts) {
[13:36:35.767]                             name <- restart$name
[13:36:35.767]                             if (is.null(name)) 
[13:36:35.767]                               next
[13:36:35.767]                             if (!grepl(pattern, name)) 
[13:36:35.767]                               next
[13:36:35.767]                             invokeRestart(restart)
[13:36:35.767]                             muffled <- TRUE
[13:36:35.767]                             break
[13:36:35.767]                           }
[13:36:35.767]                         }
[13:36:35.767]                       }
[13:36:35.767]                       invisible(muffled)
[13:36:35.767]                     }
[13:36:35.767]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.767]                   }
[13:36:35.767]                 }
[13:36:35.767]             }
[13:36:35.767]         }))
[13:36:35.767]     }, error = function(ex) {
[13:36:35.767]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.767]                 ...future.rng), started = ...future.startTime, 
[13:36:35.767]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.767]             version = "1.8"), class = "FutureResult")
[13:36:35.767]     }, finally = {
[13:36:35.767]         if (!identical(...future.workdir, getwd())) 
[13:36:35.767]             setwd(...future.workdir)
[13:36:35.767]         {
[13:36:35.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.767]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.767]             }
[13:36:35.767]             base::options(...future.oldOptions)
[13:36:35.767]             if (.Platform$OS.type == "windows") {
[13:36:35.767]                 old_names <- names(...future.oldEnvVars)
[13:36:35.767]                 envs <- base::Sys.getenv()
[13:36:35.767]                 names <- names(envs)
[13:36:35.767]                 common <- intersect(names, old_names)
[13:36:35.767]                 added <- setdiff(names, old_names)
[13:36:35.767]                 removed <- setdiff(old_names, names)
[13:36:35.767]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.767]                   envs[common]]
[13:36:35.767]                 NAMES <- toupper(changed)
[13:36:35.767]                 args <- list()
[13:36:35.767]                 for (kk in seq_along(NAMES)) {
[13:36:35.767]                   name <- changed[[kk]]
[13:36:35.767]                   NAME <- NAMES[[kk]]
[13:36:35.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.767]                     next
[13:36:35.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.767]                 }
[13:36:35.767]                 NAMES <- toupper(added)
[13:36:35.767]                 for (kk in seq_along(NAMES)) {
[13:36:35.767]                   name <- added[[kk]]
[13:36:35.767]                   NAME <- NAMES[[kk]]
[13:36:35.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.767]                     next
[13:36:35.767]                   args[[name]] <- ""
[13:36:35.767]                 }
[13:36:35.767]                 NAMES <- toupper(removed)
[13:36:35.767]                 for (kk in seq_along(NAMES)) {
[13:36:35.767]                   name <- removed[[kk]]
[13:36:35.767]                   NAME <- NAMES[[kk]]
[13:36:35.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.767]                     next
[13:36:35.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.767]                 }
[13:36:35.767]                 if (length(args) > 0) 
[13:36:35.767]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.767]             }
[13:36:35.767]             else {
[13:36:35.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.767]             }
[13:36:35.767]             {
[13:36:35.767]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.767]                   0L) {
[13:36:35.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.767]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.767]                   base::options(opts)
[13:36:35.767]                 }
[13:36:35.767]                 {
[13:36:35.767]                   {
[13:36:35.767]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.767]                     NULL
[13:36:35.767]                   }
[13:36:35.767]                   options(future.plan = NULL)
[13:36:35.767]                   if (is.na(NA_character_)) 
[13:36:35.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.767]                     .init = FALSE)
[13:36:35.767]                 }
[13:36:35.767]             }
[13:36:35.767]         }
[13:36:35.767]     })
[13:36:35.767]     if (TRUE) {
[13:36:35.767]         base::sink(type = "output", split = FALSE)
[13:36:35.767]         if (TRUE) {
[13:36:35.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.767]         }
[13:36:35.767]         else {
[13:36:35.767]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.767]         }
[13:36:35.767]         base::close(...future.stdout)
[13:36:35.767]         ...future.stdout <- NULL
[13:36:35.767]     }
[13:36:35.767]     ...future.result$conditions <- ...future.conditions
[13:36:35.767]     ...future.result$finished <- base::Sys.time()
[13:36:35.767]     ...future.result
[13:36:35.767] }
[13:36:35.770] MultisessionFuture started
[13:36:35.770] - Launch lazy future ... done
[13:36:35.770] run() for ‘MultisessionFuture’ ... done
[13:36:35.770] getGlobalsAndPackages() ...
[13:36:35.770] Searching for globals...
[13:36:35.771] 
[13:36:35.771] Searching for globals ... DONE
[13:36:35.771] - globals: [0] <none>
[13:36:35.771] getGlobalsAndPackages() ... DONE
[13:36:35.771] run() for ‘Future’ ...
[13:36:35.771] - state: ‘created’
[13:36:35.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.785]   - Field: ‘node’
[13:36:35.785]   - Field: ‘label’
[13:36:35.785]   - Field: ‘local’
[13:36:35.785]   - Field: ‘owner’
[13:36:35.785]   - Field: ‘envir’
[13:36:35.786]   - Field: ‘workers’
[13:36:35.786]   - Field: ‘packages’
[13:36:35.786]   - Field: ‘gc’
[13:36:35.786]   - Field: ‘conditions’
[13:36:35.786]   - Field: ‘persistent’
[13:36:35.786]   - Field: ‘expr’
[13:36:35.786]   - Field: ‘uuid’
[13:36:35.786]   - Field: ‘seed’
[13:36:35.786]   - Field: ‘version’
[13:36:35.786]   - Field: ‘result’
[13:36:35.787]   - Field: ‘asynchronous’
[13:36:35.787]   - Field: ‘calls’
[13:36:35.787]   - Field: ‘globals’
[13:36:35.787]   - Field: ‘stdout’
[13:36:35.787]   - Field: ‘earlySignal’
[13:36:35.787]   - Field: ‘lazy’
[13:36:35.787]   - Field: ‘state’
[13:36:35.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.787] - Launch lazy future ...
[13:36:35.788] Packages needed by the future expression (n = 0): <none>
[13:36:35.788] Packages needed by future strategies (n = 0): <none>
[13:36:35.788] {
[13:36:35.788]     {
[13:36:35.788]         {
[13:36:35.788]             ...future.startTime <- base::Sys.time()
[13:36:35.788]             {
[13:36:35.788]                 {
[13:36:35.788]                   {
[13:36:35.788]                     {
[13:36:35.788]                       base::local({
[13:36:35.788]                         has_future <- base::requireNamespace("future", 
[13:36:35.788]                           quietly = TRUE)
[13:36:35.788]                         if (has_future) {
[13:36:35.788]                           ns <- base::getNamespace("future")
[13:36:35.788]                           version <- ns[[".package"]][["version"]]
[13:36:35.788]                           if (is.null(version)) 
[13:36:35.788]                             version <- utils::packageVersion("future")
[13:36:35.788]                         }
[13:36:35.788]                         else {
[13:36:35.788]                           version <- NULL
[13:36:35.788]                         }
[13:36:35.788]                         if (!has_future || version < "1.8.0") {
[13:36:35.788]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.788]                             "", base::R.version$version.string), 
[13:36:35.788]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.788]                               "release", "version")], collapse = " "), 
[13:36:35.788]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.788]                             info)
[13:36:35.788]                           info <- base::paste(info, collapse = "; ")
[13:36:35.788]                           if (!has_future) {
[13:36:35.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.788]                               info)
[13:36:35.788]                           }
[13:36:35.788]                           else {
[13:36:35.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.788]                               info, version)
[13:36:35.788]                           }
[13:36:35.788]                           base::stop(msg)
[13:36:35.788]                         }
[13:36:35.788]                       })
[13:36:35.788]                     }
[13:36:35.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.788]                     base::options(mc.cores = 1L)
[13:36:35.788]                   }
[13:36:35.788]                   ...future.strategy.old <- future::plan("list")
[13:36:35.788]                   options(future.plan = NULL)
[13:36:35.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.788]                 }
[13:36:35.788]                 ...future.workdir <- getwd()
[13:36:35.788]             }
[13:36:35.788]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.788]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.788]         }
[13:36:35.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.788]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.788]             base::names(...future.oldOptions))
[13:36:35.788]     }
[13:36:35.788]     if (FALSE) {
[13:36:35.788]     }
[13:36:35.788]     else {
[13:36:35.788]         if (TRUE) {
[13:36:35.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.788]                 open = "w")
[13:36:35.788]         }
[13:36:35.788]         else {
[13:36:35.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.788]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.788]         }
[13:36:35.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.788]             base::sink(type = "output", split = FALSE)
[13:36:35.788]             base::close(...future.stdout)
[13:36:35.788]         }, add = TRUE)
[13:36:35.788]     }
[13:36:35.788]     ...future.frame <- base::sys.nframe()
[13:36:35.788]     ...future.conditions <- base::list()
[13:36:35.788]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.788]     if (FALSE) {
[13:36:35.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.788]     }
[13:36:35.788]     ...future.result <- base::tryCatch({
[13:36:35.788]         base::withCallingHandlers({
[13:36:35.788]             ...future.value <- base::withVisible(base::local({
[13:36:35.788]                 ...future.makeSendCondition <- base::local({
[13:36:35.788]                   sendCondition <- NULL
[13:36:35.788]                   function(frame = 1L) {
[13:36:35.788]                     if (is.function(sendCondition)) 
[13:36:35.788]                       return(sendCondition)
[13:36:35.788]                     ns <- getNamespace("parallel")
[13:36:35.788]                     if (exists("sendData", mode = "function", 
[13:36:35.788]                       envir = ns)) {
[13:36:35.788]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.788]                         envir = ns)
[13:36:35.788]                       envir <- sys.frame(frame)
[13:36:35.788]                       master <- NULL
[13:36:35.788]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.788]                         !identical(envir, emptyenv())) {
[13:36:35.788]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.788]                           inherits = FALSE)) {
[13:36:35.788]                           master <- get("master", mode = "list", 
[13:36:35.788]                             envir = envir, inherits = FALSE)
[13:36:35.788]                           if (inherits(master, c("SOCKnode", 
[13:36:35.788]                             "SOCK0node"))) {
[13:36:35.788]                             sendCondition <<- function(cond) {
[13:36:35.788]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.788]                                 success = TRUE)
[13:36:35.788]                               parallel_sendData(master, data)
[13:36:35.788]                             }
[13:36:35.788]                             return(sendCondition)
[13:36:35.788]                           }
[13:36:35.788]                         }
[13:36:35.788]                         frame <- frame + 1L
[13:36:35.788]                         envir <- sys.frame(frame)
[13:36:35.788]                       }
[13:36:35.788]                     }
[13:36:35.788]                     sendCondition <<- function(cond) NULL
[13:36:35.788]                   }
[13:36:35.788]                 })
[13:36:35.788]                 withCallingHandlers({
[13:36:35.788]                   NULL
[13:36:35.788]                 }, immediateCondition = function(cond) {
[13:36:35.788]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.788]                   sendCondition(cond)
[13:36:35.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.788]                   {
[13:36:35.788]                     inherits <- base::inherits
[13:36:35.788]                     invokeRestart <- base::invokeRestart
[13:36:35.788]                     is.null <- base::is.null
[13:36:35.788]                     muffled <- FALSE
[13:36:35.788]                     if (inherits(cond, "message")) {
[13:36:35.788]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.788]                       if (muffled) 
[13:36:35.788]                         invokeRestart("muffleMessage")
[13:36:35.788]                     }
[13:36:35.788]                     else if (inherits(cond, "warning")) {
[13:36:35.788]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.788]                       if (muffled) 
[13:36:35.788]                         invokeRestart("muffleWarning")
[13:36:35.788]                     }
[13:36:35.788]                     else if (inherits(cond, "condition")) {
[13:36:35.788]                       if (!is.null(pattern)) {
[13:36:35.788]                         computeRestarts <- base::computeRestarts
[13:36:35.788]                         grepl <- base::grepl
[13:36:35.788]                         restarts <- computeRestarts(cond)
[13:36:35.788]                         for (restart in restarts) {
[13:36:35.788]                           name <- restart$name
[13:36:35.788]                           if (is.null(name)) 
[13:36:35.788]                             next
[13:36:35.788]                           if (!grepl(pattern, name)) 
[13:36:35.788]                             next
[13:36:35.788]                           invokeRestart(restart)
[13:36:35.788]                           muffled <- TRUE
[13:36:35.788]                           break
[13:36:35.788]                         }
[13:36:35.788]                       }
[13:36:35.788]                     }
[13:36:35.788]                     invisible(muffled)
[13:36:35.788]                   }
[13:36:35.788]                   muffleCondition(cond)
[13:36:35.788]                 })
[13:36:35.788]             }))
[13:36:35.788]             future::FutureResult(value = ...future.value$value, 
[13:36:35.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.788]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.788]                     ...future.globalenv.names))
[13:36:35.788]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.788]         }, condition = base::local({
[13:36:35.788]             c <- base::c
[13:36:35.788]             inherits <- base::inherits
[13:36:35.788]             invokeRestart <- base::invokeRestart
[13:36:35.788]             length <- base::length
[13:36:35.788]             list <- base::list
[13:36:35.788]             seq.int <- base::seq.int
[13:36:35.788]             signalCondition <- base::signalCondition
[13:36:35.788]             sys.calls <- base::sys.calls
[13:36:35.788]             `[[` <- base::`[[`
[13:36:35.788]             `+` <- base::`+`
[13:36:35.788]             `<<-` <- base::`<<-`
[13:36:35.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.788]                   3L)]
[13:36:35.788]             }
[13:36:35.788]             function(cond) {
[13:36:35.788]                 is_error <- inherits(cond, "error")
[13:36:35.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.788]                   NULL)
[13:36:35.788]                 if (is_error) {
[13:36:35.788]                   sessionInformation <- function() {
[13:36:35.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.788]                       search = base::search(), system = base::Sys.info())
[13:36:35.788]                   }
[13:36:35.788]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.788]                     cond$call), session = sessionInformation(), 
[13:36:35.788]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.788]                   signalCondition(cond)
[13:36:35.788]                 }
[13:36:35.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.788]                 "immediateCondition"))) {
[13:36:35.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.788]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.788]                   if (TRUE && !signal) {
[13:36:35.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.788]                     {
[13:36:35.788]                       inherits <- base::inherits
[13:36:35.788]                       invokeRestart <- base::invokeRestart
[13:36:35.788]                       is.null <- base::is.null
[13:36:35.788]                       muffled <- FALSE
[13:36:35.788]                       if (inherits(cond, "message")) {
[13:36:35.788]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.788]                         if (muffled) 
[13:36:35.788]                           invokeRestart("muffleMessage")
[13:36:35.788]                       }
[13:36:35.788]                       else if (inherits(cond, "warning")) {
[13:36:35.788]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.788]                         if (muffled) 
[13:36:35.788]                           invokeRestart("muffleWarning")
[13:36:35.788]                       }
[13:36:35.788]                       else if (inherits(cond, "condition")) {
[13:36:35.788]                         if (!is.null(pattern)) {
[13:36:35.788]                           computeRestarts <- base::computeRestarts
[13:36:35.788]                           grepl <- base::grepl
[13:36:35.788]                           restarts <- computeRestarts(cond)
[13:36:35.788]                           for (restart in restarts) {
[13:36:35.788]                             name <- restart$name
[13:36:35.788]                             if (is.null(name)) 
[13:36:35.788]                               next
[13:36:35.788]                             if (!grepl(pattern, name)) 
[13:36:35.788]                               next
[13:36:35.788]                             invokeRestart(restart)
[13:36:35.788]                             muffled <- TRUE
[13:36:35.788]                             break
[13:36:35.788]                           }
[13:36:35.788]                         }
[13:36:35.788]                       }
[13:36:35.788]                       invisible(muffled)
[13:36:35.788]                     }
[13:36:35.788]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.788]                   }
[13:36:35.788]                 }
[13:36:35.788]                 else {
[13:36:35.788]                   if (TRUE) {
[13:36:35.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.788]                     {
[13:36:35.788]                       inherits <- base::inherits
[13:36:35.788]                       invokeRestart <- base::invokeRestart
[13:36:35.788]                       is.null <- base::is.null
[13:36:35.788]                       muffled <- FALSE
[13:36:35.788]                       if (inherits(cond, "message")) {
[13:36:35.788]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.788]                         if (muffled) 
[13:36:35.788]                           invokeRestart("muffleMessage")
[13:36:35.788]                       }
[13:36:35.788]                       else if (inherits(cond, "warning")) {
[13:36:35.788]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.788]                         if (muffled) 
[13:36:35.788]                           invokeRestart("muffleWarning")
[13:36:35.788]                       }
[13:36:35.788]                       else if (inherits(cond, "condition")) {
[13:36:35.788]                         if (!is.null(pattern)) {
[13:36:35.788]                           computeRestarts <- base::computeRestarts
[13:36:35.788]                           grepl <- base::grepl
[13:36:35.788]                           restarts <- computeRestarts(cond)
[13:36:35.788]                           for (restart in restarts) {
[13:36:35.788]                             name <- restart$name
[13:36:35.788]                             if (is.null(name)) 
[13:36:35.788]                               next
[13:36:35.788]                             if (!grepl(pattern, name)) 
[13:36:35.788]                               next
[13:36:35.788]                             invokeRestart(restart)
[13:36:35.788]                             muffled <- TRUE
[13:36:35.788]                             break
[13:36:35.788]                           }
[13:36:35.788]                         }
[13:36:35.788]                       }
[13:36:35.788]                       invisible(muffled)
[13:36:35.788]                     }
[13:36:35.788]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.788]                   }
[13:36:35.788]                 }
[13:36:35.788]             }
[13:36:35.788]         }))
[13:36:35.788]     }, error = function(ex) {
[13:36:35.788]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.788]                 ...future.rng), started = ...future.startTime, 
[13:36:35.788]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.788]             version = "1.8"), class = "FutureResult")
[13:36:35.788]     }, finally = {
[13:36:35.788]         if (!identical(...future.workdir, getwd())) 
[13:36:35.788]             setwd(...future.workdir)
[13:36:35.788]         {
[13:36:35.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.788]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.788]             }
[13:36:35.788]             base::options(...future.oldOptions)
[13:36:35.788]             if (.Platform$OS.type == "windows") {
[13:36:35.788]                 old_names <- names(...future.oldEnvVars)
[13:36:35.788]                 envs <- base::Sys.getenv()
[13:36:35.788]                 names <- names(envs)
[13:36:35.788]                 common <- intersect(names, old_names)
[13:36:35.788]                 added <- setdiff(names, old_names)
[13:36:35.788]                 removed <- setdiff(old_names, names)
[13:36:35.788]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.788]                   envs[common]]
[13:36:35.788]                 NAMES <- toupper(changed)
[13:36:35.788]                 args <- list()
[13:36:35.788]                 for (kk in seq_along(NAMES)) {
[13:36:35.788]                   name <- changed[[kk]]
[13:36:35.788]                   NAME <- NAMES[[kk]]
[13:36:35.788]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.788]                     next
[13:36:35.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.788]                 }
[13:36:35.788]                 NAMES <- toupper(added)
[13:36:35.788]                 for (kk in seq_along(NAMES)) {
[13:36:35.788]                   name <- added[[kk]]
[13:36:35.788]                   NAME <- NAMES[[kk]]
[13:36:35.788]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.788]                     next
[13:36:35.788]                   args[[name]] <- ""
[13:36:35.788]                 }
[13:36:35.788]                 NAMES <- toupper(removed)
[13:36:35.788]                 for (kk in seq_along(NAMES)) {
[13:36:35.788]                   name <- removed[[kk]]
[13:36:35.788]                   NAME <- NAMES[[kk]]
[13:36:35.788]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.788]                     next
[13:36:35.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.788]                 }
[13:36:35.788]                 if (length(args) > 0) 
[13:36:35.788]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.788]             }
[13:36:35.788]             else {
[13:36:35.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.788]             }
[13:36:35.788]             {
[13:36:35.788]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.788]                   0L) {
[13:36:35.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.788]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.788]                   base::options(opts)
[13:36:35.788]                 }
[13:36:35.788]                 {
[13:36:35.788]                   {
[13:36:35.788]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.788]                     NULL
[13:36:35.788]                   }
[13:36:35.788]                   options(future.plan = NULL)
[13:36:35.788]                   if (is.na(NA_character_)) 
[13:36:35.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.788]                     .init = FALSE)
[13:36:35.788]                 }
[13:36:35.788]             }
[13:36:35.788]         }
[13:36:35.788]     })
[13:36:35.788]     if (TRUE) {
[13:36:35.788]         base::sink(type = "output", split = FALSE)
[13:36:35.788]         if (TRUE) {
[13:36:35.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.788]         }
[13:36:35.788]         else {
[13:36:35.788]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.788]         }
[13:36:35.788]         base::close(...future.stdout)
[13:36:35.788]         ...future.stdout <- NULL
[13:36:35.788]     }
[13:36:35.788]     ...future.result$conditions <- ...future.conditions
[13:36:35.788]     ...future.result$finished <- base::Sys.time()
[13:36:35.788]     ...future.result
[13:36:35.788] }
[13:36:35.791] MultisessionFuture started
[13:36:35.791] - Launch lazy future ... done
[13:36:35.791] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72624330> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a73fbc210> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a72624330> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a73fbc210> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:35.797] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.797] - Validating connection of MultisessionFuture
[13:36:35.797] - received message: FutureResult
[13:36:35.797] - Received FutureResult
[13:36:35.797] - Erased future from FutureRegistry
[13:36:35.797] result() for ClusterFuture ...
[13:36:35.797] - result already collected: FutureResult
[13:36:35.797] result() for ClusterFuture ... done
[13:36:35.797] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:35.798] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.798] - Validating connection of MultisessionFuture
[13:36:35.798] - received message: FutureResult
[13:36:35.798] - Received FutureResult
[13:36:35.798] - Erased future from FutureRegistry
[13:36:35.798] result() for ClusterFuture ...
[13:36:35.799] - result already collected: FutureResult
[13:36:35.799] result() for ClusterFuture ... done
[13:36:35.799] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:35.800] resolve() on list ...
[13:36:35.801]  recursive: 0
[13:36:35.801]  length: 6
[13:36:35.801]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:35.801] signalConditionsASAP(numeric, pos=1) ...
[13:36:35.801] - nx: 6
[13:36:35.801] - relay: TRUE
[13:36:35.801] - stdout: TRUE
[13:36:35.801] - signal: TRUE
[13:36:35.801] - resignal: FALSE
[13:36:35.801] - force: TRUE
[13:36:35.801] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.802] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.802]  - until=2
[13:36:35.802]  - relaying element #2
[13:36:35.802] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.802] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.802] signalConditionsASAP(NULL, pos=1) ... done
[13:36:35.802]  length: 5 (resolved future 1)
[13:36:35.802] Future #2
[13:36:35.802] result() for ClusterFuture ...
[13:36:35.802] - result already collected: FutureResult
[13:36:35.803] result() for ClusterFuture ... done
[13:36:35.803] result() for ClusterFuture ...
[13:36:35.803] - result already collected: FutureResult
[13:36:35.803] result() for ClusterFuture ... done
[13:36:35.803] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:35.803] - nx: 6
[13:36:35.803] - relay: TRUE
[13:36:35.803] - stdout: TRUE
[13:36:35.803] - signal: TRUE
[13:36:35.803] - resignal: FALSE
[13:36:35.803] - force: TRUE
[13:36:35.803] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.804] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.804]  - until=2
[13:36:35.804]  - relaying element #2
[13:36:35.804] result() for ClusterFuture ...
[13:36:35.804] - result already collected: FutureResult
[13:36:35.804] result() for ClusterFuture ... done
[13:36:35.804] result() for ClusterFuture ...
[13:36:35.804] - result already collected: FutureResult
[13:36:35.804] result() for ClusterFuture ... done
[13:36:35.804] result() for ClusterFuture ...
[13:36:35.804] - result already collected: FutureResult
[13:36:35.805] result() for ClusterFuture ... done
[13:36:35.805] result() for ClusterFuture ...
[13:36:35.805] - result already collected: FutureResult
[13:36:35.805] result() for ClusterFuture ... done
[13:36:35.805] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.805] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.805] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:35.805]  length: 4 (resolved future 2)
[13:36:35.805] Future #3
[13:36:35.805] result() for ClusterFuture ...
[13:36:35.805] - result already collected: FutureResult
[13:36:35.806] result() for ClusterFuture ... done
[13:36:35.806] result() for ClusterFuture ...
[13:36:35.806] - result already collected: FutureResult
[13:36:35.806] result() for ClusterFuture ... done
[13:36:35.806] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:35.806] - nx: 6
[13:36:35.806] - relay: TRUE
[13:36:35.806] - stdout: TRUE
[13:36:35.806] - signal: TRUE
[13:36:35.806] - resignal: FALSE
[13:36:35.806] - force: TRUE
[13:36:35.807] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.807] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.807]  - until=3
[13:36:35.807]  - relaying element #3
[13:36:35.807] result() for ClusterFuture ...
[13:36:35.807] - result already collected: FutureResult
[13:36:35.807] result() for ClusterFuture ... done
[13:36:35.807] result() for ClusterFuture ...
[13:36:35.807] - result already collected: FutureResult
[13:36:35.807] result() for ClusterFuture ... done
[13:36:35.807] result() for ClusterFuture ...
[13:36:35.808] - result already collected: FutureResult
[13:36:35.808] result() for ClusterFuture ... done
[13:36:35.808] result() for ClusterFuture ...
[13:36:35.808] - result already collected: FutureResult
[13:36:35.808] result() for ClusterFuture ... done
[13:36:35.808] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.808] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.808] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:35.808]  length: 3 (resolved future 3)
[13:36:35.808] signalConditionsASAP(NULL, pos=4) ...
[13:36:35.808] - nx: 6
[13:36:35.808] - relay: TRUE
[13:36:35.809] - stdout: TRUE
[13:36:35.809] - signal: TRUE
[13:36:35.809] - resignal: FALSE
[13:36:35.809] - force: TRUE
[13:36:35.809] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.809] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.809]  - until=5
[13:36:35.809]  - relaying element #5
[13:36:35.809] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.809] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.809] signalConditionsASAP(NULL, pos=4) ... done
[13:36:35.809]  length: 2 (resolved future 4)
[13:36:35.810] signalConditionsASAP(NULL, pos=5) ...
[13:36:35.810] - nx: 6
[13:36:35.810] - relay: TRUE
[13:36:35.810] - stdout: TRUE
[13:36:35.810] - signal: TRUE
[13:36:35.810] - resignal: FALSE
[13:36:35.810] - force: TRUE
[13:36:35.810] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.810] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.810]  - until=6
[13:36:35.810]  - relaying element #6
[13:36:35.811] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.811] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.811] signalConditionsASAP(NULL, pos=5) ... done
[13:36:35.811]  length: 1 (resolved future 5)
[13:36:35.811] signalConditionsASAP(numeric, pos=6) ...
[13:36:35.811] - nx: 6
[13:36:35.811] - relay: TRUE
[13:36:35.811] - stdout: TRUE
[13:36:35.811] - signal: TRUE
[13:36:35.811] - resignal: FALSE
[13:36:35.811] - force: TRUE
[13:36:35.811] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.812] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.812]  - until=6
[13:36:35.812] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.812] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.812] signalConditionsASAP(numeric, pos=6) ... done
[13:36:35.812]  length: 0 (resolved future 6)
[13:36:35.812] Relaying remaining futures
[13:36:35.812] signalConditionsASAP(NULL, pos=0) ...
[13:36:35.812] - nx: 6
[13:36:35.812] - relay: TRUE
[13:36:35.812] - stdout: TRUE
[13:36:35.812] - signal: TRUE
[13:36:35.813] - resignal: FALSE
[13:36:35.813] - force: TRUE
[13:36:35.813] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.813] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:35.813] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.813] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.813] signalConditionsASAP(NULL, pos=0) ... done
[13:36:35.813] resolve() on list ... DONE
[13:36:35.813] result() for ClusterFuture ...
[13:36:35.813] - result already collected: FutureResult
[13:36:35.813] result() for ClusterFuture ... done
[13:36:35.814] result() for ClusterFuture ...
[13:36:35.814] - result already collected: FutureResult
[13:36:35.814] result() for ClusterFuture ... done
[13:36:35.814] result() for ClusterFuture ...
[13:36:35.814] - result already collected: FutureResult
[13:36:35.814] result() for ClusterFuture ... done
[13:36:35.814] result() for ClusterFuture ...
[13:36:35.814] - result already collected: FutureResult
[13:36:35.814] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:36:35.818] getGlobalsAndPackages() ...
[13:36:35.818] Searching for globals...
[13:36:35.818] 
[13:36:35.818] Searching for globals ... DONE
[13:36:35.818] - globals: [0] <none>
[13:36:35.818] getGlobalsAndPackages() ... DONE
[13:36:35.819] run() for ‘Future’ ...
[13:36:35.819] - state: ‘created’
[13:36:35.819] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.834] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.834] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.834]   - Field: ‘node’
[13:36:35.835]   - Field: ‘label’
[13:36:35.835]   - Field: ‘local’
[13:36:35.835]   - Field: ‘owner’
[13:36:35.835]   - Field: ‘envir’
[13:36:35.835]   - Field: ‘workers’
[13:36:35.835]   - Field: ‘packages’
[13:36:35.835]   - Field: ‘gc’
[13:36:35.835]   - Field: ‘conditions’
[13:36:35.835]   - Field: ‘persistent’
[13:36:35.835]   - Field: ‘expr’
[13:36:35.835]   - Field: ‘uuid’
[13:36:35.836]   - Field: ‘seed’
[13:36:35.836]   - Field: ‘version’
[13:36:35.836]   - Field: ‘result’
[13:36:35.836]   - Field: ‘asynchronous’
[13:36:35.836]   - Field: ‘calls’
[13:36:35.836]   - Field: ‘globals’
[13:36:35.836]   - Field: ‘stdout’
[13:36:35.836]   - Field: ‘earlySignal’
[13:36:35.836]   - Field: ‘lazy’
[13:36:35.836]   - Field: ‘state’
[13:36:35.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.837] - Launch lazy future ...
[13:36:35.837] Packages needed by the future expression (n = 0): <none>
[13:36:35.837] Packages needed by future strategies (n = 0): <none>
[13:36:35.837] {
[13:36:35.837]     {
[13:36:35.837]         {
[13:36:35.837]             ...future.startTime <- base::Sys.time()
[13:36:35.837]             {
[13:36:35.837]                 {
[13:36:35.837]                   {
[13:36:35.837]                     {
[13:36:35.837]                       base::local({
[13:36:35.837]                         has_future <- base::requireNamespace("future", 
[13:36:35.837]                           quietly = TRUE)
[13:36:35.837]                         if (has_future) {
[13:36:35.837]                           ns <- base::getNamespace("future")
[13:36:35.837]                           version <- ns[[".package"]][["version"]]
[13:36:35.837]                           if (is.null(version)) 
[13:36:35.837]                             version <- utils::packageVersion("future")
[13:36:35.837]                         }
[13:36:35.837]                         else {
[13:36:35.837]                           version <- NULL
[13:36:35.837]                         }
[13:36:35.837]                         if (!has_future || version < "1.8.0") {
[13:36:35.837]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.837]                             "", base::R.version$version.string), 
[13:36:35.837]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.837]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.837]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.837]                               "release", "version")], collapse = " "), 
[13:36:35.837]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.837]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.837]                             info)
[13:36:35.837]                           info <- base::paste(info, collapse = "; ")
[13:36:35.837]                           if (!has_future) {
[13:36:35.837]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.837]                               info)
[13:36:35.837]                           }
[13:36:35.837]                           else {
[13:36:35.837]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.837]                               info, version)
[13:36:35.837]                           }
[13:36:35.837]                           base::stop(msg)
[13:36:35.837]                         }
[13:36:35.837]                       })
[13:36:35.837]                     }
[13:36:35.837]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.837]                     base::options(mc.cores = 1L)
[13:36:35.837]                   }
[13:36:35.837]                   ...future.strategy.old <- future::plan("list")
[13:36:35.837]                   options(future.plan = NULL)
[13:36:35.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.837]                 }
[13:36:35.837]                 ...future.workdir <- getwd()
[13:36:35.837]             }
[13:36:35.837]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.837]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.837]         }
[13:36:35.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.837]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.837]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.837]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.837]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.837]             base::names(...future.oldOptions))
[13:36:35.837]     }
[13:36:35.837]     if (FALSE) {
[13:36:35.837]     }
[13:36:35.837]     else {
[13:36:35.837]         if (TRUE) {
[13:36:35.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.837]                 open = "w")
[13:36:35.837]         }
[13:36:35.837]         else {
[13:36:35.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.837]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.837]         }
[13:36:35.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.837]             base::sink(type = "output", split = FALSE)
[13:36:35.837]             base::close(...future.stdout)
[13:36:35.837]         }, add = TRUE)
[13:36:35.837]     }
[13:36:35.837]     ...future.frame <- base::sys.nframe()
[13:36:35.837]     ...future.conditions <- base::list()
[13:36:35.837]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.837]     if (FALSE) {
[13:36:35.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.837]     }
[13:36:35.837]     ...future.result <- base::tryCatch({
[13:36:35.837]         base::withCallingHandlers({
[13:36:35.837]             ...future.value <- base::withVisible(base::local({
[13:36:35.837]                 ...future.makeSendCondition <- base::local({
[13:36:35.837]                   sendCondition <- NULL
[13:36:35.837]                   function(frame = 1L) {
[13:36:35.837]                     if (is.function(sendCondition)) 
[13:36:35.837]                       return(sendCondition)
[13:36:35.837]                     ns <- getNamespace("parallel")
[13:36:35.837]                     if (exists("sendData", mode = "function", 
[13:36:35.837]                       envir = ns)) {
[13:36:35.837]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.837]                         envir = ns)
[13:36:35.837]                       envir <- sys.frame(frame)
[13:36:35.837]                       master <- NULL
[13:36:35.837]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.837]                         !identical(envir, emptyenv())) {
[13:36:35.837]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.837]                           inherits = FALSE)) {
[13:36:35.837]                           master <- get("master", mode = "list", 
[13:36:35.837]                             envir = envir, inherits = FALSE)
[13:36:35.837]                           if (inherits(master, c("SOCKnode", 
[13:36:35.837]                             "SOCK0node"))) {
[13:36:35.837]                             sendCondition <<- function(cond) {
[13:36:35.837]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.837]                                 success = TRUE)
[13:36:35.837]                               parallel_sendData(master, data)
[13:36:35.837]                             }
[13:36:35.837]                             return(sendCondition)
[13:36:35.837]                           }
[13:36:35.837]                         }
[13:36:35.837]                         frame <- frame + 1L
[13:36:35.837]                         envir <- sys.frame(frame)
[13:36:35.837]                       }
[13:36:35.837]                     }
[13:36:35.837]                     sendCondition <<- function(cond) NULL
[13:36:35.837]                   }
[13:36:35.837]                 })
[13:36:35.837]                 withCallingHandlers({
[13:36:35.837]                   2
[13:36:35.837]                 }, immediateCondition = function(cond) {
[13:36:35.837]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.837]                   sendCondition(cond)
[13:36:35.837]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.837]                   {
[13:36:35.837]                     inherits <- base::inherits
[13:36:35.837]                     invokeRestart <- base::invokeRestart
[13:36:35.837]                     is.null <- base::is.null
[13:36:35.837]                     muffled <- FALSE
[13:36:35.837]                     if (inherits(cond, "message")) {
[13:36:35.837]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.837]                       if (muffled) 
[13:36:35.837]                         invokeRestart("muffleMessage")
[13:36:35.837]                     }
[13:36:35.837]                     else if (inherits(cond, "warning")) {
[13:36:35.837]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.837]                       if (muffled) 
[13:36:35.837]                         invokeRestart("muffleWarning")
[13:36:35.837]                     }
[13:36:35.837]                     else if (inherits(cond, "condition")) {
[13:36:35.837]                       if (!is.null(pattern)) {
[13:36:35.837]                         computeRestarts <- base::computeRestarts
[13:36:35.837]                         grepl <- base::grepl
[13:36:35.837]                         restarts <- computeRestarts(cond)
[13:36:35.837]                         for (restart in restarts) {
[13:36:35.837]                           name <- restart$name
[13:36:35.837]                           if (is.null(name)) 
[13:36:35.837]                             next
[13:36:35.837]                           if (!grepl(pattern, name)) 
[13:36:35.837]                             next
[13:36:35.837]                           invokeRestart(restart)
[13:36:35.837]                           muffled <- TRUE
[13:36:35.837]                           break
[13:36:35.837]                         }
[13:36:35.837]                       }
[13:36:35.837]                     }
[13:36:35.837]                     invisible(muffled)
[13:36:35.837]                   }
[13:36:35.837]                   muffleCondition(cond)
[13:36:35.837]                 })
[13:36:35.837]             }))
[13:36:35.837]             future::FutureResult(value = ...future.value$value, 
[13:36:35.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.837]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.837]                     ...future.globalenv.names))
[13:36:35.837]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.837]         }, condition = base::local({
[13:36:35.837]             c <- base::c
[13:36:35.837]             inherits <- base::inherits
[13:36:35.837]             invokeRestart <- base::invokeRestart
[13:36:35.837]             length <- base::length
[13:36:35.837]             list <- base::list
[13:36:35.837]             seq.int <- base::seq.int
[13:36:35.837]             signalCondition <- base::signalCondition
[13:36:35.837]             sys.calls <- base::sys.calls
[13:36:35.837]             `[[` <- base::`[[`
[13:36:35.837]             `+` <- base::`+`
[13:36:35.837]             `<<-` <- base::`<<-`
[13:36:35.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.837]                   3L)]
[13:36:35.837]             }
[13:36:35.837]             function(cond) {
[13:36:35.837]                 is_error <- inherits(cond, "error")
[13:36:35.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.837]                   NULL)
[13:36:35.837]                 if (is_error) {
[13:36:35.837]                   sessionInformation <- function() {
[13:36:35.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.837]                       search = base::search(), system = base::Sys.info())
[13:36:35.837]                   }
[13:36:35.837]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.837]                     cond$call), session = sessionInformation(), 
[13:36:35.837]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.837]                   signalCondition(cond)
[13:36:35.837]                 }
[13:36:35.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.837]                 "immediateCondition"))) {
[13:36:35.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.837]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.837]                   if (TRUE && !signal) {
[13:36:35.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.837]                     {
[13:36:35.837]                       inherits <- base::inherits
[13:36:35.837]                       invokeRestart <- base::invokeRestart
[13:36:35.837]                       is.null <- base::is.null
[13:36:35.837]                       muffled <- FALSE
[13:36:35.837]                       if (inherits(cond, "message")) {
[13:36:35.837]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.837]                         if (muffled) 
[13:36:35.837]                           invokeRestart("muffleMessage")
[13:36:35.837]                       }
[13:36:35.837]                       else if (inherits(cond, "warning")) {
[13:36:35.837]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.837]                         if (muffled) 
[13:36:35.837]                           invokeRestart("muffleWarning")
[13:36:35.837]                       }
[13:36:35.837]                       else if (inherits(cond, "condition")) {
[13:36:35.837]                         if (!is.null(pattern)) {
[13:36:35.837]                           computeRestarts <- base::computeRestarts
[13:36:35.837]                           grepl <- base::grepl
[13:36:35.837]                           restarts <- computeRestarts(cond)
[13:36:35.837]                           for (restart in restarts) {
[13:36:35.837]                             name <- restart$name
[13:36:35.837]                             if (is.null(name)) 
[13:36:35.837]                               next
[13:36:35.837]                             if (!grepl(pattern, name)) 
[13:36:35.837]                               next
[13:36:35.837]                             invokeRestart(restart)
[13:36:35.837]                             muffled <- TRUE
[13:36:35.837]                             break
[13:36:35.837]                           }
[13:36:35.837]                         }
[13:36:35.837]                       }
[13:36:35.837]                       invisible(muffled)
[13:36:35.837]                     }
[13:36:35.837]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.837]                   }
[13:36:35.837]                 }
[13:36:35.837]                 else {
[13:36:35.837]                   if (TRUE) {
[13:36:35.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.837]                     {
[13:36:35.837]                       inherits <- base::inherits
[13:36:35.837]                       invokeRestart <- base::invokeRestart
[13:36:35.837]                       is.null <- base::is.null
[13:36:35.837]                       muffled <- FALSE
[13:36:35.837]                       if (inherits(cond, "message")) {
[13:36:35.837]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.837]                         if (muffled) 
[13:36:35.837]                           invokeRestart("muffleMessage")
[13:36:35.837]                       }
[13:36:35.837]                       else if (inherits(cond, "warning")) {
[13:36:35.837]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.837]                         if (muffled) 
[13:36:35.837]                           invokeRestart("muffleWarning")
[13:36:35.837]                       }
[13:36:35.837]                       else if (inherits(cond, "condition")) {
[13:36:35.837]                         if (!is.null(pattern)) {
[13:36:35.837]                           computeRestarts <- base::computeRestarts
[13:36:35.837]                           grepl <- base::grepl
[13:36:35.837]                           restarts <- computeRestarts(cond)
[13:36:35.837]                           for (restart in restarts) {
[13:36:35.837]                             name <- restart$name
[13:36:35.837]                             if (is.null(name)) 
[13:36:35.837]                               next
[13:36:35.837]                             if (!grepl(pattern, name)) 
[13:36:35.837]                               next
[13:36:35.837]                             invokeRestart(restart)
[13:36:35.837]                             muffled <- TRUE
[13:36:35.837]                             break
[13:36:35.837]                           }
[13:36:35.837]                         }
[13:36:35.837]                       }
[13:36:35.837]                       invisible(muffled)
[13:36:35.837]                     }
[13:36:35.837]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.837]                   }
[13:36:35.837]                 }
[13:36:35.837]             }
[13:36:35.837]         }))
[13:36:35.837]     }, error = function(ex) {
[13:36:35.837]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.837]                 ...future.rng), started = ...future.startTime, 
[13:36:35.837]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.837]             version = "1.8"), class = "FutureResult")
[13:36:35.837]     }, finally = {
[13:36:35.837]         if (!identical(...future.workdir, getwd())) 
[13:36:35.837]             setwd(...future.workdir)
[13:36:35.837]         {
[13:36:35.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.837]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.837]             }
[13:36:35.837]             base::options(...future.oldOptions)
[13:36:35.837]             if (.Platform$OS.type == "windows") {
[13:36:35.837]                 old_names <- names(...future.oldEnvVars)
[13:36:35.837]                 envs <- base::Sys.getenv()
[13:36:35.837]                 names <- names(envs)
[13:36:35.837]                 common <- intersect(names, old_names)
[13:36:35.837]                 added <- setdiff(names, old_names)
[13:36:35.837]                 removed <- setdiff(old_names, names)
[13:36:35.837]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.837]                   envs[common]]
[13:36:35.837]                 NAMES <- toupper(changed)
[13:36:35.837]                 args <- list()
[13:36:35.837]                 for (kk in seq_along(NAMES)) {
[13:36:35.837]                   name <- changed[[kk]]
[13:36:35.837]                   NAME <- NAMES[[kk]]
[13:36:35.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.837]                     next
[13:36:35.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.837]                 }
[13:36:35.837]                 NAMES <- toupper(added)
[13:36:35.837]                 for (kk in seq_along(NAMES)) {
[13:36:35.837]                   name <- added[[kk]]
[13:36:35.837]                   NAME <- NAMES[[kk]]
[13:36:35.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.837]                     next
[13:36:35.837]                   args[[name]] <- ""
[13:36:35.837]                 }
[13:36:35.837]                 NAMES <- toupper(removed)
[13:36:35.837]                 for (kk in seq_along(NAMES)) {
[13:36:35.837]                   name <- removed[[kk]]
[13:36:35.837]                   NAME <- NAMES[[kk]]
[13:36:35.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.837]                     next
[13:36:35.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.837]                 }
[13:36:35.837]                 if (length(args) > 0) 
[13:36:35.837]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.837]             }
[13:36:35.837]             else {
[13:36:35.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.837]             }
[13:36:35.837]             {
[13:36:35.837]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.837]                   0L) {
[13:36:35.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.837]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.837]                   base::options(opts)
[13:36:35.837]                 }
[13:36:35.837]                 {
[13:36:35.837]                   {
[13:36:35.837]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.837]                     NULL
[13:36:35.837]                   }
[13:36:35.837]                   options(future.plan = NULL)
[13:36:35.837]                   if (is.na(NA_character_)) 
[13:36:35.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.837]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.837]                     .init = FALSE)
[13:36:35.837]                 }
[13:36:35.837]             }
[13:36:35.837]         }
[13:36:35.837]     })
[13:36:35.837]     if (TRUE) {
[13:36:35.837]         base::sink(type = "output", split = FALSE)
[13:36:35.837]         if (TRUE) {
[13:36:35.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.837]         }
[13:36:35.837]         else {
[13:36:35.837]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.837]         }
[13:36:35.837]         base::close(...future.stdout)
[13:36:35.837]         ...future.stdout <- NULL
[13:36:35.837]     }
[13:36:35.837]     ...future.result$conditions <- ...future.conditions
[13:36:35.837]     ...future.result$finished <- base::Sys.time()
[13:36:35.837]     ...future.result
[13:36:35.837] }
[13:36:35.840] MultisessionFuture started
[13:36:35.840] - Launch lazy future ... done
[13:36:35.840] run() for ‘MultisessionFuture’ ... done
[13:36:35.840] getGlobalsAndPackages() ...
[13:36:35.840] Searching for globals...
[13:36:35.841] 
[13:36:35.841] Searching for globals ... DONE
[13:36:35.841] - globals: [0] <none>
[13:36:35.841] getGlobalsAndPackages() ... DONE
[13:36:35.841] run() for ‘Future’ ...
[13:36:35.841] - state: ‘created’
[13:36:35.841] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.855] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:35.856]   - Field: ‘node’
[13:36:35.856]   - Field: ‘label’
[13:36:35.856]   - Field: ‘local’
[13:36:35.856]   - Field: ‘owner’
[13:36:35.856]   - Field: ‘envir’
[13:36:35.856]   - Field: ‘workers’
[13:36:35.856]   - Field: ‘packages’
[13:36:35.856]   - Field: ‘gc’
[13:36:35.856]   - Field: ‘conditions’
[13:36:35.856]   - Field: ‘persistent’
[13:36:35.856]   - Field: ‘expr’
[13:36:35.857]   - Field: ‘uuid’
[13:36:35.857]   - Field: ‘seed’
[13:36:35.857]   - Field: ‘version’
[13:36:35.857]   - Field: ‘result’
[13:36:35.857]   - Field: ‘asynchronous’
[13:36:35.857]   - Field: ‘calls’
[13:36:35.857]   - Field: ‘globals’
[13:36:35.857]   - Field: ‘stdout’
[13:36:35.857]   - Field: ‘earlySignal’
[13:36:35.857]   - Field: ‘lazy’
[13:36:35.857]   - Field: ‘state’
[13:36:35.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:35.858] - Launch lazy future ...
[13:36:35.858] Packages needed by the future expression (n = 0): <none>
[13:36:35.858] Packages needed by future strategies (n = 0): <none>
[13:36:35.858] {
[13:36:35.858]     {
[13:36:35.858]         {
[13:36:35.858]             ...future.startTime <- base::Sys.time()
[13:36:35.858]             {
[13:36:35.858]                 {
[13:36:35.858]                   {
[13:36:35.858]                     {
[13:36:35.858]                       base::local({
[13:36:35.858]                         has_future <- base::requireNamespace("future", 
[13:36:35.858]                           quietly = TRUE)
[13:36:35.858]                         if (has_future) {
[13:36:35.858]                           ns <- base::getNamespace("future")
[13:36:35.858]                           version <- ns[[".package"]][["version"]]
[13:36:35.858]                           if (is.null(version)) 
[13:36:35.858]                             version <- utils::packageVersion("future")
[13:36:35.858]                         }
[13:36:35.858]                         else {
[13:36:35.858]                           version <- NULL
[13:36:35.858]                         }
[13:36:35.858]                         if (!has_future || version < "1.8.0") {
[13:36:35.858]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.858]                             "", base::R.version$version.string), 
[13:36:35.858]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.858]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.858]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.858]                               "release", "version")], collapse = " "), 
[13:36:35.858]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.858]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.858]                             info)
[13:36:35.858]                           info <- base::paste(info, collapse = "; ")
[13:36:35.858]                           if (!has_future) {
[13:36:35.858]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.858]                               info)
[13:36:35.858]                           }
[13:36:35.858]                           else {
[13:36:35.858]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.858]                               info, version)
[13:36:35.858]                           }
[13:36:35.858]                           base::stop(msg)
[13:36:35.858]                         }
[13:36:35.858]                       })
[13:36:35.858]                     }
[13:36:35.858]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.858]                     base::options(mc.cores = 1L)
[13:36:35.858]                   }
[13:36:35.858]                   ...future.strategy.old <- future::plan("list")
[13:36:35.858]                   options(future.plan = NULL)
[13:36:35.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.858]                 }
[13:36:35.858]                 ...future.workdir <- getwd()
[13:36:35.858]             }
[13:36:35.858]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.858]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.858]         }
[13:36:35.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.858]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.858]             base::names(...future.oldOptions))
[13:36:35.858]     }
[13:36:35.858]     if (FALSE) {
[13:36:35.858]     }
[13:36:35.858]     else {
[13:36:35.858]         if (TRUE) {
[13:36:35.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.858]                 open = "w")
[13:36:35.858]         }
[13:36:35.858]         else {
[13:36:35.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.858]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.858]         }
[13:36:35.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.858]             base::sink(type = "output", split = FALSE)
[13:36:35.858]             base::close(...future.stdout)
[13:36:35.858]         }, add = TRUE)
[13:36:35.858]     }
[13:36:35.858]     ...future.frame <- base::sys.nframe()
[13:36:35.858]     ...future.conditions <- base::list()
[13:36:35.858]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.858]     if (FALSE) {
[13:36:35.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.858]     }
[13:36:35.858]     ...future.result <- base::tryCatch({
[13:36:35.858]         base::withCallingHandlers({
[13:36:35.858]             ...future.value <- base::withVisible(base::local({
[13:36:35.858]                 ...future.makeSendCondition <- base::local({
[13:36:35.858]                   sendCondition <- NULL
[13:36:35.858]                   function(frame = 1L) {
[13:36:35.858]                     if (is.function(sendCondition)) 
[13:36:35.858]                       return(sendCondition)
[13:36:35.858]                     ns <- getNamespace("parallel")
[13:36:35.858]                     if (exists("sendData", mode = "function", 
[13:36:35.858]                       envir = ns)) {
[13:36:35.858]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:35.858]                         envir = ns)
[13:36:35.858]                       envir <- sys.frame(frame)
[13:36:35.858]                       master <- NULL
[13:36:35.858]                       while (!identical(envir, .GlobalEnv) && 
[13:36:35.858]                         !identical(envir, emptyenv())) {
[13:36:35.858]                         if (exists("master", mode = "list", envir = envir, 
[13:36:35.858]                           inherits = FALSE)) {
[13:36:35.858]                           master <- get("master", mode = "list", 
[13:36:35.858]                             envir = envir, inherits = FALSE)
[13:36:35.858]                           if (inherits(master, c("SOCKnode", 
[13:36:35.858]                             "SOCK0node"))) {
[13:36:35.858]                             sendCondition <<- function(cond) {
[13:36:35.858]                               data <- list(type = "VALUE", value = cond, 
[13:36:35.858]                                 success = TRUE)
[13:36:35.858]                               parallel_sendData(master, data)
[13:36:35.858]                             }
[13:36:35.858]                             return(sendCondition)
[13:36:35.858]                           }
[13:36:35.858]                         }
[13:36:35.858]                         frame <- frame + 1L
[13:36:35.858]                         envir <- sys.frame(frame)
[13:36:35.858]                       }
[13:36:35.858]                     }
[13:36:35.858]                     sendCondition <<- function(cond) NULL
[13:36:35.858]                   }
[13:36:35.858]                 })
[13:36:35.858]                 withCallingHandlers({
[13:36:35.858]                   NULL
[13:36:35.858]                 }, immediateCondition = function(cond) {
[13:36:35.858]                   sendCondition <- ...future.makeSendCondition()
[13:36:35.858]                   sendCondition(cond)
[13:36:35.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.858]                   {
[13:36:35.858]                     inherits <- base::inherits
[13:36:35.858]                     invokeRestart <- base::invokeRestart
[13:36:35.858]                     is.null <- base::is.null
[13:36:35.858]                     muffled <- FALSE
[13:36:35.858]                     if (inherits(cond, "message")) {
[13:36:35.858]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.858]                       if (muffled) 
[13:36:35.858]                         invokeRestart("muffleMessage")
[13:36:35.858]                     }
[13:36:35.858]                     else if (inherits(cond, "warning")) {
[13:36:35.858]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.858]                       if (muffled) 
[13:36:35.858]                         invokeRestart("muffleWarning")
[13:36:35.858]                     }
[13:36:35.858]                     else if (inherits(cond, "condition")) {
[13:36:35.858]                       if (!is.null(pattern)) {
[13:36:35.858]                         computeRestarts <- base::computeRestarts
[13:36:35.858]                         grepl <- base::grepl
[13:36:35.858]                         restarts <- computeRestarts(cond)
[13:36:35.858]                         for (restart in restarts) {
[13:36:35.858]                           name <- restart$name
[13:36:35.858]                           if (is.null(name)) 
[13:36:35.858]                             next
[13:36:35.858]                           if (!grepl(pattern, name)) 
[13:36:35.858]                             next
[13:36:35.858]                           invokeRestart(restart)
[13:36:35.858]                           muffled <- TRUE
[13:36:35.858]                           break
[13:36:35.858]                         }
[13:36:35.858]                       }
[13:36:35.858]                     }
[13:36:35.858]                     invisible(muffled)
[13:36:35.858]                   }
[13:36:35.858]                   muffleCondition(cond)
[13:36:35.858]                 })
[13:36:35.858]             }))
[13:36:35.858]             future::FutureResult(value = ...future.value$value, 
[13:36:35.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.858]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.858]                     ...future.globalenv.names))
[13:36:35.858]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.858]         }, condition = base::local({
[13:36:35.858]             c <- base::c
[13:36:35.858]             inherits <- base::inherits
[13:36:35.858]             invokeRestart <- base::invokeRestart
[13:36:35.858]             length <- base::length
[13:36:35.858]             list <- base::list
[13:36:35.858]             seq.int <- base::seq.int
[13:36:35.858]             signalCondition <- base::signalCondition
[13:36:35.858]             sys.calls <- base::sys.calls
[13:36:35.858]             `[[` <- base::`[[`
[13:36:35.858]             `+` <- base::`+`
[13:36:35.858]             `<<-` <- base::`<<-`
[13:36:35.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.858]                   3L)]
[13:36:35.858]             }
[13:36:35.858]             function(cond) {
[13:36:35.858]                 is_error <- inherits(cond, "error")
[13:36:35.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.858]                   NULL)
[13:36:35.858]                 if (is_error) {
[13:36:35.858]                   sessionInformation <- function() {
[13:36:35.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.858]                       search = base::search(), system = base::Sys.info())
[13:36:35.858]                   }
[13:36:35.858]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.858]                     cond$call), session = sessionInformation(), 
[13:36:35.858]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.858]                   signalCondition(cond)
[13:36:35.858]                 }
[13:36:35.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.858]                 "immediateCondition"))) {
[13:36:35.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.858]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.858]                   if (TRUE && !signal) {
[13:36:35.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.858]                     {
[13:36:35.858]                       inherits <- base::inherits
[13:36:35.858]                       invokeRestart <- base::invokeRestart
[13:36:35.858]                       is.null <- base::is.null
[13:36:35.858]                       muffled <- FALSE
[13:36:35.858]                       if (inherits(cond, "message")) {
[13:36:35.858]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.858]                         if (muffled) 
[13:36:35.858]                           invokeRestart("muffleMessage")
[13:36:35.858]                       }
[13:36:35.858]                       else if (inherits(cond, "warning")) {
[13:36:35.858]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.858]                         if (muffled) 
[13:36:35.858]                           invokeRestart("muffleWarning")
[13:36:35.858]                       }
[13:36:35.858]                       else if (inherits(cond, "condition")) {
[13:36:35.858]                         if (!is.null(pattern)) {
[13:36:35.858]                           computeRestarts <- base::computeRestarts
[13:36:35.858]                           grepl <- base::grepl
[13:36:35.858]                           restarts <- computeRestarts(cond)
[13:36:35.858]                           for (restart in restarts) {
[13:36:35.858]                             name <- restart$name
[13:36:35.858]                             if (is.null(name)) 
[13:36:35.858]                               next
[13:36:35.858]                             if (!grepl(pattern, name)) 
[13:36:35.858]                               next
[13:36:35.858]                             invokeRestart(restart)
[13:36:35.858]                             muffled <- TRUE
[13:36:35.858]                             break
[13:36:35.858]                           }
[13:36:35.858]                         }
[13:36:35.858]                       }
[13:36:35.858]                       invisible(muffled)
[13:36:35.858]                     }
[13:36:35.858]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.858]                   }
[13:36:35.858]                 }
[13:36:35.858]                 else {
[13:36:35.858]                   if (TRUE) {
[13:36:35.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.858]                     {
[13:36:35.858]                       inherits <- base::inherits
[13:36:35.858]                       invokeRestart <- base::invokeRestart
[13:36:35.858]                       is.null <- base::is.null
[13:36:35.858]                       muffled <- FALSE
[13:36:35.858]                       if (inherits(cond, "message")) {
[13:36:35.858]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.858]                         if (muffled) 
[13:36:35.858]                           invokeRestart("muffleMessage")
[13:36:35.858]                       }
[13:36:35.858]                       else if (inherits(cond, "warning")) {
[13:36:35.858]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.858]                         if (muffled) 
[13:36:35.858]                           invokeRestart("muffleWarning")
[13:36:35.858]                       }
[13:36:35.858]                       else if (inherits(cond, "condition")) {
[13:36:35.858]                         if (!is.null(pattern)) {
[13:36:35.858]                           computeRestarts <- base::computeRestarts
[13:36:35.858]                           grepl <- base::grepl
[13:36:35.858]                           restarts <- computeRestarts(cond)
[13:36:35.858]                           for (restart in restarts) {
[13:36:35.858]                             name <- restart$name
[13:36:35.858]                             if (is.null(name)) 
[13:36:35.858]                               next
[13:36:35.858]                             if (!grepl(pattern, name)) 
[13:36:35.858]                               next
[13:36:35.858]                             invokeRestart(restart)
[13:36:35.858]                             muffled <- TRUE
[13:36:35.858]                             break
[13:36:35.858]                           }
[13:36:35.858]                         }
[13:36:35.858]                       }
[13:36:35.858]                       invisible(muffled)
[13:36:35.858]                     }
[13:36:35.858]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.858]                   }
[13:36:35.858]                 }
[13:36:35.858]             }
[13:36:35.858]         }))
[13:36:35.858]     }, error = function(ex) {
[13:36:35.858]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.858]                 ...future.rng), started = ...future.startTime, 
[13:36:35.858]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.858]             version = "1.8"), class = "FutureResult")
[13:36:35.858]     }, finally = {
[13:36:35.858]         if (!identical(...future.workdir, getwd())) 
[13:36:35.858]             setwd(...future.workdir)
[13:36:35.858]         {
[13:36:35.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.858]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.858]             }
[13:36:35.858]             base::options(...future.oldOptions)
[13:36:35.858]             if (.Platform$OS.type == "windows") {
[13:36:35.858]                 old_names <- names(...future.oldEnvVars)
[13:36:35.858]                 envs <- base::Sys.getenv()
[13:36:35.858]                 names <- names(envs)
[13:36:35.858]                 common <- intersect(names, old_names)
[13:36:35.858]                 added <- setdiff(names, old_names)
[13:36:35.858]                 removed <- setdiff(old_names, names)
[13:36:35.858]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.858]                   envs[common]]
[13:36:35.858]                 NAMES <- toupper(changed)
[13:36:35.858]                 args <- list()
[13:36:35.858]                 for (kk in seq_along(NAMES)) {
[13:36:35.858]                   name <- changed[[kk]]
[13:36:35.858]                   NAME <- NAMES[[kk]]
[13:36:35.858]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.858]                     next
[13:36:35.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.858]                 }
[13:36:35.858]                 NAMES <- toupper(added)
[13:36:35.858]                 for (kk in seq_along(NAMES)) {
[13:36:35.858]                   name <- added[[kk]]
[13:36:35.858]                   NAME <- NAMES[[kk]]
[13:36:35.858]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.858]                     next
[13:36:35.858]                   args[[name]] <- ""
[13:36:35.858]                 }
[13:36:35.858]                 NAMES <- toupper(removed)
[13:36:35.858]                 for (kk in seq_along(NAMES)) {
[13:36:35.858]                   name <- removed[[kk]]
[13:36:35.858]                   NAME <- NAMES[[kk]]
[13:36:35.858]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.858]                     next
[13:36:35.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.858]                 }
[13:36:35.858]                 if (length(args) > 0) 
[13:36:35.858]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.858]             }
[13:36:35.858]             else {
[13:36:35.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.858]             }
[13:36:35.858]             {
[13:36:35.858]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.858]                   0L) {
[13:36:35.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.858]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.858]                   base::options(opts)
[13:36:35.858]                 }
[13:36:35.858]                 {
[13:36:35.858]                   {
[13:36:35.858]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.858]                     NULL
[13:36:35.858]                   }
[13:36:35.858]                   options(future.plan = NULL)
[13:36:35.858]                   if (is.na(NA_character_)) 
[13:36:35.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.858]                     .init = FALSE)
[13:36:35.858]                 }
[13:36:35.858]             }
[13:36:35.858]         }
[13:36:35.858]     })
[13:36:35.858]     if (TRUE) {
[13:36:35.858]         base::sink(type = "output", split = FALSE)
[13:36:35.858]         if (TRUE) {
[13:36:35.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.858]         }
[13:36:35.858]         else {
[13:36:35.858]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.858]         }
[13:36:35.858]         base::close(...future.stdout)
[13:36:35.858]         ...future.stdout <- NULL
[13:36:35.858]     }
[13:36:35.858]     ...future.result$conditions <- ...future.conditions
[13:36:35.858]     ...future.result$finished <- base::Sys.time()
[13:36:35.858]     ...future.result
[13:36:35.858] }
[13:36:35.861] MultisessionFuture started
[13:36:35.861] - Launch lazy future ... done
[13:36:35.861] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a7522b260> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a735b0e20> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a7522b260> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x564a735b0e20> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:35.867] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.867] - Validating connection of MultisessionFuture
[13:36:35.867] - received message: FutureResult
[13:36:35.867] - Received FutureResult
[13:36:35.867] - Erased future from FutureRegistry
[13:36:35.868] result() for ClusterFuture ...
[13:36:35.868] - result already collected: FutureResult
[13:36:35.868] result() for ClusterFuture ... done
[13:36:35.868] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:35.868] receiveMessageFromWorker() for ClusterFuture ...
[13:36:35.868] - Validating connection of MultisessionFuture
[13:36:35.868] - received message: FutureResult
[13:36:35.869] - Received FutureResult
[13:36:35.869] - Erased future from FutureRegistry
[13:36:35.869] result() for ClusterFuture ...
[13:36:35.869] - result already collected: FutureResult
[13:36:35.869] result() for ClusterFuture ... done
[13:36:35.869] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:36:35.871] resolve() on list ...
[13:36:35.871]  recursive: 0
[13:36:35.871]  length: 6
[13:36:35.871]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:36:35.872] signalConditionsASAP(numeric, pos=1) ...
[13:36:35.872] - nx: 6
[13:36:35.872] - relay: TRUE
[13:36:35.872] - stdout: TRUE
[13:36:35.872] - signal: TRUE
[13:36:35.872] - resignal: FALSE
[13:36:35.872] - force: TRUE
[13:36:35.872] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.872] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.872]  - until=2
[13:36:35.872]  - relaying element #2
[13:36:35.873] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.873] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.873] signalConditionsASAP(NULL, pos=1) ... done
[13:36:35.873]  length: 5 (resolved future 1)
[13:36:35.873] Future #2
[13:36:35.873] result() for ClusterFuture ...
[13:36:35.873] - result already collected: FutureResult
[13:36:35.873] result() for ClusterFuture ... done
[13:36:35.873] result() for ClusterFuture ...
[13:36:35.873] - result already collected: FutureResult
[13:36:35.873] result() for ClusterFuture ... done
[13:36:35.874] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:35.874] - nx: 6
[13:36:35.874] - relay: TRUE
[13:36:35.874] - stdout: TRUE
[13:36:35.874] - signal: TRUE
[13:36:35.874] - resignal: FALSE
[13:36:35.874] - force: TRUE
[13:36:35.874] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.874] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:35.874]  - until=2
[13:36:35.874]  - relaying element #2
[13:36:35.875] result() for ClusterFuture ...
[13:36:35.875] - result already collected: FutureResult
[13:36:35.875] result() for ClusterFuture ... done
[13:36:35.875] result() for ClusterFuture ...
[13:36:35.875] - result already collected: FutureResult
[13:36:35.875] result() for ClusterFuture ... done
[13:36:35.875] result() for ClusterFuture ...
[13:36:35.875] - result already collected: FutureResult
[13:36:35.875] result() for ClusterFuture ... done
[13:36:35.875] result() for ClusterFuture ...
[13:36:35.875] - result already collected: FutureResult
[13:36:35.875] result() for ClusterFuture ... done
[13:36:35.876] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.876] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.876] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:35.876]  length: 4 (resolved future 2)
[13:36:35.876] Future #3
[13:36:35.876] result() for ClusterFuture ...
[13:36:35.876] - result already collected: FutureResult
[13:36:35.876] result() for ClusterFuture ... done
[13:36:35.876] result() for ClusterFuture ...
[13:36:35.876] - result already collected: FutureResult
[13:36:35.876] result() for ClusterFuture ... done
[13:36:35.877] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:35.877] - nx: 6
[13:36:35.877] - relay: TRUE
[13:36:35.877] - stdout: TRUE
[13:36:35.877] - signal: TRUE
[13:36:35.877] - resignal: FALSE
[13:36:35.877] - force: TRUE
[13:36:35.877] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.877] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:35.877]  - until=3
[13:36:35.877]  - relaying element #3
[13:36:35.878] result() for ClusterFuture ...
[13:36:35.878] - result already collected: FutureResult
[13:36:35.878] result() for ClusterFuture ... done
[13:36:35.878] result() for ClusterFuture ...
[13:36:35.878] - result already collected: FutureResult
[13:36:35.878] result() for ClusterFuture ... done
[13:36:35.878] result() for ClusterFuture ...
[13:36:35.878] - result already collected: FutureResult
[13:36:35.878] result() for ClusterFuture ... done
[13:36:35.878] result() for ClusterFuture ...
[13:36:35.878] - result already collected: FutureResult
[13:36:35.879] result() for ClusterFuture ... done
[13:36:35.879] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.879] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.879] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:35.879]  length: 3 (resolved future 3)
[13:36:35.879] signalConditionsASAP(NULL, pos=4) ...
[13:36:35.879] - nx: 6
[13:36:35.879] - relay: TRUE
[13:36:35.879] - stdout: TRUE
[13:36:35.879] - signal: TRUE
[13:36:35.879] - resignal: FALSE
[13:36:35.879] - force: TRUE
[13:36:35.880] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.880] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.880]  - until=5
[13:36:35.880]  - relaying element #5
[13:36:35.880] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.880] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.880] signalConditionsASAP(NULL, pos=4) ... done
[13:36:35.880]  length: 2 (resolved future 4)
[13:36:35.880] signalConditionsASAP(NULL, pos=5) ...
[13:36:35.880] - nx: 6
[13:36:35.880] - relay: TRUE
[13:36:35.880] - stdout: TRUE
[13:36:35.881] - signal: TRUE
[13:36:35.881] - resignal: FALSE
[13:36:35.881] - force: TRUE
[13:36:35.881] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:35.881] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.881]  - until=6
[13:36:35.881]  - relaying element #6
[13:36:35.881] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.881] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.881] signalConditionsASAP(NULL, pos=5) ... done
[13:36:35.881]  length: 1 (resolved future 5)
[13:36:35.881] signalConditionsASAP(numeric, pos=6) ...
[13:36:35.882] - nx: 6
[13:36:35.882] - relay: TRUE
[13:36:35.882] - stdout: TRUE
[13:36:35.882] - signal: TRUE
[13:36:35.882] - resignal: FALSE
[13:36:35.882] - force: TRUE
[13:36:35.882] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:35.882] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.882]  - until=6
[13:36:35.882] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.882] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.883] signalConditionsASAP(numeric, pos=6) ... done
[13:36:35.883]  length: 0 (resolved future 6)
[13:36:35.883] Relaying remaining futures
[13:36:35.883] signalConditionsASAP(NULL, pos=0) ...
[13:36:35.883] - nx: 6
[13:36:35.883] - relay: TRUE
[13:36:35.883] - stdout: TRUE
[13:36:35.883] - signal: TRUE
[13:36:35.883] - resignal: FALSE
[13:36:35.883] - force: TRUE
[13:36:35.883] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.883] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:36:35.884] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:35.884] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:35.884] signalConditionsASAP(NULL, pos=0) ... done
[13:36:35.884] resolve() on list ... DONE
[13:36:35.884] result() for ClusterFuture ...
[13:36:35.884] - result already collected: FutureResult
[13:36:35.884] result() for ClusterFuture ... done
[13:36:35.884] result() for ClusterFuture ...
[13:36:35.884] - result already collected: FutureResult
[13:36:35.884] result() for ClusterFuture ... done
[13:36:35.884] result() for ClusterFuture ...
[13:36:35.885] - result already collected: FutureResult
[13:36:35.885] result() for ClusterFuture ... done
[13:36:35.885] result() for ClusterFuture ...
[13:36:35.885] - result already collected: FutureResult
[13:36:35.885] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[13:36:35.889] plan(): Setting new future strategy stack:
[13:36:35.889] List of future strategies:
[13:36:35.889] 1. multicore:
[13:36:35.889]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:35.889]    - tweaked: FALSE
[13:36:35.889]    - call: plan(strategy)
[13:36:35.893] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:36:35.894] getGlobalsAndPackages() ...
[13:36:35.894] Searching for globals...
[13:36:35.894] 
[13:36:35.894] Searching for globals ... DONE
[13:36:35.895] - globals: [0] <none>
[13:36:35.895] getGlobalsAndPackages() ... DONE
[13:36:35.895] run() for ‘Future’ ...
[13:36:35.895] - state: ‘created’
[13:36:35.895] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.899] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:35.899]   - Field: ‘label’
[13:36:35.899]   - Field: ‘local’
[13:36:35.899]   - Field: ‘owner’
[13:36:35.899]   - Field: ‘envir’
[13:36:35.899]   - Field: ‘workers’
[13:36:35.899]   - Field: ‘packages’
[13:36:35.900]   - Field: ‘gc’
[13:36:35.900]   - Field: ‘job’
[13:36:35.900]   - Field: ‘conditions’
[13:36:35.900]   - Field: ‘expr’
[13:36:35.900]   - Field: ‘uuid’
[13:36:35.900]   - Field: ‘seed’
[13:36:35.900]   - Field: ‘version’
[13:36:35.900]   - Field: ‘result’
[13:36:35.900]   - Field: ‘asynchronous’
[13:36:35.900]   - Field: ‘calls’
[13:36:35.900]   - Field: ‘globals’
[13:36:35.901]   - Field: ‘stdout’
[13:36:35.901]   - Field: ‘earlySignal’
[13:36:35.901]   - Field: ‘lazy’
[13:36:35.901]   - Field: ‘state’
[13:36:35.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:35.901] - Launch lazy future ...
[13:36:35.901] Packages needed by the future expression (n = 0): <none>
[13:36:35.901] Packages needed by future strategies (n = 0): <none>
[13:36:35.902] {
[13:36:35.902]     {
[13:36:35.902]         {
[13:36:35.902]             ...future.startTime <- base::Sys.time()
[13:36:35.902]             {
[13:36:35.902]                 {
[13:36:35.902]                   {
[13:36:35.902]                     {
[13:36:35.902]                       base::local({
[13:36:35.902]                         has_future <- base::requireNamespace("future", 
[13:36:35.902]                           quietly = TRUE)
[13:36:35.902]                         if (has_future) {
[13:36:35.902]                           ns <- base::getNamespace("future")
[13:36:35.902]                           version <- ns[[".package"]][["version"]]
[13:36:35.902]                           if (is.null(version)) 
[13:36:35.902]                             version <- utils::packageVersion("future")
[13:36:35.902]                         }
[13:36:35.902]                         else {
[13:36:35.902]                           version <- NULL
[13:36:35.902]                         }
[13:36:35.902]                         if (!has_future || version < "1.8.0") {
[13:36:35.902]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.902]                             "", base::R.version$version.string), 
[13:36:35.902]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.902]                               "release", "version")], collapse = " "), 
[13:36:35.902]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.902]                             info)
[13:36:35.902]                           info <- base::paste(info, collapse = "; ")
[13:36:35.902]                           if (!has_future) {
[13:36:35.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.902]                               info)
[13:36:35.902]                           }
[13:36:35.902]                           else {
[13:36:35.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.902]                               info, version)
[13:36:35.902]                           }
[13:36:35.902]                           base::stop(msg)
[13:36:35.902]                         }
[13:36:35.902]                       })
[13:36:35.902]                     }
[13:36:35.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.902]                     base::options(mc.cores = 1L)
[13:36:35.902]                   }
[13:36:35.902]                   ...future.strategy.old <- future::plan("list")
[13:36:35.902]                   options(future.plan = NULL)
[13:36:35.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.902]                 }
[13:36:35.902]                 ...future.workdir <- getwd()
[13:36:35.902]             }
[13:36:35.902]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.902]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.902]         }
[13:36:35.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.902]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.902]             base::names(...future.oldOptions))
[13:36:35.902]     }
[13:36:35.902]     if (FALSE) {
[13:36:35.902]     }
[13:36:35.902]     else {
[13:36:35.902]         if (TRUE) {
[13:36:35.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.902]                 open = "w")
[13:36:35.902]         }
[13:36:35.902]         else {
[13:36:35.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.902]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.902]         }
[13:36:35.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.902]             base::sink(type = "output", split = FALSE)
[13:36:35.902]             base::close(...future.stdout)
[13:36:35.902]         }, add = TRUE)
[13:36:35.902]     }
[13:36:35.902]     ...future.frame <- base::sys.nframe()
[13:36:35.902]     ...future.conditions <- base::list()
[13:36:35.902]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.902]     if (FALSE) {
[13:36:35.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.902]     }
[13:36:35.902]     ...future.result <- base::tryCatch({
[13:36:35.902]         base::withCallingHandlers({
[13:36:35.902]             ...future.value <- base::withVisible(base::local({
[13:36:35.902]                 withCallingHandlers({
[13:36:35.902]                   2
[13:36:35.902]                 }, immediateCondition = function(cond) {
[13:36:35.902]                   save_rds <- function (object, pathname, ...) 
[13:36:35.902]                   {
[13:36:35.902]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:35.902]                     if (file_test("-f", pathname_tmp)) {
[13:36:35.902]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.902]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:35.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.902]                         fi_tmp[["mtime"]])
[13:36:35.902]                     }
[13:36:35.902]                     tryCatch({
[13:36:35.902]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:35.902]                     }, error = function(ex) {
[13:36:35.902]                       msg <- conditionMessage(ex)
[13:36:35.902]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.902]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:35.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.902]                         fi_tmp[["mtime"]], msg)
[13:36:35.902]                       ex$message <- msg
[13:36:35.902]                       stop(ex)
[13:36:35.902]                     })
[13:36:35.902]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:35.902]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:35.902]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:35.902]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.902]                       fi <- file.info(pathname)
[13:36:35.902]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:35.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.902]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:35.902]                         fi[["size"]], fi[["mtime"]])
[13:36:35.902]                       stop(msg)
[13:36:35.902]                     }
[13:36:35.902]                     invisible(pathname)
[13:36:35.902]                   }
[13:36:35.902]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:35.902]                     rootPath = tempdir()) 
[13:36:35.902]                   {
[13:36:35.902]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:35.902]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:35.902]                       tmpdir = path, fileext = ".rds")
[13:36:35.902]                     save_rds(obj, file)
[13:36:35.902]                   }
[13:36:35.902]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:35.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.902]                   {
[13:36:35.902]                     inherits <- base::inherits
[13:36:35.902]                     invokeRestart <- base::invokeRestart
[13:36:35.902]                     is.null <- base::is.null
[13:36:35.902]                     muffled <- FALSE
[13:36:35.902]                     if (inherits(cond, "message")) {
[13:36:35.902]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.902]                       if (muffled) 
[13:36:35.902]                         invokeRestart("muffleMessage")
[13:36:35.902]                     }
[13:36:35.902]                     else if (inherits(cond, "warning")) {
[13:36:35.902]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.902]                       if (muffled) 
[13:36:35.902]                         invokeRestart("muffleWarning")
[13:36:35.902]                     }
[13:36:35.902]                     else if (inherits(cond, "condition")) {
[13:36:35.902]                       if (!is.null(pattern)) {
[13:36:35.902]                         computeRestarts <- base::computeRestarts
[13:36:35.902]                         grepl <- base::grepl
[13:36:35.902]                         restarts <- computeRestarts(cond)
[13:36:35.902]                         for (restart in restarts) {
[13:36:35.902]                           name <- restart$name
[13:36:35.902]                           if (is.null(name)) 
[13:36:35.902]                             next
[13:36:35.902]                           if (!grepl(pattern, name)) 
[13:36:35.902]                             next
[13:36:35.902]                           invokeRestart(restart)
[13:36:35.902]                           muffled <- TRUE
[13:36:35.902]                           break
[13:36:35.902]                         }
[13:36:35.902]                       }
[13:36:35.902]                     }
[13:36:35.902]                     invisible(muffled)
[13:36:35.902]                   }
[13:36:35.902]                   muffleCondition(cond)
[13:36:35.902]                 })
[13:36:35.902]             }))
[13:36:35.902]             future::FutureResult(value = ...future.value$value, 
[13:36:35.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.902]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.902]                     ...future.globalenv.names))
[13:36:35.902]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.902]         }, condition = base::local({
[13:36:35.902]             c <- base::c
[13:36:35.902]             inherits <- base::inherits
[13:36:35.902]             invokeRestart <- base::invokeRestart
[13:36:35.902]             length <- base::length
[13:36:35.902]             list <- base::list
[13:36:35.902]             seq.int <- base::seq.int
[13:36:35.902]             signalCondition <- base::signalCondition
[13:36:35.902]             sys.calls <- base::sys.calls
[13:36:35.902]             `[[` <- base::`[[`
[13:36:35.902]             `+` <- base::`+`
[13:36:35.902]             `<<-` <- base::`<<-`
[13:36:35.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.902]                   3L)]
[13:36:35.902]             }
[13:36:35.902]             function(cond) {
[13:36:35.902]                 is_error <- inherits(cond, "error")
[13:36:35.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.902]                   NULL)
[13:36:35.902]                 if (is_error) {
[13:36:35.902]                   sessionInformation <- function() {
[13:36:35.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.902]                       search = base::search(), system = base::Sys.info())
[13:36:35.902]                   }
[13:36:35.902]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.902]                     cond$call), session = sessionInformation(), 
[13:36:35.902]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.902]                   signalCondition(cond)
[13:36:35.902]                 }
[13:36:35.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.902]                 "immediateCondition"))) {
[13:36:35.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.902]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.902]                   if (TRUE && !signal) {
[13:36:35.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.902]                     {
[13:36:35.902]                       inherits <- base::inherits
[13:36:35.902]                       invokeRestart <- base::invokeRestart
[13:36:35.902]                       is.null <- base::is.null
[13:36:35.902]                       muffled <- FALSE
[13:36:35.902]                       if (inherits(cond, "message")) {
[13:36:35.902]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.902]                         if (muffled) 
[13:36:35.902]                           invokeRestart("muffleMessage")
[13:36:35.902]                       }
[13:36:35.902]                       else if (inherits(cond, "warning")) {
[13:36:35.902]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.902]                         if (muffled) 
[13:36:35.902]                           invokeRestart("muffleWarning")
[13:36:35.902]                       }
[13:36:35.902]                       else if (inherits(cond, "condition")) {
[13:36:35.902]                         if (!is.null(pattern)) {
[13:36:35.902]                           computeRestarts <- base::computeRestarts
[13:36:35.902]                           grepl <- base::grepl
[13:36:35.902]                           restarts <- computeRestarts(cond)
[13:36:35.902]                           for (restart in restarts) {
[13:36:35.902]                             name <- restart$name
[13:36:35.902]                             if (is.null(name)) 
[13:36:35.902]                               next
[13:36:35.902]                             if (!grepl(pattern, name)) 
[13:36:35.902]                               next
[13:36:35.902]                             invokeRestart(restart)
[13:36:35.902]                             muffled <- TRUE
[13:36:35.902]                             break
[13:36:35.902]                           }
[13:36:35.902]                         }
[13:36:35.902]                       }
[13:36:35.902]                       invisible(muffled)
[13:36:35.902]                     }
[13:36:35.902]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.902]                   }
[13:36:35.902]                 }
[13:36:35.902]                 else {
[13:36:35.902]                   if (TRUE) {
[13:36:35.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.902]                     {
[13:36:35.902]                       inherits <- base::inherits
[13:36:35.902]                       invokeRestart <- base::invokeRestart
[13:36:35.902]                       is.null <- base::is.null
[13:36:35.902]                       muffled <- FALSE
[13:36:35.902]                       if (inherits(cond, "message")) {
[13:36:35.902]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.902]                         if (muffled) 
[13:36:35.902]                           invokeRestart("muffleMessage")
[13:36:35.902]                       }
[13:36:35.902]                       else if (inherits(cond, "warning")) {
[13:36:35.902]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.902]                         if (muffled) 
[13:36:35.902]                           invokeRestart("muffleWarning")
[13:36:35.902]                       }
[13:36:35.902]                       else if (inherits(cond, "condition")) {
[13:36:35.902]                         if (!is.null(pattern)) {
[13:36:35.902]                           computeRestarts <- base::computeRestarts
[13:36:35.902]                           grepl <- base::grepl
[13:36:35.902]                           restarts <- computeRestarts(cond)
[13:36:35.902]                           for (restart in restarts) {
[13:36:35.902]                             name <- restart$name
[13:36:35.902]                             if (is.null(name)) 
[13:36:35.902]                               next
[13:36:35.902]                             if (!grepl(pattern, name)) 
[13:36:35.902]                               next
[13:36:35.902]                             invokeRestart(restart)
[13:36:35.902]                             muffled <- TRUE
[13:36:35.902]                             break
[13:36:35.902]                           }
[13:36:35.902]                         }
[13:36:35.902]                       }
[13:36:35.902]                       invisible(muffled)
[13:36:35.902]                     }
[13:36:35.902]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.902]                   }
[13:36:35.902]                 }
[13:36:35.902]             }
[13:36:35.902]         }))
[13:36:35.902]     }, error = function(ex) {
[13:36:35.902]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.902]                 ...future.rng), started = ...future.startTime, 
[13:36:35.902]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.902]             version = "1.8"), class = "FutureResult")
[13:36:35.902]     }, finally = {
[13:36:35.902]         if (!identical(...future.workdir, getwd())) 
[13:36:35.902]             setwd(...future.workdir)
[13:36:35.902]         {
[13:36:35.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.902]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.902]             }
[13:36:35.902]             base::options(...future.oldOptions)
[13:36:35.902]             if (.Platform$OS.type == "windows") {
[13:36:35.902]                 old_names <- names(...future.oldEnvVars)
[13:36:35.902]                 envs <- base::Sys.getenv()
[13:36:35.902]                 names <- names(envs)
[13:36:35.902]                 common <- intersect(names, old_names)
[13:36:35.902]                 added <- setdiff(names, old_names)
[13:36:35.902]                 removed <- setdiff(old_names, names)
[13:36:35.902]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.902]                   envs[common]]
[13:36:35.902]                 NAMES <- toupper(changed)
[13:36:35.902]                 args <- list()
[13:36:35.902]                 for (kk in seq_along(NAMES)) {
[13:36:35.902]                   name <- changed[[kk]]
[13:36:35.902]                   NAME <- NAMES[[kk]]
[13:36:35.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.902]                     next
[13:36:35.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.902]                 }
[13:36:35.902]                 NAMES <- toupper(added)
[13:36:35.902]                 for (kk in seq_along(NAMES)) {
[13:36:35.902]                   name <- added[[kk]]
[13:36:35.902]                   NAME <- NAMES[[kk]]
[13:36:35.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.902]                     next
[13:36:35.902]                   args[[name]] <- ""
[13:36:35.902]                 }
[13:36:35.902]                 NAMES <- toupper(removed)
[13:36:35.902]                 for (kk in seq_along(NAMES)) {
[13:36:35.902]                   name <- removed[[kk]]
[13:36:35.902]                   NAME <- NAMES[[kk]]
[13:36:35.902]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.902]                     next
[13:36:35.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.902]                 }
[13:36:35.902]                 if (length(args) > 0) 
[13:36:35.902]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.902]             }
[13:36:35.902]             else {
[13:36:35.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.902]             }
[13:36:35.902]             {
[13:36:35.902]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.902]                   0L) {
[13:36:35.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.902]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.902]                   base::options(opts)
[13:36:35.902]                 }
[13:36:35.902]                 {
[13:36:35.902]                   {
[13:36:35.902]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.902]                     NULL
[13:36:35.902]                   }
[13:36:35.902]                   options(future.plan = NULL)
[13:36:35.902]                   if (is.na(NA_character_)) 
[13:36:35.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.902]                     .init = FALSE)
[13:36:35.902]                 }
[13:36:35.902]             }
[13:36:35.902]         }
[13:36:35.902]     })
[13:36:35.902]     if (TRUE) {
[13:36:35.902]         base::sink(type = "output", split = FALSE)
[13:36:35.902]         if (TRUE) {
[13:36:35.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.902]         }
[13:36:35.902]         else {
[13:36:35.902]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.902]         }
[13:36:35.902]         base::close(...future.stdout)
[13:36:35.902]         ...future.stdout <- NULL
[13:36:35.902]     }
[13:36:35.902]     ...future.result$conditions <- ...future.conditions
[13:36:35.902]     ...future.result$finished <- base::Sys.time()
[13:36:35.902]     ...future.result
[13:36:35.902] }
[13:36:35.904] requestCore(): workers = 2
[13:36:35.907] MulticoreFuture started
[13:36:35.907] - Launch lazy future ... done
[13:36:35.907] run() for ‘MulticoreFuture’ ... done
[13:36:35.907] getGlobalsAndPackages() ...
[13:36:35.908] Searching for globals...
[13:36:35.908] plan(): Setting new future strategy stack:
[13:36:35.908] 
[13:36:35.909] Searching for globals ... DONE
[13:36:35.908] List of future strategies:
[13:36:35.908] 1. sequential:
[13:36:35.908]    - args: function (..., envir = parent.frame())
[13:36:35.908]    - tweaked: FALSE
[13:36:35.908]    - call: NULL
[13:36:35.909] - globals: [0] <none>
[13:36:35.909] getGlobalsAndPackages() ... DONE
[13:36:35.909] plan(): nbrOfWorkers() = 1
[13:36:35.909] run() for ‘Future’ ...
[13:36:35.909] - state: ‘created’
[13:36:35.910] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.911] plan(): Setting new future strategy stack:
[13:36:35.911] List of future strategies:
[13:36:35.911] 1. multicore:
[13:36:35.911]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:35.911]    - tweaked: FALSE
[13:36:35.911]    - call: plan(strategy)
[13:36:35.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:35.915]   - Field: ‘label’
[13:36:35.915] plan(): nbrOfWorkers() = 2
[13:36:35.915]   - Field: ‘local’
[13:36:35.916]   - Field: ‘owner’
[13:36:35.916]   - Field: ‘envir’
[13:36:35.916]   - Field: ‘workers’
[13:36:35.916]   - Field: ‘packages’
[13:36:35.916]   - Field: ‘gc’
[13:36:35.916]   - Field: ‘job’
[13:36:35.916]   - Field: ‘conditions’
[13:36:35.917]   - Field: ‘expr’
[13:36:35.917]   - Field: ‘uuid’
[13:36:35.917]   - Field: ‘seed’
[13:36:35.917]   - Field: ‘version’
[13:36:35.917]   - Field: ‘result’
[13:36:35.917]   - Field: ‘asynchronous’
[13:36:35.917]   - Field: ‘calls’
[13:36:35.918]   - Field: ‘globals’
[13:36:35.918]   - Field: ‘stdout’
[13:36:35.918]   - Field: ‘earlySignal’
[13:36:35.918]   - Field: ‘lazy’
[13:36:35.918]   - Field: ‘state’
[13:36:35.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:35.918] - Launch lazy future ...
[13:36:35.919] Packages needed by the future expression (n = 0): <none>
[13:36:35.919] Packages needed by future strategies (n = 0): <none>
[13:36:35.920] {
[13:36:35.920]     {
[13:36:35.920]         {
[13:36:35.920]             ...future.startTime <- base::Sys.time()
[13:36:35.920]             {
[13:36:35.920]                 {
[13:36:35.920]                   {
[13:36:35.920]                     {
[13:36:35.920]                       base::local({
[13:36:35.920]                         has_future <- base::requireNamespace("future", 
[13:36:35.920]                           quietly = TRUE)
[13:36:35.920]                         if (has_future) {
[13:36:35.920]                           ns <- base::getNamespace("future")
[13:36:35.920]                           version <- ns[[".package"]][["version"]]
[13:36:35.920]                           if (is.null(version)) 
[13:36:35.920]                             version <- utils::packageVersion("future")
[13:36:35.920]                         }
[13:36:35.920]                         else {
[13:36:35.920]                           version <- NULL
[13:36:35.920]                         }
[13:36:35.920]                         if (!has_future || version < "1.8.0") {
[13:36:35.920]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.920]                             "", base::R.version$version.string), 
[13:36:35.920]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.920]                               "release", "version")], collapse = " "), 
[13:36:35.920]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.920]                             info)
[13:36:35.920]                           info <- base::paste(info, collapse = "; ")
[13:36:35.920]                           if (!has_future) {
[13:36:35.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.920]                               info)
[13:36:35.920]                           }
[13:36:35.920]                           else {
[13:36:35.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.920]                               info, version)
[13:36:35.920]                           }
[13:36:35.920]                           base::stop(msg)
[13:36:35.920]                         }
[13:36:35.920]                       })
[13:36:35.920]                     }
[13:36:35.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.920]                     base::options(mc.cores = 1L)
[13:36:35.920]                   }
[13:36:35.920]                   ...future.strategy.old <- future::plan("list")
[13:36:35.920]                   options(future.plan = NULL)
[13:36:35.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.920]                 }
[13:36:35.920]                 ...future.workdir <- getwd()
[13:36:35.920]             }
[13:36:35.920]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.920]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.920]         }
[13:36:35.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.920]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.920]             base::names(...future.oldOptions))
[13:36:35.920]     }
[13:36:35.920]     if (FALSE) {
[13:36:35.920]     }
[13:36:35.920]     else {
[13:36:35.920]         if (TRUE) {
[13:36:35.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.920]                 open = "w")
[13:36:35.920]         }
[13:36:35.920]         else {
[13:36:35.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.920]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.920]         }
[13:36:35.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.920]             base::sink(type = "output", split = FALSE)
[13:36:35.920]             base::close(...future.stdout)
[13:36:35.920]         }, add = TRUE)
[13:36:35.920]     }
[13:36:35.920]     ...future.frame <- base::sys.nframe()
[13:36:35.920]     ...future.conditions <- base::list()
[13:36:35.920]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.920]     if (FALSE) {
[13:36:35.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.920]     }
[13:36:35.920]     ...future.result <- base::tryCatch({
[13:36:35.920]         base::withCallingHandlers({
[13:36:35.920]             ...future.value <- base::withVisible(base::local({
[13:36:35.920]                 withCallingHandlers({
[13:36:35.920]                   NULL
[13:36:35.920]                 }, immediateCondition = function(cond) {
[13:36:35.920]                   save_rds <- function (object, pathname, ...) 
[13:36:35.920]                   {
[13:36:35.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:35.920]                     if (file_test("-f", pathname_tmp)) {
[13:36:35.920]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:35.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.920]                         fi_tmp[["mtime"]])
[13:36:35.920]                     }
[13:36:35.920]                     tryCatch({
[13:36:35.920]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:35.920]                     }, error = function(ex) {
[13:36:35.920]                       msg <- conditionMessage(ex)
[13:36:35.920]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:35.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.920]                         fi_tmp[["mtime"]], msg)
[13:36:35.920]                       ex$message <- msg
[13:36:35.920]                       stop(ex)
[13:36:35.920]                     })
[13:36:35.920]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:35.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:35.920]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:35.920]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.920]                       fi <- file.info(pathname)
[13:36:35.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:35.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:35.920]                         fi[["size"]], fi[["mtime"]])
[13:36:35.920]                       stop(msg)
[13:36:35.920]                     }
[13:36:35.920]                     invisible(pathname)
[13:36:35.920]                   }
[13:36:35.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:35.920]                     rootPath = tempdir()) 
[13:36:35.920]                   {
[13:36:35.920]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:35.920]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:35.920]                       tmpdir = path, fileext = ".rds")
[13:36:35.920]                     save_rds(obj, file)
[13:36:35.920]                   }
[13:36:35.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:35.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.920]                   {
[13:36:35.920]                     inherits <- base::inherits
[13:36:35.920]                     invokeRestart <- base::invokeRestart
[13:36:35.920]                     is.null <- base::is.null
[13:36:35.920]                     muffled <- FALSE
[13:36:35.920]                     if (inherits(cond, "message")) {
[13:36:35.920]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.920]                       if (muffled) 
[13:36:35.920]                         invokeRestart("muffleMessage")
[13:36:35.920]                     }
[13:36:35.920]                     else if (inherits(cond, "warning")) {
[13:36:35.920]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.920]                       if (muffled) 
[13:36:35.920]                         invokeRestart("muffleWarning")
[13:36:35.920]                     }
[13:36:35.920]                     else if (inherits(cond, "condition")) {
[13:36:35.920]                       if (!is.null(pattern)) {
[13:36:35.920]                         computeRestarts <- base::computeRestarts
[13:36:35.920]                         grepl <- base::grepl
[13:36:35.920]                         restarts <- computeRestarts(cond)
[13:36:35.920]                         for (restart in restarts) {
[13:36:35.920]                           name <- restart$name
[13:36:35.920]                           if (is.null(name)) 
[13:36:35.920]                             next
[13:36:35.920]                           if (!grepl(pattern, name)) 
[13:36:35.920]                             next
[13:36:35.920]                           invokeRestart(restart)
[13:36:35.920]                           muffled <- TRUE
[13:36:35.920]                           break
[13:36:35.920]                         }
[13:36:35.920]                       }
[13:36:35.920]                     }
[13:36:35.920]                     invisible(muffled)
[13:36:35.920]                   }
[13:36:35.920]                   muffleCondition(cond)
[13:36:35.920]                 })
[13:36:35.920]             }))
[13:36:35.920]             future::FutureResult(value = ...future.value$value, 
[13:36:35.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.920]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.920]                     ...future.globalenv.names))
[13:36:35.920]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.920]         }, condition = base::local({
[13:36:35.920]             c <- base::c
[13:36:35.920]             inherits <- base::inherits
[13:36:35.920]             invokeRestart <- base::invokeRestart
[13:36:35.920]             length <- base::length
[13:36:35.920]             list <- base::list
[13:36:35.920]             seq.int <- base::seq.int
[13:36:35.920]             signalCondition <- base::signalCondition
[13:36:35.920]             sys.calls <- base::sys.calls
[13:36:35.920]             `[[` <- base::`[[`
[13:36:35.920]             `+` <- base::`+`
[13:36:35.920]             `<<-` <- base::`<<-`
[13:36:35.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.920]                   3L)]
[13:36:35.920]             }
[13:36:35.920]             function(cond) {
[13:36:35.920]                 is_error <- inherits(cond, "error")
[13:36:35.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.920]                   NULL)
[13:36:35.920]                 if (is_error) {
[13:36:35.920]                   sessionInformation <- function() {
[13:36:35.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.920]                       search = base::search(), system = base::Sys.info())
[13:36:35.920]                   }
[13:36:35.920]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.920]                     cond$call), session = sessionInformation(), 
[13:36:35.920]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.920]                   signalCondition(cond)
[13:36:35.920]                 }
[13:36:35.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.920]                 "immediateCondition"))) {
[13:36:35.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.920]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.920]                   if (TRUE && !signal) {
[13:36:35.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.920]                     {
[13:36:35.920]                       inherits <- base::inherits
[13:36:35.920]                       invokeRestart <- base::invokeRestart
[13:36:35.920]                       is.null <- base::is.null
[13:36:35.920]                       muffled <- FALSE
[13:36:35.920]                       if (inherits(cond, "message")) {
[13:36:35.920]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.920]                         if (muffled) 
[13:36:35.920]                           invokeRestart("muffleMessage")
[13:36:35.920]                       }
[13:36:35.920]                       else if (inherits(cond, "warning")) {
[13:36:35.920]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.920]                         if (muffled) 
[13:36:35.920]                           invokeRestart("muffleWarning")
[13:36:35.920]                       }
[13:36:35.920]                       else if (inherits(cond, "condition")) {
[13:36:35.920]                         if (!is.null(pattern)) {
[13:36:35.920]                           computeRestarts <- base::computeRestarts
[13:36:35.920]                           grepl <- base::grepl
[13:36:35.920]                           restarts <- computeRestarts(cond)
[13:36:35.920]                           for (restart in restarts) {
[13:36:35.920]                             name <- restart$name
[13:36:35.920]                             if (is.null(name)) 
[13:36:35.920]                               next
[13:36:35.920]                             if (!grepl(pattern, name)) 
[13:36:35.920]                               next
[13:36:35.920]                             invokeRestart(restart)
[13:36:35.920]                             muffled <- TRUE
[13:36:35.920]                             break
[13:36:35.920]                           }
[13:36:35.920]                         }
[13:36:35.920]                       }
[13:36:35.920]                       invisible(muffled)
[13:36:35.920]                     }
[13:36:35.920]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.920]                   }
[13:36:35.920]                 }
[13:36:35.920]                 else {
[13:36:35.920]                   if (TRUE) {
[13:36:35.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.920]                     {
[13:36:35.920]                       inherits <- base::inherits
[13:36:35.920]                       invokeRestart <- base::invokeRestart
[13:36:35.920]                       is.null <- base::is.null
[13:36:35.920]                       muffled <- FALSE
[13:36:35.920]                       if (inherits(cond, "message")) {
[13:36:35.920]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.920]                         if (muffled) 
[13:36:35.920]                           invokeRestart("muffleMessage")
[13:36:35.920]                       }
[13:36:35.920]                       else if (inherits(cond, "warning")) {
[13:36:35.920]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.920]                         if (muffled) 
[13:36:35.920]                           invokeRestart("muffleWarning")
[13:36:35.920]                       }
[13:36:35.920]                       else if (inherits(cond, "condition")) {
[13:36:35.920]                         if (!is.null(pattern)) {
[13:36:35.920]                           computeRestarts <- base::computeRestarts
[13:36:35.920]                           grepl <- base::grepl
[13:36:35.920]                           restarts <- computeRestarts(cond)
[13:36:35.920]                           for (restart in restarts) {
[13:36:35.920]                             name <- restart$name
[13:36:35.920]                             if (is.null(name)) 
[13:36:35.920]                               next
[13:36:35.920]                             if (!grepl(pattern, name)) 
[13:36:35.920]                               next
[13:36:35.920]                             invokeRestart(restart)
[13:36:35.920]                             muffled <- TRUE
[13:36:35.920]                             break
[13:36:35.920]                           }
[13:36:35.920]                         }
[13:36:35.920]                       }
[13:36:35.920]                       invisible(muffled)
[13:36:35.920]                     }
[13:36:35.920]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.920]                   }
[13:36:35.920]                 }
[13:36:35.920]             }
[13:36:35.920]         }))
[13:36:35.920]     }, error = function(ex) {
[13:36:35.920]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.920]                 ...future.rng), started = ...future.startTime, 
[13:36:35.920]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.920]             version = "1.8"), class = "FutureResult")
[13:36:35.920]     }, finally = {
[13:36:35.920]         if (!identical(...future.workdir, getwd())) 
[13:36:35.920]             setwd(...future.workdir)
[13:36:35.920]         {
[13:36:35.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.920]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.920]             }
[13:36:35.920]             base::options(...future.oldOptions)
[13:36:35.920]             if (.Platform$OS.type == "windows") {
[13:36:35.920]                 old_names <- names(...future.oldEnvVars)
[13:36:35.920]                 envs <- base::Sys.getenv()
[13:36:35.920]                 names <- names(envs)
[13:36:35.920]                 common <- intersect(names, old_names)
[13:36:35.920]                 added <- setdiff(names, old_names)
[13:36:35.920]                 removed <- setdiff(old_names, names)
[13:36:35.920]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.920]                   envs[common]]
[13:36:35.920]                 NAMES <- toupper(changed)
[13:36:35.920]                 args <- list()
[13:36:35.920]                 for (kk in seq_along(NAMES)) {
[13:36:35.920]                   name <- changed[[kk]]
[13:36:35.920]                   NAME <- NAMES[[kk]]
[13:36:35.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.920]                     next
[13:36:35.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.920]                 }
[13:36:35.920]                 NAMES <- toupper(added)
[13:36:35.920]                 for (kk in seq_along(NAMES)) {
[13:36:35.920]                   name <- added[[kk]]
[13:36:35.920]                   NAME <- NAMES[[kk]]
[13:36:35.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.920]                     next
[13:36:35.920]                   args[[name]] <- ""
[13:36:35.920]                 }
[13:36:35.920]                 NAMES <- toupper(removed)
[13:36:35.920]                 for (kk in seq_along(NAMES)) {
[13:36:35.920]                   name <- removed[[kk]]
[13:36:35.920]                   NAME <- NAMES[[kk]]
[13:36:35.920]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.920]                     next
[13:36:35.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.920]                 }
[13:36:35.920]                 if (length(args) > 0) 
[13:36:35.920]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.920]             }
[13:36:35.920]             else {
[13:36:35.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.920]             }
[13:36:35.920]             {
[13:36:35.920]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.920]                   0L) {
[13:36:35.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.920]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.920]                   base::options(opts)
[13:36:35.920]                 }
[13:36:35.920]                 {
[13:36:35.920]                   {
[13:36:35.920]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.920]                     NULL
[13:36:35.920]                   }
[13:36:35.920]                   options(future.plan = NULL)
[13:36:35.920]                   if (is.na(NA_character_)) 
[13:36:35.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.920]                     .init = FALSE)
[13:36:35.920]                 }
[13:36:35.920]             }
[13:36:35.920]         }
[13:36:35.920]     })
[13:36:35.920]     if (TRUE) {
[13:36:35.920]         base::sink(type = "output", split = FALSE)
[13:36:35.920]         if (TRUE) {
[13:36:35.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.920]         }
[13:36:35.920]         else {
[13:36:35.920]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.920]         }
[13:36:35.920]         base::close(...future.stdout)
[13:36:35.920]         ...future.stdout <- NULL
[13:36:35.920]     }
[13:36:35.920]     ...future.result$conditions <- ...future.conditions
[13:36:35.920]     ...future.result$finished <- base::Sys.time()
[13:36:35.920]     ...future.result
[13:36:35.920] }
[13:36:35.923] requestCore(): workers = 2
[13:36:35.926] MulticoreFuture started
[13:36:35.926] - Launch lazy future ... done
[13:36:35.926] run() for ‘MulticoreFuture’ ... done
[13:36:35.927] plan(): Setting new future strategy stack:
[13:36:35.927] getGlobalsAndPackages() ...
[13:36:35.927] Searching for globals...
[13:36:35.927] List of future strategies:
[13:36:35.927] 1. sequential:
[13:36:35.927]    - args: function (..., envir = parent.frame())
[13:36:35.927]    - tweaked: FALSE
[13:36:35.927]    - call: NULL
[13:36:35.928] plan(): nbrOfWorkers() = 1
[13:36:35.929] - globals found: [1] ‘{’
[13:36:35.929] Searching for globals ... DONE
[13:36:35.929] Resolving globals: FALSE
[13:36:35.930] 
[13:36:35.930] 
[13:36:35.930] getGlobalsAndPackages() ... DONE
[13:36:35.930] plan(): Setting new future strategy stack:
[13:36:35.930] run() for ‘Future’ ...
[13:36:35.930] - state: ‘created’
[13:36:35.930] List of future strategies:
[13:36:35.930] 1. multicore:
[13:36:35.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:35.930]    - tweaked: FALSE
[13:36:35.930]    - call: plan(strategy)
[13:36:35.931] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:35.935] plan(): nbrOfWorkers() = 2
[13:36:35.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:35.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:35.936]   - Field: ‘label’
[13:36:35.936]   - Field: ‘local’
[13:36:35.936]   - Field: ‘owner’
[13:36:35.936]   - Field: ‘envir’
[13:36:35.936]   - Field: ‘workers’
[13:36:35.936]   - Field: ‘packages’
[13:36:35.937]   - Field: ‘gc’
[13:36:35.937]   - Field: ‘job’
[13:36:35.937]   - Field: ‘conditions’
[13:36:35.937]   - Field: ‘expr’
[13:36:35.937]   - Field: ‘uuid’
[13:36:35.937]   - Field: ‘seed’
[13:36:35.937]   - Field: ‘version’
[13:36:35.937]   - Field: ‘result’
[13:36:35.938]   - Field: ‘asynchronous’
[13:36:35.938]   - Field: ‘calls’
[13:36:35.938]   - Field: ‘globals’
[13:36:35.938]   - Field: ‘stdout’
[13:36:35.938]   - Field: ‘earlySignal’
[13:36:35.938]   - Field: ‘lazy’
[13:36:35.938]   - Field: ‘state’
[13:36:35.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:35.939] - Launch lazy future ...
[13:36:35.939] Packages needed by the future expression (n = 0): <none>
[13:36:35.939] Packages needed by future strategies (n = 0): <none>
[13:36:35.940] {
[13:36:35.940]     {
[13:36:35.940]         {
[13:36:35.940]             ...future.startTime <- base::Sys.time()
[13:36:35.940]             {
[13:36:35.940]                 {
[13:36:35.940]                   {
[13:36:35.940]                     {
[13:36:35.940]                       base::local({
[13:36:35.940]                         has_future <- base::requireNamespace("future", 
[13:36:35.940]                           quietly = TRUE)
[13:36:35.940]                         if (has_future) {
[13:36:35.940]                           ns <- base::getNamespace("future")
[13:36:35.940]                           version <- ns[[".package"]][["version"]]
[13:36:35.940]                           if (is.null(version)) 
[13:36:35.940]                             version <- utils::packageVersion("future")
[13:36:35.940]                         }
[13:36:35.940]                         else {
[13:36:35.940]                           version <- NULL
[13:36:35.940]                         }
[13:36:35.940]                         if (!has_future || version < "1.8.0") {
[13:36:35.940]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:35.940]                             "", base::R.version$version.string), 
[13:36:35.940]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:35.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:35.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:35.940]                               "release", "version")], collapse = " "), 
[13:36:35.940]                             hostname = base::Sys.info()[["nodename"]])
[13:36:35.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:35.940]                             info)
[13:36:35.940]                           info <- base::paste(info, collapse = "; ")
[13:36:35.940]                           if (!has_future) {
[13:36:35.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:35.940]                               info)
[13:36:35.940]                           }
[13:36:35.940]                           else {
[13:36:35.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:35.940]                               info, version)
[13:36:35.940]                           }
[13:36:35.940]                           base::stop(msg)
[13:36:35.940]                         }
[13:36:35.940]                       })
[13:36:35.940]                     }
[13:36:35.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:35.940]                     base::options(mc.cores = 1L)
[13:36:35.940]                   }
[13:36:35.940]                   ...future.strategy.old <- future::plan("list")
[13:36:35.940]                   options(future.plan = NULL)
[13:36:35.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:35.940]                 }
[13:36:35.940]                 ...future.workdir <- getwd()
[13:36:35.940]             }
[13:36:35.940]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:35.940]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:35.940]         }
[13:36:35.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:35.940]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:35.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:35.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:35.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:35.940]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:35.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:35.940]             base::names(...future.oldOptions))
[13:36:35.940]     }
[13:36:35.940]     if (FALSE) {
[13:36:35.940]     }
[13:36:35.940]     else {
[13:36:35.940]         if (TRUE) {
[13:36:35.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:35.940]                 open = "w")
[13:36:35.940]         }
[13:36:35.940]         else {
[13:36:35.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:35.940]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:35.940]         }
[13:36:35.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:35.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:35.940]             base::sink(type = "output", split = FALSE)
[13:36:35.940]             base::close(...future.stdout)
[13:36:35.940]         }, add = TRUE)
[13:36:35.940]     }
[13:36:35.940]     ...future.frame <- base::sys.nframe()
[13:36:35.940]     ...future.conditions <- base::list()
[13:36:35.940]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:35.940]     if (FALSE) {
[13:36:35.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:35.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:35.940]     }
[13:36:35.940]     ...future.result <- base::tryCatch({
[13:36:35.940]         base::withCallingHandlers({
[13:36:35.940]             ...future.value <- base::withVisible(base::local({
[13:36:35.940]                 withCallingHandlers({
[13:36:35.940]                   {
[13:36:35.940]                     4
[13:36:35.940]                   }
[13:36:35.940]                 }, immediateCondition = function(cond) {
[13:36:35.940]                   save_rds <- function (object, pathname, ...) 
[13:36:35.940]                   {
[13:36:35.940]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:35.940]                     if (file_test("-f", pathname_tmp)) {
[13:36:35.940]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.940]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:35.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.940]                         fi_tmp[["mtime"]])
[13:36:35.940]                     }
[13:36:35.940]                     tryCatch({
[13:36:35.940]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:35.940]                     }, error = function(ex) {
[13:36:35.940]                       msg <- conditionMessage(ex)
[13:36:35.940]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.940]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:35.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.940]                         fi_tmp[["mtime"]], msg)
[13:36:35.940]                       ex$message <- msg
[13:36:35.940]                       stop(ex)
[13:36:35.940]                     })
[13:36:35.940]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:35.940]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:35.940]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:35.940]                       fi_tmp <- file.info(pathname_tmp)
[13:36:35.940]                       fi <- file.info(pathname)
[13:36:35.940]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:35.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:35.940]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:35.940]                         fi[["size"]], fi[["mtime"]])
[13:36:35.940]                       stop(msg)
[13:36:35.940]                     }
[13:36:35.940]                     invisible(pathname)
[13:36:35.940]                   }
[13:36:35.940]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:35.940]                     rootPath = tempdir()) 
[13:36:35.940]                   {
[13:36:35.940]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:35.940]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:35.940]                       tmpdir = path, fileext = ".rds")
[13:36:35.940]                     save_rds(obj, file)
[13:36:35.940]                   }
[13:36:35.940]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:35.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.940]                   {
[13:36:35.940]                     inherits <- base::inherits
[13:36:35.940]                     invokeRestart <- base::invokeRestart
[13:36:35.940]                     is.null <- base::is.null
[13:36:35.940]                     muffled <- FALSE
[13:36:35.940]                     if (inherits(cond, "message")) {
[13:36:35.940]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:35.940]                       if (muffled) 
[13:36:35.940]                         invokeRestart("muffleMessage")
[13:36:35.940]                     }
[13:36:35.940]                     else if (inherits(cond, "warning")) {
[13:36:35.940]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:35.940]                       if (muffled) 
[13:36:35.940]                         invokeRestart("muffleWarning")
[13:36:35.940]                     }
[13:36:35.940]                     else if (inherits(cond, "condition")) {
[13:36:35.940]                       if (!is.null(pattern)) {
[13:36:35.940]                         computeRestarts <- base::computeRestarts
[13:36:35.940]                         grepl <- base::grepl
[13:36:35.940]                         restarts <- computeRestarts(cond)
[13:36:35.940]                         for (restart in restarts) {
[13:36:35.940]                           name <- restart$name
[13:36:35.940]                           if (is.null(name)) 
[13:36:35.940]                             next
[13:36:35.940]                           if (!grepl(pattern, name)) 
[13:36:35.940]                             next
[13:36:35.940]                           invokeRestart(restart)
[13:36:35.940]                           muffled <- TRUE
[13:36:35.940]                           break
[13:36:35.940]                         }
[13:36:35.940]                       }
[13:36:35.940]                     }
[13:36:35.940]                     invisible(muffled)
[13:36:35.940]                   }
[13:36:35.940]                   muffleCondition(cond)
[13:36:35.940]                 })
[13:36:35.940]             }))
[13:36:35.940]             future::FutureResult(value = ...future.value$value, 
[13:36:35.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.940]                   ...future.rng), globalenv = if (FALSE) 
[13:36:35.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:35.940]                     ...future.globalenv.names))
[13:36:35.940]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:35.940]         }, condition = base::local({
[13:36:35.940]             c <- base::c
[13:36:35.940]             inherits <- base::inherits
[13:36:35.940]             invokeRestart <- base::invokeRestart
[13:36:35.940]             length <- base::length
[13:36:35.940]             list <- base::list
[13:36:35.940]             seq.int <- base::seq.int
[13:36:35.940]             signalCondition <- base::signalCondition
[13:36:35.940]             sys.calls <- base::sys.calls
[13:36:35.940]             `[[` <- base::`[[`
[13:36:35.940]             `+` <- base::`+`
[13:36:35.940]             `<<-` <- base::`<<-`
[13:36:35.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:35.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:35.940]                   3L)]
[13:36:35.940]             }
[13:36:35.940]             function(cond) {
[13:36:35.940]                 is_error <- inherits(cond, "error")
[13:36:35.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:35.940]                   NULL)
[13:36:35.940]                 if (is_error) {
[13:36:35.940]                   sessionInformation <- function() {
[13:36:35.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:35.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:35.940]                       search = base::search(), system = base::Sys.info())
[13:36:35.940]                   }
[13:36:35.940]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:35.940]                     cond$call), session = sessionInformation(), 
[13:36:35.940]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:35.940]                   signalCondition(cond)
[13:36:35.940]                 }
[13:36:35.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:35.940]                 "immediateCondition"))) {
[13:36:35.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:35.940]                   ...future.conditions[[length(...future.conditions) + 
[13:36:35.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:35.940]                   if (TRUE && !signal) {
[13:36:35.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.940]                     {
[13:36:35.940]                       inherits <- base::inherits
[13:36:35.940]                       invokeRestart <- base::invokeRestart
[13:36:35.940]                       is.null <- base::is.null
[13:36:35.940]                       muffled <- FALSE
[13:36:35.940]                       if (inherits(cond, "message")) {
[13:36:35.940]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.940]                         if (muffled) 
[13:36:35.940]                           invokeRestart("muffleMessage")
[13:36:35.940]                       }
[13:36:35.940]                       else if (inherits(cond, "warning")) {
[13:36:35.940]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.940]                         if (muffled) 
[13:36:35.940]                           invokeRestart("muffleWarning")
[13:36:35.940]                       }
[13:36:35.940]                       else if (inherits(cond, "condition")) {
[13:36:35.940]                         if (!is.null(pattern)) {
[13:36:35.940]                           computeRestarts <- base::computeRestarts
[13:36:35.940]                           grepl <- base::grepl
[13:36:35.940]                           restarts <- computeRestarts(cond)
[13:36:35.940]                           for (restart in restarts) {
[13:36:35.940]                             name <- restart$name
[13:36:35.940]                             if (is.null(name)) 
[13:36:35.940]                               next
[13:36:35.940]                             if (!grepl(pattern, name)) 
[13:36:35.940]                               next
[13:36:35.940]                             invokeRestart(restart)
[13:36:35.940]                             muffled <- TRUE
[13:36:35.940]                             break
[13:36:35.940]                           }
[13:36:35.940]                         }
[13:36:35.940]                       }
[13:36:35.940]                       invisible(muffled)
[13:36:35.940]                     }
[13:36:35.940]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.940]                   }
[13:36:35.940]                 }
[13:36:35.940]                 else {
[13:36:35.940]                   if (TRUE) {
[13:36:35.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:35.940]                     {
[13:36:35.940]                       inherits <- base::inherits
[13:36:35.940]                       invokeRestart <- base::invokeRestart
[13:36:35.940]                       is.null <- base::is.null
[13:36:35.940]                       muffled <- FALSE
[13:36:35.940]                       if (inherits(cond, "message")) {
[13:36:35.940]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:35.940]                         if (muffled) 
[13:36:35.940]                           invokeRestart("muffleMessage")
[13:36:35.940]                       }
[13:36:35.940]                       else if (inherits(cond, "warning")) {
[13:36:35.940]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:35.940]                         if (muffled) 
[13:36:35.940]                           invokeRestart("muffleWarning")
[13:36:35.940]                       }
[13:36:35.940]                       else if (inherits(cond, "condition")) {
[13:36:35.940]                         if (!is.null(pattern)) {
[13:36:35.940]                           computeRestarts <- base::computeRestarts
[13:36:35.940]                           grepl <- base::grepl
[13:36:35.940]                           restarts <- computeRestarts(cond)
[13:36:35.940]                           for (restart in restarts) {
[13:36:35.940]                             name <- restart$name
[13:36:35.940]                             if (is.null(name)) 
[13:36:35.940]                               next
[13:36:35.940]                             if (!grepl(pattern, name)) 
[13:36:35.940]                               next
[13:36:35.940]                             invokeRestart(restart)
[13:36:35.940]                             muffled <- TRUE
[13:36:35.940]                             break
[13:36:35.940]                           }
[13:36:35.940]                         }
[13:36:35.940]                       }
[13:36:35.940]                       invisible(muffled)
[13:36:35.940]                     }
[13:36:35.940]                     muffleCondition(cond, pattern = "^muffle")
[13:36:35.940]                   }
[13:36:35.940]                 }
[13:36:35.940]             }
[13:36:35.940]         }))
[13:36:35.940]     }, error = function(ex) {
[13:36:35.940]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:35.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:35.940]                 ...future.rng), started = ...future.startTime, 
[13:36:35.940]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:35.940]             version = "1.8"), class = "FutureResult")
[13:36:35.940]     }, finally = {
[13:36:35.940]         if (!identical(...future.workdir, getwd())) 
[13:36:35.940]             setwd(...future.workdir)
[13:36:35.940]         {
[13:36:35.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:35.940]                 ...future.oldOptions$nwarnings <- NULL
[13:36:35.940]             }
[13:36:35.940]             base::options(...future.oldOptions)
[13:36:35.940]             if (.Platform$OS.type == "windows") {
[13:36:35.940]                 old_names <- names(...future.oldEnvVars)
[13:36:35.940]                 envs <- base::Sys.getenv()
[13:36:35.940]                 names <- names(envs)
[13:36:35.940]                 common <- intersect(names, old_names)
[13:36:35.940]                 added <- setdiff(names, old_names)
[13:36:35.940]                 removed <- setdiff(old_names, names)
[13:36:35.940]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:35.940]                   envs[common]]
[13:36:35.940]                 NAMES <- toupper(changed)
[13:36:35.940]                 args <- list()
[13:36:35.940]                 for (kk in seq_along(NAMES)) {
[13:36:35.940]                   name <- changed[[kk]]
[13:36:35.940]                   NAME <- NAMES[[kk]]
[13:36:35.940]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.940]                     next
[13:36:35.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.940]                 }
[13:36:35.940]                 NAMES <- toupper(added)
[13:36:35.940]                 for (kk in seq_along(NAMES)) {
[13:36:35.940]                   name <- added[[kk]]
[13:36:35.940]                   NAME <- NAMES[[kk]]
[13:36:35.940]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.940]                     next
[13:36:35.940]                   args[[name]] <- ""
[13:36:35.940]                 }
[13:36:35.940]                 NAMES <- toupper(removed)
[13:36:35.940]                 for (kk in seq_along(NAMES)) {
[13:36:35.940]                   name <- removed[[kk]]
[13:36:35.940]                   NAME <- NAMES[[kk]]
[13:36:35.940]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:35.940]                     next
[13:36:35.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:35.940]                 }
[13:36:35.940]                 if (length(args) > 0) 
[13:36:35.940]                   base::do.call(base::Sys.setenv, args = args)
[13:36:35.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:35.940]             }
[13:36:35.940]             else {
[13:36:35.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:35.940]             }
[13:36:35.940]             {
[13:36:35.940]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:35.940]                   0L) {
[13:36:35.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:35.940]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:35.940]                   base::options(opts)
[13:36:35.940]                 }
[13:36:35.940]                 {
[13:36:35.940]                   {
[13:36:35.940]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:35.940]                     NULL
[13:36:35.940]                   }
[13:36:35.940]                   options(future.plan = NULL)
[13:36:35.940]                   if (is.na(NA_character_)) 
[13:36:35.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:35.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:35.940]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:35.940]                     .init = FALSE)
[13:36:35.940]                 }
[13:36:35.940]             }
[13:36:35.940]         }
[13:36:35.940]     })
[13:36:35.940]     if (TRUE) {
[13:36:35.940]         base::sink(type = "output", split = FALSE)
[13:36:35.940]         if (TRUE) {
[13:36:35.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:35.940]         }
[13:36:35.940]         else {
[13:36:35.940]             ...future.result["stdout"] <- base::list(NULL)
[13:36:35.940]         }
[13:36:35.940]         base::close(...future.stdout)
[13:36:35.940]         ...future.stdout <- NULL
[13:36:35.940]     }
[13:36:35.940]     ...future.result$conditions <- ...future.conditions
[13:36:35.940]     ...future.result$finished <- base::Sys.time()
[13:36:35.940]     ...future.result
[13:36:35.940] }
[13:36:35.943] requestCore(): workers = 2
[13:36:35.943] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:35.954] result() for MulticoreFuture ...
[13:36:35.955] result() for MulticoreFuture ...
[13:36:35.955] result() for MulticoreFuture ... done
[13:36:35.955] result() for MulticoreFuture ... done
[13:36:35.956] result() for MulticoreFuture ...
[13:36:35.956] result() for MulticoreFuture ... done
[13:36:35.958] MulticoreFuture started
[13:36:35.959] - Launch lazy future ... done
[13:36:35.959] run() for ‘MulticoreFuture’ ... done
[13:36:35.960] plan(): Setting new future strategy stack:
<environment: 0x564a74750928> 
[13:36:35.960] List of future strategies:
[13:36:35.960] 1. sequential:
[13:36:35.960]    - args: function (..., envir = parent.frame())
[13:36:35.960]    - tweaked: FALSE
[13:36:35.960]    - call: NULL
[13:36:35.961] plan(): nbrOfWorkers() = 1
<environment: 0x564a751d0e28> 
[13:36:35.964] plan(): Setting new future strategy stack:
[13:36:35.964] List of future strategies:
[13:36:35.964] 1. multicore:
[13:36:35.964]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:35.964]    - tweaked: FALSE
[13:36:35.964]    - call: plan(strategy)
[13:36:35.969] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:35.971] resolve() on environment ...
[13:36:35.971]  recursive: 0
[13:36:35.979]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:35.979] signalConditionsASAP(numeric, pos=1) ...
[13:36:35.979] - nx: 4
[13:36:35.979] - relay: TRUE
[13:36:35.979] - stdout: TRUE
[13:36:35.979] - signal: TRUE
[13:36:35.979] - resignal: FALSE
[13:36:35.980] - force: TRUE
[13:36:35.980] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:35.980] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:35.980]  - until=2
[13:36:35.980]  - relaying element #2
[13:36:35.980] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:35.980] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:35.981] signalConditionsASAP(NULL, pos=1) ... done
[13:36:35.981]  length: 3 (resolved future 1)
[13:36:35.981] Future #2
[13:36:35.981] result() for MulticoreFuture ...
[13:36:35.981] result() for MulticoreFuture ... done
[13:36:35.981] result() for MulticoreFuture ...
[13:36:35.981] result() for MulticoreFuture ... done
[13:36:35.982] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:35.982] - nx: 4
[13:36:35.982] - relay: TRUE
[13:36:35.982] - stdout: TRUE
[13:36:35.982] - signal: TRUE
[13:36:35.982] - resignal: FALSE
[13:36:35.982] - force: TRUE
[13:36:35.983] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:35.983] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:35.983]  - until=2
[13:36:35.983]  - relaying element #2
[13:36:35.983] result() for MulticoreFuture ...
[13:36:35.983] result() for MulticoreFuture ... done
[13:36:35.983] result() for MulticoreFuture ...
[13:36:35.983] result() for MulticoreFuture ... done
[13:36:35.984] result() for MulticoreFuture ...
[13:36:35.984] result() for MulticoreFuture ... done
[13:36:35.984] result() for MulticoreFuture ...
[13:36:35.984] result() for MulticoreFuture ... done
[13:36:35.984] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:35.984] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:35.984] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:35.985]  length: 2 (resolved future 2)
[13:36:35.985] Future #3
[13:36:35.985] result() for MulticoreFuture ...
[13:36:35.986] result() for MulticoreFuture ...
[13:36:35.986] result() for MulticoreFuture ... done
[13:36:35.986] result() for MulticoreFuture ... done
[13:36:35.986] result() for MulticoreFuture ...
[13:36:35.987] result() for MulticoreFuture ... done
[13:36:35.987] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:35.987] - nx: 4
[13:36:35.987] - relay: TRUE
[13:36:35.987] - stdout: TRUE
[13:36:35.987] - signal: TRUE
[13:36:35.987] - resignal: FALSE
[13:36:35.988] - force: TRUE
[13:36:35.988] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:35.988] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:35.988]  - until=3
[13:36:35.988]  - relaying element #3
[13:36:35.988] result() for MulticoreFuture ...
[13:36:35.988] result() for MulticoreFuture ... done
[13:36:35.988] result() for MulticoreFuture ...
[13:36:35.989] result() for MulticoreFuture ... done
[13:36:35.989] result() for MulticoreFuture ...
[13:36:35.989] result() for MulticoreFuture ... done
[13:36:35.989] result() for MulticoreFuture ...
[13:36:35.989] result() for MulticoreFuture ... done
[13:36:35.989] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:35.989] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:35.990] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:35.990]  length: 1 (resolved future 3)
[13:36:35.990] Future #4
[13:36:35.990] result() for MulticoreFuture ...
[13:36:35.991] result() for MulticoreFuture ...
[13:36:35.991] result() for MulticoreFuture ... done
[13:36:35.991] result() for MulticoreFuture ... done
[13:36:35.991] result() for MulticoreFuture ...
[13:36:35.992] result() for MulticoreFuture ... done
[13:36:35.992] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:35.992] - nx: 4
[13:36:35.992] - relay: TRUE
[13:36:35.992] - stdout: TRUE
[13:36:35.992] - signal: TRUE
[13:36:35.992] - resignal: FALSE
[13:36:35.993] - force: TRUE
[13:36:35.993] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:35.993] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:35.993]  - until=4
[13:36:35.993]  - relaying element #4
[13:36:35.993] result() for MulticoreFuture ...
[13:36:35.993] result() for MulticoreFuture ... done
[13:36:35.994] result() for MulticoreFuture ...
[13:36:35.994] result() for MulticoreFuture ... done
[13:36:35.994] result() for MulticoreFuture ...
[13:36:35.994] result() for MulticoreFuture ... done
[13:36:35.994] result() for MulticoreFuture ...
[13:36:35.994] result() for MulticoreFuture ... done
[13:36:35.995] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:35.995] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:35.995] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:35.995]  length: 0 (resolved future 4)
[13:36:35.995] Relaying remaining futures
[13:36:35.995] signalConditionsASAP(NULL, pos=0) ...
[13:36:35.995] - nx: 4
[13:36:35.995] - relay: TRUE
[13:36:35.996] - stdout: TRUE
[13:36:35.996] - signal: TRUE
[13:36:35.996] - resignal: FALSE
[13:36:35.996] - force: TRUE
[13:36:35.996] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:35.996] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:35.996] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:35.996] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:35.996] signalConditionsASAP(NULL, pos=0) ... done
[13:36:35.996] resolve() on environment ... DONE
[13:36:35.997] result() for MulticoreFuture ...
[13:36:35.997] result() for MulticoreFuture ... done
[13:36:35.997] result() for MulticoreFuture ...
[13:36:35.997] result() for MulticoreFuture ... done
[13:36:35.997] result() for MulticoreFuture ...
[13:36:35.997] result() for MulticoreFuture ... done
[13:36:35.997] result() for MulticoreFuture ...
[13:36:35.997] result() for MulticoreFuture ... done
[13:36:35.998] result() for MulticoreFuture ...
[13:36:35.998] result() for MulticoreFuture ... done
[13:36:35.998] result() for MulticoreFuture ...
[13:36:35.998] result() for MulticoreFuture ... done
<environment: 0x564a7528c828> 
Dimensions: c(1, 6)
[13:36:35.998] getGlobalsAndPackages() ...
[13:36:35.998] Searching for globals...
[13:36:35.999] 
[13:36:35.999] Searching for globals ... DONE
[13:36:35.999] - globals: [0] <none>
[13:36:35.999] getGlobalsAndPackages() ... DONE
[13:36:36.000] run() for ‘Future’ ...
[13:36:36.000] - state: ‘created’
[13:36:36.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.004]   - Field: ‘label’
[13:36:36.004]   - Field: ‘local’
[13:36:36.004]   - Field: ‘owner’
[13:36:36.004]   - Field: ‘envir’
[13:36:36.005]   - Field: ‘workers’
[13:36:36.005]   - Field: ‘packages’
[13:36:36.005]   - Field: ‘gc’
[13:36:36.005]   - Field: ‘job’
[13:36:36.005]   - Field: ‘conditions’
[13:36:36.005]   - Field: ‘expr’
[13:36:36.005]   - Field: ‘uuid’
[13:36:36.005]   - Field: ‘seed’
[13:36:36.005]   - Field: ‘version’
[13:36:36.006]   - Field: ‘result’
[13:36:36.006]   - Field: ‘asynchronous’
[13:36:36.006]   - Field: ‘calls’
[13:36:36.006]   - Field: ‘globals’
[13:36:36.006]   - Field: ‘stdout’
[13:36:36.006]   - Field: ‘earlySignal’
[13:36:36.006]   - Field: ‘lazy’
[13:36:36.006]   - Field: ‘state’
[13:36:36.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.007] - Launch lazy future ...
[13:36:36.007] Packages needed by the future expression (n = 0): <none>
[13:36:36.007] Packages needed by future strategies (n = 0): <none>
[13:36:36.008] {
[13:36:36.008]     {
[13:36:36.008]         {
[13:36:36.008]             ...future.startTime <- base::Sys.time()
[13:36:36.008]             {
[13:36:36.008]                 {
[13:36:36.008]                   {
[13:36:36.008]                     {
[13:36:36.008]                       base::local({
[13:36:36.008]                         has_future <- base::requireNamespace("future", 
[13:36:36.008]                           quietly = TRUE)
[13:36:36.008]                         if (has_future) {
[13:36:36.008]                           ns <- base::getNamespace("future")
[13:36:36.008]                           version <- ns[[".package"]][["version"]]
[13:36:36.008]                           if (is.null(version)) 
[13:36:36.008]                             version <- utils::packageVersion("future")
[13:36:36.008]                         }
[13:36:36.008]                         else {
[13:36:36.008]                           version <- NULL
[13:36:36.008]                         }
[13:36:36.008]                         if (!has_future || version < "1.8.0") {
[13:36:36.008]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.008]                             "", base::R.version$version.string), 
[13:36:36.008]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.008]                               "release", "version")], collapse = " "), 
[13:36:36.008]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.008]                             info)
[13:36:36.008]                           info <- base::paste(info, collapse = "; ")
[13:36:36.008]                           if (!has_future) {
[13:36:36.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.008]                               info)
[13:36:36.008]                           }
[13:36:36.008]                           else {
[13:36:36.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.008]                               info, version)
[13:36:36.008]                           }
[13:36:36.008]                           base::stop(msg)
[13:36:36.008]                         }
[13:36:36.008]                       })
[13:36:36.008]                     }
[13:36:36.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.008]                     base::options(mc.cores = 1L)
[13:36:36.008]                   }
[13:36:36.008]                   ...future.strategy.old <- future::plan("list")
[13:36:36.008]                   options(future.plan = NULL)
[13:36:36.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.008]                 }
[13:36:36.008]                 ...future.workdir <- getwd()
[13:36:36.008]             }
[13:36:36.008]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.008]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.008]         }
[13:36:36.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.008]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.008]             base::names(...future.oldOptions))
[13:36:36.008]     }
[13:36:36.008]     if (FALSE) {
[13:36:36.008]     }
[13:36:36.008]     else {
[13:36:36.008]         if (TRUE) {
[13:36:36.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.008]                 open = "w")
[13:36:36.008]         }
[13:36:36.008]         else {
[13:36:36.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.008]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.008]         }
[13:36:36.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.008]             base::sink(type = "output", split = FALSE)
[13:36:36.008]             base::close(...future.stdout)
[13:36:36.008]         }, add = TRUE)
[13:36:36.008]     }
[13:36:36.008]     ...future.frame <- base::sys.nframe()
[13:36:36.008]     ...future.conditions <- base::list()
[13:36:36.008]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.008]     if (FALSE) {
[13:36:36.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.008]     }
[13:36:36.008]     ...future.result <- base::tryCatch({
[13:36:36.008]         base::withCallingHandlers({
[13:36:36.008]             ...future.value <- base::withVisible(base::local({
[13:36:36.008]                 withCallingHandlers({
[13:36:36.008]                   2
[13:36:36.008]                 }, immediateCondition = function(cond) {
[13:36:36.008]                   save_rds <- function (object, pathname, ...) 
[13:36:36.008]                   {
[13:36:36.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.008]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.008]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.008]                         fi_tmp[["mtime"]])
[13:36:36.008]                     }
[13:36:36.008]                     tryCatch({
[13:36:36.008]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.008]                     }, error = function(ex) {
[13:36:36.008]                       msg <- conditionMessage(ex)
[13:36:36.008]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.008]                         fi_tmp[["mtime"]], msg)
[13:36:36.008]                       ex$message <- msg
[13:36:36.008]                       stop(ex)
[13:36:36.008]                     })
[13:36:36.008]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.008]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.008]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.008]                       fi <- file.info(pathname)
[13:36:36.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.008]                         fi[["size"]], fi[["mtime"]])
[13:36:36.008]                       stop(msg)
[13:36:36.008]                     }
[13:36:36.008]                     invisible(pathname)
[13:36:36.008]                   }
[13:36:36.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.008]                     rootPath = tempdir()) 
[13:36:36.008]                   {
[13:36:36.008]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.008]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.008]                       tmpdir = path, fileext = ".rds")
[13:36:36.008]                     save_rds(obj, file)
[13:36:36.008]                   }
[13:36:36.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.008]                   {
[13:36:36.008]                     inherits <- base::inherits
[13:36:36.008]                     invokeRestart <- base::invokeRestart
[13:36:36.008]                     is.null <- base::is.null
[13:36:36.008]                     muffled <- FALSE
[13:36:36.008]                     if (inherits(cond, "message")) {
[13:36:36.008]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.008]                       if (muffled) 
[13:36:36.008]                         invokeRestart("muffleMessage")
[13:36:36.008]                     }
[13:36:36.008]                     else if (inherits(cond, "warning")) {
[13:36:36.008]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.008]                       if (muffled) 
[13:36:36.008]                         invokeRestart("muffleWarning")
[13:36:36.008]                     }
[13:36:36.008]                     else if (inherits(cond, "condition")) {
[13:36:36.008]                       if (!is.null(pattern)) {
[13:36:36.008]                         computeRestarts <- base::computeRestarts
[13:36:36.008]                         grepl <- base::grepl
[13:36:36.008]                         restarts <- computeRestarts(cond)
[13:36:36.008]                         for (restart in restarts) {
[13:36:36.008]                           name <- restart$name
[13:36:36.008]                           if (is.null(name)) 
[13:36:36.008]                             next
[13:36:36.008]                           if (!grepl(pattern, name)) 
[13:36:36.008]                             next
[13:36:36.008]                           invokeRestart(restart)
[13:36:36.008]                           muffled <- TRUE
[13:36:36.008]                           break
[13:36:36.008]                         }
[13:36:36.008]                       }
[13:36:36.008]                     }
[13:36:36.008]                     invisible(muffled)
[13:36:36.008]                   }
[13:36:36.008]                   muffleCondition(cond)
[13:36:36.008]                 })
[13:36:36.008]             }))
[13:36:36.008]             future::FutureResult(value = ...future.value$value, 
[13:36:36.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.008]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.008]                     ...future.globalenv.names))
[13:36:36.008]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.008]         }, condition = base::local({
[13:36:36.008]             c <- base::c
[13:36:36.008]             inherits <- base::inherits
[13:36:36.008]             invokeRestart <- base::invokeRestart
[13:36:36.008]             length <- base::length
[13:36:36.008]             list <- base::list
[13:36:36.008]             seq.int <- base::seq.int
[13:36:36.008]             signalCondition <- base::signalCondition
[13:36:36.008]             sys.calls <- base::sys.calls
[13:36:36.008]             `[[` <- base::`[[`
[13:36:36.008]             `+` <- base::`+`
[13:36:36.008]             `<<-` <- base::`<<-`
[13:36:36.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.008]                   3L)]
[13:36:36.008]             }
[13:36:36.008]             function(cond) {
[13:36:36.008]                 is_error <- inherits(cond, "error")
[13:36:36.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.008]                   NULL)
[13:36:36.008]                 if (is_error) {
[13:36:36.008]                   sessionInformation <- function() {
[13:36:36.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.008]                       search = base::search(), system = base::Sys.info())
[13:36:36.008]                   }
[13:36:36.008]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.008]                     cond$call), session = sessionInformation(), 
[13:36:36.008]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.008]                   signalCondition(cond)
[13:36:36.008]                 }
[13:36:36.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.008]                 "immediateCondition"))) {
[13:36:36.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.008]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.008]                   if (TRUE && !signal) {
[13:36:36.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.008]                     {
[13:36:36.008]                       inherits <- base::inherits
[13:36:36.008]                       invokeRestart <- base::invokeRestart
[13:36:36.008]                       is.null <- base::is.null
[13:36:36.008]                       muffled <- FALSE
[13:36:36.008]                       if (inherits(cond, "message")) {
[13:36:36.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.008]                         if (muffled) 
[13:36:36.008]                           invokeRestart("muffleMessage")
[13:36:36.008]                       }
[13:36:36.008]                       else if (inherits(cond, "warning")) {
[13:36:36.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.008]                         if (muffled) 
[13:36:36.008]                           invokeRestart("muffleWarning")
[13:36:36.008]                       }
[13:36:36.008]                       else if (inherits(cond, "condition")) {
[13:36:36.008]                         if (!is.null(pattern)) {
[13:36:36.008]                           computeRestarts <- base::computeRestarts
[13:36:36.008]                           grepl <- base::grepl
[13:36:36.008]                           restarts <- computeRestarts(cond)
[13:36:36.008]                           for (restart in restarts) {
[13:36:36.008]                             name <- restart$name
[13:36:36.008]                             if (is.null(name)) 
[13:36:36.008]                               next
[13:36:36.008]                             if (!grepl(pattern, name)) 
[13:36:36.008]                               next
[13:36:36.008]                             invokeRestart(restart)
[13:36:36.008]                             muffled <- TRUE
[13:36:36.008]                             break
[13:36:36.008]                           }
[13:36:36.008]                         }
[13:36:36.008]                       }
[13:36:36.008]                       invisible(muffled)
[13:36:36.008]                     }
[13:36:36.008]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.008]                   }
[13:36:36.008]                 }
[13:36:36.008]                 else {
[13:36:36.008]                   if (TRUE) {
[13:36:36.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.008]                     {
[13:36:36.008]                       inherits <- base::inherits
[13:36:36.008]                       invokeRestart <- base::invokeRestart
[13:36:36.008]                       is.null <- base::is.null
[13:36:36.008]                       muffled <- FALSE
[13:36:36.008]                       if (inherits(cond, "message")) {
[13:36:36.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.008]                         if (muffled) 
[13:36:36.008]                           invokeRestart("muffleMessage")
[13:36:36.008]                       }
[13:36:36.008]                       else if (inherits(cond, "warning")) {
[13:36:36.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.008]                         if (muffled) 
[13:36:36.008]                           invokeRestart("muffleWarning")
[13:36:36.008]                       }
[13:36:36.008]                       else if (inherits(cond, "condition")) {
[13:36:36.008]                         if (!is.null(pattern)) {
[13:36:36.008]                           computeRestarts <- base::computeRestarts
[13:36:36.008]                           grepl <- base::grepl
[13:36:36.008]                           restarts <- computeRestarts(cond)
[13:36:36.008]                           for (restart in restarts) {
[13:36:36.008]                             name <- restart$name
[13:36:36.008]                             if (is.null(name)) 
[13:36:36.008]                               next
[13:36:36.008]                             if (!grepl(pattern, name)) 
[13:36:36.008]                               next
[13:36:36.008]                             invokeRestart(restart)
[13:36:36.008]                             muffled <- TRUE
[13:36:36.008]                             break
[13:36:36.008]                           }
[13:36:36.008]                         }
[13:36:36.008]                       }
[13:36:36.008]                       invisible(muffled)
[13:36:36.008]                     }
[13:36:36.008]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.008]                   }
[13:36:36.008]                 }
[13:36:36.008]             }
[13:36:36.008]         }))
[13:36:36.008]     }, error = function(ex) {
[13:36:36.008]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.008]                 ...future.rng), started = ...future.startTime, 
[13:36:36.008]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.008]             version = "1.8"), class = "FutureResult")
[13:36:36.008]     }, finally = {
[13:36:36.008]         if (!identical(...future.workdir, getwd())) 
[13:36:36.008]             setwd(...future.workdir)
[13:36:36.008]         {
[13:36:36.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.008]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.008]             }
[13:36:36.008]             base::options(...future.oldOptions)
[13:36:36.008]             if (.Platform$OS.type == "windows") {
[13:36:36.008]                 old_names <- names(...future.oldEnvVars)
[13:36:36.008]                 envs <- base::Sys.getenv()
[13:36:36.008]                 names <- names(envs)
[13:36:36.008]                 common <- intersect(names, old_names)
[13:36:36.008]                 added <- setdiff(names, old_names)
[13:36:36.008]                 removed <- setdiff(old_names, names)
[13:36:36.008]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.008]                   envs[common]]
[13:36:36.008]                 NAMES <- toupper(changed)
[13:36:36.008]                 args <- list()
[13:36:36.008]                 for (kk in seq_along(NAMES)) {
[13:36:36.008]                   name <- changed[[kk]]
[13:36:36.008]                   NAME <- NAMES[[kk]]
[13:36:36.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.008]                     next
[13:36:36.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.008]                 }
[13:36:36.008]                 NAMES <- toupper(added)
[13:36:36.008]                 for (kk in seq_along(NAMES)) {
[13:36:36.008]                   name <- added[[kk]]
[13:36:36.008]                   NAME <- NAMES[[kk]]
[13:36:36.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.008]                     next
[13:36:36.008]                   args[[name]] <- ""
[13:36:36.008]                 }
[13:36:36.008]                 NAMES <- toupper(removed)
[13:36:36.008]                 for (kk in seq_along(NAMES)) {
[13:36:36.008]                   name <- removed[[kk]]
[13:36:36.008]                   NAME <- NAMES[[kk]]
[13:36:36.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.008]                     next
[13:36:36.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.008]                 }
[13:36:36.008]                 if (length(args) > 0) 
[13:36:36.008]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.008]             }
[13:36:36.008]             else {
[13:36:36.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.008]             }
[13:36:36.008]             {
[13:36:36.008]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.008]                   0L) {
[13:36:36.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.008]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.008]                   base::options(opts)
[13:36:36.008]                 }
[13:36:36.008]                 {
[13:36:36.008]                   {
[13:36:36.008]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.008]                     NULL
[13:36:36.008]                   }
[13:36:36.008]                   options(future.plan = NULL)
[13:36:36.008]                   if (is.na(NA_character_)) 
[13:36:36.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.008]                     .init = FALSE)
[13:36:36.008]                 }
[13:36:36.008]             }
[13:36:36.008]         }
[13:36:36.008]     })
[13:36:36.008]     if (TRUE) {
[13:36:36.008]         base::sink(type = "output", split = FALSE)
[13:36:36.008]         if (TRUE) {
[13:36:36.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.008]         }
[13:36:36.008]         else {
[13:36:36.008]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.008]         }
[13:36:36.008]         base::close(...future.stdout)
[13:36:36.008]         ...future.stdout <- NULL
[13:36:36.008]     }
[13:36:36.008]     ...future.result$conditions <- ...future.conditions
[13:36:36.008]     ...future.result$finished <- base::Sys.time()
[13:36:36.008]     ...future.result
[13:36:36.008] }
[13:36:36.010] requestCore(): workers = 2
[13:36:36.012] MulticoreFuture started
[13:36:36.012] - Launch lazy future ... done
[13:36:36.013] run() for ‘MulticoreFuture’ ... done
[13:36:36.013] getGlobalsAndPackages() ...
[13:36:36.013] plan(): Setting new future strategy stack:
[13:36:36.013] Searching for globals...
[13:36:36.013] List of future strategies:
[13:36:36.013] 1. sequential:
[13:36:36.013]    - args: function (..., envir = parent.frame())
[13:36:36.013]    - tweaked: FALSE
[13:36:36.013]    - call: NULL
[13:36:36.014] 
[13:36:36.014] Searching for globals ... DONE
[13:36:36.014] plan(): nbrOfWorkers() = 1
[13:36:36.015] - globals: [0] <none>
[13:36:36.015] getGlobalsAndPackages() ... DONE
[13:36:36.015] run() for ‘Future’ ...
[13:36:36.015] - state: ‘created’
[13:36:36.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.016] plan(): Setting new future strategy stack:
[13:36:36.016] List of future strategies:
[13:36:36.016] 1. multicore:
[13:36:36.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.016]    - tweaked: FALSE
[13:36:36.016]    - call: plan(strategy)
[13:36:36.021] plan(): nbrOfWorkers() = 2
[13:36:36.021] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.022]   - Field: ‘label’
[13:36:36.022]   - Field: ‘local’
[13:36:36.022]   - Field: ‘owner’
[13:36:36.023]   - Field: ‘envir’
[13:36:36.023]   - Field: ‘workers’
[13:36:36.023]   - Field: ‘packages’
[13:36:36.023]   - Field: ‘gc’
[13:36:36.023]   - Field: ‘job’
[13:36:36.023]   - Field: ‘conditions’
[13:36:36.024]   - Field: ‘expr’
[13:36:36.024]   - Field: ‘uuid’
[13:36:36.024]   - Field: ‘seed’
[13:36:36.024]   - Field: ‘version’
[13:36:36.024]   - Field: ‘result’
[13:36:36.025]   - Field: ‘asynchronous’
[13:36:36.025]   - Field: ‘calls’
[13:36:36.025]   - Field: ‘globals’
[13:36:36.025]   - Field: ‘stdout’
[13:36:36.025]   - Field: ‘earlySignal’
[13:36:36.025]   - Field: ‘lazy’
[13:36:36.026]   - Field: ‘state’
[13:36:36.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.026] - Launch lazy future ...
[13:36:36.026] Packages needed by the future expression (n = 0): <none>
[13:36:36.027] Packages needed by future strategies (n = 0): <none>
[13:36:36.027] {
[13:36:36.027]     {
[13:36:36.027]         {
[13:36:36.027]             ...future.startTime <- base::Sys.time()
[13:36:36.027]             {
[13:36:36.027]                 {
[13:36:36.027]                   {
[13:36:36.027]                     {
[13:36:36.027]                       base::local({
[13:36:36.027]                         has_future <- base::requireNamespace("future", 
[13:36:36.027]                           quietly = TRUE)
[13:36:36.027]                         if (has_future) {
[13:36:36.027]                           ns <- base::getNamespace("future")
[13:36:36.027]                           version <- ns[[".package"]][["version"]]
[13:36:36.027]                           if (is.null(version)) 
[13:36:36.027]                             version <- utils::packageVersion("future")
[13:36:36.027]                         }
[13:36:36.027]                         else {
[13:36:36.027]                           version <- NULL
[13:36:36.027]                         }
[13:36:36.027]                         if (!has_future || version < "1.8.0") {
[13:36:36.027]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.027]                             "", base::R.version$version.string), 
[13:36:36.027]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.027]                               "release", "version")], collapse = " "), 
[13:36:36.027]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.027]                             info)
[13:36:36.027]                           info <- base::paste(info, collapse = "; ")
[13:36:36.027]                           if (!has_future) {
[13:36:36.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.027]                               info)
[13:36:36.027]                           }
[13:36:36.027]                           else {
[13:36:36.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.027]                               info, version)
[13:36:36.027]                           }
[13:36:36.027]                           base::stop(msg)
[13:36:36.027]                         }
[13:36:36.027]                       })
[13:36:36.027]                     }
[13:36:36.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.027]                     base::options(mc.cores = 1L)
[13:36:36.027]                   }
[13:36:36.027]                   ...future.strategy.old <- future::plan("list")
[13:36:36.027]                   options(future.plan = NULL)
[13:36:36.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.027]                 }
[13:36:36.027]                 ...future.workdir <- getwd()
[13:36:36.027]             }
[13:36:36.027]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.027]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.027]         }
[13:36:36.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.027]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.027]             base::names(...future.oldOptions))
[13:36:36.027]     }
[13:36:36.027]     if (FALSE) {
[13:36:36.027]     }
[13:36:36.027]     else {
[13:36:36.027]         if (TRUE) {
[13:36:36.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.027]                 open = "w")
[13:36:36.027]         }
[13:36:36.027]         else {
[13:36:36.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.027]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.027]         }
[13:36:36.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.027]             base::sink(type = "output", split = FALSE)
[13:36:36.027]             base::close(...future.stdout)
[13:36:36.027]         }, add = TRUE)
[13:36:36.027]     }
[13:36:36.027]     ...future.frame <- base::sys.nframe()
[13:36:36.027]     ...future.conditions <- base::list()
[13:36:36.027]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.027]     if (FALSE) {
[13:36:36.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.027]     }
[13:36:36.027]     ...future.result <- base::tryCatch({
[13:36:36.027]         base::withCallingHandlers({
[13:36:36.027]             ...future.value <- base::withVisible(base::local({
[13:36:36.027]                 withCallingHandlers({
[13:36:36.027]                   NULL
[13:36:36.027]                 }, immediateCondition = function(cond) {
[13:36:36.027]                   save_rds <- function (object, pathname, ...) 
[13:36:36.027]                   {
[13:36:36.027]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.027]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.027]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.027]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.027]                         fi_tmp[["mtime"]])
[13:36:36.027]                     }
[13:36:36.027]                     tryCatch({
[13:36:36.027]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.027]                     }, error = function(ex) {
[13:36:36.027]                       msg <- conditionMessage(ex)
[13:36:36.027]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.027]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.027]                         fi_tmp[["mtime"]], msg)
[13:36:36.027]                       ex$message <- msg
[13:36:36.027]                       stop(ex)
[13:36:36.027]                     })
[13:36:36.027]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.027]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.027]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.027]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.027]                       fi <- file.info(pathname)
[13:36:36.027]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.027]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.027]                         fi[["size"]], fi[["mtime"]])
[13:36:36.027]                       stop(msg)
[13:36:36.027]                     }
[13:36:36.027]                     invisible(pathname)
[13:36:36.027]                   }
[13:36:36.027]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.027]                     rootPath = tempdir()) 
[13:36:36.027]                   {
[13:36:36.027]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.027]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.027]                       tmpdir = path, fileext = ".rds")
[13:36:36.027]                     save_rds(obj, file)
[13:36:36.027]                   }
[13:36:36.027]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.027]                   {
[13:36:36.027]                     inherits <- base::inherits
[13:36:36.027]                     invokeRestart <- base::invokeRestart
[13:36:36.027]                     is.null <- base::is.null
[13:36:36.027]                     muffled <- FALSE
[13:36:36.027]                     if (inherits(cond, "message")) {
[13:36:36.027]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.027]                       if (muffled) 
[13:36:36.027]                         invokeRestart("muffleMessage")
[13:36:36.027]                     }
[13:36:36.027]                     else if (inherits(cond, "warning")) {
[13:36:36.027]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.027]                       if (muffled) 
[13:36:36.027]                         invokeRestart("muffleWarning")
[13:36:36.027]                     }
[13:36:36.027]                     else if (inherits(cond, "condition")) {
[13:36:36.027]                       if (!is.null(pattern)) {
[13:36:36.027]                         computeRestarts <- base::computeRestarts
[13:36:36.027]                         grepl <- base::grepl
[13:36:36.027]                         restarts <- computeRestarts(cond)
[13:36:36.027]                         for (restart in restarts) {
[13:36:36.027]                           name <- restart$name
[13:36:36.027]                           if (is.null(name)) 
[13:36:36.027]                             next
[13:36:36.027]                           if (!grepl(pattern, name)) 
[13:36:36.027]                             next
[13:36:36.027]                           invokeRestart(restart)
[13:36:36.027]                           muffled <- TRUE
[13:36:36.027]                           break
[13:36:36.027]                         }
[13:36:36.027]                       }
[13:36:36.027]                     }
[13:36:36.027]                     invisible(muffled)
[13:36:36.027]                   }
[13:36:36.027]                   muffleCondition(cond)
[13:36:36.027]                 })
[13:36:36.027]             }))
[13:36:36.027]             future::FutureResult(value = ...future.value$value, 
[13:36:36.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.027]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.027]                     ...future.globalenv.names))
[13:36:36.027]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.027]         }, condition = base::local({
[13:36:36.027]             c <- base::c
[13:36:36.027]             inherits <- base::inherits
[13:36:36.027]             invokeRestart <- base::invokeRestart
[13:36:36.027]             length <- base::length
[13:36:36.027]             list <- base::list
[13:36:36.027]             seq.int <- base::seq.int
[13:36:36.027]             signalCondition <- base::signalCondition
[13:36:36.027]             sys.calls <- base::sys.calls
[13:36:36.027]             `[[` <- base::`[[`
[13:36:36.027]             `+` <- base::`+`
[13:36:36.027]             `<<-` <- base::`<<-`
[13:36:36.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.027]                   3L)]
[13:36:36.027]             }
[13:36:36.027]             function(cond) {
[13:36:36.027]                 is_error <- inherits(cond, "error")
[13:36:36.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.027]                   NULL)
[13:36:36.027]                 if (is_error) {
[13:36:36.027]                   sessionInformation <- function() {
[13:36:36.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.027]                       search = base::search(), system = base::Sys.info())
[13:36:36.027]                   }
[13:36:36.027]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.027]                     cond$call), session = sessionInformation(), 
[13:36:36.027]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.027]                   signalCondition(cond)
[13:36:36.027]                 }
[13:36:36.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.027]                 "immediateCondition"))) {
[13:36:36.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.027]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.027]                   if (TRUE && !signal) {
[13:36:36.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.027]                     {
[13:36:36.027]                       inherits <- base::inherits
[13:36:36.027]                       invokeRestart <- base::invokeRestart
[13:36:36.027]                       is.null <- base::is.null
[13:36:36.027]                       muffled <- FALSE
[13:36:36.027]                       if (inherits(cond, "message")) {
[13:36:36.027]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.027]                         if (muffled) 
[13:36:36.027]                           invokeRestart("muffleMessage")
[13:36:36.027]                       }
[13:36:36.027]                       else if (inherits(cond, "warning")) {
[13:36:36.027]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.027]                         if (muffled) 
[13:36:36.027]                           invokeRestart("muffleWarning")
[13:36:36.027]                       }
[13:36:36.027]                       else if (inherits(cond, "condition")) {
[13:36:36.027]                         if (!is.null(pattern)) {
[13:36:36.027]                           computeRestarts <- base::computeRestarts
[13:36:36.027]                           grepl <- base::grepl
[13:36:36.027]                           restarts <- computeRestarts(cond)
[13:36:36.027]                           for (restart in restarts) {
[13:36:36.027]                             name <- restart$name
[13:36:36.027]                             if (is.null(name)) 
[13:36:36.027]                               next
[13:36:36.027]                             if (!grepl(pattern, name)) 
[13:36:36.027]                               next
[13:36:36.027]                             invokeRestart(restart)
[13:36:36.027]                             muffled <- TRUE
[13:36:36.027]                             break
[13:36:36.027]                           }
[13:36:36.027]                         }
[13:36:36.027]                       }
[13:36:36.027]                       invisible(muffled)
[13:36:36.027]                     }
[13:36:36.027]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.027]                   }
[13:36:36.027]                 }
[13:36:36.027]                 else {
[13:36:36.027]                   if (TRUE) {
[13:36:36.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.027]                     {
[13:36:36.027]                       inherits <- base::inherits
[13:36:36.027]                       invokeRestart <- base::invokeRestart
[13:36:36.027]                       is.null <- base::is.null
[13:36:36.027]                       muffled <- FALSE
[13:36:36.027]                       if (inherits(cond, "message")) {
[13:36:36.027]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.027]                         if (muffled) 
[13:36:36.027]                           invokeRestart("muffleMessage")
[13:36:36.027]                       }
[13:36:36.027]                       else if (inherits(cond, "warning")) {
[13:36:36.027]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.027]                         if (muffled) 
[13:36:36.027]                           invokeRestart("muffleWarning")
[13:36:36.027]                       }
[13:36:36.027]                       else if (inherits(cond, "condition")) {
[13:36:36.027]                         if (!is.null(pattern)) {
[13:36:36.027]                           computeRestarts <- base::computeRestarts
[13:36:36.027]                           grepl <- base::grepl
[13:36:36.027]                           restarts <- computeRestarts(cond)
[13:36:36.027]                           for (restart in restarts) {
[13:36:36.027]                             name <- restart$name
[13:36:36.027]                             if (is.null(name)) 
[13:36:36.027]                               next
[13:36:36.027]                             if (!grepl(pattern, name)) 
[13:36:36.027]                               next
[13:36:36.027]                             invokeRestart(restart)
[13:36:36.027]                             muffled <- TRUE
[13:36:36.027]                             break
[13:36:36.027]                           }
[13:36:36.027]                         }
[13:36:36.027]                       }
[13:36:36.027]                       invisible(muffled)
[13:36:36.027]                     }
[13:36:36.027]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.027]                   }
[13:36:36.027]                 }
[13:36:36.027]             }
[13:36:36.027]         }))
[13:36:36.027]     }, error = function(ex) {
[13:36:36.027]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.027]                 ...future.rng), started = ...future.startTime, 
[13:36:36.027]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.027]             version = "1.8"), class = "FutureResult")
[13:36:36.027]     }, finally = {
[13:36:36.027]         if (!identical(...future.workdir, getwd())) 
[13:36:36.027]             setwd(...future.workdir)
[13:36:36.027]         {
[13:36:36.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.027]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.027]             }
[13:36:36.027]             base::options(...future.oldOptions)
[13:36:36.027]             if (.Platform$OS.type == "windows") {
[13:36:36.027]                 old_names <- names(...future.oldEnvVars)
[13:36:36.027]                 envs <- base::Sys.getenv()
[13:36:36.027]                 names <- names(envs)
[13:36:36.027]                 common <- intersect(names, old_names)
[13:36:36.027]                 added <- setdiff(names, old_names)
[13:36:36.027]                 removed <- setdiff(old_names, names)
[13:36:36.027]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.027]                   envs[common]]
[13:36:36.027]                 NAMES <- toupper(changed)
[13:36:36.027]                 args <- list()
[13:36:36.027]                 for (kk in seq_along(NAMES)) {
[13:36:36.027]                   name <- changed[[kk]]
[13:36:36.027]                   NAME <- NAMES[[kk]]
[13:36:36.027]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.027]                     next
[13:36:36.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.027]                 }
[13:36:36.027]                 NAMES <- toupper(added)
[13:36:36.027]                 for (kk in seq_along(NAMES)) {
[13:36:36.027]                   name <- added[[kk]]
[13:36:36.027]                   NAME <- NAMES[[kk]]
[13:36:36.027]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.027]                     next
[13:36:36.027]                   args[[name]] <- ""
[13:36:36.027]                 }
[13:36:36.027]                 NAMES <- toupper(removed)
[13:36:36.027]                 for (kk in seq_along(NAMES)) {
[13:36:36.027]                   name <- removed[[kk]]
[13:36:36.027]                   NAME <- NAMES[[kk]]
[13:36:36.027]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.027]                     next
[13:36:36.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.027]                 }
[13:36:36.027]                 if (length(args) > 0) 
[13:36:36.027]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.027]             }
[13:36:36.027]             else {
[13:36:36.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.027]             }
[13:36:36.027]             {
[13:36:36.027]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.027]                   0L) {
[13:36:36.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.027]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.027]                   base::options(opts)
[13:36:36.027]                 }
[13:36:36.027]                 {
[13:36:36.027]                   {
[13:36:36.027]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.027]                     NULL
[13:36:36.027]                   }
[13:36:36.027]                   options(future.plan = NULL)
[13:36:36.027]                   if (is.na(NA_character_)) 
[13:36:36.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.027]                     .init = FALSE)
[13:36:36.027]                 }
[13:36:36.027]             }
[13:36:36.027]         }
[13:36:36.027]     })
[13:36:36.027]     if (TRUE) {
[13:36:36.027]         base::sink(type = "output", split = FALSE)
[13:36:36.027]         if (TRUE) {
[13:36:36.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.027]         }
[13:36:36.027]         else {
[13:36:36.027]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.027]         }
[13:36:36.027]         base::close(...future.stdout)
[13:36:36.027]         ...future.stdout <- NULL
[13:36:36.027]     }
[13:36:36.027]     ...future.result$conditions <- ...future.conditions
[13:36:36.027]     ...future.result$finished <- base::Sys.time()
[13:36:36.027]     ...future.result
[13:36:36.027] }
[13:36:36.031] requestCore(): workers = 2
[13:36:36.033] MulticoreFuture started
[13:36:36.034] - Launch lazy future ... done
[13:36:36.034] run() for ‘MulticoreFuture’ ... done
[13:36:36.035] plan(): Setting new future strategy stack:
[13:36:36.035] getGlobalsAndPackages() ...
[13:36:36.035] Searching for globals...
[13:36:36.035] List of future strategies:
[13:36:36.035] 1. sequential:
[13:36:36.035]    - args: function (..., envir = parent.frame())
[13:36:36.035]    - tweaked: FALSE
[13:36:36.035]    - call: NULL
[13:36:36.036] plan(): nbrOfWorkers() = 1
[13:36:36.036] - globals found: [1] ‘{’
[13:36:36.037] Searching for globals ... DONE
[13:36:36.037] Resolving globals: FALSE
[13:36:36.037] 
[13:36:36.037] 
[13:36:36.038] getGlobalsAndPackages() ... DONE
[13:36:36.038] plan(): Setting new future strategy stack:
[13:36:36.038] run() for ‘Future’ ...
[13:36:36.038] - state: ‘created’
[13:36:36.038] List of future strategies:
[13:36:36.038] 1. multicore:
[13:36:36.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.038]    - tweaked: FALSE
[13:36:36.038]    - call: plan(strategy)
[13:36:36.038] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.043] plan(): nbrOfWorkers() = 2
[13:36:36.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.043]   - Field: ‘label’
[13:36:36.044]   - Field: ‘local’
[13:36:36.044]   - Field: ‘owner’
[13:36:36.044]   - Field: ‘envir’
[13:36:36.044]   - Field: ‘workers’
[13:36:36.044]   - Field: ‘packages’
[13:36:36.044]   - Field: ‘gc’
[13:36:36.044]   - Field: ‘job’
[13:36:36.045]   - Field: ‘conditions’
[13:36:36.045]   - Field: ‘expr’
[13:36:36.045]   - Field: ‘uuid’
[13:36:36.045]   - Field: ‘seed’
[13:36:36.045]   - Field: ‘version’
[13:36:36.045]   - Field: ‘result’
[13:36:36.045]   - Field: ‘asynchronous’
[13:36:36.046]   - Field: ‘calls’
[13:36:36.046]   - Field: ‘globals’
[13:36:36.046]   - Field: ‘stdout’
[13:36:36.046]   - Field: ‘earlySignal’
[13:36:36.046]   - Field: ‘lazy’
[13:36:36.046]   - Field: ‘state’
[13:36:36.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.047] - Launch lazy future ...
[13:36:36.047] Packages needed by the future expression (n = 0): <none>
[13:36:36.047] Packages needed by future strategies (n = 0): <none>
[13:36:36.048] {
[13:36:36.048]     {
[13:36:36.048]         {
[13:36:36.048]             ...future.startTime <- base::Sys.time()
[13:36:36.048]             {
[13:36:36.048]                 {
[13:36:36.048]                   {
[13:36:36.048]                     {
[13:36:36.048]                       base::local({
[13:36:36.048]                         has_future <- base::requireNamespace("future", 
[13:36:36.048]                           quietly = TRUE)
[13:36:36.048]                         if (has_future) {
[13:36:36.048]                           ns <- base::getNamespace("future")
[13:36:36.048]                           version <- ns[[".package"]][["version"]]
[13:36:36.048]                           if (is.null(version)) 
[13:36:36.048]                             version <- utils::packageVersion("future")
[13:36:36.048]                         }
[13:36:36.048]                         else {
[13:36:36.048]                           version <- NULL
[13:36:36.048]                         }
[13:36:36.048]                         if (!has_future || version < "1.8.0") {
[13:36:36.048]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.048]                             "", base::R.version$version.string), 
[13:36:36.048]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.048]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.048]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.048]                               "release", "version")], collapse = " "), 
[13:36:36.048]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.048]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.048]                             info)
[13:36:36.048]                           info <- base::paste(info, collapse = "; ")
[13:36:36.048]                           if (!has_future) {
[13:36:36.048]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.048]                               info)
[13:36:36.048]                           }
[13:36:36.048]                           else {
[13:36:36.048]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.048]                               info, version)
[13:36:36.048]                           }
[13:36:36.048]                           base::stop(msg)
[13:36:36.048]                         }
[13:36:36.048]                       })
[13:36:36.048]                     }
[13:36:36.048]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.048]                     base::options(mc.cores = 1L)
[13:36:36.048]                   }
[13:36:36.048]                   ...future.strategy.old <- future::plan("list")
[13:36:36.048]                   options(future.plan = NULL)
[13:36:36.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.048]                 }
[13:36:36.048]                 ...future.workdir <- getwd()
[13:36:36.048]             }
[13:36:36.048]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.048]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.048]         }
[13:36:36.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.048]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.048]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.048]             base::names(...future.oldOptions))
[13:36:36.048]     }
[13:36:36.048]     if (FALSE) {
[13:36:36.048]     }
[13:36:36.048]     else {
[13:36:36.048]         if (TRUE) {
[13:36:36.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.048]                 open = "w")
[13:36:36.048]         }
[13:36:36.048]         else {
[13:36:36.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.048]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.048]         }
[13:36:36.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.048]             base::sink(type = "output", split = FALSE)
[13:36:36.048]             base::close(...future.stdout)
[13:36:36.048]         }, add = TRUE)
[13:36:36.048]     }
[13:36:36.048]     ...future.frame <- base::sys.nframe()
[13:36:36.048]     ...future.conditions <- base::list()
[13:36:36.048]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.048]     if (FALSE) {
[13:36:36.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.048]     }
[13:36:36.048]     ...future.result <- base::tryCatch({
[13:36:36.048]         base::withCallingHandlers({
[13:36:36.048]             ...future.value <- base::withVisible(base::local({
[13:36:36.048]                 withCallingHandlers({
[13:36:36.048]                   {
[13:36:36.048]                     4
[13:36:36.048]                   }
[13:36:36.048]                 }, immediateCondition = function(cond) {
[13:36:36.048]                   save_rds <- function (object, pathname, ...) 
[13:36:36.048]                   {
[13:36:36.048]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.048]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.048]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.048]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.048]                         fi_tmp[["mtime"]])
[13:36:36.048]                     }
[13:36:36.048]                     tryCatch({
[13:36:36.048]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.048]                     }, error = function(ex) {
[13:36:36.048]                       msg <- conditionMessage(ex)
[13:36:36.048]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.048]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.048]                         fi_tmp[["mtime"]], msg)
[13:36:36.048]                       ex$message <- msg
[13:36:36.048]                       stop(ex)
[13:36:36.048]                     })
[13:36:36.048]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.048]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.048]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.048]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.048]                       fi <- file.info(pathname)
[13:36:36.048]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.048]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.048]                         fi[["size"]], fi[["mtime"]])
[13:36:36.048]                       stop(msg)
[13:36:36.048]                     }
[13:36:36.048]                     invisible(pathname)
[13:36:36.048]                   }
[13:36:36.048]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.048]                     rootPath = tempdir()) 
[13:36:36.048]                   {
[13:36:36.048]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.048]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.048]                       tmpdir = path, fileext = ".rds")
[13:36:36.048]                     save_rds(obj, file)
[13:36:36.048]                   }
[13:36:36.048]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.048]                   {
[13:36:36.048]                     inherits <- base::inherits
[13:36:36.048]                     invokeRestart <- base::invokeRestart
[13:36:36.048]                     is.null <- base::is.null
[13:36:36.048]                     muffled <- FALSE
[13:36:36.048]                     if (inherits(cond, "message")) {
[13:36:36.048]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.048]                       if (muffled) 
[13:36:36.048]                         invokeRestart("muffleMessage")
[13:36:36.048]                     }
[13:36:36.048]                     else if (inherits(cond, "warning")) {
[13:36:36.048]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.048]                       if (muffled) 
[13:36:36.048]                         invokeRestart("muffleWarning")
[13:36:36.048]                     }
[13:36:36.048]                     else if (inherits(cond, "condition")) {
[13:36:36.048]                       if (!is.null(pattern)) {
[13:36:36.048]                         computeRestarts <- base::computeRestarts
[13:36:36.048]                         grepl <- base::grepl
[13:36:36.048]                         restarts <- computeRestarts(cond)
[13:36:36.048]                         for (restart in restarts) {
[13:36:36.048]                           name <- restart$name
[13:36:36.048]                           if (is.null(name)) 
[13:36:36.048]                             next
[13:36:36.048]                           if (!grepl(pattern, name)) 
[13:36:36.048]                             next
[13:36:36.048]                           invokeRestart(restart)
[13:36:36.048]                           muffled <- TRUE
[13:36:36.048]                           break
[13:36:36.048]                         }
[13:36:36.048]                       }
[13:36:36.048]                     }
[13:36:36.048]                     invisible(muffled)
[13:36:36.048]                   }
[13:36:36.048]                   muffleCondition(cond)
[13:36:36.048]                 })
[13:36:36.048]             }))
[13:36:36.048]             future::FutureResult(value = ...future.value$value, 
[13:36:36.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.048]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.048]                     ...future.globalenv.names))
[13:36:36.048]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.048]         }, condition = base::local({
[13:36:36.048]             c <- base::c
[13:36:36.048]             inherits <- base::inherits
[13:36:36.048]             invokeRestart <- base::invokeRestart
[13:36:36.048]             length <- base::length
[13:36:36.048]             list <- base::list
[13:36:36.048]             seq.int <- base::seq.int
[13:36:36.048]             signalCondition <- base::signalCondition
[13:36:36.048]             sys.calls <- base::sys.calls
[13:36:36.048]             `[[` <- base::`[[`
[13:36:36.048]             `+` <- base::`+`
[13:36:36.048]             `<<-` <- base::`<<-`
[13:36:36.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.048]                   3L)]
[13:36:36.048]             }
[13:36:36.048]             function(cond) {
[13:36:36.048]                 is_error <- inherits(cond, "error")
[13:36:36.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.048]                   NULL)
[13:36:36.048]                 if (is_error) {
[13:36:36.048]                   sessionInformation <- function() {
[13:36:36.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.048]                       search = base::search(), system = base::Sys.info())
[13:36:36.048]                   }
[13:36:36.048]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.048]                     cond$call), session = sessionInformation(), 
[13:36:36.048]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.048]                   signalCondition(cond)
[13:36:36.048]                 }
[13:36:36.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.048]                 "immediateCondition"))) {
[13:36:36.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.048]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.048]                   if (TRUE && !signal) {
[13:36:36.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.048]                     {
[13:36:36.048]                       inherits <- base::inherits
[13:36:36.048]                       invokeRestart <- base::invokeRestart
[13:36:36.048]                       is.null <- base::is.null
[13:36:36.048]                       muffled <- FALSE
[13:36:36.048]                       if (inherits(cond, "message")) {
[13:36:36.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.048]                         if (muffled) 
[13:36:36.048]                           invokeRestart("muffleMessage")
[13:36:36.048]                       }
[13:36:36.048]                       else if (inherits(cond, "warning")) {
[13:36:36.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.048]                         if (muffled) 
[13:36:36.048]                           invokeRestart("muffleWarning")
[13:36:36.048]                       }
[13:36:36.048]                       else if (inherits(cond, "condition")) {
[13:36:36.048]                         if (!is.null(pattern)) {
[13:36:36.048]                           computeRestarts <- base::computeRestarts
[13:36:36.048]                           grepl <- base::grepl
[13:36:36.048]                           restarts <- computeRestarts(cond)
[13:36:36.048]                           for (restart in restarts) {
[13:36:36.048]                             name <- restart$name
[13:36:36.048]                             if (is.null(name)) 
[13:36:36.048]                               next
[13:36:36.048]                             if (!grepl(pattern, name)) 
[13:36:36.048]                               next
[13:36:36.048]                             invokeRestart(restart)
[13:36:36.048]                             muffled <- TRUE
[13:36:36.048]                             break
[13:36:36.048]                           }
[13:36:36.048]                         }
[13:36:36.048]                       }
[13:36:36.048]                       invisible(muffled)
[13:36:36.048]                     }
[13:36:36.048]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.048]                   }
[13:36:36.048]                 }
[13:36:36.048]                 else {
[13:36:36.048]                   if (TRUE) {
[13:36:36.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.048]                     {
[13:36:36.048]                       inherits <- base::inherits
[13:36:36.048]                       invokeRestart <- base::invokeRestart
[13:36:36.048]                       is.null <- base::is.null
[13:36:36.048]                       muffled <- FALSE
[13:36:36.048]                       if (inherits(cond, "message")) {
[13:36:36.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.048]                         if (muffled) 
[13:36:36.048]                           invokeRestart("muffleMessage")
[13:36:36.048]                       }
[13:36:36.048]                       else if (inherits(cond, "warning")) {
[13:36:36.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.048]                         if (muffled) 
[13:36:36.048]                           invokeRestart("muffleWarning")
[13:36:36.048]                       }
[13:36:36.048]                       else if (inherits(cond, "condition")) {
[13:36:36.048]                         if (!is.null(pattern)) {
[13:36:36.048]                           computeRestarts <- base::computeRestarts
[13:36:36.048]                           grepl <- base::grepl
[13:36:36.048]                           restarts <- computeRestarts(cond)
[13:36:36.048]                           for (restart in restarts) {
[13:36:36.048]                             name <- restart$name
[13:36:36.048]                             if (is.null(name)) 
[13:36:36.048]                               next
[13:36:36.048]                             if (!grepl(pattern, name)) 
[13:36:36.048]                               next
[13:36:36.048]                             invokeRestart(restart)
[13:36:36.048]                             muffled <- TRUE
[13:36:36.048]                             break
[13:36:36.048]                           }
[13:36:36.048]                         }
[13:36:36.048]                       }
[13:36:36.048]                       invisible(muffled)
[13:36:36.048]                     }
[13:36:36.048]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.048]                   }
[13:36:36.048]                 }
[13:36:36.048]             }
[13:36:36.048]         }))
[13:36:36.048]     }, error = function(ex) {
[13:36:36.048]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.048]                 ...future.rng), started = ...future.startTime, 
[13:36:36.048]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.048]             version = "1.8"), class = "FutureResult")
[13:36:36.048]     }, finally = {
[13:36:36.048]         if (!identical(...future.workdir, getwd())) 
[13:36:36.048]             setwd(...future.workdir)
[13:36:36.048]         {
[13:36:36.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.048]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.048]             }
[13:36:36.048]             base::options(...future.oldOptions)
[13:36:36.048]             if (.Platform$OS.type == "windows") {
[13:36:36.048]                 old_names <- names(...future.oldEnvVars)
[13:36:36.048]                 envs <- base::Sys.getenv()
[13:36:36.048]                 names <- names(envs)
[13:36:36.048]                 common <- intersect(names, old_names)
[13:36:36.048]                 added <- setdiff(names, old_names)
[13:36:36.048]                 removed <- setdiff(old_names, names)
[13:36:36.048]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.048]                   envs[common]]
[13:36:36.048]                 NAMES <- toupper(changed)
[13:36:36.048]                 args <- list()
[13:36:36.048]                 for (kk in seq_along(NAMES)) {
[13:36:36.048]                   name <- changed[[kk]]
[13:36:36.048]                   NAME <- NAMES[[kk]]
[13:36:36.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.048]                     next
[13:36:36.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.048]                 }
[13:36:36.048]                 NAMES <- toupper(added)
[13:36:36.048]                 for (kk in seq_along(NAMES)) {
[13:36:36.048]                   name <- added[[kk]]
[13:36:36.048]                   NAME <- NAMES[[kk]]
[13:36:36.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.048]                     next
[13:36:36.048]                   args[[name]] <- ""
[13:36:36.048]                 }
[13:36:36.048]                 NAMES <- toupper(removed)
[13:36:36.048]                 for (kk in seq_along(NAMES)) {
[13:36:36.048]                   name <- removed[[kk]]
[13:36:36.048]                   NAME <- NAMES[[kk]]
[13:36:36.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.048]                     next
[13:36:36.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.048]                 }
[13:36:36.048]                 if (length(args) > 0) 
[13:36:36.048]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.048]             }
[13:36:36.048]             else {
[13:36:36.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.048]             }
[13:36:36.048]             {
[13:36:36.048]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.048]                   0L) {
[13:36:36.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.048]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.048]                   base::options(opts)
[13:36:36.048]                 }
[13:36:36.048]                 {
[13:36:36.048]                   {
[13:36:36.048]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.048]                     NULL
[13:36:36.048]                   }
[13:36:36.048]                   options(future.plan = NULL)
[13:36:36.048]                   if (is.na(NA_character_)) 
[13:36:36.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.048]                     .init = FALSE)
[13:36:36.048]                 }
[13:36:36.048]             }
[13:36:36.048]         }
[13:36:36.048]     })
[13:36:36.048]     if (TRUE) {
[13:36:36.048]         base::sink(type = "output", split = FALSE)
[13:36:36.048]         if (TRUE) {
[13:36:36.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.048]         }
[13:36:36.048]         else {
[13:36:36.048]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.048]         }
[13:36:36.048]         base::close(...future.stdout)
[13:36:36.048]         ...future.stdout <- NULL
[13:36:36.048]     }
[13:36:36.048]     ...future.result$conditions <- ...future.conditions
[13:36:36.048]     ...future.result$finished <- base::Sys.time()
[13:36:36.048]     ...future.result
[13:36:36.048] }
[13:36:36.051] requestCore(): workers = 2
[13:36:36.052] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:36.075] result() for MulticoreFuture ...
[13:36:36.076] result() for MulticoreFuture ...
[13:36:36.076] result() for MulticoreFuture ... done
[13:36:36.076] result() for MulticoreFuture ... done
[13:36:36.076] result() for MulticoreFuture ...
[13:36:36.076] result() for MulticoreFuture ... done
[13:36:36.079] MulticoreFuture started
[13:36:36.080] - Launch lazy future ... done
[13:36:36.080] run() for ‘MulticoreFuture’ ... done
[13:36:36.080] plan(): Setting new future strategy stack:
<environment: 0x564a72f566c8> 
[13:36:36.081] List of future strategies:
[13:36:36.081] 1. sequential:
[13:36:36.081]    - args: function (..., envir = parent.frame())
[13:36:36.081]    - tweaked: FALSE
[13:36:36.081]    - call: NULL
[13:36:36.082] plan(): nbrOfWorkers() = 1
<environment: 0x564a749167d8> 
[13:36:36.084] plan(): Setting new future strategy stack:
[13:36:36.084] List of future strategies:
[13:36:36.084] 1. multicore:
[13:36:36.084]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.084]    - tweaked: FALSE
[13:36:36.084]    - call: plan(strategy)
[13:36:36.089] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:36.091] resolve() on environment ...
[13:36:36.091]  recursive: 0
[13:36:36.092]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:36.092] signalConditionsASAP(numeric, pos=1) ...
[13:36:36.092] - nx: 4
[13:36:36.093] - relay: TRUE
[13:36:36.093] - stdout: TRUE
[13:36:36.093] - signal: TRUE
[13:36:36.093] - resignal: FALSE
[13:36:36.093] - force: TRUE
[13:36:36.093] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.093] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.093]  - until=2
[13:36:36.094]  - relaying element #2
[13:36:36.094] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.094] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.094] signalConditionsASAP(NULL, pos=1) ... done
[13:36:36.094]  length: 3 (resolved future 1)
[13:36:36.094] Future #2
[13:36:36.094] result() for MulticoreFuture ...
[13:36:36.095] result() for MulticoreFuture ... done
[13:36:36.095] result() for MulticoreFuture ...
[13:36:36.095] result() for MulticoreFuture ... done
[13:36:36.095] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:36.095] - nx: 4
[13:36:36.095] - relay: TRUE
[13:36:36.095] - stdout: TRUE
[13:36:36.096] - signal: TRUE
[13:36:36.096] - resignal: FALSE
[13:36:36.096] - force: TRUE
[13:36:36.096] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.096] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.096]  - until=2
[13:36:36.096]  - relaying element #2
[13:36:36.096] result() for MulticoreFuture ...
[13:36:36.096] result() for MulticoreFuture ... done
[13:36:36.097] result() for MulticoreFuture ...
[13:36:36.097] result() for MulticoreFuture ... done
[13:36:36.097] result() for MulticoreFuture ...
[13:36:36.097] result() for MulticoreFuture ... done
[13:36:36.097] result() for MulticoreFuture ...
[13:36:36.097] result() for MulticoreFuture ... done
[13:36:36.097] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.098] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.098] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:36.098]  length: 2 (resolved future 2)
[13:36:36.098] Future #3
[13:36:36.098] result() for MulticoreFuture ...
[13:36:36.099] result() for MulticoreFuture ...
[13:36:36.099] result() for MulticoreFuture ... done
[13:36:36.099] result() for MulticoreFuture ... done
[13:36:36.100] result() for MulticoreFuture ...
[13:36:36.100] result() for MulticoreFuture ... done
[13:36:36.100] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:36.100] - nx: 4
[13:36:36.100] - relay: TRUE
[13:36:36.100] - stdout: TRUE
[13:36:36.100] - signal: TRUE
[13:36:36.100] - resignal: FALSE
[13:36:36.101] - force: TRUE
[13:36:36.101] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.101] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.101]  - until=3
[13:36:36.101]  - relaying element #3
[13:36:36.101] result() for MulticoreFuture ...
[13:36:36.101] result() for MulticoreFuture ... done
[13:36:36.101] result() for MulticoreFuture ...
[13:36:36.102] result() for MulticoreFuture ... done
[13:36:36.102] result() for MulticoreFuture ...
[13:36:36.102] result() for MulticoreFuture ... done
[13:36:36.102] result() for MulticoreFuture ...
[13:36:36.102] result() for MulticoreFuture ... done
[13:36:36.102] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.102] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.103] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:36.103]  length: 1 (resolved future 3)
[13:36:36.103] Future #4
[13:36:36.103] result() for MulticoreFuture ...
[13:36:36.104] result() for MulticoreFuture ...
[13:36:36.104] result() for MulticoreFuture ... done
[13:36:36.104] result() for MulticoreFuture ... done
[13:36:36.104] result() for MulticoreFuture ...
[13:36:36.104] result() for MulticoreFuture ... done
[13:36:36.104] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:36.105] - nx: 4
[13:36:36.105] - relay: TRUE
[13:36:36.105] - stdout: TRUE
[13:36:36.105] - signal: TRUE
[13:36:36.105] - resignal: FALSE
[13:36:36.105] - force: TRUE
[13:36:36.105] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.105] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.106]  - until=4
[13:36:36.106]  - relaying element #4
[13:36:36.106] result() for MulticoreFuture ...
[13:36:36.106] result() for MulticoreFuture ... done
[13:36:36.106] result() for MulticoreFuture ...
[13:36:36.106] result() for MulticoreFuture ... done
[13:36:36.106] result() for MulticoreFuture ...
[13:36:36.106] result() for MulticoreFuture ... done
[13:36:36.106] result() for MulticoreFuture ...
[13:36:36.107] result() for MulticoreFuture ... done
[13:36:36.107] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.107] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.107] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:36.107]  length: 0 (resolved future 4)
[13:36:36.107] Relaying remaining futures
[13:36:36.107] signalConditionsASAP(NULL, pos=0) ...
[13:36:36.107] - nx: 4
[13:36:36.107] - relay: TRUE
[13:36:36.108] - stdout: TRUE
[13:36:36.108] - signal: TRUE
[13:36:36.108] - resignal: FALSE
[13:36:36.108] - force: TRUE
[13:36:36.108] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.108] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:36.108] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.108] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.108] signalConditionsASAP(NULL, pos=0) ... done
[13:36:36.108] resolve() on environment ... DONE
[13:36:36.109] result() for MulticoreFuture ...
[13:36:36.109] result() for MulticoreFuture ... done
[13:36:36.109] result() for MulticoreFuture ...
[13:36:36.109] result() for MulticoreFuture ... done
[13:36:36.109] result() for MulticoreFuture ...
[13:36:36.109] result() for MulticoreFuture ... done
[13:36:36.109] result() for MulticoreFuture ...
[13:36:36.109] result() for MulticoreFuture ... done
[13:36:36.109] result() for MulticoreFuture ...
[13:36:36.110] result() for MulticoreFuture ... done
[13:36:36.110] result() for MulticoreFuture ...
[13:36:36.110] result() for MulticoreFuture ... done
<environment: 0x564a749cd8e0> 
Dimensions: c(2, 3)
[13:36:36.110] getGlobalsAndPackages() ...
[13:36:36.110] Searching for globals...
[13:36:36.111] 
[13:36:36.111] Searching for globals ... DONE
[13:36:36.111] - globals: [0] <none>
[13:36:36.111] getGlobalsAndPackages() ... DONE
[13:36:36.112] run() for ‘Future’ ...
[13:36:36.112] - state: ‘created’
[13:36:36.112] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.117]   - Field: ‘label’
[13:36:36.117]   - Field: ‘local’
[13:36:36.117]   - Field: ‘owner’
[13:36:36.117]   - Field: ‘envir’
[13:36:36.117]   - Field: ‘workers’
[13:36:36.117]   - Field: ‘packages’
[13:36:36.117]   - Field: ‘gc’
[13:36:36.117]   - Field: ‘job’
[13:36:36.117]   - Field: ‘conditions’
[13:36:36.118]   - Field: ‘expr’
[13:36:36.118]   - Field: ‘uuid’
[13:36:36.118]   - Field: ‘seed’
[13:36:36.118]   - Field: ‘version’
[13:36:36.118]   - Field: ‘result’
[13:36:36.118]   - Field: ‘asynchronous’
[13:36:36.118]   - Field: ‘calls’
[13:36:36.118]   - Field: ‘globals’
[13:36:36.118]   - Field: ‘stdout’
[13:36:36.119]   - Field: ‘earlySignal’
[13:36:36.119]   - Field: ‘lazy’
[13:36:36.119]   - Field: ‘state’
[13:36:36.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.122] - Launch lazy future ...
[13:36:36.123] Packages needed by the future expression (n = 0): <none>
[13:36:36.123] Packages needed by future strategies (n = 0): <none>
[13:36:36.123] {
[13:36:36.123]     {
[13:36:36.123]         {
[13:36:36.123]             ...future.startTime <- base::Sys.time()
[13:36:36.123]             {
[13:36:36.123]                 {
[13:36:36.123]                   {
[13:36:36.123]                     {
[13:36:36.123]                       base::local({
[13:36:36.123]                         has_future <- base::requireNamespace("future", 
[13:36:36.123]                           quietly = TRUE)
[13:36:36.123]                         if (has_future) {
[13:36:36.123]                           ns <- base::getNamespace("future")
[13:36:36.123]                           version <- ns[[".package"]][["version"]]
[13:36:36.123]                           if (is.null(version)) 
[13:36:36.123]                             version <- utils::packageVersion("future")
[13:36:36.123]                         }
[13:36:36.123]                         else {
[13:36:36.123]                           version <- NULL
[13:36:36.123]                         }
[13:36:36.123]                         if (!has_future || version < "1.8.0") {
[13:36:36.123]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.123]                             "", base::R.version$version.string), 
[13:36:36.123]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.123]                               "release", "version")], collapse = " "), 
[13:36:36.123]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.123]                             info)
[13:36:36.123]                           info <- base::paste(info, collapse = "; ")
[13:36:36.123]                           if (!has_future) {
[13:36:36.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.123]                               info)
[13:36:36.123]                           }
[13:36:36.123]                           else {
[13:36:36.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.123]                               info, version)
[13:36:36.123]                           }
[13:36:36.123]                           base::stop(msg)
[13:36:36.123]                         }
[13:36:36.123]                       })
[13:36:36.123]                     }
[13:36:36.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.123]                     base::options(mc.cores = 1L)
[13:36:36.123]                   }
[13:36:36.123]                   ...future.strategy.old <- future::plan("list")
[13:36:36.123]                   options(future.plan = NULL)
[13:36:36.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.123]                 }
[13:36:36.123]                 ...future.workdir <- getwd()
[13:36:36.123]             }
[13:36:36.123]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.123]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.123]         }
[13:36:36.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.123]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.123]             base::names(...future.oldOptions))
[13:36:36.123]     }
[13:36:36.123]     if (FALSE) {
[13:36:36.123]     }
[13:36:36.123]     else {
[13:36:36.123]         if (TRUE) {
[13:36:36.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.123]                 open = "w")
[13:36:36.123]         }
[13:36:36.123]         else {
[13:36:36.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.123]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.123]         }
[13:36:36.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.123]             base::sink(type = "output", split = FALSE)
[13:36:36.123]             base::close(...future.stdout)
[13:36:36.123]         }, add = TRUE)
[13:36:36.123]     }
[13:36:36.123]     ...future.frame <- base::sys.nframe()
[13:36:36.123]     ...future.conditions <- base::list()
[13:36:36.123]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.123]     if (FALSE) {
[13:36:36.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.123]     }
[13:36:36.123]     ...future.result <- base::tryCatch({
[13:36:36.123]         base::withCallingHandlers({
[13:36:36.123]             ...future.value <- base::withVisible(base::local({
[13:36:36.123]                 withCallingHandlers({
[13:36:36.123]                   2
[13:36:36.123]                 }, immediateCondition = function(cond) {
[13:36:36.123]                   save_rds <- function (object, pathname, ...) 
[13:36:36.123]                   {
[13:36:36.123]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.123]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.123]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.123]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.123]                         fi_tmp[["mtime"]])
[13:36:36.123]                     }
[13:36:36.123]                     tryCatch({
[13:36:36.123]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.123]                     }, error = function(ex) {
[13:36:36.123]                       msg <- conditionMessage(ex)
[13:36:36.123]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.123]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.123]                         fi_tmp[["mtime"]], msg)
[13:36:36.123]                       ex$message <- msg
[13:36:36.123]                       stop(ex)
[13:36:36.123]                     })
[13:36:36.123]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.123]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.123]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.123]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.123]                       fi <- file.info(pathname)
[13:36:36.123]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.123]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.123]                         fi[["size"]], fi[["mtime"]])
[13:36:36.123]                       stop(msg)
[13:36:36.123]                     }
[13:36:36.123]                     invisible(pathname)
[13:36:36.123]                   }
[13:36:36.123]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.123]                     rootPath = tempdir()) 
[13:36:36.123]                   {
[13:36:36.123]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.123]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.123]                       tmpdir = path, fileext = ".rds")
[13:36:36.123]                     save_rds(obj, file)
[13:36:36.123]                   }
[13:36:36.123]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.123]                   {
[13:36:36.123]                     inherits <- base::inherits
[13:36:36.123]                     invokeRestart <- base::invokeRestart
[13:36:36.123]                     is.null <- base::is.null
[13:36:36.123]                     muffled <- FALSE
[13:36:36.123]                     if (inherits(cond, "message")) {
[13:36:36.123]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.123]                       if (muffled) 
[13:36:36.123]                         invokeRestart("muffleMessage")
[13:36:36.123]                     }
[13:36:36.123]                     else if (inherits(cond, "warning")) {
[13:36:36.123]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.123]                       if (muffled) 
[13:36:36.123]                         invokeRestart("muffleWarning")
[13:36:36.123]                     }
[13:36:36.123]                     else if (inherits(cond, "condition")) {
[13:36:36.123]                       if (!is.null(pattern)) {
[13:36:36.123]                         computeRestarts <- base::computeRestarts
[13:36:36.123]                         grepl <- base::grepl
[13:36:36.123]                         restarts <- computeRestarts(cond)
[13:36:36.123]                         for (restart in restarts) {
[13:36:36.123]                           name <- restart$name
[13:36:36.123]                           if (is.null(name)) 
[13:36:36.123]                             next
[13:36:36.123]                           if (!grepl(pattern, name)) 
[13:36:36.123]                             next
[13:36:36.123]                           invokeRestart(restart)
[13:36:36.123]                           muffled <- TRUE
[13:36:36.123]                           break
[13:36:36.123]                         }
[13:36:36.123]                       }
[13:36:36.123]                     }
[13:36:36.123]                     invisible(muffled)
[13:36:36.123]                   }
[13:36:36.123]                   muffleCondition(cond)
[13:36:36.123]                 })
[13:36:36.123]             }))
[13:36:36.123]             future::FutureResult(value = ...future.value$value, 
[13:36:36.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.123]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.123]                     ...future.globalenv.names))
[13:36:36.123]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.123]         }, condition = base::local({
[13:36:36.123]             c <- base::c
[13:36:36.123]             inherits <- base::inherits
[13:36:36.123]             invokeRestart <- base::invokeRestart
[13:36:36.123]             length <- base::length
[13:36:36.123]             list <- base::list
[13:36:36.123]             seq.int <- base::seq.int
[13:36:36.123]             signalCondition <- base::signalCondition
[13:36:36.123]             sys.calls <- base::sys.calls
[13:36:36.123]             `[[` <- base::`[[`
[13:36:36.123]             `+` <- base::`+`
[13:36:36.123]             `<<-` <- base::`<<-`
[13:36:36.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.123]                   3L)]
[13:36:36.123]             }
[13:36:36.123]             function(cond) {
[13:36:36.123]                 is_error <- inherits(cond, "error")
[13:36:36.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.123]                   NULL)
[13:36:36.123]                 if (is_error) {
[13:36:36.123]                   sessionInformation <- function() {
[13:36:36.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.123]                       search = base::search(), system = base::Sys.info())
[13:36:36.123]                   }
[13:36:36.123]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.123]                     cond$call), session = sessionInformation(), 
[13:36:36.123]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.123]                   signalCondition(cond)
[13:36:36.123]                 }
[13:36:36.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.123]                 "immediateCondition"))) {
[13:36:36.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.123]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.123]                   if (TRUE && !signal) {
[13:36:36.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.123]                     {
[13:36:36.123]                       inherits <- base::inherits
[13:36:36.123]                       invokeRestart <- base::invokeRestart
[13:36:36.123]                       is.null <- base::is.null
[13:36:36.123]                       muffled <- FALSE
[13:36:36.123]                       if (inherits(cond, "message")) {
[13:36:36.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.123]                         if (muffled) 
[13:36:36.123]                           invokeRestart("muffleMessage")
[13:36:36.123]                       }
[13:36:36.123]                       else if (inherits(cond, "warning")) {
[13:36:36.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.123]                         if (muffled) 
[13:36:36.123]                           invokeRestart("muffleWarning")
[13:36:36.123]                       }
[13:36:36.123]                       else if (inherits(cond, "condition")) {
[13:36:36.123]                         if (!is.null(pattern)) {
[13:36:36.123]                           computeRestarts <- base::computeRestarts
[13:36:36.123]                           grepl <- base::grepl
[13:36:36.123]                           restarts <- computeRestarts(cond)
[13:36:36.123]                           for (restart in restarts) {
[13:36:36.123]                             name <- restart$name
[13:36:36.123]                             if (is.null(name)) 
[13:36:36.123]                               next
[13:36:36.123]                             if (!grepl(pattern, name)) 
[13:36:36.123]                               next
[13:36:36.123]                             invokeRestart(restart)
[13:36:36.123]                             muffled <- TRUE
[13:36:36.123]                             break
[13:36:36.123]                           }
[13:36:36.123]                         }
[13:36:36.123]                       }
[13:36:36.123]                       invisible(muffled)
[13:36:36.123]                     }
[13:36:36.123]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.123]                   }
[13:36:36.123]                 }
[13:36:36.123]                 else {
[13:36:36.123]                   if (TRUE) {
[13:36:36.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.123]                     {
[13:36:36.123]                       inherits <- base::inherits
[13:36:36.123]                       invokeRestart <- base::invokeRestart
[13:36:36.123]                       is.null <- base::is.null
[13:36:36.123]                       muffled <- FALSE
[13:36:36.123]                       if (inherits(cond, "message")) {
[13:36:36.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.123]                         if (muffled) 
[13:36:36.123]                           invokeRestart("muffleMessage")
[13:36:36.123]                       }
[13:36:36.123]                       else if (inherits(cond, "warning")) {
[13:36:36.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.123]                         if (muffled) 
[13:36:36.123]                           invokeRestart("muffleWarning")
[13:36:36.123]                       }
[13:36:36.123]                       else if (inherits(cond, "condition")) {
[13:36:36.123]                         if (!is.null(pattern)) {
[13:36:36.123]                           computeRestarts <- base::computeRestarts
[13:36:36.123]                           grepl <- base::grepl
[13:36:36.123]                           restarts <- computeRestarts(cond)
[13:36:36.123]                           for (restart in restarts) {
[13:36:36.123]                             name <- restart$name
[13:36:36.123]                             if (is.null(name)) 
[13:36:36.123]                               next
[13:36:36.123]                             if (!grepl(pattern, name)) 
[13:36:36.123]                               next
[13:36:36.123]                             invokeRestart(restart)
[13:36:36.123]                             muffled <- TRUE
[13:36:36.123]                             break
[13:36:36.123]                           }
[13:36:36.123]                         }
[13:36:36.123]                       }
[13:36:36.123]                       invisible(muffled)
[13:36:36.123]                     }
[13:36:36.123]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.123]                   }
[13:36:36.123]                 }
[13:36:36.123]             }
[13:36:36.123]         }))
[13:36:36.123]     }, error = function(ex) {
[13:36:36.123]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.123]                 ...future.rng), started = ...future.startTime, 
[13:36:36.123]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.123]             version = "1.8"), class = "FutureResult")
[13:36:36.123]     }, finally = {
[13:36:36.123]         if (!identical(...future.workdir, getwd())) 
[13:36:36.123]             setwd(...future.workdir)
[13:36:36.123]         {
[13:36:36.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.123]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.123]             }
[13:36:36.123]             base::options(...future.oldOptions)
[13:36:36.123]             if (.Platform$OS.type == "windows") {
[13:36:36.123]                 old_names <- names(...future.oldEnvVars)
[13:36:36.123]                 envs <- base::Sys.getenv()
[13:36:36.123]                 names <- names(envs)
[13:36:36.123]                 common <- intersect(names, old_names)
[13:36:36.123]                 added <- setdiff(names, old_names)
[13:36:36.123]                 removed <- setdiff(old_names, names)
[13:36:36.123]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.123]                   envs[common]]
[13:36:36.123]                 NAMES <- toupper(changed)
[13:36:36.123]                 args <- list()
[13:36:36.123]                 for (kk in seq_along(NAMES)) {
[13:36:36.123]                   name <- changed[[kk]]
[13:36:36.123]                   NAME <- NAMES[[kk]]
[13:36:36.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.123]                     next
[13:36:36.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.123]                 }
[13:36:36.123]                 NAMES <- toupper(added)
[13:36:36.123]                 for (kk in seq_along(NAMES)) {
[13:36:36.123]                   name <- added[[kk]]
[13:36:36.123]                   NAME <- NAMES[[kk]]
[13:36:36.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.123]                     next
[13:36:36.123]                   args[[name]] <- ""
[13:36:36.123]                 }
[13:36:36.123]                 NAMES <- toupper(removed)
[13:36:36.123]                 for (kk in seq_along(NAMES)) {
[13:36:36.123]                   name <- removed[[kk]]
[13:36:36.123]                   NAME <- NAMES[[kk]]
[13:36:36.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.123]                     next
[13:36:36.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.123]                 }
[13:36:36.123]                 if (length(args) > 0) 
[13:36:36.123]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.123]             }
[13:36:36.123]             else {
[13:36:36.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.123]             }
[13:36:36.123]             {
[13:36:36.123]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.123]                   0L) {
[13:36:36.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.123]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.123]                   base::options(opts)
[13:36:36.123]                 }
[13:36:36.123]                 {
[13:36:36.123]                   {
[13:36:36.123]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.123]                     NULL
[13:36:36.123]                   }
[13:36:36.123]                   options(future.plan = NULL)
[13:36:36.123]                   if (is.na(NA_character_)) 
[13:36:36.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.123]                     .init = FALSE)
[13:36:36.123]                 }
[13:36:36.123]             }
[13:36:36.123]         }
[13:36:36.123]     })
[13:36:36.123]     if (TRUE) {
[13:36:36.123]         base::sink(type = "output", split = FALSE)
[13:36:36.123]         if (TRUE) {
[13:36:36.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.123]         }
[13:36:36.123]         else {
[13:36:36.123]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.123]         }
[13:36:36.123]         base::close(...future.stdout)
[13:36:36.123]         ...future.stdout <- NULL
[13:36:36.123]     }
[13:36:36.123]     ...future.result$conditions <- ...future.conditions
[13:36:36.123]     ...future.result$finished <- base::Sys.time()
[13:36:36.123]     ...future.result
[13:36:36.123] }
[13:36:36.126] requestCore(): workers = 2
[13:36:36.128] MulticoreFuture started
[13:36:36.128] - Launch lazy future ... done
[13:36:36.128] run() for ‘MulticoreFuture’ ... done
[13:36:36.129] getGlobalsAndPackages() ...
[13:36:36.129] Searching for globals...
[13:36:36.129] plan(): Setting new future strategy stack:
[13:36:36.130] 
[13:36:36.129] List of future strategies:
[13:36:36.129] 1. sequential:
[13:36:36.129]    - args: function (..., envir = parent.frame())
[13:36:36.129]    - tweaked: FALSE
[13:36:36.129]    - call: NULL
[13:36:36.130] Searching for globals ... DONE
[13:36:36.130] - globals: [0] <none>
[13:36:36.130] plan(): nbrOfWorkers() = 1
[13:36:36.130] getGlobalsAndPackages() ... DONE
[13:36:36.131] run() for ‘Future’ ...
[13:36:36.131] - state: ‘created’
[13:36:36.131] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.132] plan(): Setting new future strategy stack:
[13:36:36.132] List of future strategies:
[13:36:36.132] 1. multicore:
[13:36:36.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.132]    - tweaked: FALSE
[13:36:36.132]    - call: plan(strategy)
[13:36:36.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.136] plan(): nbrOfWorkers() = 2
[13:36:36.136]   - Field: ‘label’
[13:36:36.136]   - Field: ‘local’
[13:36:36.137]   - Field: ‘owner’
[13:36:36.137]   - Field: ‘envir’
[13:36:36.137]   - Field: ‘workers’
[13:36:36.137]   - Field: ‘packages’
[13:36:36.137]   - Field: ‘gc’
[13:36:36.137]   - Field: ‘job’
[13:36:36.137]   - Field: ‘conditions’
[13:36:36.138]   - Field: ‘expr’
[13:36:36.138]   - Field: ‘uuid’
[13:36:36.138]   - Field: ‘seed’
[13:36:36.138]   - Field: ‘version’
[13:36:36.138]   - Field: ‘result’
[13:36:36.138]   - Field: ‘asynchronous’
[13:36:36.138]   - Field: ‘calls’
[13:36:36.139]   - Field: ‘globals’
[13:36:36.139]   - Field: ‘stdout’
[13:36:36.139]   - Field: ‘earlySignal’
[13:36:36.139]   - Field: ‘lazy’
[13:36:36.139]   - Field: ‘state’
[13:36:36.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.140] - Launch lazy future ...
[13:36:36.140] Packages needed by the future expression (n = 0): <none>
[13:36:36.140] Packages needed by future strategies (n = 0): <none>
[13:36:36.141] {
[13:36:36.141]     {
[13:36:36.141]         {
[13:36:36.141]             ...future.startTime <- base::Sys.time()
[13:36:36.141]             {
[13:36:36.141]                 {
[13:36:36.141]                   {
[13:36:36.141]                     {
[13:36:36.141]                       base::local({
[13:36:36.141]                         has_future <- base::requireNamespace("future", 
[13:36:36.141]                           quietly = TRUE)
[13:36:36.141]                         if (has_future) {
[13:36:36.141]                           ns <- base::getNamespace("future")
[13:36:36.141]                           version <- ns[[".package"]][["version"]]
[13:36:36.141]                           if (is.null(version)) 
[13:36:36.141]                             version <- utils::packageVersion("future")
[13:36:36.141]                         }
[13:36:36.141]                         else {
[13:36:36.141]                           version <- NULL
[13:36:36.141]                         }
[13:36:36.141]                         if (!has_future || version < "1.8.0") {
[13:36:36.141]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.141]                             "", base::R.version$version.string), 
[13:36:36.141]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.141]                               "release", "version")], collapse = " "), 
[13:36:36.141]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.141]                             info)
[13:36:36.141]                           info <- base::paste(info, collapse = "; ")
[13:36:36.141]                           if (!has_future) {
[13:36:36.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.141]                               info)
[13:36:36.141]                           }
[13:36:36.141]                           else {
[13:36:36.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.141]                               info, version)
[13:36:36.141]                           }
[13:36:36.141]                           base::stop(msg)
[13:36:36.141]                         }
[13:36:36.141]                       })
[13:36:36.141]                     }
[13:36:36.141]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.141]                     base::options(mc.cores = 1L)
[13:36:36.141]                   }
[13:36:36.141]                   ...future.strategy.old <- future::plan("list")
[13:36:36.141]                   options(future.plan = NULL)
[13:36:36.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.141]                 }
[13:36:36.141]                 ...future.workdir <- getwd()
[13:36:36.141]             }
[13:36:36.141]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.141]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.141]         }
[13:36:36.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.141]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.141]             base::names(...future.oldOptions))
[13:36:36.141]     }
[13:36:36.141]     if (FALSE) {
[13:36:36.141]     }
[13:36:36.141]     else {
[13:36:36.141]         if (TRUE) {
[13:36:36.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.141]                 open = "w")
[13:36:36.141]         }
[13:36:36.141]         else {
[13:36:36.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.141]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.141]         }
[13:36:36.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.141]             base::sink(type = "output", split = FALSE)
[13:36:36.141]             base::close(...future.stdout)
[13:36:36.141]         }, add = TRUE)
[13:36:36.141]     }
[13:36:36.141]     ...future.frame <- base::sys.nframe()
[13:36:36.141]     ...future.conditions <- base::list()
[13:36:36.141]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.141]     if (FALSE) {
[13:36:36.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.141]     }
[13:36:36.141]     ...future.result <- base::tryCatch({
[13:36:36.141]         base::withCallingHandlers({
[13:36:36.141]             ...future.value <- base::withVisible(base::local({
[13:36:36.141]                 withCallingHandlers({
[13:36:36.141]                   NULL
[13:36:36.141]                 }, immediateCondition = function(cond) {
[13:36:36.141]                   save_rds <- function (object, pathname, ...) 
[13:36:36.141]                   {
[13:36:36.141]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.141]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.141]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.141]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.141]                         fi_tmp[["mtime"]])
[13:36:36.141]                     }
[13:36:36.141]                     tryCatch({
[13:36:36.141]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.141]                     }, error = function(ex) {
[13:36:36.141]                       msg <- conditionMessage(ex)
[13:36:36.141]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.141]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.141]                         fi_tmp[["mtime"]], msg)
[13:36:36.141]                       ex$message <- msg
[13:36:36.141]                       stop(ex)
[13:36:36.141]                     })
[13:36:36.141]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.141]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.141]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.141]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.141]                       fi <- file.info(pathname)
[13:36:36.141]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.141]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.141]                         fi[["size"]], fi[["mtime"]])
[13:36:36.141]                       stop(msg)
[13:36:36.141]                     }
[13:36:36.141]                     invisible(pathname)
[13:36:36.141]                   }
[13:36:36.141]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.141]                     rootPath = tempdir()) 
[13:36:36.141]                   {
[13:36:36.141]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.141]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.141]                       tmpdir = path, fileext = ".rds")
[13:36:36.141]                     save_rds(obj, file)
[13:36:36.141]                   }
[13:36:36.141]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.141]                   {
[13:36:36.141]                     inherits <- base::inherits
[13:36:36.141]                     invokeRestart <- base::invokeRestart
[13:36:36.141]                     is.null <- base::is.null
[13:36:36.141]                     muffled <- FALSE
[13:36:36.141]                     if (inherits(cond, "message")) {
[13:36:36.141]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.141]                       if (muffled) 
[13:36:36.141]                         invokeRestart("muffleMessage")
[13:36:36.141]                     }
[13:36:36.141]                     else if (inherits(cond, "warning")) {
[13:36:36.141]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.141]                       if (muffled) 
[13:36:36.141]                         invokeRestart("muffleWarning")
[13:36:36.141]                     }
[13:36:36.141]                     else if (inherits(cond, "condition")) {
[13:36:36.141]                       if (!is.null(pattern)) {
[13:36:36.141]                         computeRestarts <- base::computeRestarts
[13:36:36.141]                         grepl <- base::grepl
[13:36:36.141]                         restarts <- computeRestarts(cond)
[13:36:36.141]                         for (restart in restarts) {
[13:36:36.141]                           name <- restart$name
[13:36:36.141]                           if (is.null(name)) 
[13:36:36.141]                             next
[13:36:36.141]                           if (!grepl(pattern, name)) 
[13:36:36.141]                             next
[13:36:36.141]                           invokeRestart(restart)
[13:36:36.141]                           muffled <- TRUE
[13:36:36.141]                           break
[13:36:36.141]                         }
[13:36:36.141]                       }
[13:36:36.141]                     }
[13:36:36.141]                     invisible(muffled)
[13:36:36.141]                   }
[13:36:36.141]                   muffleCondition(cond)
[13:36:36.141]                 })
[13:36:36.141]             }))
[13:36:36.141]             future::FutureResult(value = ...future.value$value, 
[13:36:36.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.141]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.141]                     ...future.globalenv.names))
[13:36:36.141]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.141]         }, condition = base::local({
[13:36:36.141]             c <- base::c
[13:36:36.141]             inherits <- base::inherits
[13:36:36.141]             invokeRestart <- base::invokeRestart
[13:36:36.141]             length <- base::length
[13:36:36.141]             list <- base::list
[13:36:36.141]             seq.int <- base::seq.int
[13:36:36.141]             signalCondition <- base::signalCondition
[13:36:36.141]             sys.calls <- base::sys.calls
[13:36:36.141]             `[[` <- base::`[[`
[13:36:36.141]             `+` <- base::`+`
[13:36:36.141]             `<<-` <- base::`<<-`
[13:36:36.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.141]                   3L)]
[13:36:36.141]             }
[13:36:36.141]             function(cond) {
[13:36:36.141]                 is_error <- inherits(cond, "error")
[13:36:36.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.141]                   NULL)
[13:36:36.141]                 if (is_error) {
[13:36:36.141]                   sessionInformation <- function() {
[13:36:36.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.141]                       search = base::search(), system = base::Sys.info())
[13:36:36.141]                   }
[13:36:36.141]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.141]                     cond$call), session = sessionInformation(), 
[13:36:36.141]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.141]                   signalCondition(cond)
[13:36:36.141]                 }
[13:36:36.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.141]                 "immediateCondition"))) {
[13:36:36.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.141]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.141]                   if (TRUE && !signal) {
[13:36:36.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.141]                     {
[13:36:36.141]                       inherits <- base::inherits
[13:36:36.141]                       invokeRestart <- base::invokeRestart
[13:36:36.141]                       is.null <- base::is.null
[13:36:36.141]                       muffled <- FALSE
[13:36:36.141]                       if (inherits(cond, "message")) {
[13:36:36.141]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.141]                         if (muffled) 
[13:36:36.141]                           invokeRestart("muffleMessage")
[13:36:36.141]                       }
[13:36:36.141]                       else if (inherits(cond, "warning")) {
[13:36:36.141]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.141]                         if (muffled) 
[13:36:36.141]                           invokeRestart("muffleWarning")
[13:36:36.141]                       }
[13:36:36.141]                       else if (inherits(cond, "condition")) {
[13:36:36.141]                         if (!is.null(pattern)) {
[13:36:36.141]                           computeRestarts <- base::computeRestarts
[13:36:36.141]                           grepl <- base::grepl
[13:36:36.141]                           restarts <- computeRestarts(cond)
[13:36:36.141]                           for (restart in restarts) {
[13:36:36.141]                             name <- restart$name
[13:36:36.141]                             if (is.null(name)) 
[13:36:36.141]                               next
[13:36:36.141]                             if (!grepl(pattern, name)) 
[13:36:36.141]                               next
[13:36:36.141]                             invokeRestart(restart)
[13:36:36.141]                             muffled <- TRUE
[13:36:36.141]                             break
[13:36:36.141]                           }
[13:36:36.141]                         }
[13:36:36.141]                       }
[13:36:36.141]                       invisible(muffled)
[13:36:36.141]                     }
[13:36:36.141]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.141]                   }
[13:36:36.141]                 }
[13:36:36.141]                 else {
[13:36:36.141]                   if (TRUE) {
[13:36:36.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.141]                     {
[13:36:36.141]                       inherits <- base::inherits
[13:36:36.141]                       invokeRestart <- base::invokeRestart
[13:36:36.141]                       is.null <- base::is.null
[13:36:36.141]                       muffled <- FALSE
[13:36:36.141]                       if (inherits(cond, "message")) {
[13:36:36.141]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.141]                         if (muffled) 
[13:36:36.141]                           invokeRestart("muffleMessage")
[13:36:36.141]                       }
[13:36:36.141]                       else if (inherits(cond, "warning")) {
[13:36:36.141]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.141]                         if (muffled) 
[13:36:36.141]                           invokeRestart("muffleWarning")
[13:36:36.141]                       }
[13:36:36.141]                       else if (inherits(cond, "condition")) {
[13:36:36.141]                         if (!is.null(pattern)) {
[13:36:36.141]                           computeRestarts <- base::computeRestarts
[13:36:36.141]                           grepl <- base::grepl
[13:36:36.141]                           restarts <- computeRestarts(cond)
[13:36:36.141]                           for (restart in restarts) {
[13:36:36.141]                             name <- restart$name
[13:36:36.141]                             if (is.null(name)) 
[13:36:36.141]                               next
[13:36:36.141]                             if (!grepl(pattern, name)) 
[13:36:36.141]                               next
[13:36:36.141]                             invokeRestart(restart)
[13:36:36.141]                             muffled <- TRUE
[13:36:36.141]                             break
[13:36:36.141]                           }
[13:36:36.141]                         }
[13:36:36.141]                       }
[13:36:36.141]                       invisible(muffled)
[13:36:36.141]                     }
[13:36:36.141]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.141]                   }
[13:36:36.141]                 }
[13:36:36.141]             }
[13:36:36.141]         }))
[13:36:36.141]     }, error = function(ex) {
[13:36:36.141]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.141]                 ...future.rng), started = ...future.startTime, 
[13:36:36.141]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.141]             version = "1.8"), class = "FutureResult")
[13:36:36.141]     }, finally = {
[13:36:36.141]         if (!identical(...future.workdir, getwd())) 
[13:36:36.141]             setwd(...future.workdir)
[13:36:36.141]         {
[13:36:36.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.141]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.141]             }
[13:36:36.141]             base::options(...future.oldOptions)
[13:36:36.141]             if (.Platform$OS.type == "windows") {
[13:36:36.141]                 old_names <- names(...future.oldEnvVars)
[13:36:36.141]                 envs <- base::Sys.getenv()
[13:36:36.141]                 names <- names(envs)
[13:36:36.141]                 common <- intersect(names, old_names)
[13:36:36.141]                 added <- setdiff(names, old_names)
[13:36:36.141]                 removed <- setdiff(old_names, names)
[13:36:36.141]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.141]                   envs[common]]
[13:36:36.141]                 NAMES <- toupper(changed)
[13:36:36.141]                 args <- list()
[13:36:36.141]                 for (kk in seq_along(NAMES)) {
[13:36:36.141]                   name <- changed[[kk]]
[13:36:36.141]                   NAME <- NAMES[[kk]]
[13:36:36.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.141]                     next
[13:36:36.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.141]                 }
[13:36:36.141]                 NAMES <- toupper(added)
[13:36:36.141]                 for (kk in seq_along(NAMES)) {
[13:36:36.141]                   name <- added[[kk]]
[13:36:36.141]                   NAME <- NAMES[[kk]]
[13:36:36.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.141]                     next
[13:36:36.141]                   args[[name]] <- ""
[13:36:36.141]                 }
[13:36:36.141]                 NAMES <- toupper(removed)
[13:36:36.141]                 for (kk in seq_along(NAMES)) {
[13:36:36.141]                   name <- removed[[kk]]
[13:36:36.141]                   NAME <- NAMES[[kk]]
[13:36:36.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.141]                     next
[13:36:36.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.141]                 }
[13:36:36.141]                 if (length(args) > 0) 
[13:36:36.141]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.141]             }
[13:36:36.141]             else {
[13:36:36.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.141]             }
[13:36:36.141]             {
[13:36:36.141]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.141]                   0L) {
[13:36:36.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.141]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.141]                   base::options(opts)
[13:36:36.141]                 }
[13:36:36.141]                 {
[13:36:36.141]                   {
[13:36:36.141]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.141]                     NULL
[13:36:36.141]                   }
[13:36:36.141]                   options(future.plan = NULL)
[13:36:36.141]                   if (is.na(NA_character_)) 
[13:36:36.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.141]                     .init = FALSE)
[13:36:36.141]                 }
[13:36:36.141]             }
[13:36:36.141]         }
[13:36:36.141]     })
[13:36:36.141]     if (TRUE) {
[13:36:36.141]         base::sink(type = "output", split = FALSE)
[13:36:36.141]         if (TRUE) {
[13:36:36.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.141]         }
[13:36:36.141]         else {
[13:36:36.141]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.141]         }
[13:36:36.141]         base::close(...future.stdout)
[13:36:36.141]         ...future.stdout <- NULL
[13:36:36.141]     }
[13:36:36.141]     ...future.result$conditions <- ...future.conditions
[13:36:36.141]     ...future.result$finished <- base::Sys.time()
[13:36:36.141]     ...future.result
[13:36:36.141] }
[13:36:36.144] requestCore(): workers = 2
[13:36:36.147] MulticoreFuture started
[13:36:36.147] - Launch lazy future ... done
[13:36:36.147] run() for ‘MulticoreFuture’ ... done
[13:36:36.148] plan(): Setting new future strategy stack:
[13:36:36.148] getGlobalsAndPackages() ...
[13:36:36.148] Searching for globals...
[13:36:36.148] List of future strategies:
[13:36:36.148] 1. sequential:
[13:36:36.148]    - args: function (..., envir = parent.frame())
[13:36:36.148]    - tweaked: FALSE
[13:36:36.148]    - call: NULL
[13:36:36.149] plan(): nbrOfWorkers() = 1
[13:36:36.150] - globals found: [1] ‘{’
[13:36:36.150] Searching for globals ... DONE
[13:36:36.150] Resolving globals: FALSE
[13:36:36.151] 
[13:36:36.151] 
[13:36:36.151] getGlobalsAndPackages() ... DONE
[13:36:36.151] plan(): Setting new future strategy stack:
[13:36:36.151] run() for ‘Future’ ...
[13:36:36.152] - state: ‘created’
[13:36:36.151] List of future strategies:
[13:36:36.151] 1. multicore:
[13:36:36.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.151]    - tweaked: FALSE
[13:36:36.151]    - call: plan(strategy)
[13:36:36.152] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.157] plan(): nbrOfWorkers() = 2
[13:36:36.157] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.158] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.158]   - Field: ‘label’
[13:36:36.158]   - Field: ‘local’
[13:36:36.158]   - Field: ‘owner’
[13:36:36.158]   - Field: ‘envir’
[13:36:36.158]   - Field: ‘workers’
[13:36:36.158]   - Field: ‘packages’
[13:36:36.159]   - Field: ‘gc’
[13:36:36.159]   - Field: ‘job’
[13:36:36.159]   - Field: ‘conditions’
[13:36:36.159]   - Field: ‘expr’
[13:36:36.159]   - Field: ‘uuid’
[13:36:36.159]   - Field: ‘seed’
[13:36:36.159]   - Field: ‘version’
[13:36:36.160]   - Field: ‘result’
[13:36:36.160]   - Field: ‘asynchronous’
[13:36:36.160]   - Field: ‘calls’
[13:36:36.160]   - Field: ‘globals’
[13:36:36.160]   - Field: ‘stdout’
[13:36:36.160]   - Field: ‘earlySignal’
[13:36:36.160]   - Field: ‘lazy’
[13:36:36.161]   - Field: ‘state’
[13:36:36.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.161] - Launch lazy future ...
[13:36:36.161] Packages needed by the future expression (n = 0): <none>
[13:36:36.162] Packages needed by future strategies (n = 0): <none>
[13:36:36.162] {
[13:36:36.162]     {
[13:36:36.162]         {
[13:36:36.162]             ...future.startTime <- base::Sys.time()
[13:36:36.162]             {
[13:36:36.162]                 {
[13:36:36.162]                   {
[13:36:36.162]                     {
[13:36:36.162]                       base::local({
[13:36:36.162]                         has_future <- base::requireNamespace("future", 
[13:36:36.162]                           quietly = TRUE)
[13:36:36.162]                         if (has_future) {
[13:36:36.162]                           ns <- base::getNamespace("future")
[13:36:36.162]                           version <- ns[[".package"]][["version"]]
[13:36:36.162]                           if (is.null(version)) 
[13:36:36.162]                             version <- utils::packageVersion("future")
[13:36:36.162]                         }
[13:36:36.162]                         else {
[13:36:36.162]                           version <- NULL
[13:36:36.162]                         }
[13:36:36.162]                         if (!has_future || version < "1.8.0") {
[13:36:36.162]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.162]                             "", base::R.version$version.string), 
[13:36:36.162]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.162]                               "release", "version")], collapse = " "), 
[13:36:36.162]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.162]                             info)
[13:36:36.162]                           info <- base::paste(info, collapse = "; ")
[13:36:36.162]                           if (!has_future) {
[13:36:36.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.162]                               info)
[13:36:36.162]                           }
[13:36:36.162]                           else {
[13:36:36.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.162]                               info, version)
[13:36:36.162]                           }
[13:36:36.162]                           base::stop(msg)
[13:36:36.162]                         }
[13:36:36.162]                       })
[13:36:36.162]                     }
[13:36:36.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.162]                     base::options(mc.cores = 1L)
[13:36:36.162]                   }
[13:36:36.162]                   ...future.strategy.old <- future::plan("list")
[13:36:36.162]                   options(future.plan = NULL)
[13:36:36.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.162]                 }
[13:36:36.162]                 ...future.workdir <- getwd()
[13:36:36.162]             }
[13:36:36.162]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.162]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.162]         }
[13:36:36.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.162]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.162]             base::names(...future.oldOptions))
[13:36:36.162]     }
[13:36:36.162]     if (FALSE) {
[13:36:36.162]     }
[13:36:36.162]     else {
[13:36:36.162]         if (TRUE) {
[13:36:36.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.162]                 open = "w")
[13:36:36.162]         }
[13:36:36.162]         else {
[13:36:36.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.162]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.162]         }
[13:36:36.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.162]             base::sink(type = "output", split = FALSE)
[13:36:36.162]             base::close(...future.stdout)
[13:36:36.162]         }, add = TRUE)
[13:36:36.162]     }
[13:36:36.162]     ...future.frame <- base::sys.nframe()
[13:36:36.162]     ...future.conditions <- base::list()
[13:36:36.162]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.162]     if (FALSE) {
[13:36:36.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.162]     }
[13:36:36.162]     ...future.result <- base::tryCatch({
[13:36:36.162]         base::withCallingHandlers({
[13:36:36.162]             ...future.value <- base::withVisible(base::local({
[13:36:36.162]                 withCallingHandlers({
[13:36:36.162]                   {
[13:36:36.162]                     4
[13:36:36.162]                   }
[13:36:36.162]                 }, immediateCondition = function(cond) {
[13:36:36.162]                   save_rds <- function (object, pathname, ...) 
[13:36:36.162]                   {
[13:36:36.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.162]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.162]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.162]                         fi_tmp[["mtime"]])
[13:36:36.162]                     }
[13:36:36.162]                     tryCatch({
[13:36:36.162]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.162]                     }, error = function(ex) {
[13:36:36.162]                       msg <- conditionMessage(ex)
[13:36:36.162]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.162]                         fi_tmp[["mtime"]], msg)
[13:36:36.162]                       ex$message <- msg
[13:36:36.162]                       stop(ex)
[13:36:36.162]                     })
[13:36:36.162]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.162]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.162]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.162]                       fi <- file.info(pathname)
[13:36:36.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.162]                         fi[["size"]], fi[["mtime"]])
[13:36:36.162]                       stop(msg)
[13:36:36.162]                     }
[13:36:36.162]                     invisible(pathname)
[13:36:36.162]                   }
[13:36:36.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.162]                     rootPath = tempdir()) 
[13:36:36.162]                   {
[13:36:36.162]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.162]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.162]                       tmpdir = path, fileext = ".rds")
[13:36:36.162]                     save_rds(obj, file)
[13:36:36.162]                   }
[13:36:36.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.162]                   {
[13:36:36.162]                     inherits <- base::inherits
[13:36:36.162]                     invokeRestart <- base::invokeRestart
[13:36:36.162]                     is.null <- base::is.null
[13:36:36.162]                     muffled <- FALSE
[13:36:36.162]                     if (inherits(cond, "message")) {
[13:36:36.162]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.162]                       if (muffled) 
[13:36:36.162]                         invokeRestart("muffleMessage")
[13:36:36.162]                     }
[13:36:36.162]                     else if (inherits(cond, "warning")) {
[13:36:36.162]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.162]                       if (muffled) 
[13:36:36.162]                         invokeRestart("muffleWarning")
[13:36:36.162]                     }
[13:36:36.162]                     else if (inherits(cond, "condition")) {
[13:36:36.162]                       if (!is.null(pattern)) {
[13:36:36.162]                         computeRestarts <- base::computeRestarts
[13:36:36.162]                         grepl <- base::grepl
[13:36:36.162]                         restarts <- computeRestarts(cond)
[13:36:36.162]                         for (restart in restarts) {
[13:36:36.162]                           name <- restart$name
[13:36:36.162]                           if (is.null(name)) 
[13:36:36.162]                             next
[13:36:36.162]                           if (!grepl(pattern, name)) 
[13:36:36.162]                             next
[13:36:36.162]                           invokeRestart(restart)
[13:36:36.162]                           muffled <- TRUE
[13:36:36.162]                           break
[13:36:36.162]                         }
[13:36:36.162]                       }
[13:36:36.162]                     }
[13:36:36.162]                     invisible(muffled)
[13:36:36.162]                   }
[13:36:36.162]                   muffleCondition(cond)
[13:36:36.162]                 })
[13:36:36.162]             }))
[13:36:36.162]             future::FutureResult(value = ...future.value$value, 
[13:36:36.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.162]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.162]                     ...future.globalenv.names))
[13:36:36.162]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.162]         }, condition = base::local({
[13:36:36.162]             c <- base::c
[13:36:36.162]             inherits <- base::inherits
[13:36:36.162]             invokeRestart <- base::invokeRestart
[13:36:36.162]             length <- base::length
[13:36:36.162]             list <- base::list
[13:36:36.162]             seq.int <- base::seq.int
[13:36:36.162]             signalCondition <- base::signalCondition
[13:36:36.162]             sys.calls <- base::sys.calls
[13:36:36.162]             `[[` <- base::`[[`
[13:36:36.162]             `+` <- base::`+`
[13:36:36.162]             `<<-` <- base::`<<-`
[13:36:36.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.162]                   3L)]
[13:36:36.162]             }
[13:36:36.162]             function(cond) {
[13:36:36.162]                 is_error <- inherits(cond, "error")
[13:36:36.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.162]                   NULL)
[13:36:36.162]                 if (is_error) {
[13:36:36.162]                   sessionInformation <- function() {
[13:36:36.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.162]                       search = base::search(), system = base::Sys.info())
[13:36:36.162]                   }
[13:36:36.162]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.162]                     cond$call), session = sessionInformation(), 
[13:36:36.162]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.162]                   signalCondition(cond)
[13:36:36.162]                 }
[13:36:36.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.162]                 "immediateCondition"))) {
[13:36:36.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.162]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.162]                   if (TRUE && !signal) {
[13:36:36.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.162]                     {
[13:36:36.162]                       inherits <- base::inherits
[13:36:36.162]                       invokeRestart <- base::invokeRestart
[13:36:36.162]                       is.null <- base::is.null
[13:36:36.162]                       muffled <- FALSE
[13:36:36.162]                       if (inherits(cond, "message")) {
[13:36:36.162]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.162]                         if (muffled) 
[13:36:36.162]                           invokeRestart("muffleMessage")
[13:36:36.162]                       }
[13:36:36.162]                       else if (inherits(cond, "warning")) {
[13:36:36.162]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.162]                         if (muffled) 
[13:36:36.162]                           invokeRestart("muffleWarning")
[13:36:36.162]                       }
[13:36:36.162]                       else if (inherits(cond, "condition")) {
[13:36:36.162]                         if (!is.null(pattern)) {
[13:36:36.162]                           computeRestarts <- base::computeRestarts
[13:36:36.162]                           grepl <- base::grepl
[13:36:36.162]                           restarts <- computeRestarts(cond)
[13:36:36.162]                           for (restart in restarts) {
[13:36:36.162]                             name <- restart$name
[13:36:36.162]                             if (is.null(name)) 
[13:36:36.162]                               next
[13:36:36.162]                             if (!grepl(pattern, name)) 
[13:36:36.162]                               next
[13:36:36.162]                             invokeRestart(restart)
[13:36:36.162]                             muffled <- TRUE
[13:36:36.162]                             break
[13:36:36.162]                           }
[13:36:36.162]                         }
[13:36:36.162]                       }
[13:36:36.162]                       invisible(muffled)
[13:36:36.162]                     }
[13:36:36.162]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.162]                   }
[13:36:36.162]                 }
[13:36:36.162]                 else {
[13:36:36.162]                   if (TRUE) {
[13:36:36.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.162]                     {
[13:36:36.162]                       inherits <- base::inherits
[13:36:36.162]                       invokeRestart <- base::invokeRestart
[13:36:36.162]                       is.null <- base::is.null
[13:36:36.162]                       muffled <- FALSE
[13:36:36.162]                       if (inherits(cond, "message")) {
[13:36:36.162]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.162]                         if (muffled) 
[13:36:36.162]                           invokeRestart("muffleMessage")
[13:36:36.162]                       }
[13:36:36.162]                       else if (inherits(cond, "warning")) {
[13:36:36.162]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.162]                         if (muffled) 
[13:36:36.162]                           invokeRestart("muffleWarning")
[13:36:36.162]                       }
[13:36:36.162]                       else if (inherits(cond, "condition")) {
[13:36:36.162]                         if (!is.null(pattern)) {
[13:36:36.162]                           computeRestarts <- base::computeRestarts
[13:36:36.162]                           grepl <- base::grepl
[13:36:36.162]                           restarts <- computeRestarts(cond)
[13:36:36.162]                           for (restart in restarts) {
[13:36:36.162]                             name <- restart$name
[13:36:36.162]                             if (is.null(name)) 
[13:36:36.162]                               next
[13:36:36.162]                             if (!grepl(pattern, name)) 
[13:36:36.162]                               next
[13:36:36.162]                             invokeRestart(restart)
[13:36:36.162]                             muffled <- TRUE
[13:36:36.162]                             break
[13:36:36.162]                           }
[13:36:36.162]                         }
[13:36:36.162]                       }
[13:36:36.162]                       invisible(muffled)
[13:36:36.162]                     }
[13:36:36.162]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.162]                   }
[13:36:36.162]                 }
[13:36:36.162]             }
[13:36:36.162]         }))
[13:36:36.162]     }, error = function(ex) {
[13:36:36.162]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.162]                 ...future.rng), started = ...future.startTime, 
[13:36:36.162]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.162]             version = "1.8"), class = "FutureResult")
[13:36:36.162]     }, finally = {
[13:36:36.162]         if (!identical(...future.workdir, getwd())) 
[13:36:36.162]             setwd(...future.workdir)
[13:36:36.162]         {
[13:36:36.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.162]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.162]             }
[13:36:36.162]             base::options(...future.oldOptions)
[13:36:36.162]             if (.Platform$OS.type == "windows") {
[13:36:36.162]                 old_names <- names(...future.oldEnvVars)
[13:36:36.162]                 envs <- base::Sys.getenv()
[13:36:36.162]                 names <- names(envs)
[13:36:36.162]                 common <- intersect(names, old_names)
[13:36:36.162]                 added <- setdiff(names, old_names)
[13:36:36.162]                 removed <- setdiff(old_names, names)
[13:36:36.162]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.162]                   envs[common]]
[13:36:36.162]                 NAMES <- toupper(changed)
[13:36:36.162]                 args <- list()
[13:36:36.162]                 for (kk in seq_along(NAMES)) {
[13:36:36.162]                   name <- changed[[kk]]
[13:36:36.162]                   NAME <- NAMES[[kk]]
[13:36:36.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.162]                     next
[13:36:36.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.162]                 }
[13:36:36.162]                 NAMES <- toupper(added)
[13:36:36.162]                 for (kk in seq_along(NAMES)) {
[13:36:36.162]                   name <- added[[kk]]
[13:36:36.162]                   NAME <- NAMES[[kk]]
[13:36:36.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.162]                     next
[13:36:36.162]                   args[[name]] <- ""
[13:36:36.162]                 }
[13:36:36.162]                 NAMES <- toupper(removed)
[13:36:36.162]                 for (kk in seq_along(NAMES)) {
[13:36:36.162]                   name <- removed[[kk]]
[13:36:36.162]                   NAME <- NAMES[[kk]]
[13:36:36.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.162]                     next
[13:36:36.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.162]                 }
[13:36:36.162]                 if (length(args) > 0) 
[13:36:36.162]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.162]             }
[13:36:36.162]             else {
[13:36:36.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.162]             }
[13:36:36.162]             {
[13:36:36.162]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.162]                   0L) {
[13:36:36.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.162]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.162]                   base::options(opts)
[13:36:36.162]                 }
[13:36:36.162]                 {
[13:36:36.162]                   {
[13:36:36.162]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.162]                     NULL
[13:36:36.162]                   }
[13:36:36.162]                   options(future.plan = NULL)
[13:36:36.162]                   if (is.na(NA_character_)) 
[13:36:36.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.162]                     .init = FALSE)
[13:36:36.162]                 }
[13:36:36.162]             }
[13:36:36.162]         }
[13:36:36.162]     })
[13:36:36.162]     if (TRUE) {
[13:36:36.162]         base::sink(type = "output", split = FALSE)
[13:36:36.162]         if (TRUE) {
[13:36:36.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.162]         }
[13:36:36.162]         else {
[13:36:36.162]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.162]         }
[13:36:36.162]         base::close(...future.stdout)
[13:36:36.162]         ...future.stdout <- NULL
[13:36:36.162]     }
[13:36:36.162]     ...future.result$conditions <- ...future.conditions
[13:36:36.162]     ...future.result$finished <- base::Sys.time()
[13:36:36.162]     ...future.result
[13:36:36.162] }
[13:36:36.166] requestCore(): workers = 2
[13:36:36.166] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:36.177] result() for MulticoreFuture ...
[13:36:36.178] result() for MulticoreFuture ...
[13:36:36.178] result() for MulticoreFuture ... done
[13:36:36.178] result() for MulticoreFuture ... done
[13:36:36.178] result() for MulticoreFuture ...
[13:36:36.179] result() for MulticoreFuture ... done
[13:36:36.181] MulticoreFuture started
[13:36:36.182] - Launch lazy future ... done
[13:36:36.182] run() for ‘MulticoreFuture’ ... done
[13:36:36.183] plan(): Setting new future strategy stack:
<environment: 0x564a750ab830> 
[13:36:36.183] List of future strategies:
[13:36:36.183] 1. sequential:
[13:36:36.183]    - args: function (..., envir = parent.frame())
[13:36:36.183]    - tweaked: FALSE
[13:36:36.183]    - call: NULL
[13:36:36.184] plan(): nbrOfWorkers() = 1
<environment: 0x564a72c33a38> 
[13:36:36.187] plan(): Setting new future strategy stack:
[13:36:36.187] List of future strategies:
[13:36:36.187] 1. multicore:
[13:36:36.187]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.187]    - tweaked: FALSE
[13:36:36.187]    - call: plan(strategy)
[13:36:36.192] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:36.195] resolve() on environment ...
[13:36:36.195]  recursive: 0
[13:36:36.196]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:36.196] signalConditionsASAP(numeric, pos=1) ...
[13:36:36.196] - nx: 4
[13:36:36.196] - relay: TRUE
[13:36:36.196] - stdout: TRUE
[13:36:36.197] - signal: TRUE
[13:36:36.197] - resignal: FALSE
[13:36:36.197] - force: TRUE
[13:36:36.197] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.197] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.198]  - until=2
[13:36:36.198]  - relaying element #2
[13:36:36.198] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.198] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.198] signalConditionsASAP(NULL, pos=1) ... done
[13:36:36.198]  length: 3 (resolved future 1)
[13:36:36.199] Future #2
[13:36:36.199] result() for MulticoreFuture ...
[13:36:36.199] result() for MulticoreFuture ... done
[13:36:36.199] result() for MulticoreFuture ...
[13:36:36.199] result() for MulticoreFuture ... done
[13:36:36.199] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:36.200] - nx: 4
[13:36:36.200] - relay: TRUE
[13:36:36.200] - stdout: TRUE
[13:36:36.200] - signal: TRUE
[13:36:36.200] - resignal: FALSE
[13:36:36.200] - force: TRUE
[13:36:36.200] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.201] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.201]  - until=2
[13:36:36.201]  - relaying element #2
[13:36:36.201] result() for MulticoreFuture ...
[13:36:36.201] result() for MulticoreFuture ... done
[13:36:36.201] result() for MulticoreFuture ...
[13:36:36.202] result() for MulticoreFuture ... done
[13:36:36.202] result() for MulticoreFuture ...
[13:36:36.202] result() for MulticoreFuture ... done
[13:36:36.202] result() for MulticoreFuture ...
[13:36:36.202] result() for MulticoreFuture ... done
[13:36:36.203] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.203] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.203] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:36.203]  length: 2 (resolved future 2)
[13:36:36.204] Future #3
[13:36:36.204] result() for MulticoreFuture ...
[13:36:36.205] result() for MulticoreFuture ...
[13:36:36.205] result() for MulticoreFuture ... done
[13:36:36.205] result() for MulticoreFuture ... done
[13:36:36.205] result() for MulticoreFuture ...
[13:36:36.206] result() for MulticoreFuture ... done
[13:36:36.206] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:36.206] - nx: 4
[13:36:36.206] - relay: TRUE
[13:36:36.206] - stdout: TRUE
[13:36:36.207] - signal: TRUE
[13:36:36.207] - resignal: FALSE
[13:36:36.207] - force: TRUE
[13:36:36.207] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.207] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.208]  - until=3
[13:36:36.208]  - relaying element #3
[13:36:36.208] result() for MulticoreFuture ...
[13:36:36.208] result() for MulticoreFuture ... done
[13:36:36.208] result() for MulticoreFuture ...
[13:36:36.208] result() for MulticoreFuture ... done
[13:36:36.209] result() for MulticoreFuture ...
[13:36:36.209] result() for MulticoreFuture ... done
[13:36:36.209] result() for MulticoreFuture ...
[13:36:36.209] result() for MulticoreFuture ... done
[13:36:36.209] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.209] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.210] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:36.210]  length: 1 (resolved future 3)
[13:36:36.210] Future #4
[13:36:36.210] result() for MulticoreFuture ...
[13:36:36.211] result() for MulticoreFuture ...
[13:36:36.211] result() for MulticoreFuture ... done
[13:36:36.212] result() for MulticoreFuture ... done
[13:36:36.212] result() for MulticoreFuture ...
[13:36:36.212] result() for MulticoreFuture ... done
[13:36:36.212] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:36.212] - nx: 4
[13:36:36.212] - relay: TRUE
[13:36:36.213] - stdout: TRUE
[13:36:36.213] - signal: TRUE
[13:36:36.213] - resignal: FALSE
[13:36:36.213] - force: TRUE
[13:36:36.213] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.213] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.214]  - until=4
[13:36:36.214]  - relaying element #4
[13:36:36.214] result() for MulticoreFuture ...
[13:36:36.214] result() for MulticoreFuture ... done
[13:36:36.214] result() for MulticoreFuture ...
[13:36:36.214] result() for MulticoreFuture ... done
[13:36:36.215] result() for MulticoreFuture ...
[13:36:36.215] result() for MulticoreFuture ... done
[13:36:36.215] result() for MulticoreFuture ...
[13:36:36.215] result() for MulticoreFuture ... done
[13:36:36.215] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.215] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.216] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:36.216]  length: 0 (resolved future 4)
[13:36:36.216] Relaying remaining futures
[13:36:36.216] signalConditionsASAP(NULL, pos=0) ...
[13:36:36.216] - nx: 4
[13:36:36.216] - relay: TRUE
[13:36:36.216] - stdout: TRUE
[13:36:36.216] - signal: TRUE
[13:36:36.216] - resignal: FALSE
[13:36:36.216] - force: TRUE
[13:36:36.217] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.217] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:36.217] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.217] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.217] signalConditionsASAP(NULL, pos=0) ... done
[13:36:36.217] resolve() on environment ... DONE
[13:36:36.217] result() for MulticoreFuture ...
[13:36:36.217] result() for MulticoreFuture ... done
[13:36:36.218] result() for MulticoreFuture ...
[13:36:36.218] result() for MulticoreFuture ... done
[13:36:36.218] result() for MulticoreFuture ...
[13:36:36.218] result() for MulticoreFuture ... done
[13:36:36.218] result() for MulticoreFuture ...
[13:36:36.218] result() for MulticoreFuture ... done
[13:36:36.218] result() for MulticoreFuture ...
[13:36:36.218] result() for MulticoreFuture ... done
[13:36:36.218] result() for MulticoreFuture ...
[13:36:36.219] result() for MulticoreFuture ... done
<environment: 0x564a719aef48> 
Dimensions: c(2, 3, 1)
[13:36:36.219] getGlobalsAndPackages() ...
[13:36:36.219] Searching for globals...
[13:36:36.220] 
[13:36:36.220] Searching for globals ... DONE
[13:36:36.220] - globals: [0] <none>
[13:36:36.220] getGlobalsAndPackages() ... DONE
[13:36:36.220] run() for ‘Future’ ...
[13:36:36.220] - state: ‘created’
[13:36:36.221] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.224] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.225] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.225]   - Field: ‘label’
[13:36:36.225]   - Field: ‘local’
[13:36:36.225]   - Field: ‘owner’
[13:36:36.225]   - Field: ‘envir’
[13:36:36.225]   - Field: ‘workers’
[13:36:36.225]   - Field: ‘packages’
[13:36:36.225]   - Field: ‘gc’
[13:36:36.225]   - Field: ‘job’
[13:36:36.226]   - Field: ‘conditions’
[13:36:36.226]   - Field: ‘expr’
[13:36:36.226]   - Field: ‘uuid’
[13:36:36.226]   - Field: ‘seed’
[13:36:36.226]   - Field: ‘version’
[13:36:36.226]   - Field: ‘result’
[13:36:36.226]   - Field: ‘asynchronous’
[13:36:36.226]   - Field: ‘calls’
[13:36:36.226]   - Field: ‘globals’
[13:36:36.227]   - Field: ‘stdout’
[13:36:36.227]   - Field: ‘earlySignal’
[13:36:36.227]   - Field: ‘lazy’
[13:36:36.227]   - Field: ‘state’
[13:36:36.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.227] - Launch lazy future ...
[13:36:36.227] Packages needed by the future expression (n = 0): <none>
[13:36:36.228] Packages needed by future strategies (n = 0): <none>
[13:36:36.228] {
[13:36:36.228]     {
[13:36:36.228]         {
[13:36:36.228]             ...future.startTime <- base::Sys.time()
[13:36:36.228]             {
[13:36:36.228]                 {
[13:36:36.228]                   {
[13:36:36.228]                     {
[13:36:36.228]                       base::local({
[13:36:36.228]                         has_future <- base::requireNamespace("future", 
[13:36:36.228]                           quietly = TRUE)
[13:36:36.228]                         if (has_future) {
[13:36:36.228]                           ns <- base::getNamespace("future")
[13:36:36.228]                           version <- ns[[".package"]][["version"]]
[13:36:36.228]                           if (is.null(version)) 
[13:36:36.228]                             version <- utils::packageVersion("future")
[13:36:36.228]                         }
[13:36:36.228]                         else {
[13:36:36.228]                           version <- NULL
[13:36:36.228]                         }
[13:36:36.228]                         if (!has_future || version < "1.8.0") {
[13:36:36.228]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.228]                             "", base::R.version$version.string), 
[13:36:36.228]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.228]                               "release", "version")], collapse = " "), 
[13:36:36.228]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.228]                             info)
[13:36:36.228]                           info <- base::paste(info, collapse = "; ")
[13:36:36.228]                           if (!has_future) {
[13:36:36.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.228]                               info)
[13:36:36.228]                           }
[13:36:36.228]                           else {
[13:36:36.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.228]                               info, version)
[13:36:36.228]                           }
[13:36:36.228]                           base::stop(msg)
[13:36:36.228]                         }
[13:36:36.228]                       })
[13:36:36.228]                     }
[13:36:36.228]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.228]                     base::options(mc.cores = 1L)
[13:36:36.228]                   }
[13:36:36.228]                   ...future.strategy.old <- future::plan("list")
[13:36:36.228]                   options(future.plan = NULL)
[13:36:36.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.228]                 }
[13:36:36.228]                 ...future.workdir <- getwd()
[13:36:36.228]             }
[13:36:36.228]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.228]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.228]         }
[13:36:36.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.228]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.228]             base::names(...future.oldOptions))
[13:36:36.228]     }
[13:36:36.228]     if (FALSE) {
[13:36:36.228]     }
[13:36:36.228]     else {
[13:36:36.228]         if (TRUE) {
[13:36:36.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.228]                 open = "w")
[13:36:36.228]         }
[13:36:36.228]         else {
[13:36:36.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.228]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.228]         }
[13:36:36.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.228]             base::sink(type = "output", split = FALSE)
[13:36:36.228]             base::close(...future.stdout)
[13:36:36.228]         }, add = TRUE)
[13:36:36.228]     }
[13:36:36.228]     ...future.frame <- base::sys.nframe()
[13:36:36.228]     ...future.conditions <- base::list()
[13:36:36.228]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.228]     if (FALSE) {
[13:36:36.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.228]     }
[13:36:36.228]     ...future.result <- base::tryCatch({
[13:36:36.228]         base::withCallingHandlers({
[13:36:36.228]             ...future.value <- base::withVisible(base::local({
[13:36:36.228]                 withCallingHandlers({
[13:36:36.228]                   2
[13:36:36.228]                 }, immediateCondition = function(cond) {
[13:36:36.228]                   save_rds <- function (object, pathname, ...) 
[13:36:36.228]                   {
[13:36:36.228]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.228]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.228]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.228]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.228]                         fi_tmp[["mtime"]])
[13:36:36.228]                     }
[13:36:36.228]                     tryCatch({
[13:36:36.228]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.228]                     }, error = function(ex) {
[13:36:36.228]                       msg <- conditionMessage(ex)
[13:36:36.228]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.228]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.228]                         fi_tmp[["mtime"]], msg)
[13:36:36.228]                       ex$message <- msg
[13:36:36.228]                       stop(ex)
[13:36:36.228]                     })
[13:36:36.228]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.228]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.228]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.228]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.228]                       fi <- file.info(pathname)
[13:36:36.228]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.228]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.228]                         fi[["size"]], fi[["mtime"]])
[13:36:36.228]                       stop(msg)
[13:36:36.228]                     }
[13:36:36.228]                     invisible(pathname)
[13:36:36.228]                   }
[13:36:36.228]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.228]                     rootPath = tempdir()) 
[13:36:36.228]                   {
[13:36:36.228]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.228]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.228]                       tmpdir = path, fileext = ".rds")
[13:36:36.228]                     save_rds(obj, file)
[13:36:36.228]                   }
[13:36:36.228]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.228]                   {
[13:36:36.228]                     inherits <- base::inherits
[13:36:36.228]                     invokeRestart <- base::invokeRestart
[13:36:36.228]                     is.null <- base::is.null
[13:36:36.228]                     muffled <- FALSE
[13:36:36.228]                     if (inherits(cond, "message")) {
[13:36:36.228]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.228]                       if (muffled) 
[13:36:36.228]                         invokeRestart("muffleMessage")
[13:36:36.228]                     }
[13:36:36.228]                     else if (inherits(cond, "warning")) {
[13:36:36.228]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.228]                       if (muffled) 
[13:36:36.228]                         invokeRestart("muffleWarning")
[13:36:36.228]                     }
[13:36:36.228]                     else if (inherits(cond, "condition")) {
[13:36:36.228]                       if (!is.null(pattern)) {
[13:36:36.228]                         computeRestarts <- base::computeRestarts
[13:36:36.228]                         grepl <- base::grepl
[13:36:36.228]                         restarts <- computeRestarts(cond)
[13:36:36.228]                         for (restart in restarts) {
[13:36:36.228]                           name <- restart$name
[13:36:36.228]                           if (is.null(name)) 
[13:36:36.228]                             next
[13:36:36.228]                           if (!grepl(pattern, name)) 
[13:36:36.228]                             next
[13:36:36.228]                           invokeRestart(restart)
[13:36:36.228]                           muffled <- TRUE
[13:36:36.228]                           break
[13:36:36.228]                         }
[13:36:36.228]                       }
[13:36:36.228]                     }
[13:36:36.228]                     invisible(muffled)
[13:36:36.228]                   }
[13:36:36.228]                   muffleCondition(cond)
[13:36:36.228]                 })
[13:36:36.228]             }))
[13:36:36.228]             future::FutureResult(value = ...future.value$value, 
[13:36:36.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.228]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.228]                     ...future.globalenv.names))
[13:36:36.228]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.228]         }, condition = base::local({
[13:36:36.228]             c <- base::c
[13:36:36.228]             inherits <- base::inherits
[13:36:36.228]             invokeRestart <- base::invokeRestart
[13:36:36.228]             length <- base::length
[13:36:36.228]             list <- base::list
[13:36:36.228]             seq.int <- base::seq.int
[13:36:36.228]             signalCondition <- base::signalCondition
[13:36:36.228]             sys.calls <- base::sys.calls
[13:36:36.228]             `[[` <- base::`[[`
[13:36:36.228]             `+` <- base::`+`
[13:36:36.228]             `<<-` <- base::`<<-`
[13:36:36.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.228]                   3L)]
[13:36:36.228]             }
[13:36:36.228]             function(cond) {
[13:36:36.228]                 is_error <- inherits(cond, "error")
[13:36:36.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.228]                   NULL)
[13:36:36.228]                 if (is_error) {
[13:36:36.228]                   sessionInformation <- function() {
[13:36:36.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.228]                       search = base::search(), system = base::Sys.info())
[13:36:36.228]                   }
[13:36:36.228]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.228]                     cond$call), session = sessionInformation(), 
[13:36:36.228]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.228]                   signalCondition(cond)
[13:36:36.228]                 }
[13:36:36.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.228]                 "immediateCondition"))) {
[13:36:36.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.228]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.228]                   if (TRUE && !signal) {
[13:36:36.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.228]                     {
[13:36:36.228]                       inherits <- base::inherits
[13:36:36.228]                       invokeRestart <- base::invokeRestart
[13:36:36.228]                       is.null <- base::is.null
[13:36:36.228]                       muffled <- FALSE
[13:36:36.228]                       if (inherits(cond, "message")) {
[13:36:36.228]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.228]                         if (muffled) 
[13:36:36.228]                           invokeRestart("muffleMessage")
[13:36:36.228]                       }
[13:36:36.228]                       else if (inherits(cond, "warning")) {
[13:36:36.228]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.228]                         if (muffled) 
[13:36:36.228]                           invokeRestart("muffleWarning")
[13:36:36.228]                       }
[13:36:36.228]                       else if (inherits(cond, "condition")) {
[13:36:36.228]                         if (!is.null(pattern)) {
[13:36:36.228]                           computeRestarts <- base::computeRestarts
[13:36:36.228]                           grepl <- base::grepl
[13:36:36.228]                           restarts <- computeRestarts(cond)
[13:36:36.228]                           for (restart in restarts) {
[13:36:36.228]                             name <- restart$name
[13:36:36.228]                             if (is.null(name)) 
[13:36:36.228]                               next
[13:36:36.228]                             if (!grepl(pattern, name)) 
[13:36:36.228]                               next
[13:36:36.228]                             invokeRestart(restart)
[13:36:36.228]                             muffled <- TRUE
[13:36:36.228]                             break
[13:36:36.228]                           }
[13:36:36.228]                         }
[13:36:36.228]                       }
[13:36:36.228]                       invisible(muffled)
[13:36:36.228]                     }
[13:36:36.228]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.228]                   }
[13:36:36.228]                 }
[13:36:36.228]                 else {
[13:36:36.228]                   if (TRUE) {
[13:36:36.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.228]                     {
[13:36:36.228]                       inherits <- base::inherits
[13:36:36.228]                       invokeRestart <- base::invokeRestart
[13:36:36.228]                       is.null <- base::is.null
[13:36:36.228]                       muffled <- FALSE
[13:36:36.228]                       if (inherits(cond, "message")) {
[13:36:36.228]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.228]                         if (muffled) 
[13:36:36.228]                           invokeRestart("muffleMessage")
[13:36:36.228]                       }
[13:36:36.228]                       else if (inherits(cond, "warning")) {
[13:36:36.228]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.228]                         if (muffled) 
[13:36:36.228]                           invokeRestart("muffleWarning")
[13:36:36.228]                       }
[13:36:36.228]                       else if (inherits(cond, "condition")) {
[13:36:36.228]                         if (!is.null(pattern)) {
[13:36:36.228]                           computeRestarts <- base::computeRestarts
[13:36:36.228]                           grepl <- base::grepl
[13:36:36.228]                           restarts <- computeRestarts(cond)
[13:36:36.228]                           for (restart in restarts) {
[13:36:36.228]                             name <- restart$name
[13:36:36.228]                             if (is.null(name)) 
[13:36:36.228]                               next
[13:36:36.228]                             if (!grepl(pattern, name)) 
[13:36:36.228]                               next
[13:36:36.228]                             invokeRestart(restart)
[13:36:36.228]                             muffled <- TRUE
[13:36:36.228]                             break
[13:36:36.228]                           }
[13:36:36.228]                         }
[13:36:36.228]                       }
[13:36:36.228]                       invisible(muffled)
[13:36:36.228]                     }
[13:36:36.228]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.228]                   }
[13:36:36.228]                 }
[13:36:36.228]             }
[13:36:36.228]         }))
[13:36:36.228]     }, error = function(ex) {
[13:36:36.228]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.228]                 ...future.rng), started = ...future.startTime, 
[13:36:36.228]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.228]             version = "1.8"), class = "FutureResult")
[13:36:36.228]     }, finally = {
[13:36:36.228]         if (!identical(...future.workdir, getwd())) 
[13:36:36.228]             setwd(...future.workdir)
[13:36:36.228]         {
[13:36:36.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.228]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.228]             }
[13:36:36.228]             base::options(...future.oldOptions)
[13:36:36.228]             if (.Platform$OS.type == "windows") {
[13:36:36.228]                 old_names <- names(...future.oldEnvVars)
[13:36:36.228]                 envs <- base::Sys.getenv()
[13:36:36.228]                 names <- names(envs)
[13:36:36.228]                 common <- intersect(names, old_names)
[13:36:36.228]                 added <- setdiff(names, old_names)
[13:36:36.228]                 removed <- setdiff(old_names, names)
[13:36:36.228]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.228]                   envs[common]]
[13:36:36.228]                 NAMES <- toupper(changed)
[13:36:36.228]                 args <- list()
[13:36:36.228]                 for (kk in seq_along(NAMES)) {
[13:36:36.228]                   name <- changed[[kk]]
[13:36:36.228]                   NAME <- NAMES[[kk]]
[13:36:36.228]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.228]                     next
[13:36:36.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.228]                 }
[13:36:36.228]                 NAMES <- toupper(added)
[13:36:36.228]                 for (kk in seq_along(NAMES)) {
[13:36:36.228]                   name <- added[[kk]]
[13:36:36.228]                   NAME <- NAMES[[kk]]
[13:36:36.228]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.228]                     next
[13:36:36.228]                   args[[name]] <- ""
[13:36:36.228]                 }
[13:36:36.228]                 NAMES <- toupper(removed)
[13:36:36.228]                 for (kk in seq_along(NAMES)) {
[13:36:36.228]                   name <- removed[[kk]]
[13:36:36.228]                   NAME <- NAMES[[kk]]
[13:36:36.228]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.228]                     next
[13:36:36.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.228]                 }
[13:36:36.228]                 if (length(args) > 0) 
[13:36:36.228]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.228]             }
[13:36:36.228]             else {
[13:36:36.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.228]             }
[13:36:36.228]             {
[13:36:36.228]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.228]                   0L) {
[13:36:36.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.228]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.228]                   base::options(opts)
[13:36:36.228]                 }
[13:36:36.228]                 {
[13:36:36.228]                   {
[13:36:36.228]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.228]                     NULL
[13:36:36.228]                   }
[13:36:36.228]                   options(future.plan = NULL)
[13:36:36.228]                   if (is.na(NA_character_)) 
[13:36:36.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.228]                     .init = FALSE)
[13:36:36.228]                 }
[13:36:36.228]             }
[13:36:36.228]         }
[13:36:36.228]     })
[13:36:36.228]     if (TRUE) {
[13:36:36.228]         base::sink(type = "output", split = FALSE)
[13:36:36.228]         if (TRUE) {
[13:36:36.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.228]         }
[13:36:36.228]         else {
[13:36:36.228]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.228]         }
[13:36:36.228]         base::close(...future.stdout)
[13:36:36.228]         ...future.stdout <- NULL
[13:36:36.228]     }
[13:36:36.228]     ...future.result$conditions <- ...future.conditions
[13:36:36.228]     ...future.result$finished <- base::Sys.time()
[13:36:36.228]     ...future.result
[13:36:36.228] }
[13:36:36.231] requestCore(): workers = 2
[13:36:36.233] MulticoreFuture started
[13:36:36.233] - Launch lazy future ... done
[13:36:36.233] run() for ‘MulticoreFuture’ ... done
[13:36:36.233] getGlobalsAndPackages() ...
[13:36:36.234] Searching for globals...
[13:36:36.234] plan(): Setting new future strategy stack:
[13:36:36.234] 
[13:36:36.235] Searching for globals ... DONE
[13:36:36.234] List of future strategies:
[13:36:36.234] 1. sequential:
[13:36:36.234]    - args: function (..., envir = parent.frame())
[13:36:36.234]    - tweaked: FALSE
[13:36:36.234]    - call: NULL
[13:36:36.235] - globals: [0] <none>
[13:36:36.235] plan(): nbrOfWorkers() = 1
[13:36:36.235] getGlobalsAndPackages() ... DONE
[13:36:36.235] run() for ‘Future’ ...
[13:36:36.236] - state: ‘created’
[13:36:36.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.237] plan(): Setting new future strategy stack:
[13:36:36.237] List of future strategies:
[13:36:36.237] 1. multicore:
[13:36:36.237]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.237]    - tweaked: FALSE
[13:36:36.237]    - call: plan(strategy)
[13:36:36.241] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.241] plan(): nbrOfWorkers() = 2
[13:36:36.241] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.241]   - Field: ‘label’
[13:36:36.241]   - Field: ‘local’
[13:36:36.241]   - Field: ‘owner’
[13:36:36.242]   - Field: ‘envir’
[13:36:36.242]   - Field: ‘workers’
[13:36:36.242]   - Field: ‘packages’
[13:36:36.242]   - Field: ‘gc’
[13:36:36.242]   - Field: ‘job’
[13:36:36.242]   - Field: ‘conditions’
[13:36:36.243]   - Field: ‘expr’
[13:36:36.243]   - Field: ‘uuid’
[13:36:36.243]   - Field: ‘seed’
[13:36:36.243]   - Field: ‘version’
[13:36:36.243]   - Field: ‘result’
[13:36:36.243]   - Field: ‘asynchronous’
[13:36:36.243]   - Field: ‘calls’
[13:36:36.243]   - Field: ‘globals’
[13:36:36.244]   - Field: ‘stdout’
[13:36:36.244]   - Field: ‘earlySignal’
[13:36:36.244]   - Field: ‘lazy’
[13:36:36.244]   - Field: ‘state’
[13:36:36.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.244] - Launch lazy future ...
[13:36:36.245] Packages needed by the future expression (n = 0): <none>
[13:36:36.245] Packages needed by future strategies (n = 0): <none>
[13:36:36.246] {
[13:36:36.246]     {
[13:36:36.246]         {
[13:36:36.246]             ...future.startTime <- base::Sys.time()
[13:36:36.246]             {
[13:36:36.246]                 {
[13:36:36.246]                   {
[13:36:36.246]                     {
[13:36:36.246]                       base::local({
[13:36:36.246]                         has_future <- base::requireNamespace("future", 
[13:36:36.246]                           quietly = TRUE)
[13:36:36.246]                         if (has_future) {
[13:36:36.246]                           ns <- base::getNamespace("future")
[13:36:36.246]                           version <- ns[[".package"]][["version"]]
[13:36:36.246]                           if (is.null(version)) 
[13:36:36.246]                             version <- utils::packageVersion("future")
[13:36:36.246]                         }
[13:36:36.246]                         else {
[13:36:36.246]                           version <- NULL
[13:36:36.246]                         }
[13:36:36.246]                         if (!has_future || version < "1.8.0") {
[13:36:36.246]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.246]                             "", base::R.version$version.string), 
[13:36:36.246]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.246]                               "release", "version")], collapse = " "), 
[13:36:36.246]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.246]                             info)
[13:36:36.246]                           info <- base::paste(info, collapse = "; ")
[13:36:36.246]                           if (!has_future) {
[13:36:36.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.246]                               info)
[13:36:36.246]                           }
[13:36:36.246]                           else {
[13:36:36.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.246]                               info, version)
[13:36:36.246]                           }
[13:36:36.246]                           base::stop(msg)
[13:36:36.246]                         }
[13:36:36.246]                       })
[13:36:36.246]                     }
[13:36:36.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.246]                     base::options(mc.cores = 1L)
[13:36:36.246]                   }
[13:36:36.246]                   ...future.strategy.old <- future::plan("list")
[13:36:36.246]                   options(future.plan = NULL)
[13:36:36.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.246]                 }
[13:36:36.246]                 ...future.workdir <- getwd()
[13:36:36.246]             }
[13:36:36.246]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.246]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.246]         }
[13:36:36.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.246]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.246]             base::names(...future.oldOptions))
[13:36:36.246]     }
[13:36:36.246]     if (FALSE) {
[13:36:36.246]     }
[13:36:36.246]     else {
[13:36:36.246]         if (TRUE) {
[13:36:36.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.246]                 open = "w")
[13:36:36.246]         }
[13:36:36.246]         else {
[13:36:36.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.246]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.246]         }
[13:36:36.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.246]             base::sink(type = "output", split = FALSE)
[13:36:36.246]             base::close(...future.stdout)
[13:36:36.246]         }, add = TRUE)
[13:36:36.246]     }
[13:36:36.246]     ...future.frame <- base::sys.nframe()
[13:36:36.246]     ...future.conditions <- base::list()
[13:36:36.246]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.246]     if (FALSE) {
[13:36:36.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.246]     }
[13:36:36.246]     ...future.result <- base::tryCatch({
[13:36:36.246]         base::withCallingHandlers({
[13:36:36.246]             ...future.value <- base::withVisible(base::local({
[13:36:36.246]                 withCallingHandlers({
[13:36:36.246]                   NULL
[13:36:36.246]                 }, immediateCondition = function(cond) {
[13:36:36.246]                   save_rds <- function (object, pathname, ...) 
[13:36:36.246]                   {
[13:36:36.246]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.246]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.246]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.246]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.246]                         fi_tmp[["mtime"]])
[13:36:36.246]                     }
[13:36:36.246]                     tryCatch({
[13:36:36.246]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.246]                     }, error = function(ex) {
[13:36:36.246]                       msg <- conditionMessage(ex)
[13:36:36.246]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.246]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.246]                         fi_tmp[["mtime"]], msg)
[13:36:36.246]                       ex$message <- msg
[13:36:36.246]                       stop(ex)
[13:36:36.246]                     })
[13:36:36.246]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.246]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.246]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.246]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.246]                       fi <- file.info(pathname)
[13:36:36.246]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.246]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.246]                         fi[["size"]], fi[["mtime"]])
[13:36:36.246]                       stop(msg)
[13:36:36.246]                     }
[13:36:36.246]                     invisible(pathname)
[13:36:36.246]                   }
[13:36:36.246]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.246]                     rootPath = tempdir()) 
[13:36:36.246]                   {
[13:36:36.246]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.246]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.246]                       tmpdir = path, fileext = ".rds")
[13:36:36.246]                     save_rds(obj, file)
[13:36:36.246]                   }
[13:36:36.246]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.246]                   {
[13:36:36.246]                     inherits <- base::inherits
[13:36:36.246]                     invokeRestart <- base::invokeRestart
[13:36:36.246]                     is.null <- base::is.null
[13:36:36.246]                     muffled <- FALSE
[13:36:36.246]                     if (inherits(cond, "message")) {
[13:36:36.246]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.246]                       if (muffled) 
[13:36:36.246]                         invokeRestart("muffleMessage")
[13:36:36.246]                     }
[13:36:36.246]                     else if (inherits(cond, "warning")) {
[13:36:36.246]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.246]                       if (muffled) 
[13:36:36.246]                         invokeRestart("muffleWarning")
[13:36:36.246]                     }
[13:36:36.246]                     else if (inherits(cond, "condition")) {
[13:36:36.246]                       if (!is.null(pattern)) {
[13:36:36.246]                         computeRestarts <- base::computeRestarts
[13:36:36.246]                         grepl <- base::grepl
[13:36:36.246]                         restarts <- computeRestarts(cond)
[13:36:36.246]                         for (restart in restarts) {
[13:36:36.246]                           name <- restart$name
[13:36:36.246]                           if (is.null(name)) 
[13:36:36.246]                             next
[13:36:36.246]                           if (!grepl(pattern, name)) 
[13:36:36.246]                             next
[13:36:36.246]                           invokeRestart(restart)
[13:36:36.246]                           muffled <- TRUE
[13:36:36.246]                           break
[13:36:36.246]                         }
[13:36:36.246]                       }
[13:36:36.246]                     }
[13:36:36.246]                     invisible(muffled)
[13:36:36.246]                   }
[13:36:36.246]                   muffleCondition(cond)
[13:36:36.246]                 })
[13:36:36.246]             }))
[13:36:36.246]             future::FutureResult(value = ...future.value$value, 
[13:36:36.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.246]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.246]                     ...future.globalenv.names))
[13:36:36.246]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.246]         }, condition = base::local({
[13:36:36.246]             c <- base::c
[13:36:36.246]             inherits <- base::inherits
[13:36:36.246]             invokeRestart <- base::invokeRestart
[13:36:36.246]             length <- base::length
[13:36:36.246]             list <- base::list
[13:36:36.246]             seq.int <- base::seq.int
[13:36:36.246]             signalCondition <- base::signalCondition
[13:36:36.246]             sys.calls <- base::sys.calls
[13:36:36.246]             `[[` <- base::`[[`
[13:36:36.246]             `+` <- base::`+`
[13:36:36.246]             `<<-` <- base::`<<-`
[13:36:36.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.246]                   3L)]
[13:36:36.246]             }
[13:36:36.246]             function(cond) {
[13:36:36.246]                 is_error <- inherits(cond, "error")
[13:36:36.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.246]                   NULL)
[13:36:36.246]                 if (is_error) {
[13:36:36.246]                   sessionInformation <- function() {
[13:36:36.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.246]                       search = base::search(), system = base::Sys.info())
[13:36:36.246]                   }
[13:36:36.246]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.246]                     cond$call), session = sessionInformation(), 
[13:36:36.246]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.246]                   signalCondition(cond)
[13:36:36.246]                 }
[13:36:36.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.246]                 "immediateCondition"))) {
[13:36:36.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.246]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.246]                   if (TRUE && !signal) {
[13:36:36.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.246]                     {
[13:36:36.246]                       inherits <- base::inherits
[13:36:36.246]                       invokeRestart <- base::invokeRestart
[13:36:36.246]                       is.null <- base::is.null
[13:36:36.246]                       muffled <- FALSE
[13:36:36.246]                       if (inherits(cond, "message")) {
[13:36:36.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.246]                         if (muffled) 
[13:36:36.246]                           invokeRestart("muffleMessage")
[13:36:36.246]                       }
[13:36:36.246]                       else if (inherits(cond, "warning")) {
[13:36:36.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.246]                         if (muffled) 
[13:36:36.246]                           invokeRestart("muffleWarning")
[13:36:36.246]                       }
[13:36:36.246]                       else if (inherits(cond, "condition")) {
[13:36:36.246]                         if (!is.null(pattern)) {
[13:36:36.246]                           computeRestarts <- base::computeRestarts
[13:36:36.246]                           grepl <- base::grepl
[13:36:36.246]                           restarts <- computeRestarts(cond)
[13:36:36.246]                           for (restart in restarts) {
[13:36:36.246]                             name <- restart$name
[13:36:36.246]                             if (is.null(name)) 
[13:36:36.246]                               next
[13:36:36.246]                             if (!grepl(pattern, name)) 
[13:36:36.246]                               next
[13:36:36.246]                             invokeRestart(restart)
[13:36:36.246]                             muffled <- TRUE
[13:36:36.246]                             break
[13:36:36.246]                           }
[13:36:36.246]                         }
[13:36:36.246]                       }
[13:36:36.246]                       invisible(muffled)
[13:36:36.246]                     }
[13:36:36.246]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.246]                   }
[13:36:36.246]                 }
[13:36:36.246]                 else {
[13:36:36.246]                   if (TRUE) {
[13:36:36.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.246]                     {
[13:36:36.246]                       inherits <- base::inherits
[13:36:36.246]                       invokeRestart <- base::invokeRestart
[13:36:36.246]                       is.null <- base::is.null
[13:36:36.246]                       muffled <- FALSE
[13:36:36.246]                       if (inherits(cond, "message")) {
[13:36:36.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.246]                         if (muffled) 
[13:36:36.246]                           invokeRestart("muffleMessage")
[13:36:36.246]                       }
[13:36:36.246]                       else if (inherits(cond, "warning")) {
[13:36:36.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.246]                         if (muffled) 
[13:36:36.246]                           invokeRestart("muffleWarning")
[13:36:36.246]                       }
[13:36:36.246]                       else if (inherits(cond, "condition")) {
[13:36:36.246]                         if (!is.null(pattern)) {
[13:36:36.246]                           computeRestarts <- base::computeRestarts
[13:36:36.246]                           grepl <- base::grepl
[13:36:36.246]                           restarts <- computeRestarts(cond)
[13:36:36.246]                           for (restart in restarts) {
[13:36:36.246]                             name <- restart$name
[13:36:36.246]                             if (is.null(name)) 
[13:36:36.246]                               next
[13:36:36.246]                             if (!grepl(pattern, name)) 
[13:36:36.246]                               next
[13:36:36.246]                             invokeRestart(restart)
[13:36:36.246]                             muffled <- TRUE
[13:36:36.246]                             break
[13:36:36.246]                           }
[13:36:36.246]                         }
[13:36:36.246]                       }
[13:36:36.246]                       invisible(muffled)
[13:36:36.246]                     }
[13:36:36.246]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.246]                   }
[13:36:36.246]                 }
[13:36:36.246]             }
[13:36:36.246]         }))
[13:36:36.246]     }, error = function(ex) {
[13:36:36.246]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.246]                 ...future.rng), started = ...future.startTime, 
[13:36:36.246]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.246]             version = "1.8"), class = "FutureResult")
[13:36:36.246]     }, finally = {
[13:36:36.246]         if (!identical(...future.workdir, getwd())) 
[13:36:36.246]             setwd(...future.workdir)
[13:36:36.246]         {
[13:36:36.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.246]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.246]             }
[13:36:36.246]             base::options(...future.oldOptions)
[13:36:36.246]             if (.Platform$OS.type == "windows") {
[13:36:36.246]                 old_names <- names(...future.oldEnvVars)
[13:36:36.246]                 envs <- base::Sys.getenv()
[13:36:36.246]                 names <- names(envs)
[13:36:36.246]                 common <- intersect(names, old_names)
[13:36:36.246]                 added <- setdiff(names, old_names)
[13:36:36.246]                 removed <- setdiff(old_names, names)
[13:36:36.246]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.246]                   envs[common]]
[13:36:36.246]                 NAMES <- toupper(changed)
[13:36:36.246]                 args <- list()
[13:36:36.246]                 for (kk in seq_along(NAMES)) {
[13:36:36.246]                   name <- changed[[kk]]
[13:36:36.246]                   NAME <- NAMES[[kk]]
[13:36:36.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.246]                     next
[13:36:36.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.246]                 }
[13:36:36.246]                 NAMES <- toupper(added)
[13:36:36.246]                 for (kk in seq_along(NAMES)) {
[13:36:36.246]                   name <- added[[kk]]
[13:36:36.246]                   NAME <- NAMES[[kk]]
[13:36:36.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.246]                     next
[13:36:36.246]                   args[[name]] <- ""
[13:36:36.246]                 }
[13:36:36.246]                 NAMES <- toupper(removed)
[13:36:36.246]                 for (kk in seq_along(NAMES)) {
[13:36:36.246]                   name <- removed[[kk]]
[13:36:36.246]                   NAME <- NAMES[[kk]]
[13:36:36.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.246]                     next
[13:36:36.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.246]                 }
[13:36:36.246]                 if (length(args) > 0) 
[13:36:36.246]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.246]             }
[13:36:36.246]             else {
[13:36:36.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.246]             }
[13:36:36.246]             {
[13:36:36.246]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.246]                   0L) {
[13:36:36.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.246]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.246]                   base::options(opts)
[13:36:36.246]                 }
[13:36:36.246]                 {
[13:36:36.246]                   {
[13:36:36.246]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.246]                     NULL
[13:36:36.246]                   }
[13:36:36.246]                   options(future.plan = NULL)
[13:36:36.246]                   if (is.na(NA_character_)) 
[13:36:36.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.246]                     .init = FALSE)
[13:36:36.246]                 }
[13:36:36.246]             }
[13:36:36.246]         }
[13:36:36.246]     })
[13:36:36.246]     if (TRUE) {
[13:36:36.246]         base::sink(type = "output", split = FALSE)
[13:36:36.246]         if (TRUE) {
[13:36:36.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.246]         }
[13:36:36.246]         else {
[13:36:36.246]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.246]         }
[13:36:36.246]         base::close(...future.stdout)
[13:36:36.246]         ...future.stdout <- NULL
[13:36:36.246]     }
[13:36:36.246]     ...future.result$conditions <- ...future.conditions
[13:36:36.246]     ...future.result$finished <- base::Sys.time()
[13:36:36.246]     ...future.result
[13:36:36.246] }
[13:36:36.249] requestCore(): workers = 2
[13:36:36.251] MulticoreFuture started
[13:36:36.251] - Launch lazy future ... done
[13:36:36.252] run() for ‘MulticoreFuture’ ... done
[13:36:36.252] plan(): Setting new future strategy stack:
[13:36:36.252] getGlobalsAndPackages() ...
[13:36:36.253] Searching for globals...
[13:36:36.252] List of future strategies:
[13:36:36.252] 1. sequential:
[13:36:36.252]    - args: function (..., envir = parent.frame())
[13:36:36.252]    - tweaked: FALSE
[13:36:36.252]    - call: NULL
[13:36:36.253] plan(): nbrOfWorkers() = 1
[13:36:36.254] - globals found: [1] ‘{’
[13:36:36.254] Searching for globals ... DONE
[13:36:36.254] Resolving globals: FALSE
[13:36:36.255] 
[13:36:36.255] 
[13:36:36.255] getGlobalsAndPackages() ... DONE
[13:36:36.255] plan(): Setting new future strategy stack:
[13:36:36.256] run() for ‘Future’ ...
[13:36:36.255] List of future strategies:
[13:36:36.255] 1. multicore:
[13:36:36.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.255]    - tweaked: FALSE
[13:36:36.255]    - call: plan(strategy)
[13:36:36.256] - state: ‘created’
[13:36:36.256] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.260] plan(): nbrOfWorkers() = 2
[13:36:36.261] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.261]   - Field: ‘label’
[13:36:36.261]   - Field: ‘local’
[13:36:36.261]   - Field: ‘owner’
[13:36:36.261]   - Field: ‘envir’
[13:36:36.262]   - Field: ‘workers’
[13:36:36.262]   - Field: ‘packages’
[13:36:36.262]   - Field: ‘gc’
[13:36:36.262]   - Field: ‘job’
[13:36:36.262]   - Field: ‘conditions’
[13:36:36.262]   - Field: ‘expr’
[13:36:36.262]   - Field: ‘uuid’
[13:36:36.263]   - Field: ‘seed’
[13:36:36.263]   - Field: ‘version’
[13:36:36.263]   - Field: ‘result’
[13:36:36.263]   - Field: ‘asynchronous’
[13:36:36.263]   - Field: ‘calls’
[13:36:36.263]   - Field: ‘globals’
[13:36:36.263]   - Field: ‘stdout’
[13:36:36.264]   - Field: ‘earlySignal’
[13:36:36.264]   - Field: ‘lazy’
[13:36:36.264]   - Field: ‘state’
[13:36:36.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.264] - Launch lazy future ...
[13:36:36.265] Packages needed by the future expression (n = 0): <none>
[13:36:36.265] Packages needed by future strategies (n = 0): <none>
[13:36:36.265] {
[13:36:36.265]     {
[13:36:36.265]         {
[13:36:36.265]             ...future.startTime <- base::Sys.time()
[13:36:36.265]             {
[13:36:36.265]                 {
[13:36:36.265]                   {
[13:36:36.265]                     {
[13:36:36.265]                       base::local({
[13:36:36.265]                         has_future <- base::requireNamespace("future", 
[13:36:36.265]                           quietly = TRUE)
[13:36:36.265]                         if (has_future) {
[13:36:36.265]                           ns <- base::getNamespace("future")
[13:36:36.265]                           version <- ns[[".package"]][["version"]]
[13:36:36.265]                           if (is.null(version)) 
[13:36:36.265]                             version <- utils::packageVersion("future")
[13:36:36.265]                         }
[13:36:36.265]                         else {
[13:36:36.265]                           version <- NULL
[13:36:36.265]                         }
[13:36:36.265]                         if (!has_future || version < "1.8.0") {
[13:36:36.265]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.265]                             "", base::R.version$version.string), 
[13:36:36.265]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.265]                               "release", "version")], collapse = " "), 
[13:36:36.265]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.265]                             info)
[13:36:36.265]                           info <- base::paste(info, collapse = "; ")
[13:36:36.265]                           if (!has_future) {
[13:36:36.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.265]                               info)
[13:36:36.265]                           }
[13:36:36.265]                           else {
[13:36:36.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.265]                               info, version)
[13:36:36.265]                           }
[13:36:36.265]                           base::stop(msg)
[13:36:36.265]                         }
[13:36:36.265]                       })
[13:36:36.265]                     }
[13:36:36.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.265]                     base::options(mc.cores = 1L)
[13:36:36.265]                   }
[13:36:36.265]                   ...future.strategy.old <- future::plan("list")
[13:36:36.265]                   options(future.plan = NULL)
[13:36:36.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.265]                 }
[13:36:36.265]                 ...future.workdir <- getwd()
[13:36:36.265]             }
[13:36:36.265]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.265]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.265]         }
[13:36:36.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.265]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.265]             base::names(...future.oldOptions))
[13:36:36.265]     }
[13:36:36.265]     if (FALSE) {
[13:36:36.265]     }
[13:36:36.265]     else {
[13:36:36.265]         if (TRUE) {
[13:36:36.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.265]                 open = "w")
[13:36:36.265]         }
[13:36:36.265]         else {
[13:36:36.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.265]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.265]         }
[13:36:36.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.265]             base::sink(type = "output", split = FALSE)
[13:36:36.265]             base::close(...future.stdout)
[13:36:36.265]         }, add = TRUE)
[13:36:36.265]     }
[13:36:36.265]     ...future.frame <- base::sys.nframe()
[13:36:36.265]     ...future.conditions <- base::list()
[13:36:36.265]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.265]     if (FALSE) {
[13:36:36.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.265]     }
[13:36:36.265]     ...future.result <- base::tryCatch({
[13:36:36.265]         base::withCallingHandlers({
[13:36:36.265]             ...future.value <- base::withVisible(base::local({
[13:36:36.265]                 withCallingHandlers({
[13:36:36.265]                   {
[13:36:36.265]                     4
[13:36:36.265]                   }
[13:36:36.265]                 }, immediateCondition = function(cond) {
[13:36:36.265]                   save_rds <- function (object, pathname, ...) 
[13:36:36.265]                   {
[13:36:36.265]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.265]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.265]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.265]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.265]                         fi_tmp[["mtime"]])
[13:36:36.265]                     }
[13:36:36.265]                     tryCatch({
[13:36:36.265]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.265]                     }, error = function(ex) {
[13:36:36.265]                       msg <- conditionMessage(ex)
[13:36:36.265]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.265]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.265]                         fi_tmp[["mtime"]], msg)
[13:36:36.265]                       ex$message <- msg
[13:36:36.265]                       stop(ex)
[13:36:36.265]                     })
[13:36:36.265]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.265]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.265]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.265]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.265]                       fi <- file.info(pathname)
[13:36:36.265]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.265]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.265]                         fi[["size"]], fi[["mtime"]])
[13:36:36.265]                       stop(msg)
[13:36:36.265]                     }
[13:36:36.265]                     invisible(pathname)
[13:36:36.265]                   }
[13:36:36.265]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.265]                     rootPath = tempdir()) 
[13:36:36.265]                   {
[13:36:36.265]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.265]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.265]                       tmpdir = path, fileext = ".rds")
[13:36:36.265]                     save_rds(obj, file)
[13:36:36.265]                   }
[13:36:36.265]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.265]                   {
[13:36:36.265]                     inherits <- base::inherits
[13:36:36.265]                     invokeRestart <- base::invokeRestart
[13:36:36.265]                     is.null <- base::is.null
[13:36:36.265]                     muffled <- FALSE
[13:36:36.265]                     if (inherits(cond, "message")) {
[13:36:36.265]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.265]                       if (muffled) 
[13:36:36.265]                         invokeRestart("muffleMessage")
[13:36:36.265]                     }
[13:36:36.265]                     else if (inherits(cond, "warning")) {
[13:36:36.265]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.265]                       if (muffled) 
[13:36:36.265]                         invokeRestart("muffleWarning")
[13:36:36.265]                     }
[13:36:36.265]                     else if (inherits(cond, "condition")) {
[13:36:36.265]                       if (!is.null(pattern)) {
[13:36:36.265]                         computeRestarts <- base::computeRestarts
[13:36:36.265]                         grepl <- base::grepl
[13:36:36.265]                         restarts <- computeRestarts(cond)
[13:36:36.265]                         for (restart in restarts) {
[13:36:36.265]                           name <- restart$name
[13:36:36.265]                           if (is.null(name)) 
[13:36:36.265]                             next
[13:36:36.265]                           if (!grepl(pattern, name)) 
[13:36:36.265]                             next
[13:36:36.265]                           invokeRestart(restart)
[13:36:36.265]                           muffled <- TRUE
[13:36:36.265]                           break
[13:36:36.265]                         }
[13:36:36.265]                       }
[13:36:36.265]                     }
[13:36:36.265]                     invisible(muffled)
[13:36:36.265]                   }
[13:36:36.265]                   muffleCondition(cond)
[13:36:36.265]                 })
[13:36:36.265]             }))
[13:36:36.265]             future::FutureResult(value = ...future.value$value, 
[13:36:36.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.265]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.265]                     ...future.globalenv.names))
[13:36:36.265]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.265]         }, condition = base::local({
[13:36:36.265]             c <- base::c
[13:36:36.265]             inherits <- base::inherits
[13:36:36.265]             invokeRestart <- base::invokeRestart
[13:36:36.265]             length <- base::length
[13:36:36.265]             list <- base::list
[13:36:36.265]             seq.int <- base::seq.int
[13:36:36.265]             signalCondition <- base::signalCondition
[13:36:36.265]             sys.calls <- base::sys.calls
[13:36:36.265]             `[[` <- base::`[[`
[13:36:36.265]             `+` <- base::`+`
[13:36:36.265]             `<<-` <- base::`<<-`
[13:36:36.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.265]                   3L)]
[13:36:36.265]             }
[13:36:36.265]             function(cond) {
[13:36:36.265]                 is_error <- inherits(cond, "error")
[13:36:36.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.265]                   NULL)
[13:36:36.265]                 if (is_error) {
[13:36:36.265]                   sessionInformation <- function() {
[13:36:36.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.265]                       search = base::search(), system = base::Sys.info())
[13:36:36.265]                   }
[13:36:36.265]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.265]                     cond$call), session = sessionInformation(), 
[13:36:36.265]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.265]                   signalCondition(cond)
[13:36:36.265]                 }
[13:36:36.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.265]                 "immediateCondition"))) {
[13:36:36.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.265]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.265]                   if (TRUE && !signal) {
[13:36:36.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.265]                     {
[13:36:36.265]                       inherits <- base::inherits
[13:36:36.265]                       invokeRestart <- base::invokeRestart
[13:36:36.265]                       is.null <- base::is.null
[13:36:36.265]                       muffled <- FALSE
[13:36:36.265]                       if (inherits(cond, "message")) {
[13:36:36.265]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.265]                         if (muffled) 
[13:36:36.265]                           invokeRestart("muffleMessage")
[13:36:36.265]                       }
[13:36:36.265]                       else if (inherits(cond, "warning")) {
[13:36:36.265]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.265]                         if (muffled) 
[13:36:36.265]                           invokeRestart("muffleWarning")
[13:36:36.265]                       }
[13:36:36.265]                       else if (inherits(cond, "condition")) {
[13:36:36.265]                         if (!is.null(pattern)) {
[13:36:36.265]                           computeRestarts <- base::computeRestarts
[13:36:36.265]                           grepl <- base::grepl
[13:36:36.265]                           restarts <- computeRestarts(cond)
[13:36:36.265]                           for (restart in restarts) {
[13:36:36.265]                             name <- restart$name
[13:36:36.265]                             if (is.null(name)) 
[13:36:36.265]                               next
[13:36:36.265]                             if (!grepl(pattern, name)) 
[13:36:36.265]                               next
[13:36:36.265]                             invokeRestart(restart)
[13:36:36.265]                             muffled <- TRUE
[13:36:36.265]                             break
[13:36:36.265]                           }
[13:36:36.265]                         }
[13:36:36.265]                       }
[13:36:36.265]                       invisible(muffled)
[13:36:36.265]                     }
[13:36:36.265]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.265]                   }
[13:36:36.265]                 }
[13:36:36.265]                 else {
[13:36:36.265]                   if (TRUE) {
[13:36:36.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.265]                     {
[13:36:36.265]                       inherits <- base::inherits
[13:36:36.265]                       invokeRestart <- base::invokeRestart
[13:36:36.265]                       is.null <- base::is.null
[13:36:36.265]                       muffled <- FALSE
[13:36:36.265]                       if (inherits(cond, "message")) {
[13:36:36.265]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.265]                         if (muffled) 
[13:36:36.265]                           invokeRestart("muffleMessage")
[13:36:36.265]                       }
[13:36:36.265]                       else if (inherits(cond, "warning")) {
[13:36:36.265]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.265]                         if (muffled) 
[13:36:36.265]                           invokeRestart("muffleWarning")
[13:36:36.265]                       }
[13:36:36.265]                       else if (inherits(cond, "condition")) {
[13:36:36.265]                         if (!is.null(pattern)) {
[13:36:36.265]                           computeRestarts <- base::computeRestarts
[13:36:36.265]                           grepl <- base::grepl
[13:36:36.265]                           restarts <- computeRestarts(cond)
[13:36:36.265]                           for (restart in restarts) {
[13:36:36.265]                             name <- restart$name
[13:36:36.265]                             if (is.null(name)) 
[13:36:36.265]                               next
[13:36:36.265]                             if (!grepl(pattern, name)) 
[13:36:36.265]                               next
[13:36:36.265]                             invokeRestart(restart)
[13:36:36.265]                             muffled <- TRUE
[13:36:36.265]                             break
[13:36:36.265]                           }
[13:36:36.265]                         }
[13:36:36.265]                       }
[13:36:36.265]                       invisible(muffled)
[13:36:36.265]                     }
[13:36:36.265]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.265]                   }
[13:36:36.265]                 }
[13:36:36.265]             }
[13:36:36.265]         }))
[13:36:36.265]     }, error = function(ex) {
[13:36:36.265]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.265]                 ...future.rng), started = ...future.startTime, 
[13:36:36.265]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.265]             version = "1.8"), class = "FutureResult")
[13:36:36.265]     }, finally = {
[13:36:36.265]         if (!identical(...future.workdir, getwd())) 
[13:36:36.265]             setwd(...future.workdir)
[13:36:36.265]         {
[13:36:36.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.265]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.265]             }
[13:36:36.265]             base::options(...future.oldOptions)
[13:36:36.265]             if (.Platform$OS.type == "windows") {
[13:36:36.265]                 old_names <- names(...future.oldEnvVars)
[13:36:36.265]                 envs <- base::Sys.getenv()
[13:36:36.265]                 names <- names(envs)
[13:36:36.265]                 common <- intersect(names, old_names)
[13:36:36.265]                 added <- setdiff(names, old_names)
[13:36:36.265]                 removed <- setdiff(old_names, names)
[13:36:36.265]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.265]                   envs[common]]
[13:36:36.265]                 NAMES <- toupper(changed)
[13:36:36.265]                 args <- list()
[13:36:36.265]                 for (kk in seq_along(NAMES)) {
[13:36:36.265]                   name <- changed[[kk]]
[13:36:36.265]                   NAME <- NAMES[[kk]]
[13:36:36.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.265]                     next
[13:36:36.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.265]                 }
[13:36:36.265]                 NAMES <- toupper(added)
[13:36:36.265]                 for (kk in seq_along(NAMES)) {
[13:36:36.265]                   name <- added[[kk]]
[13:36:36.265]                   NAME <- NAMES[[kk]]
[13:36:36.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.265]                     next
[13:36:36.265]                   args[[name]] <- ""
[13:36:36.265]                 }
[13:36:36.265]                 NAMES <- toupper(removed)
[13:36:36.265]                 for (kk in seq_along(NAMES)) {
[13:36:36.265]                   name <- removed[[kk]]
[13:36:36.265]                   NAME <- NAMES[[kk]]
[13:36:36.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.265]                     next
[13:36:36.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.265]                 }
[13:36:36.265]                 if (length(args) > 0) 
[13:36:36.265]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.265]             }
[13:36:36.265]             else {
[13:36:36.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.265]             }
[13:36:36.265]             {
[13:36:36.265]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.265]                   0L) {
[13:36:36.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.265]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.265]                   base::options(opts)
[13:36:36.265]                 }
[13:36:36.265]                 {
[13:36:36.265]                   {
[13:36:36.265]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.265]                     NULL
[13:36:36.265]                   }
[13:36:36.265]                   options(future.plan = NULL)
[13:36:36.265]                   if (is.na(NA_character_)) 
[13:36:36.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.265]                     .init = FALSE)
[13:36:36.265]                 }
[13:36:36.265]             }
[13:36:36.265]         }
[13:36:36.265]     })
[13:36:36.265]     if (TRUE) {
[13:36:36.265]         base::sink(type = "output", split = FALSE)
[13:36:36.265]         if (TRUE) {
[13:36:36.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.265]         }
[13:36:36.265]         else {
[13:36:36.265]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.265]         }
[13:36:36.265]         base::close(...future.stdout)
[13:36:36.265]         ...future.stdout <- NULL
[13:36:36.265]     }
[13:36:36.265]     ...future.result$conditions <- ...future.conditions
[13:36:36.265]     ...future.result$finished <- base::Sys.time()
[13:36:36.265]     ...future.result
[13:36:36.265] }
[13:36:36.268] requestCore(): workers = 2
[13:36:36.269] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:36.280] result() for MulticoreFuture ...
[13:36:36.280] result() for MulticoreFuture ...
[13:36:36.281] result() for MulticoreFuture ... done
[13:36:36.281] result() for MulticoreFuture ... done
[13:36:36.281] result() for MulticoreFuture ...
[13:36:36.281] result() for MulticoreFuture ... done
[13:36:36.284] MulticoreFuture started
[13:36:36.284] - Launch lazy future ... done
[13:36:36.284] run() for ‘MulticoreFuture’ ... done
[13:36:36.285] plan(): Setting new future strategy stack:
<environment: 0x564a74200578> 
[13:36:36.285] List of future strategies:
[13:36:36.285] 1. sequential:
[13:36:36.285]    - args: function (..., envir = parent.frame())
[13:36:36.285]    - tweaked: FALSE
[13:36:36.285]    - call: NULL
[13:36:36.286] plan(): nbrOfWorkers() = 1
<environment: 0x564a74da21b0> 
[13:36:36.289] plan(): Setting new future strategy stack:
[13:36:36.289] List of future strategies:
[13:36:36.289] 1. multicore:
[13:36:36.289]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.289]    - tweaked: FALSE
[13:36:36.289]    - call: plan(strategy)
[13:36:36.294] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:36.296] resolve() on environment ...
[13:36:36.296]  recursive: 0
[13:36:36.297]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:36.297] signalConditionsASAP(numeric, pos=1) ...
[13:36:36.297] - nx: 4
[13:36:36.297] - relay: TRUE
[13:36:36.298] - stdout: TRUE
[13:36:36.298] - signal: TRUE
[13:36:36.298] - resignal: FALSE
[13:36:36.298] - force: TRUE
[13:36:36.298] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.298] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.298]  - until=2
[13:36:36.298]  - relaying element #2
[13:36:36.299] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.299] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.299] signalConditionsASAP(NULL, pos=1) ... done
[13:36:36.299]  length: 3 (resolved future 1)
[13:36:36.299] Future #2
[13:36:36.299] result() for MulticoreFuture ...
[13:36:36.299] result() for MulticoreFuture ... done
[13:36:36.300] result() for MulticoreFuture ...
[13:36:36.300] result() for MulticoreFuture ... done
[13:36:36.300] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:36.300] - nx: 4
[13:36:36.300] - relay: TRUE
[13:36:36.300] - stdout: TRUE
[13:36:36.300] - signal: TRUE
[13:36:36.301] - resignal: FALSE
[13:36:36.301] - force: TRUE
[13:36:36.301] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.301] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.301]  - until=2
[13:36:36.301]  - relaying element #2
[13:36:36.301] result() for MulticoreFuture ...
[13:36:36.301] result() for MulticoreFuture ... done
[13:36:36.302] result() for MulticoreFuture ...
[13:36:36.302] result() for MulticoreFuture ... done
[13:36:36.302] result() for MulticoreFuture ...
[13:36:36.302] result() for MulticoreFuture ... done
[13:36:36.302] result() for MulticoreFuture ...
[13:36:36.302] result() for MulticoreFuture ... done
[13:36:36.302] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.303] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.303] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:36.303]  length: 2 (resolved future 2)
[13:36:36.303] Future #3
[13:36:36.303] result() for MulticoreFuture ...
[13:36:36.304] result() for MulticoreFuture ...
[13:36:36.304] result() for MulticoreFuture ... done
[13:36:36.304] result() for MulticoreFuture ... done
[13:36:36.305] result() for MulticoreFuture ...
[13:36:36.305] result() for MulticoreFuture ... done
[13:36:36.305] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:36.305] - nx: 4
[13:36:36.305] - relay: TRUE
[13:36:36.305] - stdout: TRUE
[13:36:36.305] - signal: TRUE
[13:36:36.305] - resignal: FALSE
[13:36:36.306] - force: TRUE
[13:36:36.306] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.306] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.306]  - until=3
[13:36:36.306]  - relaying element #3
[13:36:36.306] result() for MulticoreFuture ...
[13:36:36.306] result() for MulticoreFuture ... done
[13:36:36.307] result() for MulticoreFuture ...
[13:36:36.307] result() for MulticoreFuture ... done
[13:36:36.307] result() for MulticoreFuture ...
[13:36:36.307] result() for MulticoreFuture ... done
[13:36:36.307] result() for MulticoreFuture ...
[13:36:36.307] result() for MulticoreFuture ... done
[13:36:36.307] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.308] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.308] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:36.308]  length: 1 (resolved future 3)
[13:36:36.308] Future #4
[13:36:36.308] result() for MulticoreFuture ...
[13:36:36.309] result() for MulticoreFuture ...
[13:36:36.309] result() for MulticoreFuture ... done
[13:36:36.309] result() for MulticoreFuture ... done
[13:36:36.309] result() for MulticoreFuture ...
[13:36:36.310] result() for MulticoreFuture ... done
[13:36:36.310] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:36.310] - nx: 4
[13:36:36.319] - relay: TRUE
[13:36:36.319] - stdout: TRUE
[13:36:36.319] - signal: TRUE
[13:36:36.319] - resignal: FALSE
[13:36:36.319] - force: TRUE
[13:36:36.319] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.319] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.320]  - until=4
[13:36:36.320]  - relaying element #4
[13:36:36.320] result() for MulticoreFuture ...
[13:36:36.320] result() for MulticoreFuture ... done
[13:36:36.320] result() for MulticoreFuture ...
[13:36:36.320] result() for MulticoreFuture ... done
[13:36:36.320] result() for MulticoreFuture ...
[13:36:36.320] result() for MulticoreFuture ... done
[13:36:36.320] result() for MulticoreFuture ...
[13:36:36.321] result() for MulticoreFuture ... done
[13:36:36.321] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.321] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.321] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:36.321]  length: 0 (resolved future 4)
[13:36:36.321] Relaying remaining futures
[13:36:36.321] signalConditionsASAP(NULL, pos=0) ...
[13:36:36.321] - nx: 4
[13:36:36.321] - relay: TRUE
[13:36:36.321] - stdout: TRUE
[13:36:36.322] - signal: TRUE
[13:36:36.322] - resignal: FALSE
[13:36:36.322] - force: TRUE
[13:36:36.322] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.322] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:36.322] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.322] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.322] signalConditionsASAP(NULL, pos=0) ... done
[13:36:36.322] resolve() on environment ... DONE
[13:36:36.323] result() for MulticoreFuture ...
[13:36:36.323] result() for MulticoreFuture ... done
[13:36:36.323] result() for MulticoreFuture ...
[13:36:36.323] result() for MulticoreFuture ... done
[13:36:36.323] result() for MulticoreFuture ...
[13:36:36.323] result() for MulticoreFuture ... done
[13:36:36.323] result() for MulticoreFuture ...
[13:36:36.323] result() for MulticoreFuture ... done
[13:36:36.323] result() for MulticoreFuture ...
[13:36:36.324] result() for MulticoreFuture ... done
[13:36:36.324] result() for MulticoreFuture ...
[13:36:36.324] result() for MulticoreFuture ... done
<environment: 0x564a74e5c710> 
Dimensions: c(2, 1, 3, 1)
[13:36:36.324] getGlobalsAndPackages() ...
[13:36:36.324] Searching for globals...
[13:36:36.325] 
[13:36:36.325] Searching for globals ... DONE
[13:36:36.325] - globals: [0] <none>
[13:36:36.325] getGlobalsAndPackages() ... DONE
[13:36:36.326] run() for ‘Future’ ...
[13:36:36.326] - state: ‘created’
[13:36:36.326] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.330] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.330]   - Field: ‘label’
[13:36:36.330]   - Field: ‘local’
[13:36:36.330]   - Field: ‘owner’
[13:36:36.330]   - Field: ‘envir’
[13:36:36.331]   - Field: ‘workers’
[13:36:36.331]   - Field: ‘packages’
[13:36:36.331]   - Field: ‘gc’
[13:36:36.331]   - Field: ‘job’
[13:36:36.331]   - Field: ‘conditions’
[13:36:36.331]   - Field: ‘expr’
[13:36:36.331]   - Field: ‘uuid’
[13:36:36.331]   - Field: ‘seed’
[13:36:36.331]   - Field: ‘version’
[13:36:36.331]   - Field: ‘result’
[13:36:36.332]   - Field: ‘asynchronous’
[13:36:36.332]   - Field: ‘calls’
[13:36:36.332]   - Field: ‘globals’
[13:36:36.332]   - Field: ‘stdout’
[13:36:36.332]   - Field: ‘earlySignal’
[13:36:36.332]   - Field: ‘lazy’
[13:36:36.332]   - Field: ‘state’
[13:36:36.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.332] - Launch lazy future ...
[13:36:36.333] Packages needed by the future expression (n = 0): <none>
[13:36:36.333] Packages needed by future strategies (n = 0): <none>
[13:36:36.333] {
[13:36:36.333]     {
[13:36:36.333]         {
[13:36:36.333]             ...future.startTime <- base::Sys.time()
[13:36:36.333]             {
[13:36:36.333]                 {
[13:36:36.333]                   {
[13:36:36.333]                     {
[13:36:36.333]                       base::local({
[13:36:36.333]                         has_future <- base::requireNamespace("future", 
[13:36:36.333]                           quietly = TRUE)
[13:36:36.333]                         if (has_future) {
[13:36:36.333]                           ns <- base::getNamespace("future")
[13:36:36.333]                           version <- ns[[".package"]][["version"]]
[13:36:36.333]                           if (is.null(version)) 
[13:36:36.333]                             version <- utils::packageVersion("future")
[13:36:36.333]                         }
[13:36:36.333]                         else {
[13:36:36.333]                           version <- NULL
[13:36:36.333]                         }
[13:36:36.333]                         if (!has_future || version < "1.8.0") {
[13:36:36.333]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.333]                             "", base::R.version$version.string), 
[13:36:36.333]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.333]                               "release", "version")], collapse = " "), 
[13:36:36.333]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.333]                             info)
[13:36:36.333]                           info <- base::paste(info, collapse = "; ")
[13:36:36.333]                           if (!has_future) {
[13:36:36.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.333]                               info)
[13:36:36.333]                           }
[13:36:36.333]                           else {
[13:36:36.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.333]                               info, version)
[13:36:36.333]                           }
[13:36:36.333]                           base::stop(msg)
[13:36:36.333]                         }
[13:36:36.333]                       })
[13:36:36.333]                     }
[13:36:36.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.333]                     base::options(mc.cores = 1L)
[13:36:36.333]                   }
[13:36:36.333]                   ...future.strategy.old <- future::plan("list")
[13:36:36.333]                   options(future.plan = NULL)
[13:36:36.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.333]                 }
[13:36:36.333]                 ...future.workdir <- getwd()
[13:36:36.333]             }
[13:36:36.333]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.333]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.333]         }
[13:36:36.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.333]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.333]             base::names(...future.oldOptions))
[13:36:36.333]     }
[13:36:36.333]     if (FALSE) {
[13:36:36.333]     }
[13:36:36.333]     else {
[13:36:36.333]         if (TRUE) {
[13:36:36.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.333]                 open = "w")
[13:36:36.333]         }
[13:36:36.333]         else {
[13:36:36.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.333]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.333]         }
[13:36:36.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.333]             base::sink(type = "output", split = FALSE)
[13:36:36.333]             base::close(...future.stdout)
[13:36:36.333]         }, add = TRUE)
[13:36:36.333]     }
[13:36:36.333]     ...future.frame <- base::sys.nframe()
[13:36:36.333]     ...future.conditions <- base::list()
[13:36:36.333]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.333]     if (FALSE) {
[13:36:36.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.333]     }
[13:36:36.333]     ...future.result <- base::tryCatch({
[13:36:36.333]         base::withCallingHandlers({
[13:36:36.333]             ...future.value <- base::withVisible(base::local({
[13:36:36.333]                 withCallingHandlers({
[13:36:36.333]                   2
[13:36:36.333]                 }, immediateCondition = function(cond) {
[13:36:36.333]                   save_rds <- function (object, pathname, ...) 
[13:36:36.333]                   {
[13:36:36.333]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.333]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.333]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.333]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.333]                         fi_tmp[["mtime"]])
[13:36:36.333]                     }
[13:36:36.333]                     tryCatch({
[13:36:36.333]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.333]                     }, error = function(ex) {
[13:36:36.333]                       msg <- conditionMessage(ex)
[13:36:36.333]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.333]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.333]                         fi_tmp[["mtime"]], msg)
[13:36:36.333]                       ex$message <- msg
[13:36:36.333]                       stop(ex)
[13:36:36.333]                     })
[13:36:36.333]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.333]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.333]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.333]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.333]                       fi <- file.info(pathname)
[13:36:36.333]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.333]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.333]                         fi[["size"]], fi[["mtime"]])
[13:36:36.333]                       stop(msg)
[13:36:36.333]                     }
[13:36:36.333]                     invisible(pathname)
[13:36:36.333]                   }
[13:36:36.333]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.333]                     rootPath = tempdir()) 
[13:36:36.333]                   {
[13:36:36.333]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.333]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.333]                       tmpdir = path, fileext = ".rds")
[13:36:36.333]                     save_rds(obj, file)
[13:36:36.333]                   }
[13:36:36.333]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.333]                   {
[13:36:36.333]                     inherits <- base::inherits
[13:36:36.333]                     invokeRestart <- base::invokeRestart
[13:36:36.333]                     is.null <- base::is.null
[13:36:36.333]                     muffled <- FALSE
[13:36:36.333]                     if (inherits(cond, "message")) {
[13:36:36.333]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.333]                       if (muffled) 
[13:36:36.333]                         invokeRestart("muffleMessage")
[13:36:36.333]                     }
[13:36:36.333]                     else if (inherits(cond, "warning")) {
[13:36:36.333]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.333]                       if (muffled) 
[13:36:36.333]                         invokeRestart("muffleWarning")
[13:36:36.333]                     }
[13:36:36.333]                     else if (inherits(cond, "condition")) {
[13:36:36.333]                       if (!is.null(pattern)) {
[13:36:36.333]                         computeRestarts <- base::computeRestarts
[13:36:36.333]                         grepl <- base::grepl
[13:36:36.333]                         restarts <- computeRestarts(cond)
[13:36:36.333]                         for (restart in restarts) {
[13:36:36.333]                           name <- restart$name
[13:36:36.333]                           if (is.null(name)) 
[13:36:36.333]                             next
[13:36:36.333]                           if (!grepl(pattern, name)) 
[13:36:36.333]                             next
[13:36:36.333]                           invokeRestart(restart)
[13:36:36.333]                           muffled <- TRUE
[13:36:36.333]                           break
[13:36:36.333]                         }
[13:36:36.333]                       }
[13:36:36.333]                     }
[13:36:36.333]                     invisible(muffled)
[13:36:36.333]                   }
[13:36:36.333]                   muffleCondition(cond)
[13:36:36.333]                 })
[13:36:36.333]             }))
[13:36:36.333]             future::FutureResult(value = ...future.value$value, 
[13:36:36.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.333]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.333]                     ...future.globalenv.names))
[13:36:36.333]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.333]         }, condition = base::local({
[13:36:36.333]             c <- base::c
[13:36:36.333]             inherits <- base::inherits
[13:36:36.333]             invokeRestart <- base::invokeRestart
[13:36:36.333]             length <- base::length
[13:36:36.333]             list <- base::list
[13:36:36.333]             seq.int <- base::seq.int
[13:36:36.333]             signalCondition <- base::signalCondition
[13:36:36.333]             sys.calls <- base::sys.calls
[13:36:36.333]             `[[` <- base::`[[`
[13:36:36.333]             `+` <- base::`+`
[13:36:36.333]             `<<-` <- base::`<<-`
[13:36:36.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.333]                   3L)]
[13:36:36.333]             }
[13:36:36.333]             function(cond) {
[13:36:36.333]                 is_error <- inherits(cond, "error")
[13:36:36.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.333]                   NULL)
[13:36:36.333]                 if (is_error) {
[13:36:36.333]                   sessionInformation <- function() {
[13:36:36.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.333]                       search = base::search(), system = base::Sys.info())
[13:36:36.333]                   }
[13:36:36.333]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.333]                     cond$call), session = sessionInformation(), 
[13:36:36.333]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.333]                   signalCondition(cond)
[13:36:36.333]                 }
[13:36:36.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.333]                 "immediateCondition"))) {
[13:36:36.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.333]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.333]                   if (TRUE && !signal) {
[13:36:36.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.333]                     {
[13:36:36.333]                       inherits <- base::inherits
[13:36:36.333]                       invokeRestart <- base::invokeRestart
[13:36:36.333]                       is.null <- base::is.null
[13:36:36.333]                       muffled <- FALSE
[13:36:36.333]                       if (inherits(cond, "message")) {
[13:36:36.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.333]                         if (muffled) 
[13:36:36.333]                           invokeRestart("muffleMessage")
[13:36:36.333]                       }
[13:36:36.333]                       else if (inherits(cond, "warning")) {
[13:36:36.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.333]                         if (muffled) 
[13:36:36.333]                           invokeRestart("muffleWarning")
[13:36:36.333]                       }
[13:36:36.333]                       else if (inherits(cond, "condition")) {
[13:36:36.333]                         if (!is.null(pattern)) {
[13:36:36.333]                           computeRestarts <- base::computeRestarts
[13:36:36.333]                           grepl <- base::grepl
[13:36:36.333]                           restarts <- computeRestarts(cond)
[13:36:36.333]                           for (restart in restarts) {
[13:36:36.333]                             name <- restart$name
[13:36:36.333]                             if (is.null(name)) 
[13:36:36.333]                               next
[13:36:36.333]                             if (!grepl(pattern, name)) 
[13:36:36.333]                               next
[13:36:36.333]                             invokeRestart(restart)
[13:36:36.333]                             muffled <- TRUE
[13:36:36.333]                             break
[13:36:36.333]                           }
[13:36:36.333]                         }
[13:36:36.333]                       }
[13:36:36.333]                       invisible(muffled)
[13:36:36.333]                     }
[13:36:36.333]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.333]                   }
[13:36:36.333]                 }
[13:36:36.333]                 else {
[13:36:36.333]                   if (TRUE) {
[13:36:36.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.333]                     {
[13:36:36.333]                       inherits <- base::inherits
[13:36:36.333]                       invokeRestart <- base::invokeRestart
[13:36:36.333]                       is.null <- base::is.null
[13:36:36.333]                       muffled <- FALSE
[13:36:36.333]                       if (inherits(cond, "message")) {
[13:36:36.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.333]                         if (muffled) 
[13:36:36.333]                           invokeRestart("muffleMessage")
[13:36:36.333]                       }
[13:36:36.333]                       else if (inherits(cond, "warning")) {
[13:36:36.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.333]                         if (muffled) 
[13:36:36.333]                           invokeRestart("muffleWarning")
[13:36:36.333]                       }
[13:36:36.333]                       else if (inherits(cond, "condition")) {
[13:36:36.333]                         if (!is.null(pattern)) {
[13:36:36.333]                           computeRestarts <- base::computeRestarts
[13:36:36.333]                           grepl <- base::grepl
[13:36:36.333]                           restarts <- computeRestarts(cond)
[13:36:36.333]                           for (restart in restarts) {
[13:36:36.333]                             name <- restart$name
[13:36:36.333]                             if (is.null(name)) 
[13:36:36.333]                               next
[13:36:36.333]                             if (!grepl(pattern, name)) 
[13:36:36.333]                               next
[13:36:36.333]                             invokeRestart(restart)
[13:36:36.333]                             muffled <- TRUE
[13:36:36.333]                             break
[13:36:36.333]                           }
[13:36:36.333]                         }
[13:36:36.333]                       }
[13:36:36.333]                       invisible(muffled)
[13:36:36.333]                     }
[13:36:36.333]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.333]                   }
[13:36:36.333]                 }
[13:36:36.333]             }
[13:36:36.333]         }))
[13:36:36.333]     }, error = function(ex) {
[13:36:36.333]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.333]                 ...future.rng), started = ...future.startTime, 
[13:36:36.333]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.333]             version = "1.8"), class = "FutureResult")
[13:36:36.333]     }, finally = {
[13:36:36.333]         if (!identical(...future.workdir, getwd())) 
[13:36:36.333]             setwd(...future.workdir)
[13:36:36.333]         {
[13:36:36.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.333]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.333]             }
[13:36:36.333]             base::options(...future.oldOptions)
[13:36:36.333]             if (.Platform$OS.type == "windows") {
[13:36:36.333]                 old_names <- names(...future.oldEnvVars)
[13:36:36.333]                 envs <- base::Sys.getenv()
[13:36:36.333]                 names <- names(envs)
[13:36:36.333]                 common <- intersect(names, old_names)
[13:36:36.333]                 added <- setdiff(names, old_names)
[13:36:36.333]                 removed <- setdiff(old_names, names)
[13:36:36.333]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.333]                   envs[common]]
[13:36:36.333]                 NAMES <- toupper(changed)
[13:36:36.333]                 args <- list()
[13:36:36.333]                 for (kk in seq_along(NAMES)) {
[13:36:36.333]                   name <- changed[[kk]]
[13:36:36.333]                   NAME <- NAMES[[kk]]
[13:36:36.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.333]                     next
[13:36:36.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.333]                 }
[13:36:36.333]                 NAMES <- toupper(added)
[13:36:36.333]                 for (kk in seq_along(NAMES)) {
[13:36:36.333]                   name <- added[[kk]]
[13:36:36.333]                   NAME <- NAMES[[kk]]
[13:36:36.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.333]                     next
[13:36:36.333]                   args[[name]] <- ""
[13:36:36.333]                 }
[13:36:36.333]                 NAMES <- toupper(removed)
[13:36:36.333]                 for (kk in seq_along(NAMES)) {
[13:36:36.333]                   name <- removed[[kk]]
[13:36:36.333]                   NAME <- NAMES[[kk]]
[13:36:36.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.333]                     next
[13:36:36.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.333]                 }
[13:36:36.333]                 if (length(args) > 0) 
[13:36:36.333]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.333]             }
[13:36:36.333]             else {
[13:36:36.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.333]             }
[13:36:36.333]             {
[13:36:36.333]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.333]                   0L) {
[13:36:36.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.333]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.333]                   base::options(opts)
[13:36:36.333]                 }
[13:36:36.333]                 {
[13:36:36.333]                   {
[13:36:36.333]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.333]                     NULL
[13:36:36.333]                   }
[13:36:36.333]                   options(future.plan = NULL)
[13:36:36.333]                   if (is.na(NA_character_)) 
[13:36:36.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.333]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.333]                     .init = FALSE)
[13:36:36.333]                 }
[13:36:36.333]             }
[13:36:36.333]         }
[13:36:36.333]     })
[13:36:36.333]     if (TRUE) {
[13:36:36.333]         base::sink(type = "output", split = FALSE)
[13:36:36.333]         if (TRUE) {
[13:36:36.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.333]         }
[13:36:36.333]         else {
[13:36:36.333]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.333]         }
[13:36:36.333]         base::close(...future.stdout)
[13:36:36.333]         ...future.stdout <- NULL
[13:36:36.333]     }
[13:36:36.333]     ...future.result$conditions <- ...future.conditions
[13:36:36.333]     ...future.result$finished <- base::Sys.time()
[13:36:36.333]     ...future.result
[13:36:36.333] }
[13:36:36.336] requestCore(): workers = 2
[13:36:36.338] MulticoreFuture started
[13:36:36.338] - Launch lazy future ... done
[13:36:36.339] run() for ‘MulticoreFuture’ ... done
[13:36:36.339] getGlobalsAndPackages() ...
[13:36:36.339] Searching for globals...
[13:36:36.339] plan(): Setting new future strategy stack:
[13:36:36.340] 
[13:36:36.339] List of future strategies:
[13:36:36.339] 1. sequential:
[13:36:36.339]    - args: function (..., envir = parent.frame())
[13:36:36.339]    - tweaked: FALSE
[13:36:36.339]    - call: NULL
[13:36:36.340] Searching for globals ... DONE
[13:36:36.340] - globals: [0] <none>
[13:36:36.340] plan(): nbrOfWorkers() = 1
[13:36:36.340] getGlobalsAndPackages() ... DONE
[13:36:36.341] run() for ‘Future’ ...
[13:36:36.341] - state: ‘created’
[13:36:36.341] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.342] plan(): Setting new future strategy stack:
[13:36:36.342] List of future strategies:
[13:36:36.342] 1. multicore:
[13:36:36.342]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.342]    - tweaked: FALSE
[13:36:36.342]    - call: plan(strategy)
[13:36:36.347] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.347] plan(): nbrOfWorkers() = 2
[13:36:36.347]   - Field: ‘label’
[13:36:36.347]   - Field: ‘local’
[13:36:36.347]   - Field: ‘owner’
[13:36:36.347]   - Field: ‘envir’
[13:36:36.347]   - Field: ‘workers’
[13:36:36.348]   - Field: ‘packages’
[13:36:36.348]   - Field: ‘gc’
[13:36:36.348]   - Field: ‘job’
[13:36:36.348]   - Field: ‘conditions’
[13:36:36.348]   - Field: ‘expr’
[13:36:36.348]   - Field: ‘uuid’
[13:36:36.348]   - Field: ‘seed’
[13:36:36.349]   - Field: ‘version’
[13:36:36.349]   - Field: ‘result’
[13:36:36.349]   - Field: ‘asynchronous’
[13:36:36.349]   - Field: ‘calls’
[13:36:36.349]   - Field: ‘globals’
[13:36:36.349]   - Field: ‘stdout’
[13:36:36.349]   - Field: ‘earlySignal’
[13:36:36.350]   - Field: ‘lazy’
[13:36:36.350]   - Field: ‘state’
[13:36:36.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.350] - Launch lazy future ...
[13:36:36.350] Packages needed by the future expression (n = 0): <none>
[13:36:36.351] Packages needed by future strategies (n = 0): <none>
[13:36:36.351] {
[13:36:36.351]     {
[13:36:36.351]         {
[13:36:36.351]             ...future.startTime <- base::Sys.time()
[13:36:36.351]             {
[13:36:36.351]                 {
[13:36:36.351]                   {
[13:36:36.351]                     {
[13:36:36.351]                       base::local({
[13:36:36.351]                         has_future <- base::requireNamespace("future", 
[13:36:36.351]                           quietly = TRUE)
[13:36:36.351]                         if (has_future) {
[13:36:36.351]                           ns <- base::getNamespace("future")
[13:36:36.351]                           version <- ns[[".package"]][["version"]]
[13:36:36.351]                           if (is.null(version)) 
[13:36:36.351]                             version <- utils::packageVersion("future")
[13:36:36.351]                         }
[13:36:36.351]                         else {
[13:36:36.351]                           version <- NULL
[13:36:36.351]                         }
[13:36:36.351]                         if (!has_future || version < "1.8.0") {
[13:36:36.351]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.351]                             "", base::R.version$version.string), 
[13:36:36.351]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.351]                               "release", "version")], collapse = " "), 
[13:36:36.351]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.351]                             info)
[13:36:36.351]                           info <- base::paste(info, collapse = "; ")
[13:36:36.351]                           if (!has_future) {
[13:36:36.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.351]                               info)
[13:36:36.351]                           }
[13:36:36.351]                           else {
[13:36:36.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.351]                               info, version)
[13:36:36.351]                           }
[13:36:36.351]                           base::stop(msg)
[13:36:36.351]                         }
[13:36:36.351]                       })
[13:36:36.351]                     }
[13:36:36.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.351]                     base::options(mc.cores = 1L)
[13:36:36.351]                   }
[13:36:36.351]                   ...future.strategy.old <- future::plan("list")
[13:36:36.351]                   options(future.plan = NULL)
[13:36:36.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.351]                 }
[13:36:36.351]                 ...future.workdir <- getwd()
[13:36:36.351]             }
[13:36:36.351]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.351]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.351]         }
[13:36:36.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.351]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.351]             base::names(...future.oldOptions))
[13:36:36.351]     }
[13:36:36.351]     if (FALSE) {
[13:36:36.351]     }
[13:36:36.351]     else {
[13:36:36.351]         if (TRUE) {
[13:36:36.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.351]                 open = "w")
[13:36:36.351]         }
[13:36:36.351]         else {
[13:36:36.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.351]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.351]         }
[13:36:36.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.351]             base::sink(type = "output", split = FALSE)
[13:36:36.351]             base::close(...future.stdout)
[13:36:36.351]         }, add = TRUE)
[13:36:36.351]     }
[13:36:36.351]     ...future.frame <- base::sys.nframe()
[13:36:36.351]     ...future.conditions <- base::list()
[13:36:36.351]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.351]     if (FALSE) {
[13:36:36.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.351]     }
[13:36:36.351]     ...future.result <- base::tryCatch({
[13:36:36.351]         base::withCallingHandlers({
[13:36:36.351]             ...future.value <- base::withVisible(base::local({
[13:36:36.351]                 withCallingHandlers({
[13:36:36.351]                   NULL
[13:36:36.351]                 }, immediateCondition = function(cond) {
[13:36:36.351]                   save_rds <- function (object, pathname, ...) 
[13:36:36.351]                   {
[13:36:36.351]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.351]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.351]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.351]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.351]                         fi_tmp[["mtime"]])
[13:36:36.351]                     }
[13:36:36.351]                     tryCatch({
[13:36:36.351]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.351]                     }, error = function(ex) {
[13:36:36.351]                       msg <- conditionMessage(ex)
[13:36:36.351]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.351]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.351]                         fi_tmp[["mtime"]], msg)
[13:36:36.351]                       ex$message <- msg
[13:36:36.351]                       stop(ex)
[13:36:36.351]                     })
[13:36:36.351]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.351]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.351]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.351]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.351]                       fi <- file.info(pathname)
[13:36:36.351]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.351]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.351]                         fi[["size"]], fi[["mtime"]])
[13:36:36.351]                       stop(msg)
[13:36:36.351]                     }
[13:36:36.351]                     invisible(pathname)
[13:36:36.351]                   }
[13:36:36.351]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.351]                     rootPath = tempdir()) 
[13:36:36.351]                   {
[13:36:36.351]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.351]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.351]                       tmpdir = path, fileext = ".rds")
[13:36:36.351]                     save_rds(obj, file)
[13:36:36.351]                   }
[13:36:36.351]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.351]                   {
[13:36:36.351]                     inherits <- base::inherits
[13:36:36.351]                     invokeRestart <- base::invokeRestart
[13:36:36.351]                     is.null <- base::is.null
[13:36:36.351]                     muffled <- FALSE
[13:36:36.351]                     if (inherits(cond, "message")) {
[13:36:36.351]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.351]                       if (muffled) 
[13:36:36.351]                         invokeRestart("muffleMessage")
[13:36:36.351]                     }
[13:36:36.351]                     else if (inherits(cond, "warning")) {
[13:36:36.351]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.351]                       if (muffled) 
[13:36:36.351]                         invokeRestart("muffleWarning")
[13:36:36.351]                     }
[13:36:36.351]                     else if (inherits(cond, "condition")) {
[13:36:36.351]                       if (!is.null(pattern)) {
[13:36:36.351]                         computeRestarts <- base::computeRestarts
[13:36:36.351]                         grepl <- base::grepl
[13:36:36.351]                         restarts <- computeRestarts(cond)
[13:36:36.351]                         for (restart in restarts) {
[13:36:36.351]                           name <- restart$name
[13:36:36.351]                           if (is.null(name)) 
[13:36:36.351]                             next
[13:36:36.351]                           if (!grepl(pattern, name)) 
[13:36:36.351]                             next
[13:36:36.351]                           invokeRestart(restart)
[13:36:36.351]                           muffled <- TRUE
[13:36:36.351]                           break
[13:36:36.351]                         }
[13:36:36.351]                       }
[13:36:36.351]                     }
[13:36:36.351]                     invisible(muffled)
[13:36:36.351]                   }
[13:36:36.351]                   muffleCondition(cond)
[13:36:36.351]                 })
[13:36:36.351]             }))
[13:36:36.351]             future::FutureResult(value = ...future.value$value, 
[13:36:36.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.351]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.351]                     ...future.globalenv.names))
[13:36:36.351]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.351]         }, condition = base::local({
[13:36:36.351]             c <- base::c
[13:36:36.351]             inherits <- base::inherits
[13:36:36.351]             invokeRestart <- base::invokeRestart
[13:36:36.351]             length <- base::length
[13:36:36.351]             list <- base::list
[13:36:36.351]             seq.int <- base::seq.int
[13:36:36.351]             signalCondition <- base::signalCondition
[13:36:36.351]             sys.calls <- base::sys.calls
[13:36:36.351]             `[[` <- base::`[[`
[13:36:36.351]             `+` <- base::`+`
[13:36:36.351]             `<<-` <- base::`<<-`
[13:36:36.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.351]                   3L)]
[13:36:36.351]             }
[13:36:36.351]             function(cond) {
[13:36:36.351]                 is_error <- inherits(cond, "error")
[13:36:36.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.351]                   NULL)
[13:36:36.351]                 if (is_error) {
[13:36:36.351]                   sessionInformation <- function() {
[13:36:36.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.351]                       search = base::search(), system = base::Sys.info())
[13:36:36.351]                   }
[13:36:36.351]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.351]                     cond$call), session = sessionInformation(), 
[13:36:36.351]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.351]                   signalCondition(cond)
[13:36:36.351]                 }
[13:36:36.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.351]                 "immediateCondition"))) {
[13:36:36.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.351]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.351]                   if (TRUE && !signal) {
[13:36:36.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.351]                     {
[13:36:36.351]                       inherits <- base::inherits
[13:36:36.351]                       invokeRestart <- base::invokeRestart
[13:36:36.351]                       is.null <- base::is.null
[13:36:36.351]                       muffled <- FALSE
[13:36:36.351]                       if (inherits(cond, "message")) {
[13:36:36.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.351]                         if (muffled) 
[13:36:36.351]                           invokeRestart("muffleMessage")
[13:36:36.351]                       }
[13:36:36.351]                       else if (inherits(cond, "warning")) {
[13:36:36.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.351]                         if (muffled) 
[13:36:36.351]                           invokeRestart("muffleWarning")
[13:36:36.351]                       }
[13:36:36.351]                       else if (inherits(cond, "condition")) {
[13:36:36.351]                         if (!is.null(pattern)) {
[13:36:36.351]                           computeRestarts <- base::computeRestarts
[13:36:36.351]                           grepl <- base::grepl
[13:36:36.351]                           restarts <- computeRestarts(cond)
[13:36:36.351]                           for (restart in restarts) {
[13:36:36.351]                             name <- restart$name
[13:36:36.351]                             if (is.null(name)) 
[13:36:36.351]                               next
[13:36:36.351]                             if (!grepl(pattern, name)) 
[13:36:36.351]                               next
[13:36:36.351]                             invokeRestart(restart)
[13:36:36.351]                             muffled <- TRUE
[13:36:36.351]                             break
[13:36:36.351]                           }
[13:36:36.351]                         }
[13:36:36.351]                       }
[13:36:36.351]                       invisible(muffled)
[13:36:36.351]                     }
[13:36:36.351]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.351]                   }
[13:36:36.351]                 }
[13:36:36.351]                 else {
[13:36:36.351]                   if (TRUE) {
[13:36:36.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.351]                     {
[13:36:36.351]                       inherits <- base::inherits
[13:36:36.351]                       invokeRestart <- base::invokeRestart
[13:36:36.351]                       is.null <- base::is.null
[13:36:36.351]                       muffled <- FALSE
[13:36:36.351]                       if (inherits(cond, "message")) {
[13:36:36.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.351]                         if (muffled) 
[13:36:36.351]                           invokeRestart("muffleMessage")
[13:36:36.351]                       }
[13:36:36.351]                       else if (inherits(cond, "warning")) {
[13:36:36.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.351]                         if (muffled) 
[13:36:36.351]                           invokeRestart("muffleWarning")
[13:36:36.351]                       }
[13:36:36.351]                       else if (inherits(cond, "condition")) {
[13:36:36.351]                         if (!is.null(pattern)) {
[13:36:36.351]                           computeRestarts <- base::computeRestarts
[13:36:36.351]                           grepl <- base::grepl
[13:36:36.351]                           restarts <- computeRestarts(cond)
[13:36:36.351]                           for (restart in restarts) {
[13:36:36.351]                             name <- restart$name
[13:36:36.351]                             if (is.null(name)) 
[13:36:36.351]                               next
[13:36:36.351]                             if (!grepl(pattern, name)) 
[13:36:36.351]                               next
[13:36:36.351]                             invokeRestart(restart)
[13:36:36.351]                             muffled <- TRUE
[13:36:36.351]                             break
[13:36:36.351]                           }
[13:36:36.351]                         }
[13:36:36.351]                       }
[13:36:36.351]                       invisible(muffled)
[13:36:36.351]                     }
[13:36:36.351]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.351]                   }
[13:36:36.351]                 }
[13:36:36.351]             }
[13:36:36.351]         }))
[13:36:36.351]     }, error = function(ex) {
[13:36:36.351]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.351]                 ...future.rng), started = ...future.startTime, 
[13:36:36.351]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.351]             version = "1.8"), class = "FutureResult")
[13:36:36.351]     }, finally = {
[13:36:36.351]         if (!identical(...future.workdir, getwd())) 
[13:36:36.351]             setwd(...future.workdir)
[13:36:36.351]         {
[13:36:36.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.351]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.351]             }
[13:36:36.351]             base::options(...future.oldOptions)
[13:36:36.351]             if (.Platform$OS.type == "windows") {
[13:36:36.351]                 old_names <- names(...future.oldEnvVars)
[13:36:36.351]                 envs <- base::Sys.getenv()
[13:36:36.351]                 names <- names(envs)
[13:36:36.351]                 common <- intersect(names, old_names)
[13:36:36.351]                 added <- setdiff(names, old_names)
[13:36:36.351]                 removed <- setdiff(old_names, names)
[13:36:36.351]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.351]                   envs[common]]
[13:36:36.351]                 NAMES <- toupper(changed)
[13:36:36.351]                 args <- list()
[13:36:36.351]                 for (kk in seq_along(NAMES)) {
[13:36:36.351]                   name <- changed[[kk]]
[13:36:36.351]                   NAME <- NAMES[[kk]]
[13:36:36.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.351]                     next
[13:36:36.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.351]                 }
[13:36:36.351]                 NAMES <- toupper(added)
[13:36:36.351]                 for (kk in seq_along(NAMES)) {
[13:36:36.351]                   name <- added[[kk]]
[13:36:36.351]                   NAME <- NAMES[[kk]]
[13:36:36.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.351]                     next
[13:36:36.351]                   args[[name]] <- ""
[13:36:36.351]                 }
[13:36:36.351]                 NAMES <- toupper(removed)
[13:36:36.351]                 for (kk in seq_along(NAMES)) {
[13:36:36.351]                   name <- removed[[kk]]
[13:36:36.351]                   NAME <- NAMES[[kk]]
[13:36:36.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.351]                     next
[13:36:36.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.351]                 }
[13:36:36.351]                 if (length(args) > 0) 
[13:36:36.351]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.351]             }
[13:36:36.351]             else {
[13:36:36.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.351]             }
[13:36:36.351]             {
[13:36:36.351]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.351]                   0L) {
[13:36:36.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.351]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.351]                   base::options(opts)
[13:36:36.351]                 }
[13:36:36.351]                 {
[13:36:36.351]                   {
[13:36:36.351]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.351]                     NULL
[13:36:36.351]                   }
[13:36:36.351]                   options(future.plan = NULL)
[13:36:36.351]                   if (is.na(NA_character_)) 
[13:36:36.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.351]                     .init = FALSE)
[13:36:36.351]                 }
[13:36:36.351]             }
[13:36:36.351]         }
[13:36:36.351]     })
[13:36:36.351]     if (TRUE) {
[13:36:36.351]         base::sink(type = "output", split = FALSE)
[13:36:36.351]         if (TRUE) {
[13:36:36.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.351]         }
[13:36:36.351]         else {
[13:36:36.351]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.351]         }
[13:36:36.351]         base::close(...future.stdout)
[13:36:36.351]         ...future.stdout <- NULL
[13:36:36.351]     }
[13:36:36.351]     ...future.result$conditions <- ...future.conditions
[13:36:36.351]     ...future.result$finished <- base::Sys.time()
[13:36:36.351]     ...future.result
[13:36:36.351] }
[13:36:36.355] requestCore(): workers = 2
[13:36:36.358] MulticoreFuture started
[13:36:36.358] - Launch lazy future ... done
[13:36:36.358] run() for ‘MulticoreFuture’ ... done
[13:36:36.359] getGlobalsAndPackages() ...
[13:36:36.359] plan(): Setting new future strategy stack:
[13:36:36.359] Searching for globals...
[13:36:36.359] List of future strategies:
[13:36:36.359] 1. sequential:
[13:36:36.359]    - args: function (..., envir = parent.frame())
[13:36:36.359]    - tweaked: FALSE
[13:36:36.359]    - call: NULL
[13:36:36.360] plan(): nbrOfWorkers() = 1
[13:36:36.361] - globals found: [1] ‘{’
[13:36:36.361] Searching for globals ... DONE
[13:36:36.361] Resolving globals: FALSE
[13:36:36.362] 
[13:36:36.362] 
[13:36:36.362] getGlobalsAndPackages() ... DONE
[13:36:36.362] plan(): Setting new future strategy stack:
[13:36:36.363] run() for ‘Future’ ...
[13:36:36.363] - state: ‘created’
[13:36:36.362] List of future strategies:
[13:36:36.362] 1. multicore:
[13:36:36.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.362]    - tweaked: FALSE
[13:36:36.362]    - call: plan(strategy)
[13:36:36.363] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.368] plan(): nbrOfWorkers() = 2
[13:36:36.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:36.369]   - Field: ‘label’
[13:36:36.369]   - Field: ‘local’
[13:36:36.369]   - Field: ‘owner’
[13:36:36.370]   - Field: ‘envir’
[13:36:36.370]   - Field: ‘workers’
[13:36:36.370]   - Field: ‘packages’
[13:36:36.370]   - Field: ‘gc’
[13:36:36.370]   - Field: ‘job’
[13:36:36.370]   - Field: ‘conditions’
[13:36:36.371]   - Field: ‘expr’
[13:36:36.371]   - Field: ‘uuid’
[13:36:36.371]   - Field: ‘seed’
[13:36:36.371]   - Field: ‘version’
[13:36:36.371]   - Field: ‘result’
[13:36:36.371]   - Field: ‘asynchronous’
[13:36:36.372]   - Field: ‘calls’
[13:36:36.372]   - Field: ‘globals’
[13:36:36.372]   - Field: ‘stdout’
[13:36:36.372]   - Field: ‘earlySignal’
[13:36:36.372]   - Field: ‘lazy’
[13:36:36.372]   - Field: ‘state’
[13:36:36.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:36.373] - Launch lazy future ...
[13:36:36.373] Packages needed by the future expression (n = 0): <none>
[13:36:36.374] Packages needed by future strategies (n = 0): <none>
[13:36:36.374] {
[13:36:36.374]     {
[13:36:36.374]         {
[13:36:36.374]             ...future.startTime <- base::Sys.time()
[13:36:36.374]             {
[13:36:36.374]                 {
[13:36:36.374]                   {
[13:36:36.374]                     {
[13:36:36.374]                       base::local({
[13:36:36.374]                         has_future <- base::requireNamespace("future", 
[13:36:36.374]                           quietly = TRUE)
[13:36:36.374]                         if (has_future) {
[13:36:36.374]                           ns <- base::getNamespace("future")
[13:36:36.374]                           version <- ns[[".package"]][["version"]]
[13:36:36.374]                           if (is.null(version)) 
[13:36:36.374]                             version <- utils::packageVersion("future")
[13:36:36.374]                         }
[13:36:36.374]                         else {
[13:36:36.374]                           version <- NULL
[13:36:36.374]                         }
[13:36:36.374]                         if (!has_future || version < "1.8.0") {
[13:36:36.374]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.374]                             "", base::R.version$version.string), 
[13:36:36.374]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.374]                               "release", "version")], collapse = " "), 
[13:36:36.374]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.374]                             info)
[13:36:36.374]                           info <- base::paste(info, collapse = "; ")
[13:36:36.374]                           if (!has_future) {
[13:36:36.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.374]                               info)
[13:36:36.374]                           }
[13:36:36.374]                           else {
[13:36:36.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.374]                               info, version)
[13:36:36.374]                           }
[13:36:36.374]                           base::stop(msg)
[13:36:36.374]                         }
[13:36:36.374]                       })
[13:36:36.374]                     }
[13:36:36.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.374]                     base::options(mc.cores = 1L)
[13:36:36.374]                   }
[13:36:36.374]                   ...future.strategy.old <- future::plan("list")
[13:36:36.374]                   options(future.plan = NULL)
[13:36:36.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.374]                 }
[13:36:36.374]                 ...future.workdir <- getwd()
[13:36:36.374]             }
[13:36:36.374]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.374]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.374]         }
[13:36:36.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.374]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.374]             base::names(...future.oldOptions))
[13:36:36.374]     }
[13:36:36.374]     if (FALSE) {
[13:36:36.374]     }
[13:36:36.374]     else {
[13:36:36.374]         if (TRUE) {
[13:36:36.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.374]                 open = "w")
[13:36:36.374]         }
[13:36:36.374]         else {
[13:36:36.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.374]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.374]         }
[13:36:36.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.374]             base::sink(type = "output", split = FALSE)
[13:36:36.374]             base::close(...future.stdout)
[13:36:36.374]         }, add = TRUE)
[13:36:36.374]     }
[13:36:36.374]     ...future.frame <- base::sys.nframe()
[13:36:36.374]     ...future.conditions <- base::list()
[13:36:36.374]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.374]     if (FALSE) {
[13:36:36.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.374]     }
[13:36:36.374]     ...future.result <- base::tryCatch({
[13:36:36.374]         base::withCallingHandlers({
[13:36:36.374]             ...future.value <- base::withVisible(base::local({
[13:36:36.374]                 withCallingHandlers({
[13:36:36.374]                   {
[13:36:36.374]                     4
[13:36:36.374]                   }
[13:36:36.374]                 }, immediateCondition = function(cond) {
[13:36:36.374]                   save_rds <- function (object, pathname, ...) 
[13:36:36.374]                   {
[13:36:36.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:36.374]                     if (file_test("-f", pathname_tmp)) {
[13:36:36.374]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:36.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.374]                         fi_tmp[["mtime"]])
[13:36:36.374]                     }
[13:36:36.374]                     tryCatch({
[13:36:36.374]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:36.374]                     }, error = function(ex) {
[13:36:36.374]                       msg <- conditionMessage(ex)
[13:36:36.374]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:36.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.374]                         fi_tmp[["mtime"]], msg)
[13:36:36.374]                       ex$message <- msg
[13:36:36.374]                       stop(ex)
[13:36:36.374]                     })
[13:36:36.374]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:36.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:36.374]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:36.374]                       fi_tmp <- file.info(pathname_tmp)
[13:36:36.374]                       fi <- file.info(pathname)
[13:36:36.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:36.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:36.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:36.374]                         fi[["size"]], fi[["mtime"]])
[13:36:36.374]                       stop(msg)
[13:36:36.374]                     }
[13:36:36.374]                     invisible(pathname)
[13:36:36.374]                   }
[13:36:36.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:36.374]                     rootPath = tempdir()) 
[13:36:36.374]                   {
[13:36:36.374]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:36.374]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:36.374]                       tmpdir = path, fileext = ".rds")
[13:36:36.374]                     save_rds(obj, file)
[13:36:36.374]                   }
[13:36:36.374]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:36.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.374]                   {
[13:36:36.374]                     inherits <- base::inherits
[13:36:36.374]                     invokeRestart <- base::invokeRestart
[13:36:36.374]                     is.null <- base::is.null
[13:36:36.374]                     muffled <- FALSE
[13:36:36.374]                     if (inherits(cond, "message")) {
[13:36:36.374]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.374]                       if (muffled) 
[13:36:36.374]                         invokeRestart("muffleMessage")
[13:36:36.374]                     }
[13:36:36.374]                     else if (inherits(cond, "warning")) {
[13:36:36.374]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.374]                       if (muffled) 
[13:36:36.374]                         invokeRestart("muffleWarning")
[13:36:36.374]                     }
[13:36:36.374]                     else if (inherits(cond, "condition")) {
[13:36:36.374]                       if (!is.null(pattern)) {
[13:36:36.374]                         computeRestarts <- base::computeRestarts
[13:36:36.374]                         grepl <- base::grepl
[13:36:36.374]                         restarts <- computeRestarts(cond)
[13:36:36.374]                         for (restart in restarts) {
[13:36:36.374]                           name <- restart$name
[13:36:36.374]                           if (is.null(name)) 
[13:36:36.374]                             next
[13:36:36.374]                           if (!grepl(pattern, name)) 
[13:36:36.374]                             next
[13:36:36.374]                           invokeRestart(restart)
[13:36:36.374]                           muffled <- TRUE
[13:36:36.374]                           break
[13:36:36.374]                         }
[13:36:36.374]                       }
[13:36:36.374]                     }
[13:36:36.374]                     invisible(muffled)
[13:36:36.374]                   }
[13:36:36.374]                   muffleCondition(cond)
[13:36:36.374]                 })
[13:36:36.374]             }))
[13:36:36.374]             future::FutureResult(value = ...future.value$value, 
[13:36:36.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.374]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.374]                     ...future.globalenv.names))
[13:36:36.374]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.374]         }, condition = base::local({
[13:36:36.374]             c <- base::c
[13:36:36.374]             inherits <- base::inherits
[13:36:36.374]             invokeRestart <- base::invokeRestart
[13:36:36.374]             length <- base::length
[13:36:36.374]             list <- base::list
[13:36:36.374]             seq.int <- base::seq.int
[13:36:36.374]             signalCondition <- base::signalCondition
[13:36:36.374]             sys.calls <- base::sys.calls
[13:36:36.374]             `[[` <- base::`[[`
[13:36:36.374]             `+` <- base::`+`
[13:36:36.374]             `<<-` <- base::`<<-`
[13:36:36.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.374]                   3L)]
[13:36:36.374]             }
[13:36:36.374]             function(cond) {
[13:36:36.374]                 is_error <- inherits(cond, "error")
[13:36:36.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.374]                   NULL)
[13:36:36.374]                 if (is_error) {
[13:36:36.374]                   sessionInformation <- function() {
[13:36:36.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.374]                       search = base::search(), system = base::Sys.info())
[13:36:36.374]                   }
[13:36:36.374]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.374]                     cond$call), session = sessionInformation(), 
[13:36:36.374]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.374]                   signalCondition(cond)
[13:36:36.374]                 }
[13:36:36.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.374]                 "immediateCondition"))) {
[13:36:36.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.374]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.374]                   if (TRUE && !signal) {
[13:36:36.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.374]                     {
[13:36:36.374]                       inherits <- base::inherits
[13:36:36.374]                       invokeRestart <- base::invokeRestart
[13:36:36.374]                       is.null <- base::is.null
[13:36:36.374]                       muffled <- FALSE
[13:36:36.374]                       if (inherits(cond, "message")) {
[13:36:36.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.374]                         if (muffled) 
[13:36:36.374]                           invokeRestart("muffleMessage")
[13:36:36.374]                       }
[13:36:36.374]                       else if (inherits(cond, "warning")) {
[13:36:36.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.374]                         if (muffled) 
[13:36:36.374]                           invokeRestart("muffleWarning")
[13:36:36.374]                       }
[13:36:36.374]                       else if (inherits(cond, "condition")) {
[13:36:36.374]                         if (!is.null(pattern)) {
[13:36:36.374]                           computeRestarts <- base::computeRestarts
[13:36:36.374]                           grepl <- base::grepl
[13:36:36.374]                           restarts <- computeRestarts(cond)
[13:36:36.374]                           for (restart in restarts) {
[13:36:36.374]                             name <- restart$name
[13:36:36.374]                             if (is.null(name)) 
[13:36:36.374]                               next
[13:36:36.374]                             if (!grepl(pattern, name)) 
[13:36:36.374]                               next
[13:36:36.374]                             invokeRestart(restart)
[13:36:36.374]                             muffled <- TRUE
[13:36:36.374]                             break
[13:36:36.374]                           }
[13:36:36.374]                         }
[13:36:36.374]                       }
[13:36:36.374]                       invisible(muffled)
[13:36:36.374]                     }
[13:36:36.374]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.374]                   }
[13:36:36.374]                 }
[13:36:36.374]                 else {
[13:36:36.374]                   if (TRUE) {
[13:36:36.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.374]                     {
[13:36:36.374]                       inherits <- base::inherits
[13:36:36.374]                       invokeRestart <- base::invokeRestart
[13:36:36.374]                       is.null <- base::is.null
[13:36:36.374]                       muffled <- FALSE
[13:36:36.374]                       if (inherits(cond, "message")) {
[13:36:36.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.374]                         if (muffled) 
[13:36:36.374]                           invokeRestart("muffleMessage")
[13:36:36.374]                       }
[13:36:36.374]                       else if (inherits(cond, "warning")) {
[13:36:36.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.374]                         if (muffled) 
[13:36:36.374]                           invokeRestart("muffleWarning")
[13:36:36.374]                       }
[13:36:36.374]                       else if (inherits(cond, "condition")) {
[13:36:36.374]                         if (!is.null(pattern)) {
[13:36:36.374]                           computeRestarts <- base::computeRestarts
[13:36:36.374]                           grepl <- base::grepl
[13:36:36.374]                           restarts <- computeRestarts(cond)
[13:36:36.374]                           for (restart in restarts) {
[13:36:36.374]                             name <- restart$name
[13:36:36.374]                             if (is.null(name)) 
[13:36:36.374]                               next
[13:36:36.374]                             if (!grepl(pattern, name)) 
[13:36:36.374]                               next
[13:36:36.374]                             invokeRestart(restart)
[13:36:36.374]                             muffled <- TRUE
[13:36:36.374]                             break
[13:36:36.374]                           }
[13:36:36.374]                         }
[13:36:36.374]                       }
[13:36:36.374]                       invisible(muffled)
[13:36:36.374]                     }
[13:36:36.374]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.374]                   }
[13:36:36.374]                 }
[13:36:36.374]             }
[13:36:36.374]         }))
[13:36:36.374]     }, error = function(ex) {
[13:36:36.374]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.374]                 ...future.rng), started = ...future.startTime, 
[13:36:36.374]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.374]             version = "1.8"), class = "FutureResult")
[13:36:36.374]     }, finally = {
[13:36:36.374]         if (!identical(...future.workdir, getwd())) 
[13:36:36.374]             setwd(...future.workdir)
[13:36:36.374]         {
[13:36:36.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.374]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.374]             }
[13:36:36.374]             base::options(...future.oldOptions)
[13:36:36.374]             if (.Platform$OS.type == "windows") {
[13:36:36.374]                 old_names <- names(...future.oldEnvVars)
[13:36:36.374]                 envs <- base::Sys.getenv()
[13:36:36.374]                 names <- names(envs)
[13:36:36.374]                 common <- intersect(names, old_names)
[13:36:36.374]                 added <- setdiff(names, old_names)
[13:36:36.374]                 removed <- setdiff(old_names, names)
[13:36:36.374]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.374]                   envs[common]]
[13:36:36.374]                 NAMES <- toupper(changed)
[13:36:36.374]                 args <- list()
[13:36:36.374]                 for (kk in seq_along(NAMES)) {
[13:36:36.374]                   name <- changed[[kk]]
[13:36:36.374]                   NAME <- NAMES[[kk]]
[13:36:36.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.374]                     next
[13:36:36.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.374]                 }
[13:36:36.374]                 NAMES <- toupper(added)
[13:36:36.374]                 for (kk in seq_along(NAMES)) {
[13:36:36.374]                   name <- added[[kk]]
[13:36:36.374]                   NAME <- NAMES[[kk]]
[13:36:36.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.374]                     next
[13:36:36.374]                   args[[name]] <- ""
[13:36:36.374]                 }
[13:36:36.374]                 NAMES <- toupper(removed)
[13:36:36.374]                 for (kk in seq_along(NAMES)) {
[13:36:36.374]                   name <- removed[[kk]]
[13:36:36.374]                   NAME <- NAMES[[kk]]
[13:36:36.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.374]                     next
[13:36:36.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.374]                 }
[13:36:36.374]                 if (length(args) > 0) 
[13:36:36.374]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.374]             }
[13:36:36.374]             else {
[13:36:36.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.374]             }
[13:36:36.374]             {
[13:36:36.374]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.374]                   0L) {
[13:36:36.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.374]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.374]                   base::options(opts)
[13:36:36.374]                 }
[13:36:36.374]                 {
[13:36:36.374]                   {
[13:36:36.374]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.374]                     NULL
[13:36:36.374]                   }
[13:36:36.374]                   options(future.plan = NULL)
[13:36:36.374]                   if (is.na(NA_character_)) 
[13:36:36.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.374]                     .init = FALSE)
[13:36:36.374]                 }
[13:36:36.374]             }
[13:36:36.374]         }
[13:36:36.374]     })
[13:36:36.374]     if (TRUE) {
[13:36:36.374]         base::sink(type = "output", split = FALSE)
[13:36:36.374]         if (TRUE) {
[13:36:36.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.374]         }
[13:36:36.374]         else {
[13:36:36.374]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.374]         }
[13:36:36.374]         base::close(...future.stdout)
[13:36:36.374]         ...future.stdout <- NULL
[13:36:36.374]     }
[13:36:36.374]     ...future.result$conditions <- ...future.conditions
[13:36:36.374]     ...future.result$finished <- base::Sys.time()
[13:36:36.374]     ...future.result
[13:36:36.374] }
[13:36:36.378] requestCore(): workers = 2
[13:36:36.378] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:36.389] result() for MulticoreFuture ...
[13:36:36.390] result() for MulticoreFuture ...
[13:36:36.390] result() for MulticoreFuture ... done
[13:36:36.391] result() for MulticoreFuture ... done
[13:36:36.391] result() for MulticoreFuture ...
[13:36:36.391] result() for MulticoreFuture ... done
[13:36:36.394] MulticoreFuture started
[13:36:36.395] - Launch lazy future ... done
[13:36:36.395] run() for ‘MulticoreFuture’ ... done
[13:36:36.395] plan(): Setting new future strategy stack:
<environment: 0x564a737283a8> 
[13:36:36.396] List of future strategies:
[13:36:36.396] 1. sequential:
[13:36:36.396]    - args: function (..., envir = parent.frame())
[13:36:36.396]    - tweaked: FALSE
[13:36:36.396]    - call: NULL
[13:36:36.397] plan(): nbrOfWorkers() = 1
<environment: 0x564a73aa52a0> 
[13:36:36.399] plan(): Setting new future strategy stack:
[13:36:36.399] List of future strategies:
[13:36:36.399] 1. multicore:
[13:36:36.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:36.399]    - tweaked: FALSE
[13:36:36.399]    - call: plan(strategy)
[13:36:36.404] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:36.407] resolve() on environment ...
[13:36:36.407]  recursive: 0
[13:36:36.408]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:36.408] signalConditionsASAP(numeric, pos=1) ...
[13:36:36.408] - nx: 4
[13:36:36.408] - relay: TRUE
[13:36:36.408] - stdout: TRUE
[13:36:36.408] - signal: TRUE
[13:36:36.409] - resignal: FALSE
[13:36:36.409] - force: TRUE
[13:36:36.409] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.409] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.409]  - until=2
[13:36:36.409]  - relaying element #2
[13:36:36.409] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.410] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.410] signalConditionsASAP(NULL, pos=1) ... done
[13:36:36.410]  length: 3 (resolved future 1)
[13:36:36.410] Future #2
[13:36:36.410] result() for MulticoreFuture ...
[13:36:36.411] result() for MulticoreFuture ... done
[13:36:36.411] result() for MulticoreFuture ...
[13:36:36.411] result() for MulticoreFuture ... done
[13:36:36.411] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:36.411] - nx: 4
[13:36:36.411] - relay: TRUE
[13:36:36.411] - stdout: TRUE
[13:36:36.412] - signal: TRUE
[13:36:36.412] - resignal: FALSE
[13:36:36.412] - force: TRUE
[13:36:36.412] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.412] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.412]  - until=2
[13:36:36.412]  - relaying element #2
[13:36:36.412] result() for MulticoreFuture ...
[13:36:36.413] result() for MulticoreFuture ... done
[13:36:36.413] result() for MulticoreFuture ...
[13:36:36.413] result() for MulticoreFuture ... done
[13:36:36.413] result() for MulticoreFuture ...
[13:36:36.413] result() for MulticoreFuture ... done
[13:36:36.413] result() for MulticoreFuture ...
[13:36:36.413] result() for MulticoreFuture ... done
[13:36:36.414] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.414] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.414] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:36.414]  length: 2 (resolved future 2)
[13:36:36.414] Future #3
[13:36:36.415] result() for MulticoreFuture ...
[13:36:36.415] result() for MulticoreFuture ...
[13:36:36.416] result() for MulticoreFuture ... done
[13:36:36.416] result() for MulticoreFuture ... done
[13:36:36.416] result() for MulticoreFuture ...
[13:36:36.416] result() for MulticoreFuture ... done
[13:36:36.416] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:36.417] - nx: 4
[13:36:36.417] - relay: TRUE
[13:36:36.417] - stdout: TRUE
[13:36:36.417] - signal: TRUE
[13:36:36.417] - resignal: FALSE
[13:36:36.417] - force: TRUE
[13:36:36.417] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.418] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.418]  - until=3
[13:36:36.418]  - relaying element #3
[13:36:36.418] result() for MulticoreFuture ...
[13:36:36.418] result() for MulticoreFuture ... done
[13:36:36.419] result() for MulticoreFuture ...
[13:36:36.419] result() for MulticoreFuture ... done
[13:36:36.419] result() for MulticoreFuture ...
[13:36:36.419] result() for MulticoreFuture ... done
[13:36:36.419] result() for MulticoreFuture ...
[13:36:36.419] result() for MulticoreFuture ... done
[13:36:36.420] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.420] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.420] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:36.420]  length: 1 (resolved future 3)
[13:36:36.420] Future #4
[13:36:36.420] result() for MulticoreFuture ...
[13:36:36.421] result() for MulticoreFuture ...
[13:36:36.421] result() for MulticoreFuture ... done
[13:36:36.421] result() for MulticoreFuture ... done
[13:36:36.422] result() for MulticoreFuture ...
[13:36:36.422] result() for MulticoreFuture ... done
[13:36:36.422] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:36.422] - nx: 4
[13:36:36.422] - relay: TRUE
[13:36:36.423] - stdout: TRUE
[13:36:36.423] - signal: TRUE
[13:36:36.423] - resignal: FALSE
[13:36:36.423] - force: TRUE
[13:36:36.423] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.423] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.424]  - until=4
[13:36:36.424]  - relaying element #4
[13:36:36.424] result() for MulticoreFuture ...
[13:36:36.424] result() for MulticoreFuture ... done
[13:36:36.424] result() for MulticoreFuture ...
[13:36:36.424] result() for MulticoreFuture ... done
[13:36:36.424] result() for MulticoreFuture ...
[13:36:36.425] result() for MulticoreFuture ... done
[13:36:36.425] result() for MulticoreFuture ...
[13:36:36.425] result() for MulticoreFuture ... done
[13:36:36.425] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.425] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.425] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:36.425]  length: 0 (resolved future 4)
[13:36:36.426] Relaying remaining futures
[13:36:36.426] signalConditionsASAP(NULL, pos=0) ...
[13:36:36.426] - nx: 4
[13:36:36.426] - relay: TRUE
[13:36:36.426] - stdout: TRUE
[13:36:36.426] - signal: TRUE
[13:36:36.426] - resignal: FALSE
[13:36:36.426] - force: TRUE
[13:36:36.426] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.426] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:36.427] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.427] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.427] signalConditionsASAP(NULL, pos=0) ... done
[13:36:36.427] resolve() on environment ... DONE
[13:36:36.427] result() for MulticoreFuture ...
[13:36:36.427] result() for MulticoreFuture ... done
[13:36:36.427] result() for MulticoreFuture ...
[13:36:36.427] result() for MulticoreFuture ... done
[13:36:36.427] result() for MulticoreFuture ...
[13:36:36.428] result() for MulticoreFuture ... done
[13:36:36.428] result() for MulticoreFuture ...
[13:36:36.428] result() for MulticoreFuture ... done
[13:36:36.428] result() for MulticoreFuture ...
[13:36:36.428] result() for MulticoreFuture ... done
[13:36:36.428] result() for MulticoreFuture ...
[13:36:36.428] result() for MulticoreFuture ... done
<environment: 0x564a73a69dd0> 
Type of future: multisession
[13:36:36.429] plan(): Setting new future strategy stack:
[13:36:36.429] List of future strategies:
[13:36:36.429] 1. multisession:
[13:36:36.429]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:36.429]    - tweaked: FALSE
[13:36:36.429]    - call: plan(strategy)
[13:36:36.429] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:36:36.429] multisession:
[13:36:36.429] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:36.429] - tweaked: FALSE
[13:36:36.429] - call: plan(strategy)
[13:36:36.433] getGlobalsAndPackages() ...
[13:36:36.434] Not searching for globals
[13:36:36.434] - globals: [0] <none>
[13:36:36.434] getGlobalsAndPackages() ... DONE
[13:36:36.434] [local output] makeClusterPSOCK() ...
[13:36:36.438] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:36:36.438] [local output] Base port: 11633
[13:36:36.438] [local output] Getting setup options for 2 cluster nodes ...
[13:36:36.439] [local output]  - Node 1 of 2 ...
[13:36:36.439] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:36.440] [local output] Rscript port: 11633

[13:36:36.440] [local output]  - Node 2 of 2 ...
[13:36:36.440] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:36.441] [local output] Rscript port: 11633

[13:36:36.441] [local output] Getting setup options for 2 cluster nodes ... done
[13:36:36.441] [local output]  - Parallel setup requested for some PSOCK nodes
[13:36:36.442] [local output] Setting up PSOCK nodes in parallel
[13:36:36.442] List of 36
[13:36:36.442]  $ worker          : chr "localhost"
[13:36:36.442]   ..- attr(*, "localhost")= logi TRUE
[13:36:36.442]  $ master          : chr "localhost"
[13:36:36.442]  $ port            : int 11633
[13:36:36.442]  $ connectTimeout  : num 120
[13:36:36.442]  $ timeout         : num 2592000
[13:36:36.442]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:36:36.442]  $ homogeneous     : logi TRUE
[13:36:36.442]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:36:36.442]  $ rscript_envs    : NULL
[13:36:36.442]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:36.442]  $ rscript_startup : NULL
[13:36:36.442]  $ rscript_sh      : chr "sh"
[13:36:36.442]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:36.442]  $ methods         : logi TRUE
[13:36:36.442]  $ socketOptions   : chr "no-delay"
[13:36:36.442]  $ useXDR          : logi FALSE
[13:36:36.442]  $ outfile         : chr "/dev/null"
[13:36:36.442]  $ renice          : int NA
[13:36:36.442]  $ rshcmd          : NULL
[13:36:36.442]  $ user            : chr(0) 
[13:36:36.442]  $ revtunnel       : logi FALSE
[13:36:36.442]  $ rshlogfile      : NULL
[13:36:36.442]  $ rshopts         : chr(0) 
[13:36:36.442]  $ rank            : int 1
[13:36:36.442]  $ manual          : logi FALSE
[13:36:36.442]  $ dryrun          : logi FALSE
[13:36:36.442]  $ quiet           : logi FALSE
[13:36:36.442]  $ setup_strategy  : chr "parallel"
[13:36:36.442]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:36.442]  $ pidfile         : chr "/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af51d0756d.pid"
[13:36:36.442]  $ rshcmd_label    : NULL
[13:36:36.442]  $ rsh_call        : NULL
[13:36:36.442]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:36.442]  $ localMachine    : logi TRUE
[13:36:36.442]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:36:36.442]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:36:36.442]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:36:36.442]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:36:36.442]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:36:36.442]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:36:36.442]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:36:36.442]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:36:36.442]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:36:36.442]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:36:36.442]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:36:36.442]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:36:36.442]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:36:36.442]  $ arguments       :List of 28
[13:36:36.442]   ..$ worker          : chr "localhost"
[13:36:36.442]   ..$ master          : NULL
[13:36:36.442]   ..$ port            : int 11633
[13:36:36.442]   ..$ connectTimeout  : num 120
[13:36:36.442]   ..$ timeout         : num 2592000
[13:36:36.442]   ..$ rscript         : NULL
[13:36:36.442]   ..$ homogeneous     : NULL
[13:36:36.442]   ..$ rscript_args    : NULL
[13:36:36.442]   ..$ rscript_envs    : NULL
[13:36:36.442]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:36.442]   ..$ rscript_startup : NULL
[13:36:36.442]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:36:36.442]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:36.442]   ..$ methods         : logi TRUE
[13:36:36.442]   ..$ socketOptions   : chr "no-delay"
[13:36:36.442]   ..$ useXDR          : logi FALSE
[13:36:36.442]   ..$ outfile         : chr "/dev/null"
[13:36:36.442]   ..$ renice          : int NA
[13:36:36.442]   ..$ rshcmd          : NULL
[13:36:36.442]   ..$ user            : NULL
[13:36:36.442]   ..$ revtunnel       : logi NA
[13:36:36.442]   ..$ rshlogfile      : NULL
[13:36:36.442]   ..$ rshopts         : NULL
[13:36:36.442]   ..$ rank            : int 1
[13:36:36.442]   ..$ manual          : logi FALSE
[13:36:36.442]   ..$ dryrun          : logi FALSE
[13:36:36.442]   ..$ quiet           : logi FALSE
[13:36:36.442]   ..$ setup_strategy  : chr "parallel"
[13:36:36.442]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:36:36.466] [local output] System call to launch all workers:
[13:36:36.466] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af51d0756d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11633 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:36:36.466] [local output] Starting PSOCK main server
[13:36:36.467] [local output] Workers launched
[13:36:36.468] [local output] Waiting for workers to connect back
[13:36:36.468]  - [local output] 0 workers out of 2 ready
[13:36:36.729]  - [local output] 0 workers out of 2 ready
[13:36:36.729]  - [local output] 1 workers out of 2 ready
[13:36:36.735]  - [local output] 1 workers out of 2 ready
[13:36:36.735]  - [local output] 2 workers out of 2 ready
[13:36:36.735] [local output] Launching of workers completed
[13:36:36.735] [local output] Collecting session information from workers
[13:36:36.736] [local output]  - Worker #1 of 2
[13:36:36.736] [local output]  - Worker #2 of 2
[13:36:36.737] [local output] makeClusterPSOCK() ... done
[13:36:36.748] Packages needed by the future expression (n = 0): <none>
[13:36:36.748] Packages needed by future strategies (n = 0): <none>
[13:36:36.748] {
[13:36:36.748]     {
[13:36:36.748]         {
[13:36:36.748]             ...future.startTime <- base::Sys.time()
[13:36:36.748]             {
[13:36:36.748]                 {
[13:36:36.748]                   {
[13:36:36.748]                     {
[13:36:36.748]                       base::local({
[13:36:36.748]                         has_future <- base::requireNamespace("future", 
[13:36:36.748]                           quietly = TRUE)
[13:36:36.748]                         if (has_future) {
[13:36:36.748]                           ns <- base::getNamespace("future")
[13:36:36.748]                           version <- ns[[".package"]][["version"]]
[13:36:36.748]                           if (is.null(version)) 
[13:36:36.748]                             version <- utils::packageVersion("future")
[13:36:36.748]                         }
[13:36:36.748]                         else {
[13:36:36.748]                           version <- NULL
[13:36:36.748]                         }
[13:36:36.748]                         if (!has_future || version < "1.8.0") {
[13:36:36.748]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.748]                             "", base::R.version$version.string), 
[13:36:36.748]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.748]                               "release", "version")], collapse = " "), 
[13:36:36.748]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.748]                             info)
[13:36:36.748]                           info <- base::paste(info, collapse = "; ")
[13:36:36.748]                           if (!has_future) {
[13:36:36.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.748]                               info)
[13:36:36.748]                           }
[13:36:36.748]                           else {
[13:36:36.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.748]                               info, version)
[13:36:36.748]                           }
[13:36:36.748]                           base::stop(msg)
[13:36:36.748]                         }
[13:36:36.748]                       })
[13:36:36.748]                     }
[13:36:36.748]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.748]                     base::options(mc.cores = 1L)
[13:36:36.748]                   }
[13:36:36.748]                   ...future.strategy.old <- future::plan("list")
[13:36:36.748]                   options(future.plan = NULL)
[13:36:36.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.748]                 }
[13:36:36.748]                 ...future.workdir <- getwd()
[13:36:36.748]             }
[13:36:36.748]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.748]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.748]         }
[13:36:36.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.748]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.748]             base::names(...future.oldOptions))
[13:36:36.748]     }
[13:36:36.748]     if (FALSE) {
[13:36:36.748]     }
[13:36:36.748]     else {
[13:36:36.748]         if (TRUE) {
[13:36:36.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.748]                 open = "w")
[13:36:36.748]         }
[13:36:36.748]         else {
[13:36:36.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.748]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.748]         }
[13:36:36.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.748]             base::sink(type = "output", split = FALSE)
[13:36:36.748]             base::close(...future.stdout)
[13:36:36.748]         }, add = TRUE)
[13:36:36.748]     }
[13:36:36.748]     ...future.frame <- base::sys.nframe()
[13:36:36.748]     ...future.conditions <- base::list()
[13:36:36.748]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.748]     if (FALSE) {
[13:36:36.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.748]     }
[13:36:36.748]     ...future.result <- base::tryCatch({
[13:36:36.748]         base::withCallingHandlers({
[13:36:36.748]             ...future.value <- base::withVisible(base::local({
[13:36:36.748]                 ...future.makeSendCondition <- base::local({
[13:36:36.748]                   sendCondition <- NULL
[13:36:36.748]                   function(frame = 1L) {
[13:36:36.748]                     if (is.function(sendCondition)) 
[13:36:36.748]                       return(sendCondition)
[13:36:36.748]                     ns <- getNamespace("parallel")
[13:36:36.748]                     if (exists("sendData", mode = "function", 
[13:36:36.748]                       envir = ns)) {
[13:36:36.748]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:36.748]                         envir = ns)
[13:36:36.748]                       envir <- sys.frame(frame)
[13:36:36.748]                       master <- NULL
[13:36:36.748]                       while (!identical(envir, .GlobalEnv) && 
[13:36:36.748]                         !identical(envir, emptyenv())) {
[13:36:36.748]                         if (exists("master", mode = "list", envir = envir, 
[13:36:36.748]                           inherits = FALSE)) {
[13:36:36.748]                           master <- get("master", mode = "list", 
[13:36:36.748]                             envir = envir, inherits = FALSE)
[13:36:36.748]                           if (inherits(master, c("SOCKnode", 
[13:36:36.748]                             "SOCK0node"))) {
[13:36:36.748]                             sendCondition <<- function(cond) {
[13:36:36.748]                               data <- list(type = "VALUE", value = cond, 
[13:36:36.748]                                 success = TRUE)
[13:36:36.748]                               parallel_sendData(master, data)
[13:36:36.748]                             }
[13:36:36.748]                             return(sendCondition)
[13:36:36.748]                           }
[13:36:36.748]                         }
[13:36:36.748]                         frame <- frame + 1L
[13:36:36.748]                         envir <- sys.frame(frame)
[13:36:36.748]                       }
[13:36:36.748]                     }
[13:36:36.748]                     sendCondition <<- function(cond) NULL
[13:36:36.748]                   }
[13:36:36.748]                 })
[13:36:36.748]                 withCallingHandlers({
[13:36:36.748]                   NA
[13:36:36.748]                 }, immediateCondition = function(cond) {
[13:36:36.748]                   sendCondition <- ...future.makeSendCondition()
[13:36:36.748]                   sendCondition(cond)
[13:36:36.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.748]                   {
[13:36:36.748]                     inherits <- base::inherits
[13:36:36.748]                     invokeRestart <- base::invokeRestart
[13:36:36.748]                     is.null <- base::is.null
[13:36:36.748]                     muffled <- FALSE
[13:36:36.748]                     if (inherits(cond, "message")) {
[13:36:36.748]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.748]                       if (muffled) 
[13:36:36.748]                         invokeRestart("muffleMessage")
[13:36:36.748]                     }
[13:36:36.748]                     else if (inherits(cond, "warning")) {
[13:36:36.748]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.748]                       if (muffled) 
[13:36:36.748]                         invokeRestart("muffleWarning")
[13:36:36.748]                     }
[13:36:36.748]                     else if (inherits(cond, "condition")) {
[13:36:36.748]                       if (!is.null(pattern)) {
[13:36:36.748]                         computeRestarts <- base::computeRestarts
[13:36:36.748]                         grepl <- base::grepl
[13:36:36.748]                         restarts <- computeRestarts(cond)
[13:36:36.748]                         for (restart in restarts) {
[13:36:36.748]                           name <- restart$name
[13:36:36.748]                           if (is.null(name)) 
[13:36:36.748]                             next
[13:36:36.748]                           if (!grepl(pattern, name)) 
[13:36:36.748]                             next
[13:36:36.748]                           invokeRestart(restart)
[13:36:36.748]                           muffled <- TRUE
[13:36:36.748]                           break
[13:36:36.748]                         }
[13:36:36.748]                       }
[13:36:36.748]                     }
[13:36:36.748]                     invisible(muffled)
[13:36:36.748]                   }
[13:36:36.748]                   muffleCondition(cond)
[13:36:36.748]                 })
[13:36:36.748]             }))
[13:36:36.748]             future::FutureResult(value = ...future.value$value, 
[13:36:36.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.748]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.748]                     ...future.globalenv.names))
[13:36:36.748]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.748]         }, condition = base::local({
[13:36:36.748]             c <- base::c
[13:36:36.748]             inherits <- base::inherits
[13:36:36.748]             invokeRestart <- base::invokeRestart
[13:36:36.748]             length <- base::length
[13:36:36.748]             list <- base::list
[13:36:36.748]             seq.int <- base::seq.int
[13:36:36.748]             signalCondition <- base::signalCondition
[13:36:36.748]             sys.calls <- base::sys.calls
[13:36:36.748]             `[[` <- base::`[[`
[13:36:36.748]             `+` <- base::`+`
[13:36:36.748]             `<<-` <- base::`<<-`
[13:36:36.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.748]                   3L)]
[13:36:36.748]             }
[13:36:36.748]             function(cond) {
[13:36:36.748]                 is_error <- inherits(cond, "error")
[13:36:36.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.748]                   NULL)
[13:36:36.748]                 if (is_error) {
[13:36:36.748]                   sessionInformation <- function() {
[13:36:36.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.748]                       search = base::search(), system = base::Sys.info())
[13:36:36.748]                   }
[13:36:36.748]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.748]                     cond$call), session = sessionInformation(), 
[13:36:36.748]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.748]                   signalCondition(cond)
[13:36:36.748]                 }
[13:36:36.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.748]                 "immediateCondition"))) {
[13:36:36.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.748]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.748]                   if (TRUE && !signal) {
[13:36:36.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.748]                     {
[13:36:36.748]                       inherits <- base::inherits
[13:36:36.748]                       invokeRestart <- base::invokeRestart
[13:36:36.748]                       is.null <- base::is.null
[13:36:36.748]                       muffled <- FALSE
[13:36:36.748]                       if (inherits(cond, "message")) {
[13:36:36.748]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.748]                         if (muffled) 
[13:36:36.748]                           invokeRestart("muffleMessage")
[13:36:36.748]                       }
[13:36:36.748]                       else if (inherits(cond, "warning")) {
[13:36:36.748]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.748]                         if (muffled) 
[13:36:36.748]                           invokeRestart("muffleWarning")
[13:36:36.748]                       }
[13:36:36.748]                       else if (inherits(cond, "condition")) {
[13:36:36.748]                         if (!is.null(pattern)) {
[13:36:36.748]                           computeRestarts <- base::computeRestarts
[13:36:36.748]                           grepl <- base::grepl
[13:36:36.748]                           restarts <- computeRestarts(cond)
[13:36:36.748]                           for (restart in restarts) {
[13:36:36.748]                             name <- restart$name
[13:36:36.748]                             if (is.null(name)) 
[13:36:36.748]                               next
[13:36:36.748]                             if (!grepl(pattern, name)) 
[13:36:36.748]                               next
[13:36:36.748]                             invokeRestart(restart)
[13:36:36.748]                             muffled <- TRUE
[13:36:36.748]                             break
[13:36:36.748]                           }
[13:36:36.748]                         }
[13:36:36.748]                       }
[13:36:36.748]                       invisible(muffled)
[13:36:36.748]                     }
[13:36:36.748]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.748]                   }
[13:36:36.748]                 }
[13:36:36.748]                 else {
[13:36:36.748]                   if (TRUE) {
[13:36:36.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.748]                     {
[13:36:36.748]                       inherits <- base::inherits
[13:36:36.748]                       invokeRestart <- base::invokeRestart
[13:36:36.748]                       is.null <- base::is.null
[13:36:36.748]                       muffled <- FALSE
[13:36:36.748]                       if (inherits(cond, "message")) {
[13:36:36.748]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.748]                         if (muffled) 
[13:36:36.748]                           invokeRestart("muffleMessage")
[13:36:36.748]                       }
[13:36:36.748]                       else if (inherits(cond, "warning")) {
[13:36:36.748]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.748]                         if (muffled) 
[13:36:36.748]                           invokeRestart("muffleWarning")
[13:36:36.748]                       }
[13:36:36.748]                       else if (inherits(cond, "condition")) {
[13:36:36.748]                         if (!is.null(pattern)) {
[13:36:36.748]                           computeRestarts <- base::computeRestarts
[13:36:36.748]                           grepl <- base::grepl
[13:36:36.748]                           restarts <- computeRestarts(cond)
[13:36:36.748]                           for (restart in restarts) {
[13:36:36.748]                             name <- restart$name
[13:36:36.748]                             if (is.null(name)) 
[13:36:36.748]                               next
[13:36:36.748]                             if (!grepl(pattern, name)) 
[13:36:36.748]                               next
[13:36:36.748]                             invokeRestart(restart)
[13:36:36.748]                             muffled <- TRUE
[13:36:36.748]                             break
[13:36:36.748]                           }
[13:36:36.748]                         }
[13:36:36.748]                       }
[13:36:36.748]                       invisible(muffled)
[13:36:36.748]                     }
[13:36:36.748]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.748]                   }
[13:36:36.748]                 }
[13:36:36.748]             }
[13:36:36.748]         }))
[13:36:36.748]     }, error = function(ex) {
[13:36:36.748]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.748]                 ...future.rng), started = ...future.startTime, 
[13:36:36.748]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.748]             version = "1.8"), class = "FutureResult")
[13:36:36.748]     }, finally = {
[13:36:36.748]         if (!identical(...future.workdir, getwd())) 
[13:36:36.748]             setwd(...future.workdir)
[13:36:36.748]         {
[13:36:36.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.748]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.748]             }
[13:36:36.748]             base::options(...future.oldOptions)
[13:36:36.748]             if (.Platform$OS.type == "windows") {
[13:36:36.748]                 old_names <- names(...future.oldEnvVars)
[13:36:36.748]                 envs <- base::Sys.getenv()
[13:36:36.748]                 names <- names(envs)
[13:36:36.748]                 common <- intersect(names, old_names)
[13:36:36.748]                 added <- setdiff(names, old_names)
[13:36:36.748]                 removed <- setdiff(old_names, names)
[13:36:36.748]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.748]                   envs[common]]
[13:36:36.748]                 NAMES <- toupper(changed)
[13:36:36.748]                 args <- list()
[13:36:36.748]                 for (kk in seq_along(NAMES)) {
[13:36:36.748]                   name <- changed[[kk]]
[13:36:36.748]                   NAME <- NAMES[[kk]]
[13:36:36.748]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.748]                     next
[13:36:36.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.748]                 }
[13:36:36.748]                 NAMES <- toupper(added)
[13:36:36.748]                 for (kk in seq_along(NAMES)) {
[13:36:36.748]                   name <- added[[kk]]
[13:36:36.748]                   NAME <- NAMES[[kk]]
[13:36:36.748]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.748]                     next
[13:36:36.748]                   args[[name]] <- ""
[13:36:36.748]                 }
[13:36:36.748]                 NAMES <- toupper(removed)
[13:36:36.748]                 for (kk in seq_along(NAMES)) {
[13:36:36.748]                   name <- removed[[kk]]
[13:36:36.748]                   NAME <- NAMES[[kk]]
[13:36:36.748]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.748]                     next
[13:36:36.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.748]                 }
[13:36:36.748]                 if (length(args) > 0) 
[13:36:36.748]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.748]             }
[13:36:36.748]             else {
[13:36:36.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.748]             }
[13:36:36.748]             {
[13:36:36.748]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.748]                   0L) {
[13:36:36.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.748]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.748]                   base::options(opts)
[13:36:36.748]                 }
[13:36:36.748]                 {
[13:36:36.748]                   {
[13:36:36.748]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.748]                     NULL
[13:36:36.748]                   }
[13:36:36.748]                   options(future.plan = NULL)
[13:36:36.748]                   if (is.na(NA_character_)) 
[13:36:36.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.748]                     .init = FALSE)
[13:36:36.748]                 }
[13:36:36.748]             }
[13:36:36.748]         }
[13:36:36.748]     })
[13:36:36.748]     if (TRUE) {
[13:36:36.748]         base::sink(type = "output", split = FALSE)
[13:36:36.748]         if (TRUE) {
[13:36:36.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.748]         }
[13:36:36.748]         else {
[13:36:36.748]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.748]         }
[13:36:36.748]         base::close(...future.stdout)
[13:36:36.748]         ...future.stdout <- NULL
[13:36:36.748]     }
[13:36:36.748]     ...future.result$conditions <- ...future.conditions
[13:36:36.748]     ...future.result$finished <- base::Sys.time()
[13:36:36.748]     ...future.result
[13:36:36.748] }
[13:36:36.802] MultisessionFuture started
[13:36:36.802] result() for ClusterFuture ...
[13:36:36.802] receiveMessageFromWorker() for ClusterFuture ...
[13:36:36.802] - Validating connection of MultisessionFuture
[13:36:36.835] - received message: FutureResult
[13:36:36.835] - Received FutureResult
[13:36:36.835] - Erased future from FutureRegistry
[13:36:36.835] result() for ClusterFuture ...
[13:36:36.835] - result already collected: FutureResult
[13:36:36.835] result() for ClusterFuture ... done
[13:36:36.835] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:36.836] result() for ClusterFuture ... done
[13:36:36.836] result() for ClusterFuture ...
[13:36:36.836] - result already collected: FutureResult
[13:36:36.836] result() for ClusterFuture ... done
[13:36:36.836] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:36:36.840] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:36:36.840] getGlobalsAndPackages() ...
[13:36:36.841] Searching for globals...
[13:36:36.841] 
[13:36:36.841] Searching for globals ... DONE
[13:36:36.841] - globals: [0] <none>
[13:36:36.842] getGlobalsAndPackages() ... DONE
[13:36:36.842] run() for ‘Future’ ...
[13:36:36.842] - state: ‘created’
[13:36:36.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:36.856]   - Field: ‘node’
[13:36:36.856]   - Field: ‘label’
[13:36:36.856]   - Field: ‘local’
[13:36:36.857]   - Field: ‘owner’
[13:36:36.857]   - Field: ‘envir’
[13:36:36.857]   - Field: ‘workers’
[13:36:36.857]   - Field: ‘packages’
[13:36:36.857]   - Field: ‘gc’
[13:36:36.857]   - Field: ‘conditions’
[13:36:36.857]   - Field: ‘persistent’
[13:36:36.857]   - Field: ‘expr’
[13:36:36.857]   - Field: ‘uuid’
[13:36:36.858]   - Field: ‘seed’
[13:36:36.858]   - Field: ‘version’
[13:36:36.858]   - Field: ‘result’
[13:36:36.858]   - Field: ‘asynchronous’
[13:36:36.858]   - Field: ‘calls’
[13:36:36.858]   - Field: ‘globals’
[13:36:36.858]   - Field: ‘stdout’
[13:36:36.858]   - Field: ‘earlySignal’
[13:36:36.858]   - Field: ‘lazy’
[13:36:36.859]   - Field: ‘state’
[13:36:36.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:36.859] - Launch lazy future ...
[13:36:36.859] Packages needed by the future expression (n = 0): <none>
[13:36:36.859] Packages needed by future strategies (n = 0): <none>
[13:36:36.860] {
[13:36:36.860]     {
[13:36:36.860]         {
[13:36:36.860]             ...future.startTime <- base::Sys.time()
[13:36:36.860]             {
[13:36:36.860]                 {
[13:36:36.860]                   {
[13:36:36.860]                     {
[13:36:36.860]                       base::local({
[13:36:36.860]                         has_future <- base::requireNamespace("future", 
[13:36:36.860]                           quietly = TRUE)
[13:36:36.860]                         if (has_future) {
[13:36:36.860]                           ns <- base::getNamespace("future")
[13:36:36.860]                           version <- ns[[".package"]][["version"]]
[13:36:36.860]                           if (is.null(version)) 
[13:36:36.860]                             version <- utils::packageVersion("future")
[13:36:36.860]                         }
[13:36:36.860]                         else {
[13:36:36.860]                           version <- NULL
[13:36:36.860]                         }
[13:36:36.860]                         if (!has_future || version < "1.8.0") {
[13:36:36.860]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.860]                             "", base::R.version$version.string), 
[13:36:36.860]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.860]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.860]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.860]                               "release", "version")], collapse = " "), 
[13:36:36.860]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.860]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.860]                             info)
[13:36:36.860]                           info <- base::paste(info, collapse = "; ")
[13:36:36.860]                           if (!has_future) {
[13:36:36.860]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.860]                               info)
[13:36:36.860]                           }
[13:36:36.860]                           else {
[13:36:36.860]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.860]                               info, version)
[13:36:36.860]                           }
[13:36:36.860]                           base::stop(msg)
[13:36:36.860]                         }
[13:36:36.860]                       })
[13:36:36.860]                     }
[13:36:36.860]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.860]                     base::options(mc.cores = 1L)
[13:36:36.860]                   }
[13:36:36.860]                   ...future.strategy.old <- future::plan("list")
[13:36:36.860]                   options(future.plan = NULL)
[13:36:36.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.860]                 }
[13:36:36.860]                 ...future.workdir <- getwd()
[13:36:36.860]             }
[13:36:36.860]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.860]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.860]         }
[13:36:36.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.860]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.860]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.860]             base::names(...future.oldOptions))
[13:36:36.860]     }
[13:36:36.860]     if (FALSE) {
[13:36:36.860]     }
[13:36:36.860]     else {
[13:36:36.860]         if (TRUE) {
[13:36:36.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.860]                 open = "w")
[13:36:36.860]         }
[13:36:36.860]         else {
[13:36:36.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.860]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.860]         }
[13:36:36.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.860]             base::sink(type = "output", split = FALSE)
[13:36:36.860]             base::close(...future.stdout)
[13:36:36.860]         }, add = TRUE)
[13:36:36.860]     }
[13:36:36.860]     ...future.frame <- base::sys.nframe()
[13:36:36.860]     ...future.conditions <- base::list()
[13:36:36.860]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.860]     if (FALSE) {
[13:36:36.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.860]     }
[13:36:36.860]     ...future.result <- base::tryCatch({
[13:36:36.860]         base::withCallingHandlers({
[13:36:36.860]             ...future.value <- base::withVisible(base::local({
[13:36:36.860]                 ...future.makeSendCondition <- base::local({
[13:36:36.860]                   sendCondition <- NULL
[13:36:36.860]                   function(frame = 1L) {
[13:36:36.860]                     if (is.function(sendCondition)) 
[13:36:36.860]                       return(sendCondition)
[13:36:36.860]                     ns <- getNamespace("parallel")
[13:36:36.860]                     if (exists("sendData", mode = "function", 
[13:36:36.860]                       envir = ns)) {
[13:36:36.860]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:36.860]                         envir = ns)
[13:36:36.860]                       envir <- sys.frame(frame)
[13:36:36.860]                       master <- NULL
[13:36:36.860]                       while (!identical(envir, .GlobalEnv) && 
[13:36:36.860]                         !identical(envir, emptyenv())) {
[13:36:36.860]                         if (exists("master", mode = "list", envir = envir, 
[13:36:36.860]                           inherits = FALSE)) {
[13:36:36.860]                           master <- get("master", mode = "list", 
[13:36:36.860]                             envir = envir, inherits = FALSE)
[13:36:36.860]                           if (inherits(master, c("SOCKnode", 
[13:36:36.860]                             "SOCK0node"))) {
[13:36:36.860]                             sendCondition <<- function(cond) {
[13:36:36.860]                               data <- list(type = "VALUE", value = cond, 
[13:36:36.860]                                 success = TRUE)
[13:36:36.860]                               parallel_sendData(master, data)
[13:36:36.860]                             }
[13:36:36.860]                             return(sendCondition)
[13:36:36.860]                           }
[13:36:36.860]                         }
[13:36:36.860]                         frame <- frame + 1L
[13:36:36.860]                         envir <- sys.frame(frame)
[13:36:36.860]                       }
[13:36:36.860]                     }
[13:36:36.860]                     sendCondition <<- function(cond) NULL
[13:36:36.860]                   }
[13:36:36.860]                 })
[13:36:36.860]                 withCallingHandlers({
[13:36:36.860]                   2
[13:36:36.860]                 }, immediateCondition = function(cond) {
[13:36:36.860]                   sendCondition <- ...future.makeSendCondition()
[13:36:36.860]                   sendCondition(cond)
[13:36:36.860]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.860]                   {
[13:36:36.860]                     inherits <- base::inherits
[13:36:36.860]                     invokeRestart <- base::invokeRestart
[13:36:36.860]                     is.null <- base::is.null
[13:36:36.860]                     muffled <- FALSE
[13:36:36.860]                     if (inherits(cond, "message")) {
[13:36:36.860]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.860]                       if (muffled) 
[13:36:36.860]                         invokeRestart("muffleMessage")
[13:36:36.860]                     }
[13:36:36.860]                     else if (inherits(cond, "warning")) {
[13:36:36.860]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.860]                       if (muffled) 
[13:36:36.860]                         invokeRestart("muffleWarning")
[13:36:36.860]                     }
[13:36:36.860]                     else if (inherits(cond, "condition")) {
[13:36:36.860]                       if (!is.null(pattern)) {
[13:36:36.860]                         computeRestarts <- base::computeRestarts
[13:36:36.860]                         grepl <- base::grepl
[13:36:36.860]                         restarts <- computeRestarts(cond)
[13:36:36.860]                         for (restart in restarts) {
[13:36:36.860]                           name <- restart$name
[13:36:36.860]                           if (is.null(name)) 
[13:36:36.860]                             next
[13:36:36.860]                           if (!grepl(pattern, name)) 
[13:36:36.860]                             next
[13:36:36.860]                           invokeRestart(restart)
[13:36:36.860]                           muffled <- TRUE
[13:36:36.860]                           break
[13:36:36.860]                         }
[13:36:36.860]                       }
[13:36:36.860]                     }
[13:36:36.860]                     invisible(muffled)
[13:36:36.860]                   }
[13:36:36.860]                   muffleCondition(cond)
[13:36:36.860]                 })
[13:36:36.860]             }))
[13:36:36.860]             future::FutureResult(value = ...future.value$value, 
[13:36:36.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.860]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.860]                     ...future.globalenv.names))
[13:36:36.860]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.860]         }, condition = base::local({
[13:36:36.860]             c <- base::c
[13:36:36.860]             inherits <- base::inherits
[13:36:36.860]             invokeRestart <- base::invokeRestart
[13:36:36.860]             length <- base::length
[13:36:36.860]             list <- base::list
[13:36:36.860]             seq.int <- base::seq.int
[13:36:36.860]             signalCondition <- base::signalCondition
[13:36:36.860]             sys.calls <- base::sys.calls
[13:36:36.860]             `[[` <- base::`[[`
[13:36:36.860]             `+` <- base::`+`
[13:36:36.860]             `<<-` <- base::`<<-`
[13:36:36.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.860]                   3L)]
[13:36:36.860]             }
[13:36:36.860]             function(cond) {
[13:36:36.860]                 is_error <- inherits(cond, "error")
[13:36:36.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.860]                   NULL)
[13:36:36.860]                 if (is_error) {
[13:36:36.860]                   sessionInformation <- function() {
[13:36:36.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.860]                       search = base::search(), system = base::Sys.info())
[13:36:36.860]                   }
[13:36:36.860]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.860]                     cond$call), session = sessionInformation(), 
[13:36:36.860]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.860]                   signalCondition(cond)
[13:36:36.860]                 }
[13:36:36.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.860]                 "immediateCondition"))) {
[13:36:36.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.860]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.860]                   if (TRUE && !signal) {
[13:36:36.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.860]                     {
[13:36:36.860]                       inherits <- base::inherits
[13:36:36.860]                       invokeRestart <- base::invokeRestart
[13:36:36.860]                       is.null <- base::is.null
[13:36:36.860]                       muffled <- FALSE
[13:36:36.860]                       if (inherits(cond, "message")) {
[13:36:36.860]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.860]                         if (muffled) 
[13:36:36.860]                           invokeRestart("muffleMessage")
[13:36:36.860]                       }
[13:36:36.860]                       else if (inherits(cond, "warning")) {
[13:36:36.860]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.860]                         if (muffled) 
[13:36:36.860]                           invokeRestart("muffleWarning")
[13:36:36.860]                       }
[13:36:36.860]                       else if (inherits(cond, "condition")) {
[13:36:36.860]                         if (!is.null(pattern)) {
[13:36:36.860]                           computeRestarts <- base::computeRestarts
[13:36:36.860]                           grepl <- base::grepl
[13:36:36.860]                           restarts <- computeRestarts(cond)
[13:36:36.860]                           for (restart in restarts) {
[13:36:36.860]                             name <- restart$name
[13:36:36.860]                             if (is.null(name)) 
[13:36:36.860]                               next
[13:36:36.860]                             if (!grepl(pattern, name)) 
[13:36:36.860]                               next
[13:36:36.860]                             invokeRestart(restart)
[13:36:36.860]                             muffled <- TRUE
[13:36:36.860]                             break
[13:36:36.860]                           }
[13:36:36.860]                         }
[13:36:36.860]                       }
[13:36:36.860]                       invisible(muffled)
[13:36:36.860]                     }
[13:36:36.860]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.860]                   }
[13:36:36.860]                 }
[13:36:36.860]                 else {
[13:36:36.860]                   if (TRUE) {
[13:36:36.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.860]                     {
[13:36:36.860]                       inherits <- base::inherits
[13:36:36.860]                       invokeRestart <- base::invokeRestart
[13:36:36.860]                       is.null <- base::is.null
[13:36:36.860]                       muffled <- FALSE
[13:36:36.860]                       if (inherits(cond, "message")) {
[13:36:36.860]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.860]                         if (muffled) 
[13:36:36.860]                           invokeRestart("muffleMessage")
[13:36:36.860]                       }
[13:36:36.860]                       else if (inherits(cond, "warning")) {
[13:36:36.860]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.860]                         if (muffled) 
[13:36:36.860]                           invokeRestart("muffleWarning")
[13:36:36.860]                       }
[13:36:36.860]                       else if (inherits(cond, "condition")) {
[13:36:36.860]                         if (!is.null(pattern)) {
[13:36:36.860]                           computeRestarts <- base::computeRestarts
[13:36:36.860]                           grepl <- base::grepl
[13:36:36.860]                           restarts <- computeRestarts(cond)
[13:36:36.860]                           for (restart in restarts) {
[13:36:36.860]                             name <- restart$name
[13:36:36.860]                             if (is.null(name)) 
[13:36:36.860]                               next
[13:36:36.860]                             if (!grepl(pattern, name)) 
[13:36:36.860]                               next
[13:36:36.860]                             invokeRestart(restart)
[13:36:36.860]                             muffled <- TRUE
[13:36:36.860]                             break
[13:36:36.860]                           }
[13:36:36.860]                         }
[13:36:36.860]                       }
[13:36:36.860]                       invisible(muffled)
[13:36:36.860]                     }
[13:36:36.860]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.860]                   }
[13:36:36.860]                 }
[13:36:36.860]             }
[13:36:36.860]         }))
[13:36:36.860]     }, error = function(ex) {
[13:36:36.860]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.860]                 ...future.rng), started = ...future.startTime, 
[13:36:36.860]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.860]             version = "1.8"), class = "FutureResult")
[13:36:36.860]     }, finally = {
[13:36:36.860]         if (!identical(...future.workdir, getwd())) 
[13:36:36.860]             setwd(...future.workdir)
[13:36:36.860]         {
[13:36:36.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.860]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.860]             }
[13:36:36.860]             base::options(...future.oldOptions)
[13:36:36.860]             if (.Platform$OS.type == "windows") {
[13:36:36.860]                 old_names <- names(...future.oldEnvVars)
[13:36:36.860]                 envs <- base::Sys.getenv()
[13:36:36.860]                 names <- names(envs)
[13:36:36.860]                 common <- intersect(names, old_names)
[13:36:36.860]                 added <- setdiff(names, old_names)
[13:36:36.860]                 removed <- setdiff(old_names, names)
[13:36:36.860]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.860]                   envs[common]]
[13:36:36.860]                 NAMES <- toupper(changed)
[13:36:36.860]                 args <- list()
[13:36:36.860]                 for (kk in seq_along(NAMES)) {
[13:36:36.860]                   name <- changed[[kk]]
[13:36:36.860]                   NAME <- NAMES[[kk]]
[13:36:36.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.860]                     next
[13:36:36.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.860]                 }
[13:36:36.860]                 NAMES <- toupper(added)
[13:36:36.860]                 for (kk in seq_along(NAMES)) {
[13:36:36.860]                   name <- added[[kk]]
[13:36:36.860]                   NAME <- NAMES[[kk]]
[13:36:36.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.860]                     next
[13:36:36.860]                   args[[name]] <- ""
[13:36:36.860]                 }
[13:36:36.860]                 NAMES <- toupper(removed)
[13:36:36.860]                 for (kk in seq_along(NAMES)) {
[13:36:36.860]                   name <- removed[[kk]]
[13:36:36.860]                   NAME <- NAMES[[kk]]
[13:36:36.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.860]                     next
[13:36:36.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.860]                 }
[13:36:36.860]                 if (length(args) > 0) 
[13:36:36.860]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.860]             }
[13:36:36.860]             else {
[13:36:36.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.860]             }
[13:36:36.860]             {
[13:36:36.860]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.860]                   0L) {
[13:36:36.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.860]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.860]                   base::options(opts)
[13:36:36.860]                 }
[13:36:36.860]                 {
[13:36:36.860]                   {
[13:36:36.860]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.860]                     NULL
[13:36:36.860]                   }
[13:36:36.860]                   options(future.plan = NULL)
[13:36:36.860]                   if (is.na(NA_character_)) 
[13:36:36.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.860]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.860]                     .init = FALSE)
[13:36:36.860]                 }
[13:36:36.860]             }
[13:36:36.860]         }
[13:36:36.860]     })
[13:36:36.860]     if (TRUE) {
[13:36:36.860]         base::sink(type = "output", split = FALSE)
[13:36:36.860]         if (TRUE) {
[13:36:36.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.860]         }
[13:36:36.860]         else {
[13:36:36.860]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.860]         }
[13:36:36.860]         base::close(...future.stdout)
[13:36:36.860]         ...future.stdout <- NULL
[13:36:36.860]     }
[13:36:36.860]     ...future.result$conditions <- ...future.conditions
[13:36:36.860]     ...future.result$finished <- base::Sys.time()
[13:36:36.860]     ...future.result
[13:36:36.860] }
[13:36:36.863] MultisessionFuture started
[13:36:36.863] - Launch lazy future ... done
[13:36:36.863] run() for ‘MultisessionFuture’ ... done
[13:36:36.863] getGlobalsAndPackages() ...
[13:36:36.863] Searching for globals...
[13:36:36.864] 
[13:36:36.864] Searching for globals ... DONE
[13:36:36.864] - globals: [0] <none>
[13:36:36.864] getGlobalsAndPackages() ... DONE
[13:36:36.864] run() for ‘Future’ ...
[13:36:36.864] - state: ‘created’
[13:36:36.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.878] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:36.879]   - Field: ‘node’
[13:36:36.879]   - Field: ‘label’
[13:36:36.879]   - Field: ‘local’
[13:36:36.879]   - Field: ‘owner’
[13:36:36.879]   - Field: ‘envir’
[13:36:36.879]   - Field: ‘workers’
[13:36:36.879]   - Field: ‘packages’
[13:36:36.879]   - Field: ‘gc’
[13:36:36.880]   - Field: ‘conditions’
[13:36:36.880]   - Field: ‘persistent’
[13:36:36.880]   - Field: ‘expr’
[13:36:36.880]   - Field: ‘uuid’
[13:36:36.880]   - Field: ‘seed’
[13:36:36.880]   - Field: ‘version’
[13:36:36.880]   - Field: ‘result’
[13:36:36.880]   - Field: ‘asynchronous’
[13:36:36.880]   - Field: ‘calls’
[13:36:36.880]   - Field: ‘globals’
[13:36:36.881]   - Field: ‘stdout’
[13:36:36.881]   - Field: ‘earlySignal’
[13:36:36.881]   - Field: ‘lazy’
[13:36:36.881]   - Field: ‘state’
[13:36:36.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:36.881] - Launch lazy future ...
[13:36:36.881] Packages needed by the future expression (n = 0): <none>
[13:36:36.882] Packages needed by future strategies (n = 0): <none>
[13:36:36.882] {
[13:36:36.882]     {
[13:36:36.882]         {
[13:36:36.882]             ...future.startTime <- base::Sys.time()
[13:36:36.882]             {
[13:36:36.882]                 {
[13:36:36.882]                   {
[13:36:36.882]                     {
[13:36:36.882]                       base::local({
[13:36:36.882]                         has_future <- base::requireNamespace("future", 
[13:36:36.882]                           quietly = TRUE)
[13:36:36.882]                         if (has_future) {
[13:36:36.882]                           ns <- base::getNamespace("future")
[13:36:36.882]                           version <- ns[[".package"]][["version"]]
[13:36:36.882]                           if (is.null(version)) 
[13:36:36.882]                             version <- utils::packageVersion("future")
[13:36:36.882]                         }
[13:36:36.882]                         else {
[13:36:36.882]                           version <- NULL
[13:36:36.882]                         }
[13:36:36.882]                         if (!has_future || version < "1.8.0") {
[13:36:36.882]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.882]                             "", base::R.version$version.string), 
[13:36:36.882]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.882]                               "release", "version")], collapse = " "), 
[13:36:36.882]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.882]                             info)
[13:36:36.882]                           info <- base::paste(info, collapse = "; ")
[13:36:36.882]                           if (!has_future) {
[13:36:36.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.882]                               info)
[13:36:36.882]                           }
[13:36:36.882]                           else {
[13:36:36.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.882]                               info, version)
[13:36:36.882]                           }
[13:36:36.882]                           base::stop(msg)
[13:36:36.882]                         }
[13:36:36.882]                       })
[13:36:36.882]                     }
[13:36:36.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.882]                     base::options(mc.cores = 1L)
[13:36:36.882]                   }
[13:36:36.882]                   ...future.strategy.old <- future::plan("list")
[13:36:36.882]                   options(future.plan = NULL)
[13:36:36.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.882]                 }
[13:36:36.882]                 ...future.workdir <- getwd()
[13:36:36.882]             }
[13:36:36.882]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.882]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.882]         }
[13:36:36.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.882]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.882]             base::names(...future.oldOptions))
[13:36:36.882]     }
[13:36:36.882]     if (FALSE) {
[13:36:36.882]     }
[13:36:36.882]     else {
[13:36:36.882]         if (TRUE) {
[13:36:36.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.882]                 open = "w")
[13:36:36.882]         }
[13:36:36.882]         else {
[13:36:36.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.882]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.882]         }
[13:36:36.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.882]             base::sink(type = "output", split = FALSE)
[13:36:36.882]             base::close(...future.stdout)
[13:36:36.882]         }, add = TRUE)
[13:36:36.882]     }
[13:36:36.882]     ...future.frame <- base::sys.nframe()
[13:36:36.882]     ...future.conditions <- base::list()
[13:36:36.882]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.882]     if (FALSE) {
[13:36:36.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.882]     }
[13:36:36.882]     ...future.result <- base::tryCatch({
[13:36:36.882]         base::withCallingHandlers({
[13:36:36.882]             ...future.value <- base::withVisible(base::local({
[13:36:36.882]                 ...future.makeSendCondition <- base::local({
[13:36:36.882]                   sendCondition <- NULL
[13:36:36.882]                   function(frame = 1L) {
[13:36:36.882]                     if (is.function(sendCondition)) 
[13:36:36.882]                       return(sendCondition)
[13:36:36.882]                     ns <- getNamespace("parallel")
[13:36:36.882]                     if (exists("sendData", mode = "function", 
[13:36:36.882]                       envir = ns)) {
[13:36:36.882]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:36.882]                         envir = ns)
[13:36:36.882]                       envir <- sys.frame(frame)
[13:36:36.882]                       master <- NULL
[13:36:36.882]                       while (!identical(envir, .GlobalEnv) && 
[13:36:36.882]                         !identical(envir, emptyenv())) {
[13:36:36.882]                         if (exists("master", mode = "list", envir = envir, 
[13:36:36.882]                           inherits = FALSE)) {
[13:36:36.882]                           master <- get("master", mode = "list", 
[13:36:36.882]                             envir = envir, inherits = FALSE)
[13:36:36.882]                           if (inherits(master, c("SOCKnode", 
[13:36:36.882]                             "SOCK0node"))) {
[13:36:36.882]                             sendCondition <<- function(cond) {
[13:36:36.882]                               data <- list(type = "VALUE", value = cond, 
[13:36:36.882]                                 success = TRUE)
[13:36:36.882]                               parallel_sendData(master, data)
[13:36:36.882]                             }
[13:36:36.882]                             return(sendCondition)
[13:36:36.882]                           }
[13:36:36.882]                         }
[13:36:36.882]                         frame <- frame + 1L
[13:36:36.882]                         envir <- sys.frame(frame)
[13:36:36.882]                       }
[13:36:36.882]                     }
[13:36:36.882]                     sendCondition <<- function(cond) NULL
[13:36:36.882]                   }
[13:36:36.882]                 })
[13:36:36.882]                 withCallingHandlers({
[13:36:36.882]                   NULL
[13:36:36.882]                 }, immediateCondition = function(cond) {
[13:36:36.882]                   sendCondition <- ...future.makeSendCondition()
[13:36:36.882]                   sendCondition(cond)
[13:36:36.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.882]                   {
[13:36:36.882]                     inherits <- base::inherits
[13:36:36.882]                     invokeRestart <- base::invokeRestart
[13:36:36.882]                     is.null <- base::is.null
[13:36:36.882]                     muffled <- FALSE
[13:36:36.882]                     if (inherits(cond, "message")) {
[13:36:36.882]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.882]                       if (muffled) 
[13:36:36.882]                         invokeRestart("muffleMessage")
[13:36:36.882]                     }
[13:36:36.882]                     else if (inherits(cond, "warning")) {
[13:36:36.882]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.882]                       if (muffled) 
[13:36:36.882]                         invokeRestart("muffleWarning")
[13:36:36.882]                     }
[13:36:36.882]                     else if (inherits(cond, "condition")) {
[13:36:36.882]                       if (!is.null(pattern)) {
[13:36:36.882]                         computeRestarts <- base::computeRestarts
[13:36:36.882]                         grepl <- base::grepl
[13:36:36.882]                         restarts <- computeRestarts(cond)
[13:36:36.882]                         for (restart in restarts) {
[13:36:36.882]                           name <- restart$name
[13:36:36.882]                           if (is.null(name)) 
[13:36:36.882]                             next
[13:36:36.882]                           if (!grepl(pattern, name)) 
[13:36:36.882]                             next
[13:36:36.882]                           invokeRestart(restart)
[13:36:36.882]                           muffled <- TRUE
[13:36:36.882]                           break
[13:36:36.882]                         }
[13:36:36.882]                       }
[13:36:36.882]                     }
[13:36:36.882]                     invisible(muffled)
[13:36:36.882]                   }
[13:36:36.882]                   muffleCondition(cond)
[13:36:36.882]                 })
[13:36:36.882]             }))
[13:36:36.882]             future::FutureResult(value = ...future.value$value, 
[13:36:36.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.882]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.882]                     ...future.globalenv.names))
[13:36:36.882]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.882]         }, condition = base::local({
[13:36:36.882]             c <- base::c
[13:36:36.882]             inherits <- base::inherits
[13:36:36.882]             invokeRestart <- base::invokeRestart
[13:36:36.882]             length <- base::length
[13:36:36.882]             list <- base::list
[13:36:36.882]             seq.int <- base::seq.int
[13:36:36.882]             signalCondition <- base::signalCondition
[13:36:36.882]             sys.calls <- base::sys.calls
[13:36:36.882]             `[[` <- base::`[[`
[13:36:36.882]             `+` <- base::`+`
[13:36:36.882]             `<<-` <- base::`<<-`
[13:36:36.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.882]                   3L)]
[13:36:36.882]             }
[13:36:36.882]             function(cond) {
[13:36:36.882]                 is_error <- inherits(cond, "error")
[13:36:36.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.882]                   NULL)
[13:36:36.882]                 if (is_error) {
[13:36:36.882]                   sessionInformation <- function() {
[13:36:36.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.882]                       search = base::search(), system = base::Sys.info())
[13:36:36.882]                   }
[13:36:36.882]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.882]                     cond$call), session = sessionInformation(), 
[13:36:36.882]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.882]                   signalCondition(cond)
[13:36:36.882]                 }
[13:36:36.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.882]                 "immediateCondition"))) {
[13:36:36.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.882]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.882]                   if (TRUE && !signal) {
[13:36:36.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.882]                     {
[13:36:36.882]                       inherits <- base::inherits
[13:36:36.882]                       invokeRestart <- base::invokeRestart
[13:36:36.882]                       is.null <- base::is.null
[13:36:36.882]                       muffled <- FALSE
[13:36:36.882]                       if (inherits(cond, "message")) {
[13:36:36.882]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.882]                         if (muffled) 
[13:36:36.882]                           invokeRestart("muffleMessage")
[13:36:36.882]                       }
[13:36:36.882]                       else if (inherits(cond, "warning")) {
[13:36:36.882]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.882]                         if (muffled) 
[13:36:36.882]                           invokeRestart("muffleWarning")
[13:36:36.882]                       }
[13:36:36.882]                       else if (inherits(cond, "condition")) {
[13:36:36.882]                         if (!is.null(pattern)) {
[13:36:36.882]                           computeRestarts <- base::computeRestarts
[13:36:36.882]                           grepl <- base::grepl
[13:36:36.882]                           restarts <- computeRestarts(cond)
[13:36:36.882]                           for (restart in restarts) {
[13:36:36.882]                             name <- restart$name
[13:36:36.882]                             if (is.null(name)) 
[13:36:36.882]                               next
[13:36:36.882]                             if (!grepl(pattern, name)) 
[13:36:36.882]                               next
[13:36:36.882]                             invokeRestart(restart)
[13:36:36.882]                             muffled <- TRUE
[13:36:36.882]                             break
[13:36:36.882]                           }
[13:36:36.882]                         }
[13:36:36.882]                       }
[13:36:36.882]                       invisible(muffled)
[13:36:36.882]                     }
[13:36:36.882]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.882]                   }
[13:36:36.882]                 }
[13:36:36.882]                 else {
[13:36:36.882]                   if (TRUE) {
[13:36:36.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.882]                     {
[13:36:36.882]                       inherits <- base::inherits
[13:36:36.882]                       invokeRestart <- base::invokeRestart
[13:36:36.882]                       is.null <- base::is.null
[13:36:36.882]                       muffled <- FALSE
[13:36:36.882]                       if (inherits(cond, "message")) {
[13:36:36.882]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.882]                         if (muffled) 
[13:36:36.882]                           invokeRestart("muffleMessage")
[13:36:36.882]                       }
[13:36:36.882]                       else if (inherits(cond, "warning")) {
[13:36:36.882]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.882]                         if (muffled) 
[13:36:36.882]                           invokeRestart("muffleWarning")
[13:36:36.882]                       }
[13:36:36.882]                       else if (inherits(cond, "condition")) {
[13:36:36.882]                         if (!is.null(pattern)) {
[13:36:36.882]                           computeRestarts <- base::computeRestarts
[13:36:36.882]                           grepl <- base::grepl
[13:36:36.882]                           restarts <- computeRestarts(cond)
[13:36:36.882]                           for (restart in restarts) {
[13:36:36.882]                             name <- restart$name
[13:36:36.882]                             if (is.null(name)) 
[13:36:36.882]                               next
[13:36:36.882]                             if (!grepl(pattern, name)) 
[13:36:36.882]                               next
[13:36:36.882]                             invokeRestart(restart)
[13:36:36.882]                             muffled <- TRUE
[13:36:36.882]                             break
[13:36:36.882]                           }
[13:36:36.882]                         }
[13:36:36.882]                       }
[13:36:36.882]                       invisible(muffled)
[13:36:36.882]                     }
[13:36:36.882]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.882]                   }
[13:36:36.882]                 }
[13:36:36.882]             }
[13:36:36.882]         }))
[13:36:36.882]     }, error = function(ex) {
[13:36:36.882]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.882]                 ...future.rng), started = ...future.startTime, 
[13:36:36.882]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.882]             version = "1.8"), class = "FutureResult")
[13:36:36.882]     }, finally = {
[13:36:36.882]         if (!identical(...future.workdir, getwd())) 
[13:36:36.882]             setwd(...future.workdir)
[13:36:36.882]         {
[13:36:36.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.882]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.882]             }
[13:36:36.882]             base::options(...future.oldOptions)
[13:36:36.882]             if (.Platform$OS.type == "windows") {
[13:36:36.882]                 old_names <- names(...future.oldEnvVars)
[13:36:36.882]                 envs <- base::Sys.getenv()
[13:36:36.882]                 names <- names(envs)
[13:36:36.882]                 common <- intersect(names, old_names)
[13:36:36.882]                 added <- setdiff(names, old_names)
[13:36:36.882]                 removed <- setdiff(old_names, names)
[13:36:36.882]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.882]                   envs[common]]
[13:36:36.882]                 NAMES <- toupper(changed)
[13:36:36.882]                 args <- list()
[13:36:36.882]                 for (kk in seq_along(NAMES)) {
[13:36:36.882]                   name <- changed[[kk]]
[13:36:36.882]                   NAME <- NAMES[[kk]]
[13:36:36.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.882]                     next
[13:36:36.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.882]                 }
[13:36:36.882]                 NAMES <- toupper(added)
[13:36:36.882]                 for (kk in seq_along(NAMES)) {
[13:36:36.882]                   name <- added[[kk]]
[13:36:36.882]                   NAME <- NAMES[[kk]]
[13:36:36.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.882]                     next
[13:36:36.882]                   args[[name]] <- ""
[13:36:36.882]                 }
[13:36:36.882]                 NAMES <- toupper(removed)
[13:36:36.882]                 for (kk in seq_along(NAMES)) {
[13:36:36.882]                   name <- removed[[kk]]
[13:36:36.882]                   NAME <- NAMES[[kk]]
[13:36:36.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.882]                     next
[13:36:36.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.882]                 }
[13:36:36.882]                 if (length(args) > 0) 
[13:36:36.882]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.882]             }
[13:36:36.882]             else {
[13:36:36.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.882]             }
[13:36:36.882]             {
[13:36:36.882]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.882]                   0L) {
[13:36:36.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.882]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.882]                   base::options(opts)
[13:36:36.882]                 }
[13:36:36.882]                 {
[13:36:36.882]                   {
[13:36:36.882]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.882]                     NULL
[13:36:36.882]                   }
[13:36:36.882]                   options(future.plan = NULL)
[13:36:36.882]                   if (is.na(NA_character_)) 
[13:36:36.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.882]                     .init = FALSE)
[13:36:36.882]                 }
[13:36:36.882]             }
[13:36:36.882]         }
[13:36:36.882]     })
[13:36:36.882]     if (TRUE) {
[13:36:36.882]         base::sink(type = "output", split = FALSE)
[13:36:36.882]         if (TRUE) {
[13:36:36.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.882]         }
[13:36:36.882]         else {
[13:36:36.882]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.882]         }
[13:36:36.882]         base::close(...future.stdout)
[13:36:36.882]         ...future.stdout <- NULL
[13:36:36.882]     }
[13:36:36.882]     ...future.result$conditions <- ...future.conditions
[13:36:36.882]     ...future.result$finished <- base::Sys.time()
[13:36:36.882]     ...future.result
[13:36:36.882] }
[13:36:36.936] MultisessionFuture started
[13:36:36.937] - Launch lazy future ... done
[13:36:36.937] run() for ‘MultisessionFuture’ ... done
[13:36:36.937] getGlobalsAndPackages() ...
[13:36:36.937] Searching for globals...
[13:36:36.938] - globals found: [1] ‘{’
[13:36:36.938] Searching for globals ... DONE
[13:36:36.938] Resolving globals: FALSE
[13:36:36.939] 
[13:36:36.939] 
[13:36:36.939] getGlobalsAndPackages() ... DONE
[13:36:36.939] run() for ‘Future’ ...
[13:36:36.939] - state: ‘created’
[13:36:36.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:36.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:36.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:36.954]   - Field: ‘node’
[13:36:36.954]   - Field: ‘label’
[13:36:36.954]   - Field: ‘local’
[13:36:36.954]   - Field: ‘owner’
[13:36:36.954]   - Field: ‘envir’
[13:36:36.954]   - Field: ‘workers’
[13:36:36.954]   - Field: ‘packages’
[13:36:36.954]   - Field: ‘gc’
[13:36:36.955]   - Field: ‘conditions’
[13:36:36.955]   - Field: ‘persistent’
[13:36:36.955]   - Field: ‘expr’
[13:36:36.955]   - Field: ‘uuid’
[13:36:36.955]   - Field: ‘seed’
[13:36:36.955]   - Field: ‘version’
[13:36:36.955]   - Field: ‘result’
[13:36:36.955]   - Field: ‘asynchronous’
[13:36:36.955]   - Field: ‘calls’
[13:36:36.955]   - Field: ‘globals’
[13:36:36.955]   - Field: ‘stdout’
[13:36:36.956]   - Field: ‘earlySignal’
[13:36:36.956]   - Field: ‘lazy’
[13:36:36.956]   - Field: ‘state’
[13:36:36.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:36.956] - Launch lazy future ...
[13:36:36.956] Packages needed by the future expression (n = 0): <none>
[13:36:36.956] Packages needed by future strategies (n = 0): <none>
[13:36:36.957] {
[13:36:36.957]     {
[13:36:36.957]         {
[13:36:36.957]             ...future.startTime <- base::Sys.time()
[13:36:36.957]             {
[13:36:36.957]                 {
[13:36:36.957]                   {
[13:36:36.957]                     {
[13:36:36.957]                       base::local({
[13:36:36.957]                         has_future <- base::requireNamespace("future", 
[13:36:36.957]                           quietly = TRUE)
[13:36:36.957]                         if (has_future) {
[13:36:36.957]                           ns <- base::getNamespace("future")
[13:36:36.957]                           version <- ns[[".package"]][["version"]]
[13:36:36.957]                           if (is.null(version)) 
[13:36:36.957]                             version <- utils::packageVersion("future")
[13:36:36.957]                         }
[13:36:36.957]                         else {
[13:36:36.957]                           version <- NULL
[13:36:36.957]                         }
[13:36:36.957]                         if (!has_future || version < "1.8.0") {
[13:36:36.957]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:36.957]                             "", base::R.version$version.string), 
[13:36:36.957]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:36.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:36.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:36.957]                               "release", "version")], collapse = " "), 
[13:36:36.957]                             hostname = base::Sys.info()[["nodename"]])
[13:36:36.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:36.957]                             info)
[13:36:36.957]                           info <- base::paste(info, collapse = "; ")
[13:36:36.957]                           if (!has_future) {
[13:36:36.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:36.957]                               info)
[13:36:36.957]                           }
[13:36:36.957]                           else {
[13:36:36.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:36.957]                               info, version)
[13:36:36.957]                           }
[13:36:36.957]                           base::stop(msg)
[13:36:36.957]                         }
[13:36:36.957]                       })
[13:36:36.957]                     }
[13:36:36.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:36.957]                     base::options(mc.cores = 1L)
[13:36:36.957]                   }
[13:36:36.957]                   ...future.strategy.old <- future::plan("list")
[13:36:36.957]                   options(future.plan = NULL)
[13:36:36.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:36.957]                 }
[13:36:36.957]                 ...future.workdir <- getwd()
[13:36:36.957]             }
[13:36:36.957]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:36.957]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:36.957]         }
[13:36:36.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:36.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:36.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:36.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:36.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:36.957]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:36.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:36.957]             base::names(...future.oldOptions))
[13:36:36.957]     }
[13:36:36.957]     if (FALSE) {
[13:36:36.957]     }
[13:36:36.957]     else {
[13:36:36.957]         if (TRUE) {
[13:36:36.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:36.957]                 open = "w")
[13:36:36.957]         }
[13:36:36.957]         else {
[13:36:36.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:36.957]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:36.957]         }
[13:36:36.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:36.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:36.957]             base::sink(type = "output", split = FALSE)
[13:36:36.957]             base::close(...future.stdout)
[13:36:36.957]         }, add = TRUE)
[13:36:36.957]     }
[13:36:36.957]     ...future.frame <- base::sys.nframe()
[13:36:36.957]     ...future.conditions <- base::list()
[13:36:36.957]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:36.957]     if (FALSE) {
[13:36:36.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:36.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:36.957]     }
[13:36:36.957]     ...future.result <- base::tryCatch({
[13:36:36.957]         base::withCallingHandlers({
[13:36:36.957]             ...future.value <- base::withVisible(base::local({
[13:36:36.957]                 ...future.makeSendCondition <- base::local({
[13:36:36.957]                   sendCondition <- NULL
[13:36:36.957]                   function(frame = 1L) {
[13:36:36.957]                     if (is.function(sendCondition)) 
[13:36:36.957]                       return(sendCondition)
[13:36:36.957]                     ns <- getNamespace("parallel")
[13:36:36.957]                     if (exists("sendData", mode = "function", 
[13:36:36.957]                       envir = ns)) {
[13:36:36.957]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:36.957]                         envir = ns)
[13:36:36.957]                       envir <- sys.frame(frame)
[13:36:36.957]                       master <- NULL
[13:36:36.957]                       while (!identical(envir, .GlobalEnv) && 
[13:36:36.957]                         !identical(envir, emptyenv())) {
[13:36:36.957]                         if (exists("master", mode = "list", envir = envir, 
[13:36:36.957]                           inherits = FALSE)) {
[13:36:36.957]                           master <- get("master", mode = "list", 
[13:36:36.957]                             envir = envir, inherits = FALSE)
[13:36:36.957]                           if (inherits(master, c("SOCKnode", 
[13:36:36.957]                             "SOCK0node"))) {
[13:36:36.957]                             sendCondition <<- function(cond) {
[13:36:36.957]                               data <- list(type = "VALUE", value = cond, 
[13:36:36.957]                                 success = TRUE)
[13:36:36.957]                               parallel_sendData(master, data)
[13:36:36.957]                             }
[13:36:36.957]                             return(sendCondition)
[13:36:36.957]                           }
[13:36:36.957]                         }
[13:36:36.957]                         frame <- frame + 1L
[13:36:36.957]                         envir <- sys.frame(frame)
[13:36:36.957]                       }
[13:36:36.957]                     }
[13:36:36.957]                     sendCondition <<- function(cond) NULL
[13:36:36.957]                   }
[13:36:36.957]                 })
[13:36:36.957]                 withCallingHandlers({
[13:36:36.957]                   {
[13:36:36.957]                     4
[13:36:36.957]                   }
[13:36:36.957]                 }, immediateCondition = function(cond) {
[13:36:36.957]                   sendCondition <- ...future.makeSendCondition()
[13:36:36.957]                   sendCondition(cond)
[13:36:36.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.957]                   {
[13:36:36.957]                     inherits <- base::inherits
[13:36:36.957]                     invokeRestart <- base::invokeRestart
[13:36:36.957]                     is.null <- base::is.null
[13:36:36.957]                     muffled <- FALSE
[13:36:36.957]                     if (inherits(cond, "message")) {
[13:36:36.957]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:36.957]                       if (muffled) 
[13:36:36.957]                         invokeRestart("muffleMessage")
[13:36:36.957]                     }
[13:36:36.957]                     else if (inherits(cond, "warning")) {
[13:36:36.957]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:36.957]                       if (muffled) 
[13:36:36.957]                         invokeRestart("muffleWarning")
[13:36:36.957]                     }
[13:36:36.957]                     else if (inherits(cond, "condition")) {
[13:36:36.957]                       if (!is.null(pattern)) {
[13:36:36.957]                         computeRestarts <- base::computeRestarts
[13:36:36.957]                         grepl <- base::grepl
[13:36:36.957]                         restarts <- computeRestarts(cond)
[13:36:36.957]                         for (restart in restarts) {
[13:36:36.957]                           name <- restart$name
[13:36:36.957]                           if (is.null(name)) 
[13:36:36.957]                             next
[13:36:36.957]                           if (!grepl(pattern, name)) 
[13:36:36.957]                             next
[13:36:36.957]                           invokeRestart(restart)
[13:36:36.957]                           muffled <- TRUE
[13:36:36.957]                           break
[13:36:36.957]                         }
[13:36:36.957]                       }
[13:36:36.957]                     }
[13:36:36.957]                     invisible(muffled)
[13:36:36.957]                   }
[13:36:36.957]                   muffleCondition(cond)
[13:36:36.957]                 })
[13:36:36.957]             }))
[13:36:36.957]             future::FutureResult(value = ...future.value$value, 
[13:36:36.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.957]                   ...future.rng), globalenv = if (FALSE) 
[13:36:36.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:36.957]                     ...future.globalenv.names))
[13:36:36.957]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:36.957]         }, condition = base::local({
[13:36:36.957]             c <- base::c
[13:36:36.957]             inherits <- base::inherits
[13:36:36.957]             invokeRestart <- base::invokeRestart
[13:36:36.957]             length <- base::length
[13:36:36.957]             list <- base::list
[13:36:36.957]             seq.int <- base::seq.int
[13:36:36.957]             signalCondition <- base::signalCondition
[13:36:36.957]             sys.calls <- base::sys.calls
[13:36:36.957]             `[[` <- base::`[[`
[13:36:36.957]             `+` <- base::`+`
[13:36:36.957]             `<<-` <- base::`<<-`
[13:36:36.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:36.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:36.957]                   3L)]
[13:36:36.957]             }
[13:36:36.957]             function(cond) {
[13:36:36.957]                 is_error <- inherits(cond, "error")
[13:36:36.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:36.957]                   NULL)
[13:36:36.957]                 if (is_error) {
[13:36:36.957]                   sessionInformation <- function() {
[13:36:36.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:36.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:36.957]                       search = base::search(), system = base::Sys.info())
[13:36:36.957]                   }
[13:36:36.957]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:36.957]                     cond$call), session = sessionInformation(), 
[13:36:36.957]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:36.957]                   signalCondition(cond)
[13:36:36.957]                 }
[13:36:36.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:36.957]                 "immediateCondition"))) {
[13:36:36.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:36.957]                   ...future.conditions[[length(...future.conditions) + 
[13:36:36.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:36.957]                   if (TRUE && !signal) {
[13:36:36.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.957]                     {
[13:36:36.957]                       inherits <- base::inherits
[13:36:36.957]                       invokeRestart <- base::invokeRestart
[13:36:36.957]                       is.null <- base::is.null
[13:36:36.957]                       muffled <- FALSE
[13:36:36.957]                       if (inherits(cond, "message")) {
[13:36:36.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.957]                         if (muffled) 
[13:36:36.957]                           invokeRestart("muffleMessage")
[13:36:36.957]                       }
[13:36:36.957]                       else if (inherits(cond, "warning")) {
[13:36:36.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.957]                         if (muffled) 
[13:36:36.957]                           invokeRestart("muffleWarning")
[13:36:36.957]                       }
[13:36:36.957]                       else if (inherits(cond, "condition")) {
[13:36:36.957]                         if (!is.null(pattern)) {
[13:36:36.957]                           computeRestarts <- base::computeRestarts
[13:36:36.957]                           grepl <- base::grepl
[13:36:36.957]                           restarts <- computeRestarts(cond)
[13:36:36.957]                           for (restart in restarts) {
[13:36:36.957]                             name <- restart$name
[13:36:36.957]                             if (is.null(name)) 
[13:36:36.957]                               next
[13:36:36.957]                             if (!grepl(pattern, name)) 
[13:36:36.957]                               next
[13:36:36.957]                             invokeRestart(restart)
[13:36:36.957]                             muffled <- TRUE
[13:36:36.957]                             break
[13:36:36.957]                           }
[13:36:36.957]                         }
[13:36:36.957]                       }
[13:36:36.957]                       invisible(muffled)
[13:36:36.957]                     }
[13:36:36.957]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.957]                   }
[13:36:36.957]                 }
[13:36:36.957]                 else {
[13:36:36.957]                   if (TRUE) {
[13:36:36.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:36.957]                     {
[13:36:36.957]                       inherits <- base::inherits
[13:36:36.957]                       invokeRestart <- base::invokeRestart
[13:36:36.957]                       is.null <- base::is.null
[13:36:36.957]                       muffled <- FALSE
[13:36:36.957]                       if (inherits(cond, "message")) {
[13:36:36.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:36.957]                         if (muffled) 
[13:36:36.957]                           invokeRestart("muffleMessage")
[13:36:36.957]                       }
[13:36:36.957]                       else if (inherits(cond, "warning")) {
[13:36:36.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:36.957]                         if (muffled) 
[13:36:36.957]                           invokeRestart("muffleWarning")
[13:36:36.957]                       }
[13:36:36.957]                       else if (inherits(cond, "condition")) {
[13:36:36.957]                         if (!is.null(pattern)) {
[13:36:36.957]                           computeRestarts <- base::computeRestarts
[13:36:36.957]                           grepl <- base::grepl
[13:36:36.957]                           restarts <- computeRestarts(cond)
[13:36:36.957]                           for (restart in restarts) {
[13:36:36.957]                             name <- restart$name
[13:36:36.957]                             if (is.null(name)) 
[13:36:36.957]                               next
[13:36:36.957]                             if (!grepl(pattern, name)) 
[13:36:36.957]                               next
[13:36:36.957]                             invokeRestart(restart)
[13:36:36.957]                             muffled <- TRUE
[13:36:36.957]                             break
[13:36:36.957]                           }
[13:36:36.957]                         }
[13:36:36.957]                       }
[13:36:36.957]                       invisible(muffled)
[13:36:36.957]                     }
[13:36:36.957]                     muffleCondition(cond, pattern = "^muffle")
[13:36:36.957]                   }
[13:36:36.957]                 }
[13:36:36.957]             }
[13:36:36.957]         }))
[13:36:36.957]     }, error = function(ex) {
[13:36:36.957]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:36.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:36.957]                 ...future.rng), started = ...future.startTime, 
[13:36:36.957]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:36.957]             version = "1.8"), class = "FutureResult")
[13:36:36.957]     }, finally = {
[13:36:36.957]         if (!identical(...future.workdir, getwd())) 
[13:36:36.957]             setwd(...future.workdir)
[13:36:36.957]         {
[13:36:36.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:36.957]                 ...future.oldOptions$nwarnings <- NULL
[13:36:36.957]             }
[13:36:36.957]             base::options(...future.oldOptions)
[13:36:36.957]             if (.Platform$OS.type == "windows") {
[13:36:36.957]                 old_names <- names(...future.oldEnvVars)
[13:36:36.957]                 envs <- base::Sys.getenv()
[13:36:36.957]                 names <- names(envs)
[13:36:36.957]                 common <- intersect(names, old_names)
[13:36:36.957]                 added <- setdiff(names, old_names)
[13:36:36.957]                 removed <- setdiff(old_names, names)
[13:36:36.957]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:36.957]                   envs[common]]
[13:36:36.957]                 NAMES <- toupper(changed)
[13:36:36.957]                 args <- list()
[13:36:36.957]                 for (kk in seq_along(NAMES)) {
[13:36:36.957]                   name <- changed[[kk]]
[13:36:36.957]                   NAME <- NAMES[[kk]]
[13:36:36.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.957]                     next
[13:36:36.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.957]                 }
[13:36:36.957]                 NAMES <- toupper(added)
[13:36:36.957]                 for (kk in seq_along(NAMES)) {
[13:36:36.957]                   name <- added[[kk]]
[13:36:36.957]                   NAME <- NAMES[[kk]]
[13:36:36.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.957]                     next
[13:36:36.957]                   args[[name]] <- ""
[13:36:36.957]                 }
[13:36:36.957]                 NAMES <- toupper(removed)
[13:36:36.957]                 for (kk in seq_along(NAMES)) {
[13:36:36.957]                   name <- removed[[kk]]
[13:36:36.957]                   NAME <- NAMES[[kk]]
[13:36:36.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:36.957]                     next
[13:36:36.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:36.957]                 }
[13:36:36.957]                 if (length(args) > 0) 
[13:36:36.957]                   base::do.call(base::Sys.setenv, args = args)
[13:36:36.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:36.957]             }
[13:36:36.957]             else {
[13:36:36.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:36.957]             }
[13:36:36.957]             {
[13:36:36.957]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:36.957]                   0L) {
[13:36:36.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:36.957]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:36.957]                   base::options(opts)
[13:36:36.957]                 }
[13:36:36.957]                 {
[13:36:36.957]                   {
[13:36:36.957]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:36.957]                     NULL
[13:36:36.957]                   }
[13:36:36.957]                   options(future.plan = NULL)
[13:36:36.957]                   if (is.na(NA_character_)) 
[13:36:36.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:36.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:36.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:36.957]                     .init = FALSE)
[13:36:36.957]                 }
[13:36:36.957]             }
[13:36:36.957]         }
[13:36:36.957]     })
[13:36:36.957]     if (TRUE) {
[13:36:36.957]         base::sink(type = "output", split = FALSE)
[13:36:36.957]         if (TRUE) {
[13:36:36.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:36.957]         }
[13:36:36.957]         else {
[13:36:36.957]             ...future.result["stdout"] <- base::list(NULL)
[13:36:36.957]         }
[13:36:36.957]         base::close(...future.stdout)
[13:36:36.957]         ...future.stdout <- NULL
[13:36:36.957]     }
[13:36:36.957]     ...future.result$conditions <- ...future.conditions
[13:36:36.957]     ...future.result$finished <- base::Sys.time()
[13:36:36.957]     ...future.result
[13:36:36.957] }
[13:36:36.959] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:36.970] receiveMessageFromWorker() for ClusterFuture ...
[13:36:36.970] - Validating connection of MultisessionFuture
[13:36:36.970] - received message: FutureResult
[13:36:36.970] - Received FutureResult
[13:36:36.971] - Erased future from FutureRegistry
[13:36:36.971] result() for ClusterFuture ...
[13:36:36.971] - result already collected: FutureResult
[13:36:36.971] result() for ClusterFuture ... done
[13:36:36.971] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:36.971] result() for ClusterFuture ...
[13:36:36.971] - result already collected: FutureResult
[13:36:36.971] result() for ClusterFuture ... done
[13:36:36.971] result() for ClusterFuture ...
[13:36:36.971] - result already collected: FutureResult
[13:36:36.972] result() for ClusterFuture ... done
[13:36:36.973] MultisessionFuture started
[13:36:36.973] - Launch lazy future ... done
[13:36:36.973] run() for ‘MultisessionFuture’ ... done
<environment: 0x564a73379e58> 
<environment: 0x564a74293bf8> 
[13:36:36.975] receiveMessageFromWorker() for ClusterFuture ...
[13:36:36.975] - Validating connection of MultisessionFuture
[13:36:36.975] - received message: FutureResult
[13:36:36.975] - Received FutureResult
[13:36:36.975] - Erased future from FutureRegistry
[13:36:36.975] result() for ClusterFuture ...
[13:36:36.975] - result already collected: FutureResult
[13:36:36.975] result() for ClusterFuture ... done
[13:36:36.975] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:36.976] receiveMessageFromWorker() for ClusterFuture ...
[13:36:36.976] - Validating connection of MultisessionFuture
[13:36:36.976] - received message: FutureResult
[13:36:36.976] - Received FutureResult
[13:36:36.976] - Erased future from FutureRegistry
[13:36:36.976] result() for ClusterFuture ...
[13:36:36.977] - result already collected: FutureResult
[13:36:36.977] result() for ClusterFuture ... done
[13:36:36.977] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:36.978] resolve() on environment ...
[13:36:36.978]  recursive: 0
[13:36:36.979]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:36.979] signalConditionsASAP(numeric, pos=1) ...
[13:36:36.979] - nx: 4
[13:36:36.979] - relay: TRUE
[13:36:36.979] - stdout: TRUE
[13:36:36.979] - signal: TRUE
[13:36:36.979] - resignal: FALSE
[13:36:36.979] - force: TRUE
[13:36:36.979] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.979] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.979]  - until=2
[13:36:36.980]  - relaying element #2
[13:36:36.980] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.980] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.980] signalConditionsASAP(NULL, pos=1) ... done
[13:36:36.980]  length: 3 (resolved future 1)
[13:36:36.980] Future #2
[13:36:36.980] result() for ClusterFuture ...
[13:36:36.980] - result already collected: FutureResult
[13:36:36.980] result() for ClusterFuture ... done
[13:36:36.980] result() for ClusterFuture ...
[13:36:36.980] - result already collected: FutureResult
[13:36:36.981] result() for ClusterFuture ... done
[13:36:36.981] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:36.981] - nx: 4
[13:36:36.981] - relay: TRUE
[13:36:36.981] - stdout: TRUE
[13:36:36.981] - signal: TRUE
[13:36:36.981] - resignal: FALSE
[13:36:36.981] - force: TRUE
[13:36:36.981] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:36.981] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:36.981]  - until=2
[13:36:36.982]  - relaying element #2
[13:36:36.982] result() for ClusterFuture ...
[13:36:36.982] - result already collected: FutureResult
[13:36:36.982] result() for ClusterFuture ... done
[13:36:36.982] result() for ClusterFuture ...
[13:36:36.982] - result already collected: FutureResult
[13:36:36.982] result() for ClusterFuture ... done
[13:36:36.982] result() for ClusterFuture ...
[13:36:36.982] - result already collected: FutureResult
[13:36:36.982] result() for ClusterFuture ... done
[13:36:36.982] result() for ClusterFuture ...
[13:36:36.983] - result already collected: FutureResult
[13:36:36.983] result() for ClusterFuture ... done
[13:36:36.983] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.983] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.983] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:36.983]  length: 2 (resolved future 2)
[13:36:36.983] Future #3
[13:36:36.983] result() for ClusterFuture ...
[13:36:36.983] - result already collected: FutureResult
[13:36:36.983] result() for ClusterFuture ... done
[13:36:36.984] result() for ClusterFuture ...
[13:36:36.984] - result already collected: FutureResult
[13:36:36.984] result() for ClusterFuture ... done
[13:36:36.984] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:36.984] - nx: 4
[13:36:36.984] - relay: TRUE
[13:36:36.984] - stdout: TRUE
[13:36:36.984] - signal: TRUE
[13:36:36.984] - resignal: FALSE
[13:36:36.984] - force: TRUE
[13:36:36.984] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:36.984] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:36.985]  - until=3
[13:36:36.985]  - relaying element #3
[13:36:36.985] result() for ClusterFuture ...
[13:36:36.985] - result already collected: FutureResult
[13:36:36.985] result() for ClusterFuture ... done
[13:36:36.985] result() for ClusterFuture ...
[13:36:36.985] - result already collected: FutureResult
[13:36:36.985] result() for ClusterFuture ... done
[13:36:36.985] result() for ClusterFuture ...
[13:36:36.985] - result already collected: FutureResult
[13:36:36.985] result() for ClusterFuture ... done
[13:36:36.986] result() for ClusterFuture ...
[13:36:36.986] - result already collected: FutureResult
[13:36:36.986] result() for ClusterFuture ... done
[13:36:36.986] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.986] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.986] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:36.986]  length: 1 (resolved future 3)
[13:36:36.986] Future #4
[13:36:36.986] result() for ClusterFuture ...
[13:36:36.986] - result already collected: FutureResult
[13:36:36.987] result() for ClusterFuture ... done
[13:36:36.987] result() for ClusterFuture ...
[13:36:36.987] - result already collected: FutureResult
[13:36:36.987] result() for ClusterFuture ... done
[13:36:36.987] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:36.987] - nx: 4
[13:36:36.987] - relay: TRUE
[13:36:36.987] - stdout: TRUE
[13:36:36.987] - signal: TRUE
[13:36:36.987] - resignal: FALSE
[13:36:36.987] - force: TRUE
[13:36:36.987] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:36.988] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:36.988]  - until=4
[13:36:36.988]  - relaying element #4
[13:36:36.988] result() for ClusterFuture ...
[13:36:36.988] - result already collected: FutureResult
[13:36:36.988] result() for ClusterFuture ... done
[13:36:36.988] result() for ClusterFuture ...
[13:36:36.988] - result already collected: FutureResult
[13:36:36.988] result() for ClusterFuture ... done
[13:36:36.988] result() for ClusterFuture ...
[13:36:36.988] - result already collected: FutureResult
[13:36:36.989] result() for ClusterFuture ... done
[13:36:36.989] result() for ClusterFuture ...
[13:36:36.989] - result already collected: FutureResult
[13:36:36.989] result() for ClusterFuture ... done
[13:36:36.989] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.989] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.989] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:36.989]  length: 0 (resolved future 4)
[13:36:36.989] Relaying remaining futures
[13:36:36.989] signalConditionsASAP(NULL, pos=0) ...
[13:36:36.989] - nx: 4
[13:36:36.990] - relay: TRUE
[13:36:36.990] - stdout: TRUE
[13:36:36.990] - signal: TRUE
[13:36:36.990] - resignal: FALSE
[13:36:36.990] - force: TRUE
[13:36:36.990] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.990] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:36.990] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:36.990] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:36.990] signalConditionsASAP(NULL, pos=0) ... done
[13:36:36.991] resolve() on environment ... DONE
[13:36:36.991] result() for ClusterFuture ...
[13:36:36.991] - result already collected: FutureResult
[13:36:36.991] result() for ClusterFuture ... done
[13:36:36.991] result() for ClusterFuture ...
[13:36:36.991] - result already collected: FutureResult
[13:36:36.991] result() for ClusterFuture ... done
[13:36:36.991] result() for ClusterFuture ...
[13:36:36.991] - result already collected: FutureResult
[13:36:36.991] result() for ClusterFuture ... done
[13:36:36.991] result() for ClusterFuture ...
[13:36:36.991] - result already collected: FutureResult
[13:36:36.992] result() for ClusterFuture ... done
[13:36:36.992] result() for ClusterFuture ...
[13:36:36.992] - result already collected: FutureResult
[13:36:36.992] result() for ClusterFuture ... done
[13:36:36.992] result() for ClusterFuture ...
[13:36:36.992] - result already collected: FutureResult
[13:36:36.992] result() for ClusterFuture ... done
<environment: 0x564a744baca8> 
Dimensions: c(1, 6)
[13:36:36.993] getGlobalsAndPackages() ...
[13:36:36.993] Searching for globals...
[13:36:36.993] 
[13:36:36.993] Searching for globals ... DONE
[13:36:36.993] - globals: [0] <none>
[13:36:36.993] getGlobalsAndPackages() ... DONE
[13:36:36.993] run() for ‘Future’ ...
[13:36:36.994] - state: ‘created’
[13:36:36.994] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.008] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.008]   - Field: ‘node’
[13:36:37.008]   - Field: ‘label’
[13:36:37.009]   - Field: ‘local’
[13:36:37.009]   - Field: ‘owner’
[13:36:37.009]   - Field: ‘envir’
[13:36:37.009]   - Field: ‘workers’
[13:36:37.009]   - Field: ‘packages’
[13:36:37.009]   - Field: ‘gc’
[13:36:37.009]   - Field: ‘conditions’
[13:36:37.009]   - Field: ‘persistent’
[13:36:37.009]   - Field: ‘expr’
[13:36:37.009]   - Field: ‘uuid’
[13:36:37.009]   - Field: ‘seed’
[13:36:37.010]   - Field: ‘version’
[13:36:37.010]   - Field: ‘result’
[13:36:37.010]   - Field: ‘asynchronous’
[13:36:37.010]   - Field: ‘calls’
[13:36:37.010]   - Field: ‘globals’
[13:36:37.010]   - Field: ‘stdout’
[13:36:37.010]   - Field: ‘earlySignal’
[13:36:37.010]   - Field: ‘lazy’
[13:36:37.010]   - Field: ‘state’
[13:36:37.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.011] - Launch lazy future ...
[13:36:37.011] Packages needed by the future expression (n = 0): <none>
[13:36:37.011] Packages needed by future strategies (n = 0): <none>
[13:36:37.011] {
[13:36:37.011]     {
[13:36:37.011]         {
[13:36:37.011]             ...future.startTime <- base::Sys.time()
[13:36:37.011]             {
[13:36:37.011]                 {
[13:36:37.011]                   {
[13:36:37.011]                     {
[13:36:37.011]                       base::local({
[13:36:37.011]                         has_future <- base::requireNamespace("future", 
[13:36:37.011]                           quietly = TRUE)
[13:36:37.011]                         if (has_future) {
[13:36:37.011]                           ns <- base::getNamespace("future")
[13:36:37.011]                           version <- ns[[".package"]][["version"]]
[13:36:37.011]                           if (is.null(version)) 
[13:36:37.011]                             version <- utils::packageVersion("future")
[13:36:37.011]                         }
[13:36:37.011]                         else {
[13:36:37.011]                           version <- NULL
[13:36:37.011]                         }
[13:36:37.011]                         if (!has_future || version < "1.8.0") {
[13:36:37.011]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.011]                             "", base::R.version$version.string), 
[13:36:37.011]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.011]                               "release", "version")], collapse = " "), 
[13:36:37.011]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.011]                             info)
[13:36:37.011]                           info <- base::paste(info, collapse = "; ")
[13:36:37.011]                           if (!has_future) {
[13:36:37.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.011]                               info)
[13:36:37.011]                           }
[13:36:37.011]                           else {
[13:36:37.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.011]                               info, version)
[13:36:37.011]                           }
[13:36:37.011]                           base::stop(msg)
[13:36:37.011]                         }
[13:36:37.011]                       })
[13:36:37.011]                     }
[13:36:37.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.011]                     base::options(mc.cores = 1L)
[13:36:37.011]                   }
[13:36:37.011]                   ...future.strategy.old <- future::plan("list")
[13:36:37.011]                   options(future.plan = NULL)
[13:36:37.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.011]                 }
[13:36:37.011]                 ...future.workdir <- getwd()
[13:36:37.011]             }
[13:36:37.011]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.011]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.011]         }
[13:36:37.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.011]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.011]             base::names(...future.oldOptions))
[13:36:37.011]     }
[13:36:37.011]     if (FALSE) {
[13:36:37.011]     }
[13:36:37.011]     else {
[13:36:37.011]         if (TRUE) {
[13:36:37.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.011]                 open = "w")
[13:36:37.011]         }
[13:36:37.011]         else {
[13:36:37.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.011]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.011]         }
[13:36:37.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.011]             base::sink(type = "output", split = FALSE)
[13:36:37.011]             base::close(...future.stdout)
[13:36:37.011]         }, add = TRUE)
[13:36:37.011]     }
[13:36:37.011]     ...future.frame <- base::sys.nframe()
[13:36:37.011]     ...future.conditions <- base::list()
[13:36:37.011]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.011]     if (FALSE) {
[13:36:37.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.011]     }
[13:36:37.011]     ...future.result <- base::tryCatch({
[13:36:37.011]         base::withCallingHandlers({
[13:36:37.011]             ...future.value <- base::withVisible(base::local({
[13:36:37.011]                 ...future.makeSendCondition <- base::local({
[13:36:37.011]                   sendCondition <- NULL
[13:36:37.011]                   function(frame = 1L) {
[13:36:37.011]                     if (is.function(sendCondition)) 
[13:36:37.011]                       return(sendCondition)
[13:36:37.011]                     ns <- getNamespace("parallel")
[13:36:37.011]                     if (exists("sendData", mode = "function", 
[13:36:37.011]                       envir = ns)) {
[13:36:37.011]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.011]                         envir = ns)
[13:36:37.011]                       envir <- sys.frame(frame)
[13:36:37.011]                       master <- NULL
[13:36:37.011]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.011]                         !identical(envir, emptyenv())) {
[13:36:37.011]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.011]                           inherits = FALSE)) {
[13:36:37.011]                           master <- get("master", mode = "list", 
[13:36:37.011]                             envir = envir, inherits = FALSE)
[13:36:37.011]                           if (inherits(master, c("SOCKnode", 
[13:36:37.011]                             "SOCK0node"))) {
[13:36:37.011]                             sendCondition <<- function(cond) {
[13:36:37.011]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.011]                                 success = TRUE)
[13:36:37.011]                               parallel_sendData(master, data)
[13:36:37.011]                             }
[13:36:37.011]                             return(sendCondition)
[13:36:37.011]                           }
[13:36:37.011]                         }
[13:36:37.011]                         frame <- frame + 1L
[13:36:37.011]                         envir <- sys.frame(frame)
[13:36:37.011]                       }
[13:36:37.011]                     }
[13:36:37.011]                     sendCondition <<- function(cond) NULL
[13:36:37.011]                   }
[13:36:37.011]                 })
[13:36:37.011]                 withCallingHandlers({
[13:36:37.011]                   2
[13:36:37.011]                 }, immediateCondition = function(cond) {
[13:36:37.011]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.011]                   sendCondition(cond)
[13:36:37.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.011]                   {
[13:36:37.011]                     inherits <- base::inherits
[13:36:37.011]                     invokeRestart <- base::invokeRestart
[13:36:37.011]                     is.null <- base::is.null
[13:36:37.011]                     muffled <- FALSE
[13:36:37.011]                     if (inherits(cond, "message")) {
[13:36:37.011]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.011]                       if (muffled) 
[13:36:37.011]                         invokeRestart("muffleMessage")
[13:36:37.011]                     }
[13:36:37.011]                     else if (inherits(cond, "warning")) {
[13:36:37.011]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.011]                       if (muffled) 
[13:36:37.011]                         invokeRestart("muffleWarning")
[13:36:37.011]                     }
[13:36:37.011]                     else if (inherits(cond, "condition")) {
[13:36:37.011]                       if (!is.null(pattern)) {
[13:36:37.011]                         computeRestarts <- base::computeRestarts
[13:36:37.011]                         grepl <- base::grepl
[13:36:37.011]                         restarts <- computeRestarts(cond)
[13:36:37.011]                         for (restart in restarts) {
[13:36:37.011]                           name <- restart$name
[13:36:37.011]                           if (is.null(name)) 
[13:36:37.011]                             next
[13:36:37.011]                           if (!grepl(pattern, name)) 
[13:36:37.011]                             next
[13:36:37.011]                           invokeRestart(restart)
[13:36:37.011]                           muffled <- TRUE
[13:36:37.011]                           break
[13:36:37.011]                         }
[13:36:37.011]                       }
[13:36:37.011]                     }
[13:36:37.011]                     invisible(muffled)
[13:36:37.011]                   }
[13:36:37.011]                   muffleCondition(cond)
[13:36:37.011]                 })
[13:36:37.011]             }))
[13:36:37.011]             future::FutureResult(value = ...future.value$value, 
[13:36:37.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.011]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.011]                     ...future.globalenv.names))
[13:36:37.011]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.011]         }, condition = base::local({
[13:36:37.011]             c <- base::c
[13:36:37.011]             inherits <- base::inherits
[13:36:37.011]             invokeRestart <- base::invokeRestart
[13:36:37.011]             length <- base::length
[13:36:37.011]             list <- base::list
[13:36:37.011]             seq.int <- base::seq.int
[13:36:37.011]             signalCondition <- base::signalCondition
[13:36:37.011]             sys.calls <- base::sys.calls
[13:36:37.011]             `[[` <- base::`[[`
[13:36:37.011]             `+` <- base::`+`
[13:36:37.011]             `<<-` <- base::`<<-`
[13:36:37.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.011]                   3L)]
[13:36:37.011]             }
[13:36:37.011]             function(cond) {
[13:36:37.011]                 is_error <- inherits(cond, "error")
[13:36:37.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.011]                   NULL)
[13:36:37.011]                 if (is_error) {
[13:36:37.011]                   sessionInformation <- function() {
[13:36:37.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.011]                       search = base::search(), system = base::Sys.info())
[13:36:37.011]                   }
[13:36:37.011]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.011]                     cond$call), session = sessionInformation(), 
[13:36:37.011]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.011]                   signalCondition(cond)
[13:36:37.011]                 }
[13:36:37.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.011]                 "immediateCondition"))) {
[13:36:37.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.011]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.011]                   if (TRUE && !signal) {
[13:36:37.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.011]                     {
[13:36:37.011]                       inherits <- base::inherits
[13:36:37.011]                       invokeRestart <- base::invokeRestart
[13:36:37.011]                       is.null <- base::is.null
[13:36:37.011]                       muffled <- FALSE
[13:36:37.011]                       if (inherits(cond, "message")) {
[13:36:37.011]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.011]                         if (muffled) 
[13:36:37.011]                           invokeRestart("muffleMessage")
[13:36:37.011]                       }
[13:36:37.011]                       else if (inherits(cond, "warning")) {
[13:36:37.011]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.011]                         if (muffled) 
[13:36:37.011]                           invokeRestart("muffleWarning")
[13:36:37.011]                       }
[13:36:37.011]                       else if (inherits(cond, "condition")) {
[13:36:37.011]                         if (!is.null(pattern)) {
[13:36:37.011]                           computeRestarts <- base::computeRestarts
[13:36:37.011]                           grepl <- base::grepl
[13:36:37.011]                           restarts <- computeRestarts(cond)
[13:36:37.011]                           for (restart in restarts) {
[13:36:37.011]                             name <- restart$name
[13:36:37.011]                             if (is.null(name)) 
[13:36:37.011]                               next
[13:36:37.011]                             if (!grepl(pattern, name)) 
[13:36:37.011]                               next
[13:36:37.011]                             invokeRestart(restart)
[13:36:37.011]                             muffled <- TRUE
[13:36:37.011]                             break
[13:36:37.011]                           }
[13:36:37.011]                         }
[13:36:37.011]                       }
[13:36:37.011]                       invisible(muffled)
[13:36:37.011]                     }
[13:36:37.011]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.011]                   }
[13:36:37.011]                 }
[13:36:37.011]                 else {
[13:36:37.011]                   if (TRUE) {
[13:36:37.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.011]                     {
[13:36:37.011]                       inherits <- base::inherits
[13:36:37.011]                       invokeRestart <- base::invokeRestart
[13:36:37.011]                       is.null <- base::is.null
[13:36:37.011]                       muffled <- FALSE
[13:36:37.011]                       if (inherits(cond, "message")) {
[13:36:37.011]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.011]                         if (muffled) 
[13:36:37.011]                           invokeRestart("muffleMessage")
[13:36:37.011]                       }
[13:36:37.011]                       else if (inherits(cond, "warning")) {
[13:36:37.011]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.011]                         if (muffled) 
[13:36:37.011]                           invokeRestart("muffleWarning")
[13:36:37.011]                       }
[13:36:37.011]                       else if (inherits(cond, "condition")) {
[13:36:37.011]                         if (!is.null(pattern)) {
[13:36:37.011]                           computeRestarts <- base::computeRestarts
[13:36:37.011]                           grepl <- base::grepl
[13:36:37.011]                           restarts <- computeRestarts(cond)
[13:36:37.011]                           for (restart in restarts) {
[13:36:37.011]                             name <- restart$name
[13:36:37.011]                             if (is.null(name)) 
[13:36:37.011]                               next
[13:36:37.011]                             if (!grepl(pattern, name)) 
[13:36:37.011]                               next
[13:36:37.011]                             invokeRestart(restart)
[13:36:37.011]                             muffled <- TRUE
[13:36:37.011]                             break
[13:36:37.011]                           }
[13:36:37.011]                         }
[13:36:37.011]                       }
[13:36:37.011]                       invisible(muffled)
[13:36:37.011]                     }
[13:36:37.011]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.011]                   }
[13:36:37.011]                 }
[13:36:37.011]             }
[13:36:37.011]         }))
[13:36:37.011]     }, error = function(ex) {
[13:36:37.011]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.011]                 ...future.rng), started = ...future.startTime, 
[13:36:37.011]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.011]             version = "1.8"), class = "FutureResult")
[13:36:37.011]     }, finally = {
[13:36:37.011]         if (!identical(...future.workdir, getwd())) 
[13:36:37.011]             setwd(...future.workdir)
[13:36:37.011]         {
[13:36:37.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.011]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.011]             }
[13:36:37.011]             base::options(...future.oldOptions)
[13:36:37.011]             if (.Platform$OS.type == "windows") {
[13:36:37.011]                 old_names <- names(...future.oldEnvVars)
[13:36:37.011]                 envs <- base::Sys.getenv()
[13:36:37.011]                 names <- names(envs)
[13:36:37.011]                 common <- intersect(names, old_names)
[13:36:37.011]                 added <- setdiff(names, old_names)
[13:36:37.011]                 removed <- setdiff(old_names, names)
[13:36:37.011]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.011]                   envs[common]]
[13:36:37.011]                 NAMES <- toupper(changed)
[13:36:37.011]                 args <- list()
[13:36:37.011]                 for (kk in seq_along(NAMES)) {
[13:36:37.011]                   name <- changed[[kk]]
[13:36:37.011]                   NAME <- NAMES[[kk]]
[13:36:37.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.011]                     next
[13:36:37.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.011]                 }
[13:36:37.011]                 NAMES <- toupper(added)
[13:36:37.011]                 for (kk in seq_along(NAMES)) {
[13:36:37.011]                   name <- added[[kk]]
[13:36:37.011]                   NAME <- NAMES[[kk]]
[13:36:37.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.011]                     next
[13:36:37.011]                   args[[name]] <- ""
[13:36:37.011]                 }
[13:36:37.011]                 NAMES <- toupper(removed)
[13:36:37.011]                 for (kk in seq_along(NAMES)) {
[13:36:37.011]                   name <- removed[[kk]]
[13:36:37.011]                   NAME <- NAMES[[kk]]
[13:36:37.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.011]                     next
[13:36:37.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.011]                 }
[13:36:37.011]                 if (length(args) > 0) 
[13:36:37.011]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.011]             }
[13:36:37.011]             else {
[13:36:37.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.011]             }
[13:36:37.011]             {
[13:36:37.011]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.011]                   0L) {
[13:36:37.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.011]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.011]                   base::options(opts)
[13:36:37.011]                 }
[13:36:37.011]                 {
[13:36:37.011]                   {
[13:36:37.011]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.011]                     NULL
[13:36:37.011]                   }
[13:36:37.011]                   options(future.plan = NULL)
[13:36:37.011]                   if (is.na(NA_character_)) 
[13:36:37.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.011]                     .init = FALSE)
[13:36:37.011]                 }
[13:36:37.011]             }
[13:36:37.011]         }
[13:36:37.011]     })
[13:36:37.011]     if (TRUE) {
[13:36:37.011]         base::sink(type = "output", split = FALSE)
[13:36:37.011]         if (TRUE) {
[13:36:37.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.011]         }
[13:36:37.011]         else {
[13:36:37.011]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.011]         }
[13:36:37.011]         base::close(...future.stdout)
[13:36:37.011]         ...future.stdout <- NULL
[13:36:37.011]     }
[13:36:37.011]     ...future.result$conditions <- ...future.conditions
[13:36:37.011]     ...future.result$finished <- base::Sys.time()
[13:36:37.011]     ...future.result
[13:36:37.011] }
[13:36:37.014] MultisessionFuture started
[13:36:37.014] - Launch lazy future ... done
[13:36:37.015] run() for ‘MultisessionFuture’ ... done
[13:36:37.015] getGlobalsAndPackages() ...
[13:36:37.015] Searching for globals...
[13:36:37.015] 
[13:36:37.015] Searching for globals ... DONE
[13:36:37.015] - globals: [0] <none>
[13:36:37.015] getGlobalsAndPackages() ... DONE
[13:36:37.016] run() for ‘Future’ ...
[13:36:37.016] - state: ‘created’
[13:36:37.016] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.034] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.034]   - Field: ‘node’
[13:36:37.034]   - Field: ‘label’
[13:36:37.035]   - Field: ‘local’
[13:36:37.035]   - Field: ‘owner’
[13:36:37.035]   - Field: ‘envir’
[13:36:37.035]   - Field: ‘workers’
[13:36:37.035]   - Field: ‘packages’
[13:36:37.035]   - Field: ‘gc’
[13:36:37.035]   - Field: ‘conditions’
[13:36:37.035]   - Field: ‘persistent’
[13:36:37.035]   - Field: ‘expr’
[13:36:37.036]   - Field: ‘uuid’
[13:36:37.036]   - Field: ‘seed’
[13:36:37.036]   - Field: ‘version’
[13:36:37.036]   - Field: ‘result’
[13:36:37.036]   - Field: ‘asynchronous’
[13:36:37.036]   - Field: ‘calls’
[13:36:37.036]   - Field: ‘globals’
[13:36:37.036]   - Field: ‘stdout’
[13:36:37.036]   - Field: ‘earlySignal’
[13:36:37.036]   - Field: ‘lazy’
[13:36:37.036]   - Field: ‘state’
[13:36:37.037] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.037] - Launch lazy future ...
[13:36:37.037] Packages needed by the future expression (n = 0): <none>
[13:36:37.037] Packages needed by future strategies (n = 0): <none>
[13:36:37.037] {
[13:36:37.037]     {
[13:36:37.037]         {
[13:36:37.037]             ...future.startTime <- base::Sys.time()
[13:36:37.037]             {
[13:36:37.037]                 {
[13:36:37.037]                   {
[13:36:37.037]                     {
[13:36:37.037]                       base::local({
[13:36:37.037]                         has_future <- base::requireNamespace("future", 
[13:36:37.037]                           quietly = TRUE)
[13:36:37.037]                         if (has_future) {
[13:36:37.037]                           ns <- base::getNamespace("future")
[13:36:37.037]                           version <- ns[[".package"]][["version"]]
[13:36:37.037]                           if (is.null(version)) 
[13:36:37.037]                             version <- utils::packageVersion("future")
[13:36:37.037]                         }
[13:36:37.037]                         else {
[13:36:37.037]                           version <- NULL
[13:36:37.037]                         }
[13:36:37.037]                         if (!has_future || version < "1.8.0") {
[13:36:37.037]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.037]                             "", base::R.version$version.string), 
[13:36:37.037]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.037]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.037]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.037]                               "release", "version")], collapse = " "), 
[13:36:37.037]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.037]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.037]                             info)
[13:36:37.037]                           info <- base::paste(info, collapse = "; ")
[13:36:37.037]                           if (!has_future) {
[13:36:37.037]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.037]                               info)
[13:36:37.037]                           }
[13:36:37.037]                           else {
[13:36:37.037]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.037]                               info, version)
[13:36:37.037]                           }
[13:36:37.037]                           base::stop(msg)
[13:36:37.037]                         }
[13:36:37.037]                       })
[13:36:37.037]                     }
[13:36:37.037]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.037]                     base::options(mc.cores = 1L)
[13:36:37.037]                   }
[13:36:37.037]                   ...future.strategy.old <- future::plan("list")
[13:36:37.037]                   options(future.plan = NULL)
[13:36:37.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.037]                 }
[13:36:37.037]                 ...future.workdir <- getwd()
[13:36:37.037]             }
[13:36:37.037]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.037]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.037]         }
[13:36:37.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.037]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.037]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.037]             base::names(...future.oldOptions))
[13:36:37.037]     }
[13:36:37.037]     if (FALSE) {
[13:36:37.037]     }
[13:36:37.037]     else {
[13:36:37.037]         if (TRUE) {
[13:36:37.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.037]                 open = "w")
[13:36:37.037]         }
[13:36:37.037]         else {
[13:36:37.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.037]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.037]         }
[13:36:37.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.037]             base::sink(type = "output", split = FALSE)
[13:36:37.037]             base::close(...future.stdout)
[13:36:37.037]         }, add = TRUE)
[13:36:37.037]     }
[13:36:37.037]     ...future.frame <- base::sys.nframe()
[13:36:37.037]     ...future.conditions <- base::list()
[13:36:37.037]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.037]     if (FALSE) {
[13:36:37.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.037]     }
[13:36:37.037]     ...future.result <- base::tryCatch({
[13:36:37.037]         base::withCallingHandlers({
[13:36:37.037]             ...future.value <- base::withVisible(base::local({
[13:36:37.037]                 ...future.makeSendCondition <- base::local({
[13:36:37.037]                   sendCondition <- NULL
[13:36:37.037]                   function(frame = 1L) {
[13:36:37.037]                     if (is.function(sendCondition)) 
[13:36:37.037]                       return(sendCondition)
[13:36:37.037]                     ns <- getNamespace("parallel")
[13:36:37.037]                     if (exists("sendData", mode = "function", 
[13:36:37.037]                       envir = ns)) {
[13:36:37.037]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.037]                         envir = ns)
[13:36:37.037]                       envir <- sys.frame(frame)
[13:36:37.037]                       master <- NULL
[13:36:37.037]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.037]                         !identical(envir, emptyenv())) {
[13:36:37.037]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.037]                           inherits = FALSE)) {
[13:36:37.037]                           master <- get("master", mode = "list", 
[13:36:37.037]                             envir = envir, inherits = FALSE)
[13:36:37.037]                           if (inherits(master, c("SOCKnode", 
[13:36:37.037]                             "SOCK0node"))) {
[13:36:37.037]                             sendCondition <<- function(cond) {
[13:36:37.037]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.037]                                 success = TRUE)
[13:36:37.037]                               parallel_sendData(master, data)
[13:36:37.037]                             }
[13:36:37.037]                             return(sendCondition)
[13:36:37.037]                           }
[13:36:37.037]                         }
[13:36:37.037]                         frame <- frame + 1L
[13:36:37.037]                         envir <- sys.frame(frame)
[13:36:37.037]                       }
[13:36:37.037]                     }
[13:36:37.037]                     sendCondition <<- function(cond) NULL
[13:36:37.037]                   }
[13:36:37.037]                 })
[13:36:37.037]                 withCallingHandlers({
[13:36:37.037]                   NULL
[13:36:37.037]                 }, immediateCondition = function(cond) {
[13:36:37.037]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.037]                   sendCondition(cond)
[13:36:37.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.037]                   {
[13:36:37.037]                     inherits <- base::inherits
[13:36:37.037]                     invokeRestart <- base::invokeRestart
[13:36:37.037]                     is.null <- base::is.null
[13:36:37.037]                     muffled <- FALSE
[13:36:37.037]                     if (inherits(cond, "message")) {
[13:36:37.037]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.037]                       if (muffled) 
[13:36:37.037]                         invokeRestart("muffleMessage")
[13:36:37.037]                     }
[13:36:37.037]                     else if (inherits(cond, "warning")) {
[13:36:37.037]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.037]                       if (muffled) 
[13:36:37.037]                         invokeRestart("muffleWarning")
[13:36:37.037]                     }
[13:36:37.037]                     else if (inherits(cond, "condition")) {
[13:36:37.037]                       if (!is.null(pattern)) {
[13:36:37.037]                         computeRestarts <- base::computeRestarts
[13:36:37.037]                         grepl <- base::grepl
[13:36:37.037]                         restarts <- computeRestarts(cond)
[13:36:37.037]                         for (restart in restarts) {
[13:36:37.037]                           name <- restart$name
[13:36:37.037]                           if (is.null(name)) 
[13:36:37.037]                             next
[13:36:37.037]                           if (!grepl(pattern, name)) 
[13:36:37.037]                             next
[13:36:37.037]                           invokeRestart(restart)
[13:36:37.037]                           muffled <- TRUE
[13:36:37.037]                           break
[13:36:37.037]                         }
[13:36:37.037]                       }
[13:36:37.037]                     }
[13:36:37.037]                     invisible(muffled)
[13:36:37.037]                   }
[13:36:37.037]                   muffleCondition(cond)
[13:36:37.037]                 })
[13:36:37.037]             }))
[13:36:37.037]             future::FutureResult(value = ...future.value$value, 
[13:36:37.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.037]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.037]                     ...future.globalenv.names))
[13:36:37.037]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.037]         }, condition = base::local({
[13:36:37.037]             c <- base::c
[13:36:37.037]             inherits <- base::inherits
[13:36:37.037]             invokeRestart <- base::invokeRestart
[13:36:37.037]             length <- base::length
[13:36:37.037]             list <- base::list
[13:36:37.037]             seq.int <- base::seq.int
[13:36:37.037]             signalCondition <- base::signalCondition
[13:36:37.037]             sys.calls <- base::sys.calls
[13:36:37.037]             `[[` <- base::`[[`
[13:36:37.037]             `+` <- base::`+`
[13:36:37.037]             `<<-` <- base::`<<-`
[13:36:37.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.037]                   3L)]
[13:36:37.037]             }
[13:36:37.037]             function(cond) {
[13:36:37.037]                 is_error <- inherits(cond, "error")
[13:36:37.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.037]                   NULL)
[13:36:37.037]                 if (is_error) {
[13:36:37.037]                   sessionInformation <- function() {
[13:36:37.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.037]                       search = base::search(), system = base::Sys.info())
[13:36:37.037]                   }
[13:36:37.037]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.037]                     cond$call), session = sessionInformation(), 
[13:36:37.037]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.037]                   signalCondition(cond)
[13:36:37.037]                 }
[13:36:37.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.037]                 "immediateCondition"))) {
[13:36:37.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.037]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.037]                   if (TRUE && !signal) {
[13:36:37.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.037]                     {
[13:36:37.037]                       inherits <- base::inherits
[13:36:37.037]                       invokeRestart <- base::invokeRestart
[13:36:37.037]                       is.null <- base::is.null
[13:36:37.037]                       muffled <- FALSE
[13:36:37.037]                       if (inherits(cond, "message")) {
[13:36:37.037]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.037]                         if (muffled) 
[13:36:37.037]                           invokeRestart("muffleMessage")
[13:36:37.037]                       }
[13:36:37.037]                       else if (inherits(cond, "warning")) {
[13:36:37.037]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.037]                         if (muffled) 
[13:36:37.037]                           invokeRestart("muffleWarning")
[13:36:37.037]                       }
[13:36:37.037]                       else if (inherits(cond, "condition")) {
[13:36:37.037]                         if (!is.null(pattern)) {
[13:36:37.037]                           computeRestarts <- base::computeRestarts
[13:36:37.037]                           grepl <- base::grepl
[13:36:37.037]                           restarts <- computeRestarts(cond)
[13:36:37.037]                           for (restart in restarts) {
[13:36:37.037]                             name <- restart$name
[13:36:37.037]                             if (is.null(name)) 
[13:36:37.037]                               next
[13:36:37.037]                             if (!grepl(pattern, name)) 
[13:36:37.037]                               next
[13:36:37.037]                             invokeRestart(restart)
[13:36:37.037]                             muffled <- TRUE
[13:36:37.037]                             break
[13:36:37.037]                           }
[13:36:37.037]                         }
[13:36:37.037]                       }
[13:36:37.037]                       invisible(muffled)
[13:36:37.037]                     }
[13:36:37.037]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.037]                   }
[13:36:37.037]                 }
[13:36:37.037]                 else {
[13:36:37.037]                   if (TRUE) {
[13:36:37.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.037]                     {
[13:36:37.037]                       inherits <- base::inherits
[13:36:37.037]                       invokeRestart <- base::invokeRestart
[13:36:37.037]                       is.null <- base::is.null
[13:36:37.037]                       muffled <- FALSE
[13:36:37.037]                       if (inherits(cond, "message")) {
[13:36:37.037]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.037]                         if (muffled) 
[13:36:37.037]                           invokeRestart("muffleMessage")
[13:36:37.037]                       }
[13:36:37.037]                       else if (inherits(cond, "warning")) {
[13:36:37.037]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.037]                         if (muffled) 
[13:36:37.037]                           invokeRestart("muffleWarning")
[13:36:37.037]                       }
[13:36:37.037]                       else if (inherits(cond, "condition")) {
[13:36:37.037]                         if (!is.null(pattern)) {
[13:36:37.037]                           computeRestarts <- base::computeRestarts
[13:36:37.037]                           grepl <- base::grepl
[13:36:37.037]                           restarts <- computeRestarts(cond)
[13:36:37.037]                           for (restart in restarts) {
[13:36:37.037]                             name <- restart$name
[13:36:37.037]                             if (is.null(name)) 
[13:36:37.037]                               next
[13:36:37.037]                             if (!grepl(pattern, name)) 
[13:36:37.037]                               next
[13:36:37.037]                             invokeRestart(restart)
[13:36:37.037]                             muffled <- TRUE
[13:36:37.037]                             break
[13:36:37.037]                           }
[13:36:37.037]                         }
[13:36:37.037]                       }
[13:36:37.037]                       invisible(muffled)
[13:36:37.037]                     }
[13:36:37.037]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.037]                   }
[13:36:37.037]                 }
[13:36:37.037]             }
[13:36:37.037]         }))
[13:36:37.037]     }, error = function(ex) {
[13:36:37.037]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.037]                 ...future.rng), started = ...future.startTime, 
[13:36:37.037]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.037]             version = "1.8"), class = "FutureResult")
[13:36:37.037]     }, finally = {
[13:36:37.037]         if (!identical(...future.workdir, getwd())) 
[13:36:37.037]             setwd(...future.workdir)
[13:36:37.037]         {
[13:36:37.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.037]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.037]             }
[13:36:37.037]             base::options(...future.oldOptions)
[13:36:37.037]             if (.Platform$OS.type == "windows") {
[13:36:37.037]                 old_names <- names(...future.oldEnvVars)
[13:36:37.037]                 envs <- base::Sys.getenv()
[13:36:37.037]                 names <- names(envs)
[13:36:37.037]                 common <- intersect(names, old_names)
[13:36:37.037]                 added <- setdiff(names, old_names)
[13:36:37.037]                 removed <- setdiff(old_names, names)
[13:36:37.037]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.037]                   envs[common]]
[13:36:37.037]                 NAMES <- toupper(changed)
[13:36:37.037]                 args <- list()
[13:36:37.037]                 for (kk in seq_along(NAMES)) {
[13:36:37.037]                   name <- changed[[kk]]
[13:36:37.037]                   NAME <- NAMES[[kk]]
[13:36:37.037]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.037]                     next
[13:36:37.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.037]                 }
[13:36:37.037]                 NAMES <- toupper(added)
[13:36:37.037]                 for (kk in seq_along(NAMES)) {
[13:36:37.037]                   name <- added[[kk]]
[13:36:37.037]                   NAME <- NAMES[[kk]]
[13:36:37.037]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.037]                     next
[13:36:37.037]                   args[[name]] <- ""
[13:36:37.037]                 }
[13:36:37.037]                 NAMES <- toupper(removed)
[13:36:37.037]                 for (kk in seq_along(NAMES)) {
[13:36:37.037]                   name <- removed[[kk]]
[13:36:37.037]                   NAME <- NAMES[[kk]]
[13:36:37.037]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.037]                     next
[13:36:37.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.037]                 }
[13:36:37.037]                 if (length(args) > 0) 
[13:36:37.037]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.037]             }
[13:36:37.037]             else {
[13:36:37.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.037]             }
[13:36:37.037]             {
[13:36:37.037]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.037]                   0L) {
[13:36:37.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.037]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.037]                   base::options(opts)
[13:36:37.037]                 }
[13:36:37.037]                 {
[13:36:37.037]                   {
[13:36:37.037]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.037]                     NULL
[13:36:37.037]                   }
[13:36:37.037]                   options(future.plan = NULL)
[13:36:37.037]                   if (is.na(NA_character_)) 
[13:36:37.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.037]                     .init = FALSE)
[13:36:37.037]                 }
[13:36:37.037]             }
[13:36:37.037]         }
[13:36:37.037]     })
[13:36:37.037]     if (TRUE) {
[13:36:37.037]         base::sink(type = "output", split = FALSE)
[13:36:37.037]         if (TRUE) {
[13:36:37.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.037]         }
[13:36:37.037]         else {
[13:36:37.037]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.037]         }
[13:36:37.037]         base::close(...future.stdout)
[13:36:37.037]         ...future.stdout <- NULL
[13:36:37.037]     }
[13:36:37.037]     ...future.result$conditions <- ...future.conditions
[13:36:37.037]     ...future.result$finished <- base::Sys.time()
[13:36:37.037]     ...future.result
[13:36:37.037] }
[13:36:37.040] MultisessionFuture started
[13:36:37.040] - Launch lazy future ... done
[13:36:37.040] run() for ‘MultisessionFuture’ ... done
[13:36:37.041] getGlobalsAndPackages() ...
[13:36:37.041] Searching for globals...
[13:36:37.041] - globals found: [1] ‘{’
[13:36:37.042] Searching for globals ... DONE
[13:36:37.042] Resolving globals: FALSE
[13:36:37.042] 
[13:36:37.042] 
[13:36:37.042] getGlobalsAndPackages() ... DONE
[13:36:37.042] run() for ‘Future’ ...
[13:36:37.043] - state: ‘created’
[13:36:37.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.056]   - Field: ‘node’
[13:36:37.056]   - Field: ‘label’
[13:36:37.056]   - Field: ‘local’
[13:36:37.056]   - Field: ‘owner’
[13:36:37.056]   - Field: ‘envir’
[13:36:37.056]   - Field: ‘workers’
[13:36:37.057]   - Field: ‘packages’
[13:36:37.057]   - Field: ‘gc’
[13:36:37.057]   - Field: ‘conditions’
[13:36:37.057]   - Field: ‘persistent’
[13:36:37.057]   - Field: ‘expr’
[13:36:37.057]   - Field: ‘uuid’
[13:36:37.057]   - Field: ‘seed’
[13:36:37.057]   - Field: ‘version’
[13:36:37.057]   - Field: ‘result’
[13:36:37.057]   - Field: ‘asynchronous’
[13:36:37.057]   - Field: ‘calls’
[13:36:37.058]   - Field: ‘globals’
[13:36:37.058]   - Field: ‘stdout’
[13:36:37.058]   - Field: ‘earlySignal’
[13:36:37.058]   - Field: ‘lazy’
[13:36:37.058]   - Field: ‘state’
[13:36:37.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.058] - Launch lazy future ...
[13:36:37.058] Packages needed by the future expression (n = 0): <none>
[13:36:37.059] Packages needed by future strategies (n = 0): <none>
[13:36:37.059] {
[13:36:37.059]     {
[13:36:37.059]         {
[13:36:37.059]             ...future.startTime <- base::Sys.time()
[13:36:37.059]             {
[13:36:37.059]                 {
[13:36:37.059]                   {
[13:36:37.059]                     {
[13:36:37.059]                       base::local({
[13:36:37.059]                         has_future <- base::requireNamespace("future", 
[13:36:37.059]                           quietly = TRUE)
[13:36:37.059]                         if (has_future) {
[13:36:37.059]                           ns <- base::getNamespace("future")
[13:36:37.059]                           version <- ns[[".package"]][["version"]]
[13:36:37.059]                           if (is.null(version)) 
[13:36:37.059]                             version <- utils::packageVersion("future")
[13:36:37.059]                         }
[13:36:37.059]                         else {
[13:36:37.059]                           version <- NULL
[13:36:37.059]                         }
[13:36:37.059]                         if (!has_future || version < "1.8.0") {
[13:36:37.059]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.059]                             "", base::R.version$version.string), 
[13:36:37.059]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.059]                               "release", "version")], collapse = " "), 
[13:36:37.059]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.059]                             info)
[13:36:37.059]                           info <- base::paste(info, collapse = "; ")
[13:36:37.059]                           if (!has_future) {
[13:36:37.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.059]                               info)
[13:36:37.059]                           }
[13:36:37.059]                           else {
[13:36:37.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.059]                               info, version)
[13:36:37.059]                           }
[13:36:37.059]                           base::stop(msg)
[13:36:37.059]                         }
[13:36:37.059]                       })
[13:36:37.059]                     }
[13:36:37.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.059]                     base::options(mc.cores = 1L)
[13:36:37.059]                   }
[13:36:37.059]                   ...future.strategy.old <- future::plan("list")
[13:36:37.059]                   options(future.plan = NULL)
[13:36:37.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.059]                 }
[13:36:37.059]                 ...future.workdir <- getwd()
[13:36:37.059]             }
[13:36:37.059]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.059]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.059]         }
[13:36:37.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.059]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.059]             base::names(...future.oldOptions))
[13:36:37.059]     }
[13:36:37.059]     if (FALSE) {
[13:36:37.059]     }
[13:36:37.059]     else {
[13:36:37.059]         if (TRUE) {
[13:36:37.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.059]                 open = "w")
[13:36:37.059]         }
[13:36:37.059]         else {
[13:36:37.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.059]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.059]         }
[13:36:37.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.059]             base::sink(type = "output", split = FALSE)
[13:36:37.059]             base::close(...future.stdout)
[13:36:37.059]         }, add = TRUE)
[13:36:37.059]     }
[13:36:37.059]     ...future.frame <- base::sys.nframe()
[13:36:37.059]     ...future.conditions <- base::list()
[13:36:37.059]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.059]     if (FALSE) {
[13:36:37.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.059]     }
[13:36:37.059]     ...future.result <- base::tryCatch({
[13:36:37.059]         base::withCallingHandlers({
[13:36:37.059]             ...future.value <- base::withVisible(base::local({
[13:36:37.059]                 ...future.makeSendCondition <- base::local({
[13:36:37.059]                   sendCondition <- NULL
[13:36:37.059]                   function(frame = 1L) {
[13:36:37.059]                     if (is.function(sendCondition)) 
[13:36:37.059]                       return(sendCondition)
[13:36:37.059]                     ns <- getNamespace("parallel")
[13:36:37.059]                     if (exists("sendData", mode = "function", 
[13:36:37.059]                       envir = ns)) {
[13:36:37.059]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.059]                         envir = ns)
[13:36:37.059]                       envir <- sys.frame(frame)
[13:36:37.059]                       master <- NULL
[13:36:37.059]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.059]                         !identical(envir, emptyenv())) {
[13:36:37.059]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.059]                           inherits = FALSE)) {
[13:36:37.059]                           master <- get("master", mode = "list", 
[13:36:37.059]                             envir = envir, inherits = FALSE)
[13:36:37.059]                           if (inherits(master, c("SOCKnode", 
[13:36:37.059]                             "SOCK0node"))) {
[13:36:37.059]                             sendCondition <<- function(cond) {
[13:36:37.059]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.059]                                 success = TRUE)
[13:36:37.059]                               parallel_sendData(master, data)
[13:36:37.059]                             }
[13:36:37.059]                             return(sendCondition)
[13:36:37.059]                           }
[13:36:37.059]                         }
[13:36:37.059]                         frame <- frame + 1L
[13:36:37.059]                         envir <- sys.frame(frame)
[13:36:37.059]                       }
[13:36:37.059]                     }
[13:36:37.059]                     sendCondition <<- function(cond) NULL
[13:36:37.059]                   }
[13:36:37.059]                 })
[13:36:37.059]                 withCallingHandlers({
[13:36:37.059]                   {
[13:36:37.059]                     4
[13:36:37.059]                   }
[13:36:37.059]                 }, immediateCondition = function(cond) {
[13:36:37.059]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.059]                   sendCondition(cond)
[13:36:37.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.059]                   {
[13:36:37.059]                     inherits <- base::inherits
[13:36:37.059]                     invokeRestart <- base::invokeRestart
[13:36:37.059]                     is.null <- base::is.null
[13:36:37.059]                     muffled <- FALSE
[13:36:37.059]                     if (inherits(cond, "message")) {
[13:36:37.059]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.059]                       if (muffled) 
[13:36:37.059]                         invokeRestart("muffleMessage")
[13:36:37.059]                     }
[13:36:37.059]                     else if (inherits(cond, "warning")) {
[13:36:37.059]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.059]                       if (muffled) 
[13:36:37.059]                         invokeRestart("muffleWarning")
[13:36:37.059]                     }
[13:36:37.059]                     else if (inherits(cond, "condition")) {
[13:36:37.059]                       if (!is.null(pattern)) {
[13:36:37.059]                         computeRestarts <- base::computeRestarts
[13:36:37.059]                         grepl <- base::grepl
[13:36:37.059]                         restarts <- computeRestarts(cond)
[13:36:37.059]                         for (restart in restarts) {
[13:36:37.059]                           name <- restart$name
[13:36:37.059]                           if (is.null(name)) 
[13:36:37.059]                             next
[13:36:37.059]                           if (!grepl(pattern, name)) 
[13:36:37.059]                             next
[13:36:37.059]                           invokeRestart(restart)
[13:36:37.059]                           muffled <- TRUE
[13:36:37.059]                           break
[13:36:37.059]                         }
[13:36:37.059]                       }
[13:36:37.059]                     }
[13:36:37.059]                     invisible(muffled)
[13:36:37.059]                   }
[13:36:37.059]                   muffleCondition(cond)
[13:36:37.059]                 })
[13:36:37.059]             }))
[13:36:37.059]             future::FutureResult(value = ...future.value$value, 
[13:36:37.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.059]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.059]                     ...future.globalenv.names))
[13:36:37.059]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.059]         }, condition = base::local({
[13:36:37.059]             c <- base::c
[13:36:37.059]             inherits <- base::inherits
[13:36:37.059]             invokeRestart <- base::invokeRestart
[13:36:37.059]             length <- base::length
[13:36:37.059]             list <- base::list
[13:36:37.059]             seq.int <- base::seq.int
[13:36:37.059]             signalCondition <- base::signalCondition
[13:36:37.059]             sys.calls <- base::sys.calls
[13:36:37.059]             `[[` <- base::`[[`
[13:36:37.059]             `+` <- base::`+`
[13:36:37.059]             `<<-` <- base::`<<-`
[13:36:37.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.059]                   3L)]
[13:36:37.059]             }
[13:36:37.059]             function(cond) {
[13:36:37.059]                 is_error <- inherits(cond, "error")
[13:36:37.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.059]                   NULL)
[13:36:37.059]                 if (is_error) {
[13:36:37.059]                   sessionInformation <- function() {
[13:36:37.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.059]                       search = base::search(), system = base::Sys.info())
[13:36:37.059]                   }
[13:36:37.059]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.059]                     cond$call), session = sessionInformation(), 
[13:36:37.059]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.059]                   signalCondition(cond)
[13:36:37.059]                 }
[13:36:37.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.059]                 "immediateCondition"))) {
[13:36:37.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.059]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.059]                   if (TRUE && !signal) {
[13:36:37.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.059]                     {
[13:36:37.059]                       inherits <- base::inherits
[13:36:37.059]                       invokeRestart <- base::invokeRestart
[13:36:37.059]                       is.null <- base::is.null
[13:36:37.059]                       muffled <- FALSE
[13:36:37.059]                       if (inherits(cond, "message")) {
[13:36:37.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.059]                         if (muffled) 
[13:36:37.059]                           invokeRestart("muffleMessage")
[13:36:37.059]                       }
[13:36:37.059]                       else if (inherits(cond, "warning")) {
[13:36:37.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.059]                         if (muffled) 
[13:36:37.059]                           invokeRestart("muffleWarning")
[13:36:37.059]                       }
[13:36:37.059]                       else if (inherits(cond, "condition")) {
[13:36:37.059]                         if (!is.null(pattern)) {
[13:36:37.059]                           computeRestarts <- base::computeRestarts
[13:36:37.059]                           grepl <- base::grepl
[13:36:37.059]                           restarts <- computeRestarts(cond)
[13:36:37.059]                           for (restart in restarts) {
[13:36:37.059]                             name <- restart$name
[13:36:37.059]                             if (is.null(name)) 
[13:36:37.059]                               next
[13:36:37.059]                             if (!grepl(pattern, name)) 
[13:36:37.059]                               next
[13:36:37.059]                             invokeRestart(restart)
[13:36:37.059]                             muffled <- TRUE
[13:36:37.059]                             break
[13:36:37.059]                           }
[13:36:37.059]                         }
[13:36:37.059]                       }
[13:36:37.059]                       invisible(muffled)
[13:36:37.059]                     }
[13:36:37.059]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.059]                   }
[13:36:37.059]                 }
[13:36:37.059]                 else {
[13:36:37.059]                   if (TRUE) {
[13:36:37.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.059]                     {
[13:36:37.059]                       inherits <- base::inherits
[13:36:37.059]                       invokeRestart <- base::invokeRestart
[13:36:37.059]                       is.null <- base::is.null
[13:36:37.059]                       muffled <- FALSE
[13:36:37.059]                       if (inherits(cond, "message")) {
[13:36:37.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.059]                         if (muffled) 
[13:36:37.059]                           invokeRestart("muffleMessage")
[13:36:37.059]                       }
[13:36:37.059]                       else if (inherits(cond, "warning")) {
[13:36:37.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.059]                         if (muffled) 
[13:36:37.059]                           invokeRestart("muffleWarning")
[13:36:37.059]                       }
[13:36:37.059]                       else if (inherits(cond, "condition")) {
[13:36:37.059]                         if (!is.null(pattern)) {
[13:36:37.059]                           computeRestarts <- base::computeRestarts
[13:36:37.059]                           grepl <- base::grepl
[13:36:37.059]                           restarts <- computeRestarts(cond)
[13:36:37.059]                           for (restart in restarts) {
[13:36:37.059]                             name <- restart$name
[13:36:37.059]                             if (is.null(name)) 
[13:36:37.059]                               next
[13:36:37.059]                             if (!grepl(pattern, name)) 
[13:36:37.059]                               next
[13:36:37.059]                             invokeRestart(restart)
[13:36:37.059]                             muffled <- TRUE
[13:36:37.059]                             break
[13:36:37.059]                           }
[13:36:37.059]                         }
[13:36:37.059]                       }
[13:36:37.059]                       invisible(muffled)
[13:36:37.059]                     }
[13:36:37.059]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.059]                   }
[13:36:37.059]                 }
[13:36:37.059]             }
[13:36:37.059]         }))
[13:36:37.059]     }, error = function(ex) {
[13:36:37.059]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.059]                 ...future.rng), started = ...future.startTime, 
[13:36:37.059]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.059]             version = "1.8"), class = "FutureResult")
[13:36:37.059]     }, finally = {
[13:36:37.059]         if (!identical(...future.workdir, getwd())) 
[13:36:37.059]             setwd(...future.workdir)
[13:36:37.059]         {
[13:36:37.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.059]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.059]             }
[13:36:37.059]             base::options(...future.oldOptions)
[13:36:37.059]             if (.Platform$OS.type == "windows") {
[13:36:37.059]                 old_names <- names(...future.oldEnvVars)
[13:36:37.059]                 envs <- base::Sys.getenv()
[13:36:37.059]                 names <- names(envs)
[13:36:37.059]                 common <- intersect(names, old_names)
[13:36:37.059]                 added <- setdiff(names, old_names)
[13:36:37.059]                 removed <- setdiff(old_names, names)
[13:36:37.059]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.059]                   envs[common]]
[13:36:37.059]                 NAMES <- toupper(changed)
[13:36:37.059]                 args <- list()
[13:36:37.059]                 for (kk in seq_along(NAMES)) {
[13:36:37.059]                   name <- changed[[kk]]
[13:36:37.059]                   NAME <- NAMES[[kk]]
[13:36:37.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.059]                     next
[13:36:37.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.059]                 }
[13:36:37.059]                 NAMES <- toupper(added)
[13:36:37.059]                 for (kk in seq_along(NAMES)) {
[13:36:37.059]                   name <- added[[kk]]
[13:36:37.059]                   NAME <- NAMES[[kk]]
[13:36:37.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.059]                     next
[13:36:37.059]                   args[[name]] <- ""
[13:36:37.059]                 }
[13:36:37.059]                 NAMES <- toupper(removed)
[13:36:37.059]                 for (kk in seq_along(NAMES)) {
[13:36:37.059]                   name <- removed[[kk]]
[13:36:37.059]                   NAME <- NAMES[[kk]]
[13:36:37.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.059]                     next
[13:36:37.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.059]                 }
[13:36:37.059]                 if (length(args) > 0) 
[13:36:37.059]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.059]             }
[13:36:37.059]             else {
[13:36:37.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.059]             }
[13:36:37.059]             {
[13:36:37.059]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.059]                   0L) {
[13:36:37.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.059]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.059]                   base::options(opts)
[13:36:37.059]                 }
[13:36:37.059]                 {
[13:36:37.059]                   {
[13:36:37.059]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.059]                     NULL
[13:36:37.059]                   }
[13:36:37.059]                   options(future.plan = NULL)
[13:36:37.059]                   if (is.na(NA_character_)) 
[13:36:37.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.059]                     .init = FALSE)
[13:36:37.059]                 }
[13:36:37.059]             }
[13:36:37.059]         }
[13:36:37.059]     })
[13:36:37.059]     if (TRUE) {
[13:36:37.059]         base::sink(type = "output", split = FALSE)
[13:36:37.059]         if (TRUE) {
[13:36:37.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.059]         }
[13:36:37.059]         else {
[13:36:37.059]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.059]         }
[13:36:37.059]         base::close(...future.stdout)
[13:36:37.059]         ...future.stdout <- NULL
[13:36:37.059]     }
[13:36:37.059]     ...future.result$conditions <- ...future.conditions
[13:36:37.059]     ...future.result$finished <- base::Sys.time()
[13:36:37.059]     ...future.result
[13:36:37.059] }
[13:36:37.061] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:37.072] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.072] - Validating connection of MultisessionFuture
[13:36:37.072] - received message: FutureResult
[13:36:37.072] - Received FutureResult
[13:36:37.072] - Erased future from FutureRegistry
[13:36:37.072] result() for ClusterFuture ...
[13:36:37.072] - result already collected: FutureResult
[13:36:37.072] result() for ClusterFuture ... done
[13:36:37.072] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.073] result() for ClusterFuture ...
[13:36:37.073] - result already collected: FutureResult
[13:36:37.073] result() for ClusterFuture ... done
[13:36:37.073] result() for ClusterFuture ...
[13:36:37.073] - result already collected: FutureResult
[13:36:37.073] result() for ClusterFuture ... done
[13:36:37.074] MultisessionFuture started
[13:36:37.074] - Launch lazy future ... done
[13:36:37.074] run() for ‘MultisessionFuture’ ... done
<environment: 0x564a74d3b780> 
<environment: 0x564a72ef7928> 
[13:36:37.076] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.076] - Validating connection of MultisessionFuture
[13:36:37.076] - received message: FutureResult
[13:36:37.076] - Received FutureResult
[13:36:37.076] - Erased future from FutureRegistry
[13:36:37.077] result() for ClusterFuture ...
[13:36:37.077] - result already collected: FutureResult
[13:36:37.077] result() for ClusterFuture ... done
[13:36:37.077] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.077] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.077] - Validating connection of MultisessionFuture
[13:36:37.077] - received message: FutureResult
[13:36:37.078] - Received FutureResult
[13:36:37.078] - Erased future from FutureRegistry
[13:36:37.078] result() for ClusterFuture ...
[13:36:37.078] - result already collected: FutureResult
[13:36:37.078] result() for ClusterFuture ... done
[13:36:37.078] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:37.079] resolve() on environment ...
[13:36:37.079]  recursive: 0
[13:36:37.080]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:37.080] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.080] - nx: 4
[13:36:37.080] - relay: TRUE
[13:36:37.080] - stdout: TRUE
[13:36:37.080] - signal: TRUE
[13:36:37.080] - resignal: FALSE
[13:36:37.081] - force: TRUE
[13:36:37.081] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.081] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.081]  - until=2
[13:36:37.081]  - relaying element #2
[13:36:37.081] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.081] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.081] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.081]  length: 3 (resolved future 1)
[13:36:37.081] Future #2
[13:36:37.081] result() for ClusterFuture ...
[13:36:37.082] - result already collected: FutureResult
[13:36:37.082] result() for ClusterFuture ... done
[13:36:37.082] result() for ClusterFuture ...
[13:36:37.082] - result already collected: FutureResult
[13:36:37.082] result() for ClusterFuture ... done
[13:36:37.082] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:37.082] - nx: 4
[13:36:37.082] - relay: TRUE
[13:36:37.082] - stdout: TRUE
[13:36:37.082] - signal: TRUE
[13:36:37.082] - resignal: FALSE
[13:36:37.083] - force: TRUE
[13:36:37.083] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.083] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.083]  - until=2
[13:36:37.083]  - relaying element #2
[13:36:37.083] result() for ClusterFuture ...
[13:36:37.083] - result already collected: FutureResult
[13:36:37.083] result() for ClusterFuture ... done
[13:36:37.083] result() for ClusterFuture ...
[13:36:37.083] - result already collected: FutureResult
[13:36:37.083] result() for ClusterFuture ... done
[13:36:37.084] result() for ClusterFuture ...
[13:36:37.084] - result already collected: FutureResult
[13:36:37.084] result() for ClusterFuture ... done
[13:36:37.084] result() for ClusterFuture ...
[13:36:37.084] - result already collected: FutureResult
[13:36:37.084] result() for ClusterFuture ... done
[13:36:37.084] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.084] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.084] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:37.084]  length: 2 (resolved future 2)
[13:36:37.085] Future #3
[13:36:37.085] result() for ClusterFuture ...
[13:36:37.085] - result already collected: FutureResult
[13:36:37.085] result() for ClusterFuture ... done
[13:36:37.085] result() for ClusterFuture ...
[13:36:37.085] - result already collected: FutureResult
[13:36:37.085] result() for ClusterFuture ... done
[13:36:37.085] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:37.085] - nx: 4
[13:36:37.085] - relay: TRUE
[13:36:37.085] - stdout: TRUE
[13:36:37.086] - signal: TRUE
[13:36:37.086] - resignal: FALSE
[13:36:37.086] - force: TRUE
[13:36:37.086] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.086] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.086]  - until=3
[13:36:37.086]  - relaying element #3
[13:36:37.086] result() for ClusterFuture ...
[13:36:37.086] - result already collected: FutureResult
[13:36:37.086] result() for ClusterFuture ... done
[13:36:37.086] result() for ClusterFuture ...
[13:36:37.087] - result already collected: FutureResult
[13:36:37.087] result() for ClusterFuture ... done
[13:36:37.087] result() for ClusterFuture ...
[13:36:37.087] - result already collected: FutureResult
[13:36:37.087] result() for ClusterFuture ... done
[13:36:37.087] result() for ClusterFuture ...
[13:36:37.087] - result already collected: FutureResult
[13:36:37.087] result() for ClusterFuture ... done
[13:36:37.087] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.087] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.087] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:37.088]  length: 1 (resolved future 3)
[13:36:37.088] Future #4
[13:36:37.088] result() for ClusterFuture ...
[13:36:37.088] - result already collected: FutureResult
[13:36:37.088] result() for ClusterFuture ... done
[13:36:37.088] result() for ClusterFuture ...
[13:36:37.088] - result already collected: FutureResult
[13:36:37.088] result() for ClusterFuture ... done
[13:36:37.088] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:37.088] - nx: 4
[13:36:37.088] - relay: TRUE
[13:36:37.088] - stdout: TRUE
[13:36:37.089] - signal: TRUE
[13:36:37.089] - resignal: FALSE
[13:36:37.089] - force: TRUE
[13:36:37.089] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.089] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.089]  - until=4
[13:36:37.089]  - relaying element #4
[13:36:37.089] result() for ClusterFuture ...
[13:36:37.089] - result already collected: FutureResult
[13:36:37.089] result() for ClusterFuture ... done
[13:36:37.089] result() for ClusterFuture ...
[13:36:37.090] - result already collected: FutureResult
[13:36:37.090] result() for ClusterFuture ... done
[13:36:37.090] result() for ClusterFuture ...
[13:36:37.090] - result already collected: FutureResult
[13:36:37.090] result() for ClusterFuture ... done
[13:36:37.090] result() for ClusterFuture ...
[13:36:37.090] - result already collected: FutureResult
[13:36:37.090] result() for ClusterFuture ... done
[13:36:37.090] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.090] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.090] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:37.091]  length: 0 (resolved future 4)
[13:36:37.091] Relaying remaining futures
[13:36:37.091] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.091] - nx: 4
[13:36:37.091] - relay: TRUE
[13:36:37.091] - stdout: TRUE
[13:36:37.091] - signal: TRUE
[13:36:37.091] - resignal: FALSE
[13:36:37.091] - force: TRUE
[13:36:37.091] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.091] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:37.092] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.092] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.092] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.092] resolve() on environment ... DONE
[13:36:37.092] result() for ClusterFuture ...
[13:36:37.092] - result already collected: FutureResult
[13:36:37.092] result() for ClusterFuture ... done
[13:36:37.092] result() for ClusterFuture ...
[13:36:37.092] - result already collected: FutureResult
[13:36:37.092] result() for ClusterFuture ... done
[13:36:37.092] result() for ClusterFuture ...
[13:36:37.093] - result already collected: FutureResult
[13:36:37.093] result() for ClusterFuture ... done
[13:36:37.093] result() for ClusterFuture ...
[13:36:37.093] - result already collected: FutureResult
[13:36:37.093] result() for ClusterFuture ... done
[13:36:37.093] result() for ClusterFuture ...
[13:36:37.093] - result already collected: FutureResult
[13:36:37.093] result() for ClusterFuture ... done
[13:36:37.093] result() for ClusterFuture ...
[13:36:37.093] - result already collected: FutureResult
[13:36:37.093] result() for ClusterFuture ... done
<environment: 0x564a715b6810> 
Dimensions: c(2, 3)
[13:36:37.094] getGlobalsAndPackages() ...
[13:36:37.094] Searching for globals...
[13:36:37.094] 
[13:36:37.094] Searching for globals ... DONE
[13:36:37.094] - globals: [0] <none>
[13:36:37.095] getGlobalsAndPackages() ... DONE
[13:36:37.095] run() for ‘Future’ ...
[13:36:37.095] - state: ‘created’
[13:36:37.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.109]   - Field: ‘node’
[13:36:37.109]   - Field: ‘label’
[13:36:37.109]   - Field: ‘local’
[13:36:37.109]   - Field: ‘owner’
[13:36:37.109]   - Field: ‘envir’
[13:36:37.109]   - Field: ‘workers’
[13:36:37.109]   - Field: ‘packages’
[13:36:37.109]   - Field: ‘gc’
[13:36:37.110]   - Field: ‘conditions’
[13:36:37.110]   - Field: ‘persistent’
[13:36:37.110]   - Field: ‘expr’
[13:36:37.110]   - Field: ‘uuid’
[13:36:37.110]   - Field: ‘seed’
[13:36:37.110]   - Field: ‘version’
[13:36:37.110]   - Field: ‘result’
[13:36:37.110]   - Field: ‘asynchronous’
[13:36:37.110]   - Field: ‘calls’
[13:36:37.110]   - Field: ‘globals’
[13:36:37.110]   - Field: ‘stdout’
[13:36:37.111]   - Field: ‘earlySignal’
[13:36:37.111]   - Field: ‘lazy’
[13:36:37.111]   - Field: ‘state’
[13:36:37.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.111] - Launch lazy future ...
[13:36:37.111] Packages needed by the future expression (n = 0): <none>
[13:36:37.111] Packages needed by future strategies (n = 0): <none>
[13:36:37.112] {
[13:36:37.112]     {
[13:36:37.112]         {
[13:36:37.112]             ...future.startTime <- base::Sys.time()
[13:36:37.112]             {
[13:36:37.112]                 {
[13:36:37.112]                   {
[13:36:37.112]                     {
[13:36:37.112]                       base::local({
[13:36:37.112]                         has_future <- base::requireNamespace("future", 
[13:36:37.112]                           quietly = TRUE)
[13:36:37.112]                         if (has_future) {
[13:36:37.112]                           ns <- base::getNamespace("future")
[13:36:37.112]                           version <- ns[[".package"]][["version"]]
[13:36:37.112]                           if (is.null(version)) 
[13:36:37.112]                             version <- utils::packageVersion("future")
[13:36:37.112]                         }
[13:36:37.112]                         else {
[13:36:37.112]                           version <- NULL
[13:36:37.112]                         }
[13:36:37.112]                         if (!has_future || version < "1.8.0") {
[13:36:37.112]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.112]                             "", base::R.version$version.string), 
[13:36:37.112]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.112]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.112]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.112]                               "release", "version")], collapse = " "), 
[13:36:37.112]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.112]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.112]                             info)
[13:36:37.112]                           info <- base::paste(info, collapse = "; ")
[13:36:37.112]                           if (!has_future) {
[13:36:37.112]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.112]                               info)
[13:36:37.112]                           }
[13:36:37.112]                           else {
[13:36:37.112]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.112]                               info, version)
[13:36:37.112]                           }
[13:36:37.112]                           base::stop(msg)
[13:36:37.112]                         }
[13:36:37.112]                       })
[13:36:37.112]                     }
[13:36:37.112]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.112]                     base::options(mc.cores = 1L)
[13:36:37.112]                   }
[13:36:37.112]                   ...future.strategy.old <- future::plan("list")
[13:36:37.112]                   options(future.plan = NULL)
[13:36:37.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.112]                 }
[13:36:37.112]                 ...future.workdir <- getwd()
[13:36:37.112]             }
[13:36:37.112]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.112]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.112]         }
[13:36:37.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.112]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.112]             base::names(...future.oldOptions))
[13:36:37.112]     }
[13:36:37.112]     if (FALSE) {
[13:36:37.112]     }
[13:36:37.112]     else {
[13:36:37.112]         if (TRUE) {
[13:36:37.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.112]                 open = "w")
[13:36:37.112]         }
[13:36:37.112]         else {
[13:36:37.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.112]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.112]         }
[13:36:37.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.112]             base::sink(type = "output", split = FALSE)
[13:36:37.112]             base::close(...future.stdout)
[13:36:37.112]         }, add = TRUE)
[13:36:37.112]     }
[13:36:37.112]     ...future.frame <- base::sys.nframe()
[13:36:37.112]     ...future.conditions <- base::list()
[13:36:37.112]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.112]     if (FALSE) {
[13:36:37.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.112]     }
[13:36:37.112]     ...future.result <- base::tryCatch({
[13:36:37.112]         base::withCallingHandlers({
[13:36:37.112]             ...future.value <- base::withVisible(base::local({
[13:36:37.112]                 ...future.makeSendCondition <- base::local({
[13:36:37.112]                   sendCondition <- NULL
[13:36:37.112]                   function(frame = 1L) {
[13:36:37.112]                     if (is.function(sendCondition)) 
[13:36:37.112]                       return(sendCondition)
[13:36:37.112]                     ns <- getNamespace("parallel")
[13:36:37.112]                     if (exists("sendData", mode = "function", 
[13:36:37.112]                       envir = ns)) {
[13:36:37.112]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.112]                         envir = ns)
[13:36:37.112]                       envir <- sys.frame(frame)
[13:36:37.112]                       master <- NULL
[13:36:37.112]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.112]                         !identical(envir, emptyenv())) {
[13:36:37.112]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.112]                           inherits = FALSE)) {
[13:36:37.112]                           master <- get("master", mode = "list", 
[13:36:37.112]                             envir = envir, inherits = FALSE)
[13:36:37.112]                           if (inherits(master, c("SOCKnode", 
[13:36:37.112]                             "SOCK0node"))) {
[13:36:37.112]                             sendCondition <<- function(cond) {
[13:36:37.112]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.112]                                 success = TRUE)
[13:36:37.112]                               parallel_sendData(master, data)
[13:36:37.112]                             }
[13:36:37.112]                             return(sendCondition)
[13:36:37.112]                           }
[13:36:37.112]                         }
[13:36:37.112]                         frame <- frame + 1L
[13:36:37.112]                         envir <- sys.frame(frame)
[13:36:37.112]                       }
[13:36:37.112]                     }
[13:36:37.112]                     sendCondition <<- function(cond) NULL
[13:36:37.112]                   }
[13:36:37.112]                 })
[13:36:37.112]                 withCallingHandlers({
[13:36:37.112]                   2
[13:36:37.112]                 }, immediateCondition = function(cond) {
[13:36:37.112]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.112]                   sendCondition(cond)
[13:36:37.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.112]                   {
[13:36:37.112]                     inherits <- base::inherits
[13:36:37.112]                     invokeRestart <- base::invokeRestart
[13:36:37.112]                     is.null <- base::is.null
[13:36:37.112]                     muffled <- FALSE
[13:36:37.112]                     if (inherits(cond, "message")) {
[13:36:37.112]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.112]                       if (muffled) 
[13:36:37.112]                         invokeRestart("muffleMessage")
[13:36:37.112]                     }
[13:36:37.112]                     else if (inherits(cond, "warning")) {
[13:36:37.112]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.112]                       if (muffled) 
[13:36:37.112]                         invokeRestart("muffleWarning")
[13:36:37.112]                     }
[13:36:37.112]                     else if (inherits(cond, "condition")) {
[13:36:37.112]                       if (!is.null(pattern)) {
[13:36:37.112]                         computeRestarts <- base::computeRestarts
[13:36:37.112]                         grepl <- base::grepl
[13:36:37.112]                         restarts <- computeRestarts(cond)
[13:36:37.112]                         for (restart in restarts) {
[13:36:37.112]                           name <- restart$name
[13:36:37.112]                           if (is.null(name)) 
[13:36:37.112]                             next
[13:36:37.112]                           if (!grepl(pattern, name)) 
[13:36:37.112]                             next
[13:36:37.112]                           invokeRestart(restart)
[13:36:37.112]                           muffled <- TRUE
[13:36:37.112]                           break
[13:36:37.112]                         }
[13:36:37.112]                       }
[13:36:37.112]                     }
[13:36:37.112]                     invisible(muffled)
[13:36:37.112]                   }
[13:36:37.112]                   muffleCondition(cond)
[13:36:37.112]                 })
[13:36:37.112]             }))
[13:36:37.112]             future::FutureResult(value = ...future.value$value, 
[13:36:37.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.112]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.112]                     ...future.globalenv.names))
[13:36:37.112]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.112]         }, condition = base::local({
[13:36:37.112]             c <- base::c
[13:36:37.112]             inherits <- base::inherits
[13:36:37.112]             invokeRestart <- base::invokeRestart
[13:36:37.112]             length <- base::length
[13:36:37.112]             list <- base::list
[13:36:37.112]             seq.int <- base::seq.int
[13:36:37.112]             signalCondition <- base::signalCondition
[13:36:37.112]             sys.calls <- base::sys.calls
[13:36:37.112]             `[[` <- base::`[[`
[13:36:37.112]             `+` <- base::`+`
[13:36:37.112]             `<<-` <- base::`<<-`
[13:36:37.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.112]                   3L)]
[13:36:37.112]             }
[13:36:37.112]             function(cond) {
[13:36:37.112]                 is_error <- inherits(cond, "error")
[13:36:37.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.112]                   NULL)
[13:36:37.112]                 if (is_error) {
[13:36:37.112]                   sessionInformation <- function() {
[13:36:37.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.112]                       search = base::search(), system = base::Sys.info())
[13:36:37.112]                   }
[13:36:37.112]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.112]                     cond$call), session = sessionInformation(), 
[13:36:37.112]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.112]                   signalCondition(cond)
[13:36:37.112]                 }
[13:36:37.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.112]                 "immediateCondition"))) {
[13:36:37.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.112]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.112]                   if (TRUE && !signal) {
[13:36:37.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.112]                     {
[13:36:37.112]                       inherits <- base::inherits
[13:36:37.112]                       invokeRestart <- base::invokeRestart
[13:36:37.112]                       is.null <- base::is.null
[13:36:37.112]                       muffled <- FALSE
[13:36:37.112]                       if (inherits(cond, "message")) {
[13:36:37.112]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.112]                         if (muffled) 
[13:36:37.112]                           invokeRestart("muffleMessage")
[13:36:37.112]                       }
[13:36:37.112]                       else if (inherits(cond, "warning")) {
[13:36:37.112]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.112]                         if (muffled) 
[13:36:37.112]                           invokeRestart("muffleWarning")
[13:36:37.112]                       }
[13:36:37.112]                       else if (inherits(cond, "condition")) {
[13:36:37.112]                         if (!is.null(pattern)) {
[13:36:37.112]                           computeRestarts <- base::computeRestarts
[13:36:37.112]                           grepl <- base::grepl
[13:36:37.112]                           restarts <- computeRestarts(cond)
[13:36:37.112]                           for (restart in restarts) {
[13:36:37.112]                             name <- restart$name
[13:36:37.112]                             if (is.null(name)) 
[13:36:37.112]                               next
[13:36:37.112]                             if (!grepl(pattern, name)) 
[13:36:37.112]                               next
[13:36:37.112]                             invokeRestart(restart)
[13:36:37.112]                             muffled <- TRUE
[13:36:37.112]                             break
[13:36:37.112]                           }
[13:36:37.112]                         }
[13:36:37.112]                       }
[13:36:37.112]                       invisible(muffled)
[13:36:37.112]                     }
[13:36:37.112]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.112]                   }
[13:36:37.112]                 }
[13:36:37.112]                 else {
[13:36:37.112]                   if (TRUE) {
[13:36:37.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.112]                     {
[13:36:37.112]                       inherits <- base::inherits
[13:36:37.112]                       invokeRestart <- base::invokeRestart
[13:36:37.112]                       is.null <- base::is.null
[13:36:37.112]                       muffled <- FALSE
[13:36:37.112]                       if (inherits(cond, "message")) {
[13:36:37.112]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.112]                         if (muffled) 
[13:36:37.112]                           invokeRestart("muffleMessage")
[13:36:37.112]                       }
[13:36:37.112]                       else if (inherits(cond, "warning")) {
[13:36:37.112]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.112]                         if (muffled) 
[13:36:37.112]                           invokeRestart("muffleWarning")
[13:36:37.112]                       }
[13:36:37.112]                       else if (inherits(cond, "condition")) {
[13:36:37.112]                         if (!is.null(pattern)) {
[13:36:37.112]                           computeRestarts <- base::computeRestarts
[13:36:37.112]                           grepl <- base::grepl
[13:36:37.112]                           restarts <- computeRestarts(cond)
[13:36:37.112]                           for (restart in restarts) {
[13:36:37.112]                             name <- restart$name
[13:36:37.112]                             if (is.null(name)) 
[13:36:37.112]                               next
[13:36:37.112]                             if (!grepl(pattern, name)) 
[13:36:37.112]                               next
[13:36:37.112]                             invokeRestart(restart)
[13:36:37.112]                             muffled <- TRUE
[13:36:37.112]                             break
[13:36:37.112]                           }
[13:36:37.112]                         }
[13:36:37.112]                       }
[13:36:37.112]                       invisible(muffled)
[13:36:37.112]                     }
[13:36:37.112]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.112]                   }
[13:36:37.112]                 }
[13:36:37.112]             }
[13:36:37.112]         }))
[13:36:37.112]     }, error = function(ex) {
[13:36:37.112]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.112]                 ...future.rng), started = ...future.startTime, 
[13:36:37.112]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.112]             version = "1.8"), class = "FutureResult")
[13:36:37.112]     }, finally = {
[13:36:37.112]         if (!identical(...future.workdir, getwd())) 
[13:36:37.112]             setwd(...future.workdir)
[13:36:37.112]         {
[13:36:37.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.112]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.112]             }
[13:36:37.112]             base::options(...future.oldOptions)
[13:36:37.112]             if (.Platform$OS.type == "windows") {
[13:36:37.112]                 old_names <- names(...future.oldEnvVars)
[13:36:37.112]                 envs <- base::Sys.getenv()
[13:36:37.112]                 names <- names(envs)
[13:36:37.112]                 common <- intersect(names, old_names)
[13:36:37.112]                 added <- setdiff(names, old_names)
[13:36:37.112]                 removed <- setdiff(old_names, names)
[13:36:37.112]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.112]                   envs[common]]
[13:36:37.112]                 NAMES <- toupper(changed)
[13:36:37.112]                 args <- list()
[13:36:37.112]                 for (kk in seq_along(NAMES)) {
[13:36:37.112]                   name <- changed[[kk]]
[13:36:37.112]                   NAME <- NAMES[[kk]]
[13:36:37.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.112]                     next
[13:36:37.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.112]                 }
[13:36:37.112]                 NAMES <- toupper(added)
[13:36:37.112]                 for (kk in seq_along(NAMES)) {
[13:36:37.112]                   name <- added[[kk]]
[13:36:37.112]                   NAME <- NAMES[[kk]]
[13:36:37.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.112]                     next
[13:36:37.112]                   args[[name]] <- ""
[13:36:37.112]                 }
[13:36:37.112]                 NAMES <- toupper(removed)
[13:36:37.112]                 for (kk in seq_along(NAMES)) {
[13:36:37.112]                   name <- removed[[kk]]
[13:36:37.112]                   NAME <- NAMES[[kk]]
[13:36:37.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.112]                     next
[13:36:37.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.112]                 }
[13:36:37.112]                 if (length(args) > 0) 
[13:36:37.112]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.112]             }
[13:36:37.112]             else {
[13:36:37.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.112]             }
[13:36:37.112]             {
[13:36:37.112]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.112]                   0L) {
[13:36:37.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.112]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.112]                   base::options(opts)
[13:36:37.112]                 }
[13:36:37.112]                 {
[13:36:37.112]                   {
[13:36:37.112]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.112]                     NULL
[13:36:37.112]                   }
[13:36:37.112]                   options(future.plan = NULL)
[13:36:37.112]                   if (is.na(NA_character_)) 
[13:36:37.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.112]                     .init = FALSE)
[13:36:37.112]                 }
[13:36:37.112]             }
[13:36:37.112]         }
[13:36:37.112]     })
[13:36:37.112]     if (TRUE) {
[13:36:37.112]         base::sink(type = "output", split = FALSE)
[13:36:37.112]         if (TRUE) {
[13:36:37.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.112]         }
[13:36:37.112]         else {
[13:36:37.112]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.112]         }
[13:36:37.112]         base::close(...future.stdout)
[13:36:37.112]         ...future.stdout <- NULL
[13:36:37.112]     }
[13:36:37.112]     ...future.result$conditions <- ...future.conditions
[13:36:37.112]     ...future.result$finished <- base::Sys.time()
[13:36:37.112]     ...future.result
[13:36:37.112] }
[13:36:37.114] MultisessionFuture started
[13:36:37.115] - Launch lazy future ... done
[13:36:37.115] run() for ‘MultisessionFuture’ ... done
[13:36:37.115] getGlobalsAndPackages() ...
[13:36:37.115] Searching for globals...
[13:36:37.115] 
[13:36:37.115] Searching for globals ... DONE
[13:36:37.115] - globals: [0] <none>
[13:36:37.115] getGlobalsAndPackages() ... DONE
[13:36:37.116] run() for ‘Future’ ...
[13:36:37.116] - state: ‘created’
[13:36:37.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.129]   - Field: ‘node’
[13:36:37.130]   - Field: ‘label’
[13:36:37.130]   - Field: ‘local’
[13:36:37.130]   - Field: ‘owner’
[13:36:37.130]   - Field: ‘envir’
[13:36:37.130]   - Field: ‘workers’
[13:36:37.130]   - Field: ‘packages’
[13:36:37.130]   - Field: ‘gc’
[13:36:37.130]   - Field: ‘conditions’
[13:36:37.130]   - Field: ‘persistent’
[13:36:37.130]   - Field: ‘expr’
[13:36:37.131]   - Field: ‘uuid’
[13:36:37.131]   - Field: ‘seed’
[13:36:37.131]   - Field: ‘version’
[13:36:37.131]   - Field: ‘result’
[13:36:37.131]   - Field: ‘asynchronous’
[13:36:37.131]   - Field: ‘calls’
[13:36:37.131]   - Field: ‘globals’
[13:36:37.131]   - Field: ‘stdout’
[13:36:37.131]   - Field: ‘earlySignal’
[13:36:37.131]   - Field: ‘lazy’
[13:36:37.131]   - Field: ‘state’
[13:36:37.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.132] - Launch lazy future ...
[13:36:37.132] Packages needed by the future expression (n = 0): <none>
[13:36:37.132] Packages needed by future strategies (n = 0): <none>
[13:36:37.132] {
[13:36:37.132]     {
[13:36:37.132]         {
[13:36:37.132]             ...future.startTime <- base::Sys.time()
[13:36:37.132]             {
[13:36:37.132]                 {
[13:36:37.132]                   {
[13:36:37.132]                     {
[13:36:37.132]                       base::local({
[13:36:37.132]                         has_future <- base::requireNamespace("future", 
[13:36:37.132]                           quietly = TRUE)
[13:36:37.132]                         if (has_future) {
[13:36:37.132]                           ns <- base::getNamespace("future")
[13:36:37.132]                           version <- ns[[".package"]][["version"]]
[13:36:37.132]                           if (is.null(version)) 
[13:36:37.132]                             version <- utils::packageVersion("future")
[13:36:37.132]                         }
[13:36:37.132]                         else {
[13:36:37.132]                           version <- NULL
[13:36:37.132]                         }
[13:36:37.132]                         if (!has_future || version < "1.8.0") {
[13:36:37.132]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.132]                             "", base::R.version$version.string), 
[13:36:37.132]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.132]                               "release", "version")], collapse = " "), 
[13:36:37.132]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.132]                             info)
[13:36:37.132]                           info <- base::paste(info, collapse = "; ")
[13:36:37.132]                           if (!has_future) {
[13:36:37.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.132]                               info)
[13:36:37.132]                           }
[13:36:37.132]                           else {
[13:36:37.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.132]                               info, version)
[13:36:37.132]                           }
[13:36:37.132]                           base::stop(msg)
[13:36:37.132]                         }
[13:36:37.132]                       })
[13:36:37.132]                     }
[13:36:37.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.132]                     base::options(mc.cores = 1L)
[13:36:37.132]                   }
[13:36:37.132]                   ...future.strategy.old <- future::plan("list")
[13:36:37.132]                   options(future.plan = NULL)
[13:36:37.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.132]                 }
[13:36:37.132]                 ...future.workdir <- getwd()
[13:36:37.132]             }
[13:36:37.132]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.132]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.132]         }
[13:36:37.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.132]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.132]             base::names(...future.oldOptions))
[13:36:37.132]     }
[13:36:37.132]     if (FALSE) {
[13:36:37.132]     }
[13:36:37.132]     else {
[13:36:37.132]         if (TRUE) {
[13:36:37.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.132]                 open = "w")
[13:36:37.132]         }
[13:36:37.132]         else {
[13:36:37.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.132]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.132]         }
[13:36:37.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.132]             base::sink(type = "output", split = FALSE)
[13:36:37.132]             base::close(...future.stdout)
[13:36:37.132]         }, add = TRUE)
[13:36:37.132]     }
[13:36:37.132]     ...future.frame <- base::sys.nframe()
[13:36:37.132]     ...future.conditions <- base::list()
[13:36:37.132]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.132]     if (FALSE) {
[13:36:37.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.132]     }
[13:36:37.132]     ...future.result <- base::tryCatch({
[13:36:37.132]         base::withCallingHandlers({
[13:36:37.132]             ...future.value <- base::withVisible(base::local({
[13:36:37.132]                 ...future.makeSendCondition <- base::local({
[13:36:37.132]                   sendCondition <- NULL
[13:36:37.132]                   function(frame = 1L) {
[13:36:37.132]                     if (is.function(sendCondition)) 
[13:36:37.132]                       return(sendCondition)
[13:36:37.132]                     ns <- getNamespace("parallel")
[13:36:37.132]                     if (exists("sendData", mode = "function", 
[13:36:37.132]                       envir = ns)) {
[13:36:37.132]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.132]                         envir = ns)
[13:36:37.132]                       envir <- sys.frame(frame)
[13:36:37.132]                       master <- NULL
[13:36:37.132]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.132]                         !identical(envir, emptyenv())) {
[13:36:37.132]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.132]                           inherits = FALSE)) {
[13:36:37.132]                           master <- get("master", mode = "list", 
[13:36:37.132]                             envir = envir, inherits = FALSE)
[13:36:37.132]                           if (inherits(master, c("SOCKnode", 
[13:36:37.132]                             "SOCK0node"))) {
[13:36:37.132]                             sendCondition <<- function(cond) {
[13:36:37.132]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.132]                                 success = TRUE)
[13:36:37.132]                               parallel_sendData(master, data)
[13:36:37.132]                             }
[13:36:37.132]                             return(sendCondition)
[13:36:37.132]                           }
[13:36:37.132]                         }
[13:36:37.132]                         frame <- frame + 1L
[13:36:37.132]                         envir <- sys.frame(frame)
[13:36:37.132]                       }
[13:36:37.132]                     }
[13:36:37.132]                     sendCondition <<- function(cond) NULL
[13:36:37.132]                   }
[13:36:37.132]                 })
[13:36:37.132]                 withCallingHandlers({
[13:36:37.132]                   NULL
[13:36:37.132]                 }, immediateCondition = function(cond) {
[13:36:37.132]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.132]                   sendCondition(cond)
[13:36:37.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.132]                   {
[13:36:37.132]                     inherits <- base::inherits
[13:36:37.132]                     invokeRestart <- base::invokeRestart
[13:36:37.132]                     is.null <- base::is.null
[13:36:37.132]                     muffled <- FALSE
[13:36:37.132]                     if (inherits(cond, "message")) {
[13:36:37.132]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.132]                       if (muffled) 
[13:36:37.132]                         invokeRestart("muffleMessage")
[13:36:37.132]                     }
[13:36:37.132]                     else if (inherits(cond, "warning")) {
[13:36:37.132]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.132]                       if (muffled) 
[13:36:37.132]                         invokeRestart("muffleWarning")
[13:36:37.132]                     }
[13:36:37.132]                     else if (inherits(cond, "condition")) {
[13:36:37.132]                       if (!is.null(pattern)) {
[13:36:37.132]                         computeRestarts <- base::computeRestarts
[13:36:37.132]                         grepl <- base::grepl
[13:36:37.132]                         restarts <- computeRestarts(cond)
[13:36:37.132]                         for (restart in restarts) {
[13:36:37.132]                           name <- restart$name
[13:36:37.132]                           if (is.null(name)) 
[13:36:37.132]                             next
[13:36:37.132]                           if (!grepl(pattern, name)) 
[13:36:37.132]                             next
[13:36:37.132]                           invokeRestart(restart)
[13:36:37.132]                           muffled <- TRUE
[13:36:37.132]                           break
[13:36:37.132]                         }
[13:36:37.132]                       }
[13:36:37.132]                     }
[13:36:37.132]                     invisible(muffled)
[13:36:37.132]                   }
[13:36:37.132]                   muffleCondition(cond)
[13:36:37.132]                 })
[13:36:37.132]             }))
[13:36:37.132]             future::FutureResult(value = ...future.value$value, 
[13:36:37.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.132]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.132]                     ...future.globalenv.names))
[13:36:37.132]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.132]         }, condition = base::local({
[13:36:37.132]             c <- base::c
[13:36:37.132]             inherits <- base::inherits
[13:36:37.132]             invokeRestart <- base::invokeRestart
[13:36:37.132]             length <- base::length
[13:36:37.132]             list <- base::list
[13:36:37.132]             seq.int <- base::seq.int
[13:36:37.132]             signalCondition <- base::signalCondition
[13:36:37.132]             sys.calls <- base::sys.calls
[13:36:37.132]             `[[` <- base::`[[`
[13:36:37.132]             `+` <- base::`+`
[13:36:37.132]             `<<-` <- base::`<<-`
[13:36:37.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.132]                   3L)]
[13:36:37.132]             }
[13:36:37.132]             function(cond) {
[13:36:37.132]                 is_error <- inherits(cond, "error")
[13:36:37.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.132]                   NULL)
[13:36:37.132]                 if (is_error) {
[13:36:37.132]                   sessionInformation <- function() {
[13:36:37.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.132]                       search = base::search(), system = base::Sys.info())
[13:36:37.132]                   }
[13:36:37.132]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.132]                     cond$call), session = sessionInformation(), 
[13:36:37.132]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.132]                   signalCondition(cond)
[13:36:37.132]                 }
[13:36:37.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.132]                 "immediateCondition"))) {
[13:36:37.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.132]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.132]                   if (TRUE && !signal) {
[13:36:37.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.132]                     {
[13:36:37.132]                       inherits <- base::inherits
[13:36:37.132]                       invokeRestart <- base::invokeRestart
[13:36:37.132]                       is.null <- base::is.null
[13:36:37.132]                       muffled <- FALSE
[13:36:37.132]                       if (inherits(cond, "message")) {
[13:36:37.132]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.132]                         if (muffled) 
[13:36:37.132]                           invokeRestart("muffleMessage")
[13:36:37.132]                       }
[13:36:37.132]                       else if (inherits(cond, "warning")) {
[13:36:37.132]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.132]                         if (muffled) 
[13:36:37.132]                           invokeRestart("muffleWarning")
[13:36:37.132]                       }
[13:36:37.132]                       else if (inherits(cond, "condition")) {
[13:36:37.132]                         if (!is.null(pattern)) {
[13:36:37.132]                           computeRestarts <- base::computeRestarts
[13:36:37.132]                           grepl <- base::grepl
[13:36:37.132]                           restarts <- computeRestarts(cond)
[13:36:37.132]                           for (restart in restarts) {
[13:36:37.132]                             name <- restart$name
[13:36:37.132]                             if (is.null(name)) 
[13:36:37.132]                               next
[13:36:37.132]                             if (!grepl(pattern, name)) 
[13:36:37.132]                               next
[13:36:37.132]                             invokeRestart(restart)
[13:36:37.132]                             muffled <- TRUE
[13:36:37.132]                             break
[13:36:37.132]                           }
[13:36:37.132]                         }
[13:36:37.132]                       }
[13:36:37.132]                       invisible(muffled)
[13:36:37.132]                     }
[13:36:37.132]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.132]                   }
[13:36:37.132]                 }
[13:36:37.132]                 else {
[13:36:37.132]                   if (TRUE) {
[13:36:37.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.132]                     {
[13:36:37.132]                       inherits <- base::inherits
[13:36:37.132]                       invokeRestart <- base::invokeRestart
[13:36:37.132]                       is.null <- base::is.null
[13:36:37.132]                       muffled <- FALSE
[13:36:37.132]                       if (inherits(cond, "message")) {
[13:36:37.132]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.132]                         if (muffled) 
[13:36:37.132]                           invokeRestart("muffleMessage")
[13:36:37.132]                       }
[13:36:37.132]                       else if (inherits(cond, "warning")) {
[13:36:37.132]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.132]                         if (muffled) 
[13:36:37.132]                           invokeRestart("muffleWarning")
[13:36:37.132]                       }
[13:36:37.132]                       else if (inherits(cond, "condition")) {
[13:36:37.132]                         if (!is.null(pattern)) {
[13:36:37.132]                           computeRestarts <- base::computeRestarts
[13:36:37.132]                           grepl <- base::grepl
[13:36:37.132]                           restarts <- computeRestarts(cond)
[13:36:37.132]                           for (restart in restarts) {
[13:36:37.132]                             name <- restart$name
[13:36:37.132]                             if (is.null(name)) 
[13:36:37.132]                               next
[13:36:37.132]                             if (!grepl(pattern, name)) 
[13:36:37.132]                               next
[13:36:37.132]                             invokeRestart(restart)
[13:36:37.132]                             muffled <- TRUE
[13:36:37.132]                             break
[13:36:37.132]                           }
[13:36:37.132]                         }
[13:36:37.132]                       }
[13:36:37.132]                       invisible(muffled)
[13:36:37.132]                     }
[13:36:37.132]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.132]                   }
[13:36:37.132]                 }
[13:36:37.132]             }
[13:36:37.132]         }))
[13:36:37.132]     }, error = function(ex) {
[13:36:37.132]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.132]                 ...future.rng), started = ...future.startTime, 
[13:36:37.132]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.132]             version = "1.8"), class = "FutureResult")
[13:36:37.132]     }, finally = {
[13:36:37.132]         if (!identical(...future.workdir, getwd())) 
[13:36:37.132]             setwd(...future.workdir)
[13:36:37.132]         {
[13:36:37.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.132]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.132]             }
[13:36:37.132]             base::options(...future.oldOptions)
[13:36:37.132]             if (.Platform$OS.type == "windows") {
[13:36:37.132]                 old_names <- names(...future.oldEnvVars)
[13:36:37.132]                 envs <- base::Sys.getenv()
[13:36:37.132]                 names <- names(envs)
[13:36:37.132]                 common <- intersect(names, old_names)
[13:36:37.132]                 added <- setdiff(names, old_names)
[13:36:37.132]                 removed <- setdiff(old_names, names)
[13:36:37.132]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.132]                   envs[common]]
[13:36:37.132]                 NAMES <- toupper(changed)
[13:36:37.132]                 args <- list()
[13:36:37.132]                 for (kk in seq_along(NAMES)) {
[13:36:37.132]                   name <- changed[[kk]]
[13:36:37.132]                   NAME <- NAMES[[kk]]
[13:36:37.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.132]                     next
[13:36:37.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.132]                 }
[13:36:37.132]                 NAMES <- toupper(added)
[13:36:37.132]                 for (kk in seq_along(NAMES)) {
[13:36:37.132]                   name <- added[[kk]]
[13:36:37.132]                   NAME <- NAMES[[kk]]
[13:36:37.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.132]                     next
[13:36:37.132]                   args[[name]] <- ""
[13:36:37.132]                 }
[13:36:37.132]                 NAMES <- toupper(removed)
[13:36:37.132]                 for (kk in seq_along(NAMES)) {
[13:36:37.132]                   name <- removed[[kk]]
[13:36:37.132]                   NAME <- NAMES[[kk]]
[13:36:37.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.132]                     next
[13:36:37.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.132]                 }
[13:36:37.132]                 if (length(args) > 0) 
[13:36:37.132]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.132]             }
[13:36:37.132]             else {
[13:36:37.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.132]             }
[13:36:37.132]             {
[13:36:37.132]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.132]                   0L) {
[13:36:37.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.132]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.132]                   base::options(opts)
[13:36:37.132]                 }
[13:36:37.132]                 {
[13:36:37.132]                   {
[13:36:37.132]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.132]                     NULL
[13:36:37.132]                   }
[13:36:37.132]                   options(future.plan = NULL)
[13:36:37.132]                   if (is.na(NA_character_)) 
[13:36:37.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.132]                     .init = FALSE)
[13:36:37.132]                 }
[13:36:37.132]             }
[13:36:37.132]         }
[13:36:37.132]     })
[13:36:37.132]     if (TRUE) {
[13:36:37.132]         base::sink(type = "output", split = FALSE)
[13:36:37.132]         if (TRUE) {
[13:36:37.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.132]         }
[13:36:37.132]         else {
[13:36:37.132]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.132]         }
[13:36:37.132]         base::close(...future.stdout)
[13:36:37.132]         ...future.stdout <- NULL
[13:36:37.132]     }
[13:36:37.132]     ...future.result$conditions <- ...future.conditions
[13:36:37.132]     ...future.result$finished <- base::Sys.time()
[13:36:37.132]     ...future.result
[13:36:37.132] }
[13:36:37.135] MultisessionFuture started
[13:36:37.135] - Launch lazy future ... done
[13:36:37.135] run() for ‘MultisessionFuture’ ... done
[13:36:37.136] getGlobalsAndPackages() ...
[13:36:37.136] Searching for globals...
[13:36:37.136] - globals found: [1] ‘{’
[13:36:37.136] Searching for globals ... DONE
[13:36:37.137] Resolving globals: FALSE
[13:36:37.137] 
[13:36:37.137] 
[13:36:37.137] getGlobalsAndPackages() ... DONE
[13:36:37.137] run() for ‘Future’ ...
[13:36:37.137] - state: ‘created’
[13:36:37.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.151] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.151]   - Field: ‘node’
[13:36:37.151]   - Field: ‘label’
[13:36:37.151]   - Field: ‘local’
[13:36:37.151]   - Field: ‘owner’
[13:36:37.151]   - Field: ‘envir’
[13:36:37.151]   - Field: ‘workers’
[13:36:37.152]   - Field: ‘packages’
[13:36:37.152]   - Field: ‘gc’
[13:36:37.152]   - Field: ‘conditions’
[13:36:37.152]   - Field: ‘persistent’
[13:36:37.152]   - Field: ‘expr’
[13:36:37.152]   - Field: ‘uuid’
[13:36:37.152]   - Field: ‘seed’
[13:36:37.152]   - Field: ‘version’
[13:36:37.152]   - Field: ‘result’
[13:36:37.152]   - Field: ‘asynchronous’
[13:36:37.153]   - Field: ‘calls’
[13:36:37.153]   - Field: ‘globals’
[13:36:37.153]   - Field: ‘stdout’
[13:36:37.153]   - Field: ‘earlySignal’
[13:36:37.153]   - Field: ‘lazy’
[13:36:37.153]   - Field: ‘state’
[13:36:37.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.153] - Launch lazy future ...
[13:36:37.153] Packages needed by the future expression (n = 0): <none>
[13:36:37.154] Packages needed by future strategies (n = 0): <none>
[13:36:37.154] {
[13:36:37.154]     {
[13:36:37.154]         {
[13:36:37.154]             ...future.startTime <- base::Sys.time()
[13:36:37.154]             {
[13:36:37.154]                 {
[13:36:37.154]                   {
[13:36:37.154]                     {
[13:36:37.154]                       base::local({
[13:36:37.154]                         has_future <- base::requireNamespace("future", 
[13:36:37.154]                           quietly = TRUE)
[13:36:37.154]                         if (has_future) {
[13:36:37.154]                           ns <- base::getNamespace("future")
[13:36:37.154]                           version <- ns[[".package"]][["version"]]
[13:36:37.154]                           if (is.null(version)) 
[13:36:37.154]                             version <- utils::packageVersion("future")
[13:36:37.154]                         }
[13:36:37.154]                         else {
[13:36:37.154]                           version <- NULL
[13:36:37.154]                         }
[13:36:37.154]                         if (!has_future || version < "1.8.0") {
[13:36:37.154]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.154]                             "", base::R.version$version.string), 
[13:36:37.154]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.154]                               "release", "version")], collapse = " "), 
[13:36:37.154]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.154]                             info)
[13:36:37.154]                           info <- base::paste(info, collapse = "; ")
[13:36:37.154]                           if (!has_future) {
[13:36:37.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.154]                               info)
[13:36:37.154]                           }
[13:36:37.154]                           else {
[13:36:37.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.154]                               info, version)
[13:36:37.154]                           }
[13:36:37.154]                           base::stop(msg)
[13:36:37.154]                         }
[13:36:37.154]                       })
[13:36:37.154]                     }
[13:36:37.154]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.154]                     base::options(mc.cores = 1L)
[13:36:37.154]                   }
[13:36:37.154]                   ...future.strategy.old <- future::plan("list")
[13:36:37.154]                   options(future.plan = NULL)
[13:36:37.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.154]                 }
[13:36:37.154]                 ...future.workdir <- getwd()
[13:36:37.154]             }
[13:36:37.154]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.154]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.154]         }
[13:36:37.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.154]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.154]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.154]             base::names(...future.oldOptions))
[13:36:37.154]     }
[13:36:37.154]     if (FALSE) {
[13:36:37.154]     }
[13:36:37.154]     else {
[13:36:37.154]         if (TRUE) {
[13:36:37.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.154]                 open = "w")
[13:36:37.154]         }
[13:36:37.154]         else {
[13:36:37.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.154]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.154]         }
[13:36:37.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.154]             base::sink(type = "output", split = FALSE)
[13:36:37.154]             base::close(...future.stdout)
[13:36:37.154]         }, add = TRUE)
[13:36:37.154]     }
[13:36:37.154]     ...future.frame <- base::sys.nframe()
[13:36:37.154]     ...future.conditions <- base::list()
[13:36:37.154]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.154]     if (FALSE) {
[13:36:37.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.154]     }
[13:36:37.154]     ...future.result <- base::tryCatch({
[13:36:37.154]         base::withCallingHandlers({
[13:36:37.154]             ...future.value <- base::withVisible(base::local({
[13:36:37.154]                 ...future.makeSendCondition <- base::local({
[13:36:37.154]                   sendCondition <- NULL
[13:36:37.154]                   function(frame = 1L) {
[13:36:37.154]                     if (is.function(sendCondition)) 
[13:36:37.154]                       return(sendCondition)
[13:36:37.154]                     ns <- getNamespace("parallel")
[13:36:37.154]                     if (exists("sendData", mode = "function", 
[13:36:37.154]                       envir = ns)) {
[13:36:37.154]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.154]                         envir = ns)
[13:36:37.154]                       envir <- sys.frame(frame)
[13:36:37.154]                       master <- NULL
[13:36:37.154]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.154]                         !identical(envir, emptyenv())) {
[13:36:37.154]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.154]                           inherits = FALSE)) {
[13:36:37.154]                           master <- get("master", mode = "list", 
[13:36:37.154]                             envir = envir, inherits = FALSE)
[13:36:37.154]                           if (inherits(master, c("SOCKnode", 
[13:36:37.154]                             "SOCK0node"))) {
[13:36:37.154]                             sendCondition <<- function(cond) {
[13:36:37.154]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.154]                                 success = TRUE)
[13:36:37.154]                               parallel_sendData(master, data)
[13:36:37.154]                             }
[13:36:37.154]                             return(sendCondition)
[13:36:37.154]                           }
[13:36:37.154]                         }
[13:36:37.154]                         frame <- frame + 1L
[13:36:37.154]                         envir <- sys.frame(frame)
[13:36:37.154]                       }
[13:36:37.154]                     }
[13:36:37.154]                     sendCondition <<- function(cond) NULL
[13:36:37.154]                   }
[13:36:37.154]                 })
[13:36:37.154]                 withCallingHandlers({
[13:36:37.154]                   {
[13:36:37.154]                     4
[13:36:37.154]                   }
[13:36:37.154]                 }, immediateCondition = function(cond) {
[13:36:37.154]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.154]                   sendCondition(cond)
[13:36:37.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.154]                   {
[13:36:37.154]                     inherits <- base::inherits
[13:36:37.154]                     invokeRestart <- base::invokeRestart
[13:36:37.154]                     is.null <- base::is.null
[13:36:37.154]                     muffled <- FALSE
[13:36:37.154]                     if (inherits(cond, "message")) {
[13:36:37.154]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.154]                       if (muffled) 
[13:36:37.154]                         invokeRestart("muffleMessage")
[13:36:37.154]                     }
[13:36:37.154]                     else if (inherits(cond, "warning")) {
[13:36:37.154]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.154]                       if (muffled) 
[13:36:37.154]                         invokeRestart("muffleWarning")
[13:36:37.154]                     }
[13:36:37.154]                     else if (inherits(cond, "condition")) {
[13:36:37.154]                       if (!is.null(pattern)) {
[13:36:37.154]                         computeRestarts <- base::computeRestarts
[13:36:37.154]                         grepl <- base::grepl
[13:36:37.154]                         restarts <- computeRestarts(cond)
[13:36:37.154]                         for (restart in restarts) {
[13:36:37.154]                           name <- restart$name
[13:36:37.154]                           if (is.null(name)) 
[13:36:37.154]                             next
[13:36:37.154]                           if (!grepl(pattern, name)) 
[13:36:37.154]                             next
[13:36:37.154]                           invokeRestart(restart)
[13:36:37.154]                           muffled <- TRUE
[13:36:37.154]                           break
[13:36:37.154]                         }
[13:36:37.154]                       }
[13:36:37.154]                     }
[13:36:37.154]                     invisible(muffled)
[13:36:37.154]                   }
[13:36:37.154]                   muffleCondition(cond)
[13:36:37.154]                 })
[13:36:37.154]             }))
[13:36:37.154]             future::FutureResult(value = ...future.value$value, 
[13:36:37.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.154]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.154]                     ...future.globalenv.names))
[13:36:37.154]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.154]         }, condition = base::local({
[13:36:37.154]             c <- base::c
[13:36:37.154]             inherits <- base::inherits
[13:36:37.154]             invokeRestart <- base::invokeRestart
[13:36:37.154]             length <- base::length
[13:36:37.154]             list <- base::list
[13:36:37.154]             seq.int <- base::seq.int
[13:36:37.154]             signalCondition <- base::signalCondition
[13:36:37.154]             sys.calls <- base::sys.calls
[13:36:37.154]             `[[` <- base::`[[`
[13:36:37.154]             `+` <- base::`+`
[13:36:37.154]             `<<-` <- base::`<<-`
[13:36:37.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.154]                   3L)]
[13:36:37.154]             }
[13:36:37.154]             function(cond) {
[13:36:37.154]                 is_error <- inherits(cond, "error")
[13:36:37.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.154]                   NULL)
[13:36:37.154]                 if (is_error) {
[13:36:37.154]                   sessionInformation <- function() {
[13:36:37.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.154]                       search = base::search(), system = base::Sys.info())
[13:36:37.154]                   }
[13:36:37.154]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.154]                     cond$call), session = sessionInformation(), 
[13:36:37.154]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.154]                   signalCondition(cond)
[13:36:37.154]                 }
[13:36:37.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.154]                 "immediateCondition"))) {
[13:36:37.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.154]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.154]                   if (TRUE && !signal) {
[13:36:37.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.154]                     {
[13:36:37.154]                       inherits <- base::inherits
[13:36:37.154]                       invokeRestart <- base::invokeRestart
[13:36:37.154]                       is.null <- base::is.null
[13:36:37.154]                       muffled <- FALSE
[13:36:37.154]                       if (inherits(cond, "message")) {
[13:36:37.154]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.154]                         if (muffled) 
[13:36:37.154]                           invokeRestart("muffleMessage")
[13:36:37.154]                       }
[13:36:37.154]                       else if (inherits(cond, "warning")) {
[13:36:37.154]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.154]                         if (muffled) 
[13:36:37.154]                           invokeRestart("muffleWarning")
[13:36:37.154]                       }
[13:36:37.154]                       else if (inherits(cond, "condition")) {
[13:36:37.154]                         if (!is.null(pattern)) {
[13:36:37.154]                           computeRestarts <- base::computeRestarts
[13:36:37.154]                           grepl <- base::grepl
[13:36:37.154]                           restarts <- computeRestarts(cond)
[13:36:37.154]                           for (restart in restarts) {
[13:36:37.154]                             name <- restart$name
[13:36:37.154]                             if (is.null(name)) 
[13:36:37.154]                               next
[13:36:37.154]                             if (!grepl(pattern, name)) 
[13:36:37.154]                               next
[13:36:37.154]                             invokeRestart(restart)
[13:36:37.154]                             muffled <- TRUE
[13:36:37.154]                             break
[13:36:37.154]                           }
[13:36:37.154]                         }
[13:36:37.154]                       }
[13:36:37.154]                       invisible(muffled)
[13:36:37.154]                     }
[13:36:37.154]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.154]                   }
[13:36:37.154]                 }
[13:36:37.154]                 else {
[13:36:37.154]                   if (TRUE) {
[13:36:37.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.154]                     {
[13:36:37.154]                       inherits <- base::inherits
[13:36:37.154]                       invokeRestart <- base::invokeRestart
[13:36:37.154]                       is.null <- base::is.null
[13:36:37.154]                       muffled <- FALSE
[13:36:37.154]                       if (inherits(cond, "message")) {
[13:36:37.154]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.154]                         if (muffled) 
[13:36:37.154]                           invokeRestart("muffleMessage")
[13:36:37.154]                       }
[13:36:37.154]                       else if (inherits(cond, "warning")) {
[13:36:37.154]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.154]                         if (muffled) 
[13:36:37.154]                           invokeRestart("muffleWarning")
[13:36:37.154]                       }
[13:36:37.154]                       else if (inherits(cond, "condition")) {
[13:36:37.154]                         if (!is.null(pattern)) {
[13:36:37.154]                           computeRestarts <- base::computeRestarts
[13:36:37.154]                           grepl <- base::grepl
[13:36:37.154]                           restarts <- computeRestarts(cond)
[13:36:37.154]                           for (restart in restarts) {
[13:36:37.154]                             name <- restart$name
[13:36:37.154]                             if (is.null(name)) 
[13:36:37.154]                               next
[13:36:37.154]                             if (!grepl(pattern, name)) 
[13:36:37.154]                               next
[13:36:37.154]                             invokeRestart(restart)
[13:36:37.154]                             muffled <- TRUE
[13:36:37.154]                             break
[13:36:37.154]                           }
[13:36:37.154]                         }
[13:36:37.154]                       }
[13:36:37.154]                       invisible(muffled)
[13:36:37.154]                     }
[13:36:37.154]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.154]                   }
[13:36:37.154]                 }
[13:36:37.154]             }
[13:36:37.154]         }))
[13:36:37.154]     }, error = function(ex) {
[13:36:37.154]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.154]                 ...future.rng), started = ...future.startTime, 
[13:36:37.154]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.154]             version = "1.8"), class = "FutureResult")
[13:36:37.154]     }, finally = {
[13:36:37.154]         if (!identical(...future.workdir, getwd())) 
[13:36:37.154]             setwd(...future.workdir)
[13:36:37.154]         {
[13:36:37.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.154]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.154]             }
[13:36:37.154]             base::options(...future.oldOptions)
[13:36:37.154]             if (.Platform$OS.type == "windows") {
[13:36:37.154]                 old_names <- names(...future.oldEnvVars)
[13:36:37.154]                 envs <- base::Sys.getenv()
[13:36:37.154]                 names <- names(envs)
[13:36:37.154]                 common <- intersect(names, old_names)
[13:36:37.154]                 added <- setdiff(names, old_names)
[13:36:37.154]                 removed <- setdiff(old_names, names)
[13:36:37.154]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.154]                   envs[common]]
[13:36:37.154]                 NAMES <- toupper(changed)
[13:36:37.154]                 args <- list()
[13:36:37.154]                 for (kk in seq_along(NAMES)) {
[13:36:37.154]                   name <- changed[[kk]]
[13:36:37.154]                   NAME <- NAMES[[kk]]
[13:36:37.154]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.154]                     next
[13:36:37.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.154]                 }
[13:36:37.154]                 NAMES <- toupper(added)
[13:36:37.154]                 for (kk in seq_along(NAMES)) {
[13:36:37.154]                   name <- added[[kk]]
[13:36:37.154]                   NAME <- NAMES[[kk]]
[13:36:37.154]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.154]                     next
[13:36:37.154]                   args[[name]] <- ""
[13:36:37.154]                 }
[13:36:37.154]                 NAMES <- toupper(removed)
[13:36:37.154]                 for (kk in seq_along(NAMES)) {
[13:36:37.154]                   name <- removed[[kk]]
[13:36:37.154]                   NAME <- NAMES[[kk]]
[13:36:37.154]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.154]                     next
[13:36:37.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.154]                 }
[13:36:37.154]                 if (length(args) > 0) 
[13:36:37.154]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.154]             }
[13:36:37.154]             else {
[13:36:37.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.154]             }
[13:36:37.154]             {
[13:36:37.154]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.154]                   0L) {
[13:36:37.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.154]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.154]                   base::options(opts)
[13:36:37.154]                 }
[13:36:37.154]                 {
[13:36:37.154]                   {
[13:36:37.154]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.154]                     NULL
[13:36:37.154]                   }
[13:36:37.154]                   options(future.plan = NULL)
[13:36:37.154]                   if (is.na(NA_character_)) 
[13:36:37.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.154]                     .init = FALSE)
[13:36:37.154]                 }
[13:36:37.154]             }
[13:36:37.154]         }
[13:36:37.154]     })
[13:36:37.154]     if (TRUE) {
[13:36:37.154]         base::sink(type = "output", split = FALSE)
[13:36:37.154]         if (TRUE) {
[13:36:37.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.154]         }
[13:36:37.154]         else {
[13:36:37.154]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.154]         }
[13:36:37.154]         base::close(...future.stdout)
[13:36:37.154]         ...future.stdout <- NULL
[13:36:37.154]     }
[13:36:37.154]     ...future.result$conditions <- ...future.conditions
[13:36:37.154]     ...future.result$finished <- base::Sys.time()
[13:36:37.154]     ...future.result
[13:36:37.154] }
[13:36:37.156] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:37.167] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.167] - Validating connection of MultisessionFuture
[13:36:37.167] - received message: FutureResult
[13:36:37.167] - Received FutureResult
[13:36:37.167] - Erased future from FutureRegistry
[13:36:37.167] result() for ClusterFuture ...
[13:36:37.167] - result already collected: FutureResult
[13:36:37.168] result() for ClusterFuture ... done
[13:36:37.168] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.168] result() for ClusterFuture ...
[13:36:37.168] - result already collected: FutureResult
[13:36:37.168] result() for ClusterFuture ... done
[13:36:37.168] result() for ClusterFuture ...
[13:36:37.168] - result already collected: FutureResult
[13:36:37.168] result() for ClusterFuture ... done
[13:36:37.169] MultisessionFuture started
[13:36:37.169] - Launch lazy future ... done
[13:36:37.169] run() for ‘MultisessionFuture’ ... done
<environment: 0x564a74256128> 
<environment: 0x564a750254c8> 
[13:36:37.171] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.171] - Validating connection of MultisessionFuture
[13:36:37.171] - received message: FutureResult
[13:36:37.171] - Received FutureResult
[13:36:37.171] - Erased future from FutureRegistry
[13:36:37.171] result() for ClusterFuture ...
[13:36:37.172] - result already collected: FutureResult
[13:36:37.172] result() for ClusterFuture ... done
[13:36:37.172] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.172] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.172] - Validating connection of MultisessionFuture
[13:36:37.172] - received message: FutureResult
[13:36:37.173] - Received FutureResult
[13:36:37.173] - Erased future from FutureRegistry
[13:36:37.173] result() for ClusterFuture ...
[13:36:37.173] - result already collected: FutureResult
[13:36:37.173] result() for ClusterFuture ... done
[13:36:37.173] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:37.177] resolve() on environment ...
[13:36:37.177]  recursive: 0
[13:36:37.178]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:37.178] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.178] - nx: 4
[13:36:37.178] - relay: TRUE
[13:36:37.178] - stdout: TRUE
[13:36:37.178] - signal: TRUE
[13:36:37.178] - resignal: FALSE
[13:36:37.178] - force: TRUE
[13:36:37.178] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.179] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.179]  - until=2
[13:36:37.179]  - relaying element #2
[13:36:37.179] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.179] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.179] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.179]  length: 3 (resolved future 1)
[13:36:37.179] Future #2
[13:36:37.179] result() for ClusterFuture ...
[13:36:37.179] - result already collected: FutureResult
[13:36:37.179] result() for ClusterFuture ... done
[13:36:37.180] result() for ClusterFuture ...
[13:36:37.180] - result already collected: FutureResult
[13:36:37.180] result() for ClusterFuture ... done
[13:36:37.180] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:37.180] - nx: 4
[13:36:37.180] - relay: TRUE
[13:36:37.180] - stdout: TRUE
[13:36:37.180] - signal: TRUE
[13:36:37.180] - resignal: FALSE
[13:36:37.180] - force: TRUE
[13:36:37.180] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.180] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.181]  - until=2
[13:36:37.181]  - relaying element #2
[13:36:37.181] result() for ClusterFuture ...
[13:36:37.181] - result already collected: FutureResult
[13:36:37.181] result() for ClusterFuture ... done
[13:36:37.181] result() for ClusterFuture ...
[13:36:37.181] - result already collected: FutureResult
[13:36:37.181] result() for ClusterFuture ... done
[13:36:37.181] result() for ClusterFuture ...
[13:36:37.181] - result already collected: FutureResult
[13:36:37.181] result() for ClusterFuture ... done
[13:36:37.182] result() for ClusterFuture ...
[13:36:37.182] - result already collected: FutureResult
[13:36:37.182] result() for ClusterFuture ... done
[13:36:37.182] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.182] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.182] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:37.182]  length: 2 (resolved future 2)
[13:36:37.182] Future #3
[13:36:37.182] result() for ClusterFuture ...
[13:36:37.182] - result already collected: FutureResult
[13:36:37.183] result() for ClusterFuture ... done
[13:36:37.183] result() for ClusterFuture ...
[13:36:37.183] - result already collected: FutureResult
[13:36:37.183] result() for ClusterFuture ... done
[13:36:37.183] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:37.183] - nx: 4
[13:36:37.183] - relay: TRUE
[13:36:37.183] - stdout: TRUE
[13:36:37.183] - signal: TRUE
[13:36:37.183] - resignal: FALSE
[13:36:37.183] - force: TRUE
[13:36:37.183] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.184] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.184]  - until=3
[13:36:37.184]  - relaying element #3
[13:36:37.184] result() for ClusterFuture ...
[13:36:37.184] - result already collected: FutureResult
[13:36:37.184] result() for ClusterFuture ... done
[13:36:37.184] result() for ClusterFuture ...
[13:36:37.184] - result already collected: FutureResult
[13:36:37.184] result() for ClusterFuture ... done
[13:36:37.184] result() for ClusterFuture ...
[13:36:37.184] - result already collected: FutureResult
[13:36:37.184] result() for ClusterFuture ... done
[13:36:37.185] result() for ClusterFuture ...
[13:36:37.185] - result already collected: FutureResult
[13:36:37.185] result() for ClusterFuture ... done
[13:36:37.185] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.185] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.185] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:37.185]  length: 1 (resolved future 3)
[13:36:37.185] Future #4
[13:36:37.185] result() for ClusterFuture ...
[13:36:37.185] - result already collected: FutureResult
[13:36:37.185] result() for ClusterFuture ... done
[13:36:37.186] result() for ClusterFuture ...
[13:36:37.186] - result already collected: FutureResult
[13:36:37.186] result() for ClusterFuture ... done
[13:36:37.186] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:37.186] - nx: 4
[13:36:37.186] - relay: TRUE
[13:36:37.186] - stdout: TRUE
[13:36:37.186] - signal: TRUE
[13:36:37.186] - resignal: FALSE
[13:36:37.186] - force: TRUE
[13:36:37.186] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.186] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.187]  - until=4
[13:36:37.187]  - relaying element #4
[13:36:37.187] result() for ClusterFuture ...
[13:36:37.187] - result already collected: FutureResult
[13:36:37.187] result() for ClusterFuture ... done
[13:36:37.187] result() for ClusterFuture ...
[13:36:37.187] - result already collected: FutureResult
[13:36:37.187] result() for ClusterFuture ... done
[13:36:37.187] result() for ClusterFuture ...
[13:36:37.187] - result already collected: FutureResult
[13:36:37.187] result() for ClusterFuture ... done
[13:36:37.188] result() for ClusterFuture ...
[13:36:37.188] - result already collected: FutureResult
[13:36:37.188] result() for ClusterFuture ... done
[13:36:37.188] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.188] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.188] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:37.188]  length: 0 (resolved future 4)
[13:36:37.188] Relaying remaining futures
[13:36:37.188] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.188] - nx: 4
[13:36:37.188] - relay: TRUE
[13:36:37.189] - stdout: TRUE
[13:36:37.189] - signal: TRUE
[13:36:37.189] - resignal: FALSE
[13:36:37.189] - force: TRUE
[13:36:37.189] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.189] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:37.189] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.189] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.189] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.189] resolve() on environment ... DONE
[13:36:37.189] result() for ClusterFuture ...
[13:36:37.190] - result already collected: FutureResult
[13:36:37.190] result() for ClusterFuture ... done
[13:36:37.190] result() for ClusterFuture ...
[13:36:37.190] - result already collected: FutureResult
[13:36:37.190] result() for ClusterFuture ... done
[13:36:37.190] result() for ClusterFuture ...
[13:36:37.190] - result already collected: FutureResult
[13:36:37.190] result() for ClusterFuture ... done
[13:36:37.190] result() for ClusterFuture ...
[13:36:37.190] - result already collected: FutureResult
[13:36:37.190] result() for ClusterFuture ... done
[13:36:37.191] result() for ClusterFuture ...
[13:36:37.191] - result already collected: FutureResult
[13:36:37.191] result() for ClusterFuture ... done
[13:36:37.191] result() for ClusterFuture ...
[13:36:37.191] - result already collected: FutureResult
[13:36:37.191] result() for ClusterFuture ... done
<environment: 0x564a75331428> 
Dimensions: c(2, 3, 1)
[13:36:37.191] getGlobalsAndPackages() ...
[13:36:37.191] Searching for globals...
[13:36:37.192] 
[13:36:37.192] Searching for globals ... DONE
[13:36:37.192] - globals: [0] <none>
[13:36:37.192] getGlobalsAndPackages() ... DONE
[13:36:37.192] run() for ‘Future’ ...
[13:36:37.192] - state: ‘created’
[13:36:37.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.207]   - Field: ‘node’
[13:36:37.207]   - Field: ‘label’
[13:36:37.207]   - Field: ‘local’
[13:36:37.207]   - Field: ‘owner’
[13:36:37.208]   - Field: ‘envir’
[13:36:37.208]   - Field: ‘workers’
[13:36:37.208]   - Field: ‘packages’
[13:36:37.208]   - Field: ‘gc’
[13:36:37.208]   - Field: ‘conditions’
[13:36:37.208]   - Field: ‘persistent’
[13:36:37.208]   - Field: ‘expr’
[13:36:37.208]   - Field: ‘uuid’
[13:36:37.208]   - Field: ‘seed’
[13:36:37.208]   - Field: ‘version’
[13:36:37.208]   - Field: ‘result’
[13:36:37.209]   - Field: ‘asynchronous’
[13:36:37.209]   - Field: ‘calls’
[13:36:37.209]   - Field: ‘globals’
[13:36:37.209]   - Field: ‘stdout’
[13:36:37.209]   - Field: ‘earlySignal’
[13:36:37.209]   - Field: ‘lazy’
[13:36:37.209]   - Field: ‘state’
[13:36:37.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.209] - Launch lazy future ...
[13:36:37.209] Packages needed by the future expression (n = 0): <none>
[13:36:37.210] Packages needed by future strategies (n = 0): <none>
[13:36:37.210] {
[13:36:37.210]     {
[13:36:37.210]         {
[13:36:37.210]             ...future.startTime <- base::Sys.time()
[13:36:37.210]             {
[13:36:37.210]                 {
[13:36:37.210]                   {
[13:36:37.210]                     {
[13:36:37.210]                       base::local({
[13:36:37.210]                         has_future <- base::requireNamespace("future", 
[13:36:37.210]                           quietly = TRUE)
[13:36:37.210]                         if (has_future) {
[13:36:37.210]                           ns <- base::getNamespace("future")
[13:36:37.210]                           version <- ns[[".package"]][["version"]]
[13:36:37.210]                           if (is.null(version)) 
[13:36:37.210]                             version <- utils::packageVersion("future")
[13:36:37.210]                         }
[13:36:37.210]                         else {
[13:36:37.210]                           version <- NULL
[13:36:37.210]                         }
[13:36:37.210]                         if (!has_future || version < "1.8.0") {
[13:36:37.210]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.210]                             "", base::R.version$version.string), 
[13:36:37.210]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.210]                               "release", "version")], collapse = " "), 
[13:36:37.210]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.210]                             info)
[13:36:37.210]                           info <- base::paste(info, collapse = "; ")
[13:36:37.210]                           if (!has_future) {
[13:36:37.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.210]                               info)
[13:36:37.210]                           }
[13:36:37.210]                           else {
[13:36:37.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.210]                               info, version)
[13:36:37.210]                           }
[13:36:37.210]                           base::stop(msg)
[13:36:37.210]                         }
[13:36:37.210]                       })
[13:36:37.210]                     }
[13:36:37.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.210]                     base::options(mc.cores = 1L)
[13:36:37.210]                   }
[13:36:37.210]                   ...future.strategy.old <- future::plan("list")
[13:36:37.210]                   options(future.plan = NULL)
[13:36:37.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.210]                 }
[13:36:37.210]                 ...future.workdir <- getwd()
[13:36:37.210]             }
[13:36:37.210]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.210]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.210]         }
[13:36:37.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.210]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.210]             base::names(...future.oldOptions))
[13:36:37.210]     }
[13:36:37.210]     if (FALSE) {
[13:36:37.210]     }
[13:36:37.210]     else {
[13:36:37.210]         if (TRUE) {
[13:36:37.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.210]                 open = "w")
[13:36:37.210]         }
[13:36:37.210]         else {
[13:36:37.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.210]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.210]         }
[13:36:37.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.210]             base::sink(type = "output", split = FALSE)
[13:36:37.210]             base::close(...future.stdout)
[13:36:37.210]         }, add = TRUE)
[13:36:37.210]     }
[13:36:37.210]     ...future.frame <- base::sys.nframe()
[13:36:37.210]     ...future.conditions <- base::list()
[13:36:37.210]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.210]     if (FALSE) {
[13:36:37.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.210]     }
[13:36:37.210]     ...future.result <- base::tryCatch({
[13:36:37.210]         base::withCallingHandlers({
[13:36:37.210]             ...future.value <- base::withVisible(base::local({
[13:36:37.210]                 ...future.makeSendCondition <- base::local({
[13:36:37.210]                   sendCondition <- NULL
[13:36:37.210]                   function(frame = 1L) {
[13:36:37.210]                     if (is.function(sendCondition)) 
[13:36:37.210]                       return(sendCondition)
[13:36:37.210]                     ns <- getNamespace("parallel")
[13:36:37.210]                     if (exists("sendData", mode = "function", 
[13:36:37.210]                       envir = ns)) {
[13:36:37.210]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.210]                         envir = ns)
[13:36:37.210]                       envir <- sys.frame(frame)
[13:36:37.210]                       master <- NULL
[13:36:37.210]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.210]                         !identical(envir, emptyenv())) {
[13:36:37.210]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.210]                           inherits = FALSE)) {
[13:36:37.210]                           master <- get("master", mode = "list", 
[13:36:37.210]                             envir = envir, inherits = FALSE)
[13:36:37.210]                           if (inherits(master, c("SOCKnode", 
[13:36:37.210]                             "SOCK0node"))) {
[13:36:37.210]                             sendCondition <<- function(cond) {
[13:36:37.210]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.210]                                 success = TRUE)
[13:36:37.210]                               parallel_sendData(master, data)
[13:36:37.210]                             }
[13:36:37.210]                             return(sendCondition)
[13:36:37.210]                           }
[13:36:37.210]                         }
[13:36:37.210]                         frame <- frame + 1L
[13:36:37.210]                         envir <- sys.frame(frame)
[13:36:37.210]                       }
[13:36:37.210]                     }
[13:36:37.210]                     sendCondition <<- function(cond) NULL
[13:36:37.210]                   }
[13:36:37.210]                 })
[13:36:37.210]                 withCallingHandlers({
[13:36:37.210]                   2
[13:36:37.210]                 }, immediateCondition = function(cond) {
[13:36:37.210]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.210]                   sendCondition(cond)
[13:36:37.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.210]                   {
[13:36:37.210]                     inherits <- base::inherits
[13:36:37.210]                     invokeRestart <- base::invokeRestart
[13:36:37.210]                     is.null <- base::is.null
[13:36:37.210]                     muffled <- FALSE
[13:36:37.210]                     if (inherits(cond, "message")) {
[13:36:37.210]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.210]                       if (muffled) 
[13:36:37.210]                         invokeRestart("muffleMessage")
[13:36:37.210]                     }
[13:36:37.210]                     else if (inherits(cond, "warning")) {
[13:36:37.210]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.210]                       if (muffled) 
[13:36:37.210]                         invokeRestart("muffleWarning")
[13:36:37.210]                     }
[13:36:37.210]                     else if (inherits(cond, "condition")) {
[13:36:37.210]                       if (!is.null(pattern)) {
[13:36:37.210]                         computeRestarts <- base::computeRestarts
[13:36:37.210]                         grepl <- base::grepl
[13:36:37.210]                         restarts <- computeRestarts(cond)
[13:36:37.210]                         for (restart in restarts) {
[13:36:37.210]                           name <- restart$name
[13:36:37.210]                           if (is.null(name)) 
[13:36:37.210]                             next
[13:36:37.210]                           if (!grepl(pattern, name)) 
[13:36:37.210]                             next
[13:36:37.210]                           invokeRestart(restart)
[13:36:37.210]                           muffled <- TRUE
[13:36:37.210]                           break
[13:36:37.210]                         }
[13:36:37.210]                       }
[13:36:37.210]                     }
[13:36:37.210]                     invisible(muffled)
[13:36:37.210]                   }
[13:36:37.210]                   muffleCondition(cond)
[13:36:37.210]                 })
[13:36:37.210]             }))
[13:36:37.210]             future::FutureResult(value = ...future.value$value, 
[13:36:37.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.210]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.210]                     ...future.globalenv.names))
[13:36:37.210]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.210]         }, condition = base::local({
[13:36:37.210]             c <- base::c
[13:36:37.210]             inherits <- base::inherits
[13:36:37.210]             invokeRestart <- base::invokeRestart
[13:36:37.210]             length <- base::length
[13:36:37.210]             list <- base::list
[13:36:37.210]             seq.int <- base::seq.int
[13:36:37.210]             signalCondition <- base::signalCondition
[13:36:37.210]             sys.calls <- base::sys.calls
[13:36:37.210]             `[[` <- base::`[[`
[13:36:37.210]             `+` <- base::`+`
[13:36:37.210]             `<<-` <- base::`<<-`
[13:36:37.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.210]                   3L)]
[13:36:37.210]             }
[13:36:37.210]             function(cond) {
[13:36:37.210]                 is_error <- inherits(cond, "error")
[13:36:37.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.210]                   NULL)
[13:36:37.210]                 if (is_error) {
[13:36:37.210]                   sessionInformation <- function() {
[13:36:37.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.210]                       search = base::search(), system = base::Sys.info())
[13:36:37.210]                   }
[13:36:37.210]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.210]                     cond$call), session = sessionInformation(), 
[13:36:37.210]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.210]                   signalCondition(cond)
[13:36:37.210]                 }
[13:36:37.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.210]                 "immediateCondition"))) {
[13:36:37.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.210]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.210]                   if (TRUE && !signal) {
[13:36:37.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.210]                     {
[13:36:37.210]                       inherits <- base::inherits
[13:36:37.210]                       invokeRestart <- base::invokeRestart
[13:36:37.210]                       is.null <- base::is.null
[13:36:37.210]                       muffled <- FALSE
[13:36:37.210]                       if (inherits(cond, "message")) {
[13:36:37.210]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.210]                         if (muffled) 
[13:36:37.210]                           invokeRestart("muffleMessage")
[13:36:37.210]                       }
[13:36:37.210]                       else if (inherits(cond, "warning")) {
[13:36:37.210]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.210]                         if (muffled) 
[13:36:37.210]                           invokeRestart("muffleWarning")
[13:36:37.210]                       }
[13:36:37.210]                       else if (inherits(cond, "condition")) {
[13:36:37.210]                         if (!is.null(pattern)) {
[13:36:37.210]                           computeRestarts <- base::computeRestarts
[13:36:37.210]                           grepl <- base::grepl
[13:36:37.210]                           restarts <- computeRestarts(cond)
[13:36:37.210]                           for (restart in restarts) {
[13:36:37.210]                             name <- restart$name
[13:36:37.210]                             if (is.null(name)) 
[13:36:37.210]                               next
[13:36:37.210]                             if (!grepl(pattern, name)) 
[13:36:37.210]                               next
[13:36:37.210]                             invokeRestart(restart)
[13:36:37.210]                             muffled <- TRUE
[13:36:37.210]                             break
[13:36:37.210]                           }
[13:36:37.210]                         }
[13:36:37.210]                       }
[13:36:37.210]                       invisible(muffled)
[13:36:37.210]                     }
[13:36:37.210]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.210]                   }
[13:36:37.210]                 }
[13:36:37.210]                 else {
[13:36:37.210]                   if (TRUE) {
[13:36:37.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.210]                     {
[13:36:37.210]                       inherits <- base::inherits
[13:36:37.210]                       invokeRestart <- base::invokeRestart
[13:36:37.210]                       is.null <- base::is.null
[13:36:37.210]                       muffled <- FALSE
[13:36:37.210]                       if (inherits(cond, "message")) {
[13:36:37.210]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.210]                         if (muffled) 
[13:36:37.210]                           invokeRestart("muffleMessage")
[13:36:37.210]                       }
[13:36:37.210]                       else if (inherits(cond, "warning")) {
[13:36:37.210]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.210]                         if (muffled) 
[13:36:37.210]                           invokeRestart("muffleWarning")
[13:36:37.210]                       }
[13:36:37.210]                       else if (inherits(cond, "condition")) {
[13:36:37.210]                         if (!is.null(pattern)) {
[13:36:37.210]                           computeRestarts <- base::computeRestarts
[13:36:37.210]                           grepl <- base::grepl
[13:36:37.210]                           restarts <- computeRestarts(cond)
[13:36:37.210]                           for (restart in restarts) {
[13:36:37.210]                             name <- restart$name
[13:36:37.210]                             if (is.null(name)) 
[13:36:37.210]                               next
[13:36:37.210]                             if (!grepl(pattern, name)) 
[13:36:37.210]                               next
[13:36:37.210]                             invokeRestart(restart)
[13:36:37.210]                             muffled <- TRUE
[13:36:37.210]                             break
[13:36:37.210]                           }
[13:36:37.210]                         }
[13:36:37.210]                       }
[13:36:37.210]                       invisible(muffled)
[13:36:37.210]                     }
[13:36:37.210]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.210]                   }
[13:36:37.210]                 }
[13:36:37.210]             }
[13:36:37.210]         }))
[13:36:37.210]     }, error = function(ex) {
[13:36:37.210]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.210]                 ...future.rng), started = ...future.startTime, 
[13:36:37.210]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.210]             version = "1.8"), class = "FutureResult")
[13:36:37.210]     }, finally = {
[13:36:37.210]         if (!identical(...future.workdir, getwd())) 
[13:36:37.210]             setwd(...future.workdir)
[13:36:37.210]         {
[13:36:37.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.210]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.210]             }
[13:36:37.210]             base::options(...future.oldOptions)
[13:36:37.210]             if (.Platform$OS.type == "windows") {
[13:36:37.210]                 old_names <- names(...future.oldEnvVars)
[13:36:37.210]                 envs <- base::Sys.getenv()
[13:36:37.210]                 names <- names(envs)
[13:36:37.210]                 common <- intersect(names, old_names)
[13:36:37.210]                 added <- setdiff(names, old_names)
[13:36:37.210]                 removed <- setdiff(old_names, names)
[13:36:37.210]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.210]                   envs[common]]
[13:36:37.210]                 NAMES <- toupper(changed)
[13:36:37.210]                 args <- list()
[13:36:37.210]                 for (kk in seq_along(NAMES)) {
[13:36:37.210]                   name <- changed[[kk]]
[13:36:37.210]                   NAME <- NAMES[[kk]]
[13:36:37.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.210]                     next
[13:36:37.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.210]                 }
[13:36:37.210]                 NAMES <- toupper(added)
[13:36:37.210]                 for (kk in seq_along(NAMES)) {
[13:36:37.210]                   name <- added[[kk]]
[13:36:37.210]                   NAME <- NAMES[[kk]]
[13:36:37.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.210]                     next
[13:36:37.210]                   args[[name]] <- ""
[13:36:37.210]                 }
[13:36:37.210]                 NAMES <- toupper(removed)
[13:36:37.210]                 for (kk in seq_along(NAMES)) {
[13:36:37.210]                   name <- removed[[kk]]
[13:36:37.210]                   NAME <- NAMES[[kk]]
[13:36:37.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.210]                     next
[13:36:37.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.210]                 }
[13:36:37.210]                 if (length(args) > 0) 
[13:36:37.210]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.210]             }
[13:36:37.210]             else {
[13:36:37.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.210]             }
[13:36:37.210]             {
[13:36:37.210]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.210]                   0L) {
[13:36:37.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.210]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.210]                   base::options(opts)
[13:36:37.210]                 }
[13:36:37.210]                 {
[13:36:37.210]                   {
[13:36:37.210]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.210]                     NULL
[13:36:37.210]                   }
[13:36:37.210]                   options(future.plan = NULL)
[13:36:37.210]                   if (is.na(NA_character_)) 
[13:36:37.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.210]                     .init = FALSE)
[13:36:37.210]                 }
[13:36:37.210]             }
[13:36:37.210]         }
[13:36:37.210]     })
[13:36:37.210]     if (TRUE) {
[13:36:37.210]         base::sink(type = "output", split = FALSE)
[13:36:37.210]         if (TRUE) {
[13:36:37.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.210]         }
[13:36:37.210]         else {
[13:36:37.210]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.210]         }
[13:36:37.210]         base::close(...future.stdout)
[13:36:37.210]         ...future.stdout <- NULL
[13:36:37.210]     }
[13:36:37.210]     ...future.result$conditions <- ...future.conditions
[13:36:37.210]     ...future.result$finished <- base::Sys.time()
[13:36:37.210]     ...future.result
[13:36:37.210] }
[13:36:37.213] MultisessionFuture started
[13:36:37.213] - Launch lazy future ... done
[13:36:37.213] run() for ‘MultisessionFuture’ ... done
[13:36:37.213] getGlobalsAndPackages() ...
[13:36:37.213] Searching for globals...
[13:36:37.214] 
[13:36:37.214] Searching for globals ... DONE
[13:36:37.214] - globals: [0] <none>
[13:36:37.214] getGlobalsAndPackages() ... DONE
[13:36:37.214] run() for ‘Future’ ...
[13:36:37.214] - state: ‘created’
[13:36:37.214] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.228]   - Field: ‘node’
[13:36:37.228]   - Field: ‘label’
[13:36:37.228]   - Field: ‘local’
[13:36:37.228]   - Field: ‘owner’
[13:36:37.228]   - Field: ‘envir’
[13:36:37.229]   - Field: ‘workers’
[13:36:37.229]   - Field: ‘packages’
[13:36:37.229]   - Field: ‘gc’
[13:36:37.229]   - Field: ‘conditions’
[13:36:37.229]   - Field: ‘persistent’
[13:36:37.229]   - Field: ‘expr’
[13:36:37.229]   - Field: ‘uuid’
[13:36:37.229]   - Field: ‘seed’
[13:36:37.229]   - Field: ‘version’
[13:36:37.229]   - Field: ‘result’
[13:36:37.229]   - Field: ‘asynchronous’
[13:36:37.230]   - Field: ‘calls’
[13:36:37.230]   - Field: ‘globals’
[13:36:37.230]   - Field: ‘stdout’
[13:36:37.230]   - Field: ‘earlySignal’
[13:36:37.230]   - Field: ‘lazy’
[13:36:37.230]   - Field: ‘state’
[13:36:37.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.230] - Launch lazy future ...
[13:36:37.231] Packages needed by the future expression (n = 0): <none>
[13:36:37.231] Packages needed by future strategies (n = 0): <none>
[13:36:37.231] {
[13:36:37.231]     {
[13:36:37.231]         {
[13:36:37.231]             ...future.startTime <- base::Sys.time()
[13:36:37.231]             {
[13:36:37.231]                 {
[13:36:37.231]                   {
[13:36:37.231]                     {
[13:36:37.231]                       base::local({
[13:36:37.231]                         has_future <- base::requireNamespace("future", 
[13:36:37.231]                           quietly = TRUE)
[13:36:37.231]                         if (has_future) {
[13:36:37.231]                           ns <- base::getNamespace("future")
[13:36:37.231]                           version <- ns[[".package"]][["version"]]
[13:36:37.231]                           if (is.null(version)) 
[13:36:37.231]                             version <- utils::packageVersion("future")
[13:36:37.231]                         }
[13:36:37.231]                         else {
[13:36:37.231]                           version <- NULL
[13:36:37.231]                         }
[13:36:37.231]                         if (!has_future || version < "1.8.0") {
[13:36:37.231]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.231]                             "", base::R.version$version.string), 
[13:36:37.231]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.231]                               "release", "version")], collapse = " "), 
[13:36:37.231]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.231]                             info)
[13:36:37.231]                           info <- base::paste(info, collapse = "; ")
[13:36:37.231]                           if (!has_future) {
[13:36:37.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.231]                               info)
[13:36:37.231]                           }
[13:36:37.231]                           else {
[13:36:37.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.231]                               info, version)
[13:36:37.231]                           }
[13:36:37.231]                           base::stop(msg)
[13:36:37.231]                         }
[13:36:37.231]                       })
[13:36:37.231]                     }
[13:36:37.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.231]                     base::options(mc.cores = 1L)
[13:36:37.231]                   }
[13:36:37.231]                   ...future.strategy.old <- future::plan("list")
[13:36:37.231]                   options(future.plan = NULL)
[13:36:37.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.231]                 }
[13:36:37.231]                 ...future.workdir <- getwd()
[13:36:37.231]             }
[13:36:37.231]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.231]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.231]         }
[13:36:37.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.231]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.231]             base::names(...future.oldOptions))
[13:36:37.231]     }
[13:36:37.231]     if (FALSE) {
[13:36:37.231]     }
[13:36:37.231]     else {
[13:36:37.231]         if (TRUE) {
[13:36:37.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.231]                 open = "w")
[13:36:37.231]         }
[13:36:37.231]         else {
[13:36:37.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.231]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.231]         }
[13:36:37.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.231]             base::sink(type = "output", split = FALSE)
[13:36:37.231]             base::close(...future.stdout)
[13:36:37.231]         }, add = TRUE)
[13:36:37.231]     }
[13:36:37.231]     ...future.frame <- base::sys.nframe()
[13:36:37.231]     ...future.conditions <- base::list()
[13:36:37.231]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.231]     if (FALSE) {
[13:36:37.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.231]     }
[13:36:37.231]     ...future.result <- base::tryCatch({
[13:36:37.231]         base::withCallingHandlers({
[13:36:37.231]             ...future.value <- base::withVisible(base::local({
[13:36:37.231]                 ...future.makeSendCondition <- base::local({
[13:36:37.231]                   sendCondition <- NULL
[13:36:37.231]                   function(frame = 1L) {
[13:36:37.231]                     if (is.function(sendCondition)) 
[13:36:37.231]                       return(sendCondition)
[13:36:37.231]                     ns <- getNamespace("parallel")
[13:36:37.231]                     if (exists("sendData", mode = "function", 
[13:36:37.231]                       envir = ns)) {
[13:36:37.231]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.231]                         envir = ns)
[13:36:37.231]                       envir <- sys.frame(frame)
[13:36:37.231]                       master <- NULL
[13:36:37.231]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.231]                         !identical(envir, emptyenv())) {
[13:36:37.231]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.231]                           inherits = FALSE)) {
[13:36:37.231]                           master <- get("master", mode = "list", 
[13:36:37.231]                             envir = envir, inherits = FALSE)
[13:36:37.231]                           if (inherits(master, c("SOCKnode", 
[13:36:37.231]                             "SOCK0node"))) {
[13:36:37.231]                             sendCondition <<- function(cond) {
[13:36:37.231]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.231]                                 success = TRUE)
[13:36:37.231]                               parallel_sendData(master, data)
[13:36:37.231]                             }
[13:36:37.231]                             return(sendCondition)
[13:36:37.231]                           }
[13:36:37.231]                         }
[13:36:37.231]                         frame <- frame + 1L
[13:36:37.231]                         envir <- sys.frame(frame)
[13:36:37.231]                       }
[13:36:37.231]                     }
[13:36:37.231]                     sendCondition <<- function(cond) NULL
[13:36:37.231]                   }
[13:36:37.231]                 })
[13:36:37.231]                 withCallingHandlers({
[13:36:37.231]                   NULL
[13:36:37.231]                 }, immediateCondition = function(cond) {
[13:36:37.231]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.231]                   sendCondition(cond)
[13:36:37.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.231]                   {
[13:36:37.231]                     inherits <- base::inherits
[13:36:37.231]                     invokeRestart <- base::invokeRestart
[13:36:37.231]                     is.null <- base::is.null
[13:36:37.231]                     muffled <- FALSE
[13:36:37.231]                     if (inherits(cond, "message")) {
[13:36:37.231]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.231]                       if (muffled) 
[13:36:37.231]                         invokeRestart("muffleMessage")
[13:36:37.231]                     }
[13:36:37.231]                     else if (inherits(cond, "warning")) {
[13:36:37.231]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.231]                       if (muffled) 
[13:36:37.231]                         invokeRestart("muffleWarning")
[13:36:37.231]                     }
[13:36:37.231]                     else if (inherits(cond, "condition")) {
[13:36:37.231]                       if (!is.null(pattern)) {
[13:36:37.231]                         computeRestarts <- base::computeRestarts
[13:36:37.231]                         grepl <- base::grepl
[13:36:37.231]                         restarts <- computeRestarts(cond)
[13:36:37.231]                         for (restart in restarts) {
[13:36:37.231]                           name <- restart$name
[13:36:37.231]                           if (is.null(name)) 
[13:36:37.231]                             next
[13:36:37.231]                           if (!grepl(pattern, name)) 
[13:36:37.231]                             next
[13:36:37.231]                           invokeRestart(restart)
[13:36:37.231]                           muffled <- TRUE
[13:36:37.231]                           break
[13:36:37.231]                         }
[13:36:37.231]                       }
[13:36:37.231]                     }
[13:36:37.231]                     invisible(muffled)
[13:36:37.231]                   }
[13:36:37.231]                   muffleCondition(cond)
[13:36:37.231]                 })
[13:36:37.231]             }))
[13:36:37.231]             future::FutureResult(value = ...future.value$value, 
[13:36:37.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.231]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.231]                     ...future.globalenv.names))
[13:36:37.231]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.231]         }, condition = base::local({
[13:36:37.231]             c <- base::c
[13:36:37.231]             inherits <- base::inherits
[13:36:37.231]             invokeRestart <- base::invokeRestart
[13:36:37.231]             length <- base::length
[13:36:37.231]             list <- base::list
[13:36:37.231]             seq.int <- base::seq.int
[13:36:37.231]             signalCondition <- base::signalCondition
[13:36:37.231]             sys.calls <- base::sys.calls
[13:36:37.231]             `[[` <- base::`[[`
[13:36:37.231]             `+` <- base::`+`
[13:36:37.231]             `<<-` <- base::`<<-`
[13:36:37.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.231]                   3L)]
[13:36:37.231]             }
[13:36:37.231]             function(cond) {
[13:36:37.231]                 is_error <- inherits(cond, "error")
[13:36:37.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.231]                   NULL)
[13:36:37.231]                 if (is_error) {
[13:36:37.231]                   sessionInformation <- function() {
[13:36:37.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.231]                       search = base::search(), system = base::Sys.info())
[13:36:37.231]                   }
[13:36:37.231]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.231]                     cond$call), session = sessionInformation(), 
[13:36:37.231]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.231]                   signalCondition(cond)
[13:36:37.231]                 }
[13:36:37.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.231]                 "immediateCondition"))) {
[13:36:37.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.231]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.231]                   if (TRUE && !signal) {
[13:36:37.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.231]                     {
[13:36:37.231]                       inherits <- base::inherits
[13:36:37.231]                       invokeRestart <- base::invokeRestart
[13:36:37.231]                       is.null <- base::is.null
[13:36:37.231]                       muffled <- FALSE
[13:36:37.231]                       if (inherits(cond, "message")) {
[13:36:37.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.231]                         if (muffled) 
[13:36:37.231]                           invokeRestart("muffleMessage")
[13:36:37.231]                       }
[13:36:37.231]                       else if (inherits(cond, "warning")) {
[13:36:37.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.231]                         if (muffled) 
[13:36:37.231]                           invokeRestart("muffleWarning")
[13:36:37.231]                       }
[13:36:37.231]                       else if (inherits(cond, "condition")) {
[13:36:37.231]                         if (!is.null(pattern)) {
[13:36:37.231]                           computeRestarts <- base::computeRestarts
[13:36:37.231]                           grepl <- base::grepl
[13:36:37.231]                           restarts <- computeRestarts(cond)
[13:36:37.231]                           for (restart in restarts) {
[13:36:37.231]                             name <- restart$name
[13:36:37.231]                             if (is.null(name)) 
[13:36:37.231]                               next
[13:36:37.231]                             if (!grepl(pattern, name)) 
[13:36:37.231]                               next
[13:36:37.231]                             invokeRestart(restart)
[13:36:37.231]                             muffled <- TRUE
[13:36:37.231]                             break
[13:36:37.231]                           }
[13:36:37.231]                         }
[13:36:37.231]                       }
[13:36:37.231]                       invisible(muffled)
[13:36:37.231]                     }
[13:36:37.231]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.231]                   }
[13:36:37.231]                 }
[13:36:37.231]                 else {
[13:36:37.231]                   if (TRUE) {
[13:36:37.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.231]                     {
[13:36:37.231]                       inherits <- base::inherits
[13:36:37.231]                       invokeRestart <- base::invokeRestart
[13:36:37.231]                       is.null <- base::is.null
[13:36:37.231]                       muffled <- FALSE
[13:36:37.231]                       if (inherits(cond, "message")) {
[13:36:37.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.231]                         if (muffled) 
[13:36:37.231]                           invokeRestart("muffleMessage")
[13:36:37.231]                       }
[13:36:37.231]                       else if (inherits(cond, "warning")) {
[13:36:37.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.231]                         if (muffled) 
[13:36:37.231]                           invokeRestart("muffleWarning")
[13:36:37.231]                       }
[13:36:37.231]                       else if (inherits(cond, "condition")) {
[13:36:37.231]                         if (!is.null(pattern)) {
[13:36:37.231]                           computeRestarts <- base::computeRestarts
[13:36:37.231]                           grepl <- base::grepl
[13:36:37.231]                           restarts <- computeRestarts(cond)
[13:36:37.231]                           for (restart in restarts) {
[13:36:37.231]                             name <- restart$name
[13:36:37.231]                             if (is.null(name)) 
[13:36:37.231]                               next
[13:36:37.231]                             if (!grepl(pattern, name)) 
[13:36:37.231]                               next
[13:36:37.231]                             invokeRestart(restart)
[13:36:37.231]                             muffled <- TRUE
[13:36:37.231]                             break
[13:36:37.231]                           }
[13:36:37.231]                         }
[13:36:37.231]                       }
[13:36:37.231]                       invisible(muffled)
[13:36:37.231]                     }
[13:36:37.231]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.231]                   }
[13:36:37.231]                 }
[13:36:37.231]             }
[13:36:37.231]         }))
[13:36:37.231]     }, error = function(ex) {
[13:36:37.231]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.231]                 ...future.rng), started = ...future.startTime, 
[13:36:37.231]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.231]             version = "1.8"), class = "FutureResult")
[13:36:37.231]     }, finally = {
[13:36:37.231]         if (!identical(...future.workdir, getwd())) 
[13:36:37.231]             setwd(...future.workdir)
[13:36:37.231]         {
[13:36:37.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.231]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.231]             }
[13:36:37.231]             base::options(...future.oldOptions)
[13:36:37.231]             if (.Platform$OS.type == "windows") {
[13:36:37.231]                 old_names <- names(...future.oldEnvVars)
[13:36:37.231]                 envs <- base::Sys.getenv()
[13:36:37.231]                 names <- names(envs)
[13:36:37.231]                 common <- intersect(names, old_names)
[13:36:37.231]                 added <- setdiff(names, old_names)
[13:36:37.231]                 removed <- setdiff(old_names, names)
[13:36:37.231]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.231]                   envs[common]]
[13:36:37.231]                 NAMES <- toupper(changed)
[13:36:37.231]                 args <- list()
[13:36:37.231]                 for (kk in seq_along(NAMES)) {
[13:36:37.231]                   name <- changed[[kk]]
[13:36:37.231]                   NAME <- NAMES[[kk]]
[13:36:37.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.231]                     next
[13:36:37.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.231]                 }
[13:36:37.231]                 NAMES <- toupper(added)
[13:36:37.231]                 for (kk in seq_along(NAMES)) {
[13:36:37.231]                   name <- added[[kk]]
[13:36:37.231]                   NAME <- NAMES[[kk]]
[13:36:37.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.231]                     next
[13:36:37.231]                   args[[name]] <- ""
[13:36:37.231]                 }
[13:36:37.231]                 NAMES <- toupper(removed)
[13:36:37.231]                 for (kk in seq_along(NAMES)) {
[13:36:37.231]                   name <- removed[[kk]]
[13:36:37.231]                   NAME <- NAMES[[kk]]
[13:36:37.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.231]                     next
[13:36:37.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.231]                 }
[13:36:37.231]                 if (length(args) > 0) 
[13:36:37.231]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.231]             }
[13:36:37.231]             else {
[13:36:37.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.231]             }
[13:36:37.231]             {
[13:36:37.231]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.231]                   0L) {
[13:36:37.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.231]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.231]                   base::options(opts)
[13:36:37.231]                 }
[13:36:37.231]                 {
[13:36:37.231]                   {
[13:36:37.231]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.231]                     NULL
[13:36:37.231]                   }
[13:36:37.231]                   options(future.plan = NULL)
[13:36:37.231]                   if (is.na(NA_character_)) 
[13:36:37.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.231]                     .init = FALSE)
[13:36:37.231]                 }
[13:36:37.231]             }
[13:36:37.231]         }
[13:36:37.231]     })
[13:36:37.231]     if (TRUE) {
[13:36:37.231]         base::sink(type = "output", split = FALSE)
[13:36:37.231]         if (TRUE) {
[13:36:37.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.231]         }
[13:36:37.231]         else {
[13:36:37.231]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.231]         }
[13:36:37.231]         base::close(...future.stdout)
[13:36:37.231]         ...future.stdout <- NULL
[13:36:37.231]     }
[13:36:37.231]     ...future.result$conditions <- ...future.conditions
[13:36:37.231]     ...future.result$finished <- base::Sys.time()
[13:36:37.231]     ...future.result
[13:36:37.231] }
[13:36:37.234] MultisessionFuture started
[13:36:37.234] - Launch lazy future ... done
[13:36:37.234] run() for ‘MultisessionFuture’ ... done
[13:36:37.234] getGlobalsAndPackages() ...
[13:36:37.234] Searching for globals...
[13:36:37.235] - globals found: [1] ‘{’
[13:36:37.235] Searching for globals ... DONE
[13:36:37.235] Resolving globals: FALSE
[13:36:37.236] 
[13:36:37.236] 
[13:36:37.236] getGlobalsAndPackages() ... DONE
[13:36:37.236] run() for ‘Future’ ...
[13:36:37.236] - state: ‘created’
[13:36:37.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.250]   - Field: ‘node’
[13:36:37.250]   - Field: ‘label’
[13:36:37.250]   - Field: ‘local’
[13:36:37.250]   - Field: ‘owner’
[13:36:37.250]   - Field: ‘envir’
[13:36:37.250]   - Field: ‘workers’
[13:36:37.250]   - Field: ‘packages’
[13:36:37.250]   - Field: ‘gc’
[13:36:37.250]   - Field: ‘conditions’
[13:36:37.251]   - Field: ‘persistent’
[13:36:37.251]   - Field: ‘expr’
[13:36:37.251]   - Field: ‘uuid’
[13:36:37.251]   - Field: ‘seed’
[13:36:37.251]   - Field: ‘version’
[13:36:37.251]   - Field: ‘result’
[13:36:37.251]   - Field: ‘asynchronous’
[13:36:37.251]   - Field: ‘calls’
[13:36:37.251]   - Field: ‘globals’
[13:36:37.251]   - Field: ‘stdout’
[13:36:37.251]   - Field: ‘earlySignal’
[13:36:37.252]   - Field: ‘lazy’
[13:36:37.252]   - Field: ‘state’
[13:36:37.252] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.252] - Launch lazy future ...
[13:36:37.252] Packages needed by the future expression (n = 0): <none>
[13:36:37.252] Packages needed by future strategies (n = 0): <none>
[13:36:37.253] {
[13:36:37.253]     {
[13:36:37.253]         {
[13:36:37.253]             ...future.startTime <- base::Sys.time()
[13:36:37.253]             {
[13:36:37.253]                 {
[13:36:37.253]                   {
[13:36:37.253]                     {
[13:36:37.253]                       base::local({
[13:36:37.253]                         has_future <- base::requireNamespace("future", 
[13:36:37.253]                           quietly = TRUE)
[13:36:37.253]                         if (has_future) {
[13:36:37.253]                           ns <- base::getNamespace("future")
[13:36:37.253]                           version <- ns[[".package"]][["version"]]
[13:36:37.253]                           if (is.null(version)) 
[13:36:37.253]                             version <- utils::packageVersion("future")
[13:36:37.253]                         }
[13:36:37.253]                         else {
[13:36:37.253]                           version <- NULL
[13:36:37.253]                         }
[13:36:37.253]                         if (!has_future || version < "1.8.0") {
[13:36:37.253]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.253]                             "", base::R.version$version.string), 
[13:36:37.253]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.253]                               "release", "version")], collapse = " "), 
[13:36:37.253]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.253]                             info)
[13:36:37.253]                           info <- base::paste(info, collapse = "; ")
[13:36:37.253]                           if (!has_future) {
[13:36:37.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.253]                               info)
[13:36:37.253]                           }
[13:36:37.253]                           else {
[13:36:37.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.253]                               info, version)
[13:36:37.253]                           }
[13:36:37.253]                           base::stop(msg)
[13:36:37.253]                         }
[13:36:37.253]                       })
[13:36:37.253]                     }
[13:36:37.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.253]                     base::options(mc.cores = 1L)
[13:36:37.253]                   }
[13:36:37.253]                   ...future.strategy.old <- future::plan("list")
[13:36:37.253]                   options(future.plan = NULL)
[13:36:37.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.253]                 }
[13:36:37.253]                 ...future.workdir <- getwd()
[13:36:37.253]             }
[13:36:37.253]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.253]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.253]         }
[13:36:37.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.253]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.253]             base::names(...future.oldOptions))
[13:36:37.253]     }
[13:36:37.253]     if (FALSE) {
[13:36:37.253]     }
[13:36:37.253]     else {
[13:36:37.253]         if (TRUE) {
[13:36:37.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.253]                 open = "w")
[13:36:37.253]         }
[13:36:37.253]         else {
[13:36:37.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.253]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.253]         }
[13:36:37.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.253]             base::sink(type = "output", split = FALSE)
[13:36:37.253]             base::close(...future.stdout)
[13:36:37.253]         }, add = TRUE)
[13:36:37.253]     }
[13:36:37.253]     ...future.frame <- base::sys.nframe()
[13:36:37.253]     ...future.conditions <- base::list()
[13:36:37.253]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.253]     if (FALSE) {
[13:36:37.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.253]     }
[13:36:37.253]     ...future.result <- base::tryCatch({
[13:36:37.253]         base::withCallingHandlers({
[13:36:37.253]             ...future.value <- base::withVisible(base::local({
[13:36:37.253]                 ...future.makeSendCondition <- base::local({
[13:36:37.253]                   sendCondition <- NULL
[13:36:37.253]                   function(frame = 1L) {
[13:36:37.253]                     if (is.function(sendCondition)) 
[13:36:37.253]                       return(sendCondition)
[13:36:37.253]                     ns <- getNamespace("parallel")
[13:36:37.253]                     if (exists("sendData", mode = "function", 
[13:36:37.253]                       envir = ns)) {
[13:36:37.253]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.253]                         envir = ns)
[13:36:37.253]                       envir <- sys.frame(frame)
[13:36:37.253]                       master <- NULL
[13:36:37.253]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.253]                         !identical(envir, emptyenv())) {
[13:36:37.253]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.253]                           inherits = FALSE)) {
[13:36:37.253]                           master <- get("master", mode = "list", 
[13:36:37.253]                             envir = envir, inherits = FALSE)
[13:36:37.253]                           if (inherits(master, c("SOCKnode", 
[13:36:37.253]                             "SOCK0node"))) {
[13:36:37.253]                             sendCondition <<- function(cond) {
[13:36:37.253]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.253]                                 success = TRUE)
[13:36:37.253]                               parallel_sendData(master, data)
[13:36:37.253]                             }
[13:36:37.253]                             return(sendCondition)
[13:36:37.253]                           }
[13:36:37.253]                         }
[13:36:37.253]                         frame <- frame + 1L
[13:36:37.253]                         envir <- sys.frame(frame)
[13:36:37.253]                       }
[13:36:37.253]                     }
[13:36:37.253]                     sendCondition <<- function(cond) NULL
[13:36:37.253]                   }
[13:36:37.253]                 })
[13:36:37.253]                 withCallingHandlers({
[13:36:37.253]                   {
[13:36:37.253]                     4
[13:36:37.253]                   }
[13:36:37.253]                 }, immediateCondition = function(cond) {
[13:36:37.253]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.253]                   sendCondition(cond)
[13:36:37.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.253]                   {
[13:36:37.253]                     inherits <- base::inherits
[13:36:37.253]                     invokeRestart <- base::invokeRestart
[13:36:37.253]                     is.null <- base::is.null
[13:36:37.253]                     muffled <- FALSE
[13:36:37.253]                     if (inherits(cond, "message")) {
[13:36:37.253]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.253]                       if (muffled) 
[13:36:37.253]                         invokeRestart("muffleMessage")
[13:36:37.253]                     }
[13:36:37.253]                     else if (inherits(cond, "warning")) {
[13:36:37.253]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.253]                       if (muffled) 
[13:36:37.253]                         invokeRestart("muffleWarning")
[13:36:37.253]                     }
[13:36:37.253]                     else if (inherits(cond, "condition")) {
[13:36:37.253]                       if (!is.null(pattern)) {
[13:36:37.253]                         computeRestarts <- base::computeRestarts
[13:36:37.253]                         grepl <- base::grepl
[13:36:37.253]                         restarts <- computeRestarts(cond)
[13:36:37.253]                         for (restart in restarts) {
[13:36:37.253]                           name <- restart$name
[13:36:37.253]                           if (is.null(name)) 
[13:36:37.253]                             next
[13:36:37.253]                           if (!grepl(pattern, name)) 
[13:36:37.253]                             next
[13:36:37.253]                           invokeRestart(restart)
[13:36:37.253]                           muffled <- TRUE
[13:36:37.253]                           break
[13:36:37.253]                         }
[13:36:37.253]                       }
[13:36:37.253]                     }
[13:36:37.253]                     invisible(muffled)
[13:36:37.253]                   }
[13:36:37.253]                   muffleCondition(cond)
[13:36:37.253]                 })
[13:36:37.253]             }))
[13:36:37.253]             future::FutureResult(value = ...future.value$value, 
[13:36:37.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.253]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.253]                     ...future.globalenv.names))
[13:36:37.253]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.253]         }, condition = base::local({
[13:36:37.253]             c <- base::c
[13:36:37.253]             inherits <- base::inherits
[13:36:37.253]             invokeRestart <- base::invokeRestart
[13:36:37.253]             length <- base::length
[13:36:37.253]             list <- base::list
[13:36:37.253]             seq.int <- base::seq.int
[13:36:37.253]             signalCondition <- base::signalCondition
[13:36:37.253]             sys.calls <- base::sys.calls
[13:36:37.253]             `[[` <- base::`[[`
[13:36:37.253]             `+` <- base::`+`
[13:36:37.253]             `<<-` <- base::`<<-`
[13:36:37.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.253]                   3L)]
[13:36:37.253]             }
[13:36:37.253]             function(cond) {
[13:36:37.253]                 is_error <- inherits(cond, "error")
[13:36:37.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.253]                   NULL)
[13:36:37.253]                 if (is_error) {
[13:36:37.253]                   sessionInformation <- function() {
[13:36:37.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.253]                       search = base::search(), system = base::Sys.info())
[13:36:37.253]                   }
[13:36:37.253]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.253]                     cond$call), session = sessionInformation(), 
[13:36:37.253]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.253]                   signalCondition(cond)
[13:36:37.253]                 }
[13:36:37.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.253]                 "immediateCondition"))) {
[13:36:37.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.253]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.253]                   if (TRUE && !signal) {
[13:36:37.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.253]                     {
[13:36:37.253]                       inherits <- base::inherits
[13:36:37.253]                       invokeRestart <- base::invokeRestart
[13:36:37.253]                       is.null <- base::is.null
[13:36:37.253]                       muffled <- FALSE
[13:36:37.253]                       if (inherits(cond, "message")) {
[13:36:37.253]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.253]                         if (muffled) 
[13:36:37.253]                           invokeRestart("muffleMessage")
[13:36:37.253]                       }
[13:36:37.253]                       else if (inherits(cond, "warning")) {
[13:36:37.253]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.253]                         if (muffled) 
[13:36:37.253]                           invokeRestart("muffleWarning")
[13:36:37.253]                       }
[13:36:37.253]                       else if (inherits(cond, "condition")) {
[13:36:37.253]                         if (!is.null(pattern)) {
[13:36:37.253]                           computeRestarts <- base::computeRestarts
[13:36:37.253]                           grepl <- base::grepl
[13:36:37.253]                           restarts <- computeRestarts(cond)
[13:36:37.253]                           for (restart in restarts) {
[13:36:37.253]                             name <- restart$name
[13:36:37.253]                             if (is.null(name)) 
[13:36:37.253]                               next
[13:36:37.253]                             if (!grepl(pattern, name)) 
[13:36:37.253]                               next
[13:36:37.253]                             invokeRestart(restart)
[13:36:37.253]                             muffled <- TRUE
[13:36:37.253]                             break
[13:36:37.253]                           }
[13:36:37.253]                         }
[13:36:37.253]                       }
[13:36:37.253]                       invisible(muffled)
[13:36:37.253]                     }
[13:36:37.253]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.253]                   }
[13:36:37.253]                 }
[13:36:37.253]                 else {
[13:36:37.253]                   if (TRUE) {
[13:36:37.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.253]                     {
[13:36:37.253]                       inherits <- base::inherits
[13:36:37.253]                       invokeRestart <- base::invokeRestart
[13:36:37.253]                       is.null <- base::is.null
[13:36:37.253]                       muffled <- FALSE
[13:36:37.253]                       if (inherits(cond, "message")) {
[13:36:37.253]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.253]                         if (muffled) 
[13:36:37.253]                           invokeRestart("muffleMessage")
[13:36:37.253]                       }
[13:36:37.253]                       else if (inherits(cond, "warning")) {
[13:36:37.253]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.253]                         if (muffled) 
[13:36:37.253]                           invokeRestart("muffleWarning")
[13:36:37.253]                       }
[13:36:37.253]                       else if (inherits(cond, "condition")) {
[13:36:37.253]                         if (!is.null(pattern)) {
[13:36:37.253]                           computeRestarts <- base::computeRestarts
[13:36:37.253]                           grepl <- base::grepl
[13:36:37.253]                           restarts <- computeRestarts(cond)
[13:36:37.253]                           for (restart in restarts) {
[13:36:37.253]                             name <- restart$name
[13:36:37.253]                             if (is.null(name)) 
[13:36:37.253]                               next
[13:36:37.253]                             if (!grepl(pattern, name)) 
[13:36:37.253]                               next
[13:36:37.253]                             invokeRestart(restart)
[13:36:37.253]                             muffled <- TRUE
[13:36:37.253]                             break
[13:36:37.253]                           }
[13:36:37.253]                         }
[13:36:37.253]                       }
[13:36:37.253]                       invisible(muffled)
[13:36:37.253]                     }
[13:36:37.253]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.253]                   }
[13:36:37.253]                 }
[13:36:37.253]             }
[13:36:37.253]         }))
[13:36:37.253]     }, error = function(ex) {
[13:36:37.253]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.253]                 ...future.rng), started = ...future.startTime, 
[13:36:37.253]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.253]             version = "1.8"), class = "FutureResult")
[13:36:37.253]     }, finally = {
[13:36:37.253]         if (!identical(...future.workdir, getwd())) 
[13:36:37.253]             setwd(...future.workdir)
[13:36:37.253]         {
[13:36:37.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.253]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.253]             }
[13:36:37.253]             base::options(...future.oldOptions)
[13:36:37.253]             if (.Platform$OS.type == "windows") {
[13:36:37.253]                 old_names <- names(...future.oldEnvVars)
[13:36:37.253]                 envs <- base::Sys.getenv()
[13:36:37.253]                 names <- names(envs)
[13:36:37.253]                 common <- intersect(names, old_names)
[13:36:37.253]                 added <- setdiff(names, old_names)
[13:36:37.253]                 removed <- setdiff(old_names, names)
[13:36:37.253]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.253]                   envs[common]]
[13:36:37.253]                 NAMES <- toupper(changed)
[13:36:37.253]                 args <- list()
[13:36:37.253]                 for (kk in seq_along(NAMES)) {
[13:36:37.253]                   name <- changed[[kk]]
[13:36:37.253]                   NAME <- NAMES[[kk]]
[13:36:37.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.253]                     next
[13:36:37.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.253]                 }
[13:36:37.253]                 NAMES <- toupper(added)
[13:36:37.253]                 for (kk in seq_along(NAMES)) {
[13:36:37.253]                   name <- added[[kk]]
[13:36:37.253]                   NAME <- NAMES[[kk]]
[13:36:37.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.253]                     next
[13:36:37.253]                   args[[name]] <- ""
[13:36:37.253]                 }
[13:36:37.253]                 NAMES <- toupper(removed)
[13:36:37.253]                 for (kk in seq_along(NAMES)) {
[13:36:37.253]                   name <- removed[[kk]]
[13:36:37.253]                   NAME <- NAMES[[kk]]
[13:36:37.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.253]                     next
[13:36:37.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.253]                 }
[13:36:37.253]                 if (length(args) > 0) 
[13:36:37.253]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.253]             }
[13:36:37.253]             else {
[13:36:37.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.253]             }
[13:36:37.253]             {
[13:36:37.253]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.253]                   0L) {
[13:36:37.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.253]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.253]                   base::options(opts)
[13:36:37.253]                 }
[13:36:37.253]                 {
[13:36:37.253]                   {
[13:36:37.253]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.253]                     NULL
[13:36:37.253]                   }
[13:36:37.253]                   options(future.plan = NULL)
[13:36:37.253]                   if (is.na(NA_character_)) 
[13:36:37.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.253]                     .init = FALSE)
[13:36:37.253]                 }
[13:36:37.253]             }
[13:36:37.253]         }
[13:36:37.253]     })
[13:36:37.253]     if (TRUE) {
[13:36:37.253]         base::sink(type = "output", split = FALSE)
[13:36:37.253]         if (TRUE) {
[13:36:37.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.253]         }
[13:36:37.253]         else {
[13:36:37.253]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.253]         }
[13:36:37.253]         base::close(...future.stdout)
[13:36:37.253]         ...future.stdout <- NULL
[13:36:37.253]     }
[13:36:37.253]     ...future.result$conditions <- ...future.conditions
[13:36:37.253]     ...future.result$finished <- base::Sys.time()
[13:36:37.253]     ...future.result
[13:36:37.253] }
[13:36:37.255] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:37.265] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.266] - Validating connection of MultisessionFuture
[13:36:37.266] - received message: FutureResult
[13:36:37.266] - Received FutureResult
[13:36:37.266] - Erased future from FutureRegistry
[13:36:37.266] result() for ClusterFuture ...
[13:36:37.266] - result already collected: FutureResult
[13:36:37.266] result() for ClusterFuture ... done
[13:36:37.266] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.267] result() for ClusterFuture ...
[13:36:37.267] - result already collected: FutureResult
[13:36:37.267] result() for ClusterFuture ... done
[13:36:37.267] result() for ClusterFuture ...
[13:36:37.267] - result already collected: FutureResult
[13:36:37.267] result() for ClusterFuture ... done
[13:36:37.268] MultisessionFuture started
[13:36:37.268] - Launch lazy future ... done
[13:36:37.268] run() for ‘MultisessionFuture’ ... done
<environment: 0x564a72ec2020> 
<environment: 0x564a746c1110> 
[13:36:37.270] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.270] - Validating connection of MultisessionFuture
[13:36:37.270] - received message: FutureResult
[13:36:37.270] - Received FutureResult
[13:36:37.270] - Erased future from FutureRegistry
[13:36:37.270] result() for ClusterFuture ...
[13:36:37.270] - result already collected: FutureResult
[13:36:37.270] result() for ClusterFuture ... done
[13:36:37.271] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.271] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.271] - Validating connection of MultisessionFuture
[13:36:37.271] - received message: FutureResult
[13:36:37.271] - Received FutureResult
[13:36:37.271] - Erased future from FutureRegistry
[13:36:37.272] result() for ClusterFuture ...
[13:36:37.272] - result already collected: FutureResult
[13:36:37.272] result() for ClusterFuture ... done
[13:36:37.272] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:37.273] resolve() on environment ...
[13:36:37.273]  recursive: 0
[13:36:37.273]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:37.274] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.274] - nx: 4
[13:36:37.274] - relay: TRUE
[13:36:37.274] - stdout: TRUE
[13:36:37.274] - signal: TRUE
[13:36:37.274] - resignal: FALSE
[13:36:37.274] - force: TRUE
[13:36:37.274] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.274] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.274]  - until=2
[13:36:37.275]  - relaying element #2
[13:36:37.275] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.275] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.275] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.275]  length: 3 (resolved future 1)
[13:36:37.275] Future #2
[13:36:37.275] result() for ClusterFuture ...
[13:36:37.275] - result already collected: FutureResult
[13:36:37.275] result() for ClusterFuture ... done
[13:36:37.275] result() for ClusterFuture ...
[13:36:37.275] - result already collected: FutureResult
[13:36:37.276] result() for ClusterFuture ... done
[13:36:37.276] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:37.276] - nx: 4
[13:36:37.276] - relay: TRUE
[13:36:37.276] - stdout: TRUE
[13:36:37.276] - signal: TRUE
[13:36:37.276] - resignal: FALSE
[13:36:37.276] - force: TRUE
[13:36:37.276] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.276] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.276]  - until=2
[13:36:37.276]  - relaying element #2
[13:36:37.277] result() for ClusterFuture ...
[13:36:37.277] - result already collected: FutureResult
[13:36:37.277] result() for ClusterFuture ... done
[13:36:37.277] result() for ClusterFuture ...
[13:36:37.277] - result already collected: FutureResult
[13:36:37.277] result() for ClusterFuture ... done
[13:36:37.277] result() for ClusterFuture ...
[13:36:37.277] - result already collected: FutureResult
[13:36:37.277] result() for ClusterFuture ... done
[13:36:37.277] result() for ClusterFuture ...
[13:36:37.277] - result already collected: FutureResult
[13:36:37.278] result() for ClusterFuture ... done
[13:36:37.278] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.278] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.278] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:37.278]  length: 2 (resolved future 2)
[13:36:37.278] Future #3
[13:36:37.278] result() for ClusterFuture ...
[13:36:37.278] - result already collected: FutureResult
[13:36:37.278] result() for ClusterFuture ... done
[13:36:37.278] result() for ClusterFuture ...
[13:36:37.278] - result already collected: FutureResult
[13:36:37.279] result() for ClusterFuture ... done
[13:36:37.279] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:37.279] - nx: 4
[13:36:37.279] - relay: TRUE
[13:36:37.279] - stdout: TRUE
[13:36:37.279] - signal: TRUE
[13:36:37.279] - resignal: FALSE
[13:36:37.279] - force: TRUE
[13:36:37.279] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.279] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.279]  - until=3
[13:36:37.279]  - relaying element #3
[13:36:37.280] result() for ClusterFuture ...
[13:36:37.280] - result already collected: FutureResult
[13:36:37.280] result() for ClusterFuture ... done
[13:36:37.280] result() for ClusterFuture ...
[13:36:37.280] - result already collected: FutureResult
[13:36:37.280] result() for ClusterFuture ... done
[13:36:37.280] result() for ClusterFuture ...
[13:36:37.280] - result already collected: FutureResult
[13:36:37.280] result() for ClusterFuture ... done
[13:36:37.280] result() for ClusterFuture ...
[13:36:37.280] - result already collected: FutureResult
[13:36:37.281] result() for ClusterFuture ... done
[13:36:37.281] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.281] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.281] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:37.281]  length: 1 (resolved future 3)
[13:36:37.281] Future #4
[13:36:37.281] result() for ClusterFuture ...
[13:36:37.281] - result already collected: FutureResult
[13:36:37.281] result() for ClusterFuture ... done
[13:36:37.281] result() for ClusterFuture ...
[13:36:37.281] - result already collected: FutureResult
[13:36:37.281] result() for ClusterFuture ... done
[13:36:37.282] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:37.282] - nx: 4
[13:36:37.282] - relay: TRUE
[13:36:37.282] - stdout: TRUE
[13:36:37.282] - signal: TRUE
[13:36:37.282] - resignal: FALSE
[13:36:37.282] - force: TRUE
[13:36:37.282] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.282] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.282]  - until=4
[13:36:37.282]  - relaying element #4
[13:36:37.283] result() for ClusterFuture ...
[13:36:37.283] - result already collected: FutureResult
[13:36:37.283] result() for ClusterFuture ... done
[13:36:37.283] result() for ClusterFuture ...
[13:36:37.283] - result already collected: FutureResult
[13:36:37.283] result() for ClusterFuture ... done
[13:36:37.283] result() for ClusterFuture ...
[13:36:37.283] - result already collected: FutureResult
[13:36:37.283] result() for ClusterFuture ... done
[13:36:37.283] result() for ClusterFuture ...
[13:36:37.283] - result already collected: FutureResult
[13:36:37.283] result() for ClusterFuture ... done
[13:36:37.284] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.284] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.284] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:37.284]  length: 0 (resolved future 4)
[13:36:37.284] Relaying remaining futures
[13:36:37.284] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.284] - nx: 4
[13:36:37.284] - relay: TRUE
[13:36:37.284] - stdout: TRUE
[13:36:37.284] - signal: TRUE
[13:36:37.284] - resignal: FALSE
[13:36:37.284] - force: TRUE
[13:36:37.285] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.285] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:37.285] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.285] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.285] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.285] resolve() on environment ... DONE
[13:36:37.285] result() for ClusterFuture ...
[13:36:37.285] - result already collected: FutureResult
[13:36:37.285] result() for ClusterFuture ... done
[13:36:37.285] result() for ClusterFuture ...
[13:36:37.285] - result already collected: FutureResult
[13:36:37.286] result() for ClusterFuture ... done
[13:36:37.286] result() for ClusterFuture ...
[13:36:37.286] - result already collected: FutureResult
[13:36:37.286] result() for ClusterFuture ... done
[13:36:37.286] result() for ClusterFuture ...
[13:36:37.286] - result already collected: FutureResult
[13:36:37.286] result() for ClusterFuture ... done
[13:36:37.286] result() for ClusterFuture ...
[13:36:37.286] - result already collected: FutureResult
[13:36:37.286] result() for ClusterFuture ... done
[13:36:37.286] result() for ClusterFuture ...
[13:36:37.287] - result already collected: FutureResult
[13:36:37.287] result() for ClusterFuture ... done
<environment: 0x564a748f9568> 
Dimensions: c(2, 1, 3, 1)
[13:36:37.287] getGlobalsAndPackages() ...
[13:36:37.287] Searching for globals...
[13:36:37.287] 
[13:36:37.287] Searching for globals ... DONE
[13:36:37.288] - globals: [0] <none>
[13:36:37.288] getGlobalsAndPackages() ... DONE
[13:36:37.288] run() for ‘Future’ ...
[13:36:37.288] - state: ‘created’
[13:36:37.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.305] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.305]   - Field: ‘node’
[13:36:37.305]   - Field: ‘label’
[13:36:37.305]   - Field: ‘local’
[13:36:37.305]   - Field: ‘owner’
[13:36:37.305]   - Field: ‘envir’
[13:36:37.306]   - Field: ‘workers’
[13:36:37.306]   - Field: ‘packages’
[13:36:37.306]   - Field: ‘gc’
[13:36:37.306]   - Field: ‘conditions’
[13:36:37.306]   - Field: ‘persistent’
[13:36:37.306]   - Field: ‘expr’
[13:36:37.306]   - Field: ‘uuid’
[13:36:37.306]   - Field: ‘seed’
[13:36:37.306]   - Field: ‘version’
[13:36:37.306]   - Field: ‘result’
[13:36:37.306]   - Field: ‘asynchronous’
[13:36:37.307]   - Field: ‘calls’
[13:36:37.307]   - Field: ‘globals’
[13:36:37.307]   - Field: ‘stdout’
[13:36:37.307]   - Field: ‘earlySignal’
[13:36:37.307]   - Field: ‘lazy’
[13:36:37.307]   - Field: ‘state’
[13:36:37.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.307] - Launch lazy future ...
[13:36:37.307] Packages needed by the future expression (n = 0): <none>
[13:36:37.308] Packages needed by future strategies (n = 0): <none>
[13:36:37.308] {
[13:36:37.308]     {
[13:36:37.308]         {
[13:36:37.308]             ...future.startTime <- base::Sys.time()
[13:36:37.308]             {
[13:36:37.308]                 {
[13:36:37.308]                   {
[13:36:37.308]                     {
[13:36:37.308]                       base::local({
[13:36:37.308]                         has_future <- base::requireNamespace("future", 
[13:36:37.308]                           quietly = TRUE)
[13:36:37.308]                         if (has_future) {
[13:36:37.308]                           ns <- base::getNamespace("future")
[13:36:37.308]                           version <- ns[[".package"]][["version"]]
[13:36:37.308]                           if (is.null(version)) 
[13:36:37.308]                             version <- utils::packageVersion("future")
[13:36:37.308]                         }
[13:36:37.308]                         else {
[13:36:37.308]                           version <- NULL
[13:36:37.308]                         }
[13:36:37.308]                         if (!has_future || version < "1.8.0") {
[13:36:37.308]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.308]                             "", base::R.version$version.string), 
[13:36:37.308]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.308]                               "release", "version")], collapse = " "), 
[13:36:37.308]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.308]                             info)
[13:36:37.308]                           info <- base::paste(info, collapse = "; ")
[13:36:37.308]                           if (!has_future) {
[13:36:37.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.308]                               info)
[13:36:37.308]                           }
[13:36:37.308]                           else {
[13:36:37.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.308]                               info, version)
[13:36:37.308]                           }
[13:36:37.308]                           base::stop(msg)
[13:36:37.308]                         }
[13:36:37.308]                       })
[13:36:37.308]                     }
[13:36:37.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.308]                     base::options(mc.cores = 1L)
[13:36:37.308]                   }
[13:36:37.308]                   ...future.strategy.old <- future::plan("list")
[13:36:37.308]                   options(future.plan = NULL)
[13:36:37.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.308]                 }
[13:36:37.308]                 ...future.workdir <- getwd()
[13:36:37.308]             }
[13:36:37.308]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.308]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.308]         }
[13:36:37.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.308]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.308]             base::names(...future.oldOptions))
[13:36:37.308]     }
[13:36:37.308]     if (FALSE) {
[13:36:37.308]     }
[13:36:37.308]     else {
[13:36:37.308]         if (TRUE) {
[13:36:37.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.308]                 open = "w")
[13:36:37.308]         }
[13:36:37.308]         else {
[13:36:37.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.308]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.308]         }
[13:36:37.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.308]             base::sink(type = "output", split = FALSE)
[13:36:37.308]             base::close(...future.stdout)
[13:36:37.308]         }, add = TRUE)
[13:36:37.308]     }
[13:36:37.308]     ...future.frame <- base::sys.nframe()
[13:36:37.308]     ...future.conditions <- base::list()
[13:36:37.308]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.308]     if (FALSE) {
[13:36:37.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.308]     }
[13:36:37.308]     ...future.result <- base::tryCatch({
[13:36:37.308]         base::withCallingHandlers({
[13:36:37.308]             ...future.value <- base::withVisible(base::local({
[13:36:37.308]                 ...future.makeSendCondition <- base::local({
[13:36:37.308]                   sendCondition <- NULL
[13:36:37.308]                   function(frame = 1L) {
[13:36:37.308]                     if (is.function(sendCondition)) 
[13:36:37.308]                       return(sendCondition)
[13:36:37.308]                     ns <- getNamespace("parallel")
[13:36:37.308]                     if (exists("sendData", mode = "function", 
[13:36:37.308]                       envir = ns)) {
[13:36:37.308]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.308]                         envir = ns)
[13:36:37.308]                       envir <- sys.frame(frame)
[13:36:37.308]                       master <- NULL
[13:36:37.308]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.308]                         !identical(envir, emptyenv())) {
[13:36:37.308]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.308]                           inherits = FALSE)) {
[13:36:37.308]                           master <- get("master", mode = "list", 
[13:36:37.308]                             envir = envir, inherits = FALSE)
[13:36:37.308]                           if (inherits(master, c("SOCKnode", 
[13:36:37.308]                             "SOCK0node"))) {
[13:36:37.308]                             sendCondition <<- function(cond) {
[13:36:37.308]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.308]                                 success = TRUE)
[13:36:37.308]                               parallel_sendData(master, data)
[13:36:37.308]                             }
[13:36:37.308]                             return(sendCondition)
[13:36:37.308]                           }
[13:36:37.308]                         }
[13:36:37.308]                         frame <- frame + 1L
[13:36:37.308]                         envir <- sys.frame(frame)
[13:36:37.308]                       }
[13:36:37.308]                     }
[13:36:37.308]                     sendCondition <<- function(cond) NULL
[13:36:37.308]                   }
[13:36:37.308]                 })
[13:36:37.308]                 withCallingHandlers({
[13:36:37.308]                   2
[13:36:37.308]                 }, immediateCondition = function(cond) {
[13:36:37.308]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.308]                   sendCondition(cond)
[13:36:37.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.308]                   {
[13:36:37.308]                     inherits <- base::inherits
[13:36:37.308]                     invokeRestart <- base::invokeRestart
[13:36:37.308]                     is.null <- base::is.null
[13:36:37.308]                     muffled <- FALSE
[13:36:37.308]                     if (inherits(cond, "message")) {
[13:36:37.308]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.308]                       if (muffled) 
[13:36:37.308]                         invokeRestart("muffleMessage")
[13:36:37.308]                     }
[13:36:37.308]                     else if (inherits(cond, "warning")) {
[13:36:37.308]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.308]                       if (muffled) 
[13:36:37.308]                         invokeRestart("muffleWarning")
[13:36:37.308]                     }
[13:36:37.308]                     else if (inherits(cond, "condition")) {
[13:36:37.308]                       if (!is.null(pattern)) {
[13:36:37.308]                         computeRestarts <- base::computeRestarts
[13:36:37.308]                         grepl <- base::grepl
[13:36:37.308]                         restarts <- computeRestarts(cond)
[13:36:37.308]                         for (restart in restarts) {
[13:36:37.308]                           name <- restart$name
[13:36:37.308]                           if (is.null(name)) 
[13:36:37.308]                             next
[13:36:37.308]                           if (!grepl(pattern, name)) 
[13:36:37.308]                             next
[13:36:37.308]                           invokeRestart(restart)
[13:36:37.308]                           muffled <- TRUE
[13:36:37.308]                           break
[13:36:37.308]                         }
[13:36:37.308]                       }
[13:36:37.308]                     }
[13:36:37.308]                     invisible(muffled)
[13:36:37.308]                   }
[13:36:37.308]                   muffleCondition(cond)
[13:36:37.308]                 })
[13:36:37.308]             }))
[13:36:37.308]             future::FutureResult(value = ...future.value$value, 
[13:36:37.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.308]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.308]                     ...future.globalenv.names))
[13:36:37.308]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.308]         }, condition = base::local({
[13:36:37.308]             c <- base::c
[13:36:37.308]             inherits <- base::inherits
[13:36:37.308]             invokeRestart <- base::invokeRestart
[13:36:37.308]             length <- base::length
[13:36:37.308]             list <- base::list
[13:36:37.308]             seq.int <- base::seq.int
[13:36:37.308]             signalCondition <- base::signalCondition
[13:36:37.308]             sys.calls <- base::sys.calls
[13:36:37.308]             `[[` <- base::`[[`
[13:36:37.308]             `+` <- base::`+`
[13:36:37.308]             `<<-` <- base::`<<-`
[13:36:37.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.308]                   3L)]
[13:36:37.308]             }
[13:36:37.308]             function(cond) {
[13:36:37.308]                 is_error <- inherits(cond, "error")
[13:36:37.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.308]                   NULL)
[13:36:37.308]                 if (is_error) {
[13:36:37.308]                   sessionInformation <- function() {
[13:36:37.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.308]                       search = base::search(), system = base::Sys.info())
[13:36:37.308]                   }
[13:36:37.308]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.308]                     cond$call), session = sessionInformation(), 
[13:36:37.308]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.308]                   signalCondition(cond)
[13:36:37.308]                 }
[13:36:37.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.308]                 "immediateCondition"))) {
[13:36:37.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.308]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.308]                   if (TRUE && !signal) {
[13:36:37.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.308]                     {
[13:36:37.308]                       inherits <- base::inherits
[13:36:37.308]                       invokeRestart <- base::invokeRestart
[13:36:37.308]                       is.null <- base::is.null
[13:36:37.308]                       muffled <- FALSE
[13:36:37.308]                       if (inherits(cond, "message")) {
[13:36:37.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.308]                         if (muffled) 
[13:36:37.308]                           invokeRestart("muffleMessage")
[13:36:37.308]                       }
[13:36:37.308]                       else if (inherits(cond, "warning")) {
[13:36:37.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.308]                         if (muffled) 
[13:36:37.308]                           invokeRestart("muffleWarning")
[13:36:37.308]                       }
[13:36:37.308]                       else if (inherits(cond, "condition")) {
[13:36:37.308]                         if (!is.null(pattern)) {
[13:36:37.308]                           computeRestarts <- base::computeRestarts
[13:36:37.308]                           grepl <- base::grepl
[13:36:37.308]                           restarts <- computeRestarts(cond)
[13:36:37.308]                           for (restart in restarts) {
[13:36:37.308]                             name <- restart$name
[13:36:37.308]                             if (is.null(name)) 
[13:36:37.308]                               next
[13:36:37.308]                             if (!grepl(pattern, name)) 
[13:36:37.308]                               next
[13:36:37.308]                             invokeRestart(restart)
[13:36:37.308]                             muffled <- TRUE
[13:36:37.308]                             break
[13:36:37.308]                           }
[13:36:37.308]                         }
[13:36:37.308]                       }
[13:36:37.308]                       invisible(muffled)
[13:36:37.308]                     }
[13:36:37.308]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.308]                   }
[13:36:37.308]                 }
[13:36:37.308]                 else {
[13:36:37.308]                   if (TRUE) {
[13:36:37.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.308]                     {
[13:36:37.308]                       inherits <- base::inherits
[13:36:37.308]                       invokeRestart <- base::invokeRestart
[13:36:37.308]                       is.null <- base::is.null
[13:36:37.308]                       muffled <- FALSE
[13:36:37.308]                       if (inherits(cond, "message")) {
[13:36:37.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.308]                         if (muffled) 
[13:36:37.308]                           invokeRestart("muffleMessage")
[13:36:37.308]                       }
[13:36:37.308]                       else if (inherits(cond, "warning")) {
[13:36:37.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.308]                         if (muffled) 
[13:36:37.308]                           invokeRestart("muffleWarning")
[13:36:37.308]                       }
[13:36:37.308]                       else if (inherits(cond, "condition")) {
[13:36:37.308]                         if (!is.null(pattern)) {
[13:36:37.308]                           computeRestarts <- base::computeRestarts
[13:36:37.308]                           grepl <- base::grepl
[13:36:37.308]                           restarts <- computeRestarts(cond)
[13:36:37.308]                           for (restart in restarts) {
[13:36:37.308]                             name <- restart$name
[13:36:37.308]                             if (is.null(name)) 
[13:36:37.308]                               next
[13:36:37.308]                             if (!grepl(pattern, name)) 
[13:36:37.308]                               next
[13:36:37.308]                             invokeRestart(restart)
[13:36:37.308]                             muffled <- TRUE
[13:36:37.308]                             break
[13:36:37.308]                           }
[13:36:37.308]                         }
[13:36:37.308]                       }
[13:36:37.308]                       invisible(muffled)
[13:36:37.308]                     }
[13:36:37.308]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.308]                   }
[13:36:37.308]                 }
[13:36:37.308]             }
[13:36:37.308]         }))
[13:36:37.308]     }, error = function(ex) {
[13:36:37.308]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.308]                 ...future.rng), started = ...future.startTime, 
[13:36:37.308]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.308]             version = "1.8"), class = "FutureResult")
[13:36:37.308]     }, finally = {
[13:36:37.308]         if (!identical(...future.workdir, getwd())) 
[13:36:37.308]             setwd(...future.workdir)
[13:36:37.308]         {
[13:36:37.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.308]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.308]             }
[13:36:37.308]             base::options(...future.oldOptions)
[13:36:37.308]             if (.Platform$OS.type == "windows") {
[13:36:37.308]                 old_names <- names(...future.oldEnvVars)
[13:36:37.308]                 envs <- base::Sys.getenv()
[13:36:37.308]                 names <- names(envs)
[13:36:37.308]                 common <- intersect(names, old_names)
[13:36:37.308]                 added <- setdiff(names, old_names)
[13:36:37.308]                 removed <- setdiff(old_names, names)
[13:36:37.308]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.308]                   envs[common]]
[13:36:37.308]                 NAMES <- toupper(changed)
[13:36:37.308]                 args <- list()
[13:36:37.308]                 for (kk in seq_along(NAMES)) {
[13:36:37.308]                   name <- changed[[kk]]
[13:36:37.308]                   NAME <- NAMES[[kk]]
[13:36:37.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.308]                     next
[13:36:37.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.308]                 }
[13:36:37.308]                 NAMES <- toupper(added)
[13:36:37.308]                 for (kk in seq_along(NAMES)) {
[13:36:37.308]                   name <- added[[kk]]
[13:36:37.308]                   NAME <- NAMES[[kk]]
[13:36:37.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.308]                     next
[13:36:37.308]                   args[[name]] <- ""
[13:36:37.308]                 }
[13:36:37.308]                 NAMES <- toupper(removed)
[13:36:37.308]                 for (kk in seq_along(NAMES)) {
[13:36:37.308]                   name <- removed[[kk]]
[13:36:37.308]                   NAME <- NAMES[[kk]]
[13:36:37.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.308]                     next
[13:36:37.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.308]                 }
[13:36:37.308]                 if (length(args) > 0) 
[13:36:37.308]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.308]             }
[13:36:37.308]             else {
[13:36:37.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.308]             }
[13:36:37.308]             {
[13:36:37.308]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.308]                   0L) {
[13:36:37.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.308]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.308]                   base::options(opts)
[13:36:37.308]                 }
[13:36:37.308]                 {
[13:36:37.308]                   {
[13:36:37.308]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.308]                     NULL
[13:36:37.308]                   }
[13:36:37.308]                   options(future.plan = NULL)
[13:36:37.308]                   if (is.na(NA_character_)) 
[13:36:37.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.308]                     .init = FALSE)
[13:36:37.308]                 }
[13:36:37.308]             }
[13:36:37.308]         }
[13:36:37.308]     })
[13:36:37.308]     if (TRUE) {
[13:36:37.308]         base::sink(type = "output", split = FALSE)
[13:36:37.308]         if (TRUE) {
[13:36:37.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.308]         }
[13:36:37.308]         else {
[13:36:37.308]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.308]         }
[13:36:37.308]         base::close(...future.stdout)
[13:36:37.308]         ...future.stdout <- NULL
[13:36:37.308]     }
[13:36:37.308]     ...future.result$conditions <- ...future.conditions
[13:36:37.308]     ...future.result$finished <- base::Sys.time()
[13:36:37.308]     ...future.result
[13:36:37.308] }
[13:36:37.311] MultisessionFuture started
[13:36:37.311] - Launch lazy future ... done
[13:36:37.311] run() for ‘MultisessionFuture’ ... done
[13:36:37.311] getGlobalsAndPackages() ...
[13:36:37.311] Searching for globals...
[13:36:37.312] 
[13:36:37.312] Searching for globals ... DONE
[13:36:37.312] - globals: [0] <none>
[13:36:37.312] getGlobalsAndPackages() ... DONE
[13:36:37.312] run() for ‘Future’ ...
[13:36:37.312] - state: ‘created’
[13:36:37.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.326]   - Field: ‘node’
[13:36:37.326]   - Field: ‘label’
[13:36:37.327]   - Field: ‘local’
[13:36:37.327]   - Field: ‘owner’
[13:36:37.327]   - Field: ‘envir’
[13:36:37.327]   - Field: ‘workers’
[13:36:37.327]   - Field: ‘packages’
[13:36:37.327]   - Field: ‘gc’
[13:36:37.327]   - Field: ‘conditions’
[13:36:37.327]   - Field: ‘persistent’
[13:36:37.327]   - Field: ‘expr’
[13:36:37.327]   - Field: ‘uuid’
[13:36:37.327]   - Field: ‘seed’
[13:36:37.328]   - Field: ‘version’
[13:36:37.328]   - Field: ‘result’
[13:36:37.328]   - Field: ‘asynchronous’
[13:36:37.328]   - Field: ‘calls’
[13:36:37.328]   - Field: ‘globals’
[13:36:37.328]   - Field: ‘stdout’
[13:36:37.328]   - Field: ‘earlySignal’
[13:36:37.328]   - Field: ‘lazy’
[13:36:37.328]   - Field: ‘state’
[13:36:37.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.328] - Launch lazy future ...
[13:36:37.329] Packages needed by the future expression (n = 0): <none>
[13:36:37.329] Packages needed by future strategies (n = 0): <none>
[13:36:37.329] {
[13:36:37.329]     {
[13:36:37.329]         {
[13:36:37.329]             ...future.startTime <- base::Sys.time()
[13:36:37.329]             {
[13:36:37.329]                 {
[13:36:37.329]                   {
[13:36:37.329]                     {
[13:36:37.329]                       base::local({
[13:36:37.329]                         has_future <- base::requireNamespace("future", 
[13:36:37.329]                           quietly = TRUE)
[13:36:37.329]                         if (has_future) {
[13:36:37.329]                           ns <- base::getNamespace("future")
[13:36:37.329]                           version <- ns[[".package"]][["version"]]
[13:36:37.329]                           if (is.null(version)) 
[13:36:37.329]                             version <- utils::packageVersion("future")
[13:36:37.329]                         }
[13:36:37.329]                         else {
[13:36:37.329]                           version <- NULL
[13:36:37.329]                         }
[13:36:37.329]                         if (!has_future || version < "1.8.0") {
[13:36:37.329]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.329]                             "", base::R.version$version.string), 
[13:36:37.329]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.329]                               "release", "version")], collapse = " "), 
[13:36:37.329]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.329]                             info)
[13:36:37.329]                           info <- base::paste(info, collapse = "; ")
[13:36:37.329]                           if (!has_future) {
[13:36:37.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.329]                               info)
[13:36:37.329]                           }
[13:36:37.329]                           else {
[13:36:37.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.329]                               info, version)
[13:36:37.329]                           }
[13:36:37.329]                           base::stop(msg)
[13:36:37.329]                         }
[13:36:37.329]                       })
[13:36:37.329]                     }
[13:36:37.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.329]                     base::options(mc.cores = 1L)
[13:36:37.329]                   }
[13:36:37.329]                   ...future.strategy.old <- future::plan("list")
[13:36:37.329]                   options(future.plan = NULL)
[13:36:37.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.329]                 }
[13:36:37.329]                 ...future.workdir <- getwd()
[13:36:37.329]             }
[13:36:37.329]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.329]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.329]         }
[13:36:37.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.329]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.329]             base::names(...future.oldOptions))
[13:36:37.329]     }
[13:36:37.329]     if (FALSE) {
[13:36:37.329]     }
[13:36:37.329]     else {
[13:36:37.329]         if (TRUE) {
[13:36:37.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.329]                 open = "w")
[13:36:37.329]         }
[13:36:37.329]         else {
[13:36:37.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.329]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.329]         }
[13:36:37.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.329]             base::sink(type = "output", split = FALSE)
[13:36:37.329]             base::close(...future.stdout)
[13:36:37.329]         }, add = TRUE)
[13:36:37.329]     }
[13:36:37.329]     ...future.frame <- base::sys.nframe()
[13:36:37.329]     ...future.conditions <- base::list()
[13:36:37.329]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.329]     if (FALSE) {
[13:36:37.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.329]     }
[13:36:37.329]     ...future.result <- base::tryCatch({
[13:36:37.329]         base::withCallingHandlers({
[13:36:37.329]             ...future.value <- base::withVisible(base::local({
[13:36:37.329]                 ...future.makeSendCondition <- base::local({
[13:36:37.329]                   sendCondition <- NULL
[13:36:37.329]                   function(frame = 1L) {
[13:36:37.329]                     if (is.function(sendCondition)) 
[13:36:37.329]                       return(sendCondition)
[13:36:37.329]                     ns <- getNamespace("parallel")
[13:36:37.329]                     if (exists("sendData", mode = "function", 
[13:36:37.329]                       envir = ns)) {
[13:36:37.329]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.329]                         envir = ns)
[13:36:37.329]                       envir <- sys.frame(frame)
[13:36:37.329]                       master <- NULL
[13:36:37.329]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.329]                         !identical(envir, emptyenv())) {
[13:36:37.329]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.329]                           inherits = FALSE)) {
[13:36:37.329]                           master <- get("master", mode = "list", 
[13:36:37.329]                             envir = envir, inherits = FALSE)
[13:36:37.329]                           if (inherits(master, c("SOCKnode", 
[13:36:37.329]                             "SOCK0node"))) {
[13:36:37.329]                             sendCondition <<- function(cond) {
[13:36:37.329]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.329]                                 success = TRUE)
[13:36:37.329]                               parallel_sendData(master, data)
[13:36:37.329]                             }
[13:36:37.329]                             return(sendCondition)
[13:36:37.329]                           }
[13:36:37.329]                         }
[13:36:37.329]                         frame <- frame + 1L
[13:36:37.329]                         envir <- sys.frame(frame)
[13:36:37.329]                       }
[13:36:37.329]                     }
[13:36:37.329]                     sendCondition <<- function(cond) NULL
[13:36:37.329]                   }
[13:36:37.329]                 })
[13:36:37.329]                 withCallingHandlers({
[13:36:37.329]                   NULL
[13:36:37.329]                 }, immediateCondition = function(cond) {
[13:36:37.329]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.329]                   sendCondition(cond)
[13:36:37.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.329]                   {
[13:36:37.329]                     inherits <- base::inherits
[13:36:37.329]                     invokeRestart <- base::invokeRestart
[13:36:37.329]                     is.null <- base::is.null
[13:36:37.329]                     muffled <- FALSE
[13:36:37.329]                     if (inherits(cond, "message")) {
[13:36:37.329]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.329]                       if (muffled) 
[13:36:37.329]                         invokeRestart("muffleMessage")
[13:36:37.329]                     }
[13:36:37.329]                     else if (inherits(cond, "warning")) {
[13:36:37.329]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.329]                       if (muffled) 
[13:36:37.329]                         invokeRestart("muffleWarning")
[13:36:37.329]                     }
[13:36:37.329]                     else if (inherits(cond, "condition")) {
[13:36:37.329]                       if (!is.null(pattern)) {
[13:36:37.329]                         computeRestarts <- base::computeRestarts
[13:36:37.329]                         grepl <- base::grepl
[13:36:37.329]                         restarts <- computeRestarts(cond)
[13:36:37.329]                         for (restart in restarts) {
[13:36:37.329]                           name <- restart$name
[13:36:37.329]                           if (is.null(name)) 
[13:36:37.329]                             next
[13:36:37.329]                           if (!grepl(pattern, name)) 
[13:36:37.329]                             next
[13:36:37.329]                           invokeRestart(restart)
[13:36:37.329]                           muffled <- TRUE
[13:36:37.329]                           break
[13:36:37.329]                         }
[13:36:37.329]                       }
[13:36:37.329]                     }
[13:36:37.329]                     invisible(muffled)
[13:36:37.329]                   }
[13:36:37.329]                   muffleCondition(cond)
[13:36:37.329]                 })
[13:36:37.329]             }))
[13:36:37.329]             future::FutureResult(value = ...future.value$value, 
[13:36:37.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.329]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.329]                     ...future.globalenv.names))
[13:36:37.329]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.329]         }, condition = base::local({
[13:36:37.329]             c <- base::c
[13:36:37.329]             inherits <- base::inherits
[13:36:37.329]             invokeRestart <- base::invokeRestart
[13:36:37.329]             length <- base::length
[13:36:37.329]             list <- base::list
[13:36:37.329]             seq.int <- base::seq.int
[13:36:37.329]             signalCondition <- base::signalCondition
[13:36:37.329]             sys.calls <- base::sys.calls
[13:36:37.329]             `[[` <- base::`[[`
[13:36:37.329]             `+` <- base::`+`
[13:36:37.329]             `<<-` <- base::`<<-`
[13:36:37.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.329]                   3L)]
[13:36:37.329]             }
[13:36:37.329]             function(cond) {
[13:36:37.329]                 is_error <- inherits(cond, "error")
[13:36:37.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.329]                   NULL)
[13:36:37.329]                 if (is_error) {
[13:36:37.329]                   sessionInformation <- function() {
[13:36:37.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.329]                       search = base::search(), system = base::Sys.info())
[13:36:37.329]                   }
[13:36:37.329]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.329]                     cond$call), session = sessionInformation(), 
[13:36:37.329]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.329]                   signalCondition(cond)
[13:36:37.329]                 }
[13:36:37.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.329]                 "immediateCondition"))) {
[13:36:37.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.329]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.329]                   if (TRUE && !signal) {
[13:36:37.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.329]                     {
[13:36:37.329]                       inherits <- base::inherits
[13:36:37.329]                       invokeRestart <- base::invokeRestart
[13:36:37.329]                       is.null <- base::is.null
[13:36:37.329]                       muffled <- FALSE
[13:36:37.329]                       if (inherits(cond, "message")) {
[13:36:37.329]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.329]                         if (muffled) 
[13:36:37.329]                           invokeRestart("muffleMessage")
[13:36:37.329]                       }
[13:36:37.329]                       else if (inherits(cond, "warning")) {
[13:36:37.329]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.329]                         if (muffled) 
[13:36:37.329]                           invokeRestart("muffleWarning")
[13:36:37.329]                       }
[13:36:37.329]                       else if (inherits(cond, "condition")) {
[13:36:37.329]                         if (!is.null(pattern)) {
[13:36:37.329]                           computeRestarts <- base::computeRestarts
[13:36:37.329]                           grepl <- base::grepl
[13:36:37.329]                           restarts <- computeRestarts(cond)
[13:36:37.329]                           for (restart in restarts) {
[13:36:37.329]                             name <- restart$name
[13:36:37.329]                             if (is.null(name)) 
[13:36:37.329]                               next
[13:36:37.329]                             if (!grepl(pattern, name)) 
[13:36:37.329]                               next
[13:36:37.329]                             invokeRestart(restart)
[13:36:37.329]                             muffled <- TRUE
[13:36:37.329]                             break
[13:36:37.329]                           }
[13:36:37.329]                         }
[13:36:37.329]                       }
[13:36:37.329]                       invisible(muffled)
[13:36:37.329]                     }
[13:36:37.329]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.329]                   }
[13:36:37.329]                 }
[13:36:37.329]                 else {
[13:36:37.329]                   if (TRUE) {
[13:36:37.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.329]                     {
[13:36:37.329]                       inherits <- base::inherits
[13:36:37.329]                       invokeRestart <- base::invokeRestart
[13:36:37.329]                       is.null <- base::is.null
[13:36:37.329]                       muffled <- FALSE
[13:36:37.329]                       if (inherits(cond, "message")) {
[13:36:37.329]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.329]                         if (muffled) 
[13:36:37.329]                           invokeRestart("muffleMessage")
[13:36:37.329]                       }
[13:36:37.329]                       else if (inherits(cond, "warning")) {
[13:36:37.329]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.329]                         if (muffled) 
[13:36:37.329]                           invokeRestart("muffleWarning")
[13:36:37.329]                       }
[13:36:37.329]                       else if (inherits(cond, "condition")) {
[13:36:37.329]                         if (!is.null(pattern)) {
[13:36:37.329]                           computeRestarts <- base::computeRestarts
[13:36:37.329]                           grepl <- base::grepl
[13:36:37.329]                           restarts <- computeRestarts(cond)
[13:36:37.329]                           for (restart in restarts) {
[13:36:37.329]                             name <- restart$name
[13:36:37.329]                             if (is.null(name)) 
[13:36:37.329]                               next
[13:36:37.329]                             if (!grepl(pattern, name)) 
[13:36:37.329]                               next
[13:36:37.329]                             invokeRestart(restart)
[13:36:37.329]                             muffled <- TRUE
[13:36:37.329]                             break
[13:36:37.329]                           }
[13:36:37.329]                         }
[13:36:37.329]                       }
[13:36:37.329]                       invisible(muffled)
[13:36:37.329]                     }
[13:36:37.329]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.329]                   }
[13:36:37.329]                 }
[13:36:37.329]             }
[13:36:37.329]         }))
[13:36:37.329]     }, error = function(ex) {
[13:36:37.329]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.329]                 ...future.rng), started = ...future.startTime, 
[13:36:37.329]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.329]             version = "1.8"), class = "FutureResult")
[13:36:37.329]     }, finally = {
[13:36:37.329]         if (!identical(...future.workdir, getwd())) 
[13:36:37.329]             setwd(...future.workdir)
[13:36:37.329]         {
[13:36:37.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.329]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.329]             }
[13:36:37.329]             base::options(...future.oldOptions)
[13:36:37.329]             if (.Platform$OS.type == "windows") {
[13:36:37.329]                 old_names <- names(...future.oldEnvVars)
[13:36:37.329]                 envs <- base::Sys.getenv()
[13:36:37.329]                 names <- names(envs)
[13:36:37.329]                 common <- intersect(names, old_names)
[13:36:37.329]                 added <- setdiff(names, old_names)
[13:36:37.329]                 removed <- setdiff(old_names, names)
[13:36:37.329]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.329]                   envs[common]]
[13:36:37.329]                 NAMES <- toupper(changed)
[13:36:37.329]                 args <- list()
[13:36:37.329]                 for (kk in seq_along(NAMES)) {
[13:36:37.329]                   name <- changed[[kk]]
[13:36:37.329]                   NAME <- NAMES[[kk]]
[13:36:37.329]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.329]                     next
[13:36:37.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.329]                 }
[13:36:37.329]                 NAMES <- toupper(added)
[13:36:37.329]                 for (kk in seq_along(NAMES)) {
[13:36:37.329]                   name <- added[[kk]]
[13:36:37.329]                   NAME <- NAMES[[kk]]
[13:36:37.329]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.329]                     next
[13:36:37.329]                   args[[name]] <- ""
[13:36:37.329]                 }
[13:36:37.329]                 NAMES <- toupper(removed)
[13:36:37.329]                 for (kk in seq_along(NAMES)) {
[13:36:37.329]                   name <- removed[[kk]]
[13:36:37.329]                   NAME <- NAMES[[kk]]
[13:36:37.329]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.329]                     next
[13:36:37.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.329]                 }
[13:36:37.329]                 if (length(args) > 0) 
[13:36:37.329]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.329]             }
[13:36:37.329]             else {
[13:36:37.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.329]             }
[13:36:37.329]             {
[13:36:37.329]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.329]                   0L) {
[13:36:37.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.329]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.329]                   base::options(opts)
[13:36:37.329]                 }
[13:36:37.329]                 {
[13:36:37.329]                   {
[13:36:37.329]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.329]                     NULL
[13:36:37.329]                   }
[13:36:37.329]                   options(future.plan = NULL)
[13:36:37.329]                   if (is.na(NA_character_)) 
[13:36:37.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.329]                     .init = FALSE)
[13:36:37.329]                 }
[13:36:37.329]             }
[13:36:37.329]         }
[13:36:37.329]     })
[13:36:37.329]     if (TRUE) {
[13:36:37.329]         base::sink(type = "output", split = FALSE)
[13:36:37.329]         if (TRUE) {
[13:36:37.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.329]         }
[13:36:37.329]         else {
[13:36:37.329]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.329]         }
[13:36:37.329]         base::close(...future.stdout)
[13:36:37.329]         ...future.stdout <- NULL
[13:36:37.329]     }
[13:36:37.329]     ...future.result$conditions <- ...future.conditions
[13:36:37.329]     ...future.result$finished <- base::Sys.time()
[13:36:37.329]     ...future.result
[13:36:37.329] }
[13:36:37.332] MultisessionFuture started
[13:36:37.332] - Launch lazy future ... done
[13:36:37.332] run() for ‘MultisessionFuture’ ... done
[13:36:37.333] getGlobalsAndPackages() ...
[13:36:37.333] Searching for globals...
[13:36:37.333] - globals found: [1] ‘{’
[13:36:37.333] Searching for globals ... DONE
[13:36:37.333] Resolving globals: FALSE
[13:36:37.334] 
[13:36:37.334] 
[13:36:37.334] getGlobalsAndPackages() ... DONE
[13:36:37.334] run() for ‘Future’ ...
[13:36:37.334] - state: ‘created’
[13:36:37.334] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:37.348]   - Field: ‘node’
[13:36:37.348]   - Field: ‘label’
[13:36:37.348]   - Field: ‘local’
[13:36:37.348]   - Field: ‘owner’
[13:36:37.348]   - Field: ‘envir’
[13:36:37.349]   - Field: ‘workers’
[13:36:37.349]   - Field: ‘packages’
[13:36:37.349]   - Field: ‘gc’
[13:36:37.349]   - Field: ‘conditions’
[13:36:37.349]   - Field: ‘persistent’
[13:36:37.349]   - Field: ‘expr’
[13:36:37.349]   - Field: ‘uuid’
[13:36:37.349]   - Field: ‘seed’
[13:36:37.349]   - Field: ‘version’
[13:36:37.349]   - Field: ‘result’
[13:36:37.350]   - Field: ‘asynchronous’
[13:36:37.350]   - Field: ‘calls’
[13:36:37.350]   - Field: ‘globals’
[13:36:37.350]   - Field: ‘stdout’
[13:36:37.350]   - Field: ‘earlySignal’
[13:36:37.350]   - Field: ‘lazy’
[13:36:37.350]   - Field: ‘state’
[13:36:37.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:37.350] - Launch lazy future ...
[13:36:37.351] Packages needed by the future expression (n = 0): <none>
[13:36:37.351] Packages needed by future strategies (n = 0): <none>
[13:36:37.351] {
[13:36:37.351]     {
[13:36:37.351]         {
[13:36:37.351]             ...future.startTime <- base::Sys.time()
[13:36:37.351]             {
[13:36:37.351]                 {
[13:36:37.351]                   {
[13:36:37.351]                     {
[13:36:37.351]                       base::local({
[13:36:37.351]                         has_future <- base::requireNamespace("future", 
[13:36:37.351]                           quietly = TRUE)
[13:36:37.351]                         if (has_future) {
[13:36:37.351]                           ns <- base::getNamespace("future")
[13:36:37.351]                           version <- ns[[".package"]][["version"]]
[13:36:37.351]                           if (is.null(version)) 
[13:36:37.351]                             version <- utils::packageVersion("future")
[13:36:37.351]                         }
[13:36:37.351]                         else {
[13:36:37.351]                           version <- NULL
[13:36:37.351]                         }
[13:36:37.351]                         if (!has_future || version < "1.8.0") {
[13:36:37.351]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.351]                             "", base::R.version$version.string), 
[13:36:37.351]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.351]                               "release", "version")], collapse = " "), 
[13:36:37.351]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.351]                             info)
[13:36:37.351]                           info <- base::paste(info, collapse = "; ")
[13:36:37.351]                           if (!has_future) {
[13:36:37.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.351]                               info)
[13:36:37.351]                           }
[13:36:37.351]                           else {
[13:36:37.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.351]                               info, version)
[13:36:37.351]                           }
[13:36:37.351]                           base::stop(msg)
[13:36:37.351]                         }
[13:36:37.351]                       })
[13:36:37.351]                     }
[13:36:37.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.351]                     base::options(mc.cores = 1L)
[13:36:37.351]                   }
[13:36:37.351]                   ...future.strategy.old <- future::plan("list")
[13:36:37.351]                   options(future.plan = NULL)
[13:36:37.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.351]                 }
[13:36:37.351]                 ...future.workdir <- getwd()
[13:36:37.351]             }
[13:36:37.351]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.351]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.351]         }
[13:36:37.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.351]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.351]             base::names(...future.oldOptions))
[13:36:37.351]     }
[13:36:37.351]     if (FALSE) {
[13:36:37.351]     }
[13:36:37.351]     else {
[13:36:37.351]         if (TRUE) {
[13:36:37.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.351]                 open = "w")
[13:36:37.351]         }
[13:36:37.351]         else {
[13:36:37.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.351]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.351]         }
[13:36:37.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.351]             base::sink(type = "output", split = FALSE)
[13:36:37.351]             base::close(...future.stdout)
[13:36:37.351]         }, add = TRUE)
[13:36:37.351]     }
[13:36:37.351]     ...future.frame <- base::sys.nframe()
[13:36:37.351]     ...future.conditions <- base::list()
[13:36:37.351]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.351]     if (FALSE) {
[13:36:37.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.351]     }
[13:36:37.351]     ...future.result <- base::tryCatch({
[13:36:37.351]         base::withCallingHandlers({
[13:36:37.351]             ...future.value <- base::withVisible(base::local({
[13:36:37.351]                 ...future.makeSendCondition <- base::local({
[13:36:37.351]                   sendCondition <- NULL
[13:36:37.351]                   function(frame = 1L) {
[13:36:37.351]                     if (is.function(sendCondition)) 
[13:36:37.351]                       return(sendCondition)
[13:36:37.351]                     ns <- getNamespace("parallel")
[13:36:37.351]                     if (exists("sendData", mode = "function", 
[13:36:37.351]                       envir = ns)) {
[13:36:37.351]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:37.351]                         envir = ns)
[13:36:37.351]                       envir <- sys.frame(frame)
[13:36:37.351]                       master <- NULL
[13:36:37.351]                       while (!identical(envir, .GlobalEnv) && 
[13:36:37.351]                         !identical(envir, emptyenv())) {
[13:36:37.351]                         if (exists("master", mode = "list", envir = envir, 
[13:36:37.351]                           inherits = FALSE)) {
[13:36:37.351]                           master <- get("master", mode = "list", 
[13:36:37.351]                             envir = envir, inherits = FALSE)
[13:36:37.351]                           if (inherits(master, c("SOCKnode", 
[13:36:37.351]                             "SOCK0node"))) {
[13:36:37.351]                             sendCondition <<- function(cond) {
[13:36:37.351]                               data <- list(type = "VALUE", value = cond, 
[13:36:37.351]                                 success = TRUE)
[13:36:37.351]                               parallel_sendData(master, data)
[13:36:37.351]                             }
[13:36:37.351]                             return(sendCondition)
[13:36:37.351]                           }
[13:36:37.351]                         }
[13:36:37.351]                         frame <- frame + 1L
[13:36:37.351]                         envir <- sys.frame(frame)
[13:36:37.351]                       }
[13:36:37.351]                     }
[13:36:37.351]                     sendCondition <<- function(cond) NULL
[13:36:37.351]                   }
[13:36:37.351]                 })
[13:36:37.351]                 withCallingHandlers({
[13:36:37.351]                   {
[13:36:37.351]                     4
[13:36:37.351]                   }
[13:36:37.351]                 }, immediateCondition = function(cond) {
[13:36:37.351]                   sendCondition <- ...future.makeSendCondition()
[13:36:37.351]                   sendCondition(cond)
[13:36:37.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.351]                   {
[13:36:37.351]                     inherits <- base::inherits
[13:36:37.351]                     invokeRestart <- base::invokeRestart
[13:36:37.351]                     is.null <- base::is.null
[13:36:37.351]                     muffled <- FALSE
[13:36:37.351]                     if (inherits(cond, "message")) {
[13:36:37.351]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.351]                       if (muffled) 
[13:36:37.351]                         invokeRestart("muffleMessage")
[13:36:37.351]                     }
[13:36:37.351]                     else if (inherits(cond, "warning")) {
[13:36:37.351]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.351]                       if (muffled) 
[13:36:37.351]                         invokeRestart("muffleWarning")
[13:36:37.351]                     }
[13:36:37.351]                     else if (inherits(cond, "condition")) {
[13:36:37.351]                       if (!is.null(pattern)) {
[13:36:37.351]                         computeRestarts <- base::computeRestarts
[13:36:37.351]                         grepl <- base::grepl
[13:36:37.351]                         restarts <- computeRestarts(cond)
[13:36:37.351]                         for (restart in restarts) {
[13:36:37.351]                           name <- restart$name
[13:36:37.351]                           if (is.null(name)) 
[13:36:37.351]                             next
[13:36:37.351]                           if (!grepl(pattern, name)) 
[13:36:37.351]                             next
[13:36:37.351]                           invokeRestart(restart)
[13:36:37.351]                           muffled <- TRUE
[13:36:37.351]                           break
[13:36:37.351]                         }
[13:36:37.351]                       }
[13:36:37.351]                     }
[13:36:37.351]                     invisible(muffled)
[13:36:37.351]                   }
[13:36:37.351]                   muffleCondition(cond)
[13:36:37.351]                 })
[13:36:37.351]             }))
[13:36:37.351]             future::FutureResult(value = ...future.value$value, 
[13:36:37.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.351]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.351]                     ...future.globalenv.names))
[13:36:37.351]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.351]         }, condition = base::local({
[13:36:37.351]             c <- base::c
[13:36:37.351]             inherits <- base::inherits
[13:36:37.351]             invokeRestart <- base::invokeRestart
[13:36:37.351]             length <- base::length
[13:36:37.351]             list <- base::list
[13:36:37.351]             seq.int <- base::seq.int
[13:36:37.351]             signalCondition <- base::signalCondition
[13:36:37.351]             sys.calls <- base::sys.calls
[13:36:37.351]             `[[` <- base::`[[`
[13:36:37.351]             `+` <- base::`+`
[13:36:37.351]             `<<-` <- base::`<<-`
[13:36:37.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.351]                   3L)]
[13:36:37.351]             }
[13:36:37.351]             function(cond) {
[13:36:37.351]                 is_error <- inherits(cond, "error")
[13:36:37.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.351]                   NULL)
[13:36:37.351]                 if (is_error) {
[13:36:37.351]                   sessionInformation <- function() {
[13:36:37.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.351]                       search = base::search(), system = base::Sys.info())
[13:36:37.351]                   }
[13:36:37.351]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.351]                     cond$call), session = sessionInformation(), 
[13:36:37.351]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.351]                   signalCondition(cond)
[13:36:37.351]                 }
[13:36:37.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.351]                 "immediateCondition"))) {
[13:36:37.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.351]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.351]                   if (TRUE && !signal) {
[13:36:37.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.351]                     {
[13:36:37.351]                       inherits <- base::inherits
[13:36:37.351]                       invokeRestart <- base::invokeRestart
[13:36:37.351]                       is.null <- base::is.null
[13:36:37.351]                       muffled <- FALSE
[13:36:37.351]                       if (inherits(cond, "message")) {
[13:36:37.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.351]                         if (muffled) 
[13:36:37.351]                           invokeRestart("muffleMessage")
[13:36:37.351]                       }
[13:36:37.351]                       else if (inherits(cond, "warning")) {
[13:36:37.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.351]                         if (muffled) 
[13:36:37.351]                           invokeRestart("muffleWarning")
[13:36:37.351]                       }
[13:36:37.351]                       else if (inherits(cond, "condition")) {
[13:36:37.351]                         if (!is.null(pattern)) {
[13:36:37.351]                           computeRestarts <- base::computeRestarts
[13:36:37.351]                           grepl <- base::grepl
[13:36:37.351]                           restarts <- computeRestarts(cond)
[13:36:37.351]                           for (restart in restarts) {
[13:36:37.351]                             name <- restart$name
[13:36:37.351]                             if (is.null(name)) 
[13:36:37.351]                               next
[13:36:37.351]                             if (!grepl(pattern, name)) 
[13:36:37.351]                               next
[13:36:37.351]                             invokeRestart(restart)
[13:36:37.351]                             muffled <- TRUE
[13:36:37.351]                             break
[13:36:37.351]                           }
[13:36:37.351]                         }
[13:36:37.351]                       }
[13:36:37.351]                       invisible(muffled)
[13:36:37.351]                     }
[13:36:37.351]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.351]                   }
[13:36:37.351]                 }
[13:36:37.351]                 else {
[13:36:37.351]                   if (TRUE) {
[13:36:37.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.351]                     {
[13:36:37.351]                       inherits <- base::inherits
[13:36:37.351]                       invokeRestart <- base::invokeRestart
[13:36:37.351]                       is.null <- base::is.null
[13:36:37.351]                       muffled <- FALSE
[13:36:37.351]                       if (inherits(cond, "message")) {
[13:36:37.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.351]                         if (muffled) 
[13:36:37.351]                           invokeRestart("muffleMessage")
[13:36:37.351]                       }
[13:36:37.351]                       else if (inherits(cond, "warning")) {
[13:36:37.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.351]                         if (muffled) 
[13:36:37.351]                           invokeRestart("muffleWarning")
[13:36:37.351]                       }
[13:36:37.351]                       else if (inherits(cond, "condition")) {
[13:36:37.351]                         if (!is.null(pattern)) {
[13:36:37.351]                           computeRestarts <- base::computeRestarts
[13:36:37.351]                           grepl <- base::grepl
[13:36:37.351]                           restarts <- computeRestarts(cond)
[13:36:37.351]                           for (restart in restarts) {
[13:36:37.351]                             name <- restart$name
[13:36:37.351]                             if (is.null(name)) 
[13:36:37.351]                               next
[13:36:37.351]                             if (!grepl(pattern, name)) 
[13:36:37.351]                               next
[13:36:37.351]                             invokeRestart(restart)
[13:36:37.351]                             muffled <- TRUE
[13:36:37.351]                             break
[13:36:37.351]                           }
[13:36:37.351]                         }
[13:36:37.351]                       }
[13:36:37.351]                       invisible(muffled)
[13:36:37.351]                     }
[13:36:37.351]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.351]                   }
[13:36:37.351]                 }
[13:36:37.351]             }
[13:36:37.351]         }))
[13:36:37.351]     }, error = function(ex) {
[13:36:37.351]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.351]                 ...future.rng), started = ...future.startTime, 
[13:36:37.351]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.351]             version = "1.8"), class = "FutureResult")
[13:36:37.351]     }, finally = {
[13:36:37.351]         if (!identical(...future.workdir, getwd())) 
[13:36:37.351]             setwd(...future.workdir)
[13:36:37.351]         {
[13:36:37.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.351]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.351]             }
[13:36:37.351]             base::options(...future.oldOptions)
[13:36:37.351]             if (.Platform$OS.type == "windows") {
[13:36:37.351]                 old_names <- names(...future.oldEnvVars)
[13:36:37.351]                 envs <- base::Sys.getenv()
[13:36:37.351]                 names <- names(envs)
[13:36:37.351]                 common <- intersect(names, old_names)
[13:36:37.351]                 added <- setdiff(names, old_names)
[13:36:37.351]                 removed <- setdiff(old_names, names)
[13:36:37.351]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.351]                   envs[common]]
[13:36:37.351]                 NAMES <- toupper(changed)
[13:36:37.351]                 args <- list()
[13:36:37.351]                 for (kk in seq_along(NAMES)) {
[13:36:37.351]                   name <- changed[[kk]]
[13:36:37.351]                   NAME <- NAMES[[kk]]
[13:36:37.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.351]                     next
[13:36:37.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.351]                 }
[13:36:37.351]                 NAMES <- toupper(added)
[13:36:37.351]                 for (kk in seq_along(NAMES)) {
[13:36:37.351]                   name <- added[[kk]]
[13:36:37.351]                   NAME <- NAMES[[kk]]
[13:36:37.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.351]                     next
[13:36:37.351]                   args[[name]] <- ""
[13:36:37.351]                 }
[13:36:37.351]                 NAMES <- toupper(removed)
[13:36:37.351]                 for (kk in seq_along(NAMES)) {
[13:36:37.351]                   name <- removed[[kk]]
[13:36:37.351]                   NAME <- NAMES[[kk]]
[13:36:37.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.351]                     next
[13:36:37.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.351]                 }
[13:36:37.351]                 if (length(args) > 0) 
[13:36:37.351]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.351]             }
[13:36:37.351]             else {
[13:36:37.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.351]             }
[13:36:37.351]             {
[13:36:37.351]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.351]                   0L) {
[13:36:37.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.351]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.351]                   base::options(opts)
[13:36:37.351]                 }
[13:36:37.351]                 {
[13:36:37.351]                   {
[13:36:37.351]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.351]                     NULL
[13:36:37.351]                   }
[13:36:37.351]                   options(future.plan = NULL)
[13:36:37.351]                   if (is.na(NA_character_)) 
[13:36:37.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.351]                     .init = FALSE)
[13:36:37.351]                 }
[13:36:37.351]             }
[13:36:37.351]         }
[13:36:37.351]     })
[13:36:37.351]     if (TRUE) {
[13:36:37.351]         base::sink(type = "output", split = FALSE)
[13:36:37.351]         if (TRUE) {
[13:36:37.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.351]         }
[13:36:37.351]         else {
[13:36:37.351]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.351]         }
[13:36:37.351]         base::close(...future.stdout)
[13:36:37.351]         ...future.stdout <- NULL
[13:36:37.351]     }
[13:36:37.351]     ...future.result$conditions <- ...future.conditions
[13:36:37.351]     ...future.result$finished <- base::Sys.time()
[13:36:37.351]     ...future.result
[13:36:37.351] }
[13:36:37.353] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:37.364] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.364] - Validating connection of MultisessionFuture
[13:36:37.364] - received message: FutureResult
[13:36:37.364] - Received FutureResult
[13:36:37.364] - Erased future from FutureRegistry
[13:36:37.364] result() for ClusterFuture ...
[13:36:37.364] - result already collected: FutureResult
[13:36:37.365] result() for ClusterFuture ... done
[13:36:37.365] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.365] result() for ClusterFuture ...
[13:36:37.365] - result already collected: FutureResult
[13:36:37.365] result() for ClusterFuture ... done
[13:36:37.365] result() for ClusterFuture ...
[13:36:37.365] - result already collected: FutureResult
[13:36:37.365] result() for ClusterFuture ... done
[13:36:37.366] MultisessionFuture started
[13:36:37.366] - Launch lazy future ... done
[13:36:37.366] run() for ‘MultisessionFuture’ ... done
<environment: 0x564a7505d180> 
<environment: 0x564a71b36a38> 
[13:36:37.368] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.368] - Validating connection of MultisessionFuture
[13:36:37.368] - received message: FutureResult
[13:36:37.368] - Received FutureResult
[13:36:37.369] - Erased future from FutureRegistry
[13:36:37.369] result() for ClusterFuture ...
[13:36:37.369] - result already collected: FutureResult
[13:36:37.369] result() for ClusterFuture ... done
[13:36:37.369] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:37.369] receiveMessageFromWorker() for ClusterFuture ...
[13:36:37.369] - Validating connection of MultisessionFuture
[13:36:37.370] - received message: FutureResult
[13:36:37.370] - Received FutureResult
[13:36:37.370] - Erased future from FutureRegistry
[13:36:37.370] result() for ClusterFuture ...
[13:36:37.370] - result already collected: FutureResult
[13:36:37.370] result() for ClusterFuture ... done
[13:36:37.370] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:36:37.371] resolve() on environment ...
[13:36:37.371]  recursive: 0
[13:36:37.372]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:36:37.372] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.372] - nx: 4
[13:36:37.372] - relay: TRUE
[13:36:37.372] - stdout: TRUE
[13:36:37.372] - signal: TRUE
[13:36:37.372] - resignal: FALSE
[13:36:37.373] - force: TRUE
[13:36:37.373] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.373] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.373]  - until=2
[13:36:37.373]  - relaying element #2
[13:36:37.373] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.373] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.373] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.373]  length: 3 (resolved future 1)
[13:36:37.373] Future #2
[13:36:37.373] result() for ClusterFuture ...
[13:36:37.374] - result already collected: FutureResult
[13:36:37.374] result() for ClusterFuture ... done
[13:36:37.374] result() for ClusterFuture ...
[13:36:37.374] - result already collected: FutureResult
[13:36:37.374] result() for ClusterFuture ... done
[13:36:37.374] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:37.374] - nx: 4
[13:36:37.374] - relay: TRUE
[13:36:37.374] - stdout: TRUE
[13:36:37.374] - signal: TRUE
[13:36:37.374] - resignal: FALSE
[13:36:37.375] - force: TRUE
[13:36:37.375] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:36:37.375] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:36:37.375]  - until=2
[13:36:37.375]  - relaying element #2
[13:36:37.375] result() for ClusterFuture ...
[13:36:37.375] - result already collected: FutureResult
[13:36:37.375] result() for ClusterFuture ... done
[13:36:37.375] result() for ClusterFuture ...
[13:36:37.375] - result already collected: FutureResult
[13:36:37.375] result() for ClusterFuture ... done
[13:36:37.376] result() for ClusterFuture ...
[13:36:37.376] - result already collected: FutureResult
[13:36:37.376] result() for ClusterFuture ... done
[13:36:37.376] result() for ClusterFuture ...
[13:36:37.376] - result already collected: FutureResult
[13:36:37.376] result() for ClusterFuture ... done
[13:36:37.376] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.376] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.376] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:37.376]  length: 2 (resolved future 2)
[13:36:37.376] Future #3
[13:36:37.377] result() for ClusterFuture ...
[13:36:37.377] - result already collected: FutureResult
[13:36:37.377] result() for ClusterFuture ... done
[13:36:37.377] result() for ClusterFuture ...
[13:36:37.377] - result already collected: FutureResult
[13:36:37.377] result() for ClusterFuture ... done
[13:36:37.377] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:37.377] - nx: 4
[13:36:37.377] - relay: TRUE
[13:36:37.377] - stdout: TRUE
[13:36:37.377] - signal: TRUE
[13:36:37.377] - resignal: FALSE
[13:36:37.377] - force: TRUE
[13:36:37.378] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:36:37.378] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:36:37.378]  - until=3
[13:36:37.378]  - relaying element #3
[13:36:37.378] result() for ClusterFuture ...
[13:36:37.378] - result already collected: FutureResult
[13:36:37.378] result() for ClusterFuture ... done
[13:36:37.378] result() for ClusterFuture ...
[13:36:37.378] - result already collected: FutureResult
[13:36:37.378] result() for ClusterFuture ... done
[13:36:37.379] result() for ClusterFuture ...
[13:36:37.379] - result already collected: FutureResult
[13:36:37.379] result() for ClusterFuture ... done
[13:36:37.379] result() for ClusterFuture ...
[13:36:37.379] - result already collected: FutureResult
[13:36:37.379] result() for ClusterFuture ... done
[13:36:37.379] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.379] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.379] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:37.379]  length: 1 (resolved future 3)
[13:36:37.379] Future #4
[13:36:37.379] result() for ClusterFuture ...
[13:36:37.380] - result already collected: FutureResult
[13:36:37.380] result() for ClusterFuture ... done
[13:36:37.380] result() for ClusterFuture ...
[13:36:37.380] - result already collected: FutureResult
[13:36:37.380] result() for ClusterFuture ... done
[13:36:37.380] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:37.380] - nx: 4
[13:36:37.380] - relay: TRUE
[13:36:37.380] - stdout: TRUE
[13:36:37.380] - signal: TRUE
[13:36:37.380] - resignal: FALSE
[13:36:37.381] - force: TRUE
[13:36:37.381] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:36:37.381] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:36:37.381]  - until=4
[13:36:37.381]  - relaying element #4
[13:36:37.381] result() for ClusterFuture ...
[13:36:37.381] - result already collected: FutureResult
[13:36:37.381] result() for ClusterFuture ... done
[13:36:37.381] result() for ClusterFuture ...
[13:36:37.381] - result already collected: FutureResult
[13:36:37.381] result() for ClusterFuture ... done
[13:36:37.381] result() for ClusterFuture ...
[13:36:37.382] - result already collected: FutureResult
[13:36:37.382] result() for ClusterFuture ... done
[13:36:37.382] result() for ClusterFuture ...
[13:36:37.382] - result already collected: FutureResult
[13:36:37.382] result() for ClusterFuture ... done
[13:36:37.382] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.382] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.382] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:37.382]  length: 0 (resolved future 4)
[13:36:37.382] Relaying remaining futures
[13:36:37.382] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.383] - nx: 4
[13:36:37.383] - relay: TRUE
[13:36:37.383] - stdout: TRUE
[13:36:37.383] - signal: TRUE
[13:36:37.383] - resignal: FALSE
[13:36:37.383] - force: TRUE
[13:36:37.383] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.383] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:36:37.383] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:36:37.383] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:36:37.383] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.383] resolve() on environment ... DONE
[13:36:37.384] result() for ClusterFuture ...
[13:36:37.384] - result already collected: FutureResult
[13:36:37.384] result() for ClusterFuture ... done
[13:36:37.384] result() for ClusterFuture ...
[13:36:37.384] - result already collected: FutureResult
[13:36:37.384] result() for ClusterFuture ... done
[13:36:37.384] result() for ClusterFuture ...
[13:36:37.384] - result already collected: FutureResult
[13:36:37.384] result() for ClusterFuture ... done
[13:36:37.384] result() for ClusterFuture ...
[13:36:37.384] - result already collected: FutureResult
[13:36:37.385] result() for ClusterFuture ... done
[13:36:37.385] result() for ClusterFuture ...
[13:36:37.385] - result already collected: FutureResult
[13:36:37.385] result() for ClusterFuture ... done
[13:36:37.385] result() for ClusterFuture ...
[13:36:37.385] - result already collected: FutureResult
[13:36:37.385] result() for ClusterFuture ... done
<environment: 0x564a73c20b30> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[13:36:37.386] plan(): Setting new future strategy stack:
[13:36:37.386] List of future strategies:
[13:36:37.386] 1. multicore:
[13:36:37.386]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.386]    - tweaked: FALSE
[13:36:37.386]    - call: plan(strategy)
[13:36:37.390] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:36:37.391] getGlobalsAndPackages() ...
[13:36:37.391] Searching for globals...
[13:36:37.391] 
[13:36:37.392] Searching for globals ... DONE
[13:36:37.392] - globals: [0] <none>
[13:36:37.392] getGlobalsAndPackages() ... DONE
[13:36:37.392] run() for ‘Future’ ...
[13:36:37.392] - state: ‘created’
[13:36:37.392] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.397] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.397]   - Field: ‘label’
[13:36:37.397]   - Field: ‘local’
[13:36:37.397]   - Field: ‘owner’
[13:36:37.397]   - Field: ‘envir’
[13:36:37.397]   - Field: ‘workers’
[13:36:37.398]   - Field: ‘packages’
[13:36:37.398]   - Field: ‘gc’
[13:36:37.398]   - Field: ‘job’
[13:36:37.398]   - Field: ‘conditions’
[13:36:37.398]   - Field: ‘expr’
[13:36:37.398]   - Field: ‘uuid’
[13:36:37.398]   - Field: ‘seed’
[13:36:37.398]   - Field: ‘version’
[13:36:37.398]   - Field: ‘result’
[13:36:37.398]   - Field: ‘asynchronous’
[13:36:37.399]   - Field: ‘calls’
[13:36:37.399]   - Field: ‘globals’
[13:36:37.399]   - Field: ‘stdout’
[13:36:37.399]   - Field: ‘earlySignal’
[13:36:37.399]   - Field: ‘lazy’
[13:36:37.399]   - Field: ‘state’
[13:36:37.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.399] - Launch lazy future ...
[13:36:37.399] Packages needed by the future expression (n = 0): <none>
[13:36:37.400] Packages needed by future strategies (n = 0): <none>
[13:36:37.400] {
[13:36:37.400]     {
[13:36:37.400]         {
[13:36:37.400]             ...future.startTime <- base::Sys.time()
[13:36:37.400]             {
[13:36:37.400]                 {
[13:36:37.400]                   {
[13:36:37.400]                     {
[13:36:37.400]                       base::local({
[13:36:37.400]                         has_future <- base::requireNamespace("future", 
[13:36:37.400]                           quietly = TRUE)
[13:36:37.400]                         if (has_future) {
[13:36:37.400]                           ns <- base::getNamespace("future")
[13:36:37.400]                           version <- ns[[".package"]][["version"]]
[13:36:37.400]                           if (is.null(version)) 
[13:36:37.400]                             version <- utils::packageVersion("future")
[13:36:37.400]                         }
[13:36:37.400]                         else {
[13:36:37.400]                           version <- NULL
[13:36:37.400]                         }
[13:36:37.400]                         if (!has_future || version < "1.8.0") {
[13:36:37.400]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.400]                             "", base::R.version$version.string), 
[13:36:37.400]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.400]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.400]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.400]                               "release", "version")], collapse = " "), 
[13:36:37.400]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.400]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.400]                             info)
[13:36:37.400]                           info <- base::paste(info, collapse = "; ")
[13:36:37.400]                           if (!has_future) {
[13:36:37.400]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.400]                               info)
[13:36:37.400]                           }
[13:36:37.400]                           else {
[13:36:37.400]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.400]                               info, version)
[13:36:37.400]                           }
[13:36:37.400]                           base::stop(msg)
[13:36:37.400]                         }
[13:36:37.400]                       })
[13:36:37.400]                     }
[13:36:37.400]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.400]                     base::options(mc.cores = 1L)
[13:36:37.400]                   }
[13:36:37.400]                   ...future.strategy.old <- future::plan("list")
[13:36:37.400]                   options(future.plan = NULL)
[13:36:37.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.400]                 }
[13:36:37.400]                 ...future.workdir <- getwd()
[13:36:37.400]             }
[13:36:37.400]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.400]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.400]         }
[13:36:37.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.400]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.400]             base::names(...future.oldOptions))
[13:36:37.400]     }
[13:36:37.400]     if (FALSE) {
[13:36:37.400]     }
[13:36:37.400]     else {
[13:36:37.400]         if (TRUE) {
[13:36:37.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.400]                 open = "w")
[13:36:37.400]         }
[13:36:37.400]         else {
[13:36:37.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.400]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.400]         }
[13:36:37.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.400]             base::sink(type = "output", split = FALSE)
[13:36:37.400]             base::close(...future.stdout)
[13:36:37.400]         }, add = TRUE)
[13:36:37.400]     }
[13:36:37.400]     ...future.frame <- base::sys.nframe()
[13:36:37.400]     ...future.conditions <- base::list()
[13:36:37.400]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.400]     if (FALSE) {
[13:36:37.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.400]     }
[13:36:37.400]     ...future.result <- base::tryCatch({
[13:36:37.400]         base::withCallingHandlers({
[13:36:37.400]             ...future.value <- base::withVisible(base::local({
[13:36:37.400]                 withCallingHandlers({
[13:36:37.400]                   2
[13:36:37.400]                 }, immediateCondition = function(cond) {
[13:36:37.400]                   save_rds <- function (object, pathname, ...) 
[13:36:37.400]                   {
[13:36:37.400]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.400]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.400]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.400]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.400]                         fi_tmp[["mtime"]])
[13:36:37.400]                     }
[13:36:37.400]                     tryCatch({
[13:36:37.400]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.400]                     }, error = function(ex) {
[13:36:37.400]                       msg <- conditionMessage(ex)
[13:36:37.400]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.400]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.400]                         fi_tmp[["mtime"]], msg)
[13:36:37.400]                       ex$message <- msg
[13:36:37.400]                       stop(ex)
[13:36:37.400]                     })
[13:36:37.400]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.400]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.400]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.400]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.400]                       fi <- file.info(pathname)
[13:36:37.400]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.400]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.400]                         fi[["size"]], fi[["mtime"]])
[13:36:37.400]                       stop(msg)
[13:36:37.400]                     }
[13:36:37.400]                     invisible(pathname)
[13:36:37.400]                   }
[13:36:37.400]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.400]                     rootPath = tempdir()) 
[13:36:37.400]                   {
[13:36:37.400]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.400]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.400]                       tmpdir = path, fileext = ".rds")
[13:36:37.400]                     save_rds(obj, file)
[13:36:37.400]                   }
[13:36:37.400]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.400]                   {
[13:36:37.400]                     inherits <- base::inherits
[13:36:37.400]                     invokeRestart <- base::invokeRestart
[13:36:37.400]                     is.null <- base::is.null
[13:36:37.400]                     muffled <- FALSE
[13:36:37.400]                     if (inherits(cond, "message")) {
[13:36:37.400]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.400]                       if (muffled) 
[13:36:37.400]                         invokeRestart("muffleMessage")
[13:36:37.400]                     }
[13:36:37.400]                     else if (inherits(cond, "warning")) {
[13:36:37.400]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.400]                       if (muffled) 
[13:36:37.400]                         invokeRestart("muffleWarning")
[13:36:37.400]                     }
[13:36:37.400]                     else if (inherits(cond, "condition")) {
[13:36:37.400]                       if (!is.null(pattern)) {
[13:36:37.400]                         computeRestarts <- base::computeRestarts
[13:36:37.400]                         grepl <- base::grepl
[13:36:37.400]                         restarts <- computeRestarts(cond)
[13:36:37.400]                         for (restart in restarts) {
[13:36:37.400]                           name <- restart$name
[13:36:37.400]                           if (is.null(name)) 
[13:36:37.400]                             next
[13:36:37.400]                           if (!grepl(pattern, name)) 
[13:36:37.400]                             next
[13:36:37.400]                           invokeRestart(restart)
[13:36:37.400]                           muffled <- TRUE
[13:36:37.400]                           break
[13:36:37.400]                         }
[13:36:37.400]                       }
[13:36:37.400]                     }
[13:36:37.400]                     invisible(muffled)
[13:36:37.400]                   }
[13:36:37.400]                   muffleCondition(cond)
[13:36:37.400]                 })
[13:36:37.400]             }))
[13:36:37.400]             future::FutureResult(value = ...future.value$value, 
[13:36:37.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.400]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.400]                     ...future.globalenv.names))
[13:36:37.400]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.400]         }, condition = base::local({
[13:36:37.400]             c <- base::c
[13:36:37.400]             inherits <- base::inherits
[13:36:37.400]             invokeRestart <- base::invokeRestart
[13:36:37.400]             length <- base::length
[13:36:37.400]             list <- base::list
[13:36:37.400]             seq.int <- base::seq.int
[13:36:37.400]             signalCondition <- base::signalCondition
[13:36:37.400]             sys.calls <- base::sys.calls
[13:36:37.400]             `[[` <- base::`[[`
[13:36:37.400]             `+` <- base::`+`
[13:36:37.400]             `<<-` <- base::`<<-`
[13:36:37.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.400]                   3L)]
[13:36:37.400]             }
[13:36:37.400]             function(cond) {
[13:36:37.400]                 is_error <- inherits(cond, "error")
[13:36:37.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.400]                   NULL)
[13:36:37.400]                 if (is_error) {
[13:36:37.400]                   sessionInformation <- function() {
[13:36:37.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.400]                       search = base::search(), system = base::Sys.info())
[13:36:37.400]                   }
[13:36:37.400]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.400]                     cond$call), session = sessionInformation(), 
[13:36:37.400]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.400]                   signalCondition(cond)
[13:36:37.400]                 }
[13:36:37.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.400]                 "immediateCondition"))) {
[13:36:37.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.400]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.400]                   if (TRUE && !signal) {
[13:36:37.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.400]                     {
[13:36:37.400]                       inherits <- base::inherits
[13:36:37.400]                       invokeRestart <- base::invokeRestart
[13:36:37.400]                       is.null <- base::is.null
[13:36:37.400]                       muffled <- FALSE
[13:36:37.400]                       if (inherits(cond, "message")) {
[13:36:37.400]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.400]                         if (muffled) 
[13:36:37.400]                           invokeRestart("muffleMessage")
[13:36:37.400]                       }
[13:36:37.400]                       else if (inherits(cond, "warning")) {
[13:36:37.400]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.400]                         if (muffled) 
[13:36:37.400]                           invokeRestart("muffleWarning")
[13:36:37.400]                       }
[13:36:37.400]                       else if (inherits(cond, "condition")) {
[13:36:37.400]                         if (!is.null(pattern)) {
[13:36:37.400]                           computeRestarts <- base::computeRestarts
[13:36:37.400]                           grepl <- base::grepl
[13:36:37.400]                           restarts <- computeRestarts(cond)
[13:36:37.400]                           for (restart in restarts) {
[13:36:37.400]                             name <- restart$name
[13:36:37.400]                             if (is.null(name)) 
[13:36:37.400]                               next
[13:36:37.400]                             if (!grepl(pattern, name)) 
[13:36:37.400]                               next
[13:36:37.400]                             invokeRestart(restart)
[13:36:37.400]                             muffled <- TRUE
[13:36:37.400]                             break
[13:36:37.400]                           }
[13:36:37.400]                         }
[13:36:37.400]                       }
[13:36:37.400]                       invisible(muffled)
[13:36:37.400]                     }
[13:36:37.400]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.400]                   }
[13:36:37.400]                 }
[13:36:37.400]                 else {
[13:36:37.400]                   if (TRUE) {
[13:36:37.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.400]                     {
[13:36:37.400]                       inherits <- base::inherits
[13:36:37.400]                       invokeRestart <- base::invokeRestart
[13:36:37.400]                       is.null <- base::is.null
[13:36:37.400]                       muffled <- FALSE
[13:36:37.400]                       if (inherits(cond, "message")) {
[13:36:37.400]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.400]                         if (muffled) 
[13:36:37.400]                           invokeRestart("muffleMessage")
[13:36:37.400]                       }
[13:36:37.400]                       else if (inherits(cond, "warning")) {
[13:36:37.400]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.400]                         if (muffled) 
[13:36:37.400]                           invokeRestart("muffleWarning")
[13:36:37.400]                       }
[13:36:37.400]                       else if (inherits(cond, "condition")) {
[13:36:37.400]                         if (!is.null(pattern)) {
[13:36:37.400]                           computeRestarts <- base::computeRestarts
[13:36:37.400]                           grepl <- base::grepl
[13:36:37.400]                           restarts <- computeRestarts(cond)
[13:36:37.400]                           for (restart in restarts) {
[13:36:37.400]                             name <- restart$name
[13:36:37.400]                             if (is.null(name)) 
[13:36:37.400]                               next
[13:36:37.400]                             if (!grepl(pattern, name)) 
[13:36:37.400]                               next
[13:36:37.400]                             invokeRestart(restart)
[13:36:37.400]                             muffled <- TRUE
[13:36:37.400]                             break
[13:36:37.400]                           }
[13:36:37.400]                         }
[13:36:37.400]                       }
[13:36:37.400]                       invisible(muffled)
[13:36:37.400]                     }
[13:36:37.400]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.400]                   }
[13:36:37.400]                 }
[13:36:37.400]             }
[13:36:37.400]         }))
[13:36:37.400]     }, error = function(ex) {
[13:36:37.400]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.400]                 ...future.rng), started = ...future.startTime, 
[13:36:37.400]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.400]             version = "1.8"), class = "FutureResult")
[13:36:37.400]     }, finally = {
[13:36:37.400]         if (!identical(...future.workdir, getwd())) 
[13:36:37.400]             setwd(...future.workdir)
[13:36:37.400]         {
[13:36:37.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.400]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.400]             }
[13:36:37.400]             base::options(...future.oldOptions)
[13:36:37.400]             if (.Platform$OS.type == "windows") {
[13:36:37.400]                 old_names <- names(...future.oldEnvVars)
[13:36:37.400]                 envs <- base::Sys.getenv()
[13:36:37.400]                 names <- names(envs)
[13:36:37.400]                 common <- intersect(names, old_names)
[13:36:37.400]                 added <- setdiff(names, old_names)
[13:36:37.400]                 removed <- setdiff(old_names, names)
[13:36:37.400]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.400]                   envs[common]]
[13:36:37.400]                 NAMES <- toupper(changed)
[13:36:37.400]                 args <- list()
[13:36:37.400]                 for (kk in seq_along(NAMES)) {
[13:36:37.400]                   name <- changed[[kk]]
[13:36:37.400]                   NAME <- NAMES[[kk]]
[13:36:37.400]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.400]                     next
[13:36:37.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.400]                 }
[13:36:37.400]                 NAMES <- toupper(added)
[13:36:37.400]                 for (kk in seq_along(NAMES)) {
[13:36:37.400]                   name <- added[[kk]]
[13:36:37.400]                   NAME <- NAMES[[kk]]
[13:36:37.400]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.400]                     next
[13:36:37.400]                   args[[name]] <- ""
[13:36:37.400]                 }
[13:36:37.400]                 NAMES <- toupper(removed)
[13:36:37.400]                 for (kk in seq_along(NAMES)) {
[13:36:37.400]                   name <- removed[[kk]]
[13:36:37.400]                   NAME <- NAMES[[kk]]
[13:36:37.400]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.400]                     next
[13:36:37.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.400]                 }
[13:36:37.400]                 if (length(args) > 0) 
[13:36:37.400]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.400]             }
[13:36:37.400]             else {
[13:36:37.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.400]             }
[13:36:37.400]             {
[13:36:37.400]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.400]                   0L) {
[13:36:37.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.400]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.400]                   base::options(opts)
[13:36:37.400]                 }
[13:36:37.400]                 {
[13:36:37.400]                   {
[13:36:37.400]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.400]                     NULL
[13:36:37.400]                   }
[13:36:37.400]                   options(future.plan = NULL)
[13:36:37.400]                   if (is.na(NA_character_)) 
[13:36:37.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.400]                     .init = FALSE)
[13:36:37.400]                 }
[13:36:37.400]             }
[13:36:37.400]         }
[13:36:37.400]     })
[13:36:37.400]     if (TRUE) {
[13:36:37.400]         base::sink(type = "output", split = FALSE)
[13:36:37.400]         if (TRUE) {
[13:36:37.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.400]         }
[13:36:37.400]         else {
[13:36:37.400]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.400]         }
[13:36:37.400]         base::close(...future.stdout)
[13:36:37.400]         ...future.stdout <- NULL
[13:36:37.400]     }
[13:36:37.400]     ...future.result$conditions <- ...future.conditions
[13:36:37.400]     ...future.result$finished <- base::Sys.time()
[13:36:37.400]     ...future.result
[13:36:37.400] }
[13:36:37.402] requestCore(): workers = 2
[13:36:37.405] MulticoreFuture started
[13:36:37.405] - Launch lazy future ... done
[13:36:37.405] run() for ‘MulticoreFuture’ ... done
[13:36:37.406] getGlobalsAndPackages() ...
[13:36:37.406] Searching for globals...
[13:36:37.406] plan(): Setting new future strategy stack:
[13:36:37.406] List of future strategies:
[13:36:37.406] 1. sequential:
[13:36:37.406]    - args: function (..., envir = parent.frame())
[13:36:37.406]    - tweaked: FALSE
[13:36:37.406]    - call: NULL
[13:36:37.407] 
[13:36:37.407] Searching for globals ... DONE
[13:36:37.407] plan(): nbrOfWorkers() = 1
[13:36:37.407] - globals: [0] <none>
[13:36:37.407] getGlobalsAndPackages() ... DONE
[13:36:37.408] run() for ‘Future’ ...
[13:36:37.408] - state: ‘created’
[13:36:37.408] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.409] plan(): Setting new future strategy stack:
[13:36:37.409] List of future strategies:
[13:36:37.409] 1. multicore:
[13:36:37.409]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.409]    - tweaked: FALSE
[13:36:37.409]    - call: plan(strategy)
[13:36:37.413] plan(): nbrOfWorkers() = 2
[13:36:37.413] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.414]   - Field: ‘label’
[13:36:37.414]   - Field: ‘local’
[13:36:37.414]   - Field: ‘owner’
[13:36:37.414]   - Field: ‘envir’
[13:36:37.414]   - Field: ‘workers’
[13:36:37.414]   - Field: ‘packages’
[13:36:37.415]   - Field: ‘gc’
[13:36:37.415]   - Field: ‘job’
[13:36:37.415]   - Field: ‘conditions’
[13:36:37.415]   - Field: ‘expr’
[13:36:37.415]   - Field: ‘uuid’
[13:36:37.415]   - Field: ‘seed’
[13:36:37.415]   - Field: ‘version’
[13:36:37.416]   - Field: ‘result’
[13:36:37.416]   - Field: ‘asynchronous’
[13:36:37.416]   - Field: ‘calls’
[13:36:37.416]   - Field: ‘globals’
[13:36:37.416]   - Field: ‘stdout’
[13:36:37.416]   - Field: ‘earlySignal’
[13:36:37.416]   - Field: ‘lazy’
[13:36:37.417]   - Field: ‘state’
[13:36:37.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.417] - Launch lazy future ...
[13:36:37.417] Packages needed by the future expression (n = 0): <none>
[13:36:37.417] Packages needed by future strategies (n = 0): <none>
[13:36:37.418] {
[13:36:37.418]     {
[13:36:37.418]         {
[13:36:37.418]             ...future.startTime <- base::Sys.time()
[13:36:37.418]             {
[13:36:37.418]                 {
[13:36:37.418]                   {
[13:36:37.418]                     {
[13:36:37.418]                       base::local({
[13:36:37.418]                         has_future <- base::requireNamespace("future", 
[13:36:37.418]                           quietly = TRUE)
[13:36:37.418]                         if (has_future) {
[13:36:37.418]                           ns <- base::getNamespace("future")
[13:36:37.418]                           version <- ns[[".package"]][["version"]]
[13:36:37.418]                           if (is.null(version)) 
[13:36:37.418]                             version <- utils::packageVersion("future")
[13:36:37.418]                         }
[13:36:37.418]                         else {
[13:36:37.418]                           version <- NULL
[13:36:37.418]                         }
[13:36:37.418]                         if (!has_future || version < "1.8.0") {
[13:36:37.418]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.418]                             "", base::R.version$version.string), 
[13:36:37.418]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.418]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.418]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.418]                               "release", "version")], collapse = " "), 
[13:36:37.418]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.418]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.418]                             info)
[13:36:37.418]                           info <- base::paste(info, collapse = "; ")
[13:36:37.418]                           if (!has_future) {
[13:36:37.418]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.418]                               info)
[13:36:37.418]                           }
[13:36:37.418]                           else {
[13:36:37.418]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.418]                               info, version)
[13:36:37.418]                           }
[13:36:37.418]                           base::stop(msg)
[13:36:37.418]                         }
[13:36:37.418]                       })
[13:36:37.418]                     }
[13:36:37.418]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.418]                     base::options(mc.cores = 1L)
[13:36:37.418]                   }
[13:36:37.418]                   ...future.strategy.old <- future::plan("list")
[13:36:37.418]                   options(future.plan = NULL)
[13:36:37.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.418]                 }
[13:36:37.418]                 ...future.workdir <- getwd()
[13:36:37.418]             }
[13:36:37.418]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.418]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.418]         }
[13:36:37.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.418]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.418]             base::names(...future.oldOptions))
[13:36:37.418]     }
[13:36:37.418]     if (FALSE) {
[13:36:37.418]     }
[13:36:37.418]     else {
[13:36:37.418]         if (TRUE) {
[13:36:37.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.418]                 open = "w")
[13:36:37.418]         }
[13:36:37.418]         else {
[13:36:37.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.418]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.418]         }
[13:36:37.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.418]             base::sink(type = "output", split = FALSE)
[13:36:37.418]             base::close(...future.stdout)
[13:36:37.418]         }, add = TRUE)
[13:36:37.418]     }
[13:36:37.418]     ...future.frame <- base::sys.nframe()
[13:36:37.418]     ...future.conditions <- base::list()
[13:36:37.418]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.418]     if (FALSE) {
[13:36:37.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.418]     }
[13:36:37.418]     ...future.result <- base::tryCatch({
[13:36:37.418]         base::withCallingHandlers({
[13:36:37.418]             ...future.value <- base::withVisible(base::local({
[13:36:37.418]                 withCallingHandlers({
[13:36:37.418]                   NULL
[13:36:37.418]                 }, immediateCondition = function(cond) {
[13:36:37.418]                   save_rds <- function (object, pathname, ...) 
[13:36:37.418]                   {
[13:36:37.418]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.418]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.418]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.418]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.418]                         fi_tmp[["mtime"]])
[13:36:37.418]                     }
[13:36:37.418]                     tryCatch({
[13:36:37.418]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.418]                     }, error = function(ex) {
[13:36:37.418]                       msg <- conditionMessage(ex)
[13:36:37.418]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.418]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.418]                         fi_tmp[["mtime"]], msg)
[13:36:37.418]                       ex$message <- msg
[13:36:37.418]                       stop(ex)
[13:36:37.418]                     })
[13:36:37.418]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.418]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.418]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.418]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.418]                       fi <- file.info(pathname)
[13:36:37.418]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.418]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.418]                         fi[["size"]], fi[["mtime"]])
[13:36:37.418]                       stop(msg)
[13:36:37.418]                     }
[13:36:37.418]                     invisible(pathname)
[13:36:37.418]                   }
[13:36:37.418]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.418]                     rootPath = tempdir()) 
[13:36:37.418]                   {
[13:36:37.418]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.418]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.418]                       tmpdir = path, fileext = ".rds")
[13:36:37.418]                     save_rds(obj, file)
[13:36:37.418]                   }
[13:36:37.418]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.418]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.418]                   {
[13:36:37.418]                     inherits <- base::inherits
[13:36:37.418]                     invokeRestart <- base::invokeRestart
[13:36:37.418]                     is.null <- base::is.null
[13:36:37.418]                     muffled <- FALSE
[13:36:37.418]                     if (inherits(cond, "message")) {
[13:36:37.418]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.418]                       if (muffled) 
[13:36:37.418]                         invokeRestart("muffleMessage")
[13:36:37.418]                     }
[13:36:37.418]                     else if (inherits(cond, "warning")) {
[13:36:37.418]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.418]                       if (muffled) 
[13:36:37.418]                         invokeRestart("muffleWarning")
[13:36:37.418]                     }
[13:36:37.418]                     else if (inherits(cond, "condition")) {
[13:36:37.418]                       if (!is.null(pattern)) {
[13:36:37.418]                         computeRestarts <- base::computeRestarts
[13:36:37.418]                         grepl <- base::grepl
[13:36:37.418]                         restarts <- computeRestarts(cond)
[13:36:37.418]                         for (restart in restarts) {
[13:36:37.418]                           name <- restart$name
[13:36:37.418]                           if (is.null(name)) 
[13:36:37.418]                             next
[13:36:37.418]                           if (!grepl(pattern, name)) 
[13:36:37.418]                             next
[13:36:37.418]                           invokeRestart(restart)
[13:36:37.418]                           muffled <- TRUE
[13:36:37.418]                           break
[13:36:37.418]                         }
[13:36:37.418]                       }
[13:36:37.418]                     }
[13:36:37.418]                     invisible(muffled)
[13:36:37.418]                   }
[13:36:37.418]                   muffleCondition(cond)
[13:36:37.418]                 })
[13:36:37.418]             }))
[13:36:37.418]             future::FutureResult(value = ...future.value$value, 
[13:36:37.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.418]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.418]                     ...future.globalenv.names))
[13:36:37.418]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.418]         }, condition = base::local({
[13:36:37.418]             c <- base::c
[13:36:37.418]             inherits <- base::inherits
[13:36:37.418]             invokeRestart <- base::invokeRestart
[13:36:37.418]             length <- base::length
[13:36:37.418]             list <- base::list
[13:36:37.418]             seq.int <- base::seq.int
[13:36:37.418]             signalCondition <- base::signalCondition
[13:36:37.418]             sys.calls <- base::sys.calls
[13:36:37.418]             `[[` <- base::`[[`
[13:36:37.418]             `+` <- base::`+`
[13:36:37.418]             `<<-` <- base::`<<-`
[13:36:37.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.418]                   3L)]
[13:36:37.418]             }
[13:36:37.418]             function(cond) {
[13:36:37.418]                 is_error <- inherits(cond, "error")
[13:36:37.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.418]                   NULL)
[13:36:37.418]                 if (is_error) {
[13:36:37.418]                   sessionInformation <- function() {
[13:36:37.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.418]                       search = base::search(), system = base::Sys.info())
[13:36:37.418]                   }
[13:36:37.418]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.418]                     cond$call), session = sessionInformation(), 
[13:36:37.418]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.418]                   signalCondition(cond)
[13:36:37.418]                 }
[13:36:37.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.418]                 "immediateCondition"))) {
[13:36:37.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.418]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.418]                   if (TRUE && !signal) {
[13:36:37.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.418]                     {
[13:36:37.418]                       inherits <- base::inherits
[13:36:37.418]                       invokeRestart <- base::invokeRestart
[13:36:37.418]                       is.null <- base::is.null
[13:36:37.418]                       muffled <- FALSE
[13:36:37.418]                       if (inherits(cond, "message")) {
[13:36:37.418]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.418]                         if (muffled) 
[13:36:37.418]                           invokeRestart("muffleMessage")
[13:36:37.418]                       }
[13:36:37.418]                       else if (inherits(cond, "warning")) {
[13:36:37.418]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.418]                         if (muffled) 
[13:36:37.418]                           invokeRestart("muffleWarning")
[13:36:37.418]                       }
[13:36:37.418]                       else if (inherits(cond, "condition")) {
[13:36:37.418]                         if (!is.null(pattern)) {
[13:36:37.418]                           computeRestarts <- base::computeRestarts
[13:36:37.418]                           grepl <- base::grepl
[13:36:37.418]                           restarts <- computeRestarts(cond)
[13:36:37.418]                           for (restart in restarts) {
[13:36:37.418]                             name <- restart$name
[13:36:37.418]                             if (is.null(name)) 
[13:36:37.418]                               next
[13:36:37.418]                             if (!grepl(pattern, name)) 
[13:36:37.418]                               next
[13:36:37.418]                             invokeRestart(restart)
[13:36:37.418]                             muffled <- TRUE
[13:36:37.418]                             break
[13:36:37.418]                           }
[13:36:37.418]                         }
[13:36:37.418]                       }
[13:36:37.418]                       invisible(muffled)
[13:36:37.418]                     }
[13:36:37.418]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.418]                   }
[13:36:37.418]                 }
[13:36:37.418]                 else {
[13:36:37.418]                   if (TRUE) {
[13:36:37.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.418]                     {
[13:36:37.418]                       inherits <- base::inherits
[13:36:37.418]                       invokeRestart <- base::invokeRestart
[13:36:37.418]                       is.null <- base::is.null
[13:36:37.418]                       muffled <- FALSE
[13:36:37.418]                       if (inherits(cond, "message")) {
[13:36:37.418]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.418]                         if (muffled) 
[13:36:37.418]                           invokeRestart("muffleMessage")
[13:36:37.418]                       }
[13:36:37.418]                       else if (inherits(cond, "warning")) {
[13:36:37.418]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.418]                         if (muffled) 
[13:36:37.418]                           invokeRestart("muffleWarning")
[13:36:37.418]                       }
[13:36:37.418]                       else if (inherits(cond, "condition")) {
[13:36:37.418]                         if (!is.null(pattern)) {
[13:36:37.418]                           computeRestarts <- base::computeRestarts
[13:36:37.418]                           grepl <- base::grepl
[13:36:37.418]                           restarts <- computeRestarts(cond)
[13:36:37.418]                           for (restart in restarts) {
[13:36:37.418]                             name <- restart$name
[13:36:37.418]                             if (is.null(name)) 
[13:36:37.418]                               next
[13:36:37.418]                             if (!grepl(pattern, name)) 
[13:36:37.418]                               next
[13:36:37.418]                             invokeRestart(restart)
[13:36:37.418]                             muffled <- TRUE
[13:36:37.418]                             break
[13:36:37.418]                           }
[13:36:37.418]                         }
[13:36:37.418]                       }
[13:36:37.418]                       invisible(muffled)
[13:36:37.418]                     }
[13:36:37.418]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.418]                   }
[13:36:37.418]                 }
[13:36:37.418]             }
[13:36:37.418]         }))
[13:36:37.418]     }, error = function(ex) {
[13:36:37.418]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.418]                 ...future.rng), started = ...future.startTime, 
[13:36:37.418]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.418]             version = "1.8"), class = "FutureResult")
[13:36:37.418]     }, finally = {
[13:36:37.418]         if (!identical(...future.workdir, getwd())) 
[13:36:37.418]             setwd(...future.workdir)
[13:36:37.418]         {
[13:36:37.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.418]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.418]             }
[13:36:37.418]             base::options(...future.oldOptions)
[13:36:37.418]             if (.Platform$OS.type == "windows") {
[13:36:37.418]                 old_names <- names(...future.oldEnvVars)
[13:36:37.418]                 envs <- base::Sys.getenv()
[13:36:37.418]                 names <- names(envs)
[13:36:37.418]                 common <- intersect(names, old_names)
[13:36:37.418]                 added <- setdiff(names, old_names)
[13:36:37.418]                 removed <- setdiff(old_names, names)
[13:36:37.418]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.418]                   envs[common]]
[13:36:37.418]                 NAMES <- toupper(changed)
[13:36:37.418]                 args <- list()
[13:36:37.418]                 for (kk in seq_along(NAMES)) {
[13:36:37.418]                   name <- changed[[kk]]
[13:36:37.418]                   NAME <- NAMES[[kk]]
[13:36:37.418]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.418]                     next
[13:36:37.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.418]                 }
[13:36:37.418]                 NAMES <- toupper(added)
[13:36:37.418]                 for (kk in seq_along(NAMES)) {
[13:36:37.418]                   name <- added[[kk]]
[13:36:37.418]                   NAME <- NAMES[[kk]]
[13:36:37.418]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.418]                     next
[13:36:37.418]                   args[[name]] <- ""
[13:36:37.418]                 }
[13:36:37.418]                 NAMES <- toupper(removed)
[13:36:37.418]                 for (kk in seq_along(NAMES)) {
[13:36:37.418]                   name <- removed[[kk]]
[13:36:37.418]                   NAME <- NAMES[[kk]]
[13:36:37.418]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.418]                     next
[13:36:37.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.418]                 }
[13:36:37.418]                 if (length(args) > 0) 
[13:36:37.418]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.418]             }
[13:36:37.418]             else {
[13:36:37.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.418]             }
[13:36:37.418]             {
[13:36:37.418]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.418]                   0L) {
[13:36:37.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.418]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.418]                   base::options(opts)
[13:36:37.418]                 }
[13:36:37.418]                 {
[13:36:37.418]                   {
[13:36:37.418]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.418]                     NULL
[13:36:37.418]                   }
[13:36:37.418]                   options(future.plan = NULL)
[13:36:37.418]                   if (is.na(NA_character_)) 
[13:36:37.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.418]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.418]                     .init = FALSE)
[13:36:37.418]                 }
[13:36:37.418]             }
[13:36:37.418]         }
[13:36:37.418]     })
[13:36:37.418]     if (TRUE) {
[13:36:37.418]         base::sink(type = "output", split = FALSE)
[13:36:37.418]         if (TRUE) {
[13:36:37.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.418]         }
[13:36:37.418]         else {
[13:36:37.418]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.418]         }
[13:36:37.418]         base::close(...future.stdout)
[13:36:37.418]         ...future.stdout <- NULL
[13:36:37.418]     }
[13:36:37.418]     ...future.result$conditions <- ...future.conditions
[13:36:37.418]     ...future.result$finished <- base::Sys.time()
[13:36:37.418]     ...future.result
[13:36:37.418] }
[13:36:37.421] requestCore(): workers = 2
[13:36:37.424] MulticoreFuture started
[13:36:37.424] - Launch lazy future ... done
[13:36:37.425] run() for ‘MulticoreFuture’ ... done
[13:36:37.425] plan(): Setting new future strategy stack:
[13:36:37.426] getGlobalsAndPackages() ...
[13:36:37.426] Searching for globals...
[13:36:37.425] List of future strategies:
[13:36:37.425] 1. sequential:
[13:36:37.425]    - args: function (..., envir = parent.frame())
[13:36:37.425]    - tweaked: FALSE
[13:36:37.425]    - call: NULL
[13:36:37.426] plan(): nbrOfWorkers() = 1
[13:36:37.427] - globals found: [1] ‘{’
[13:36:37.427] Searching for globals ... DONE
[13:36:37.428] Resolving globals: FALSE
[13:36:37.428] 
[13:36:37.428] plan(): Setting new future strategy stack:
[13:36:37.428] 
[13:36:37.428] getGlobalsAndPackages() ... DONE
[13:36:37.428] List of future strategies:
[13:36:37.428] 1. multicore:
[13:36:37.428]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.428]    - tweaked: FALSE
[13:36:37.428]    - call: plan(strategy)
[13:36:37.429] run() for ‘Future’ ...
[13:36:37.429] - state: ‘created’
[13:36:37.429] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.434] plan(): nbrOfWorkers() = 2
[13:36:37.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.435]   - Field: ‘label’
[13:36:37.435]   - Field: ‘local’
[13:36:37.435]   - Field: ‘owner’
[13:36:37.435]   - Field: ‘envir’
[13:36:37.435]   - Field: ‘workers’
[13:36:37.436]   - Field: ‘packages’
[13:36:37.436]   - Field: ‘gc’
[13:36:37.436]   - Field: ‘job’
[13:36:37.436]   - Field: ‘conditions’
[13:36:37.436]   - Field: ‘expr’
[13:36:37.436]   - Field: ‘uuid’
[13:36:37.436]   - Field: ‘seed’
[13:36:37.437]   - Field: ‘version’
[13:36:37.437]   - Field: ‘result’
[13:36:37.437]   - Field: ‘asynchronous’
[13:36:37.437]   - Field: ‘calls’
[13:36:37.437]   - Field: ‘globals’
[13:36:37.437]   - Field: ‘stdout’
[13:36:37.437]   - Field: ‘earlySignal’
[13:36:37.437]   - Field: ‘lazy’
[13:36:37.438]   - Field: ‘state’
[13:36:37.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.438] - Launch lazy future ...
[13:36:37.438] Packages needed by the future expression (n = 0): <none>
[13:36:37.439] Packages needed by future strategies (n = 0): <none>
[13:36:37.439] {
[13:36:37.439]     {
[13:36:37.439]         {
[13:36:37.439]             ...future.startTime <- base::Sys.time()
[13:36:37.439]             {
[13:36:37.439]                 {
[13:36:37.439]                   {
[13:36:37.439]                     {
[13:36:37.439]                       base::local({
[13:36:37.439]                         has_future <- base::requireNamespace("future", 
[13:36:37.439]                           quietly = TRUE)
[13:36:37.439]                         if (has_future) {
[13:36:37.439]                           ns <- base::getNamespace("future")
[13:36:37.439]                           version <- ns[[".package"]][["version"]]
[13:36:37.439]                           if (is.null(version)) 
[13:36:37.439]                             version <- utils::packageVersion("future")
[13:36:37.439]                         }
[13:36:37.439]                         else {
[13:36:37.439]                           version <- NULL
[13:36:37.439]                         }
[13:36:37.439]                         if (!has_future || version < "1.8.0") {
[13:36:37.439]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.439]                             "", base::R.version$version.string), 
[13:36:37.439]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.439]                               "release", "version")], collapse = " "), 
[13:36:37.439]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.439]                             info)
[13:36:37.439]                           info <- base::paste(info, collapse = "; ")
[13:36:37.439]                           if (!has_future) {
[13:36:37.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.439]                               info)
[13:36:37.439]                           }
[13:36:37.439]                           else {
[13:36:37.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.439]                               info, version)
[13:36:37.439]                           }
[13:36:37.439]                           base::stop(msg)
[13:36:37.439]                         }
[13:36:37.439]                       })
[13:36:37.439]                     }
[13:36:37.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.439]                     base::options(mc.cores = 1L)
[13:36:37.439]                   }
[13:36:37.439]                   ...future.strategy.old <- future::plan("list")
[13:36:37.439]                   options(future.plan = NULL)
[13:36:37.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.439]                 }
[13:36:37.439]                 ...future.workdir <- getwd()
[13:36:37.439]             }
[13:36:37.439]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.439]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.439]         }
[13:36:37.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.439]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.439]             base::names(...future.oldOptions))
[13:36:37.439]     }
[13:36:37.439]     if (FALSE) {
[13:36:37.439]     }
[13:36:37.439]     else {
[13:36:37.439]         if (TRUE) {
[13:36:37.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.439]                 open = "w")
[13:36:37.439]         }
[13:36:37.439]         else {
[13:36:37.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.439]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.439]         }
[13:36:37.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.439]             base::sink(type = "output", split = FALSE)
[13:36:37.439]             base::close(...future.stdout)
[13:36:37.439]         }, add = TRUE)
[13:36:37.439]     }
[13:36:37.439]     ...future.frame <- base::sys.nframe()
[13:36:37.439]     ...future.conditions <- base::list()
[13:36:37.439]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.439]     if (FALSE) {
[13:36:37.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.439]     }
[13:36:37.439]     ...future.result <- base::tryCatch({
[13:36:37.439]         base::withCallingHandlers({
[13:36:37.439]             ...future.value <- base::withVisible(base::local({
[13:36:37.439]                 withCallingHandlers({
[13:36:37.439]                   {
[13:36:37.439]                     4
[13:36:37.439]                   }
[13:36:37.439]                 }, immediateCondition = function(cond) {
[13:36:37.439]                   save_rds <- function (object, pathname, ...) 
[13:36:37.439]                   {
[13:36:37.439]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.439]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.439]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.439]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.439]                         fi_tmp[["mtime"]])
[13:36:37.439]                     }
[13:36:37.439]                     tryCatch({
[13:36:37.439]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.439]                     }, error = function(ex) {
[13:36:37.439]                       msg <- conditionMessage(ex)
[13:36:37.439]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.439]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.439]                         fi_tmp[["mtime"]], msg)
[13:36:37.439]                       ex$message <- msg
[13:36:37.439]                       stop(ex)
[13:36:37.439]                     })
[13:36:37.439]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.439]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.439]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.439]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.439]                       fi <- file.info(pathname)
[13:36:37.439]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.439]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.439]                         fi[["size"]], fi[["mtime"]])
[13:36:37.439]                       stop(msg)
[13:36:37.439]                     }
[13:36:37.439]                     invisible(pathname)
[13:36:37.439]                   }
[13:36:37.439]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.439]                     rootPath = tempdir()) 
[13:36:37.439]                   {
[13:36:37.439]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.439]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.439]                       tmpdir = path, fileext = ".rds")
[13:36:37.439]                     save_rds(obj, file)
[13:36:37.439]                   }
[13:36:37.439]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.439]                   {
[13:36:37.439]                     inherits <- base::inherits
[13:36:37.439]                     invokeRestart <- base::invokeRestart
[13:36:37.439]                     is.null <- base::is.null
[13:36:37.439]                     muffled <- FALSE
[13:36:37.439]                     if (inherits(cond, "message")) {
[13:36:37.439]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.439]                       if (muffled) 
[13:36:37.439]                         invokeRestart("muffleMessage")
[13:36:37.439]                     }
[13:36:37.439]                     else if (inherits(cond, "warning")) {
[13:36:37.439]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.439]                       if (muffled) 
[13:36:37.439]                         invokeRestart("muffleWarning")
[13:36:37.439]                     }
[13:36:37.439]                     else if (inherits(cond, "condition")) {
[13:36:37.439]                       if (!is.null(pattern)) {
[13:36:37.439]                         computeRestarts <- base::computeRestarts
[13:36:37.439]                         grepl <- base::grepl
[13:36:37.439]                         restarts <- computeRestarts(cond)
[13:36:37.439]                         for (restart in restarts) {
[13:36:37.439]                           name <- restart$name
[13:36:37.439]                           if (is.null(name)) 
[13:36:37.439]                             next
[13:36:37.439]                           if (!grepl(pattern, name)) 
[13:36:37.439]                             next
[13:36:37.439]                           invokeRestart(restart)
[13:36:37.439]                           muffled <- TRUE
[13:36:37.439]                           break
[13:36:37.439]                         }
[13:36:37.439]                       }
[13:36:37.439]                     }
[13:36:37.439]                     invisible(muffled)
[13:36:37.439]                   }
[13:36:37.439]                   muffleCondition(cond)
[13:36:37.439]                 })
[13:36:37.439]             }))
[13:36:37.439]             future::FutureResult(value = ...future.value$value, 
[13:36:37.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.439]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.439]                     ...future.globalenv.names))
[13:36:37.439]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.439]         }, condition = base::local({
[13:36:37.439]             c <- base::c
[13:36:37.439]             inherits <- base::inherits
[13:36:37.439]             invokeRestart <- base::invokeRestart
[13:36:37.439]             length <- base::length
[13:36:37.439]             list <- base::list
[13:36:37.439]             seq.int <- base::seq.int
[13:36:37.439]             signalCondition <- base::signalCondition
[13:36:37.439]             sys.calls <- base::sys.calls
[13:36:37.439]             `[[` <- base::`[[`
[13:36:37.439]             `+` <- base::`+`
[13:36:37.439]             `<<-` <- base::`<<-`
[13:36:37.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.439]                   3L)]
[13:36:37.439]             }
[13:36:37.439]             function(cond) {
[13:36:37.439]                 is_error <- inherits(cond, "error")
[13:36:37.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.439]                   NULL)
[13:36:37.439]                 if (is_error) {
[13:36:37.439]                   sessionInformation <- function() {
[13:36:37.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.439]                       search = base::search(), system = base::Sys.info())
[13:36:37.439]                   }
[13:36:37.439]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.439]                     cond$call), session = sessionInformation(), 
[13:36:37.439]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.439]                   signalCondition(cond)
[13:36:37.439]                 }
[13:36:37.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.439]                 "immediateCondition"))) {
[13:36:37.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.439]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.439]                   if (TRUE && !signal) {
[13:36:37.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.439]                     {
[13:36:37.439]                       inherits <- base::inherits
[13:36:37.439]                       invokeRestart <- base::invokeRestart
[13:36:37.439]                       is.null <- base::is.null
[13:36:37.439]                       muffled <- FALSE
[13:36:37.439]                       if (inherits(cond, "message")) {
[13:36:37.439]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.439]                         if (muffled) 
[13:36:37.439]                           invokeRestart("muffleMessage")
[13:36:37.439]                       }
[13:36:37.439]                       else if (inherits(cond, "warning")) {
[13:36:37.439]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.439]                         if (muffled) 
[13:36:37.439]                           invokeRestart("muffleWarning")
[13:36:37.439]                       }
[13:36:37.439]                       else if (inherits(cond, "condition")) {
[13:36:37.439]                         if (!is.null(pattern)) {
[13:36:37.439]                           computeRestarts <- base::computeRestarts
[13:36:37.439]                           grepl <- base::grepl
[13:36:37.439]                           restarts <- computeRestarts(cond)
[13:36:37.439]                           for (restart in restarts) {
[13:36:37.439]                             name <- restart$name
[13:36:37.439]                             if (is.null(name)) 
[13:36:37.439]                               next
[13:36:37.439]                             if (!grepl(pattern, name)) 
[13:36:37.439]                               next
[13:36:37.439]                             invokeRestart(restart)
[13:36:37.439]                             muffled <- TRUE
[13:36:37.439]                             break
[13:36:37.439]                           }
[13:36:37.439]                         }
[13:36:37.439]                       }
[13:36:37.439]                       invisible(muffled)
[13:36:37.439]                     }
[13:36:37.439]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.439]                   }
[13:36:37.439]                 }
[13:36:37.439]                 else {
[13:36:37.439]                   if (TRUE) {
[13:36:37.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.439]                     {
[13:36:37.439]                       inherits <- base::inherits
[13:36:37.439]                       invokeRestart <- base::invokeRestart
[13:36:37.439]                       is.null <- base::is.null
[13:36:37.439]                       muffled <- FALSE
[13:36:37.439]                       if (inherits(cond, "message")) {
[13:36:37.439]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.439]                         if (muffled) 
[13:36:37.439]                           invokeRestart("muffleMessage")
[13:36:37.439]                       }
[13:36:37.439]                       else if (inherits(cond, "warning")) {
[13:36:37.439]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.439]                         if (muffled) 
[13:36:37.439]                           invokeRestart("muffleWarning")
[13:36:37.439]                       }
[13:36:37.439]                       else if (inherits(cond, "condition")) {
[13:36:37.439]                         if (!is.null(pattern)) {
[13:36:37.439]                           computeRestarts <- base::computeRestarts
[13:36:37.439]                           grepl <- base::grepl
[13:36:37.439]                           restarts <- computeRestarts(cond)
[13:36:37.439]                           for (restart in restarts) {
[13:36:37.439]                             name <- restart$name
[13:36:37.439]                             if (is.null(name)) 
[13:36:37.439]                               next
[13:36:37.439]                             if (!grepl(pattern, name)) 
[13:36:37.439]                               next
[13:36:37.439]                             invokeRestart(restart)
[13:36:37.439]                             muffled <- TRUE
[13:36:37.439]                             break
[13:36:37.439]                           }
[13:36:37.439]                         }
[13:36:37.439]                       }
[13:36:37.439]                       invisible(muffled)
[13:36:37.439]                     }
[13:36:37.439]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.439]                   }
[13:36:37.439]                 }
[13:36:37.439]             }
[13:36:37.439]         }))
[13:36:37.439]     }, error = function(ex) {
[13:36:37.439]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.439]                 ...future.rng), started = ...future.startTime, 
[13:36:37.439]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.439]             version = "1.8"), class = "FutureResult")
[13:36:37.439]     }, finally = {
[13:36:37.439]         if (!identical(...future.workdir, getwd())) 
[13:36:37.439]             setwd(...future.workdir)
[13:36:37.439]         {
[13:36:37.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.439]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.439]             }
[13:36:37.439]             base::options(...future.oldOptions)
[13:36:37.439]             if (.Platform$OS.type == "windows") {
[13:36:37.439]                 old_names <- names(...future.oldEnvVars)
[13:36:37.439]                 envs <- base::Sys.getenv()
[13:36:37.439]                 names <- names(envs)
[13:36:37.439]                 common <- intersect(names, old_names)
[13:36:37.439]                 added <- setdiff(names, old_names)
[13:36:37.439]                 removed <- setdiff(old_names, names)
[13:36:37.439]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.439]                   envs[common]]
[13:36:37.439]                 NAMES <- toupper(changed)
[13:36:37.439]                 args <- list()
[13:36:37.439]                 for (kk in seq_along(NAMES)) {
[13:36:37.439]                   name <- changed[[kk]]
[13:36:37.439]                   NAME <- NAMES[[kk]]
[13:36:37.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.439]                     next
[13:36:37.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.439]                 }
[13:36:37.439]                 NAMES <- toupper(added)
[13:36:37.439]                 for (kk in seq_along(NAMES)) {
[13:36:37.439]                   name <- added[[kk]]
[13:36:37.439]                   NAME <- NAMES[[kk]]
[13:36:37.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.439]                     next
[13:36:37.439]                   args[[name]] <- ""
[13:36:37.439]                 }
[13:36:37.439]                 NAMES <- toupper(removed)
[13:36:37.439]                 for (kk in seq_along(NAMES)) {
[13:36:37.439]                   name <- removed[[kk]]
[13:36:37.439]                   NAME <- NAMES[[kk]]
[13:36:37.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.439]                     next
[13:36:37.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.439]                 }
[13:36:37.439]                 if (length(args) > 0) 
[13:36:37.439]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.439]             }
[13:36:37.439]             else {
[13:36:37.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.439]             }
[13:36:37.439]             {
[13:36:37.439]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.439]                   0L) {
[13:36:37.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.439]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.439]                   base::options(opts)
[13:36:37.439]                 }
[13:36:37.439]                 {
[13:36:37.439]                   {
[13:36:37.439]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.439]                     NULL
[13:36:37.439]                   }
[13:36:37.439]                   options(future.plan = NULL)
[13:36:37.439]                   if (is.na(NA_character_)) 
[13:36:37.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.439]                     .init = FALSE)
[13:36:37.439]                 }
[13:36:37.439]             }
[13:36:37.439]         }
[13:36:37.439]     })
[13:36:37.439]     if (TRUE) {
[13:36:37.439]         base::sink(type = "output", split = FALSE)
[13:36:37.439]         if (TRUE) {
[13:36:37.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.439]         }
[13:36:37.439]         else {
[13:36:37.439]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.439]         }
[13:36:37.439]         base::close(...future.stdout)
[13:36:37.439]         ...future.stdout <- NULL
[13:36:37.439]     }
[13:36:37.439]     ...future.result$conditions <- ...future.conditions
[13:36:37.439]     ...future.result$finished <- base::Sys.time()
[13:36:37.439]     ...future.result
[13:36:37.439] }
[13:36:37.451] requestCore(): workers = 2
[13:36:37.451] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:37.462] result() for MulticoreFuture ...
[13:36:37.463] result() for MulticoreFuture ...
[13:36:37.463] result() for MulticoreFuture ... done
[13:36:37.464] result() for MulticoreFuture ... done
[13:36:37.464] result() for MulticoreFuture ...
[13:36:37.464] result() for MulticoreFuture ... done
[13:36:37.467] MulticoreFuture started
[13:36:37.468] - Launch lazy future ... done
[13:36:37.468] run() for ‘MulticoreFuture’ ... done
[13:36:37.469] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x564a74822df8> 
[13:36:37.469] List of future strategies:
[13:36:37.469] 1. sequential:
[13:36:37.469]    - args: function (..., envir = parent.frame())
[13:36:37.469]    - tweaked: FALSE
[13:36:37.469]    - call: NULL
[13:36:37.470] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x564a73829c10> 
[13:36:37.472] plan(): Setting new future strategy stack:
[13:36:37.472] List of future strategies:
[13:36:37.472] 1. multicore:
[13:36:37.472]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.472]    - tweaked: FALSE
[13:36:37.472]    - call: plan(strategy)
[13:36:37.477] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:37.480] resolve() on list environment ...
[13:36:37.481]  recursive: 0
[13:36:37.482]  length: 6
[13:36:37.482]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:37.482] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.483] - nx: 6
[13:36:37.483] - relay: TRUE
[13:36:37.483] - stdout: TRUE
[13:36:37.483] - signal: TRUE
[13:36:37.483] - resignal: FALSE
[13:36:37.483] - force: TRUE
[13:36:37.483] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.483] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.484]  - until=2
[13:36:37.484]  - relaying element #2
[13:36:37.484] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.484] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.484] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.484]  length: 5 (resolved future 1)
[13:36:37.485] Future #2
[13:36:37.485] result() for MulticoreFuture ...
[13:36:37.485] result() for MulticoreFuture ... done
[13:36:37.485] result() for MulticoreFuture ...
[13:36:37.485] result() for MulticoreFuture ... done
[13:36:37.485] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:37.485] - nx: 6
[13:36:37.486] - relay: TRUE
[13:36:37.486] - stdout: TRUE
[13:36:37.486] - signal: TRUE
[13:36:37.486] - resignal: FALSE
[13:36:37.486] - force: TRUE
[13:36:37.486] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.486] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.486]  - until=2
[13:36:37.487]  - relaying element #2
[13:36:37.487] result() for MulticoreFuture ...
[13:36:37.487] result() for MulticoreFuture ... done
[13:36:37.487] result() for MulticoreFuture ...
[13:36:37.487] result() for MulticoreFuture ... done
[13:36:37.487] result() for MulticoreFuture ...
[13:36:37.487] result() for MulticoreFuture ... done
[13:36:37.488] result() for MulticoreFuture ...
[13:36:37.488] result() for MulticoreFuture ... done
[13:36:37.488] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.488] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.488] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:37.488]  length: 4 (resolved future 2)
[13:36:37.489] Future #3
[13:36:37.489] result() for MulticoreFuture ...
[13:36:37.490] result() for MulticoreFuture ...
[13:36:37.490] result() for MulticoreFuture ... done
[13:36:37.490] result() for MulticoreFuture ... done
[13:36:37.490] result() for MulticoreFuture ...
[13:36:37.490] result() for MulticoreFuture ... done
[13:36:37.491] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:37.491] - nx: 6
[13:36:37.491] - relay: TRUE
[13:36:37.491] - stdout: TRUE
[13:36:37.491] - signal: TRUE
[13:36:37.491] - resignal: FALSE
[13:36:37.492] - force: TRUE
[13:36:37.492] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.492] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.492]  - until=3
[13:36:37.492]  - relaying element #3
[13:36:37.492] result() for MulticoreFuture ...
[13:36:37.493] result() for MulticoreFuture ... done
[13:36:37.493] result() for MulticoreFuture ...
[13:36:37.493] result() for MulticoreFuture ... done
[13:36:37.493] result() for MulticoreFuture ...
[13:36:37.493] result() for MulticoreFuture ... done
[13:36:37.494] result() for MulticoreFuture ...
[13:36:37.494] result() for MulticoreFuture ... done
[13:36:37.494] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.494] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:37.495]  length: 3 (resolved future 3)
[13:36:37.495] Future #4
[13:36:37.495] result() for MulticoreFuture ...
[13:36:37.496] result() for MulticoreFuture ...
[13:36:37.496] result() for MulticoreFuture ... done
[13:36:37.496] result() for MulticoreFuture ... done
[13:36:37.496] result() for MulticoreFuture ...
[13:36:37.496] result() for MulticoreFuture ... done
[13:36:37.496] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:37.497] - nx: 6
[13:36:37.497] - relay: TRUE
[13:36:37.497] - stdout: TRUE
[13:36:37.497] - signal: TRUE
[13:36:37.497] - resignal: FALSE
[13:36:37.497] - force: TRUE
[13:36:37.497] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.497] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.498]  - until=4
[13:36:37.498]  - relaying element #4
[13:36:37.498] result() for MulticoreFuture ...
[13:36:37.498] result() for MulticoreFuture ... done
[13:36:37.498] result() for MulticoreFuture ...
[13:36:37.498] result() for MulticoreFuture ... done
[13:36:37.498] result() for MulticoreFuture ...
[13:36:37.498] result() for MulticoreFuture ... done
[13:36:37.499] result() for MulticoreFuture ...
[13:36:37.499] result() for MulticoreFuture ... done
[13:36:37.499] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.499] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.499] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:37.499]  length: 2 (resolved future 4)
[13:36:37.499] signalConditionsASAP(NULL, pos=5) ...
[13:36:37.499] - nx: 6
[13:36:37.499] - relay: TRUE
[13:36:37.500] - stdout: TRUE
[13:36:37.500] - signal: TRUE
[13:36:37.500] - resignal: FALSE
[13:36:37.500] - force: TRUE
[13:36:37.500] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.500] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.500]  - until=6
[13:36:37.500]  - relaying element #6
[13:36:37.500] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.501] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.501] signalConditionsASAP(NULL, pos=5) ... done
[13:36:37.501]  length: 1 (resolved future 5)
[13:36:37.501] signalConditionsASAP(numeric, pos=6) ...
[13:36:37.501] - nx: 6
[13:36:37.501] - relay: TRUE
[13:36:37.501] - stdout: TRUE
[13:36:37.501] - signal: TRUE
[13:36:37.501] - resignal: FALSE
[13:36:37.502] - force: TRUE
[13:36:37.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.502] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.502]  - until=6
[13:36:37.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.502] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.502] signalConditionsASAP(numeric, pos=6) ... done
[13:36:37.502]  length: 0 (resolved future 6)
[13:36:37.503] Relaying remaining futures
[13:36:37.503] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.503] - nx: 6
[13:36:37.503] - relay: TRUE
[13:36:37.503] - stdout: TRUE
[13:36:37.503] - signal: TRUE
[13:36:37.503] - resignal: FALSE
[13:36:37.503] - force: TRUE
[13:36:37.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.503] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:37.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.504] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.504] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.504] resolve() on list environment ... DONE
[13:36:37.504] result() for MulticoreFuture ...
[13:36:37.504] result() for MulticoreFuture ... done
[13:36:37.505] result() for MulticoreFuture ...
[13:36:37.505] result() for MulticoreFuture ... done
[13:36:37.505] result() for MulticoreFuture ...
[13:36:37.505] result() for MulticoreFuture ... done
[13:36:37.505] result() for MulticoreFuture ...
[13:36:37.505] result() for MulticoreFuture ... done
[13:36:37.505] result() for MulticoreFuture ...
[13:36:37.506] result() for MulticoreFuture ... done
[13:36:37.506] result() for MulticoreFuture ...
[13:36:37.506] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a73576ab0> 
Dimensions: c(1, 6)
[13:36:37.507] getGlobalsAndPackages() ...
[13:36:37.507] Searching for globals...
[13:36:37.507] 
[13:36:37.507] Searching for globals ... DONE
[13:36:37.507] - globals: [0] <none>
[13:36:37.508] getGlobalsAndPackages() ... DONE
[13:36:37.508] run() for ‘Future’ ...
[13:36:37.508] - state: ‘created’
[13:36:37.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.512]   - Field: ‘label’
[13:36:37.513]   - Field: ‘local’
[13:36:37.513]   - Field: ‘owner’
[13:36:37.513]   - Field: ‘envir’
[13:36:37.513]   - Field: ‘workers’
[13:36:37.513]   - Field: ‘packages’
[13:36:37.513]   - Field: ‘gc’
[13:36:37.513]   - Field: ‘job’
[13:36:37.513]   - Field: ‘conditions’
[13:36:37.513]   - Field: ‘expr’
[13:36:37.514]   - Field: ‘uuid’
[13:36:37.514]   - Field: ‘seed’
[13:36:37.514]   - Field: ‘version’
[13:36:37.514]   - Field: ‘result’
[13:36:37.514]   - Field: ‘asynchronous’
[13:36:37.514]   - Field: ‘calls’
[13:36:37.514]   - Field: ‘globals’
[13:36:37.514]   - Field: ‘stdout’
[13:36:37.515]   - Field: ‘earlySignal’
[13:36:37.515]   - Field: ‘lazy’
[13:36:37.515]   - Field: ‘state’
[13:36:37.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.515] - Launch lazy future ...
[13:36:37.515] Packages needed by the future expression (n = 0): <none>
[13:36:37.515] Packages needed by future strategies (n = 0): <none>
[13:36:37.516] {
[13:36:37.516]     {
[13:36:37.516]         {
[13:36:37.516]             ...future.startTime <- base::Sys.time()
[13:36:37.516]             {
[13:36:37.516]                 {
[13:36:37.516]                   {
[13:36:37.516]                     {
[13:36:37.516]                       base::local({
[13:36:37.516]                         has_future <- base::requireNamespace("future", 
[13:36:37.516]                           quietly = TRUE)
[13:36:37.516]                         if (has_future) {
[13:36:37.516]                           ns <- base::getNamespace("future")
[13:36:37.516]                           version <- ns[[".package"]][["version"]]
[13:36:37.516]                           if (is.null(version)) 
[13:36:37.516]                             version <- utils::packageVersion("future")
[13:36:37.516]                         }
[13:36:37.516]                         else {
[13:36:37.516]                           version <- NULL
[13:36:37.516]                         }
[13:36:37.516]                         if (!has_future || version < "1.8.0") {
[13:36:37.516]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.516]                             "", base::R.version$version.string), 
[13:36:37.516]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.516]                               "release", "version")], collapse = " "), 
[13:36:37.516]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.516]                             info)
[13:36:37.516]                           info <- base::paste(info, collapse = "; ")
[13:36:37.516]                           if (!has_future) {
[13:36:37.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.516]                               info)
[13:36:37.516]                           }
[13:36:37.516]                           else {
[13:36:37.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.516]                               info, version)
[13:36:37.516]                           }
[13:36:37.516]                           base::stop(msg)
[13:36:37.516]                         }
[13:36:37.516]                       })
[13:36:37.516]                     }
[13:36:37.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.516]                     base::options(mc.cores = 1L)
[13:36:37.516]                   }
[13:36:37.516]                   ...future.strategy.old <- future::plan("list")
[13:36:37.516]                   options(future.plan = NULL)
[13:36:37.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.516]                 }
[13:36:37.516]                 ...future.workdir <- getwd()
[13:36:37.516]             }
[13:36:37.516]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.516]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.516]         }
[13:36:37.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.516]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.516]             base::names(...future.oldOptions))
[13:36:37.516]     }
[13:36:37.516]     if (FALSE) {
[13:36:37.516]     }
[13:36:37.516]     else {
[13:36:37.516]         if (TRUE) {
[13:36:37.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.516]                 open = "w")
[13:36:37.516]         }
[13:36:37.516]         else {
[13:36:37.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.516]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.516]         }
[13:36:37.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.516]             base::sink(type = "output", split = FALSE)
[13:36:37.516]             base::close(...future.stdout)
[13:36:37.516]         }, add = TRUE)
[13:36:37.516]     }
[13:36:37.516]     ...future.frame <- base::sys.nframe()
[13:36:37.516]     ...future.conditions <- base::list()
[13:36:37.516]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.516]     if (FALSE) {
[13:36:37.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.516]     }
[13:36:37.516]     ...future.result <- base::tryCatch({
[13:36:37.516]         base::withCallingHandlers({
[13:36:37.516]             ...future.value <- base::withVisible(base::local({
[13:36:37.516]                 withCallingHandlers({
[13:36:37.516]                   2
[13:36:37.516]                 }, immediateCondition = function(cond) {
[13:36:37.516]                   save_rds <- function (object, pathname, ...) 
[13:36:37.516]                   {
[13:36:37.516]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.516]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.516]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.516]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.516]                         fi_tmp[["mtime"]])
[13:36:37.516]                     }
[13:36:37.516]                     tryCatch({
[13:36:37.516]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.516]                     }, error = function(ex) {
[13:36:37.516]                       msg <- conditionMessage(ex)
[13:36:37.516]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.516]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.516]                         fi_tmp[["mtime"]], msg)
[13:36:37.516]                       ex$message <- msg
[13:36:37.516]                       stop(ex)
[13:36:37.516]                     })
[13:36:37.516]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.516]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.516]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.516]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.516]                       fi <- file.info(pathname)
[13:36:37.516]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.516]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.516]                         fi[["size"]], fi[["mtime"]])
[13:36:37.516]                       stop(msg)
[13:36:37.516]                     }
[13:36:37.516]                     invisible(pathname)
[13:36:37.516]                   }
[13:36:37.516]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.516]                     rootPath = tempdir()) 
[13:36:37.516]                   {
[13:36:37.516]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.516]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.516]                       tmpdir = path, fileext = ".rds")
[13:36:37.516]                     save_rds(obj, file)
[13:36:37.516]                   }
[13:36:37.516]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.516]                   {
[13:36:37.516]                     inherits <- base::inherits
[13:36:37.516]                     invokeRestart <- base::invokeRestart
[13:36:37.516]                     is.null <- base::is.null
[13:36:37.516]                     muffled <- FALSE
[13:36:37.516]                     if (inherits(cond, "message")) {
[13:36:37.516]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.516]                       if (muffled) 
[13:36:37.516]                         invokeRestart("muffleMessage")
[13:36:37.516]                     }
[13:36:37.516]                     else if (inherits(cond, "warning")) {
[13:36:37.516]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.516]                       if (muffled) 
[13:36:37.516]                         invokeRestart("muffleWarning")
[13:36:37.516]                     }
[13:36:37.516]                     else if (inherits(cond, "condition")) {
[13:36:37.516]                       if (!is.null(pattern)) {
[13:36:37.516]                         computeRestarts <- base::computeRestarts
[13:36:37.516]                         grepl <- base::grepl
[13:36:37.516]                         restarts <- computeRestarts(cond)
[13:36:37.516]                         for (restart in restarts) {
[13:36:37.516]                           name <- restart$name
[13:36:37.516]                           if (is.null(name)) 
[13:36:37.516]                             next
[13:36:37.516]                           if (!grepl(pattern, name)) 
[13:36:37.516]                             next
[13:36:37.516]                           invokeRestart(restart)
[13:36:37.516]                           muffled <- TRUE
[13:36:37.516]                           break
[13:36:37.516]                         }
[13:36:37.516]                       }
[13:36:37.516]                     }
[13:36:37.516]                     invisible(muffled)
[13:36:37.516]                   }
[13:36:37.516]                   muffleCondition(cond)
[13:36:37.516]                 })
[13:36:37.516]             }))
[13:36:37.516]             future::FutureResult(value = ...future.value$value, 
[13:36:37.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.516]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.516]                     ...future.globalenv.names))
[13:36:37.516]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.516]         }, condition = base::local({
[13:36:37.516]             c <- base::c
[13:36:37.516]             inherits <- base::inherits
[13:36:37.516]             invokeRestart <- base::invokeRestart
[13:36:37.516]             length <- base::length
[13:36:37.516]             list <- base::list
[13:36:37.516]             seq.int <- base::seq.int
[13:36:37.516]             signalCondition <- base::signalCondition
[13:36:37.516]             sys.calls <- base::sys.calls
[13:36:37.516]             `[[` <- base::`[[`
[13:36:37.516]             `+` <- base::`+`
[13:36:37.516]             `<<-` <- base::`<<-`
[13:36:37.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.516]                   3L)]
[13:36:37.516]             }
[13:36:37.516]             function(cond) {
[13:36:37.516]                 is_error <- inherits(cond, "error")
[13:36:37.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.516]                   NULL)
[13:36:37.516]                 if (is_error) {
[13:36:37.516]                   sessionInformation <- function() {
[13:36:37.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.516]                       search = base::search(), system = base::Sys.info())
[13:36:37.516]                   }
[13:36:37.516]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.516]                     cond$call), session = sessionInformation(), 
[13:36:37.516]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.516]                   signalCondition(cond)
[13:36:37.516]                 }
[13:36:37.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.516]                 "immediateCondition"))) {
[13:36:37.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.516]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.516]                   if (TRUE && !signal) {
[13:36:37.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.516]                     {
[13:36:37.516]                       inherits <- base::inherits
[13:36:37.516]                       invokeRestart <- base::invokeRestart
[13:36:37.516]                       is.null <- base::is.null
[13:36:37.516]                       muffled <- FALSE
[13:36:37.516]                       if (inherits(cond, "message")) {
[13:36:37.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.516]                         if (muffled) 
[13:36:37.516]                           invokeRestart("muffleMessage")
[13:36:37.516]                       }
[13:36:37.516]                       else if (inherits(cond, "warning")) {
[13:36:37.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.516]                         if (muffled) 
[13:36:37.516]                           invokeRestart("muffleWarning")
[13:36:37.516]                       }
[13:36:37.516]                       else if (inherits(cond, "condition")) {
[13:36:37.516]                         if (!is.null(pattern)) {
[13:36:37.516]                           computeRestarts <- base::computeRestarts
[13:36:37.516]                           grepl <- base::grepl
[13:36:37.516]                           restarts <- computeRestarts(cond)
[13:36:37.516]                           for (restart in restarts) {
[13:36:37.516]                             name <- restart$name
[13:36:37.516]                             if (is.null(name)) 
[13:36:37.516]                               next
[13:36:37.516]                             if (!grepl(pattern, name)) 
[13:36:37.516]                               next
[13:36:37.516]                             invokeRestart(restart)
[13:36:37.516]                             muffled <- TRUE
[13:36:37.516]                             break
[13:36:37.516]                           }
[13:36:37.516]                         }
[13:36:37.516]                       }
[13:36:37.516]                       invisible(muffled)
[13:36:37.516]                     }
[13:36:37.516]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.516]                   }
[13:36:37.516]                 }
[13:36:37.516]                 else {
[13:36:37.516]                   if (TRUE) {
[13:36:37.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.516]                     {
[13:36:37.516]                       inherits <- base::inherits
[13:36:37.516]                       invokeRestart <- base::invokeRestart
[13:36:37.516]                       is.null <- base::is.null
[13:36:37.516]                       muffled <- FALSE
[13:36:37.516]                       if (inherits(cond, "message")) {
[13:36:37.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.516]                         if (muffled) 
[13:36:37.516]                           invokeRestart("muffleMessage")
[13:36:37.516]                       }
[13:36:37.516]                       else if (inherits(cond, "warning")) {
[13:36:37.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.516]                         if (muffled) 
[13:36:37.516]                           invokeRestart("muffleWarning")
[13:36:37.516]                       }
[13:36:37.516]                       else if (inherits(cond, "condition")) {
[13:36:37.516]                         if (!is.null(pattern)) {
[13:36:37.516]                           computeRestarts <- base::computeRestarts
[13:36:37.516]                           grepl <- base::grepl
[13:36:37.516]                           restarts <- computeRestarts(cond)
[13:36:37.516]                           for (restart in restarts) {
[13:36:37.516]                             name <- restart$name
[13:36:37.516]                             if (is.null(name)) 
[13:36:37.516]                               next
[13:36:37.516]                             if (!grepl(pattern, name)) 
[13:36:37.516]                               next
[13:36:37.516]                             invokeRestart(restart)
[13:36:37.516]                             muffled <- TRUE
[13:36:37.516]                             break
[13:36:37.516]                           }
[13:36:37.516]                         }
[13:36:37.516]                       }
[13:36:37.516]                       invisible(muffled)
[13:36:37.516]                     }
[13:36:37.516]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.516]                   }
[13:36:37.516]                 }
[13:36:37.516]             }
[13:36:37.516]         }))
[13:36:37.516]     }, error = function(ex) {
[13:36:37.516]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.516]                 ...future.rng), started = ...future.startTime, 
[13:36:37.516]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.516]             version = "1.8"), class = "FutureResult")
[13:36:37.516]     }, finally = {
[13:36:37.516]         if (!identical(...future.workdir, getwd())) 
[13:36:37.516]             setwd(...future.workdir)
[13:36:37.516]         {
[13:36:37.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.516]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.516]             }
[13:36:37.516]             base::options(...future.oldOptions)
[13:36:37.516]             if (.Platform$OS.type == "windows") {
[13:36:37.516]                 old_names <- names(...future.oldEnvVars)
[13:36:37.516]                 envs <- base::Sys.getenv()
[13:36:37.516]                 names <- names(envs)
[13:36:37.516]                 common <- intersect(names, old_names)
[13:36:37.516]                 added <- setdiff(names, old_names)
[13:36:37.516]                 removed <- setdiff(old_names, names)
[13:36:37.516]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.516]                   envs[common]]
[13:36:37.516]                 NAMES <- toupper(changed)
[13:36:37.516]                 args <- list()
[13:36:37.516]                 for (kk in seq_along(NAMES)) {
[13:36:37.516]                   name <- changed[[kk]]
[13:36:37.516]                   NAME <- NAMES[[kk]]
[13:36:37.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.516]                     next
[13:36:37.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.516]                 }
[13:36:37.516]                 NAMES <- toupper(added)
[13:36:37.516]                 for (kk in seq_along(NAMES)) {
[13:36:37.516]                   name <- added[[kk]]
[13:36:37.516]                   NAME <- NAMES[[kk]]
[13:36:37.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.516]                     next
[13:36:37.516]                   args[[name]] <- ""
[13:36:37.516]                 }
[13:36:37.516]                 NAMES <- toupper(removed)
[13:36:37.516]                 for (kk in seq_along(NAMES)) {
[13:36:37.516]                   name <- removed[[kk]]
[13:36:37.516]                   NAME <- NAMES[[kk]]
[13:36:37.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.516]                     next
[13:36:37.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.516]                 }
[13:36:37.516]                 if (length(args) > 0) 
[13:36:37.516]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.516]             }
[13:36:37.516]             else {
[13:36:37.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.516]             }
[13:36:37.516]             {
[13:36:37.516]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.516]                   0L) {
[13:36:37.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.516]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.516]                   base::options(opts)
[13:36:37.516]                 }
[13:36:37.516]                 {
[13:36:37.516]                   {
[13:36:37.516]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.516]                     NULL
[13:36:37.516]                   }
[13:36:37.516]                   options(future.plan = NULL)
[13:36:37.516]                   if (is.na(NA_character_)) 
[13:36:37.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.516]                     .init = FALSE)
[13:36:37.516]                 }
[13:36:37.516]             }
[13:36:37.516]         }
[13:36:37.516]     })
[13:36:37.516]     if (TRUE) {
[13:36:37.516]         base::sink(type = "output", split = FALSE)
[13:36:37.516]         if (TRUE) {
[13:36:37.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.516]         }
[13:36:37.516]         else {
[13:36:37.516]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.516]         }
[13:36:37.516]         base::close(...future.stdout)
[13:36:37.516]         ...future.stdout <- NULL
[13:36:37.516]     }
[13:36:37.516]     ...future.result$conditions <- ...future.conditions
[13:36:37.516]     ...future.result$finished <- base::Sys.time()
[13:36:37.516]     ...future.result
[13:36:37.516] }
[13:36:37.519] requestCore(): workers = 2
[13:36:37.521] MulticoreFuture started
[13:36:37.521] - Launch lazy future ... done
[13:36:37.521] run() for ‘MulticoreFuture’ ... done
[13:36:37.522] getGlobalsAndPackages() ...
[13:36:37.522] Searching for globals...
[13:36:37.522] plan(): Setting new future strategy stack:
[13:36:37.523] 
[13:36:37.522] List of future strategies:
[13:36:37.522] 1. sequential:
[13:36:37.522]    - args: function (..., envir = parent.frame())
[13:36:37.522]    - tweaked: FALSE
[13:36:37.522]    - call: NULL
[13:36:37.523] Searching for globals ... DONE
[13:36:37.523] plan(): nbrOfWorkers() = 1
[13:36:37.523] - globals: [0] <none>
[13:36:37.523] getGlobalsAndPackages() ... DONE
[13:36:37.524] run() for ‘Future’ ...
[13:36:37.524] - state: ‘created’
[13:36:37.524] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.525] plan(): Setting new future strategy stack:
[13:36:37.525] List of future strategies:
[13:36:37.525] 1. multicore:
[13:36:37.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.525]    - tweaked: FALSE
[13:36:37.525]    - call: plan(strategy)
[13:36:37.529] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.529] plan(): nbrOfWorkers() = 2
[13:36:37.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.530]   - Field: ‘label’
[13:36:37.530]   - Field: ‘local’
[13:36:37.530]   - Field: ‘owner’
[13:36:37.530]   - Field: ‘envir’
[13:36:37.530]   - Field: ‘workers’
[13:36:37.530]   - Field: ‘packages’
[13:36:37.530]   - Field: ‘gc’
[13:36:37.531]   - Field: ‘job’
[13:36:37.531]   - Field: ‘conditions’
[13:36:37.531]   - Field: ‘expr’
[13:36:37.531]   - Field: ‘uuid’
[13:36:37.531]   - Field: ‘seed’
[13:36:37.531]   - Field: ‘version’
[13:36:37.531]   - Field: ‘result’
[13:36:37.531]   - Field: ‘asynchronous’
[13:36:37.532]   - Field: ‘calls’
[13:36:37.532]   - Field: ‘globals’
[13:36:37.532]   - Field: ‘stdout’
[13:36:37.532]   - Field: ‘earlySignal’
[13:36:37.532]   - Field: ‘lazy’
[13:36:37.532]   - Field: ‘state’
[13:36:37.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.533] - Launch lazy future ...
[13:36:37.533] Packages needed by the future expression (n = 0): <none>
[13:36:37.533] Packages needed by future strategies (n = 0): <none>
[13:36:37.534] {
[13:36:37.534]     {
[13:36:37.534]         {
[13:36:37.534]             ...future.startTime <- base::Sys.time()
[13:36:37.534]             {
[13:36:37.534]                 {
[13:36:37.534]                   {
[13:36:37.534]                     {
[13:36:37.534]                       base::local({
[13:36:37.534]                         has_future <- base::requireNamespace("future", 
[13:36:37.534]                           quietly = TRUE)
[13:36:37.534]                         if (has_future) {
[13:36:37.534]                           ns <- base::getNamespace("future")
[13:36:37.534]                           version <- ns[[".package"]][["version"]]
[13:36:37.534]                           if (is.null(version)) 
[13:36:37.534]                             version <- utils::packageVersion("future")
[13:36:37.534]                         }
[13:36:37.534]                         else {
[13:36:37.534]                           version <- NULL
[13:36:37.534]                         }
[13:36:37.534]                         if (!has_future || version < "1.8.0") {
[13:36:37.534]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.534]                             "", base::R.version$version.string), 
[13:36:37.534]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.534]                               "release", "version")], collapse = " "), 
[13:36:37.534]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.534]                             info)
[13:36:37.534]                           info <- base::paste(info, collapse = "; ")
[13:36:37.534]                           if (!has_future) {
[13:36:37.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.534]                               info)
[13:36:37.534]                           }
[13:36:37.534]                           else {
[13:36:37.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.534]                               info, version)
[13:36:37.534]                           }
[13:36:37.534]                           base::stop(msg)
[13:36:37.534]                         }
[13:36:37.534]                       })
[13:36:37.534]                     }
[13:36:37.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.534]                     base::options(mc.cores = 1L)
[13:36:37.534]                   }
[13:36:37.534]                   ...future.strategy.old <- future::plan("list")
[13:36:37.534]                   options(future.plan = NULL)
[13:36:37.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.534]                 }
[13:36:37.534]                 ...future.workdir <- getwd()
[13:36:37.534]             }
[13:36:37.534]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.534]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.534]         }
[13:36:37.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.534]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.534]             base::names(...future.oldOptions))
[13:36:37.534]     }
[13:36:37.534]     if (FALSE) {
[13:36:37.534]     }
[13:36:37.534]     else {
[13:36:37.534]         if (TRUE) {
[13:36:37.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.534]                 open = "w")
[13:36:37.534]         }
[13:36:37.534]         else {
[13:36:37.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.534]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.534]         }
[13:36:37.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.534]             base::sink(type = "output", split = FALSE)
[13:36:37.534]             base::close(...future.stdout)
[13:36:37.534]         }, add = TRUE)
[13:36:37.534]     }
[13:36:37.534]     ...future.frame <- base::sys.nframe()
[13:36:37.534]     ...future.conditions <- base::list()
[13:36:37.534]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.534]     if (FALSE) {
[13:36:37.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.534]     }
[13:36:37.534]     ...future.result <- base::tryCatch({
[13:36:37.534]         base::withCallingHandlers({
[13:36:37.534]             ...future.value <- base::withVisible(base::local({
[13:36:37.534]                 withCallingHandlers({
[13:36:37.534]                   NULL
[13:36:37.534]                 }, immediateCondition = function(cond) {
[13:36:37.534]                   save_rds <- function (object, pathname, ...) 
[13:36:37.534]                   {
[13:36:37.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.534]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.534]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.534]                         fi_tmp[["mtime"]])
[13:36:37.534]                     }
[13:36:37.534]                     tryCatch({
[13:36:37.534]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.534]                     }, error = function(ex) {
[13:36:37.534]                       msg <- conditionMessage(ex)
[13:36:37.534]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.534]                         fi_tmp[["mtime"]], msg)
[13:36:37.534]                       ex$message <- msg
[13:36:37.534]                       stop(ex)
[13:36:37.534]                     })
[13:36:37.534]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.534]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.534]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.534]                       fi <- file.info(pathname)
[13:36:37.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.534]                         fi[["size"]], fi[["mtime"]])
[13:36:37.534]                       stop(msg)
[13:36:37.534]                     }
[13:36:37.534]                     invisible(pathname)
[13:36:37.534]                   }
[13:36:37.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.534]                     rootPath = tempdir()) 
[13:36:37.534]                   {
[13:36:37.534]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.534]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.534]                       tmpdir = path, fileext = ".rds")
[13:36:37.534]                     save_rds(obj, file)
[13:36:37.534]                   }
[13:36:37.534]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.534]                   {
[13:36:37.534]                     inherits <- base::inherits
[13:36:37.534]                     invokeRestart <- base::invokeRestart
[13:36:37.534]                     is.null <- base::is.null
[13:36:37.534]                     muffled <- FALSE
[13:36:37.534]                     if (inherits(cond, "message")) {
[13:36:37.534]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.534]                       if (muffled) 
[13:36:37.534]                         invokeRestart("muffleMessage")
[13:36:37.534]                     }
[13:36:37.534]                     else if (inherits(cond, "warning")) {
[13:36:37.534]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.534]                       if (muffled) 
[13:36:37.534]                         invokeRestart("muffleWarning")
[13:36:37.534]                     }
[13:36:37.534]                     else if (inherits(cond, "condition")) {
[13:36:37.534]                       if (!is.null(pattern)) {
[13:36:37.534]                         computeRestarts <- base::computeRestarts
[13:36:37.534]                         grepl <- base::grepl
[13:36:37.534]                         restarts <- computeRestarts(cond)
[13:36:37.534]                         for (restart in restarts) {
[13:36:37.534]                           name <- restart$name
[13:36:37.534]                           if (is.null(name)) 
[13:36:37.534]                             next
[13:36:37.534]                           if (!grepl(pattern, name)) 
[13:36:37.534]                             next
[13:36:37.534]                           invokeRestart(restart)
[13:36:37.534]                           muffled <- TRUE
[13:36:37.534]                           break
[13:36:37.534]                         }
[13:36:37.534]                       }
[13:36:37.534]                     }
[13:36:37.534]                     invisible(muffled)
[13:36:37.534]                   }
[13:36:37.534]                   muffleCondition(cond)
[13:36:37.534]                 })
[13:36:37.534]             }))
[13:36:37.534]             future::FutureResult(value = ...future.value$value, 
[13:36:37.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.534]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.534]                     ...future.globalenv.names))
[13:36:37.534]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.534]         }, condition = base::local({
[13:36:37.534]             c <- base::c
[13:36:37.534]             inherits <- base::inherits
[13:36:37.534]             invokeRestart <- base::invokeRestart
[13:36:37.534]             length <- base::length
[13:36:37.534]             list <- base::list
[13:36:37.534]             seq.int <- base::seq.int
[13:36:37.534]             signalCondition <- base::signalCondition
[13:36:37.534]             sys.calls <- base::sys.calls
[13:36:37.534]             `[[` <- base::`[[`
[13:36:37.534]             `+` <- base::`+`
[13:36:37.534]             `<<-` <- base::`<<-`
[13:36:37.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.534]                   3L)]
[13:36:37.534]             }
[13:36:37.534]             function(cond) {
[13:36:37.534]                 is_error <- inherits(cond, "error")
[13:36:37.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.534]                   NULL)
[13:36:37.534]                 if (is_error) {
[13:36:37.534]                   sessionInformation <- function() {
[13:36:37.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.534]                       search = base::search(), system = base::Sys.info())
[13:36:37.534]                   }
[13:36:37.534]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.534]                     cond$call), session = sessionInformation(), 
[13:36:37.534]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.534]                   signalCondition(cond)
[13:36:37.534]                 }
[13:36:37.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.534]                 "immediateCondition"))) {
[13:36:37.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.534]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.534]                   if (TRUE && !signal) {
[13:36:37.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.534]                     {
[13:36:37.534]                       inherits <- base::inherits
[13:36:37.534]                       invokeRestart <- base::invokeRestart
[13:36:37.534]                       is.null <- base::is.null
[13:36:37.534]                       muffled <- FALSE
[13:36:37.534]                       if (inherits(cond, "message")) {
[13:36:37.534]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.534]                         if (muffled) 
[13:36:37.534]                           invokeRestart("muffleMessage")
[13:36:37.534]                       }
[13:36:37.534]                       else if (inherits(cond, "warning")) {
[13:36:37.534]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.534]                         if (muffled) 
[13:36:37.534]                           invokeRestart("muffleWarning")
[13:36:37.534]                       }
[13:36:37.534]                       else if (inherits(cond, "condition")) {
[13:36:37.534]                         if (!is.null(pattern)) {
[13:36:37.534]                           computeRestarts <- base::computeRestarts
[13:36:37.534]                           grepl <- base::grepl
[13:36:37.534]                           restarts <- computeRestarts(cond)
[13:36:37.534]                           for (restart in restarts) {
[13:36:37.534]                             name <- restart$name
[13:36:37.534]                             if (is.null(name)) 
[13:36:37.534]                               next
[13:36:37.534]                             if (!grepl(pattern, name)) 
[13:36:37.534]                               next
[13:36:37.534]                             invokeRestart(restart)
[13:36:37.534]                             muffled <- TRUE
[13:36:37.534]                             break
[13:36:37.534]                           }
[13:36:37.534]                         }
[13:36:37.534]                       }
[13:36:37.534]                       invisible(muffled)
[13:36:37.534]                     }
[13:36:37.534]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.534]                   }
[13:36:37.534]                 }
[13:36:37.534]                 else {
[13:36:37.534]                   if (TRUE) {
[13:36:37.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.534]                     {
[13:36:37.534]                       inherits <- base::inherits
[13:36:37.534]                       invokeRestart <- base::invokeRestart
[13:36:37.534]                       is.null <- base::is.null
[13:36:37.534]                       muffled <- FALSE
[13:36:37.534]                       if (inherits(cond, "message")) {
[13:36:37.534]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.534]                         if (muffled) 
[13:36:37.534]                           invokeRestart("muffleMessage")
[13:36:37.534]                       }
[13:36:37.534]                       else if (inherits(cond, "warning")) {
[13:36:37.534]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.534]                         if (muffled) 
[13:36:37.534]                           invokeRestart("muffleWarning")
[13:36:37.534]                       }
[13:36:37.534]                       else if (inherits(cond, "condition")) {
[13:36:37.534]                         if (!is.null(pattern)) {
[13:36:37.534]                           computeRestarts <- base::computeRestarts
[13:36:37.534]                           grepl <- base::grepl
[13:36:37.534]                           restarts <- computeRestarts(cond)
[13:36:37.534]                           for (restart in restarts) {
[13:36:37.534]                             name <- restart$name
[13:36:37.534]                             if (is.null(name)) 
[13:36:37.534]                               next
[13:36:37.534]                             if (!grepl(pattern, name)) 
[13:36:37.534]                               next
[13:36:37.534]                             invokeRestart(restart)
[13:36:37.534]                             muffled <- TRUE
[13:36:37.534]                             break
[13:36:37.534]                           }
[13:36:37.534]                         }
[13:36:37.534]                       }
[13:36:37.534]                       invisible(muffled)
[13:36:37.534]                     }
[13:36:37.534]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.534]                   }
[13:36:37.534]                 }
[13:36:37.534]             }
[13:36:37.534]         }))
[13:36:37.534]     }, error = function(ex) {
[13:36:37.534]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.534]                 ...future.rng), started = ...future.startTime, 
[13:36:37.534]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.534]             version = "1.8"), class = "FutureResult")
[13:36:37.534]     }, finally = {
[13:36:37.534]         if (!identical(...future.workdir, getwd())) 
[13:36:37.534]             setwd(...future.workdir)
[13:36:37.534]         {
[13:36:37.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.534]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.534]             }
[13:36:37.534]             base::options(...future.oldOptions)
[13:36:37.534]             if (.Platform$OS.type == "windows") {
[13:36:37.534]                 old_names <- names(...future.oldEnvVars)
[13:36:37.534]                 envs <- base::Sys.getenv()
[13:36:37.534]                 names <- names(envs)
[13:36:37.534]                 common <- intersect(names, old_names)
[13:36:37.534]                 added <- setdiff(names, old_names)
[13:36:37.534]                 removed <- setdiff(old_names, names)
[13:36:37.534]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.534]                   envs[common]]
[13:36:37.534]                 NAMES <- toupper(changed)
[13:36:37.534]                 args <- list()
[13:36:37.534]                 for (kk in seq_along(NAMES)) {
[13:36:37.534]                   name <- changed[[kk]]
[13:36:37.534]                   NAME <- NAMES[[kk]]
[13:36:37.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.534]                     next
[13:36:37.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.534]                 }
[13:36:37.534]                 NAMES <- toupper(added)
[13:36:37.534]                 for (kk in seq_along(NAMES)) {
[13:36:37.534]                   name <- added[[kk]]
[13:36:37.534]                   NAME <- NAMES[[kk]]
[13:36:37.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.534]                     next
[13:36:37.534]                   args[[name]] <- ""
[13:36:37.534]                 }
[13:36:37.534]                 NAMES <- toupper(removed)
[13:36:37.534]                 for (kk in seq_along(NAMES)) {
[13:36:37.534]                   name <- removed[[kk]]
[13:36:37.534]                   NAME <- NAMES[[kk]]
[13:36:37.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.534]                     next
[13:36:37.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.534]                 }
[13:36:37.534]                 if (length(args) > 0) 
[13:36:37.534]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.534]             }
[13:36:37.534]             else {
[13:36:37.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.534]             }
[13:36:37.534]             {
[13:36:37.534]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.534]                   0L) {
[13:36:37.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.534]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.534]                   base::options(opts)
[13:36:37.534]                 }
[13:36:37.534]                 {
[13:36:37.534]                   {
[13:36:37.534]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.534]                     NULL
[13:36:37.534]                   }
[13:36:37.534]                   options(future.plan = NULL)
[13:36:37.534]                   if (is.na(NA_character_)) 
[13:36:37.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.534]                     .init = FALSE)
[13:36:37.534]                 }
[13:36:37.534]             }
[13:36:37.534]         }
[13:36:37.534]     })
[13:36:37.534]     if (TRUE) {
[13:36:37.534]         base::sink(type = "output", split = FALSE)
[13:36:37.534]         if (TRUE) {
[13:36:37.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.534]         }
[13:36:37.534]         else {
[13:36:37.534]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.534]         }
[13:36:37.534]         base::close(...future.stdout)
[13:36:37.534]         ...future.stdout <- NULL
[13:36:37.534]     }
[13:36:37.534]     ...future.result$conditions <- ...future.conditions
[13:36:37.534]     ...future.result$finished <- base::Sys.time()
[13:36:37.534]     ...future.result
[13:36:37.534] }
[13:36:37.537] requestCore(): workers = 2
[13:36:37.540] MulticoreFuture started
[13:36:37.540] - Launch lazy future ... done
[13:36:37.540] run() for ‘MulticoreFuture’ ... done
[13:36:37.541] plan(): Setting new future strategy stack:
[13:36:37.541] getGlobalsAndPackages() ...
[13:36:37.541] Searching for globals...
[13:36:37.541] List of future strategies:
[13:36:37.541] 1. sequential:
[13:36:37.541]    - args: function (..., envir = parent.frame())
[13:36:37.541]    - tweaked: FALSE
[13:36:37.541]    - call: NULL
[13:36:37.542] plan(): nbrOfWorkers() = 1
[13:36:37.543] - globals found: [1] ‘{’
[13:36:37.543] Searching for globals ... DONE
[13:36:37.543] Resolving globals: FALSE
[13:36:37.544] 
[13:36:37.544] 
[13:36:37.544] getGlobalsAndPackages() ... DONE
[13:36:37.544] plan(): Setting new future strategy stack:
[13:36:37.544] run() for ‘Future’ ...
[13:36:37.544] List of future strategies:
[13:36:37.544] 1. multicore:
[13:36:37.544]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.544]    - tweaked: FALSE
[13:36:37.544]    - call: plan(strategy)
[13:36:37.544] - state: ‘created’
[13:36:37.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.550] plan(): nbrOfWorkers() = 2
[13:36:37.550] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.551]   - Field: ‘label’
[13:36:37.551]   - Field: ‘local’
[13:36:37.551]   - Field: ‘owner’
[13:36:37.551]   - Field: ‘envir’
[13:36:37.551]   - Field: ‘workers’
[13:36:37.551]   - Field: ‘packages’
[13:36:37.551]   - Field: ‘gc’
[13:36:37.552]   - Field: ‘job’
[13:36:37.552]   - Field: ‘conditions’
[13:36:37.552]   - Field: ‘expr’
[13:36:37.552]   - Field: ‘uuid’
[13:36:37.552]   - Field: ‘seed’
[13:36:37.552]   - Field: ‘version’
[13:36:37.552]   - Field: ‘result’
[13:36:37.553]   - Field: ‘asynchronous’
[13:36:37.553]   - Field: ‘calls’
[13:36:37.553]   - Field: ‘globals’
[13:36:37.553]   - Field: ‘stdout’
[13:36:37.553]   - Field: ‘earlySignal’
[13:36:37.553]   - Field: ‘lazy’
[13:36:37.553]   - Field: ‘state’
[13:36:37.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.554] - Launch lazy future ...
[13:36:37.554] Packages needed by the future expression (n = 0): <none>
[13:36:37.554] Packages needed by future strategies (n = 0): <none>
[13:36:37.555] {
[13:36:37.555]     {
[13:36:37.555]         {
[13:36:37.555]             ...future.startTime <- base::Sys.time()
[13:36:37.555]             {
[13:36:37.555]                 {
[13:36:37.555]                   {
[13:36:37.555]                     {
[13:36:37.555]                       base::local({
[13:36:37.555]                         has_future <- base::requireNamespace("future", 
[13:36:37.555]                           quietly = TRUE)
[13:36:37.555]                         if (has_future) {
[13:36:37.555]                           ns <- base::getNamespace("future")
[13:36:37.555]                           version <- ns[[".package"]][["version"]]
[13:36:37.555]                           if (is.null(version)) 
[13:36:37.555]                             version <- utils::packageVersion("future")
[13:36:37.555]                         }
[13:36:37.555]                         else {
[13:36:37.555]                           version <- NULL
[13:36:37.555]                         }
[13:36:37.555]                         if (!has_future || version < "1.8.0") {
[13:36:37.555]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.555]                             "", base::R.version$version.string), 
[13:36:37.555]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.555]                               "release", "version")], collapse = " "), 
[13:36:37.555]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.555]                             info)
[13:36:37.555]                           info <- base::paste(info, collapse = "; ")
[13:36:37.555]                           if (!has_future) {
[13:36:37.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.555]                               info)
[13:36:37.555]                           }
[13:36:37.555]                           else {
[13:36:37.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.555]                               info, version)
[13:36:37.555]                           }
[13:36:37.555]                           base::stop(msg)
[13:36:37.555]                         }
[13:36:37.555]                       })
[13:36:37.555]                     }
[13:36:37.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.555]                     base::options(mc.cores = 1L)
[13:36:37.555]                   }
[13:36:37.555]                   ...future.strategy.old <- future::plan("list")
[13:36:37.555]                   options(future.plan = NULL)
[13:36:37.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.555]                 }
[13:36:37.555]                 ...future.workdir <- getwd()
[13:36:37.555]             }
[13:36:37.555]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.555]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.555]         }
[13:36:37.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.555]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.555]             base::names(...future.oldOptions))
[13:36:37.555]     }
[13:36:37.555]     if (FALSE) {
[13:36:37.555]     }
[13:36:37.555]     else {
[13:36:37.555]         if (TRUE) {
[13:36:37.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.555]                 open = "w")
[13:36:37.555]         }
[13:36:37.555]         else {
[13:36:37.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.555]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.555]         }
[13:36:37.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.555]             base::sink(type = "output", split = FALSE)
[13:36:37.555]             base::close(...future.stdout)
[13:36:37.555]         }, add = TRUE)
[13:36:37.555]     }
[13:36:37.555]     ...future.frame <- base::sys.nframe()
[13:36:37.555]     ...future.conditions <- base::list()
[13:36:37.555]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.555]     if (FALSE) {
[13:36:37.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.555]     }
[13:36:37.555]     ...future.result <- base::tryCatch({
[13:36:37.555]         base::withCallingHandlers({
[13:36:37.555]             ...future.value <- base::withVisible(base::local({
[13:36:37.555]                 withCallingHandlers({
[13:36:37.555]                   {
[13:36:37.555]                     4
[13:36:37.555]                   }
[13:36:37.555]                 }, immediateCondition = function(cond) {
[13:36:37.555]                   save_rds <- function (object, pathname, ...) 
[13:36:37.555]                   {
[13:36:37.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.555]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.555]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.555]                         fi_tmp[["mtime"]])
[13:36:37.555]                     }
[13:36:37.555]                     tryCatch({
[13:36:37.555]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.555]                     }, error = function(ex) {
[13:36:37.555]                       msg <- conditionMessage(ex)
[13:36:37.555]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.555]                         fi_tmp[["mtime"]], msg)
[13:36:37.555]                       ex$message <- msg
[13:36:37.555]                       stop(ex)
[13:36:37.555]                     })
[13:36:37.555]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.555]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.555]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.555]                       fi <- file.info(pathname)
[13:36:37.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.555]                         fi[["size"]], fi[["mtime"]])
[13:36:37.555]                       stop(msg)
[13:36:37.555]                     }
[13:36:37.555]                     invisible(pathname)
[13:36:37.555]                   }
[13:36:37.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.555]                     rootPath = tempdir()) 
[13:36:37.555]                   {
[13:36:37.555]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.555]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.555]                       tmpdir = path, fileext = ".rds")
[13:36:37.555]                     save_rds(obj, file)
[13:36:37.555]                   }
[13:36:37.555]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.555]                   {
[13:36:37.555]                     inherits <- base::inherits
[13:36:37.555]                     invokeRestart <- base::invokeRestart
[13:36:37.555]                     is.null <- base::is.null
[13:36:37.555]                     muffled <- FALSE
[13:36:37.555]                     if (inherits(cond, "message")) {
[13:36:37.555]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.555]                       if (muffled) 
[13:36:37.555]                         invokeRestart("muffleMessage")
[13:36:37.555]                     }
[13:36:37.555]                     else if (inherits(cond, "warning")) {
[13:36:37.555]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.555]                       if (muffled) 
[13:36:37.555]                         invokeRestart("muffleWarning")
[13:36:37.555]                     }
[13:36:37.555]                     else if (inherits(cond, "condition")) {
[13:36:37.555]                       if (!is.null(pattern)) {
[13:36:37.555]                         computeRestarts <- base::computeRestarts
[13:36:37.555]                         grepl <- base::grepl
[13:36:37.555]                         restarts <- computeRestarts(cond)
[13:36:37.555]                         for (restart in restarts) {
[13:36:37.555]                           name <- restart$name
[13:36:37.555]                           if (is.null(name)) 
[13:36:37.555]                             next
[13:36:37.555]                           if (!grepl(pattern, name)) 
[13:36:37.555]                             next
[13:36:37.555]                           invokeRestart(restart)
[13:36:37.555]                           muffled <- TRUE
[13:36:37.555]                           break
[13:36:37.555]                         }
[13:36:37.555]                       }
[13:36:37.555]                     }
[13:36:37.555]                     invisible(muffled)
[13:36:37.555]                   }
[13:36:37.555]                   muffleCondition(cond)
[13:36:37.555]                 })
[13:36:37.555]             }))
[13:36:37.555]             future::FutureResult(value = ...future.value$value, 
[13:36:37.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.555]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.555]                     ...future.globalenv.names))
[13:36:37.555]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.555]         }, condition = base::local({
[13:36:37.555]             c <- base::c
[13:36:37.555]             inherits <- base::inherits
[13:36:37.555]             invokeRestart <- base::invokeRestart
[13:36:37.555]             length <- base::length
[13:36:37.555]             list <- base::list
[13:36:37.555]             seq.int <- base::seq.int
[13:36:37.555]             signalCondition <- base::signalCondition
[13:36:37.555]             sys.calls <- base::sys.calls
[13:36:37.555]             `[[` <- base::`[[`
[13:36:37.555]             `+` <- base::`+`
[13:36:37.555]             `<<-` <- base::`<<-`
[13:36:37.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.555]                   3L)]
[13:36:37.555]             }
[13:36:37.555]             function(cond) {
[13:36:37.555]                 is_error <- inherits(cond, "error")
[13:36:37.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.555]                   NULL)
[13:36:37.555]                 if (is_error) {
[13:36:37.555]                   sessionInformation <- function() {
[13:36:37.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.555]                       search = base::search(), system = base::Sys.info())
[13:36:37.555]                   }
[13:36:37.555]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.555]                     cond$call), session = sessionInformation(), 
[13:36:37.555]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.555]                   signalCondition(cond)
[13:36:37.555]                 }
[13:36:37.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.555]                 "immediateCondition"))) {
[13:36:37.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.555]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.555]                   if (TRUE && !signal) {
[13:36:37.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.555]                     {
[13:36:37.555]                       inherits <- base::inherits
[13:36:37.555]                       invokeRestart <- base::invokeRestart
[13:36:37.555]                       is.null <- base::is.null
[13:36:37.555]                       muffled <- FALSE
[13:36:37.555]                       if (inherits(cond, "message")) {
[13:36:37.555]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.555]                         if (muffled) 
[13:36:37.555]                           invokeRestart("muffleMessage")
[13:36:37.555]                       }
[13:36:37.555]                       else if (inherits(cond, "warning")) {
[13:36:37.555]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.555]                         if (muffled) 
[13:36:37.555]                           invokeRestart("muffleWarning")
[13:36:37.555]                       }
[13:36:37.555]                       else if (inherits(cond, "condition")) {
[13:36:37.555]                         if (!is.null(pattern)) {
[13:36:37.555]                           computeRestarts <- base::computeRestarts
[13:36:37.555]                           grepl <- base::grepl
[13:36:37.555]                           restarts <- computeRestarts(cond)
[13:36:37.555]                           for (restart in restarts) {
[13:36:37.555]                             name <- restart$name
[13:36:37.555]                             if (is.null(name)) 
[13:36:37.555]                               next
[13:36:37.555]                             if (!grepl(pattern, name)) 
[13:36:37.555]                               next
[13:36:37.555]                             invokeRestart(restart)
[13:36:37.555]                             muffled <- TRUE
[13:36:37.555]                             break
[13:36:37.555]                           }
[13:36:37.555]                         }
[13:36:37.555]                       }
[13:36:37.555]                       invisible(muffled)
[13:36:37.555]                     }
[13:36:37.555]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.555]                   }
[13:36:37.555]                 }
[13:36:37.555]                 else {
[13:36:37.555]                   if (TRUE) {
[13:36:37.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.555]                     {
[13:36:37.555]                       inherits <- base::inherits
[13:36:37.555]                       invokeRestart <- base::invokeRestart
[13:36:37.555]                       is.null <- base::is.null
[13:36:37.555]                       muffled <- FALSE
[13:36:37.555]                       if (inherits(cond, "message")) {
[13:36:37.555]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.555]                         if (muffled) 
[13:36:37.555]                           invokeRestart("muffleMessage")
[13:36:37.555]                       }
[13:36:37.555]                       else if (inherits(cond, "warning")) {
[13:36:37.555]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.555]                         if (muffled) 
[13:36:37.555]                           invokeRestart("muffleWarning")
[13:36:37.555]                       }
[13:36:37.555]                       else if (inherits(cond, "condition")) {
[13:36:37.555]                         if (!is.null(pattern)) {
[13:36:37.555]                           computeRestarts <- base::computeRestarts
[13:36:37.555]                           grepl <- base::grepl
[13:36:37.555]                           restarts <- computeRestarts(cond)
[13:36:37.555]                           for (restart in restarts) {
[13:36:37.555]                             name <- restart$name
[13:36:37.555]                             if (is.null(name)) 
[13:36:37.555]                               next
[13:36:37.555]                             if (!grepl(pattern, name)) 
[13:36:37.555]                               next
[13:36:37.555]                             invokeRestart(restart)
[13:36:37.555]                             muffled <- TRUE
[13:36:37.555]                             break
[13:36:37.555]                           }
[13:36:37.555]                         }
[13:36:37.555]                       }
[13:36:37.555]                       invisible(muffled)
[13:36:37.555]                     }
[13:36:37.555]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.555]                   }
[13:36:37.555]                 }
[13:36:37.555]             }
[13:36:37.555]         }))
[13:36:37.555]     }, error = function(ex) {
[13:36:37.555]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.555]                 ...future.rng), started = ...future.startTime, 
[13:36:37.555]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.555]             version = "1.8"), class = "FutureResult")
[13:36:37.555]     }, finally = {
[13:36:37.555]         if (!identical(...future.workdir, getwd())) 
[13:36:37.555]             setwd(...future.workdir)
[13:36:37.555]         {
[13:36:37.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.555]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.555]             }
[13:36:37.555]             base::options(...future.oldOptions)
[13:36:37.555]             if (.Platform$OS.type == "windows") {
[13:36:37.555]                 old_names <- names(...future.oldEnvVars)
[13:36:37.555]                 envs <- base::Sys.getenv()
[13:36:37.555]                 names <- names(envs)
[13:36:37.555]                 common <- intersect(names, old_names)
[13:36:37.555]                 added <- setdiff(names, old_names)
[13:36:37.555]                 removed <- setdiff(old_names, names)
[13:36:37.555]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.555]                   envs[common]]
[13:36:37.555]                 NAMES <- toupper(changed)
[13:36:37.555]                 args <- list()
[13:36:37.555]                 for (kk in seq_along(NAMES)) {
[13:36:37.555]                   name <- changed[[kk]]
[13:36:37.555]                   NAME <- NAMES[[kk]]
[13:36:37.555]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.555]                     next
[13:36:37.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.555]                 }
[13:36:37.555]                 NAMES <- toupper(added)
[13:36:37.555]                 for (kk in seq_along(NAMES)) {
[13:36:37.555]                   name <- added[[kk]]
[13:36:37.555]                   NAME <- NAMES[[kk]]
[13:36:37.555]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.555]                     next
[13:36:37.555]                   args[[name]] <- ""
[13:36:37.555]                 }
[13:36:37.555]                 NAMES <- toupper(removed)
[13:36:37.555]                 for (kk in seq_along(NAMES)) {
[13:36:37.555]                   name <- removed[[kk]]
[13:36:37.555]                   NAME <- NAMES[[kk]]
[13:36:37.555]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.555]                     next
[13:36:37.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.555]                 }
[13:36:37.555]                 if (length(args) > 0) 
[13:36:37.555]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.555]             }
[13:36:37.555]             else {
[13:36:37.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.555]             }
[13:36:37.555]             {
[13:36:37.555]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.555]                   0L) {
[13:36:37.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.555]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.555]                   base::options(opts)
[13:36:37.555]                 }
[13:36:37.555]                 {
[13:36:37.555]                   {
[13:36:37.555]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.555]                     NULL
[13:36:37.555]                   }
[13:36:37.555]                   options(future.plan = NULL)
[13:36:37.555]                   if (is.na(NA_character_)) 
[13:36:37.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.555]                     .init = FALSE)
[13:36:37.555]                 }
[13:36:37.555]             }
[13:36:37.555]         }
[13:36:37.555]     })
[13:36:37.555]     if (TRUE) {
[13:36:37.555]         base::sink(type = "output", split = FALSE)
[13:36:37.555]         if (TRUE) {
[13:36:37.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.555]         }
[13:36:37.555]         else {
[13:36:37.555]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.555]         }
[13:36:37.555]         base::close(...future.stdout)
[13:36:37.555]         ...future.stdout <- NULL
[13:36:37.555]     }
[13:36:37.555]     ...future.result$conditions <- ...future.conditions
[13:36:37.555]     ...future.result$finished <- base::Sys.time()
[13:36:37.555]     ...future.result
[13:36:37.555] }
[13:36:37.558] requestCore(): workers = 2
[13:36:37.559] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:37.570] result() for MulticoreFuture ...
[13:36:37.571] result() for MulticoreFuture ...
[13:36:37.571] result() for MulticoreFuture ... done
[13:36:37.571] result() for MulticoreFuture ... done
[13:36:37.571] result() for MulticoreFuture ...
[13:36:37.571] result() for MulticoreFuture ... done
[13:36:37.574] MulticoreFuture started
[13:36:37.574] - Launch lazy future ... done
[13:36:37.574] run() for ‘MulticoreFuture’ ... done
[13:36:37.575] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x564a70fcc380> 
[13:36:37.576] List of future strategies:
[13:36:37.576] 1. sequential:
[13:36:37.576]    - args: function (..., envir = parent.frame())
[13:36:37.576]    - tweaked: FALSE
[13:36:37.576]    - call: NULL
[13:36:37.577] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x564a749611d0> 
 - attr(*, "dim.")=[13:36:37.580] plan(): Setting new future strategy stack:
 int [1:2] 1 6
 - attr(*, "dimnames.")=[13:36:37.580] List of future strategies:
[13:36:37.580] 1. multicore:
[13:36:37.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.580]    - tweaked: FALSE
[13:36:37.580]    - call: plan(strategy)
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:36:37.586] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:37.589] resolve() on list environment ...
[13:36:37.590]  recursive: 0
[13:36:37.591]  length: 6
[13:36:37.591]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:37.591] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.592] - nx: 6
[13:36:37.592] - relay: TRUE
[13:36:37.592] - stdout: TRUE
[13:36:37.592] - signal: TRUE
[13:36:37.592] - resignal: FALSE
[13:36:37.592] - force: TRUE
[13:36:37.592] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.592] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.593]  - until=2
[13:36:37.593]  - relaying element #2
[13:36:37.593] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.593] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.593] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.593]  length: 5 (resolved future 1)
[13:36:37.593] Future #2
[13:36:37.594] result() for MulticoreFuture ...
[13:36:37.594] result() for MulticoreFuture ... done
[13:36:37.594] result() for MulticoreFuture ...
[13:36:37.594] result() for MulticoreFuture ... done
[13:36:37.594] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:37.594] - nx: 6
[13:36:37.594] - relay: TRUE
[13:36:37.595] - stdout: TRUE
[13:36:37.595] - signal: TRUE
[13:36:37.595] - resignal: FALSE
[13:36:37.595] - force: TRUE
[13:36:37.595] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.595] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.595]  - until=2
[13:36:37.595]  - relaying element #2
[13:36:37.596] result() for MulticoreFuture ...
[13:36:37.596] result() for MulticoreFuture ... done
[13:36:37.596] result() for MulticoreFuture ...
[13:36:37.596] result() for MulticoreFuture ... done
[13:36:37.596] result() for MulticoreFuture ...
[13:36:37.596] result() for MulticoreFuture ... done
[13:36:37.596] result() for MulticoreFuture ...
[13:36:37.597] result() for MulticoreFuture ... done
[13:36:37.597] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.597] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.597] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:37.597]  length: 4 (resolved future 2)
[13:36:37.597] Future #3
[13:36:37.598] result() for MulticoreFuture ...
[13:36:37.599] result() for MulticoreFuture ...
[13:36:37.599] result() for MulticoreFuture ... done
[13:36:37.599] result() for MulticoreFuture ... done
[13:36:37.599] result() for MulticoreFuture ...
[13:36:37.599] result() for MulticoreFuture ... done
[13:36:37.599] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:37.600] - nx: 6
[13:36:37.600] - relay: TRUE
[13:36:37.600] - stdout: TRUE
[13:36:37.600] - signal: TRUE
[13:36:37.600] - resignal: FALSE
[13:36:37.600] - force: TRUE
[13:36:37.601] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.601] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.601]  - until=3
[13:36:37.601]  - relaying element #3
[13:36:37.601] result() for MulticoreFuture ...
[13:36:37.601] result() for MulticoreFuture ... done
[13:36:37.602] result() for MulticoreFuture ...
[13:36:37.602] result() for MulticoreFuture ... done
[13:36:37.602] result() for MulticoreFuture ...
[13:36:37.602] result() for MulticoreFuture ... done
[13:36:37.602] result() for MulticoreFuture ...
[13:36:37.603] result() for MulticoreFuture ... done
[13:36:37.603] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.603] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.603] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:37.603]  length: 3 (resolved future 3)
[13:36:37.603] Future #4
[13:36:37.604] result() for MulticoreFuture ...
[13:36:37.604] result() for MulticoreFuture ...
[13:36:37.604] result() for MulticoreFuture ... done
[13:36:37.605] result() for MulticoreFuture ... done
[13:36:37.605] result() for MulticoreFuture ...
[13:36:37.605] result() for MulticoreFuture ... done
[13:36:37.605] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:37.605] - nx: 6
[13:36:37.606] - relay: TRUE
[13:36:37.606] - stdout: TRUE
[13:36:37.606] - signal: TRUE
[13:36:37.606] - resignal: FALSE
[13:36:37.606] - force: TRUE
[13:36:37.606] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.606] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.607]  - until=4
[13:36:37.607]  - relaying element #4
[13:36:37.607] result() for MulticoreFuture ...
[13:36:37.607] result() for MulticoreFuture ... done
[13:36:37.607] result() for MulticoreFuture ...
[13:36:37.608] result() for MulticoreFuture ... done
[13:36:37.608] result() for MulticoreFuture ...
[13:36:37.608] result() for MulticoreFuture ... done
[13:36:37.612] result() for MulticoreFuture ...
[13:36:37.613] result() for MulticoreFuture ... done
[13:36:37.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.613] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.613] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:37.613]  length: 2 (resolved future 4)
[13:36:37.613] signalConditionsASAP(NULL, pos=5) ...
[13:36:37.614] - nx: 6
[13:36:37.614] - relay: TRUE
[13:36:37.614] - stdout: TRUE
[13:36:37.614] - signal: TRUE
[13:36:37.614] - resignal: FALSE
[13:36:37.614] - force: TRUE
[13:36:37.614] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.614] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.614]  - until=6
[13:36:37.615]  - relaying element #6
[13:36:37.615] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.615] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.615] signalConditionsASAP(NULL, pos=5) ... done
[13:36:37.615]  length: 1 (resolved future 5)
[13:36:37.615] signalConditionsASAP(numeric, pos=6) ...
[13:36:37.615] - nx: 6
[13:36:37.615] - relay: TRUE
[13:36:37.615] - stdout: TRUE
[13:36:37.615] - signal: TRUE
[13:36:37.616] - resignal: FALSE
[13:36:37.616] - force: TRUE
[13:36:37.616] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.616] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.616]  - until=6
[13:36:37.616] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.616] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.616] signalConditionsASAP(numeric, pos=6) ... done
[13:36:37.616]  length: 0 (resolved future 6)
[13:36:37.617] Relaying remaining futures
[13:36:37.617] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.617] - nx: 6
[13:36:37.617] - relay: TRUE
[13:36:37.617] - stdout: TRUE
[13:36:37.617] - signal: TRUE
[13:36:37.617] - resignal: FALSE
[13:36:37.617] - force: TRUE
[13:36:37.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:37.618] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.618] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.618] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.618] resolve() on list environment ... DONE
[13:36:37.618] result() for MulticoreFuture ...
[13:36:37.618] result() for MulticoreFuture ... done
[13:36:37.618] result() for MulticoreFuture ...
[13:36:37.618] result() for MulticoreFuture ... done
[13:36:37.619] result() for MulticoreFuture ...
[13:36:37.619] result() for MulticoreFuture ... done
[13:36:37.619] result() for MulticoreFuture ...
[13:36:37.619] result() for MulticoreFuture ... done
[13:36:37.619] result() for MulticoreFuture ...
[13:36:37.619] result() for MulticoreFuture ... done
[13:36:37.619] result() for MulticoreFuture ...
[13:36:37.619] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a74c48c78> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:36:37.621] getGlobalsAndPackages() ...
[13:36:37.622] Searching for globals...
[13:36:37.622] 
[13:36:37.622] Searching for globals ... DONE
[13:36:37.622] - globals: [0] <none>
[13:36:37.622] getGlobalsAndPackages() ... DONE
[13:36:37.623] run() for ‘Future’ ...
[13:36:37.623] - state: ‘created’
[13:36:37.623] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.627] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.627]   - Field: ‘label’
[13:36:37.627]   - Field: ‘local’
[13:36:37.627]   - Field: ‘owner’
[13:36:37.628]   - Field: ‘envir’
[13:36:37.628]   - Field: ‘workers’
[13:36:37.628]   - Field: ‘packages’
[13:36:37.628]   - Field: ‘gc’
[13:36:37.628]   - Field: ‘job’
[13:36:37.628]   - Field: ‘conditions’
[13:36:37.628]   - Field: ‘expr’
[13:36:37.628]   - Field: ‘uuid’
[13:36:37.628]   - Field: ‘seed’
[13:36:37.628]   - Field: ‘version’
[13:36:37.629]   - Field: ‘result’
[13:36:37.629]   - Field: ‘asynchronous’
[13:36:37.629]   - Field: ‘calls’
[13:36:37.629]   - Field: ‘globals’
[13:36:37.629]   - Field: ‘stdout’
[13:36:37.629]   - Field: ‘earlySignal’
[13:36:37.629]   - Field: ‘lazy’
[13:36:37.629]   - Field: ‘state’
[13:36:37.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.630] - Launch lazy future ...
[13:36:37.630] Packages needed by the future expression (n = 0): <none>
[13:36:37.630] Packages needed by future strategies (n = 0): <none>
[13:36:37.631] {
[13:36:37.631]     {
[13:36:37.631]         {
[13:36:37.631]             ...future.startTime <- base::Sys.time()
[13:36:37.631]             {
[13:36:37.631]                 {
[13:36:37.631]                   {
[13:36:37.631]                     {
[13:36:37.631]                       base::local({
[13:36:37.631]                         has_future <- base::requireNamespace("future", 
[13:36:37.631]                           quietly = TRUE)
[13:36:37.631]                         if (has_future) {
[13:36:37.631]                           ns <- base::getNamespace("future")
[13:36:37.631]                           version <- ns[[".package"]][["version"]]
[13:36:37.631]                           if (is.null(version)) 
[13:36:37.631]                             version <- utils::packageVersion("future")
[13:36:37.631]                         }
[13:36:37.631]                         else {
[13:36:37.631]                           version <- NULL
[13:36:37.631]                         }
[13:36:37.631]                         if (!has_future || version < "1.8.0") {
[13:36:37.631]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.631]                             "", base::R.version$version.string), 
[13:36:37.631]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.631]                               "release", "version")], collapse = " "), 
[13:36:37.631]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.631]                             info)
[13:36:37.631]                           info <- base::paste(info, collapse = "; ")
[13:36:37.631]                           if (!has_future) {
[13:36:37.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.631]                               info)
[13:36:37.631]                           }
[13:36:37.631]                           else {
[13:36:37.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.631]                               info, version)
[13:36:37.631]                           }
[13:36:37.631]                           base::stop(msg)
[13:36:37.631]                         }
[13:36:37.631]                       })
[13:36:37.631]                     }
[13:36:37.631]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.631]                     base::options(mc.cores = 1L)
[13:36:37.631]                   }
[13:36:37.631]                   ...future.strategy.old <- future::plan("list")
[13:36:37.631]                   options(future.plan = NULL)
[13:36:37.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.631]                 }
[13:36:37.631]                 ...future.workdir <- getwd()
[13:36:37.631]             }
[13:36:37.631]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.631]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.631]         }
[13:36:37.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.631]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.631]             base::names(...future.oldOptions))
[13:36:37.631]     }
[13:36:37.631]     if (FALSE) {
[13:36:37.631]     }
[13:36:37.631]     else {
[13:36:37.631]         if (TRUE) {
[13:36:37.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.631]                 open = "w")
[13:36:37.631]         }
[13:36:37.631]         else {
[13:36:37.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.631]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.631]         }
[13:36:37.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.631]             base::sink(type = "output", split = FALSE)
[13:36:37.631]             base::close(...future.stdout)
[13:36:37.631]         }, add = TRUE)
[13:36:37.631]     }
[13:36:37.631]     ...future.frame <- base::sys.nframe()
[13:36:37.631]     ...future.conditions <- base::list()
[13:36:37.631]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.631]     if (FALSE) {
[13:36:37.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.631]     }
[13:36:37.631]     ...future.result <- base::tryCatch({
[13:36:37.631]         base::withCallingHandlers({
[13:36:37.631]             ...future.value <- base::withVisible(base::local({
[13:36:37.631]                 withCallingHandlers({
[13:36:37.631]                   2
[13:36:37.631]                 }, immediateCondition = function(cond) {
[13:36:37.631]                   save_rds <- function (object, pathname, ...) 
[13:36:37.631]                   {
[13:36:37.631]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.631]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.631]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.631]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.631]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.631]                         fi_tmp[["mtime"]])
[13:36:37.631]                     }
[13:36:37.631]                     tryCatch({
[13:36:37.631]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.631]                     }, error = function(ex) {
[13:36:37.631]                       msg <- conditionMessage(ex)
[13:36:37.631]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.631]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.631]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.631]                         fi_tmp[["mtime"]], msg)
[13:36:37.631]                       ex$message <- msg
[13:36:37.631]                       stop(ex)
[13:36:37.631]                     })
[13:36:37.631]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.631]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.631]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.631]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.631]                       fi <- file.info(pathname)
[13:36:37.631]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.631]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.631]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.631]                         fi[["size"]], fi[["mtime"]])
[13:36:37.631]                       stop(msg)
[13:36:37.631]                     }
[13:36:37.631]                     invisible(pathname)
[13:36:37.631]                   }
[13:36:37.631]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.631]                     rootPath = tempdir()) 
[13:36:37.631]                   {
[13:36:37.631]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.631]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.631]                       tmpdir = path, fileext = ".rds")
[13:36:37.631]                     save_rds(obj, file)
[13:36:37.631]                   }
[13:36:37.631]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.631]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.631]                   {
[13:36:37.631]                     inherits <- base::inherits
[13:36:37.631]                     invokeRestart <- base::invokeRestart
[13:36:37.631]                     is.null <- base::is.null
[13:36:37.631]                     muffled <- FALSE
[13:36:37.631]                     if (inherits(cond, "message")) {
[13:36:37.631]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.631]                       if (muffled) 
[13:36:37.631]                         invokeRestart("muffleMessage")
[13:36:37.631]                     }
[13:36:37.631]                     else if (inherits(cond, "warning")) {
[13:36:37.631]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.631]                       if (muffled) 
[13:36:37.631]                         invokeRestart("muffleWarning")
[13:36:37.631]                     }
[13:36:37.631]                     else if (inherits(cond, "condition")) {
[13:36:37.631]                       if (!is.null(pattern)) {
[13:36:37.631]                         computeRestarts <- base::computeRestarts
[13:36:37.631]                         grepl <- base::grepl
[13:36:37.631]                         restarts <- computeRestarts(cond)
[13:36:37.631]                         for (restart in restarts) {
[13:36:37.631]                           name <- restart$name
[13:36:37.631]                           if (is.null(name)) 
[13:36:37.631]                             next
[13:36:37.631]                           if (!grepl(pattern, name)) 
[13:36:37.631]                             next
[13:36:37.631]                           invokeRestart(restart)
[13:36:37.631]                           muffled <- TRUE
[13:36:37.631]                           break
[13:36:37.631]                         }
[13:36:37.631]                       }
[13:36:37.631]                     }
[13:36:37.631]                     invisible(muffled)
[13:36:37.631]                   }
[13:36:37.631]                   muffleCondition(cond)
[13:36:37.631]                 })
[13:36:37.631]             }))
[13:36:37.631]             future::FutureResult(value = ...future.value$value, 
[13:36:37.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.631]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.631]                     ...future.globalenv.names))
[13:36:37.631]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.631]         }, condition = base::local({
[13:36:37.631]             c <- base::c
[13:36:37.631]             inherits <- base::inherits
[13:36:37.631]             invokeRestart <- base::invokeRestart
[13:36:37.631]             length <- base::length
[13:36:37.631]             list <- base::list
[13:36:37.631]             seq.int <- base::seq.int
[13:36:37.631]             signalCondition <- base::signalCondition
[13:36:37.631]             sys.calls <- base::sys.calls
[13:36:37.631]             `[[` <- base::`[[`
[13:36:37.631]             `+` <- base::`+`
[13:36:37.631]             `<<-` <- base::`<<-`
[13:36:37.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.631]                   3L)]
[13:36:37.631]             }
[13:36:37.631]             function(cond) {
[13:36:37.631]                 is_error <- inherits(cond, "error")
[13:36:37.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.631]                   NULL)
[13:36:37.631]                 if (is_error) {
[13:36:37.631]                   sessionInformation <- function() {
[13:36:37.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.631]                       search = base::search(), system = base::Sys.info())
[13:36:37.631]                   }
[13:36:37.631]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.631]                     cond$call), session = sessionInformation(), 
[13:36:37.631]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.631]                   signalCondition(cond)
[13:36:37.631]                 }
[13:36:37.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.631]                 "immediateCondition"))) {
[13:36:37.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.631]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.631]                   if (TRUE && !signal) {
[13:36:37.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.631]                     {
[13:36:37.631]                       inherits <- base::inherits
[13:36:37.631]                       invokeRestart <- base::invokeRestart
[13:36:37.631]                       is.null <- base::is.null
[13:36:37.631]                       muffled <- FALSE
[13:36:37.631]                       if (inherits(cond, "message")) {
[13:36:37.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.631]                         if (muffled) 
[13:36:37.631]                           invokeRestart("muffleMessage")
[13:36:37.631]                       }
[13:36:37.631]                       else if (inherits(cond, "warning")) {
[13:36:37.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.631]                         if (muffled) 
[13:36:37.631]                           invokeRestart("muffleWarning")
[13:36:37.631]                       }
[13:36:37.631]                       else if (inherits(cond, "condition")) {
[13:36:37.631]                         if (!is.null(pattern)) {
[13:36:37.631]                           computeRestarts <- base::computeRestarts
[13:36:37.631]                           grepl <- base::grepl
[13:36:37.631]                           restarts <- computeRestarts(cond)
[13:36:37.631]                           for (restart in restarts) {
[13:36:37.631]                             name <- restart$name
[13:36:37.631]                             if (is.null(name)) 
[13:36:37.631]                               next
[13:36:37.631]                             if (!grepl(pattern, name)) 
[13:36:37.631]                               next
[13:36:37.631]                             invokeRestart(restart)
[13:36:37.631]                             muffled <- TRUE
[13:36:37.631]                             break
[13:36:37.631]                           }
[13:36:37.631]                         }
[13:36:37.631]                       }
[13:36:37.631]                       invisible(muffled)
[13:36:37.631]                     }
[13:36:37.631]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.631]                   }
[13:36:37.631]                 }
[13:36:37.631]                 else {
[13:36:37.631]                   if (TRUE) {
[13:36:37.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.631]                     {
[13:36:37.631]                       inherits <- base::inherits
[13:36:37.631]                       invokeRestart <- base::invokeRestart
[13:36:37.631]                       is.null <- base::is.null
[13:36:37.631]                       muffled <- FALSE
[13:36:37.631]                       if (inherits(cond, "message")) {
[13:36:37.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.631]                         if (muffled) 
[13:36:37.631]                           invokeRestart("muffleMessage")
[13:36:37.631]                       }
[13:36:37.631]                       else if (inherits(cond, "warning")) {
[13:36:37.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.631]                         if (muffled) 
[13:36:37.631]                           invokeRestart("muffleWarning")
[13:36:37.631]                       }
[13:36:37.631]                       else if (inherits(cond, "condition")) {
[13:36:37.631]                         if (!is.null(pattern)) {
[13:36:37.631]                           computeRestarts <- base::computeRestarts
[13:36:37.631]                           grepl <- base::grepl
[13:36:37.631]                           restarts <- computeRestarts(cond)
[13:36:37.631]                           for (restart in restarts) {
[13:36:37.631]                             name <- restart$name
[13:36:37.631]                             if (is.null(name)) 
[13:36:37.631]                               next
[13:36:37.631]                             if (!grepl(pattern, name)) 
[13:36:37.631]                               next
[13:36:37.631]                             invokeRestart(restart)
[13:36:37.631]                             muffled <- TRUE
[13:36:37.631]                             break
[13:36:37.631]                           }
[13:36:37.631]                         }
[13:36:37.631]                       }
[13:36:37.631]                       invisible(muffled)
[13:36:37.631]                     }
[13:36:37.631]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.631]                   }
[13:36:37.631]                 }
[13:36:37.631]             }
[13:36:37.631]         }))
[13:36:37.631]     }, error = function(ex) {
[13:36:37.631]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.631]                 ...future.rng), started = ...future.startTime, 
[13:36:37.631]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.631]             version = "1.8"), class = "FutureResult")
[13:36:37.631]     }, finally = {
[13:36:37.631]         if (!identical(...future.workdir, getwd())) 
[13:36:37.631]             setwd(...future.workdir)
[13:36:37.631]         {
[13:36:37.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.631]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.631]             }
[13:36:37.631]             base::options(...future.oldOptions)
[13:36:37.631]             if (.Platform$OS.type == "windows") {
[13:36:37.631]                 old_names <- names(...future.oldEnvVars)
[13:36:37.631]                 envs <- base::Sys.getenv()
[13:36:37.631]                 names <- names(envs)
[13:36:37.631]                 common <- intersect(names, old_names)
[13:36:37.631]                 added <- setdiff(names, old_names)
[13:36:37.631]                 removed <- setdiff(old_names, names)
[13:36:37.631]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.631]                   envs[common]]
[13:36:37.631]                 NAMES <- toupper(changed)
[13:36:37.631]                 args <- list()
[13:36:37.631]                 for (kk in seq_along(NAMES)) {
[13:36:37.631]                   name <- changed[[kk]]
[13:36:37.631]                   NAME <- NAMES[[kk]]
[13:36:37.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.631]                     next
[13:36:37.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.631]                 }
[13:36:37.631]                 NAMES <- toupper(added)
[13:36:37.631]                 for (kk in seq_along(NAMES)) {
[13:36:37.631]                   name <- added[[kk]]
[13:36:37.631]                   NAME <- NAMES[[kk]]
[13:36:37.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.631]                     next
[13:36:37.631]                   args[[name]] <- ""
[13:36:37.631]                 }
[13:36:37.631]                 NAMES <- toupper(removed)
[13:36:37.631]                 for (kk in seq_along(NAMES)) {
[13:36:37.631]                   name <- removed[[kk]]
[13:36:37.631]                   NAME <- NAMES[[kk]]
[13:36:37.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.631]                     next
[13:36:37.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.631]                 }
[13:36:37.631]                 if (length(args) > 0) 
[13:36:37.631]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.631]             }
[13:36:37.631]             else {
[13:36:37.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.631]             }
[13:36:37.631]             {
[13:36:37.631]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.631]                   0L) {
[13:36:37.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.631]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.631]                   base::options(opts)
[13:36:37.631]                 }
[13:36:37.631]                 {
[13:36:37.631]                   {
[13:36:37.631]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.631]                     NULL
[13:36:37.631]                   }
[13:36:37.631]                   options(future.plan = NULL)
[13:36:37.631]                   if (is.na(NA_character_)) 
[13:36:37.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.631]                     .init = FALSE)
[13:36:37.631]                 }
[13:36:37.631]             }
[13:36:37.631]         }
[13:36:37.631]     })
[13:36:37.631]     if (TRUE) {
[13:36:37.631]         base::sink(type = "output", split = FALSE)
[13:36:37.631]         if (TRUE) {
[13:36:37.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.631]         }
[13:36:37.631]         else {
[13:36:37.631]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.631]         }
[13:36:37.631]         base::close(...future.stdout)
[13:36:37.631]         ...future.stdout <- NULL
[13:36:37.631]     }
[13:36:37.631]     ...future.result$conditions <- ...future.conditions
[13:36:37.631]     ...future.result$finished <- base::Sys.time()
[13:36:37.631]     ...future.result
[13:36:37.631] }
[13:36:37.633] requestCore(): workers = 2
[13:36:37.635] MulticoreFuture started
[13:36:37.635] - Launch lazy future ... done
[13:36:37.636] run() for ‘MulticoreFuture’ ... done
[13:36:37.636] getGlobalsAndPackages() ...
[13:36:37.636] Searching for globals...
[13:36:37.636] plan(): Setting new future strategy stack:
[13:36:37.636] List of future strategies:
[13:36:37.636] 1. sequential:
[13:36:37.636]    - args: function (..., envir = parent.frame())
[13:36:37.636]    - tweaked: FALSE
[13:36:37.636]    - call: NULL
[13:36:37.637] 
[13:36:37.637] Searching for globals ... DONE
[13:36:37.637] plan(): nbrOfWorkers() = 1
[13:36:37.637] - globals: [0] <none>
[13:36:37.637] getGlobalsAndPackages() ... DONE
[13:36:37.638] run() for ‘Future’ ...
[13:36:37.638] - state: ‘created’
[13:36:37.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.639] plan(): Setting new future strategy stack:
[13:36:37.639] List of future strategies:
[13:36:37.639] 1. multicore:
[13:36:37.639]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.639]    - tweaked: FALSE
[13:36:37.639]    - call: plan(strategy)
[13:36:37.643] plan(): nbrOfWorkers() = 2
[13:36:37.643] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.644]   - Field: ‘label’
[13:36:37.644]   - Field: ‘local’
[13:36:37.644]   - Field: ‘owner’
[13:36:37.644]   - Field: ‘envir’
[13:36:37.644]   - Field: ‘workers’
[13:36:37.645]   - Field: ‘packages’
[13:36:37.645]   - Field: ‘gc’
[13:36:37.645]   - Field: ‘job’
[13:36:37.645]   - Field: ‘conditions’
[13:36:37.645]   - Field: ‘expr’
[13:36:37.645]   - Field: ‘uuid’
[13:36:37.646]   - Field: ‘seed’
[13:36:37.646]   - Field: ‘version’
[13:36:37.646]   - Field: ‘result’
[13:36:37.646]   - Field: ‘asynchronous’
[13:36:37.646]   - Field: ‘calls’
[13:36:37.646]   - Field: ‘globals’
[13:36:37.647]   - Field: ‘stdout’
[13:36:37.647]   - Field: ‘earlySignal’
[13:36:37.647]   - Field: ‘lazy’
[13:36:37.647]   - Field: ‘state’
[13:36:37.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.647] - Launch lazy future ...
[13:36:37.648] Packages needed by the future expression (n = 0): <none>
[13:36:37.648] Packages needed by future strategies (n = 0): <none>
[13:36:37.649] {
[13:36:37.649]     {
[13:36:37.649]         {
[13:36:37.649]             ...future.startTime <- base::Sys.time()
[13:36:37.649]             {
[13:36:37.649]                 {
[13:36:37.649]                   {
[13:36:37.649]                     {
[13:36:37.649]                       base::local({
[13:36:37.649]                         has_future <- base::requireNamespace("future", 
[13:36:37.649]                           quietly = TRUE)
[13:36:37.649]                         if (has_future) {
[13:36:37.649]                           ns <- base::getNamespace("future")
[13:36:37.649]                           version <- ns[[".package"]][["version"]]
[13:36:37.649]                           if (is.null(version)) 
[13:36:37.649]                             version <- utils::packageVersion("future")
[13:36:37.649]                         }
[13:36:37.649]                         else {
[13:36:37.649]                           version <- NULL
[13:36:37.649]                         }
[13:36:37.649]                         if (!has_future || version < "1.8.0") {
[13:36:37.649]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.649]                             "", base::R.version$version.string), 
[13:36:37.649]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.649]                               "release", "version")], collapse = " "), 
[13:36:37.649]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.649]                             info)
[13:36:37.649]                           info <- base::paste(info, collapse = "; ")
[13:36:37.649]                           if (!has_future) {
[13:36:37.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.649]                               info)
[13:36:37.649]                           }
[13:36:37.649]                           else {
[13:36:37.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.649]                               info, version)
[13:36:37.649]                           }
[13:36:37.649]                           base::stop(msg)
[13:36:37.649]                         }
[13:36:37.649]                       })
[13:36:37.649]                     }
[13:36:37.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.649]                     base::options(mc.cores = 1L)
[13:36:37.649]                   }
[13:36:37.649]                   ...future.strategy.old <- future::plan("list")
[13:36:37.649]                   options(future.plan = NULL)
[13:36:37.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.649]                 }
[13:36:37.649]                 ...future.workdir <- getwd()
[13:36:37.649]             }
[13:36:37.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.649]         }
[13:36:37.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.649]             base::names(...future.oldOptions))
[13:36:37.649]     }
[13:36:37.649]     if (FALSE) {
[13:36:37.649]     }
[13:36:37.649]     else {
[13:36:37.649]         if (TRUE) {
[13:36:37.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.649]                 open = "w")
[13:36:37.649]         }
[13:36:37.649]         else {
[13:36:37.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.649]         }
[13:36:37.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.649]             base::sink(type = "output", split = FALSE)
[13:36:37.649]             base::close(...future.stdout)
[13:36:37.649]         }, add = TRUE)
[13:36:37.649]     }
[13:36:37.649]     ...future.frame <- base::sys.nframe()
[13:36:37.649]     ...future.conditions <- base::list()
[13:36:37.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.649]     if (FALSE) {
[13:36:37.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.649]     }
[13:36:37.649]     ...future.result <- base::tryCatch({
[13:36:37.649]         base::withCallingHandlers({
[13:36:37.649]             ...future.value <- base::withVisible(base::local({
[13:36:37.649]                 withCallingHandlers({
[13:36:37.649]                   NULL
[13:36:37.649]                 }, immediateCondition = function(cond) {
[13:36:37.649]                   save_rds <- function (object, pathname, ...) 
[13:36:37.649]                   {
[13:36:37.649]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.649]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.649]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.649]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.649]                         fi_tmp[["mtime"]])
[13:36:37.649]                     }
[13:36:37.649]                     tryCatch({
[13:36:37.649]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.649]                     }, error = function(ex) {
[13:36:37.649]                       msg <- conditionMessage(ex)
[13:36:37.649]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.649]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.649]                         fi_tmp[["mtime"]], msg)
[13:36:37.649]                       ex$message <- msg
[13:36:37.649]                       stop(ex)
[13:36:37.649]                     })
[13:36:37.649]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.649]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.649]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.649]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.649]                       fi <- file.info(pathname)
[13:36:37.649]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.649]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.649]                         fi[["size"]], fi[["mtime"]])
[13:36:37.649]                       stop(msg)
[13:36:37.649]                     }
[13:36:37.649]                     invisible(pathname)
[13:36:37.649]                   }
[13:36:37.649]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.649]                     rootPath = tempdir()) 
[13:36:37.649]                   {
[13:36:37.649]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.649]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.649]                       tmpdir = path, fileext = ".rds")
[13:36:37.649]                     save_rds(obj, file)
[13:36:37.649]                   }
[13:36:37.649]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.649]                   {
[13:36:37.649]                     inherits <- base::inherits
[13:36:37.649]                     invokeRestart <- base::invokeRestart
[13:36:37.649]                     is.null <- base::is.null
[13:36:37.649]                     muffled <- FALSE
[13:36:37.649]                     if (inherits(cond, "message")) {
[13:36:37.649]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.649]                       if (muffled) 
[13:36:37.649]                         invokeRestart("muffleMessage")
[13:36:37.649]                     }
[13:36:37.649]                     else if (inherits(cond, "warning")) {
[13:36:37.649]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.649]                       if (muffled) 
[13:36:37.649]                         invokeRestart("muffleWarning")
[13:36:37.649]                     }
[13:36:37.649]                     else if (inherits(cond, "condition")) {
[13:36:37.649]                       if (!is.null(pattern)) {
[13:36:37.649]                         computeRestarts <- base::computeRestarts
[13:36:37.649]                         grepl <- base::grepl
[13:36:37.649]                         restarts <- computeRestarts(cond)
[13:36:37.649]                         for (restart in restarts) {
[13:36:37.649]                           name <- restart$name
[13:36:37.649]                           if (is.null(name)) 
[13:36:37.649]                             next
[13:36:37.649]                           if (!grepl(pattern, name)) 
[13:36:37.649]                             next
[13:36:37.649]                           invokeRestart(restart)
[13:36:37.649]                           muffled <- TRUE
[13:36:37.649]                           break
[13:36:37.649]                         }
[13:36:37.649]                       }
[13:36:37.649]                     }
[13:36:37.649]                     invisible(muffled)
[13:36:37.649]                   }
[13:36:37.649]                   muffleCondition(cond)
[13:36:37.649]                 })
[13:36:37.649]             }))
[13:36:37.649]             future::FutureResult(value = ...future.value$value, 
[13:36:37.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.649]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.649]                     ...future.globalenv.names))
[13:36:37.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.649]         }, condition = base::local({
[13:36:37.649]             c <- base::c
[13:36:37.649]             inherits <- base::inherits
[13:36:37.649]             invokeRestart <- base::invokeRestart
[13:36:37.649]             length <- base::length
[13:36:37.649]             list <- base::list
[13:36:37.649]             seq.int <- base::seq.int
[13:36:37.649]             signalCondition <- base::signalCondition
[13:36:37.649]             sys.calls <- base::sys.calls
[13:36:37.649]             `[[` <- base::`[[`
[13:36:37.649]             `+` <- base::`+`
[13:36:37.649]             `<<-` <- base::`<<-`
[13:36:37.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.649]                   3L)]
[13:36:37.649]             }
[13:36:37.649]             function(cond) {
[13:36:37.649]                 is_error <- inherits(cond, "error")
[13:36:37.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.649]                   NULL)
[13:36:37.649]                 if (is_error) {
[13:36:37.649]                   sessionInformation <- function() {
[13:36:37.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.649]                       search = base::search(), system = base::Sys.info())
[13:36:37.649]                   }
[13:36:37.649]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.649]                     cond$call), session = sessionInformation(), 
[13:36:37.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.649]                   signalCondition(cond)
[13:36:37.649]                 }
[13:36:37.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.649]                 "immediateCondition"))) {
[13:36:37.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.649]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.649]                   if (TRUE && !signal) {
[13:36:37.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.649]                     {
[13:36:37.649]                       inherits <- base::inherits
[13:36:37.649]                       invokeRestart <- base::invokeRestart
[13:36:37.649]                       is.null <- base::is.null
[13:36:37.649]                       muffled <- FALSE
[13:36:37.649]                       if (inherits(cond, "message")) {
[13:36:37.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.649]                         if (muffled) 
[13:36:37.649]                           invokeRestart("muffleMessage")
[13:36:37.649]                       }
[13:36:37.649]                       else if (inherits(cond, "warning")) {
[13:36:37.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.649]                         if (muffled) 
[13:36:37.649]                           invokeRestart("muffleWarning")
[13:36:37.649]                       }
[13:36:37.649]                       else if (inherits(cond, "condition")) {
[13:36:37.649]                         if (!is.null(pattern)) {
[13:36:37.649]                           computeRestarts <- base::computeRestarts
[13:36:37.649]                           grepl <- base::grepl
[13:36:37.649]                           restarts <- computeRestarts(cond)
[13:36:37.649]                           for (restart in restarts) {
[13:36:37.649]                             name <- restart$name
[13:36:37.649]                             if (is.null(name)) 
[13:36:37.649]                               next
[13:36:37.649]                             if (!grepl(pattern, name)) 
[13:36:37.649]                               next
[13:36:37.649]                             invokeRestart(restart)
[13:36:37.649]                             muffled <- TRUE
[13:36:37.649]                             break
[13:36:37.649]                           }
[13:36:37.649]                         }
[13:36:37.649]                       }
[13:36:37.649]                       invisible(muffled)
[13:36:37.649]                     }
[13:36:37.649]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.649]                   }
[13:36:37.649]                 }
[13:36:37.649]                 else {
[13:36:37.649]                   if (TRUE) {
[13:36:37.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.649]                     {
[13:36:37.649]                       inherits <- base::inherits
[13:36:37.649]                       invokeRestart <- base::invokeRestart
[13:36:37.649]                       is.null <- base::is.null
[13:36:37.649]                       muffled <- FALSE
[13:36:37.649]                       if (inherits(cond, "message")) {
[13:36:37.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.649]                         if (muffled) 
[13:36:37.649]                           invokeRestart("muffleMessage")
[13:36:37.649]                       }
[13:36:37.649]                       else if (inherits(cond, "warning")) {
[13:36:37.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.649]                         if (muffled) 
[13:36:37.649]                           invokeRestart("muffleWarning")
[13:36:37.649]                       }
[13:36:37.649]                       else if (inherits(cond, "condition")) {
[13:36:37.649]                         if (!is.null(pattern)) {
[13:36:37.649]                           computeRestarts <- base::computeRestarts
[13:36:37.649]                           grepl <- base::grepl
[13:36:37.649]                           restarts <- computeRestarts(cond)
[13:36:37.649]                           for (restart in restarts) {
[13:36:37.649]                             name <- restart$name
[13:36:37.649]                             if (is.null(name)) 
[13:36:37.649]                               next
[13:36:37.649]                             if (!grepl(pattern, name)) 
[13:36:37.649]                               next
[13:36:37.649]                             invokeRestart(restart)
[13:36:37.649]                             muffled <- TRUE
[13:36:37.649]                             break
[13:36:37.649]                           }
[13:36:37.649]                         }
[13:36:37.649]                       }
[13:36:37.649]                       invisible(muffled)
[13:36:37.649]                     }
[13:36:37.649]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.649]                   }
[13:36:37.649]                 }
[13:36:37.649]             }
[13:36:37.649]         }))
[13:36:37.649]     }, error = function(ex) {
[13:36:37.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.649]                 ...future.rng), started = ...future.startTime, 
[13:36:37.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.649]             version = "1.8"), class = "FutureResult")
[13:36:37.649]     }, finally = {
[13:36:37.649]         if (!identical(...future.workdir, getwd())) 
[13:36:37.649]             setwd(...future.workdir)
[13:36:37.649]         {
[13:36:37.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.649]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.649]             }
[13:36:37.649]             base::options(...future.oldOptions)
[13:36:37.649]             if (.Platform$OS.type == "windows") {
[13:36:37.649]                 old_names <- names(...future.oldEnvVars)
[13:36:37.649]                 envs <- base::Sys.getenv()
[13:36:37.649]                 names <- names(envs)
[13:36:37.649]                 common <- intersect(names, old_names)
[13:36:37.649]                 added <- setdiff(names, old_names)
[13:36:37.649]                 removed <- setdiff(old_names, names)
[13:36:37.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.649]                   envs[common]]
[13:36:37.649]                 NAMES <- toupper(changed)
[13:36:37.649]                 args <- list()
[13:36:37.649]                 for (kk in seq_along(NAMES)) {
[13:36:37.649]                   name <- changed[[kk]]
[13:36:37.649]                   NAME <- NAMES[[kk]]
[13:36:37.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.649]                     next
[13:36:37.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.649]                 }
[13:36:37.649]                 NAMES <- toupper(added)
[13:36:37.649]                 for (kk in seq_along(NAMES)) {
[13:36:37.649]                   name <- added[[kk]]
[13:36:37.649]                   NAME <- NAMES[[kk]]
[13:36:37.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.649]                     next
[13:36:37.649]                   args[[name]] <- ""
[13:36:37.649]                 }
[13:36:37.649]                 NAMES <- toupper(removed)
[13:36:37.649]                 for (kk in seq_along(NAMES)) {
[13:36:37.649]                   name <- removed[[kk]]
[13:36:37.649]                   NAME <- NAMES[[kk]]
[13:36:37.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.649]                     next
[13:36:37.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.649]                 }
[13:36:37.649]                 if (length(args) > 0) 
[13:36:37.649]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.649]             }
[13:36:37.649]             else {
[13:36:37.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.649]             }
[13:36:37.649]             {
[13:36:37.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.649]                   0L) {
[13:36:37.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.649]                   base::options(opts)
[13:36:37.649]                 }
[13:36:37.649]                 {
[13:36:37.649]                   {
[13:36:37.649]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.649]                     NULL
[13:36:37.649]                   }
[13:36:37.649]                   options(future.plan = NULL)
[13:36:37.649]                   if (is.na(NA_character_)) 
[13:36:37.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.649]                     .init = FALSE)
[13:36:37.649]                 }
[13:36:37.649]             }
[13:36:37.649]         }
[13:36:37.649]     })
[13:36:37.649]     if (TRUE) {
[13:36:37.649]         base::sink(type = "output", split = FALSE)
[13:36:37.649]         if (TRUE) {
[13:36:37.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.649]         }
[13:36:37.649]         else {
[13:36:37.649]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.649]         }
[13:36:37.649]         base::close(...future.stdout)
[13:36:37.649]         ...future.stdout <- NULL
[13:36:37.649]     }
[13:36:37.649]     ...future.result$conditions <- ...future.conditions
[13:36:37.649]     ...future.result$finished <- base::Sys.time()
[13:36:37.649]     ...future.result
[13:36:37.649] }
[13:36:37.653] requestCore(): workers = 2
[13:36:37.655] MulticoreFuture started
[13:36:37.655] - Launch lazy future ... done
[13:36:37.656] run() for ‘MulticoreFuture’ ... done
[13:36:37.656] plan(): Setting new future strategy stack:
[13:36:37.657] getGlobalsAndPackages() ...
[13:36:37.657] Searching for globals...
[13:36:37.657] List of future strategies:
[13:36:37.657] 1. sequential:
[13:36:37.657]    - args: function (..., envir = parent.frame())
[13:36:37.657]    - tweaked: FALSE
[13:36:37.657]    - call: NULL
[13:36:37.658] plan(): nbrOfWorkers() = 1
[13:36:37.659] - globals found: [1] ‘{’
[13:36:37.659] Searching for globals ... DONE
[13:36:37.659] Resolving globals: FALSE
[13:36:37.660] 
[13:36:37.660] plan(): Setting new future strategy stack:
[13:36:37.660] 
[13:36:37.660] getGlobalsAndPackages() ... DONE
[13:36:37.660] List of future strategies:
[13:36:37.660] 1. multicore:
[13:36:37.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.660]    - tweaked: FALSE
[13:36:37.660]    - call: plan(strategy)
[13:36:37.660] run() for ‘Future’ ...
[13:36:37.661] - state: ‘created’
[13:36:37.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.665] plan(): nbrOfWorkers() = 2
[13:36:37.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.666]   - Field: ‘label’
[13:36:37.667]   - Field: ‘local’
[13:36:37.667]   - Field: ‘owner’
[13:36:37.667]   - Field: ‘envir’
[13:36:37.667]   - Field: ‘workers’
[13:36:37.667]   - Field: ‘packages’
[13:36:37.667]   - Field: ‘gc’
[13:36:37.668]   - Field: ‘job’
[13:36:37.668]   - Field: ‘conditions’
[13:36:37.668]   - Field: ‘expr’
[13:36:37.668]   - Field: ‘uuid’
[13:36:37.668]   - Field: ‘seed’
[13:36:37.668]   - Field: ‘version’
[13:36:37.668]   - Field: ‘result’
[13:36:37.669]   - Field: ‘asynchronous’
[13:36:37.669]   - Field: ‘calls’
[13:36:37.669]   - Field: ‘globals’
[13:36:37.669]   - Field: ‘stdout’
[13:36:37.669]   - Field: ‘earlySignal’
[13:36:37.669]   - Field: ‘lazy’
[13:36:37.669]   - Field: ‘state’
[13:36:37.670] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.670] - Launch lazy future ...
[13:36:37.670] Packages needed by the future expression (n = 0): <none>
[13:36:37.670] Packages needed by future strategies (n = 0): <none>
[13:36:37.671] {
[13:36:37.671]     {
[13:36:37.671]         {
[13:36:37.671]             ...future.startTime <- base::Sys.time()
[13:36:37.671]             {
[13:36:37.671]                 {
[13:36:37.671]                   {
[13:36:37.671]                     {
[13:36:37.671]                       base::local({
[13:36:37.671]                         has_future <- base::requireNamespace("future", 
[13:36:37.671]                           quietly = TRUE)
[13:36:37.671]                         if (has_future) {
[13:36:37.671]                           ns <- base::getNamespace("future")
[13:36:37.671]                           version <- ns[[".package"]][["version"]]
[13:36:37.671]                           if (is.null(version)) 
[13:36:37.671]                             version <- utils::packageVersion("future")
[13:36:37.671]                         }
[13:36:37.671]                         else {
[13:36:37.671]                           version <- NULL
[13:36:37.671]                         }
[13:36:37.671]                         if (!has_future || version < "1.8.0") {
[13:36:37.671]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.671]                             "", base::R.version$version.string), 
[13:36:37.671]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.671]                               "release", "version")], collapse = " "), 
[13:36:37.671]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.671]                             info)
[13:36:37.671]                           info <- base::paste(info, collapse = "; ")
[13:36:37.671]                           if (!has_future) {
[13:36:37.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.671]                               info)
[13:36:37.671]                           }
[13:36:37.671]                           else {
[13:36:37.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.671]                               info, version)
[13:36:37.671]                           }
[13:36:37.671]                           base::stop(msg)
[13:36:37.671]                         }
[13:36:37.671]                       })
[13:36:37.671]                     }
[13:36:37.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.671]                     base::options(mc.cores = 1L)
[13:36:37.671]                   }
[13:36:37.671]                   ...future.strategy.old <- future::plan("list")
[13:36:37.671]                   options(future.plan = NULL)
[13:36:37.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.671]                 }
[13:36:37.671]                 ...future.workdir <- getwd()
[13:36:37.671]             }
[13:36:37.671]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.671]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.671]         }
[13:36:37.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.671]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.671]             base::names(...future.oldOptions))
[13:36:37.671]     }
[13:36:37.671]     if (FALSE) {
[13:36:37.671]     }
[13:36:37.671]     else {
[13:36:37.671]         if (TRUE) {
[13:36:37.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.671]                 open = "w")
[13:36:37.671]         }
[13:36:37.671]         else {
[13:36:37.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.671]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.671]         }
[13:36:37.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.671]             base::sink(type = "output", split = FALSE)
[13:36:37.671]             base::close(...future.stdout)
[13:36:37.671]         }, add = TRUE)
[13:36:37.671]     }
[13:36:37.671]     ...future.frame <- base::sys.nframe()
[13:36:37.671]     ...future.conditions <- base::list()
[13:36:37.671]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.671]     if (FALSE) {
[13:36:37.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.671]     }
[13:36:37.671]     ...future.result <- base::tryCatch({
[13:36:37.671]         base::withCallingHandlers({
[13:36:37.671]             ...future.value <- base::withVisible(base::local({
[13:36:37.671]                 withCallingHandlers({
[13:36:37.671]                   {
[13:36:37.671]                     4
[13:36:37.671]                   }
[13:36:37.671]                 }, immediateCondition = function(cond) {
[13:36:37.671]                   save_rds <- function (object, pathname, ...) 
[13:36:37.671]                   {
[13:36:37.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.671]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.671]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.671]                         fi_tmp[["mtime"]])
[13:36:37.671]                     }
[13:36:37.671]                     tryCatch({
[13:36:37.671]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.671]                     }, error = function(ex) {
[13:36:37.671]                       msg <- conditionMessage(ex)
[13:36:37.671]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.671]                         fi_tmp[["mtime"]], msg)
[13:36:37.671]                       ex$message <- msg
[13:36:37.671]                       stop(ex)
[13:36:37.671]                     })
[13:36:37.671]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.671]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.671]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.671]                       fi <- file.info(pathname)
[13:36:37.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.671]                         fi[["size"]], fi[["mtime"]])
[13:36:37.671]                       stop(msg)
[13:36:37.671]                     }
[13:36:37.671]                     invisible(pathname)
[13:36:37.671]                   }
[13:36:37.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.671]                     rootPath = tempdir()) 
[13:36:37.671]                   {
[13:36:37.671]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.671]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.671]                       tmpdir = path, fileext = ".rds")
[13:36:37.671]                     save_rds(obj, file)
[13:36:37.671]                   }
[13:36:37.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.671]                   {
[13:36:37.671]                     inherits <- base::inherits
[13:36:37.671]                     invokeRestart <- base::invokeRestart
[13:36:37.671]                     is.null <- base::is.null
[13:36:37.671]                     muffled <- FALSE
[13:36:37.671]                     if (inherits(cond, "message")) {
[13:36:37.671]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.671]                       if (muffled) 
[13:36:37.671]                         invokeRestart("muffleMessage")
[13:36:37.671]                     }
[13:36:37.671]                     else if (inherits(cond, "warning")) {
[13:36:37.671]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.671]                       if (muffled) 
[13:36:37.671]                         invokeRestart("muffleWarning")
[13:36:37.671]                     }
[13:36:37.671]                     else if (inherits(cond, "condition")) {
[13:36:37.671]                       if (!is.null(pattern)) {
[13:36:37.671]                         computeRestarts <- base::computeRestarts
[13:36:37.671]                         grepl <- base::grepl
[13:36:37.671]                         restarts <- computeRestarts(cond)
[13:36:37.671]                         for (restart in restarts) {
[13:36:37.671]                           name <- restart$name
[13:36:37.671]                           if (is.null(name)) 
[13:36:37.671]                             next
[13:36:37.671]                           if (!grepl(pattern, name)) 
[13:36:37.671]                             next
[13:36:37.671]                           invokeRestart(restart)
[13:36:37.671]                           muffled <- TRUE
[13:36:37.671]                           break
[13:36:37.671]                         }
[13:36:37.671]                       }
[13:36:37.671]                     }
[13:36:37.671]                     invisible(muffled)
[13:36:37.671]                   }
[13:36:37.671]                   muffleCondition(cond)
[13:36:37.671]                 })
[13:36:37.671]             }))
[13:36:37.671]             future::FutureResult(value = ...future.value$value, 
[13:36:37.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.671]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.671]                     ...future.globalenv.names))
[13:36:37.671]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.671]         }, condition = base::local({
[13:36:37.671]             c <- base::c
[13:36:37.671]             inherits <- base::inherits
[13:36:37.671]             invokeRestart <- base::invokeRestart
[13:36:37.671]             length <- base::length
[13:36:37.671]             list <- base::list
[13:36:37.671]             seq.int <- base::seq.int
[13:36:37.671]             signalCondition <- base::signalCondition
[13:36:37.671]             sys.calls <- base::sys.calls
[13:36:37.671]             `[[` <- base::`[[`
[13:36:37.671]             `+` <- base::`+`
[13:36:37.671]             `<<-` <- base::`<<-`
[13:36:37.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.671]                   3L)]
[13:36:37.671]             }
[13:36:37.671]             function(cond) {
[13:36:37.671]                 is_error <- inherits(cond, "error")
[13:36:37.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.671]                   NULL)
[13:36:37.671]                 if (is_error) {
[13:36:37.671]                   sessionInformation <- function() {
[13:36:37.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.671]                       search = base::search(), system = base::Sys.info())
[13:36:37.671]                   }
[13:36:37.671]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.671]                     cond$call), session = sessionInformation(), 
[13:36:37.671]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.671]                   signalCondition(cond)
[13:36:37.671]                 }
[13:36:37.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.671]                 "immediateCondition"))) {
[13:36:37.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.671]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.671]                   if (TRUE && !signal) {
[13:36:37.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.671]                     {
[13:36:37.671]                       inherits <- base::inherits
[13:36:37.671]                       invokeRestart <- base::invokeRestart
[13:36:37.671]                       is.null <- base::is.null
[13:36:37.671]                       muffled <- FALSE
[13:36:37.671]                       if (inherits(cond, "message")) {
[13:36:37.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.671]                         if (muffled) 
[13:36:37.671]                           invokeRestart("muffleMessage")
[13:36:37.671]                       }
[13:36:37.671]                       else if (inherits(cond, "warning")) {
[13:36:37.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.671]                         if (muffled) 
[13:36:37.671]                           invokeRestart("muffleWarning")
[13:36:37.671]                       }
[13:36:37.671]                       else if (inherits(cond, "condition")) {
[13:36:37.671]                         if (!is.null(pattern)) {
[13:36:37.671]                           computeRestarts <- base::computeRestarts
[13:36:37.671]                           grepl <- base::grepl
[13:36:37.671]                           restarts <- computeRestarts(cond)
[13:36:37.671]                           for (restart in restarts) {
[13:36:37.671]                             name <- restart$name
[13:36:37.671]                             if (is.null(name)) 
[13:36:37.671]                               next
[13:36:37.671]                             if (!grepl(pattern, name)) 
[13:36:37.671]                               next
[13:36:37.671]                             invokeRestart(restart)
[13:36:37.671]                             muffled <- TRUE
[13:36:37.671]                             break
[13:36:37.671]                           }
[13:36:37.671]                         }
[13:36:37.671]                       }
[13:36:37.671]                       invisible(muffled)
[13:36:37.671]                     }
[13:36:37.671]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.671]                   }
[13:36:37.671]                 }
[13:36:37.671]                 else {
[13:36:37.671]                   if (TRUE) {
[13:36:37.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.671]                     {
[13:36:37.671]                       inherits <- base::inherits
[13:36:37.671]                       invokeRestart <- base::invokeRestart
[13:36:37.671]                       is.null <- base::is.null
[13:36:37.671]                       muffled <- FALSE
[13:36:37.671]                       if (inherits(cond, "message")) {
[13:36:37.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.671]                         if (muffled) 
[13:36:37.671]                           invokeRestart("muffleMessage")
[13:36:37.671]                       }
[13:36:37.671]                       else if (inherits(cond, "warning")) {
[13:36:37.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.671]                         if (muffled) 
[13:36:37.671]                           invokeRestart("muffleWarning")
[13:36:37.671]                       }
[13:36:37.671]                       else if (inherits(cond, "condition")) {
[13:36:37.671]                         if (!is.null(pattern)) {
[13:36:37.671]                           computeRestarts <- base::computeRestarts
[13:36:37.671]                           grepl <- base::grepl
[13:36:37.671]                           restarts <- computeRestarts(cond)
[13:36:37.671]                           for (restart in restarts) {
[13:36:37.671]                             name <- restart$name
[13:36:37.671]                             if (is.null(name)) 
[13:36:37.671]                               next
[13:36:37.671]                             if (!grepl(pattern, name)) 
[13:36:37.671]                               next
[13:36:37.671]                             invokeRestart(restart)
[13:36:37.671]                             muffled <- TRUE
[13:36:37.671]                             break
[13:36:37.671]                           }
[13:36:37.671]                         }
[13:36:37.671]                       }
[13:36:37.671]                       invisible(muffled)
[13:36:37.671]                     }
[13:36:37.671]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.671]                   }
[13:36:37.671]                 }
[13:36:37.671]             }
[13:36:37.671]         }))
[13:36:37.671]     }, error = function(ex) {
[13:36:37.671]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.671]                 ...future.rng), started = ...future.startTime, 
[13:36:37.671]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.671]             version = "1.8"), class = "FutureResult")
[13:36:37.671]     }, finally = {
[13:36:37.671]         if (!identical(...future.workdir, getwd())) 
[13:36:37.671]             setwd(...future.workdir)
[13:36:37.671]         {
[13:36:37.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.671]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.671]             }
[13:36:37.671]             base::options(...future.oldOptions)
[13:36:37.671]             if (.Platform$OS.type == "windows") {
[13:36:37.671]                 old_names <- names(...future.oldEnvVars)
[13:36:37.671]                 envs <- base::Sys.getenv()
[13:36:37.671]                 names <- names(envs)
[13:36:37.671]                 common <- intersect(names, old_names)
[13:36:37.671]                 added <- setdiff(names, old_names)
[13:36:37.671]                 removed <- setdiff(old_names, names)
[13:36:37.671]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.671]                   envs[common]]
[13:36:37.671]                 NAMES <- toupper(changed)
[13:36:37.671]                 args <- list()
[13:36:37.671]                 for (kk in seq_along(NAMES)) {
[13:36:37.671]                   name <- changed[[kk]]
[13:36:37.671]                   NAME <- NAMES[[kk]]
[13:36:37.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.671]                     next
[13:36:37.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.671]                 }
[13:36:37.671]                 NAMES <- toupper(added)
[13:36:37.671]                 for (kk in seq_along(NAMES)) {
[13:36:37.671]                   name <- added[[kk]]
[13:36:37.671]                   NAME <- NAMES[[kk]]
[13:36:37.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.671]                     next
[13:36:37.671]                   args[[name]] <- ""
[13:36:37.671]                 }
[13:36:37.671]                 NAMES <- toupper(removed)
[13:36:37.671]                 for (kk in seq_along(NAMES)) {
[13:36:37.671]                   name <- removed[[kk]]
[13:36:37.671]                   NAME <- NAMES[[kk]]
[13:36:37.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.671]                     next
[13:36:37.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.671]                 }
[13:36:37.671]                 if (length(args) > 0) 
[13:36:37.671]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.671]             }
[13:36:37.671]             else {
[13:36:37.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.671]             }
[13:36:37.671]             {
[13:36:37.671]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.671]                   0L) {
[13:36:37.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.671]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.671]                   base::options(opts)
[13:36:37.671]                 }
[13:36:37.671]                 {
[13:36:37.671]                   {
[13:36:37.671]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.671]                     NULL
[13:36:37.671]                   }
[13:36:37.671]                   options(future.plan = NULL)
[13:36:37.671]                   if (is.na(NA_character_)) 
[13:36:37.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.671]                     .init = FALSE)
[13:36:37.671]                 }
[13:36:37.671]             }
[13:36:37.671]         }
[13:36:37.671]     })
[13:36:37.671]     if (TRUE) {
[13:36:37.671]         base::sink(type = "output", split = FALSE)
[13:36:37.671]         if (TRUE) {
[13:36:37.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.671]         }
[13:36:37.671]         else {
[13:36:37.671]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.671]         }
[13:36:37.671]         base::close(...future.stdout)
[13:36:37.671]         ...future.stdout <- NULL
[13:36:37.671]     }
[13:36:37.671]     ...future.result$conditions <- ...future.conditions
[13:36:37.671]     ...future.result$finished <- base::Sys.time()
[13:36:37.671]     ...future.result
[13:36:37.671] }
[13:36:37.675] requestCore(): workers = 2
[13:36:37.675] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:37.686] result() for MulticoreFuture ...
[13:36:37.687] result() for MulticoreFuture ...
[13:36:37.687] result() for MulticoreFuture ... done
[13:36:37.687] result() for MulticoreFuture ... done
[13:36:37.688] result() for MulticoreFuture ...
[13:36:37.688] result() for MulticoreFuture ... done
[13:36:37.690] MulticoreFuture started
[13:36:37.691] - Launch lazy future ... done
[13:36:37.691] run() for ‘MulticoreFuture’ ... done
[13:36:37.692] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x564a733a2488> 
[13:36:37.692] List of future strategies:
[13:36:37.692] 1. sequential:
[13:36:37.692]    - args: function (..., envir = parent.frame())
[13:36:37.692]    - tweaked: FALSE
[13:36:37.692]    - call: NULL
[13:36:37.693] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x564a73fd7608> 
 - attr(*, "dim.")=[13:36:37.696] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=[13:36:37.696] List of future strategies:
[13:36:37.696] 1. multicore:
[13:36:37.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.696]    - tweaked: FALSE
[13:36:37.696]    - call: plan(strategy)
List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:36:37.702] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:37.706] resolve() on list environment ...
[13:36:37.706]  recursive: 0
[13:36:37.707]  length: 6
[13:36:37.708]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:37.708] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.708] - nx: 6
[13:36:37.708] - relay: TRUE
[13:36:37.708] - stdout: TRUE
[13:36:37.708] - signal: TRUE
[13:36:37.708] - resignal: FALSE
[13:36:37.708] - force: TRUE
[13:36:37.709] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.709] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.709]  - until=2
[13:36:37.709]  - relaying element #2
[13:36:37.709] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.709] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.709] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.710]  length: 5 (resolved future 1)
[13:36:37.710] Future #2
[13:36:37.710] result() for MulticoreFuture ...
[13:36:37.710] result() for MulticoreFuture ... done
[13:36:37.710] result() for MulticoreFuture ...
[13:36:37.710] result() for MulticoreFuture ... done
[13:36:37.710] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:37.711] - nx: 6
[13:36:37.711] - relay: TRUE
[13:36:37.711] - stdout: TRUE
[13:36:37.711] - signal: TRUE
[13:36:37.711] - resignal: FALSE
[13:36:37.711] - force: TRUE
[13:36:37.711] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.711] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.712]  - until=2
[13:36:37.712]  - relaying element #2
[13:36:37.712] result() for MulticoreFuture ...
[13:36:37.712] result() for MulticoreFuture ... done
[13:36:37.712] result() for MulticoreFuture ...
[13:36:37.712] result() for MulticoreFuture ... done
[13:36:37.712] result() for MulticoreFuture ...
[13:36:37.713] result() for MulticoreFuture ... done
[13:36:37.713] result() for MulticoreFuture ...
[13:36:37.713] result() for MulticoreFuture ... done
[13:36:37.713] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.713] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.713] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:37.713]  length: 4 (resolved future 2)
[13:36:37.714] Future #3
[13:36:37.714] result() for MulticoreFuture ...
[13:36:37.715] result() for MulticoreFuture ...
[13:36:37.715] result() for MulticoreFuture ... done
[13:36:37.715] result() for MulticoreFuture ... done
[13:36:37.715] result() for MulticoreFuture ...
[13:36:37.716] result() for MulticoreFuture ... done
[13:36:37.716] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:37.716] - nx: 6
[13:36:37.716] - relay: TRUE
[13:36:37.716] - stdout: TRUE
[13:36:37.717] - signal: TRUE
[13:36:37.717] - resignal: FALSE
[13:36:37.717] - force: TRUE
[13:36:37.717] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.717] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.717]  - until=3
[13:36:37.718]  - relaying element #3
[13:36:37.718] result() for MulticoreFuture ...
[13:36:37.718] result() for MulticoreFuture ... done
[13:36:37.718] result() for MulticoreFuture ...
[13:36:37.718] result() for MulticoreFuture ... done
[13:36:37.718] result() for MulticoreFuture ...
[13:36:37.719] result() for MulticoreFuture ... done
[13:36:37.719] result() for MulticoreFuture ...
[13:36:37.719] result() for MulticoreFuture ... done
[13:36:37.719] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.719] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.719] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:37.719]  length: 3 (resolved future 3)
[13:36:37.720] Future #4
[13:36:37.720] result() for MulticoreFuture ...
[13:36:37.720] result() for MulticoreFuture ...
[13:36:37.721] result() for MulticoreFuture ... done
[13:36:37.721] result() for MulticoreFuture ... done
[13:36:37.721] result() for MulticoreFuture ...
[13:36:37.721] result() for MulticoreFuture ... done
[13:36:37.721] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:37.722] - nx: 6
[13:36:37.722] - relay: TRUE
[13:36:37.722] - stdout: TRUE
[13:36:37.722] - signal: TRUE
[13:36:37.722] - resignal: FALSE
[13:36:37.722] - force: TRUE
[13:36:37.723] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.723] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.723]  - until=4
[13:36:37.723]  - relaying element #4
[13:36:37.723] result() for MulticoreFuture ...
[13:36:37.723] result() for MulticoreFuture ... done
[13:36:37.724] result() for MulticoreFuture ...
[13:36:37.724] result() for MulticoreFuture ... done
[13:36:37.724] result() for MulticoreFuture ...
[13:36:37.724] result() for MulticoreFuture ... done
[13:36:37.724] result() for MulticoreFuture ...
[13:36:37.724] result() for MulticoreFuture ... done
[13:36:37.724] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.724] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.725] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:37.725]  length: 2 (resolved future 4)
[13:36:37.725] signalConditionsASAP(NULL, pos=5) ...
[13:36:37.725] - nx: 6
[13:36:37.725] - relay: TRUE
[13:36:37.725] - stdout: TRUE
[13:36:37.725] - signal: TRUE
[13:36:37.725] - resignal: FALSE
[13:36:37.725] - force: TRUE
[13:36:37.726] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.726] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.726]  - until=6
[13:36:37.726]  - relaying element #6
[13:36:37.726] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.726] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.726] signalConditionsASAP(NULL, pos=5) ... done
[13:36:37.726]  length: 1 (resolved future 5)
[13:36:37.726] signalConditionsASAP(numeric, pos=6) ...
[13:36:37.727] - nx: 6
[13:36:37.727] - relay: TRUE
[13:36:37.727] - stdout: TRUE
[13:36:37.727] - signal: TRUE
[13:36:37.727] - resignal: FALSE
[13:36:37.727] - force: TRUE
[13:36:37.727] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.727] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.727]  - until=6
[13:36:37.727] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.728] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.728] signalConditionsASAP(numeric, pos=6) ... done
[13:36:37.728]  length: 0 (resolved future 6)
[13:36:37.728] Relaying remaining futures
[13:36:37.728] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.728] - nx: 6
[13:36:37.728] - relay: TRUE
[13:36:37.728] - stdout: TRUE
[13:36:37.728] - signal: TRUE
[13:36:37.728] - resignal: FALSE
[13:36:37.729] - force: TRUE
[13:36:37.729] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.729] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:37.729] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.729] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.729] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.729] resolve() on list environment ... DONE
[13:36:37.729] result() for MulticoreFuture ...
[13:36:37.729] result() for MulticoreFuture ... done
[13:36:37.730] result() for MulticoreFuture ...
[13:36:37.730] result() for MulticoreFuture ... done
[13:36:37.730] result() for MulticoreFuture ...
[13:36:37.730] result() for MulticoreFuture ... done
[13:36:37.730] result() for MulticoreFuture ...
[13:36:37.730] result() for MulticoreFuture ... done
[13:36:37.730] result() for MulticoreFuture ...
[13:36:37.731] result() for MulticoreFuture ... done
[13:36:37.731] result() for MulticoreFuture ...
[13:36:37.731] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a742e2148> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:36:37.733] getGlobalsAndPackages() ...
[13:36:37.733] Searching for globals...
[13:36:37.733] 
[13:36:37.733] Searching for globals ... DONE
[13:36:37.734] - globals: [0] <none>
[13:36:37.734] getGlobalsAndPackages() ... DONE
[13:36:37.734] run() for ‘Future’ ...
[13:36:37.734] - state: ‘created’
[13:36:37.734] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.738] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.739]   - Field: ‘label’
[13:36:37.739]   - Field: ‘local’
[13:36:37.739]   - Field: ‘owner’
[13:36:37.739]   - Field: ‘envir’
[13:36:37.739]   - Field: ‘workers’
[13:36:37.739]   - Field: ‘packages’
[13:36:37.739]   - Field: ‘gc’
[13:36:37.739]   - Field: ‘job’
[13:36:37.740]   - Field: ‘conditions’
[13:36:37.740]   - Field: ‘expr’
[13:36:37.740]   - Field: ‘uuid’
[13:36:37.740]   - Field: ‘seed’
[13:36:37.740]   - Field: ‘version’
[13:36:37.740]   - Field: ‘result’
[13:36:37.740]   - Field: ‘asynchronous’
[13:36:37.740]   - Field: ‘calls’
[13:36:37.740]   - Field: ‘globals’
[13:36:37.741]   - Field: ‘stdout’
[13:36:37.741]   - Field: ‘earlySignal’
[13:36:37.741]   - Field: ‘lazy’
[13:36:37.741]   - Field: ‘state’
[13:36:37.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.741] - Launch lazy future ...
[13:36:37.741] Packages needed by the future expression (n = 0): <none>
[13:36:37.742] Packages needed by future strategies (n = 0): <none>
[13:36:37.742] {
[13:36:37.742]     {
[13:36:37.742]         {
[13:36:37.742]             ...future.startTime <- base::Sys.time()
[13:36:37.742]             {
[13:36:37.742]                 {
[13:36:37.742]                   {
[13:36:37.742]                     {
[13:36:37.742]                       base::local({
[13:36:37.742]                         has_future <- base::requireNamespace("future", 
[13:36:37.742]                           quietly = TRUE)
[13:36:37.742]                         if (has_future) {
[13:36:37.742]                           ns <- base::getNamespace("future")
[13:36:37.742]                           version <- ns[[".package"]][["version"]]
[13:36:37.742]                           if (is.null(version)) 
[13:36:37.742]                             version <- utils::packageVersion("future")
[13:36:37.742]                         }
[13:36:37.742]                         else {
[13:36:37.742]                           version <- NULL
[13:36:37.742]                         }
[13:36:37.742]                         if (!has_future || version < "1.8.0") {
[13:36:37.742]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.742]                             "", base::R.version$version.string), 
[13:36:37.742]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.742]                               "release", "version")], collapse = " "), 
[13:36:37.742]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.742]                             info)
[13:36:37.742]                           info <- base::paste(info, collapse = "; ")
[13:36:37.742]                           if (!has_future) {
[13:36:37.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.742]                               info)
[13:36:37.742]                           }
[13:36:37.742]                           else {
[13:36:37.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.742]                               info, version)
[13:36:37.742]                           }
[13:36:37.742]                           base::stop(msg)
[13:36:37.742]                         }
[13:36:37.742]                       })
[13:36:37.742]                     }
[13:36:37.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.742]                     base::options(mc.cores = 1L)
[13:36:37.742]                   }
[13:36:37.742]                   ...future.strategy.old <- future::plan("list")
[13:36:37.742]                   options(future.plan = NULL)
[13:36:37.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.742]                 }
[13:36:37.742]                 ...future.workdir <- getwd()
[13:36:37.742]             }
[13:36:37.742]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.742]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.742]         }
[13:36:37.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.742]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.742]             base::names(...future.oldOptions))
[13:36:37.742]     }
[13:36:37.742]     if (FALSE) {
[13:36:37.742]     }
[13:36:37.742]     else {
[13:36:37.742]         if (TRUE) {
[13:36:37.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.742]                 open = "w")
[13:36:37.742]         }
[13:36:37.742]         else {
[13:36:37.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.742]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.742]         }
[13:36:37.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.742]             base::sink(type = "output", split = FALSE)
[13:36:37.742]             base::close(...future.stdout)
[13:36:37.742]         }, add = TRUE)
[13:36:37.742]     }
[13:36:37.742]     ...future.frame <- base::sys.nframe()
[13:36:37.742]     ...future.conditions <- base::list()
[13:36:37.742]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.742]     if (FALSE) {
[13:36:37.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.742]     }
[13:36:37.742]     ...future.result <- base::tryCatch({
[13:36:37.742]         base::withCallingHandlers({
[13:36:37.742]             ...future.value <- base::withVisible(base::local({
[13:36:37.742]                 withCallingHandlers({
[13:36:37.742]                   2
[13:36:37.742]                 }, immediateCondition = function(cond) {
[13:36:37.742]                   save_rds <- function (object, pathname, ...) 
[13:36:37.742]                   {
[13:36:37.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.742]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.742]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.742]                         fi_tmp[["mtime"]])
[13:36:37.742]                     }
[13:36:37.742]                     tryCatch({
[13:36:37.742]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.742]                     }, error = function(ex) {
[13:36:37.742]                       msg <- conditionMessage(ex)
[13:36:37.742]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.742]                         fi_tmp[["mtime"]], msg)
[13:36:37.742]                       ex$message <- msg
[13:36:37.742]                       stop(ex)
[13:36:37.742]                     })
[13:36:37.742]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.742]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.742]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.742]                       fi <- file.info(pathname)
[13:36:37.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.742]                         fi[["size"]], fi[["mtime"]])
[13:36:37.742]                       stop(msg)
[13:36:37.742]                     }
[13:36:37.742]                     invisible(pathname)
[13:36:37.742]                   }
[13:36:37.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.742]                     rootPath = tempdir()) 
[13:36:37.742]                   {
[13:36:37.742]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.742]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.742]                       tmpdir = path, fileext = ".rds")
[13:36:37.742]                     save_rds(obj, file)
[13:36:37.742]                   }
[13:36:37.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.742]                   {
[13:36:37.742]                     inherits <- base::inherits
[13:36:37.742]                     invokeRestart <- base::invokeRestart
[13:36:37.742]                     is.null <- base::is.null
[13:36:37.742]                     muffled <- FALSE
[13:36:37.742]                     if (inherits(cond, "message")) {
[13:36:37.742]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.742]                       if (muffled) 
[13:36:37.742]                         invokeRestart("muffleMessage")
[13:36:37.742]                     }
[13:36:37.742]                     else if (inherits(cond, "warning")) {
[13:36:37.742]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.742]                       if (muffled) 
[13:36:37.742]                         invokeRestart("muffleWarning")
[13:36:37.742]                     }
[13:36:37.742]                     else if (inherits(cond, "condition")) {
[13:36:37.742]                       if (!is.null(pattern)) {
[13:36:37.742]                         computeRestarts <- base::computeRestarts
[13:36:37.742]                         grepl <- base::grepl
[13:36:37.742]                         restarts <- computeRestarts(cond)
[13:36:37.742]                         for (restart in restarts) {
[13:36:37.742]                           name <- restart$name
[13:36:37.742]                           if (is.null(name)) 
[13:36:37.742]                             next
[13:36:37.742]                           if (!grepl(pattern, name)) 
[13:36:37.742]                             next
[13:36:37.742]                           invokeRestart(restart)
[13:36:37.742]                           muffled <- TRUE
[13:36:37.742]                           break
[13:36:37.742]                         }
[13:36:37.742]                       }
[13:36:37.742]                     }
[13:36:37.742]                     invisible(muffled)
[13:36:37.742]                   }
[13:36:37.742]                   muffleCondition(cond)
[13:36:37.742]                 })
[13:36:37.742]             }))
[13:36:37.742]             future::FutureResult(value = ...future.value$value, 
[13:36:37.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.742]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.742]                     ...future.globalenv.names))
[13:36:37.742]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.742]         }, condition = base::local({
[13:36:37.742]             c <- base::c
[13:36:37.742]             inherits <- base::inherits
[13:36:37.742]             invokeRestart <- base::invokeRestart
[13:36:37.742]             length <- base::length
[13:36:37.742]             list <- base::list
[13:36:37.742]             seq.int <- base::seq.int
[13:36:37.742]             signalCondition <- base::signalCondition
[13:36:37.742]             sys.calls <- base::sys.calls
[13:36:37.742]             `[[` <- base::`[[`
[13:36:37.742]             `+` <- base::`+`
[13:36:37.742]             `<<-` <- base::`<<-`
[13:36:37.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.742]                   3L)]
[13:36:37.742]             }
[13:36:37.742]             function(cond) {
[13:36:37.742]                 is_error <- inherits(cond, "error")
[13:36:37.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.742]                   NULL)
[13:36:37.742]                 if (is_error) {
[13:36:37.742]                   sessionInformation <- function() {
[13:36:37.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.742]                       search = base::search(), system = base::Sys.info())
[13:36:37.742]                   }
[13:36:37.742]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.742]                     cond$call), session = sessionInformation(), 
[13:36:37.742]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.742]                   signalCondition(cond)
[13:36:37.742]                 }
[13:36:37.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.742]                 "immediateCondition"))) {
[13:36:37.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.742]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.742]                   if (TRUE && !signal) {
[13:36:37.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.742]                     {
[13:36:37.742]                       inherits <- base::inherits
[13:36:37.742]                       invokeRestart <- base::invokeRestart
[13:36:37.742]                       is.null <- base::is.null
[13:36:37.742]                       muffled <- FALSE
[13:36:37.742]                       if (inherits(cond, "message")) {
[13:36:37.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.742]                         if (muffled) 
[13:36:37.742]                           invokeRestart("muffleMessage")
[13:36:37.742]                       }
[13:36:37.742]                       else if (inherits(cond, "warning")) {
[13:36:37.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.742]                         if (muffled) 
[13:36:37.742]                           invokeRestart("muffleWarning")
[13:36:37.742]                       }
[13:36:37.742]                       else if (inherits(cond, "condition")) {
[13:36:37.742]                         if (!is.null(pattern)) {
[13:36:37.742]                           computeRestarts <- base::computeRestarts
[13:36:37.742]                           grepl <- base::grepl
[13:36:37.742]                           restarts <- computeRestarts(cond)
[13:36:37.742]                           for (restart in restarts) {
[13:36:37.742]                             name <- restart$name
[13:36:37.742]                             if (is.null(name)) 
[13:36:37.742]                               next
[13:36:37.742]                             if (!grepl(pattern, name)) 
[13:36:37.742]                               next
[13:36:37.742]                             invokeRestart(restart)
[13:36:37.742]                             muffled <- TRUE
[13:36:37.742]                             break
[13:36:37.742]                           }
[13:36:37.742]                         }
[13:36:37.742]                       }
[13:36:37.742]                       invisible(muffled)
[13:36:37.742]                     }
[13:36:37.742]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.742]                   }
[13:36:37.742]                 }
[13:36:37.742]                 else {
[13:36:37.742]                   if (TRUE) {
[13:36:37.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.742]                     {
[13:36:37.742]                       inherits <- base::inherits
[13:36:37.742]                       invokeRestart <- base::invokeRestart
[13:36:37.742]                       is.null <- base::is.null
[13:36:37.742]                       muffled <- FALSE
[13:36:37.742]                       if (inherits(cond, "message")) {
[13:36:37.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.742]                         if (muffled) 
[13:36:37.742]                           invokeRestart("muffleMessage")
[13:36:37.742]                       }
[13:36:37.742]                       else if (inherits(cond, "warning")) {
[13:36:37.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.742]                         if (muffled) 
[13:36:37.742]                           invokeRestart("muffleWarning")
[13:36:37.742]                       }
[13:36:37.742]                       else if (inherits(cond, "condition")) {
[13:36:37.742]                         if (!is.null(pattern)) {
[13:36:37.742]                           computeRestarts <- base::computeRestarts
[13:36:37.742]                           grepl <- base::grepl
[13:36:37.742]                           restarts <- computeRestarts(cond)
[13:36:37.742]                           for (restart in restarts) {
[13:36:37.742]                             name <- restart$name
[13:36:37.742]                             if (is.null(name)) 
[13:36:37.742]                               next
[13:36:37.742]                             if (!grepl(pattern, name)) 
[13:36:37.742]                               next
[13:36:37.742]                             invokeRestart(restart)
[13:36:37.742]                             muffled <- TRUE
[13:36:37.742]                             break
[13:36:37.742]                           }
[13:36:37.742]                         }
[13:36:37.742]                       }
[13:36:37.742]                       invisible(muffled)
[13:36:37.742]                     }
[13:36:37.742]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.742]                   }
[13:36:37.742]                 }
[13:36:37.742]             }
[13:36:37.742]         }))
[13:36:37.742]     }, error = function(ex) {
[13:36:37.742]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.742]                 ...future.rng), started = ...future.startTime, 
[13:36:37.742]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.742]             version = "1.8"), class = "FutureResult")
[13:36:37.742]     }, finally = {
[13:36:37.742]         if (!identical(...future.workdir, getwd())) 
[13:36:37.742]             setwd(...future.workdir)
[13:36:37.742]         {
[13:36:37.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.742]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.742]             }
[13:36:37.742]             base::options(...future.oldOptions)
[13:36:37.742]             if (.Platform$OS.type == "windows") {
[13:36:37.742]                 old_names <- names(...future.oldEnvVars)
[13:36:37.742]                 envs <- base::Sys.getenv()
[13:36:37.742]                 names <- names(envs)
[13:36:37.742]                 common <- intersect(names, old_names)
[13:36:37.742]                 added <- setdiff(names, old_names)
[13:36:37.742]                 removed <- setdiff(old_names, names)
[13:36:37.742]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.742]                   envs[common]]
[13:36:37.742]                 NAMES <- toupper(changed)
[13:36:37.742]                 args <- list()
[13:36:37.742]                 for (kk in seq_along(NAMES)) {
[13:36:37.742]                   name <- changed[[kk]]
[13:36:37.742]                   NAME <- NAMES[[kk]]
[13:36:37.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.742]                     next
[13:36:37.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.742]                 }
[13:36:37.742]                 NAMES <- toupper(added)
[13:36:37.742]                 for (kk in seq_along(NAMES)) {
[13:36:37.742]                   name <- added[[kk]]
[13:36:37.742]                   NAME <- NAMES[[kk]]
[13:36:37.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.742]                     next
[13:36:37.742]                   args[[name]] <- ""
[13:36:37.742]                 }
[13:36:37.742]                 NAMES <- toupper(removed)
[13:36:37.742]                 for (kk in seq_along(NAMES)) {
[13:36:37.742]                   name <- removed[[kk]]
[13:36:37.742]                   NAME <- NAMES[[kk]]
[13:36:37.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.742]                     next
[13:36:37.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.742]                 }
[13:36:37.742]                 if (length(args) > 0) 
[13:36:37.742]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.742]             }
[13:36:37.742]             else {
[13:36:37.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.742]             }
[13:36:37.742]             {
[13:36:37.742]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.742]                   0L) {
[13:36:37.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.742]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.742]                   base::options(opts)
[13:36:37.742]                 }
[13:36:37.742]                 {
[13:36:37.742]                   {
[13:36:37.742]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.742]                     NULL
[13:36:37.742]                   }
[13:36:37.742]                   options(future.plan = NULL)
[13:36:37.742]                   if (is.na(NA_character_)) 
[13:36:37.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.742]                     .init = FALSE)
[13:36:37.742]                 }
[13:36:37.742]             }
[13:36:37.742]         }
[13:36:37.742]     })
[13:36:37.742]     if (TRUE) {
[13:36:37.742]         base::sink(type = "output", split = FALSE)
[13:36:37.742]         if (TRUE) {
[13:36:37.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.742]         }
[13:36:37.742]         else {
[13:36:37.742]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.742]         }
[13:36:37.742]         base::close(...future.stdout)
[13:36:37.742]         ...future.stdout <- NULL
[13:36:37.742]     }
[13:36:37.742]     ...future.result$conditions <- ...future.conditions
[13:36:37.742]     ...future.result$finished <- base::Sys.time()
[13:36:37.742]     ...future.result
[13:36:37.742] }
[13:36:37.745] requestCore(): workers = 2
[13:36:37.747] MulticoreFuture started
[13:36:37.747] - Launch lazy future ... done
[13:36:37.747] run() for ‘MulticoreFuture’ ... done
[13:36:37.748] getGlobalsAndPackages() ...
[13:36:37.748] Searching for globals...
[13:36:37.748] plan(): Setting new future strategy stack:
[13:36:37.749] 
[13:36:37.748] List of future strategies:
[13:36:37.748] 1. sequential:
[13:36:37.748]    - args: function (..., envir = parent.frame())
[13:36:37.748]    - tweaked: FALSE
[13:36:37.748]    - call: NULL
[13:36:37.749] Searching for globals ... DONE
[13:36:37.749] - globals: [0] <none>
[13:36:37.749] plan(): nbrOfWorkers() = 1
[13:36:37.749] getGlobalsAndPackages() ... DONE
[13:36:37.750] run() for ‘Future’ ...
[13:36:37.750] - state: ‘created’
[13:36:37.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.751] plan(): Setting new future strategy stack:
[13:36:37.751] List of future strategies:
[13:36:37.751] 1. multicore:
[13:36:37.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.751]    - tweaked: FALSE
[13:36:37.751]    - call: plan(strategy)
[13:36:37.762] plan(): nbrOfWorkers() = 2
[13:36:37.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.763]   - Field: ‘label’
[13:36:37.763]   - Field: ‘local’
[13:36:37.763]   - Field: ‘owner’
[13:36:37.764]   - Field: ‘envir’
[13:36:37.764]   - Field: ‘workers’
[13:36:37.764]   - Field: ‘packages’
[13:36:37.764]   - Field: ‘gc’
[13:36:37.764]   - Field: ‘job’
[13:36:37.764]   - Field: ‘conditions’
[13:36:37.764]   - Field: ‘expr’
[13:36:37.765]   - Field: ‘uuid’
[13:36:37.765]   - Field: ‘seed’
[13:36:37.765]   - Field: ‘version’
[13:36:37.765]   - Field: ‘result’
[13:36:37.765]   - Field: ‘asynchronous’
[13:36:37.765]   - Field: ‘calls’
[13:36:37.765]   - Field: ‘globals’
[13:36:37.766]   - Field: ‘stdout’
[13:36:37.766]   - Field: ‘earlySignal’
[13:36:37.766]   - Field: ‘lazy’
[13:36:37.766]   - Field: ‘state’
[13:36:37.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.766] - Launch lazy future ...
[13:36:37.767] Packages needed by the future expression (n = 0): <none>
[13:36:37.767] Packages needed by future strategies (n = 0): <none>
[13:36:37.768] {
[13:36:37.768]     {
[13:36:37.768]         {
[13:36:37.768]             ...future.startTime <- base::Sys.time()
[13:36:37.768]             {
[13:36:37.768]                 {
[13:36:37.768]                   {
[13:36:37.768]                     {
[13:36:37.768]                       base::local({
[13:36:37.768]                         has_future <- base::requireNamespace("future", 
[13:36:37.768]                           quietly = TRUE)
[13:36:37.768]                         if (has_future) {
[13:36:37.768]                           ns <- base::getNamespace("future")
[13:36:37.768]                           version <- ns[[".package"]][["version"]]
[13:36:37.768]                           if (is.null(version)) 
[13:36:37.768]                             version <- utils::packageVersion("future")
[13:36:37.768]                         }
[13:36:37.768]                         else {
[13:36:37.768]                           version <- NULL
[13:36:37.768]                         }
[13:36:37.768]                         if (!has_future || version < "1.8.0") {
[13:36:37.768]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.768]                             "", base::R.version$version.string), 
[13:36:37.768]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.768]                               "release", "version")], collapse = " "), 
[13:36:37.768]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.768]                             info)
[13:36:37.768]                           info <- base::paste(info, collapse = "; ")
[13:36:37.768]                           if (!has_future) {
[13:36:37.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.768]                               info)
[13:36:37.768]                           }
[13:36:37.768]                           else {
[13:36:37.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.768]                               info, version)
[13:36:37.768]                           }
[13:36:37.768]                           base::stop(msg)
[13:36:37.768]                         }
[13:36:37.768]                       })
[13:36:37.768]                     }
[13:36:37.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.768]                     base::options(mc.cores = 1L)
[13:36:37.768]                   }
[13:36:37.768]                   ...future.strategy.old <- future::plan("list")
[13:36:37.768]                   options(future.plan = NULL)
[13:36:37.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.768]                 }
[13:36:37.768]                 ...future.workdir <- getwd()
[13:36:37.768]             }
[13:36:37.768]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.768]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.768]         }
[13:36:37.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.768]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.768]             base::names(...future.oldOptions))
[13:36:37.768]     }
[13:36:37.768]     if (FALSE) {
[13:36:37.768]     }
[13:36:37.768]     else {
[13:36:37.768]         if (TRUE) {
[13:36:37.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.768]                 open = "w")
[13:36:37.768]         }
[13:36:37.768]         else {
[13:36:37.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.768]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.768]         }
[13:36:37.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.768]             base::sink(type = "output", split = FALSE)
[13:36:37.768]             base::close(...future.stdout)
[13:36:37.768]         }, add = TRUE)
[13:36:37.768]     }
[13:36:37.768]     ...future.frame <- base::sys.nframe()
[13:36:37.768]     ...future.conditions <- base::list()
[13:36:37.768]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.768]     if (FALSE) {
[13:36:37.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.768]     }
[13:36:37.768]     ...future.result <- base::tryCatch({
[13:36:37.768]         base::withCallingHandlers({
[13:36:37.768]             ...future.value <- base::withVisible(base::local({
[13:36:37.768]                 withCallingHandlers({
[13:36:37.768]                   NULL
[13:36:37.768]                 }, immediateCondition = function(cond) {
[13:36:37.768]                   save_rds <- function (object, pathname, ...) 
[13:36:37.768]                   {
[13:36:37.768]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.768]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.768]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.768]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.768]                         fi_tmp[["mtime"]])
[13:36:37.768]                     }
[13:36:37.768]                     tryCatch({
[13:36:37.768]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.768]                     }, error = function(ex) {
[13:36:37.768]                       msg <- conditionMessage(ex)
[13:36:37.768]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.768]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.768]                         fi_tmp[["mtime"]], msg)
[13:36:37.768]                       ex$message <- msg
[13:36:37.768]                       stop(ex)
[13:36:37.768]                     })
[13:36:37.768]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.768]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.768]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.768]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.768]                       fi <- file.info(pathname)
[13:36:37.768]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.768]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.768]                         fi[["size"]], fi[["mtime"]])
[13:36:37.768]                       stop(msg)
[13:36:37.768]                     }
[13:36:37.768]                     invisible(pathname)
[13:36:37.768]                   }
[13:36:37.768]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.768]                     rootPath = tempdir()) 
[13:36:37.768]                   {
[13:36:37.768]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.768]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.768]                       tmpdir = path, fileext = ".rds")
[13:36:37.768]                     save_rds(obj, file)
[13:36:37.768]                   }
[13:36:37.768]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.768]                   {
[13:36:37.768]                     inherits <- base::inherits
[13:36:37.768]                     invokeRestart <- base::invokeRestart
[13:36:37.768]                     is.null <- base::is.null
[13:36:37.768]                     muffled <- FALSE
[13:36:37.768]                     if (inherits(cond, "message")) {
[13:36:37.768]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.768]                       if (muffled) 
[13:36:37.768]                         invokeRestart("muffleMessage")
[13:36:37.768]                     }
[13:36:37.768]                     else if (inherits(cond, "warning")) {
[13:36:37.768]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.768]                       if (muffled) 
[13:36:37.768]                         invokeRestart("muffleWarning")
[13:36:37.768]                     }
[13:36:37.768]                     else if (inherits(cond, "condition")) {
[13:36:37.768]                       if (!is.null(pattern)) {
[13:36:37.768]                         computeRestarts <- base::computeRestarts
[13:36:37.768]                         grepl <- base::grepl
[13:36:37.768]                         restarts <- computeRestarts(cond)
[13:36:37.768]                         for (restart in restarts) {
[13:36:37.768]                           name <- restart$name
[13:36:37.768]                           if (is.null(name)) 
[13:36:37.768]                             next
[13:36:37.768]                           if (!grepl(pattern, name)) 
[13:36:37.768]                             next
[13:36:37.768]                           invokeRestart(restart)
[13:36:37.768]                           muffled <- TRUE
[13:36:37.768]                           break
[13:36:37.768]                         }
[13:36:37.768]                       }
[13:36:37.768]                     }
[13:36:37.768]                     invisible(muffled)
[13:36:37.768]                   }
[13:36:37.768]                   muffleCondition(cond)
[13:36:37.768]                 })
[13:36:37.768]             }))
[13:36:37.768]             future::FutureResult(value = ...future.value$value, 
[13:36:37.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.768]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.768]                     ...future.globalenv.names))
[13:36:37.768]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.768]         }, condition = base::local({
[13:36:37.768]             c <- base::c
[13:36:37.768]             inherits <- base::inherits
[13:36:37.768]             invokeRestart <- base::invokeRestart
[13:36:37.768]             length <- base::length
[13:36:37.768]             list <- base::list
[13:36:37.768]             seq.int <- base::seq.int
[13:36:37.768]             signalCondition <- base::signalCondition
[13:36:37.768]             sys.calls <- base::sys.calls
[13:36:37.768]             `[[` <- base::`[[`
[13:36:37.768]             `+` <- base::`+`
[13:36:37.768]             `<<-` <- base::`<<-`
[13:36:37.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.768]                   3L)]
[13:36:37.768]             }
[13:36:37.768]             function(cond) {
[13:36:37.768]                 is_error <- inherits(cond, "error")
[13:36:37.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.768]                   NULL)
[13:36:37.768]                 if (is_error) {
[13:36:37.768]                   sessionInformation <- function() {
[13:36:37.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.768]                       search = base::search(), system = base::Sys.info())
[13:36:37.768]                   }
[13:36:37.768]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.768]                     cond$call), session = sessionInformation(), 
[13:36:37.768]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.768]                   signalCondition(cond)
[13:36:37.768]                 }
[13:36:37.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.768]                 "immediateCondition"))) {
[13:36:37.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.768]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.768]                   if (TRUE && !signal) {
[13:36:37.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.768]                     {
[13:36:37.768]                       inherits <- base::inherits
[13:36:37.768]                       invokeRestart <- base::invokeRestart
[13:36:37.768]                       is.null <- base::is.null
[13:36:37.768]                       muffled <- FALSE
[13:36:37.768]                       if (inherits(cond, "message")) {
[13:36:37.768]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.768]                         if (muffled) 
[13:36:37.768]                           invokeRestart("muffleMessage")
[13:36:37.768]                       }
[13:36:37.768]                       else if (inherits(cond, "warning")) {
[13:36:37.768]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.768]                         if (muffled) 
[13:36:37.768]                           invokeRestart("muffleWarning")
[13:36:37.768]                       }
[13:36:37.768]                       else if (inherits(cond, "condition")) {
[13:36:37.768]                         if (!is.null(pattern)) {
[13:36:37.768]                           computeRestarts <- base::computeRestarts
[13:36:37.768]                           grepl <- base::grepl
[13:36:37.768]                           restarts <- computeRestarts(cond)
[13:36:37.768]                           for (restart in restarts) {
[13:36:37.768]                             name <- restart$name
[13:36:37.768]                             if (is.null(name)) 
[13:36:37.768]                               next
[13:36:37.768]                             if (!grepl(pattern, name)) 
[13:36:37.768]                               next
[13:36:37.768]                             invokeRestart(restart)
[13:36:37.768]                             muffled <- TRUE
[13:36:37.768]                             break
[13:36:37.768]                           }
[13:36:37.768]                         }
[13:36:37.768]                       }
[13:36:37.768]                       invisible(muffled)
[13:36:37.768]                     }
[13:36:37.768]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.768]                   }
[13:36:37.768]                 }
[13:36:37.768]                 else {
[13:36:37.768]                   if (TRUE) {
[13:36:37.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.768]                     {
[13:36:37.768]                       inherits <- base::inherits
[13:36:37.768]                       invokeRestart <- base::invokeRestart
[13:36:37.768]                       is.null <- base::is.null
[13:36:37.768]                       muffled <- FALSE
[13:36:37.768]                       if (inherits(cond, "message")) {
[13:36:37.768]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.768]                         if (muffled) 
[13:36:37.768]                           invokeRestart("muffleMessage")
[13:36:37.768]                       }
[13:36:37.768]                       else if (inherits(cond, "warning")) {
[13:36:37.768]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.768]                         if (muffled) 
[13:36:37.768]                           invokeRestart("muffleWarning")
[13:36:37.768]                       }
[13:36:37.768]                       else if (inherits(cond, "condition")) {
[13:36:37.768]                         if (!is.null(pattern)) {
[13:36:37.768]                           computeRestarts <- base::computeRestarts
[13:36:37.768]                           grepl <- base::grepl
[13:36:37.768]                           restarts <- computeRestarts(cond)
[13:36:37.768]                           for (restart in restarts) {
[13:36:37.768]                             name <- restart$name
[13:36:37.768]                             if (is.null(name)) 
[13:36:37.768]                               next
[13:36:37.768]                             if (!grepl(pattern, name)) 
[13:36:37.768]                               next
[13:36:37.768]                             invokeRestart(restart)
[13:36:37.768]                             muffled <- TRUE
[13:36:37.768]                             break
[13:36:37.768]                           }
[13:36:37.768]                         }
[13:36:37.768]                       }
[13:36:37.768]                       invisible(muffled)
[13:36:37.768]                     }
[13:36:37.768]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.768]                   }
[13:36:37.768]                 }
[13:36:37.768]             }
[13:36:37.768]         }))
[13:36:37.768]     }, error = function(ex) {
[13:36:37.768]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.768]                 ...future.rng), started = ...future.startTime, 
[13:36:37.768]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.768]             version = "1.8"), class = "FutureResult")
[13:36:37.768]     }, finally = {
[13:36:37.768]         if (!identical(...future.workdir, getwd())) 
[13:36:37.768]             setwd(...future.workdir)
[13:36:37.768]         {
[13:36:37.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.768]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.768]             }
[13:36:37.768]             base::options(...future.oldOptions)
[13:36:37.768]             if (.Platform$OS.type == "windows") {
[13:36:37.768]                 old_names <- names(...future.oldEnvVars)
[13:36:37.768]                 envs <- base::Sys.getenv()
[13:36:37.768]                 names <- names(envs)
[13:36:37.768]                 common <- intersect(names, old_names)
[13:36:37.768]                 added <- setdiff(names, old_names)
[13:36:37.768]                 removed <- setdiff(old_names, names)
[13:36:37.768]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.768]                   envs[common]]
[13:36:37.768]                 NAMES <- toupper(changed)
[13:36:37.768]                 args <- list()
[13:36:37.768]                 for (kk in seq_along(NAMES)) {
[13:36:37.768]                   name <- changed[[kk]]
[13:36:37.768]                   NAME <- NAMES[[kk]]
[13:36:37.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.768]                     next
[13:36:37.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.768]                 }
[13:36:37.768]                 NAMES <- toupper(added)
[13:36:37.768]                 for (kk in seq_along(NAMES)) {
[13:36:37.768]                   name <- added[[kk]]
[13:36:37.768]                   NAME <- NAMES[[kk]]
[13:36:37.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.768]                     next
[13:36:37.768]                   args[[name]] <- ""
[13:36:37.768]                 }
[13:36:37.768]                 NAMES <- toupper(removed)
[13:36:37.768]                 for (kk in seq_along(NAMES)) {
[13:36:37.768]                   name <- removed[[kk]]
[13:36:37.768]                   NAME <- NAMES[[kk]]
[13:36:37.768]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.768]                     next
[13:36:37.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.768]                 }
[13:36:37.768]                 if (length(args) > 0) 
[13:36:37.768]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.768]             }
[13:36:37.768]             else {
[13:36:37.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.768]             }
[13:36:37.768]             {
[13:36:37.768]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.768]                   0L) {
[13:36:37.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.768]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.768]                   base::options(opts)
[13:36:37.768]                 }
[13:36:37.768]                 {
[13:36:37.768]                   {
[13:36:37.768]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.768]                     NULL
[13:36:37.768]                   }
[13:36:37.768]                   options(future.plan = NULL)
[13:36:37.768]                   if (is.na(NA_character_)) 
[13:36:37.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.768]                     .init = FALSE)
[13:36:37.768]                 }
[13:36:37.768]             }
[13:36:37.768]         }
[13:36:37.768]     })
[13:36:37.768]     if (TRUE) {
[13:36:37.768]         base::sink(type = "output", split = FALSE)
[13:36:37.768]         if (TRUE) {
[13:36:37.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.768]         }
[13:36:37.768]         else {
[13:36:37.768]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.768]         }
[13:36:37.768]         base::close(...future.stdout)
[13:36:37.768]         ...future.stdout <- NULL
[13:36:37.768]     }
[13:36:37.768]     ...future.result$conditions <- ...future.conditions
[13:36:37.768]     ...future.result$finished <- base::Sys.time()
[13:36:37.768]     ...future.result
[13:36:37.768] }
[13:36:37.771] requestCore(): workers = 2
[13:36:37.773] MulticoreFuture started
[13:36:37.774] - Launch lazy future ... done
[13:36:37.774] run() for ‘MulticoreFuture’ ... done
[13:36:37.775] plan(): Setting new future strategy stack:
[13:36:37.775] getGlobalsAndPackages() ...
[13:36:37.775] Searching for globals...
[13:36:37.775] List of future strategies:
[13:36:37.775] 1. sequential:
[13:36:37.775]    - args: function (..., envir = parent.frame())
[13:36:37.775]    - tweaked: FALSE
[13:36:37.775]    - call: NULL
[13:36:37.776] plan(): nbrOfWorkers() = 1
[13:36:37.777] - globals found: [1] ‘{’
[13:36:37.777] Searching for globals ... DONE
[13:36:37.777] Resolving globals: FALSE
[13:36:37.778] 
[13:36:37.778] 
[13:36:37.778] getGlobalsAndPackages() ... DONE
[13:36:37.778] plan(): Setting new future strategy stack:
[13:36:37.778] run() for ‘Future’ ...
[13:36:37.779] - state: ‘created’
[13:36:37.778] List of future strategies:
[13:36:37.778] 1. multicore:
[13:36:37.778]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.778]    - tweaked: FALSE
[13:36:37.778]    - call: plan(strategy)
[13:36:37.779] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.784] plan(): nbrOfWorkers() = 2
[13:36:37.784] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.784]   - Field: ‘label’
[13:36:37.784]   - Field: ‘local’
[13:36:37.784]   - Field: ‘owner’
[13:36:37.785]   - Field: ‘envir’
[13:36:37.785]   - Field: ‘workers’
[13:36:37.785]   - Field: ‘packages’
[13:36:37.785]   - Field: ‘gc’
[13:36:37.785]   - Field: ‘job’
[13:36:37.785]   - Field: ‘conditions’
[13:36:37.785]   - Field: ‘expr’
[13:36:37.786]   - Field: ‘uuid’
[13:36:37.786]   - Field: ‘seed’
[13:36:37.786]   - Field: ‘version’
[13:36:37.786]   - Field: ‘result’
[13:36:37.786]   - Field: ‘asynchronous’
[13:36:37.786]   - Field: ‘calls’
[13:36:37.786]   - Field: ‘globals’
[13:36:37.787]   - Field: ‘stdout’
[13:36:37.787]   - Field: ‘earlySignal’
[13:36:37.787]   - Field: ‘lazy’
[13:36:37.787]   - Field: ‘state’
[13:36:37.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.787] - Launch lazy future ...
[13:36:37.788] Packages needed by the future expression (n = 0): <none>
[13:36:37.788] Packages needed by future strategies (n = 0): <none>
[13:36:37.789] {
[13:36:37.789]     {
[13:36:37.789]         {
[13:36:37.789]             ...future.startTime <- base::Sys.time()
[13:36:37.789]             {
[13:36:37.789]                 {
[13:36:37.789]                   {
[13:36:37.789]                     {
[13:36:37.789]                       base::local({
[13:36:37.789]                         has_future <- base::requireNamespace("future", 
[13:36:37.789]                           quietly = TRUE)
[13:36:37.789]                         if (has_future) {
[13:36:37.789]                           ns <- base::getNamespace("future")
[13:36:37.789]                           version <- ns[[".package"]][["version"]]
[13:36:37.789]                           if (is.null(version)) 
[13:36:37.789]                             version <- utils::packageVersion("future")
[13:36:37.789]                         }
[13:36:37.789]                         else {
[13:36:37.789]                           version <- NULL
[13:36:37.789]                         }
[13:36:37.789]                         if (!has_future || version < "1.8.0") {
[13:36:37.789]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.789]                             "", base::R.version$version.string), 
[13:36:37.789]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.789]                               "release", "version")], collapse = " "), 
[13:36:37.789]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.789]                             info)
[13:36:37.789]                           info <- base::paste(info, collapse = "; ")
[13:36:37.789]                           if (!has_future) {
[13:36:37.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.789]                               info)
[13:36:37.789]                           }
[13:36:37.789]                           else {
[13:36:37.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.789]                               info, version)
[13:36:37.789]                           }
[13:36:37.789]                           base::stop(msg)
[13:36:37.789]                         }
[13:36:37.789]                       })
[13:36:37.789]                     }
[13:36:37.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.789]                     base::options(mc.cores = 1L)
[13:36:37.789]                   }
[13:36:37.789]                   ...future.strategy.old <- future::plan("list")
[13:36:37.789]                   options(future.plan = NULL)
[13:36:37.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.789]                 }
[13:36:37.789]                 ...future.workdir <- getwd()
[13:36:37.789]             }
[13:36:37.789]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.789]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.789]         }
[13:36:37.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.789]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.789]             base::names(...future.oldOptions))
[13:36:37.789]     }
[13:36:37.789]     if (FALSE) {
[13:36:37.789]     }
[13:36:37.789]     else {
[13:36:37.789]         if (TRUE) {
[13:36:37.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.789]                 open = "w")
[13:36:37.789]         }
[13:36:37.789]         else {
[13:36:37.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.789]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.789]         }
[13:36:37.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.789]             base::sink(type = "output", split = FALSE)
[13:36:37.789]             base::close(...future.stdout)
[13:36:37.789]         }, add = TRUE)
[13:36:37.789]     }
[13:36:37.789]     ...future.frame <- base::sys.nframe()
[13:36:37.789]     ...future.conditions <- base::list()
[13:36:37.789]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.789]     if (FALSE) {
[13:36:37.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.789]     }
[13:36:37.789]     ...future.result <- base::tryCatch({
[13:36:37.789]         base::withCallingHandlers({
[13:36:37.789]             ...future.value <- base::withVisible(base::local({
[13:36:37.789]                 withCallingHandlers({
[13:36:37.789]                   {
[13:36:37.789]                     4
[13:36:37.789]                   }
[13:36:37.789]                 }, immediateCondition = function(cond) {
[13:36:37.789]                   save_rds <- function (object, pathname, ...) 
[13:36:37.789]                   {
[13:36:37.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.789]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.789]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.789]                         fi_tmp[["mtime"]])
[13:36:37.789]                     }
[13:36:37.789]                     tryCatch({
[13:36:37.789]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.789]                     }, error = function(ex) {
[13:36:37.789]                       msg <- conditionMessage(ex)
[13:36:37.789]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.789]                         fi_tmp[["mtime"]], msg)
[13:36:37.789]                       ex$message <- msg
[13:36:37.789]                       stop(ex)
[13:36:37.789]                     })
[13:36:37.789]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.789]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.789]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.789]                       fi <- file.info(pathname)
[13:36:37.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.789]                         fi[["size"]], fi[["mtime"]])
[13:36:37.789]                       stop(msg)
[13:36:37.789]                     }
[13:36:37.789]                     invisible(pathname)
[13:36:37.789]                   }
[13:36:37.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.789]                     rootPath = tempdir()) 
[13:36:37.789]                   {
[13:36:37.789]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.789]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.789]                       tmpdir = path, fileext = ".rds")
[13:36:37.789]                     save_rds(obj, file)
[13:36:37.789]                   }
[13:36:37.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.789]                   {
[13:36:37.789]                     inherits <- base::inherits
[13:36:37.789]                     invokeRestart <- base::invokeRestart
[13:36:37.789]                     is.null <- base::is.null
[13:36:37.789]                     muffled <- FALSE
[13:36:37.789]                     if (inherits(cond, "message")) {
[13:36:37.789]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.789]                       if (muffled) 
[13:36:37.789]                         invokeRestart("muffleMessage")
[13:36:37.789]                     }
[13:36:37.789]                     else if (inherits(cond, "warning")) {
[13:36:37.789]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.789]                       if (muffled) 
[13:36:37.789]                         invokeRestart("muffleWarning")
[13:36:37.789]                     }
[13:36:37.789]                     else if (inherits(cond, "condition")) {
[13:36:37.789]                       if (!is.null(pattern)) {
[13:36:37.789]                         computeRestarts <- base::computeRestarts
[13:36:37.789]                         grepl <- base::grepl
[13:36:37.789]                         restarts <- computeRestarts(cond)
[13:36:37.789]                         for (restart in restarts) {
[13:36:37.789]                           name <- restart$name
[13:36:37.789]                           if (is.null(name)) 
[13:36:37.789]                             next
[13:36:37.789]                           if (!grepl(pattern, name)) 
[13:36:37.789]                             next
[13:36:37.789]                           invokeRestart(restart)
[13:36:37.789]                           muffled <- TRUE
[13:36:37.789]                           break
[13:36:37.789]                         }
[13:36:37.789]                       }
[13:36:37.789]                     }
[13:36:37.789]                     invisible(muffled)
[13:36:37.789]                   }
[13:36:37.789]                   muffleCondition(cond)
[13:36:37.789]                 })
[13:36:37.789]             }))
[13:36:37.789]             future::FutureResult(value = ...future.value$value, 
[13:36:37.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.789]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.789]                     ...future.globalenv.names))
[13:36:37.789]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.789]         }, condition = base::local({
[13:36:37.789]             c <- base::c
[13:36:37.789]             inherits <- base::inherits
[13:36:37.789]             invokeRestart <- base::invokeRestart
[13:36:37.789]             length <- base::length
[13:36:37.789]             list <- base::list
[13:36:37.789]             seq.int <- base::seq.int
[13:36:37.789]             signalCondition <- base::signalCondition
[13:36:37.789]             sys.calls <- base::sys.calls
[13:36:37.789]             `[[` <- base::`[[`
[13:36:37.789]             `+` <- base::`+`
[13:36:37.789]             `<<-` <- base::`<<-`
[13:36:37.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.789]                   3L)]
[13:36:37.789]             }
[13:36:37.789]             function(cond) {
[13:36:37.789]                 is_error <- inherits(cond, "error")
[13:36:37.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.789]                   NULL)
[13:36:37.789]                 if (is_error) {
[13:36:37.789]                   sessionInformation <- function() {
[13:36:37.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.789]                       search = base::search(), system = base::Sys.info())
[13:36:37.789]                   }
[13:36:37.789]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.789]                     cond$call), session = sessionInformation(), 
[13:36:37.789]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.789]                   signalCondition(cond)
[13:36:37.789]                 }
[13:36:37.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.789]                 "immediateCondition"))) {
[13:36:37.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.789]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.789]                   if (TRUE && !signal) {
[13:36:37.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.789]                     {
[13:36:37.789]                       inherits <- base::inherits
[13:36:37.789]                       invokeRestart <- base::invokeRestart
[13:36:37.789]                       is.null <- base::is.null
[13:36:37.789]                       muffled <- FALSE
[13:36:37.789]                       if (inherits(cond, "message")) {
[13:36:37.789]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.789]                         if (muffled) 
[13:36:37.789]                           invokeRestart("muffleMessage")
[13:36:37.789]                       }
[13:36:37.789]                       else if (inherits(cond, "warning")) {
[13:36:37.789]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.789]                         if (muffled) 
[13:36:37.789]                           invokeRestart("muffleWarning")
[13:36:37.789]                       }
[13:36:37.789]                       else if (inherits(cond, "condition")) {
[13:36:37.789]                         if (!is.null(pattern)) {
[13:36:37.789]                           computeRestarts <- base::computeRestarts
[13:36:37.789]                           grepl <- base::grepl
[13:36:37.789]                           restarts <- computeRestarts(cond)
[13:36:37.789]                           for (restart in restarts) {
[13:36:37.789]                             name <- restart$name
[13:36:37.789]                             if (is.null(name)) 
[13:36:37.789]                               next
[13:36:37.789]                             if (!grepl(pattern, name)) 
[13:36:37.789]                               next
[13:36:37.789]                             invokeRestart(restart)
[13:36:37.789]                             muffled <- TRUE
[13:36:37.789]                             break
[13:36:37.789]                           }
[13:36:37.789]                         }
[13:36:37.789]                       }
[13:36:37.789]                       invisible(muffled)
[13:36:37.789]                     }
[13:36:37.789]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.789]                   }
[13:36:37.789]                 }
[13:36:37.789]                 else {
[13:36:37.789]                   if (TRUE) {
[13:36:37.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.789]                     {
[13:36:37.789]                       inherits <- base::inherits
[13:36:37.789]                       invokeRestart <- base::invokeRestart
[13:36:37.789]                       is.null <- base::is.null
[13:36:37.789]                       muffled <- FALSE
[13:36:37.789]                       if (inherits(cond, "message")) {
[13:36:37.789]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.789]                         if (muffled) 
[13:36:37.789]                           invokeRestart("muffleMessage")
[13:36:37.789]                       }
[13:36:37.789]                       else if (inherits(cond, "warning")) {
[13:36:37.789]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.789]                         if (muffled) 
[13:36:37.789]                           invokeRestart("muffleWarning")
[13:36:37.789]                       }
[13:36:37.789]                       else if (inherits(cond, "condition")) {
[13:36:37.789]                         if (!is.null(pattern)) {
[13:36:37.789]                           computeRestarts <- base::computeRestarts
[13:36:37.789]                           grepl <- base::grepl
[13:36:37.789]                           restarts <- computeRestarts(cond)
[13:36:37.789]                           for (restart in restarts) {
[13:36:37.789]                             name <- restart$name
[13:36:37.789]                             if (is.null(name)) 
[13:36:37.789]                               next
[13:36:37.789]                             if (!grepl(pattern, name)) 
[13:36:37.789]                               next
[13:36:37.789]                             invokeRestart(restart)
[13:36:37.789]                             muffled <- TRUE
[13:36:37.789]                             break
[13:36:37.789]                           }
[13:36:37.789]                         }
[13:36:37.789]                       }
[13:36:37.789]                       invisible(muffled)
[13:36:37.789]                     }
[13:36:37.789]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.789]                   }
[13:36:37.789]                 }
[13:36:37.789]             }
[13:36:37.789]         }))
[13:36:37.789]     }, error = function(ex) {
[13:36:37.789]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.789]                 ...future.rng), started = ...future.startTime, 
[13:36:37.789]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.789]             version = "1.8"), class = "FutureResult")
[13:36:37.789]     }, finally = {
[13:36:37.789]         if (!identical(...future.workdir, getwd())) 
[13:36:37.789]             setwd(...future.workdir)
[13:36:37.789]         {
[13:36:37.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.789]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.789]             }
[13:36:37.789]             base::options(...future.oldOptions)
[13:36:37.789]             if (.Platform$OS.type == "windows") {
[13:36:37.789]                 old_names <- names(...future.oldEnvVars)
[13:36:37.789]                 envs <- base::Sys.getenv()
[13:36:37.789]                 names <- names(envs)
[13:36:37.789]                 common <- intersect(names, old_names)
[13:36:37.789]                 added <- setdiff(names, old_names)
[13:36:37.789]                 removed <- setdiff(old_names, names)
[13:36:37.789]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.789]                   envs[common]]
[13:36:37.789]                 NAMES <- toupper(changed)
[13:36:37.789]                 args <- list()
[13:36:37.789]                 for (kk in seq_along(NAMES)) {
[13:36:37.789]                   name <- changed[[kk]]
[13:36:37.789]                   NAME <- NAMES[[kk]]
[13:36:37.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.789]                     next
[13:36:37.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.789]                 }
[13:36:37.789]                 NAMES <- toupper(added)
[13:36:37.789]                 for (kk in seq_along(NAMES)) {
[13:36:37.789]                   name <- added[[kk]]
[13:36:37.789]                   NAME <- NAMES[[kk]]
[13:36:37.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.789]                     next
[13:36:37.789]                   args[[name]] <- ""
[13:36:37.789]                 }
[13:36:37.789]                 NAMES <- toupper(removed)
[13:36:37.789]                 for (kk in seq_along(NAMES)) {
[13:36:37.789]                   name <- removed[[kk]]
[13:36:37.789]                   NAME <- NAMES[[kk]]
[13:36:37.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.789]                     next
[13:36:37.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.789]                 }
[13:36:37.789]                 if (length(args) > 0) 
[13:36:37.789]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.789]             }
[13:36:37.789]             else {
[13:36:37.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.789]             }
[13:36:37.789]             {
[13:36:37.789]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.789]                   0L) {
[13:36:37.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.789]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.789]                   base::options(opts)
[13:36:37.789]                 }
[13:36:37.789]                 {
[13:36:37.789]                   {
[13:36:37.789]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.789]                     NULL
[13:36:37.789]                   }
[13:36:37.789]                   options(future.plan = NULL)
[13:36:37.789]                   if (is.na(NA_character_)) 
[13:36:37.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.789]                     .init = FALSE)
[13:36:37.789]                 }
[13:36:37.789]             }
[13:36:37.789]         }
[13:36:37.789]     })
[13:36:37.789]     if (TRUE) {
[13:36:37.789]         base::sink(type = "output", split = FALSE)
[13:36:37.789]         if (TRUE) {
[13:36:37.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.789]         }
[13:36:37.789]         else {
[13:36:37.789]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.789]         }
[13:36:37.789]         base::close(...future.stdout)
[13:36:37.789]         ...future.stdout <- NULL
[13:36:37.789]     }
[13:36:37.789]     ...future.result$conditions <- ...future.conditions
[13:36:37.789]     ...future.result$finished <- base::Sys.time()
[13:36:37.789]     ...future.result
[13:36:37.789] }
[13:36:37.792] requestCore(): workers = 2
[13:36:37.793] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:37.803] result() for MulticoreFuture ...
[13:36:37.804] result() for MulticoreFuture ...
[13:36:37.804] result() for MulticoreFuture ... done
[13:36:37.805] result() for MulticoreFuture ... done
[13:36:37.805] result() for MulticoreFuture ...
[13:36:37.805] result() for MulticoreFuture ... done
[13:36:37.808] MulticoreFuture started
[13:36:37.808] - Launch lazy future ... done
[13:36:37.808] run() for ‘MulticoreFuture’ ... done
[13:36:37.809] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x564a74dd62c8> 
[13:36:37.809] List of future strategies:
[13:36:37.809] 1. sequential:
[13:36:37.809]    - args: function (..., envir = parent.frame())
[13:36:37.809]    - tweaked: FALSE
[13:36:37.809]    - call: NULL
[13:36:37.811] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x564a72f7bf20> 
 - attr(*, "dim.")=[13:36:37.813] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=[13:36:37.814] List of future strategies:
[13:36:37.814] 1. multicore:
[13:36:37.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.814]    - tweaked: FALSE
[13:36:37.814]    - call: plan(strategy)
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:37.820] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:37.824] resolve() on list environment ...
[13:36:37.825]  recursive: 0
[13:36:37.826]  length: 6
[13:36:37.827]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:37.827] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.827] - nx: 6
[13:36:37.827] - relay: TRUE
[13:36:37.827] - stdout: TRUE
[13:36:37.827] - signal: TRUE
[13:36:37.828] - resignal: FALSE
[13:36:37.828] - force: TRUE
[13:36:37.828] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.828] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.828]  - until=2
[13:36:37.829]  - relaying element #2
[13:36:37.829] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.829] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.829] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.829]  length: 5 (resolved future 1)
[13:36:37.829] Future #2
[13:36:37.830] result() for MulticoreFuture ...
[13:36:37.830] result() for MulticoreFuture ... done
[13:36:37.830] result() for MulticoreFuture ...
[13:36:37.830] result() for MulticoreFuture ... done
[13:36:37.830] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:37.831] - nx: 6
[13:36:37.831] - relay: TRUE
[13:36:37.831] - stdout: TRUE
[13:36:37.831] - signal: TRUE
[13:36:37.831] - resignal: FALSE
[13:36:37.831] - force: TRUE
[13:36:37.832] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.832] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.832]  - until=2
[13:36:37.832]  - relaying element #2
[13:36:37.832] result() for MulticoreFuture ...
[13:36:37.832] result() for MulticoreFuture ... done
[13:36:37.833] result() for MulticoreFuture ...
[13:36:37.833] result() for MulticoreFuture ... done
[13:36:37.833] result() for MulticoreFuture ...
[13:36:37.833] result() for MulticoreFuture ... done
[13:36:37.833] result() for MulticoreFuture ...
[13:36:37.833] result() for MulticoreFuture ... done
[13:36:37.834] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.834] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.834] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:37.834]  length: 4 (resolved future 2)
[13:36:37.834] Future #3
[13:36:37.835] result() for MulticoreFuture ...
[13:36:37.835] result() for MulticoreFuture ...
[13:36:37.836] result() for MulticoreFuture ... done
[13:36:37.836] result() for MulticoreFuture ... done
[13:36:37.836] result() for MulticoreFuture ...
[13:36:37.836] result() for MulticoreFuture ... done
[13:36:37.836] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:37.836] - nx: 6
[13:36:37.836] - relay: TRUE
[13:36:37.837] - stdout: TRUE
[13:36:37.837] - signal: TRUE
[13:36:37.837] - resignal: FALSE
[13:36:37.837] - force: TRUE
[13:36:37.837] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.837] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.837]  - until=3
[13:36:37.837]  - relaying element #3
[13:36:37.838] result() for MulticoreFuture ...
[13:36:37.838] result() for MulticoreFuture ... done
[13:36:37.838] result() for MulticoreFuture ...
[13:36:37.838] result() for MulticoreFuture ... done
[13:36:37.838] result() for MulticoreFuture ...
[13:36:37.838] result() for MulticoreFuture ... done
[13:36:37.839] result() for MulticoreFuture ...
[13:36:37.839] result() for MulticoreFuture ... done
[13:36:37.839] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.839] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.839] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:37.839]  length: 3 (resolved future 3)
[13:36:37.840] Future #4
[13:36:37.840] result() for MulticoreFuture ...
[13:36:37.841] result() for MulticoreFuture ...
[13:36:37.841] result() for MulticoreFuture ... done
[13:36:37.841] result() for MulticoreFuture ... done
[13:36:37.841] result() for MulticoreFuture ...
[13:36:37.841] result() for MulticoreFuture ... done
[13:36:37.842] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:37.842] - nx: 6
[13:36:37.842] - relay: TRUE
[13:36:37.842] - stdout: TRUE
[13:36:37.842] - signal: TRUE
[13:36:37.842] - resignal: FALSE
[13:36:37.843] - force: TRUE
[13:36:37.843] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.843] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.843]  - until=4
[13:36:37.843]  - relaying element #4
[13:36:37.843] result() for MulticoreFuture ...
[13:36:37.844] result() for MulticoreFuture ... done
[13:36:37.844] result() for MulticoreFuture ...
[13:36:37.844] result() for MulticoreFuture ... done
[13:36:37.844] result() for MulticoreFuture ...
[13:36:37.844] result() for MulticoreFuture ... done
[13:36:37.844] result() for MulticoreFuture ...
[13:36:37.845] result() for MulticoreFuture ... done
[13:36:37.845] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.845] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.845] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:37.845]  length: 2 (resolved future 4)
[13:36:37.845] signalConditionsASAP(NULL, pos=5) ...
[13:36:37.845] - nx: 6
[13:36:37.845] - relay: TRUE
[13:36:37.845] - stdout: TRUE
[13:36:37.846] - signal: TRUE
[13:36:37.846] - resignal: FALSE
[13:36:37.846] - force: TRUE
[13:36:37.846] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.846] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.846]  - until=6
[13:36:37.846]  - relaying element #6
[13:36:37.846] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.846] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.847] signalConditionsASAP(NULL, pos=5) ... done
[13:36:37.847]  length: 1 (resolved future 5)
[13:36:37.847] signalConditionsASAP(numeric, pos=6) ...
[13:36:37.847] - nx: 6
[13:36:37.847] - relay: TRUE
[13:36:37.847] - stdout: TRUE
[13:36:37.847] - signal: TRUE
[13:36:37.847] - resignal: FALSE
[13:36:37.847] - force: TRUE
[13:36:37.848] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.848] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.848]  - until=6
[13:36:37.848] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.848] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.848] signalConditionsASAP(numeric, pos=6) ... done
[13:36:37.848]  length: 0 (resolved future 6)
[13:36:37.848] Relaying remaining futures
[13:36:37.848] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.848] - nx: 6
[13:36:37.849] - relay: TRUE
[13:36:37.849] - stdout: TRUE
[13:36:37.849] - signal: TRUE
[13:36:37.849] - resignal: FALSE
[13:36:37.849] - force: TRUE
[13:36:37.849] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.849] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:37.849] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.849] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.850] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.850] resolve() on list environment ... DONE
[13:36:37.850] result() for MulticoreFuture ...
[13:36:37.850] result() for MulticoreFuture ... done
[13:36:37.850] result() for MulticoreFuture ...
[13:36:37.850] result() for MulticoreFuture ... done
[13:36:37.850] result() for MulticoreFuture ...
[13:36:37.850] result() for MulticoreFuture ... done
[13:36:37.851] result() for MulticoreFuture ...
[13:36:37.851] result() for MulticoreFuture ... done
[13:36:37.851] result() for MulticoreFuture ...
[13:36:37.851] result() for MulticoreFuture ... done
[13:36:37.851] result() for MulticoreFuture ...
[13:36:37.851] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a711fe818> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:36:37.853] getGlobalsAndPackages() ...
[13:36:37.854] Searching for globals...
[13:36:37.854] 
[13:36:37.854] Searching for globals ... DONE
[13:36:37.854] - globals: [0] <none>
[13:36:37.854] getGlobalsAndPackages() ... DONE
[13:36:37.855] run() for ‘Future’ ...
[13:36:37.855] - state: ‘created’
[13:36:37.855] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.859]   - Field: ‘label’
[13:36:37.859]   - Field: ‘local’
[13:36:37.859]   - Field: ‘owner’
[13:36:37.860]   - Field: ‘envir’
[13:36:37.860]   - Field: ‘workers’
[13:36:37.860]   - Field: ‘packages’
[13:36:37.860]   - Field: ‘gc’
[13:36:37.860]   - Field: ‘job’
[13:36:37.860]   - Field: ‘conditions’
[13:36:37.860]   - Field: ‘expr’
[13:36:37.860]   - Field: ‘uuid’
[13:36:37.860]   - Field: ‘seed’
[13:36:37.861]   - Field: ‘version’
[13:36:37.861]   - Field: ‘result’
[13:36:37.861]   - Field: ‘asynchronous’
[13:36:37.861]   - Field: ‘calls’
[13:36:37.861]   - Field: ‘globals’
[13:36:37.861]   - Field: ‘stdout’
[13:36:37.861]   - Field: ‘earlySignal’
[13:36:37.861]   - Field: ‘lazy’
[13:36:37.861]   - Field: ‘state’
[13:36:37.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.862] - Launch lazy future ...
[13:36:37.862] Packages needed by the future expression (n = 0): <none>
[13:36:37.862] Packages needed by future strategies (n = 0): <none>
[13:36:37.863] {
[13:36:37.863]     {
[13:36:37.863]         {
[13:36:37.863]             ...future.startTime <- base::Sys.time()
[13:36:37.863]             {
[13:36:37.863]                 {
[13:36:37.863]                   {
[13:36:37.863]                     {
[13:36:37.863]                       base::local({
[13:36:37.863]                         has_future <- base::requireNamespace("future", 
[13:36:37.863]                           quietly = TRUE)
[13:36:37.863]                         if (has_future) {
[13:36:37.863]                           ns <- base::getNamespace("future")
[13:36:37.863]                           version <- ns[[".package"]][["version"]]
[13:36:37.863]                           if (is.null(version)) 
[13:36:37.863]                             version <- utils::packageVersion("future")
[13:36:37.863]                         }
[13:36:37.863]                         else {
[13:36:37.863]                           version <- NULL
[13:36:37.863]                         }
[13:36:37.863]                         if (!has_future || version < "1.8.0") {
[13:36:37.863]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.863]                             "", base::R.version$version.string), 
[13:36:37.863]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.863]                               "release", "version")], collapse = " "), 
[13:36:37.863]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.863]                             info)
[13:36:37.863]                           info <- base::paste(info, collapse = "; ")
[13:36:37.863]                           if (!has_future) {
[13:36:37.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.863]                               info)
[13:36:37.863]                           }
[13:36:37.863]                           else {
[13:36:37.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.863]                               info, version)
[13:36:37.863]                           }
[13:36:37.863]                           base::stop(msg)
[13:36:37.863]                         }
[13:36:37.863]                       })
[13:36:37.863]                     }
[13:36:37.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.863]                     base::options(mc.cores = 1L)
[13:36:37.863]                   }
[13:36:37.863]                   ...future.strategy.old <- future::plan("list")
[13:36:37.863]                   options(future.plan = NULL)
[13:36:37.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.863]                 }
[13:36:37.863]                 ...future.workdir <- getwd()
[13:36:37.863]             }
[13:36:37.863]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.863]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.863]         }
[13:36:37.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.863]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.863]             base::names(...future.oldOptions))
[13:36:37.863]     }
[13:36:37.863]     if (FALSE) {
[13:36:37.863]     }
[13:36:37.863]     else {
[13:36:37.863]         if (TRUE) {
[13:36:37.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.863]                 open = "w")
[13:36:37.863]         }
[13:36:37.863]         else {
[13:36:37.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.863]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.863]         }
[13:36:37.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.863]             base::sink(type = "output", split = FALSE)
[13:36:37.863]             base::close(...future.stdout)
[13:36:37.863]         }, add = TRUE)
[13:36:37.863]     }
[13:36:37.863]     ...future.frame <- base::sys.nframe()
[13:36:37.863]     ...future.conditions <- base::list()
[13:36:37.863]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.863]     if (FALSE) {
[13:36:37.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.863]     }
[13:36:37.863]     ...future.result <- base::tryCatch({
[13:36:37.863]         base::withCallingHandlers({
[13:36:37.863]             ...future.value <- base::withVisible(base::local({
[13:36:37.863]                 withCallingHandlers({
[13:36:37.863]                   2
[13:36:37.863]                 }, immediateCondition = function(cond) {
[13:36:37.863]                   save_rds <- function (object, pathname, ...) 
[13:36:37.863]                   {
[13:36:37.863]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.863]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.863]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.863]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.863]                         fi_tmp[["mtime"]])
[13:36:37.863]                     }
[13:36:37.863]                     tryCatch({
[13:36:37.863]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.863]                     }, error = function(ex) {
[13:36:37.863]                       msg <- conditionMessage(ex)
[13:36:37.863]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.863]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.863]                         fi_tmp[["mtime"]], msg)
[13:36:37.863]                       ex$message <- msg
[13:36:37.863]                       stop(ex)
[13:36:37.863]                     })
[13:36:37.863]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.863]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.863]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.863]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.863]                       fi <- file.info(pathname)
[13:36:37.863]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.863]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.863]                         fi[["size"]], fi[["mtime"]])
[13:36:37.863]                       stop(msg)
[13:36:37.863]                     }
[13:36:37.863]                     invisible(pathname)
[13:36:37.863]                   }
[13:36:37.863]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.863]                     rootPath = tempdir()) 
[13:36:37.863]                   {
[13:36:37.863]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.863]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.863]                       tmpdir = path, fileext = ".rds")
[13:36:37.863]                     save_rds(obj, file)
[13:36:37.863]                   }
[13:36:37.863]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.863]                   {
[13:36:37.863]                     inherits <- base::inherits
[13:36:37.863]                     invokeRestart <- base::invokeRestart
[13:36:37.863]                     is.null <- base::is.null
[13:36:37.863]                     muffled <- FALSE
[13:36:37.863]                     if (inherits(cond, "message")) {
[13:36:37.863]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.863]                       if (muffled) 
[13:36:37.863]                         invokeRestart("muffleMessage")
[13:36:37.863]                     }
[13:36:37.863]                     else if (inherits(cond, "warning")) {
[13:36:37.863]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.863]                       if (muffled) 
[13:36:37.863]                         invokeRestart("muffleWarning")
[13:36:37.863]                     }
[13:36:37.863]                     else if (inherits(cond, "condition")) {
[13:36:37.863]                       if (!is.null(pattern)) {
[13:36:37.863]                         computeRestarts <- base::computeRestarts
[13:36:37.863]                         grepl <- base::grepl
[13:36:37.863]                         restarts <- computeRestarts(cond)
[13:36:37.863]                         for (restart in restarts) {
[13:36:37.863]                           name <- restart$name
[13:36:37.863]                           if (is.null(name)) 
[13:36:37.863]                             next
[13:36:37.863]                           if (!grepl(pattern, name)) 
[13:36:37.863]                             next
[13:36:37.863]                           invokeRestart(restart)
[13:36:37.863]                           muffled <- TRUE
[13:36:37.863]                           break
[13:36:37.863]                         }
[13:36:37.863]                       }
[13:36:37.863]                     }
[13:36:37.863]                     invisible(muffled)
[13:36:37.863]                   }
[13:36:37.863]                   muffleCondition(cond)
[13:36:37.863]                 })
[13:36:37.863]             }))
[13:36:37.863]             future::FutureResult(value = ...future.value$value, 
[13:36:37.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.863]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.863]                     ...future.globalenv.names))
[13:36:37.863]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.863]         }, condition = base::local({
[13:36:37.863]             c <- base::c
[13:36:37.863]             inherits <- base::inherits
[13:36:37.863]             invokeRestart <- base::invokeRestart
[13:36:37.863]             length <- base::length
[13:36:37.863]             list <- base::list
[13:36:37.863]             seq.int <- base::seq.int
[13:36:37.863]             signalCondition <- base::signalCondition
[13:36:37.863]             sys.calls <- base::sys.calls
[13:36:37.863]             `[[` <- base::`[[`
[13:36:37.863]             `+` <- base::`+`
[13:36:37.863]             `<<-` <- base::`<<-`
[13:36:37.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.863]                   3L)]
[13:36:37.863]             }
[13:36:37.863]             function(cond) {
[13:36:37.863]                 is_error <- inherits(cond, "error")
[13:36:37.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.863]                   NULL)
[13:36:37.863]                 if (is_error) {
[13:36:37.863]                   sessionInformation <- function() {
[13:36:37.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.863]                       search = base::search(), system = base::Sys.info())
[13:36:37.863]                   }
[13:36:37.863]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.863]                     cond$call), session = sessionInformation(), 
[13:36:37.863]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.863]                   signalCondition(cond)
[13:36:37.863]                 }
[13:36:37.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.863]                 "immediateCondition"))) {
[13:36:37.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.863]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.863]                   if (TRUE && !signal) {
[13:36:37.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.863]                     {
[13:36:37.863]                       inherits <- base::inherits
[13:36:37.863]                       invokeRestart <- base::invokeRestart
[13:36:37.863]                       is.null <- base::is.null
[13:36:37.863]                       muffled <- FALSE
[13:36:37.863]                       if (inherits(cond, "message")) {
[13:36:37.863]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.863]                         if (muffled) 
[13:36:37.863]                           invokeRestart("muffleMessage")
[13:36:37.863]                       }
[13:36:37.863]                       else if (inherits(cond, "warning")) {
[13:36:37.863]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.863]                         if (muffled) 
[13:36:37.863]                           invokeRestart("muffleWarning")
[13:36:37.863]                       }
[13:36:37.863]                       else if (inherits(cond, "condition")) {
[13:36:37.863]                         if (!is.null(pattern)) {
[13:36:37.863]                           computeRestarts <- base::computeRestarts
[13:36:37.863]                           grepl <- base::grepl
[13:36:37.863]                           restarts <- computeRestarts(cond)
[13:36:37.863]                           for (restart in restarts) {
[13:36:37.863]                             name <- restart$name
[13:36:37.863]                             if (is.null(name)) 
[13:36:37.863]                               next
[13:36:37.863]                             if (!grepl(pattern, name)) 
[13:36:37.863]                               next
[13:36:37.863]                             invokeRestart(restart)
[13:36:37.863]                             muffled <- TRUE
[13:36:37.863]                             break
[13:36:37.863]                           }
[13:36:37.863]                         }
[13:36:37.863]                       }
[13:36:37.863]                       invisible(muffled)
[13:36:37.863]                     }
[13:36:37.863]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.863]                   }
[13:36:37.863]                 }
[13:36:37.863]                 else {
[13:36:37.863]                   if (TRUE) {
[13:36:37.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.863]                     {
[13:36:37.863]                       inherits <- base::inherits
[13:36:37.863]                       invokeRestart <- base::invokeRestart
[13:36:37.863]                       is.null <- base::is.null
[13:36:37.863]                       muffled <- FALSE
[13:36:37.863]                       if (inherits(cond, "message")) {
[13:36:37.863]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.863]                         if (muffled) 
[13:36:37.863]                           invokeRestart("muffleMessage")
[13:36:37.863]                       }
[13:36:37.863]                       else if (inherits(cond, "warning")) {
[13:36:37.863]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.863]                         if (muffled) 
[13:36:37.863]                           invokeRestart("muffleWarning")
[13:36:37.863]                       }
[13:36:37.863]                       else if (inherits(cond, "condition")) {
[13:36:37.863]                         if (!is.null(pattern)) {
[13:36:37.863]                           computeRestarts <- base::computeRestarts
[13:36:37.863]                           grepl <- base::grepl
[13:36:37.863]                           restarts <- computeRestarts(cond)
[13:36:37.863]                           for (restart in restarts) {
[13:36:37.863]                             name <- restart$name
[13:36:37.863]                             if (is.null(name)) 
[13:36:37.863]                               next
[13:36:37.863]                             if (!grepl(pattern, name)) 
[13:36:37.863]                               next
[13:36:37.863]                             invokeRestart(restart)
[13:36:37.863]                             muffled <- TRUE
[13:36:37.863]                             break
[13:36:37.863]                           }
[13:36:37.863]                         }
[13:36:37.863]                       }
[13:36:37.863]                       invisible(muffled)
[13:36:37.863]                     }
[13:36:37.863]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.863]                   }
[13:36:37.863]                 }
[13:36:37.863]             }
[13:36:37.863]         }))
[13:36:37.863]     }, error = function(ex) {
[13:36:37.863]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.863]                 ...future.rng), started = ...future.startTime, 
[13:36:37.863]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.863]             version = "1.8"), class = "FutureResult")
[13:36:37.863]     }, finally = {
[13:36:37.863]         if (!identical(...future.workdir, getwd())) 
[13:36:37.863]             setwd(...future.workdir)
[13:36:37.863]         {
[13:36:37.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.863]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.863]             }
[13:36:37.863]             base::options(...future.oldOptions)
[13:36:37.863]             if (.Platform$OS.type == "windows") {
[13:36:37.863]                 old_names <- names(...future.oldEnvVars)
[13:36:37.863]                 envs <- base::Sys.getenv()
[13:36:37.863]                 names <- names(envs)
[13:36:37.863]                 common <- intersect(names, old_names)
[13:36:37.863]                 added <- setdiff(names, old_names)
[13:36:37.863]                 removed <- setdiff(old_names, names)
[13:36:37.863]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.863]                   envs[common]]
[13:36:37.863]                 NAMES <- toupper(changed)
[13:36:37.863]                 args <- list()
[13:36:37.863]                 for (kk in seq_along(NAMES)) {
[13:36:37.863]                   name <- changed[[kk]]
[13:36:37.863]                   NAME <- NAMES[[kk]]
[13:36:37.863]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.863]                     next
[13:36:37.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.863]                 }
[13:36:37.863]                 NAMES <- toupper(added)
[13:36:37.863]                 for (kk in seq_along(NAMES)) {
[13:36:37.863]                   name <- added[[kk]]
[13:36:37.863]                   NAME <- NAMES[[kk]]
[13:36:37.863]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.863]                     next
[13:36:37.863]                   args[[name]] <- ""
[13:36:37.863]                 }
[13:36:37.863]                 NAMES <- toupper(removed)
[13:36:37.863]                 for (kk in seq_along(NAMES)) {
[13:36:37.863]                   name <- removed[[kk]]
[13:36:37.863]                   NAME <- NAMES[[kk]]
[13:36:37.863]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.863]                     next
[13:36:37.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.863]                 }
[13:36:37.863]                 if (length(args) > 0) 
[13:36:37.863]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.863]             }
[13:36:37.863]             else {
[13:36:37.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.863]             }
[13:36:37.863]             {
[13:36:37.863]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.863]                   0L) {
[13:36:37.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.863]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.863]                   base::options(opts)
[13:36:37.863]                 }
[13:36:37.863]                 {
[13:36:37.863]                   {
[13:36:37.863]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.863]                     NULL
[13:36:37.863]                   }
[13:36:37.863]                   options(future.plan = NULL)
[13:36:37.863]                   if (is.na(NA_character_)) 
[13:36:37.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.863]                     .init = FALSE)
[13:36:37.863]                 }
[13:36:37.863]             }
[13:36:37.863]         }
[13:36:37.863]     })
[13:36:37.863]     if (TRUE) {
[13:36:37.863]         base::sink(type = "output", split = FALSE)
[13:36:37.863]         if (TRUE) {
[13:36:37.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.863]         }
[13:36:37.863]         else {
[13:36:37.863]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.863]         }
[13:36:37.863]         base::close(...future.stdout)
[13:36:37.863]         ...future.stdout <- NULL
[13:36:37.863]     }
[13:36:37.863]     ...future.result$conditions <- ...future.conditions
[13:36:37.863]     ...future.result$finished <- base::Sys.time()
[13:36:37.863]     ...future.result
[13:36:37.863] }
[13:36:37.865] requestCore(): workers = 2
[13:36:37.867] MulticoreFuture started
[13:36:37.868] - Launch lazy future ... done
[13:36:37.868] run() for ‘MulticoreFuture’ ... done
[13:36:37.868] getGlobalsAndPackages() ...
[13:36:37.868] Searching for globals...
[13:36:37.868] plan(): Setting new future strategy stack:
[13:36:37.869] 
[13:36:37.869] List of future strategies:
[13:36:37.869] 1. sequential:
[13:36:37.869]    - args: function (..., envir = parent.frame())
[13:36:37.869]    - tweaked: FALSE
[13:36:37.869]    - call: NULL
[13:36:37.869] Searching for globals ... DONE
[13:36:37.870] plan(): nbrOfWorkers() = 1
[13:36:37.870] - globals: [0] <none>
[13:36:37.870] getGlobalsAndPackages() ... DONE
[13:36:37.870] run() for ‘Future’ ...
[13:36:37.870] - state: ‘created’
[13:36:37.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.871] plan(): Setting new future strategy stack:
[13:36:37.872] List of future strategies:
[13:36:37.872] 1. multicore:
[13:36:37.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.872]    - tweaked: FALSE
[13:36:37.872]    - call: plan(strategy)
[13:36:37.876] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.876] plan(): nbrOfWorkers() = 2
[13:36:37.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.876]   - Field: ‘label’
[13:36:37.876]   - Field: ‘local’
[13:36:37.876]   - Field: ‘owner’
[13:36:37.877]   - Field: ‘envir’
[13:36:37.877]   - Field: ‘workers’
[13:36:37.877]   - Field: ‘packages’
[13:36:37.877]   - Field: ‘gc’
[13:36:37.877]   - Field: ‘job’
[13:36:37.877]   - Field: ‘conditions’
[13:36:37.877]   - Field: ‘expr’
[13:36:37.878]   - Field: ‘uuid’
[13:36:37.878]   - Field: ‘seed’
[13:36:37.878]   - Field: ‘version’
[13:36:37.878]   - Field: ‘result’
[13:36:37.878]   - Field: ‘asynchronous’
[13:36:37.878]   - Field: ‘calls’
[13:36:37.878]   - Field: ‘globals’
[13:36:37.878]   - Field: ‘stdout’
[13:36:37.879]   - Field: ‘earlySignal’
[13:36:37.879]   - Field: ‘lazy’
[13:36:37.879]   - Field: ‘state’
[13:36:37.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.879] - Launch lazy future ...
[13:36:37.880] Packages needed by the future expression (n = 0): <none>
[13:36:37.880] Packages needed by future strategies (n = 0): <none>
[13:36:37.881] {
[13:36:37.881]     {
[13:36:37.881]         {
[13:36:37.881]             ...future.startTime <- base::Sys.time()
[13:36:37.881]             {
[13:36:37.881]                 {
[13:36:37.881]                   {
[13:36:37.881]                     {
[13:36:37.881]                       base::local({
[13:36:37.881]                         has_future <- base::requireNamespace("future", 
[13:36:37.881]                           quietly = TRUE)
[13:36:37.881]                         if (has_future) {
[13:36:37.881]                           ns <- base::getNamespace("future")
[13:36:37.881]                           version <- ns[[".package"]][["version"]]
[13:36:37.881]                           if (is.null(version)) 
[13:36:37.881]                             version <- utils::packageVersion("future")
[13:36:37.881]                         }
[13:36:37.881]                         else {
[13:36:37.881]                           version <- NULL
[13:36:37.881]                         }
[13:36:37.881]                         if (!has_future || version < "1.8.0") {
[13:36:37.881]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.881]                             "", base::R.version$version.string), 
[13:36:37.881]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.881]                               "release", "version")], collapse = " "), 
[13:36:37.881]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.881]                             info)
[13:36:37.881]                           info <- base::paste(info, collapse = "; ")
[13:36:37.881]                           if (!has_future) {
[13:36:37.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.881]                               info)
[13:36:37.881]                           }
[13:36:37.881]                           else {
[13:36:37.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.881]                               info, version)
[13:36:37.881]                           }
[13:36:37.881]                           base::stop(msg)
[13:36:37.881]                         }
[13:36:37.881]                       })
[13:36:37.881]                     }
[13:36:37.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.881]                     base::options(mc.cores = 1L)
[13:36:37.881]                   }
[13:36:37.881]                   ...future.strategy.old <- future::plan("list")
[13:36:37.881]                   options(future.plan = NULL)
[13:36:37.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.881]                 }
[13:36:37.881]                 ...future.workdir <- getwd()
[13:36:37.881]             }
[13:36:37.881]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.881]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.881]         }
[13:36:37.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.881]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.881]             base::names(...future.oldOptions))
[13:36:37.881]     }
[13:36:37.881]     if (FALSE) {
[13:36:37.881]     }
[13:36:37.881]     else {
[13:36:37.881]         if (TRUE) {
[13:36:37.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.881]                 open = "w")
[13:36:37.881]         }
[13:36:37.881]         else {
[13:36:37.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.881]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.881]         }
[13:36:37.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.881]             base::sink(type = "output", split = FALSE)
[13:36:37.881]             base::close(...future.stdout)
[13:36:37.881]         }, add = TRUE)
[13:36:37.881]     }
[13:36:37.881]     ...future.frame <- base::sys.nframe()
[13:36:37.881]     ...future.conditions <- base::list()
[13:36:37.881]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.881]     if (FALSE) {
[13:36:37.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.881]     }
[13:36:37.881]     ...future.result <- base::tryCatch({
[13:36:37.881]         base::withCallingHandlers({
[13:36:37.881]             ...future.value <- base::withVisible(base::local({
[13:36:37.881]                 withCallingHandlers({
[13:36:37.881]                   NULL
[13:36:37.881]                 }, immediateCondition = function(cond) {
[13:36:37.881]                   save_rds <- function (object, pathname, ...) 
[13:36:37.881]                   {
[13:36:37.881]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.881]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.881]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.881]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.881]                         fi_tmp[["mtime"]])
[13:36:37.881]                     }
[13:36:37.881]                     tryCatch({
[13:36:37.881]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.881]                     }, error = function(ex) {
[13:36:37.881]                       msg <- conditionMessage(ex)
[13:36:37.881]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.881]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.881]                         fi_tmp[["mtime"]], msg)
[13:36:37.881]                       ex$message <- msg
[13:36:37.881]                       stop(ex)
[13:36:37.881]                     })
[13:36:37.881]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.881]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.881]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.881]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.881]                       fi <- file.info(pathname)
[13:36:37.881]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.881]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.881]                         fi[["size"]], fi[["mtime"]])
[13:36:37.881]                       stop(msg)
[13:36:37.881]                     }
[13:36:37.881]                     invisible(pathname)
[13:36:37.881]                   }
[13:36:37.881]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.881]                     rootPath = tempdir()) 
[13:36:37.881]                   {
[13:36:37.881]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.881]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.881]                       tmpdir = path, fileext = ".rds")
[13:36:37.881]                     save_rds(obj, file)
[13:36:37.881]                   }
[13:36:37.881]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.881]                   {
[13:36:37.881]                     inherits <- base::inherits
[13:36:37.881]                     invokeRestart <- base::invokeRestart
[13:36:37.881]                     is.null <- base::is.null
[13:36:37.881]                     muffled <- FALSE
[13:36:37.881]                     if (inherits(cond, "message")) {
[13:36:37.881]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.881]                       if (muffled) 
[13:36:37.881]                         invokeRestart("muffleMessage")
[13:36:37.881]                     }
[13:36:37.881]                     else if (inherits(cond, "warning")) {
[13:36:37.881]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.881]                       if (muffled) 
[13:36:37.881]                         invokeRestart("muffleWarning")
[13:36:37.881]                     }
[13:36:37.881]                     else if (inherits(cond, "condition")) {
[13:36:37.881]                       if (!is.null(pattern)) {
[13:36:37.881]                         computeRestarts <- base::computeRestarts
[13:36:37.881]                         grepl <- base::grepl
[13:36:37.881]                         restarts <- computeRestarts(cond)
[13:36:37.881]                         for (restart in restarts) {
[13:36:37.881]                           name <- restart$name
[13:36:37.881]                           if (is.null(name)) 
[13:36:37.881]                             next
[13:36:37.881]                           if (!grepl(pattern, name)) 
[13:36:37.881]                             next
[13:36:37.881]                           invokeRestart(restart)
[13:36:37.881]                           muffled <- TRUE
[13:36:37.881]                           break
[13:36:37.881]                         }
[13:36:37.881]                       }
[13:36:37.881]                     }
[13:36:37.881]                     invisible(muffled)
[13:36:37.881]                   }
[13:36:37.881]                   muffleCondition(cond)
[13:36:37.881]                 })
[13:36:37.881]             }))
[13:36:37.881]             future::FutureResult(value = ...future.value$value, 
[13:36:37.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.881]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.881]                     ...future.globalenv.names))
[13:36:37.881]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.881]         }, condition = base::local({
[13:36:37.881]             c <- base::c
[13:36:37.881]             inherits <- base::inherits
[13:36:37.881]             invokeRestart <- base::invokeRestart
[13:36:37.881]             length <- base::length
[13:36:37.881]             list <- base::list
[13:36:37.881]             seq.int <- base::seq.int
[13:36:37.881]             signalCondition <- base::signalCondition
[13:36:37.881]             sys.calls <- base::sys.calls
[13:36:37.881]             `[[` <- base::`[[`
[13:36:37.881]             `+` <- base::`+`
[13:36:37.881]             `<<-` <- base::`<<-`
[13:36:37.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.881]                   3L)]
[13:36:37.881]             }
[13:36:37.881]             function(cond) {
[13:36:37.881]                 is_error <- inherits(cond, "error")
[13:36:37.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.881]                   NULL)
[13:36:37.881]                 if (is_error) {
[13:36:37.881]                   sessionInformation <- function() {
[13:36:37.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.881]                       search = base::search(), system = base::Sys.info())
[13:36:37.881]                   }
[13:36:37.881]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.881]                     cond$call), session = sessionInformation(), 
[13:36:37.881]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.881]                   signalCondition(cond)
[13:36:37.881]                 }
[13:36:37.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.881]                 "immediateCondition"))) {
[13:36:37.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.881]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.881]                   if (TRUE && !signal) {
[13:36:37.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.881]                     {
[13:36:37.881]                       inherits <- base::inherits
[13:36:37.881]                       invokeRestart <- base::invokeRestart
[13:36:37.881]                       is.null <- base::is.null
[13:36:37.881]                       muffled <- FALSE
[13:36:37.881]                       if (inherits(cond, "message")) {
[13:36:37.881]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.881]                         if (muffled) 
[13:36:37.881]                           invokeRestart("muffleMessage")
[13:36:37.881]                       }
[13:36:37.881]                       else if (inherits(cond, "warning")) {
[13:36:37.881]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.881]                         if (muffled) 
[13:36:37.881]                           invokeRestart("muffleWarning")
[13:36:37.881]                       }
[13:36:37.881]                       else if (inherits(cond, "condition")) {
[13:36:37.881]                         if (!is.null(pattern)) {
[13:36:37.881]                           computeRestarts <- base::computeRestarts
[13:36:37.881]                           grepl <- base::grepl
[13:36:37.881]                           restarts <- computeRestarts(cond)
[13:36:37.881]                           for (restart in restarts) {
[13:36:37.881]                             name <- restart$name
[13:36:37.881]                             if (is.null(name)) 
[13:36:37.881]                               next
[13:36:37.881]                             if (!grepl(pattern, name)) 
[13:36:37.881]                               next
[13:36:37.881]                             invokeRestart(restart)
[13:36:37.881]                             muffled <- TRUE
[13:36:37.881]                             break
[13:36:37.881]                           }
[13:36:37.881]                         }
[13:36:37.881]                       }
[13:36:37.881]                       invisible(muffled)
[13:36:37.881]                     }
[13:36:37.881]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.881]                   }
[13:36:37.881]                 }
[13:36:37.881]                 else {
[13:36:37.881]                   if (TRUE) {
[13:36:37.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.881]                     {
[13:36:37.881]                       inherits <- base::inherits
[13:36:37.881]                       invokeRestart <- base::invokeRestart
[13:36:37.881]                       is.null <- base::is.null
[13:36:37.881]                       muffled <- FALSE
[13:36:37.881]                       if (inherits(cond, "message")) {
[13:36:37.881]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.881]                         if (muffled) 
[13:36:37.881]                           invokeRestart("muffleMessage")
[13:36:37.881]                       }
[13:36:37.881]                       else if (inherits(cond, "warning")) {
[13:36:37.881]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.881]                         if (muffled) 
[13:36:37.881]                           invokeRestart("muffleWarning")
[13:36:37.881]                       }
[13:36:37.881]                       else if (inherits(cond, "condition")) {
[13:36:37.881]                         if (!is.null(pattern)) {
[13:36:37.881]                           computeRestarts <- base::computeRestarts
[13:36:37.881]                           grepl <- base::grepl
[13:36:37.881]                           restarts <- computeRestarts(cond)
[13:36:37.881]                           for (restart in restarts) {
[13:36:37.881]                             name <- restart$name
[13:36:37.881]                             if (is.null(name)) 
[13:36:37.881]                               next
[13:36:37.881]                             if (!grepl(pattern, name)) 
[13:36:37.881]                               next
[13:36:37.881]                             invokeRestart(restart)
[13:36:37.881]                             muffled <- TRUE
[13:36:37.881]                             break
[13:36:37.881]                           }
[13:36:37.881]                         }
[13:36:37.881]                       }
[13:36:37.881]                       invisible(muffled)
[13:36:37.881]                     }
[13:36:37.881]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.881]                   }
[13:36:37.881]                 }
[13:36:37.881]             }
[13:36:37.881]         }))
[13:36:37.881]     }, error = function(ex) {
[13:36:37.881]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.881]                 ...future.rng), started = ...future.startTime, 
[13:36:37.881]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.881]             version = "1.8"), class = "FutureResult")
[13:36:37.881]     }, finally = {
[13:36:37.881]         if (!identical(...future.workdir, getwd())) 
[13:36:37.881]             setwd(...future.workdir)
[13:36:37.881]         {
[13:36:37.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.881]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.881]             }
[13:36:37.881]             base::options(...future.oldOptions)
[13:36:37.881]             if (.Platform$OS.type == "windows") {
[13:36:37.881]                 old_names <- names(...future.oldEnvVars)
[13:36:37.881]                 envs <- base::Sys.getenv()
[13:36:37.881]                 names <- names(envs)
[13:36:37.881]                 common <- intersect(names, old_names)
[13:36:37.881]                 added <- setdiff(names, old_names)
[13:36:37.881]                 removed <- setdiff(old_names, names)
[13:36:37.881]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.881]                   envs[common]]
[13:36:37.881]                 NAMES <- toupper(changed)
[13:36:37.881]                 args <- list()
[13:36:37.881]                 for (kk in seq_along(NAMES)) {
[13:36:37.881]                   name <- changed[[kk]]
[13:36:37.881]                   NAME <- NAMES[[kk]]
[13:36:37.881]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.881]                     next
[13:36:37.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.881]                 }
[13:36:37.881]                 NAMES <- toupper(added)
[13:36:37.881]                 for (kk in seq_along(NAMES)) {
[13:36:37.881]                   name <- added[[kk]]
[13:36:37.881]                   NAME <- NAMES[[kk]]
[13:36:37.881]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.881]                     next
[13:36:37.881]                   args[[name]] <- ""
[13:36:37.881]                 }
[13:36:37.881]                 NAMES <- toupper(removed)
[13:36:37.881]                 for (kk in seq_along(NAMES)) {
[13:36:37.881]                   name <- removed[[kk]]
[13:36:37.881]                   NAME <- NAMES[[kk]]
[13:36:37.881]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.881]                     next
[13:36:37.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.881]                 }
[13:36:37.881]                 if (length(args) > 0) 
[13:36:37.881]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.881]             }
[13:36:37.881]             else {
[13:36:37.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.881]             }
[13:36:37.881]             {
[13:36:37.881]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.881]                   0L) {
[13:36:37.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.881]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.881]                   base::options(opts)
[13:36:37.881]                 }
[13:36:37.881]                 {
[13:36:37.881]                   {
[13:36:37.881]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.881]                     NULL
[13:36:37.881]                   }
[13:36:37.881]                   options(future.plan = NULL)
[13:36:37.881]                   if (is.na(NA_character_)) 
[13:36:37.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.881]                     .init = FALSE)
[13:36:37.881]                 }
[13:36:37.881]             }
[13:36:37.881]         }
[13:36:37.881]     })
[13:36:37.881]     if (TRUE) {
[13:36:37.881]         base::sink(type = "output", split = FALSE)
[13:36:37.881]         if (TRUE) {
[13:36:37.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.881]         }
[13:36:37.881]         else {
[13:36:37.881]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.881]         }
[13:36:37.881]         base::close(...future.stdout)
[13:36:37.881]         ...future.stdout <- NULL
[13:36:37.881]     }
[13:36:37.881]     ...future.result$conditions <- ...future.conditions
[13:36:37.881]     ...future.result$finished <- base::Sys.time()
[13:36:37.881]     ...future.result
[13:36:37.881] }
[13:36:37.884] requestCore(): workers = 2
[13:36:37.886] MulticoreFuture started
[13:36:37.887] - Launch lazy future ... done
[13:36:37.887] run() for ‘MulticoreFuture’ ... done
[13:36:37.888] plan(): Setting new future strategy stack:
[13:36:37.888] getGlobalsAndPackages() ...
[13:36:37.888] Searching for globals...
[13:36:37.888] List of future strategies:
[13:36:37.888] 1. sequential:
[13:36:37.888]    - args: function (..., envir = parent.frame())
[13:36:37.888]    - tweaked: FALSE
[13:36:37.888]    - call: NULL
[13:36:37.889] plan(): nbrOfWorkers() = 1
[13:36:37.889] - globals found: [1] ‘{’
[13:36:37.889] Searching for globals ... DONE
[13:36:37.890] Resolving globals: FALSE
[13:36:37.890] 
[13:36:37.890] 
[13:36:37.891] getGlobalsAndPackages() ... DONE
[13:36:37.891] plan(): Setting new future strategy stack:
[13:36:37.891] run() for ‘Future’ ...
[13:36:37.891] - state: ‘created’
[13:36:37.891] List of future strategies:
[13:36:37.891] 1. multicore:
[13:36:37.891]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.891]    - tweaked: FALSE
[13:36:37.891]    - call: plan(strategy)
[13:36:37.891] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:37.896] plan(): nbrOfWorkers() = 2
[13:36:37.896] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:37.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:37.896]   - Field: ‘label’
[13:36:37.897]   - Field: ‘local’
[13:36:37.897]   - Field: ‘owner’
[13:36:37.897]   - Field: ‘envir’
[13:36:37.897]   - Field: ‘workers’
[13:36:37.897]   - Field: ‘packages’
[13:36:37.897]   - Field: ‘gc’
[13:36:37.897]   - Field: ‘job’
[13:36:37.898]   - Field: ‘conditions’
[13:36:37.898]   - Field: ‘expr’
[13:36:37.898]   - Field: ‘uuid’
[13:36:37.898]   - Field: ‘seed’
[13:36:37.898]   - Field: ‘version’
[13:36:37.898]   - Field: ‘result’
[13:36:37.898]   - Field: ‘asynchronous’
[13:36:37.899]   - Field: ‘calls’
[13:36:37.899]   - Field: ‘globals’
[13:36:37.899]   - Field: ‘stdout’
[13:36:37.899]   - Field: ‘earlySignal’
[13:36:37.899]   - Field: ‘lazy’
[13:36:37.899]   - Field: ‘state’
[13:36:37.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:37.900] - Launch lazy future ...
[13:36:37.900] Packages needed by the future expression (n = 0): <none>
[13:36:37.900] Packages needed by future strategies (n = 0): <none>
[13:36:37.901] {
[13:36:37.901]     {
[13:36:37.901]         {
[13:36:37.901]             ...future.startTime <- base::Sys.time()
[13:36:37.901]             {
[13:36:37.901]                 {
[13:36:37.901]                   {
[13:36:37.901]                     {
[13:36:37.901]                       base::local({
[13:36:37.901]                         has_future <- base::requireNamespace("future", 
[13:36:37.901]                           quietly = TRUE)
[13:36:37.901]                         if (has_future) {
[13:36:37.901]                           ns <- base::getNamespace("future")
[13:36:37.901]                           version <- ns[[".package"]][["version"]]
[13:36:37.901]                           if (is.null(version)) 
[13:36:37.901]                             version <- utils::packageVersion("future")
[13:36:37.901]                         }
[13:36:37.901]                         else {
[13:36:37.901]                           version <- NULL
[13:36:37.901]                         }
[13:36:37.901]                         if (!has_future || version < "1.8.0") {
[13:36:37.901]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:37.901]                             "", base::R.version$version.string), 
[13:36:37.901]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:37.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:37.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:37.901]                               "release", "version")], collapse = " "), 
[13:36:37.901]                             hostname = base::Sys.info()[["nodename"]])
[13:36:37.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:37.901]                             info)
[13:36:37.901]                           info <- base::paste(info, collapse = "; ")
[13:36:37.901]                           if (!has_future) {
[13:36:37.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:37.901]                               info)
[13:36:37.901]                           }
[13:36:37.901]                           else {
[13:36:37.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:37.901]                               info, version)
[13:36:37.901]                           }
[13:36:37.901]                           base::stop(msg)
[13:36:37.901]                         }
[13:36:37.901]                       })
[13:36:37.901]                     }
[13:36:37.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:37.901]                     base::options(mc.cores = 1L)
[13:36:37.901]                   }
[13:36:37.901]                   ...future.strategy.old <- future::plan("list")
[13:36:37.901]                   options(future.plan = NULL)
[13:36:37.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:37.901]                 }
[13:36:37.901]                 ...future.workdir <- getwd()
[13:36:37.901]             }
[13:36:37.901]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:37.901]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:37.901]         }
[13:36:37.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:37.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:37.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:37.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:37.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:37.901]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:37.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:37.901]             base::names(...future.oldOptions))
[13:36:37.901]     }
[13:36:37.901]     if (FALSE) {
[13:36:37.901]     }
[13:36:37.901]     else {
[13:36:37.901]         if (TRUE) {
[13:36:37.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:37.901]                 open = "w")
[13:36:37.901]         }
[13:36:37.901]         else {
[13:36:37.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:37.901]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:37.901]         }
[13:36:37.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:37.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:37.901]             base::sink(type = "output", split = FALSE)
[13:36:37.901]             base::close(...future.stdout)
[13:36:37.901]         }, add = TRUE)
[13:36:37.901]     }
[13:36:37.901]     ...future.frame <- base::sys.nframe()
[13:36:37.901]     ...future.conditions <- base::list()
[13:36:37.901]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:37.901]     if (FALSE) {
[13:36:37.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:37.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:37.901]     }
[13:36:37.901]     ...future.result <- base::tryCatch({
[13:36:37.901]         base::withCallingHandlers({
[13:36:37.901]             ...future.value <- base::withVisible(base::local({
[13:36:37.901]                 withCallingHandlers({
[13:36:37.901]                   {
[13:36:37.901]                     4
[13:36:37.901]                   }
[13:36:37.901]                 }, immediateCondition = function(cond) {
[13:36:37.901]                   save_rds <- function (object, pathname, ...) 
[13:36:37.901]                   {
[13:36:37.901]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:37.901]                     if (file_test("-f", pathname_tmp)) {
[13:36:37.901]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.901]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:37.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.901]                         fi_tmp[["mtime"]])
[13:36:37.901]                     }
[13:36:37.901]                     tryCatch({
[13:36:37.901]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:37.901]                     }, error = function(ex) {
[13:36:37.901]                       msg <- conditionMessage(ex)
[13:36:37.901]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.901]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:37.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.901]                         fi_tmp[["mtime"]], msg)
[13:36:37.901]                       ex$message <- msg
[13:36:37.901]                       stop(ex)
[13:36:37.901]                     })
[13:36:37.901]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:37.901]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:37.901]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:37.901]                       fi_tmp <- file.info(pathname_tmp)
[13:36:37.901]                       fi <- file.info(pathname)
[13:36:37.901]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:37.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:37.901]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:37.901]                         fi[["size"]], fi[["mtime"]])
[13:36:37.901]                       stop(msg)
[13:36:37.901]                     }
[13:36:37.901]                     invisible(pathname)
[13:36:37.901]                   }
[13:36:37.901]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:37.901]                     rootPath = tempdir()) 
[13:36:37.901]                   {
[13:36:37.901]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:37.901]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:37.901]                       tmpdir = path, fileext = ".rds")
[13:36:37.901]                     save_rds(obj, file)
[13:36:37.901]                   }
[13:36:37.901]                   saveImmediateCondition(cond, path = "/tmp/RtmpghQbAf/.future/immediateConditions")
[13:36:37.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.901]                   {
[13:36:37.901]                     inherits <- base::inherits
[13:36:37.901]                     invokeRestart <- base::invokeRestart
[13:36:37.901]                     is.null <- base::is.null
[13:36:37.901]                     muffled <- FALSE
[13:36:37.901]                     if (inherits(cond, "message")) {
[13:36:37.901]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:37.901]                       if (muffled) 
[13:36:37.901]                         invokeRestart("muffleMessage")
[13:36:37.901]                     }
[13:36:37.901]                     else if (inherits(cond, "warning")) {
[13:36:37.901]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:37.901]                       if (muffled) 
[13:36:37.901]                         invokeRestart("muffleWarning")
[13:36:37.901]                     }
[13:36:37.901]                     else if (inherits(cond, "condition")) {
[13:36:37.901]                       if (!is.null(pattern)) {
[13:36:37.901]                         computeRestarts <- base::computeRestarts
[13:36:37.901]                         grepl <- base::grepl
[13:36:37.901]                         restarts <- computeRestarts(cond)
[13:36:37.901]                         for (restart in restarts) {
[13:36:37.901]                           name <- restart$name
[13:36:37.901]                           if (is.null(name)) 
[13:36:37.901]                             next
[13:36:37.901]                           if (!grepl(pattern, name)) 
[13:36:37.901]                             next
[13:36:37.901]                           invokeRestart(restart)
[13:36:37.901]                           muffled <- TRUE
[13:36:37.901]                           break
[13:36:37.901]                         }
[13:36:37.901]                       }
[13:36:37.901]                     }
[13:36:37.901]                     invisible(muffled)
[13:36:37.901]                   }
[13:36:37.901]                   muffleCondition(cond)
[13:36:37.901]                 })
[13:36:37.901]             }))
[13:36:37.901]             future::FutureResult(value = ...future.value$value, 
[13:36:37.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.901]                   ...future.rng), globalenv = if (FALSE) 
[13:36:37.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:37.901]                     ...future.globalenv.names))
[13:36:37.901]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:37.901]         }, condition = base::local({
[13:36:37.901]             c <- base::c
[13:36:37.901]             inherits <- base::inherits
[13:36:37.901]             invokeRestart <- base::invokeRestart
[13:36:37.901]             length <- base::length
[13:36:37.901]             list <- base::list
[13:36:37.901]             seq.int <- base::seq.int
[13:36:37.901]             signalCondition <- base::signalCondition
[13:36:37.901]             sys.calls <- base::sys.calls
[13:36:37.901]             `[[` <- base::`[[`
[13:36:37.901]             `+` <- base::`+`
[13:36:37.901]             `<<-` <- base::`<<-`
[13:36:37.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:37.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:37.901]                   3L)]
[13:36:37.901]             }
[13:36:37.901]             function(cond) {
[13:36:37.901]                 is_error <- inherits(cond, "error")
[13:36:37.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:37.901]                   NULL)
[13:36:37.901]                 if (is_error) {
[13:36:37.901]                   sessionInformation <- function() {
[13:36:37.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:37.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:37.901]                       search = base::search(), system = base::Sys.info())
[13:36:37.901]                   }
[13:36:37.901]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:37.901]                     cond$call), session = sessionInformation(), 
[13:36:37.901]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:37.901]                   signalCondition(cond)
[13:36:37.901]                 }
[13:36:37.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:37.901]                 "immediateCondition"))) {
[13:36:37.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:37.901]                   ...future.conditions[[length(...future.conditions) + 
[13:36:37.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:37.901]                   if (TRUE && !signal) {
[13:36:37.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.901]                     {
[13:36:37.901]                       inherits <- base::inherits
[13:36:37.901]                       invokeRestart <- base::invokeRestart
[13:36:37.901]                       is.null <- base::is.null
[13:36:37.901]                       muffled <- FALSE
[13:36:37.901]                       if (inherits(cond, "message")) {
[13:36:37.901]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.901]                         if (muffled) 
[13:36:37.901]                           invokeRestart("muffleMessage")
[13:36:37.901]                       }
[13:36:37.901]                       else if (inherits(cond, "warning")) {
[13:36:37.901]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.901]                         if (muffled) 
[13:36:37.901]                           invokeRestart("muffleWarning")
[13:36:37.901]                       }
[13:36:37.901]                       else if (inherits(cond, "condition")) {
[13:36:37.901]                         if (!is.null(pattern)) {
[13:36:37.901]                           computeRestarts <- base::computeRestarts
[13:36:37.901]                           grepl <- base::grepl
[13:36:37.901]                           restarts <- computeRestarts(cond)
[13:36:37.901]                           for (restart in restarts) {
[13:36:37.901]                             name <- restart$name
[13:36:37.901]                             if (is.null(name)) 
[13:36:37.901]                               next
[13:36:37.901]                             if (!grepl(pattern, name)) 
[13:36:37.901]                               next
[13:36:37.901]                             invokeRestart(restart)
[13:36:37.901]                             muffled <- TRUE
[13:36:37.901]                             break
[13:36:37.901]                           }
[13:36:37.901]                         }
[13:36:37.901]                       }
[13:36:37.901]                       invisible(muffled)
[13:36:37.901]                     }
[13:36:37.901]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.901]                   }
[13:36:37.901]                 }
[13:36:37.901]                 else {
[13:36:37.901]                   if (TRUE) {
[13:36:37.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:37.901]                     {
[13:36:37.901]                       inherits <- base::inherits
[13:36:37.901]                       invokeRestart <- base::invokeRestart
[13:36:37.901]                       is.null <- base::is.null
[13:36:37.901]                       muffled <- FALSE
[13:36:37.901]                       if (inherits(cond, "message")) {
[13:36:37.901]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:37.901]                         if (muffled) 
[13:36:37.901]                           invokeRestart("muffleMessage")
[13:36:37.901]                       }
[13:36:37.901]                       else if (inherits(cond, "warning")) {
[13:36:37.901]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:37.901]                         if (muffled) 
[13:36:37.901]                           invokeRestart("muffleWarning")
[13:36:37.901]                       }
[13:36:37.901]                       else if (inherits(cond, "condition")) {
[13:36:37.901]                         if (!is.null(pattern)) {
[13:36:37.901]                           computeRestarts <- base::computeRestarts
[13:36:37.901]                           grepl <- base::grepl
[13:36:37.901]                           restarts <- computeRestarts(cond)
[13:36:37.901]                           for (restart in restarts) {
[13:36:37.901]                             name <- restart$name
[13:36:37.901]                             if (is.null(name)) 
[13:36:37.901]                               next
[13:36:37.901]                             if (!grepl(pattern, name)) 
[13:36:37.901]                               next
[13:36:37.901]                             invokeRestart(restart)
[13:36:37.901]                             muffled <- TRUE
[13:36:37.901]                             break
[13:36:37.901]                           }
[13:36:37.901]                         }
[13:36:37.901]                       }
[13:36:37.901]                       invisible(muffled)
[13:36:37.901]                     }
[13:36:37.901]                     muffleCondition(cond, pattern = "^muffle")
[13:36:37.901]                   }
[13:36:37.901]                 }
[13:36:37.901]             }
[13:36:37.901]         }))
[13:36:37.901]     }, error = function(ex) {
[13:36:37.901]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:37.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:37.901]                 ...future.rng), started = ...future.startTime, 
[13:36:37.901]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:37.901]             version = "1.8"), class = "FutureResult")
[13:36:37.901]     }, finally = {
[13:36:37.901]         if (!identical(...future.workdir, getwd())) 
[13:36:37.901]             setwd(...future.workdir)
[13:36:37.901]         {
[13:36:37.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:37.901]                 ...future.oldOptions$nwarnings <- NULL
[13:36:37.901]             }
[13:36:37.901]             base::options(...future.oldOptions)
[13:36:37.901]             if (.Platform$OS.type == "windows") {
[13:36:37.901]                 old_names <- names(...future.oldEnvVars)
[13:36:37.901]                 envs <- base::Sys.getenv()
[13:36:37.901]                 names <- names(envs)
[13:36:37.901]                 common <- intersect(names, old_names)
[13:36:37.901]                 added <- setdiff(names, old_names)
[13:36:37.901]                 removed <- setdiff(old_names, names)
[13:36:37.901]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:37.901]                   envs[common]]
[13:36:37.901]                 NAMES <- toupper(changed)
[13:36:37.901]                 args <- list()
[13:36:37.901]                 for (kk in seq_along(NAMES)) {
[13:36:37.901]                   name <- changed[[kk]]
[13:36:37.901]                   NAME <- NAMES[[kk]]
[13:36:37.901]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.901]                     next
[13:36:37.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.901]                 }
[13:36:37.901]                 NAMES <- toupper(added)
[13:36:37.901]                 for (kk in seq_along(NAMES)) {
[13:36:37.901]                   name <- added[[kk]]
[13:36:37.901]                   NAME <- NAMES[[kk]]
[13:36:37.901]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.901]                     next
[13:36:37.901]                   args[[name]] <- ""
[13:36:37.901]                 }
[13:36:37.901]                 NAMES <- toupper(removed)
[13:36:37.901]                 for (kk in seq_along(NAMES)) {
[13:36:37.901]                   name <- removed[[kk]]
[13:36:37.901]                   NAME <- NAMES[[kk]]
[13:36:37.901]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:37.901]                     next
[13:36:37.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:37.901]                 }
[13:36:37.901]                 if (length(args) > 0) 
[13:36:37.901]                   base::do.call(base::Sys.setenv, args = args)
[13:36:37.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:37.901]             }
[13:36:37.901]             else {
[13:36:37.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:37.901]             }
[13:36:37.901]             {
[13:36:37.901]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:37.901]                   0L) {
[13:36:37.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:37.901]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:37.901]                   base::options(opts)
[13:36:37.901]                 }
[13:36:37.901]                 {
[13:36:37.901]                   {
[13:36:37.901]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:37.901]                     NULL
[13:36:37.901]                   }
[13:36:37.901]                   options(future.plan = NULL)
[13:36:37.901]                   if (is.na(NA_character_)) 
[13:36:37.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:37.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:37.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:37.901]                     .init = FALSE)
[13:36:37.901]                 }
[13:36:37.901]             }
[13:36:37.901]         }
[13:36:37.901]     })
[13:36:37.901]     if (TRUE) {
[13:36:37.901]         base::sink(type = "output", split = FALSE)
[13:36:37.901]         if (TRUE) {
[13:36:37.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:37.901]         }
[13:36:37.901]         else {
[13:36:37.901]             ...future.result["stdout"] <- base::list(NULL)
[13:36:37.901]         }
[13:36:37.901]         base::close(...future.stdout)
[13:36:37.901]         ...future.stdout <- NULL
[13:36:37.901]     }
[13:36:37.901]     ...future.result$conditions <- ...future.conditions
[13:36:37.901]     ...future.result$finished <- base::Sys.time()
[13:36:37.901]     ...future.result
[13:36:37.901] }
[13:36:37.904] requestCore(): workers = 2
[13:36:37.905] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:37.915] result() for MulticoreFuture ...
[13:36:37.916] result() for MulticoreFuture ...
[13:36:37.916] result() for MulticoreFuture ... done
[13:36:37.916] result() for MulticoreFuture ... done
[13:36:37.917] result() for MulticoreFuture ...
[13:36:37.917] result() for MulticoreFuture ... done
[13:36:37.919] MulticoreFuture started
[13:36:37.920] - Launch lazy future ... done
[13:36:37.920] run() for ‘MulticoreFuture’ ... done
[13:36:37.921] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x564a7454bb80> 
[13:36:37.921] List of future strategies:
[13:36:37.921] 1. sequential:
[13:36:37.921]    - args: function (..., envir = parent.frame())
[13:36:37.921]    - tweaked: FALSE
[13:36:37.921]    - call: NULL
[13:36:37.922] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x564a750e3210> 
 - attr(*, "dim.")=[13:36:37.925] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[13:36:37.925] List of future strategies:
[13:36:37.925] 1. multicore:
[13:36:37.925]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:37.925]    - tweaked: FALSE
[13:36:37.925]    - call: plan(strategy)
List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:37.941] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:37.946] resolve() on list environment ...
[13:36:37.947]  recursive: 0
[13:36:37.948]  length: 6
[13:36:37.948]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:37.948] signalConditionsASAP(numeric, pos=1) ...
[13:36:37.948] - nx: 6
[13:36:37.949] - relay: TRUE
[13:36:37.949] - stdout: TRUE
[13:36:37.949] - signal: TRUE
[13:36:37.949] - resignal: FALSE
[13:36:37.949] - force: TRUE
[13:36:37.949] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.949] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.950]  - until=2
[13:36:37.950]  - relaying element #2
[13:36:37.950] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.950] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.950] signalConditionsASAP(NULL, pos=1) ... done
[13:36:37.950]  length: 5 (resolved future 1)
[13:36:37.950] Future #2
[13:36:37.951] result() for MulticoreFuture ...
[13:36:37.951] result() for MulticoreFuture ... done
[13:36:37.951] result() for MulticoreFuture ...
[13:36:37.951] result() for MulticoreFuture ... done
[13:36:37.951] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:36:37.951] - nx: 6
[13:36:37.951] - relay: TRUE
[13:36:37.951] - stdout: TRUE
[13:36:37.952] - signal: TRUE
[13:36:37.952] - resignal: FALSE
[13:36:37.952] - force: TRUE
[13:36:37.952] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.952] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:37.952]  - until=2
[13:36:37.952]  - relaying element #2
[13:36:37.952] result() for MulticoreFuture ...
[13:36:37.953] result() for MulticoreFuture ... done
[13:36:37.953] result() for MulticoreFuture ...
[13:36:37.953] result() for MulticoreFuture ... done
[13:36:37.953] result() for MulticoreFuture ...
[13:36:37.953] result() for MulticoreFuture ... done
[13:36:37.953] result() for MulticoreFuture ...
[13:36:37.953] result() for MulticoreFuture ... done
[13:36:37.953] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.954] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.954] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:36:37.954]  length: 4 (resolved future 2)
[13:36:37.954] Future #3
[13:36:37.954] result() for MulticoreFuture ...
[13:36:37.955] result() for MulticoreFuture ...
[13:36:37.955] result() for MulticoreFuture ... done
[13:36:37.955] result() for MulticoreFuture ... done
[13:36:37.956] result() for MulticoreFuture ...
[13:36:37.956] result() for MulticoreFuture ... done
[13:36:37.956] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:36:37.956] - nx: 6
[13:36:37.956] - relay: TRUE
[13:36:37.956] - stdout: TRUE
[13:36:37.956] - signal: TRUE
[13:36:37.956] - resignal: FALSE
[13:36:37.956] - force: TRUE
[13:36:37.957] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.957] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:37.957]  - until=3
[13:36:37.957]  - relaying element #3
[13:36:37.957] result() for MulticoreFuture ...
[13:36:37.957] result() for MulticoreFuture ... done
[13:36:37.957] result() for MulticoreFuture ...
[13:36:37.957] result() for MulticoreFuture ... done
[13:36:37.958] result() for MulticoreFuture ...
[13:36:37.958] result() for MulticoreFuture ... done
[13:36:37.958] result() for MulticoreFuture ...
[13:36:37.958] result() for MulticoreFuture ... done
[13:36:37.958] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.958] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.958] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:36:37.959]  length: 3 (resolved future 3)
[13:36:37.959] Future #4
[13:36:37.959] result() for MulticoreFuture ...
[13:36:37.960] result() for MulticoreFuture ...
[13:36:37.960] result() for MulticoreFuture ... done
[13:36:37.960] result() for MulticoreFuture ... done
[13:36:37.960] result() for MulticoreFuture ...
[13:36:37.960] result() for MulticoreFuture ... done
[13:36:37.961] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:36:37.961] - nx: 6
[13:36:37.961] - relay: TRUE
[13:36:37.961] - stdout: TRUE
[13:36:37.961] - signal: TRUE
[13:36:37.961] - resignal: FALSE
[13:36:37.962] - force: TRUE
[13:36:37.962] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.962] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:37.962]  - until=4
[13:36:37.962]  - relaying element #4
[13:36:37.962] result() for MulticoreFuture ...
[13:36:37.963] result() for MulticoreFuture ... done
[13:36:37.963] result() for MulticoreFuture ...
[13:36:37.963] result() for MulticoreFuture ... done
[13:36:37.963] result() for MulticoreFuture ...
[13:36:37.963] result() for MulticoreFuture ... done
[13:36:37.963] result() for MulticoreFuture ...
[13:36:37.964] result() for MulticoreFuture ... done
[13:36:37.964] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.964] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.964] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:36:37.964]  length: 2 (resolved future 4)
[13:36:37.964] signalConditionsASAP(NULL, pos=5) ...
[13:36:37.965] - nx: 6
[13:36:37.965] - relay: TRUE
[13:36:37.965] - stdout: TRUE
[13:36:37.965] - signal: TRUE
[13:36:37.965] - resignal: FALSE
[13:36:37.965] - force: TRUE
[13:36:37.965] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.965] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.965]  - until=6
[13:36:37.966]  - relaying element #6
[13:36:37.966] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.966] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.966] signalConditionsASAP(NULL, pos=5) ... done
[13:36:37.966]  length: 1 (resolved future 5)
[13:36:37.966] signalConditionsASAP(numeric, pos=6) ...
[13:36:37.966] - nx: 6
[13:36:37.966] - relay: TRUE
[13:36:37.966] - stdout: TRUE
[13:36:37.967] - signal: TRUE
[13:36:37.967] - resignal: FALSE
[13:36:37.967] - force: TRUE
[13:36:37.967] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:37.967] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.967]  - until=6
[13:36:37.967] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.967] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.967] signalConditionsASAP(numeric, pos=6) ... done
[13:36:37.968]  length: 0 (resolved future 6)
[13:36:37.968] Relaying remaining futures
[13:36:37.968] signalConditionsASAP(NULL, pos=0) ...
[13:36:37.968] - nx: 6
[13:36:37.968] - relay: TRUE
[13:36:37.968] - stdout: TRUE
[13:36:37.968] - signal: TRUE
[13:36:37.968] - resignal: FALSE
[13:36:37.968] - force: TRUE
[13:36:37.968] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.969] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:37.969] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:37.969] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:37.969] signalConditionsASAP(NULL, pos=0) ... done
[13:36:37.969] resolve() on list environment ... DONE
[13:36:37.969] result() for MulticoreFuture ...
[13:36:37.969] result() for MulticoreFuture ... done
[13:36:37.969] result() for MulticoreFuture ...
[13:36:37.970] result() for MulticoreFuture ... done
[13:36:37.970] result() for MulticoreFuture ...
[13:36:37.970] result() for MulticoreFuture ... done
[13:36:37.970] result() for MulticoreFuture ...
[13:36:37.970] result() for MulticoreFuture ... done
[13:36:37.970] result() for MulticoreFuture ...
[13:36:37.971] result() for MulticoreFuture ... done
[13:36:37.971] result() for MulticoreFuture ...
[13:36:37.971] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a73681a70> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[13:36:37.974] plan(): Setting new future strategy stack:
[13:36:37.974] List of future strategies:
[13:36:37.974] 1. multisession:
[13:36:37.974]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:37.974]    - tweaked: FALSE
[13:36:37.974]    - call: plan(strategy)
[13:36:37.974] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:36:37.974] multisession:
[13:36:37.974] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:37.974] - tweaked: FALSE
[13:36:37.974] - call: plan(strategy)
[13:36:37.979] getGlobalsAndPackages() ...
[13:36:37.979] Not searching for globals
[13:36:37.979] - globals: [0] <none>
[13:36:37.979] getGlobalsAndPackages() ... DONE
[13:36:37.979] [local output] makeClusterPSOCK() ...
[13:36:37.983] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:36:37.983] [local output] Base port: 11904
[13:36:37.983] [local output] Getting setup options for 2 cluster nodes ...
[13:36:37.984] [local output]  - Node 1 of 2 ...
[13:36:37.984] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:37.985] [local output] Rscript port: 11904

[13:36:37.985] [local output]  - Node 2 of 2 ...
[13:36:37.985] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:37.986] [local output] Rscript port: 11904

[13:36:37.986] [local output] Getting setup options for 2 cluster nodes ... done
[13:36:37.986] [local output]  - Parallel setup requested for some PSOCK nodes
[13:36:37.987] [local output] Setting up PSOCK nodes in parallel
[13:36:37.987] List of 36
[13:36:37.987]  $ worker          : chr "localhost"
[13:36:37.987]   ..- attr(*, "localhost")= logi TRUE
[13:36:37.987]  $ master          : chr "localhost"
[13:36:37.987]  $ port            : int 11904
[13:36:37.987]  $ connectTimeout  : num 120
[13:36:37.987]  $ timeout         : num 2592000
[13:36:37.987]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:36:37.987]  $ homogeneous     : logi TRUE
[13:36:37.987]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:36:37.987]  $ rscript_envs    : NULL
[13:36:37.987]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:37.987]  $ rscript_startup : NULL
[13:36:37.987]  $ rscript_sh      : chr "sh"
[13:36:37.987]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:37.987]  $ methods         : logi TRUE
[13:36:37.987]  $ socketOptions   : chr "no-delay"
[13:36:37.987]  $ useXDR          : logi FALSE
[13:36:37.987]  $ outfile         : chr "/dev/null"
[13:36:37.987]  $ renice          : int NA
[13:36:37.987]  $ rshcmd          : NULL
[13:36:37.987]  $ user            : chr(0) 
[13:36:37.987]  $ revtunnel       : logi FALSE
[13:36:37.987]  $ rshlogfile      : NULL
[13:36:37.987]  $ rshopts         : chr(0) 
[13:36:37.987]  $ rank            : int 1
[13:36:37.987]  $ manual          : logi FALSE
[13:36:37.987]  $ dryrun          : logi FALSE
[13:36:37.987]  $ quiet           : logi FALSE
[13:36:37.987]  $ setup_strategy  : chr "parallel"
[13:36:37.987]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:37.987]  $ pidfile         : chr "/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af4f00c394.pid"
[13:36:37.987]  $ rshcmd_label    : NULL
[13:36:37.987]  $ rsh_call        : NULL
[13:36:37.987]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:37.987]  $ localMachine    : logi TRUE
[13:36:37.987]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:36:37.987]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:36:37.987]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:36:37.987]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:36:37.987]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:36:37.987]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:36:37.987]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:36:37.987]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:36:37.987]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:36:37.987]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:36:37.987]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:36:37.987]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:36:37.987]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:36:37.987]  $ arguments       :List of 28
[13:36:37.987]   ..$ worker          : chr "localhost"
[13:36:37.987]   ..$ master          : NULL
[13:36:37.987]   ..$ port            : int 11904
[13:36:37.987]   ..$ connectTimeout  : num 120
[13:36:37.987]   ..$ timeout         : num 2592000
[13:36:37.987]   ..$ rscript         : NULL
[13:36:37.987]   ..$ homogeneous     : NULL
[13:36:37.987]   ..$ rscript_args    : NULL
[13:36:37.987]   ..$ rscript_envs    : NULL
[13:36:37.987]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:37.987]   ..$ rscript_startup : NULL
[13:36:37.987]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:36:37.987]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:37.987]   ..$ methods         : logi TRUE
[13:36:37.987]   ..$ socketOptions   : chr "no-delay"
[13:36:37.987]   ..$ useXDR          : logi FALSE
[13:36:37.987]   ..$ outfile         : chr "/dev/null"
[13:36:37.987]   ..$ renice          : int NA
[13:36:37.987]   ..$ rshcmd          : NULL
[13:36:37.987]   ..$ user            : NULL
[13:36:37.987]   ..$ revtunnel       : logi NA
[13:36:37.987]   ..$ rshlogfile      : NULL
[13:36:37.987]   ..$ rshopts         : NULL
[13:36:37.987]   ..$ rank            : int 1
[13:36:37.987]   ..$ manual          : logi FALSE
[13:36:37.987]   ..$ dryrun          : logi FALSE
[13:36:37.987]   ..$ quiet           : logi FALSE
[13:36:37.987]   ..$ setup_strategy  : chr "parallel"
[13:36:37.987]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:36:38.006] [local output] System call to launch all workers:
[13:36:38.006] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpghQbAf/worker.rank=1.parallelly.parent=82607.142af4f00c394.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11904 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:36:38.006] [local output] Starting PSOCK main server
[13:36:38.008] [local output] Workers launched
[13:36:38.008] [local output] Waiting for workers to connect back
[13:36:38.008]  - [local output] 0 workers out of 2 ready
[13:36:38.281]  - [local output] 0 workers out of 2 ready
[13:36:38.282]  - [local output] 1 workers out of 2 ready
[13:36:38.282]  - [local output] 2 workers out of 2 ready
[13:36:38.282] [local output] Launching of workers completed
[13:36:38.282] [local output] Collecting session information from workers
[13:36:38.283] [local output]  - Worker #1 of 2
[13:36:38.283] [local output]  - Worker #2 of 2
[13:36:38.284] [local output] makeClusterPSOCK() ... done
[13:36:38.295] Packages needed by the future expression (n = 0): <none>
[13:36:38.295] Packages needed by future strategies (n = 0): <none>
[13:36:38.296] {
[13:36:38.296]     {
[13:36:38.296]         {
[13:36:38.296]             ...future.startTime <- base::Sys.time()
[13:36:38.296]             {
[13:36:38.296]                 {
[13:36:38.296]                   {
[13:36:38.296]                     {
[13:36:38.296]                       base::local({
[13:36:38.296]                         has_future <- base::requireNamespace("future", 
[13:36:38.296]                           quietly = TRUE)
[13:36:38.296]                         if (has_future) {
[13:36:38.296]                           ns <- base::getNamespace("future")
[13:36:38.296]                           version <- ns[[".package"]][["version"]]
[13:36:38.296]                           if (is.null(version)) 
[13:36:38.296]                             version <- utils::packageVersion("future")
[13:36:38.296]                         }
[13:36:38.296]                         else {
[13:36:38.296]                           version <- NULL
[13:36:38.296]                         }
[13:36:38.296]                         if (!has_future || version < "1.8.0") {
[13:36:38.296]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.296]                             "", base::R.version$version.string), 
[13:36:38.296]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.296]                               "release", "version")], collapse = " "), 
[13:36:38.296]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.296]                             info)
[13:36:38.296]                           info <- base::paste(info, collapse = "; ")
[13:36:38.296]                           if (!has_future) {
[13:36:38.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.296]                               info)
[13:36:38.296]                           }
[13:36:38.296]                           else {
[13:36:38.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.296]                               info, version)
[13:36:38.296]                           }
[13:36:38.296]                           base::stop(msg)
[13:36:38.296]                         }
[13:36:38.296]                       })
[13:36:38.296]                     }
[13:36:38.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.296]                     base::options(mc.cores = 1L)
[13:36:38.296]                   }
[13:36:38.296]                   ...future.strategy.old <- future::plan("list")
[13:36:38.296]                   options(future.plan = NULL)
[13:36:38.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.296]                 }
[13:36:38.296]                 ...future.workdir <- getwd()
[13:36:38.296]             }
[13:36:38.296]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.296]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.296]         }
[13:36:38.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.296]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.296]             base::names(...future.oldOptions))
[13:36:38.296]     }
[13:36:38.296]     if (FALSE) {
[13:36:38.296]     }
[13:36:38.296]     else {
[13:36:38.296]         if (TRUE) {
[13:36:38.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.296]                 open = "w")
[13:36:38.296]         }
[13:36:38.296]         else {
[13:36:38.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.296]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.296]         }
[13:36:38.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.296]             base::sink(type = "output", split = FALSE)
[13:36:38.296]             base::close(...future.stdout)
[13:36:38.296]         }, add = TRUE)
[13:36:38.296]     }
[13:36:38.296]     ...future.frame <- base::sys.nframe()
[13:36:38.296]     ...future.conditions <- base::list()
[13:36:38.296]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.296]     if (FALSE) {
[13:36:38.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.296]     }
[13:36:38.296]     ...future.result <- base::tryCatch({
[13:36:38.296]         base::withCallingHandlers({
[13:36:38.296]             ...future.value <- base::withVisible(base::local({
[13:36:38.296]                 ...future.makeSendCondition <- base::local({
[13:36:38.296]                   sendCondition <- NULL
[13:36:38.296]                   function(frame = 1L) {
[13:36:38.296]                     if (is.function(sendCondition)) 
[13:36:38.296]                       return(sendCondition)
[13:36:38.296]                     ns <- getNamespace("parallel")
[13:36:38.296]                     if (exists("sendData", mode = "function", 
[13:36:38.296]                       envir = ns)) {
[13:36:38.296]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.296]                         envir = ns)
[13:36:38.296]                       envir <- sys.frame(frame)
[13:36:38.296]                       master <- NULL
[13:36:38.296]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.296]                         !identical(envir, emptyenv())) {
[13:36:38.296]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.296]                           inherits = FALSE)) {
[13:36:38.296]                           master <- get("master", mode = "list", 
[13:36:38.296]                             envir = envir, inherits = FALSE)
[13:36:38.296]                           if (inherits(master, c("SOCKnode", 
[13:36:38.296]                             "SOCK0node"))) {
[13:36:38.296]                             sendCondition <<- function(cond) {
[13:36:38.296]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.296]                                 success = TRUE)
[13:36:38.296]                               parallel_sendData(master, data)
[13:36:38.296]                             }
[13:36:38.296]                             return(sendCondition)
[13:36:38.296]                           }
[13:36:38.296]                         }
[13:36:38.296]                         frame <- frame + 1L
[13:36:38.296]                         envir <- sys.frame(frame)
[13:36:38.296]                       }
[13:36:38.296]                     }
[13:36:38.296]                     sendCondition <<- function(cond) NULL
[13:36:38.296]                   }
[13:36:38.296]                 })
[13:36:38.296]                 withCallingHandlers({
[13:36:38.296]                   NA
[13:36:38.296]                 }, immediateCondition = function(cond) {
[13:36:38.296]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.296]                   sendCondition(cond)
[13:36:38.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.296]                   {
[13:36:38.296]                     inherits <- base::inherits
[13:36:38.296]                     invokeRestart <- base::invokeRestart
[13:36:38.296]                     is.null <- base::is.null
[13:36:38.296]                     muffled <- FALSE
[13:36:38.296]                     if (inherits(cond, "message")) {
[13:36:38.296]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.296]                       if (muffled) 
[13:36:38.296]                         invokeRestart("muffleMessage")
[13:36:38.296]                     }
[13:36:38.296]                     else if (inherits(cond, "warning")) {
[13:36:38.296]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.296]                       if (muffled) 
[13:36:38.296]                         invokeRestart("muffleWarning")
[13:36:38.296]                     }
[13:36:38.296]                     else if (inherits(cond, "condition")) {
[13:36:38.296]                       if (!is.null(pattern)) {
[13:36:38.296]                         computeRestarts <- base::computeRestarts
[13:36:38.296]                         grepl <- base::grepl
[13:36:38.296]                         restarts <- computeRestarts(cond)
[13:36:38.296]                         for (restart in restarts) {
[13:36:38.296]                           name <- restart$name
[13:36:38.296]                           if (is.null(name)) 
[13:36:38.296]                             next
[13:36:38.296]                           if (!grepl(pattern, name)) 
[13:36:38.296]                             next
[13:36:38.296]                           invokeRestart(restart)
[13:36:38.296]                           muffled <- TRUE
[13:36:38.296]                           break
[13:36:38.296]                         }
[13:36:38.296]                       }
[13:36:38.296]                     }
[13:36:38.296]                     invisible(muffled)
[13:36:38.296]                   }
[13:36:38.296]                   muffleCondition(cond)
[13:36:38.296]                 })
[13:36:38.296]             }))
[13:36:38.296]             future::FutureResult(value = ...future.value$value, 
[13:36:38.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.296]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.296]                     ...future.globalenv.names))
[13:36:38.296]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.296]         }, condition = base::local({
[13:36:38.296]             c <- base::c
[13:36:38.296]             inherits <- base::inherits
[13:36:38.296]             invokeRestart <- base::invokeRestart
[13:36:38.296]             length <- base::length
[13:36:38.296]             list <- base::list
[13:36:38.296]             seq.int <- base::seq.int
[13:36:38.296]             signalCondition <- base::signalCondition
[13:36:38.296]             sys.calls <- base::sys.calls
[13:36:38.296]             `[[` <- base::`[[`
[13:36:38.296]             `+` <- base::`+`
[13:36:38.296]             `<<-` <- base::`<<-`
[13:36:38.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.296]                   3L)]
[13:36:38.296]             }
[13:36:38.296]             function(cond) {
[13:36:38.296]                 is_error <- inherits(cond, "error")
[13:36:38.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.296]                   NULL)
[13:36:38.296]                 if (is_error) {
[13:36:38.296]                   sessionInformation <- function() {
[13:36:38.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.296]                       search = base::search(), system = base::Sys.info())
[13:36:38.296]                   }
[13:36:38.296]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.296]                     cond$call), session = sessionInformation(), 
[13:36:38.296]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.296]                   signalCondition(cond)
[13:36:38.296]                 }
[13:36:38.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.296]                 "immediateCondition"))) {
[13:36:38.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.296]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.296]                   if (TRUE && !signal) {
[13:36:38.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.296]                     {
[13:36:38.296]                       inherits <- base::inherits
[13:36:38.296]                       invokeRestart <- base::invokeRestart
[13:36:38.296]                       is.null <- base::is.null
[13:36:38.296]                       muffled <- FALSE
[13:36:38.296]                       if (inherits(cond, "message")) {
[13:36:38.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.296]                         if (muffled) 
[13:36:38.296]                           invokeRestart("muffleMessage")
[13:36:38.296]                       }
[13:36:38.296]                       else if (inherits(cond, "warning")) {
[13:36:38.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.296]                         if (muffled) 
[13:36:38.296]                           invokeRestart("muffleWarning")
[13:36:38.296]                       }
[13:36:38.296]                       else if (inherits(cond, "condition")) {
[13:36:38.296]                         if (!is.null(pattern)) {
[13:36:38.296]                           computeRestarts <- base::computeRestarts
[13:36:38.296]                           grepl <- base::grepl
[13:36:38.296]                           restarts <- computeRestarts(cond)
[13:36:38.296]                           for (restart in restarts) {
[13:36:38.296]                             name <- restart$name
[13:36:38.296]                             if (is.null(name)) 
[13:36:38.296]                               next
[13:36:38.296]                             if (!grepl(pattern, name)) 
[13:36:38.296]                               next
[13:36:38.296]                             invokeRestart(restart)
[13:36:38.296]                             muffled <- TRUE
[13:36:38.296]                             break
[13:36:38.296]                           }
[13:36:38.296]                         }
[13:36:38.296]                       }
[13:36:38.296]                       invisible(muffled)
[13:36:38.296]                     }
[13:36:38.296]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.296]                   }
[13:36:38.296]                 }
[13:36:38.296]                 else {
[13:36:38.296]                   if (TRUE) {
[13:36:38.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.296]                     {
[13:36:38.296]                       inherits <- base::inherits
[13:36:38.296]                       invokeRestart <- base::invokeRestart
[13:36:38.296]                       is.null <- base::is.null
[13:36:38.296]                       muffled <- FALSE
[13:36:38.296]                       if (inherits(cond, "message")) {
[13:36:38.296]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.296]                         if (muffled) 
[13:36:38.296]                           invokeRestart("muffleMessage")
[13:36:38.296]                       }
[13:36:38.296]                       else if (inherits(cond, "warning")) {
[13:36:38.296]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.296]                         if (muffled) 
[13:36:38.296]                           invokeRestart("muffleWarning")
[13:36:38.296]                       }
[13:36:38.296]                       else if (inherits(cond, "condition")) {
[13:36:38.296]                         if (!is.null(pattern)) {
[13:36:38.296]                           computeRestarts <- base::computeRestarts
[13:36:38.296]                           grepl <- base::grepl
[13:36:38.296]                           restarts <- computeRestarts(cond)
[13:36:38.296]                           for (restart in restarts) {
[13:36:38.296]                             name <- restart$name
[13:36:38.296]                             if (is.null(name)) 
[13:36:38.296]                               next
[13:36:38.296]                             if (!grepl(pattern, name)) 
[13:36:38.296]                               next
[13:36:38.296]                             invokeRestart(restart)
[13:36:38.296]                             muffled <- TRUE
[13:36:38.296]                             break
[13:36:38.296]                           }
[13:36:38.296]                         }
[13:36:38.296]                       }
[13:36:38.296]                       invisible(muffled)
[13:36:38.296]                     }
[13:36:38.296]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.296]                   }
[13:36:38.296]                 }
[13:36:38.296]             }
[13:36:38.296]         }))
[13:36:38.296]     }, error = function(ex) {
[13:36:38.296]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.296]                 ...future.rng), started = ...future.startTime, 
[13:36:38.296]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.296]             version = "1.8"), class = "FutureResult")
[13:36:38.296]     }, finally = {
[13:36:38.296]         if (!identical(...future.workdir, getwd())) 
[13:36:38.296]             setwd(...future.workdir)
[13:36:38.296]         {
[13:36:38.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.296]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.296]             }
[13:36:38.296]             base::options(...future.oldOptions)
[13:36:38.296]             if (.Platform$OS.type == "windows") {
[13:36:38.296]                 old_names <- names(...future.oldEnvVars)
[13:36:38.296]                 envs <- base::Sys.getenv()
[13:36:38.296]                 names <- names(envs)
[13:36:38.296]                 common <- intersect(names, old_names)
[13:36:38.296]                 added <- setdiff(names, old_names)
[13:36:38.296]                 removed <- setdiff(old_names, names)
[13:36:38.296]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.296]                   envs[common]]
[13:36:38.296]                 NAMES <- toupper(changed)
[13:36:38.296]                 args <- list()
[13:36:38.296]                 for (kk in seq_along(NAMES)) {
[13:36:38.296]                   name <- changed[[kk]]
[13:36:38.296]                   NAME <- NAMES[[kk]]
[13:36:38.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.296]                     next
[13:36:38.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.296]                 }
[13:36:38.296]                 NAMES <- toupper(added)
[13:36:38.296]                 for (kk in seq_along(NAMES)) {
[13:36:38.296]                   name <- added[[kk]]
[13:36:38.296]                   NAME <- NAMES[[kk]]
[13:36:38.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.296]                     next
[13:36:38.296]                   args[[name]] <- ""
[13:36:38.296]                 }
[13:36:38.296]                 NAMES <- toupper(removed)
[13:36:38.296]                 for (kk in seq_along(NAMES)) {
[13:36:38.296]                   name <- removed[[kk]]
[13:36:38.296]                   NAME <- NAMES[[kk]]
[13:36:38.296]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.296]                     next
[13:36:38.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.296]                 }
[13:36:38.296]                 if (length(args) > 0) 
[13:36:38.296]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.296]             }
[13:36:38.296]             else {
[13:36:38.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.296]             }
[13:36:38.296]             {
[13:36:38.296]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.296]                   0L) {
[13:36:38.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.296]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.296]                   base::options(opts)
[13:36:38.296]                 }
[13:36:38.296]                 {
[13:36:38.296]                   {
[13:36:38.296]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.296]                     NULL
[13:36:38.296]                   }
[13:36:38.296]                   options(future.plan = NULL)
[13:36:38.296]                   if (is.na(NA_character_)) 
[13:36:38.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.296]                     .init = FALSE)
[13:36:38.296]                 }
[13:36:38.296]             }
[13:36:38.296]         }
[13:36:38.296]     })
[13:36:38.296]     if (TRUE) {
[13:36:38.296]         base::sink(type = "output", split = FALSE)
[13:36:38.296]         if (TRUE) {
[13:36:38.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.296]         }
[13:36:38.296]         else {
[13:36:38.296]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.296]         }
[13:36:38.296]         base::close(...future.stdout)
[13:36:38.296]         ...future.stdout <- NULL
[13:36:38.296]     }
[13:36:38.296]     ...future.result$conditions <- ...future.conditions
[13:36:38.296]     ...future.result$finished <- base::Sys.time()
[13:36:38.296]     ...future.result
[13:36:38.296] }
[13:36:38.367] MultisessionFuture started
[13:36:38.368] result() for ClusterFuture ...
[13:36:38.368] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.368] - Validating connection of MultisessionFuture
[13:36:38.402] - received message: FutureResult
[13:36:38.402] - Received FutureResult
[13:36:38.402] - Erased future from FutureRegistry
[13:36:38.403] result() for ClusterFuture ...
[13:36:38.403] - result already collected: FutureResult
[13:36:38.403] result() for ClusterFuture ... done
[13:36:38.403] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.403] result() for ClusterFuture ... done
[13:36:38.403] result() for ClusterFuture ...
[13:36:38.403] - result already collected: FutureResult
[13:36:38.404] result() for ClusterFuture ... done
[13:36:38.404] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:36:38.408] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:36:38.408] getGlobalsAndPackages() ...
[13:36:38.408] Searching for globals...
[13:36:38.409] 
[13:36:38.409] Searching for globals ... DONE
[13:36:38.409] - globals: [0] <none>
[13:36:38.409] getGlobalsAndPackages() ... DONE
[13:36:38.410] run() for ‘Future’ ...
[13:36:38.410] - state: ‘created’
[13:36:38.410] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.424]   - Field: ‘node’
[13:36:38.425]   - Field: ‘label’
[13:36:38.425]   - Field: ‘local’
[13:36:38.425]   - Field: ‘owner’
[13:36:38.425]   - Field: ‘envir’
[13:36:38.428]   - Field: ‘workers’
[13:36:38.428]   - Field: ‘packages’
[13:36:38.428]   - Field: ‘gc’
[13:36:38.428]   - Field: ‘conditions’
[13:36:38.428]   - Field: ‘persistent’
[13:36:38.428]   - Field: ‘expr’
[13:36:38.429]   - Field: ‘uuid’
[13:36:38.429]   - Field: ‘seed’
[13:36:38.429]   - Field: ‘version’
[13:36:38.429]   - Field: ‘result’
[13:36:38.429]   - Field: ‘asynchronous’
[13:36:38.429]   - Field: ‘calls’
[13:36:38.429]   - Field: ‘globals’
[13:36:38.429]   - Field: ‘stdout’
[13:36:38.429]   - Field: ‘earlySignal’
[13:36:38.429]   - Field: ‘lazy’
[13:36:38.429]   - Field: ‘state’
[13:36:38.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.430] - Launch lazy future ...
[13:36:38.430] Packages needed by the future expression (n = 0): <none>
[13:36:38.430] Packages needed by future strategies (n = 0): <none>
[13:36:38.431] {
[13:36:38.431]     {
[13:36:38.431]         {
[13:36:38.431]             ...future.startTime <- base::Sys.time()
[13:36:38.431]             {
[13:36:38.431]                 {
[13:36:38.431]                   {
[13:36:38.431]                     {
[13:36:38.431]                       base::local({
[13:36:38.431]                         has_future <- base::requireNamespace("future", 
[13:36:38.431]                           quietly = TRUE)
[13:36:38.431]                         if (has_future) {
[13:36:38.431]                           ns <- base::getNamespace("future")
[13:36:38.431]                           version <- ns[[".package"]][["version"]]
[13:36:38.431]                           if (is.null(version)) 
[13:36:38.431]                             version <- utils::packageVersion("future")
[13:36:38.431]                         }
[13:36:38.431]                         else {
[13:36:38.431]                           version <- NULL
[13:36:38.431]                         }
[13:36:38.431]                         if (!has_future || version < "1.8.0") {
[13:36:38.431]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.431]                             "", base::R.version$version.string), 
[13:36:38.431]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.431]                               "release", "version")], collapse = " "), 
[13:36:38.431]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.431]                             info)
[13:36:38.431]                           info <- base::paste(info, collapse = "; ")
[13:36:38.431]                           if (!has_future) {
[13:36:38.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.431]                               info)
[13:36:38.431]                           }
[13:36:38.431]                           else {
[13:36:38.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.431]                               info, version)
[13:36:38.431]                           }
[13:36:38.431]                           base::stop(msg)
[13:36:38.431]                         }
[13:36:38.431]                       })
[13:36:38.431]                     }
[13:36:38.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.431]                     base::options(mc.cores = 1L)
[13:36:38.431]                   }
[13:36:38.431]                   ...future.strategy.old <- future::plan("list")
[13:36:38.431]                   options(future.plan = NULL)
[13:36:38.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.431]                 }
[13:36:38.431]                 ...future.workdir <- getwd()
[13:36:38.431]             }
[13:36:38.431]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.431]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.431]         }
[13:36:38.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.431]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.431]             base::names(...future.oldOptions))
[13:36:38.431]     }
[13:36:38.431]     if (FALSE) {
[13:36:38.431]     }
[13:36:38.431]     else {
[13:36:38.431]         if (TRUE) {
[13:36:38.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.431]                 open = "w")
[13:36:38.431]         }
[13:36:38.431]         else {
[13:36:38.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.431]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.431]         }
[13:36:38.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.431]             base::sink(type = "output", split = FALSE)
[13:36:38.431]             base::close(...future.stdout)
[13:36:38.431]         }, add = TRUE)
[13:36:38.431]     }
[13:36:38.431]     ...future.frame <- base::sys.nframe()
[13:36:38.431]     ...future.conditions <- base::list()
[13:36:38.431]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.431]     if (FALSE) {
[13:36:38.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.431]     }
[13:36:38.431]     ...future.result <- base::tryCatch({
[13:36:38.431]         base::withCallingHandlers({
[13:36:38.431]             ...future.value <- base::withVisible(base::local({
[13:36:38.431]                 ...future.makeSendCondition <- base::local({
[13:36:38.431]                   sendCondition <- NULL
[13:36:38.431]                   function(frame = 1L) {
[13:36:38.431]                     if (is.function(sendCondition)) 
[13:36:38.431]                       return(sendCondition)
[13:36:38.431]                     ns <- getNamespace("parallel")
[13:36:38.431]                     if (exists("sendData", mode = "function", 
[13:36:38.431]                       envir = ns)) {
[13:36:38.431]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.431]                         envir = ns)
[13:36:38.431]                       envir <- sys.frame(frame)
[13:36:38.431]                       master <- NULL
[13:36:38.431]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.431]                         !identical(envir, emptyenv())) {
[13:36:38.431]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.431]                           inherits = FALSE)) {
[13:36:38.431]                           master <- get("master", mode = "list", 
[13:36:38.431]                             envir = envir, inherits = FALSE)
[13:36:38.431]                           if (inherits(master, c("SOCKnode", 
[13:36:38.431]                             "SOCK0node"))) {
[13:36:38.431]                             sendCondition <<- function(cond) {
[13:36:38.431]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.431]                                 success = TRUE)
[13:36:38.431]                               parallel_sendData(master, data)
[13:36:38.431]                             }
[13:36:38.431]                             return(sendCondition)
[13:36:38.431]                           }
[13:36:38.431]                         }
[13:36:38.431]                         frame <- frame + 1L
[13:36:38.431]                         envir <- sys.frame(frame)
[13:36:38.431]                       }
[13:36:38.431]                     }
[13:36:38.431]                     sendCondition <<- function(cond) NULL
[13:36:38.431]                   }
[13:36:38.431]                 })
[13:36:38.431]                 withCallingHandlers({
[13:36:38.431]                   2
[13:36:38.431]                 }, immediateCondition = function(cond) {
[13:36:38.431]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.431]                   sendCondition(cond)
[13:36:38.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.431]                   {
[13:36:38.431]                     inherits <- base::inherits
[13:36:38.431]                     invokeRestart <- base::invokeRestart
[13:36:38.431]                     is.null <- base::is.null
[13:36:38.431]                     muffled <- FALSE
[13:36:38.431]                     if (inherits(cond, "message")) {
[13:36:38.431]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.431]                       if (muffled) 
[13:36:38.431]                         invokeRestart("muffleMessage")
[13:36:38.431]                     }
[13:36:38.431]                     else if (inherits(cond, "warning")) {
[13:36:38.431]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.431]                       if (muffled) 
[13:36:38.431]                         invokeRestart("muffleWarning")
[13:36:38.431]                     }
[13:36:38.431]                     else if (inherits(cond, "condition")) {
[13:36:38.431]                       if (!is.null(pattern)) {
[13:36:38.431]                         computeRestarts <- base::computeRestarts
[13:36:38.431]                         grepl <- base::grepl
[13:36:38.431]                         restarts <- computeRestarts(cond)
[13:36:38.431]                         for (restart in restarts) {
[13:36:38.431]                           name <- restart$name
[13:36:38.431]                           if (is.null(name)) 
[13:36:38.431]                             next
[13:36:38.431]                           if (!grepl(pattern, name)) 
[13:36:38.431]                             next
[13:36:38.431]                           invokeRestart(restart)
[13:36:38.431]                           muffled <- TRUE
[13:36:38.431]                           break
[13:36:38.431]                         }
[13:36:38.431]                       }
[13:36:38.431]                     }
[13:36:38.431]                     invisible(muffled)
[13:36:38.431]                   }
[13:36:38.431]                   muffleCondition(cond)
[13:36:38.431]                 })
[13:36:38.431]             }))
[13:36:38.431]             future::FutureResult(value = ...future.value$value, 
[13:36:38.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.431]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.431]                     ...future.globalenv.names))
[13:36:38.431]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.431]         }, condition = base::local({
[13:36:38.431]             c <- base::c
[13:36:38.431]             inherits <- base::inherits
[13:36:38.431]             invokeRestart <- base::invokeRestart
[13:36:38.431]             length <- base::length
[13:36:38.431]             list <- base::list
[13:36:38.431]             seq.int <- base::seq.int
[13:36:38.431]             signalCondition <- base::signalCondition
[13:36:38.431]             sys.calls <- base::sys.calls
[13:36:38.431]             `[[` <- base::`[[`
[13:36:38.431]             `+` <- base::`+`
[13:36:38.431]             `<<-` <- base::`<<-`
[13:36:38.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.431]                   3L)]
[13:36:38.431]             }
[13:36:38.431]             function(cond) {
[13:36:38.431]                 is_error <- inherits(cond, "error")
[13:36:38.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.431]                   NULL)
[13:36:38.431]                 if (is_error) {
[13:36:38.431]                   sessionInformation <- function() {
[13:36:38.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.431]                       search = base::search(), system = base::Sys.info())
[13:36:38.431]                   }
[13:36:38.431]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.431]                     cond$call), session = sessionInformation(), 
[13:36:38.431]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.431]                   signalCondition(cond)
[13:36:38.431]                 }
[13:36:38.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.431]                 "immediateCondition"))) {
[13:36:38.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.431]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.431]                   if (TRUE && !signal) {
[13:36:38.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.431]                     {
[13:36:38.431]                       inherits <- base::inherits
[13:36:38.431]                       invokeRestart <- base::invokeRestart
[13:36:38.431]                       is.null <- base::is.null
[13:36:38.431]                       muffled <- FALSE
[13:36:38.431]                       if (inherits(cond, "message")) {
[13:36:38.431]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.431]                         if (muffled) 
[13:36:38.431]                           invokeRestart("muffleMessage")
[13:36:38.431]                       }
[13:36:38.431]                       else if (inherits(cond, "warning")) {
[13:36:38.431]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.431]                         if (muffled) 
[13:36:38.431]                           invokeRestart("muffleWarning")
[13:36:38.431]                       }
[13:36:38.431]                       else if (inherits(cond, "condition")) {
[13:36:38.431]                         if (!is.null(pattern)) {
[13:36:38.431]                           computeRestarts <- base::computeRestarts
[13:36:38.431]                           grepl <- base::grepl
[13:36:38.431]                           restarts <- computeRestarts(cond)
[13:36:38.431]                           for (restart in restarts) {
[13:36:38.431]                             name <- restart$name
[13:36:38.431]                             if (is.null(name)) 
[13:36:38.431]                               next
[13:36:38.431]                             if (!grepl(pattern, name)) 
[13:36:38.431]                               next
[13:36:38.431]                             invokeRestart(restart)
[13:36:38.431]                             muffled <- TRUE
[13:36:38.431]                             break
[13:36:38.431]                           }
[13:36:38.431]                         }
[13:36:38.431]                       }
[13:36:38.431]                       invisible(muffled)
[13:36:38.431]                     }
[13:36:38.431]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.431]                   }
[13:36:38.431]                 }
[13:36:38.431]                 else {
[13:36:38.431]                   if (TRUE) {
[13:36:38.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.431]                     {
[13:36:38.431]                       inherits <- base::inherits
[13:36:38.431]                       invokeRestart <- base::invokeRestart
[13:36:38.431]                       is.null <- base::is.null
[13:36:38.431]                       muffled <- FALSE
[13:36:38.431]                       if (inherits(cond, "message")) {
[13:36:38.431]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.431]                         if (muffled) 
[13:36:38.431]                           invokeRestart("muffleMessage")
[13:36:38.431]                       }
[13:36:38.431]                       else if (inherits(cond, "warning")) {
[13:36:38.431]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.431]                         if (muffled) 
[13:36:38.431]                           invokeRestart("muffleWarning")
[13:36:38.431]                       }
[13:36:38.431]                       else if (inherits(cond, "condition")) {
[13:36:38.431]                         if (!is.null(pattern)) {
[13:36:38.431]                           computeRestarts <- base::computeRestarts
[13:36:38.431]                           grepl <- base::grepl
[13:36:38.431]                           restarts <- computeRestarts(cond)
[13:36:38.431]                           for (restart in restarts) {
[13:36:38.431]                             name <- restart$name
[13:36:38.431]                             if (is.null(name)) 
[13:36:38.431]                               next
[13:36:38.431]                             if (!grepl(pattern, name)) 
[13:36:38.431]                               next
[13:36:38.431]                             invokeRestart(restart)
[13:36:38.431]                             muffled <- TRUE
[13:36:38.431]                             break
[13:36:38.431]                           }
[13:36:38.431]                         }
[13:36:38.431]                       }
[13:36:38.431]                       invisible(muffled)
[13:36:38.431]                     }
[13:36:38.431]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.431]                   }
[13:36:38.431]                 }
[13:36:38.431]             }
[13:36:38.431]         }))
[13:36:38.431]     }, error = function(ex) {
[13:36:38.431]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.431]                 ...future.rng), started = ...future.startTime, 
[13:36:38.431]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.431]             version = "1.8"), class = "FutureResult")
[13:36:38.431]     }, finally = {
[13:36:38.431]         if (!identical(...future.workdir, getwd())) 
[13:36:38.431]             setwd(...future.workdir)
[13:36:38.431]         {
[13:36:38.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.431]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.431]             }
[13:36:38.431]             base::options(...future.oldOptions)
[13:36:38.431]             if (.Platform$OS.type == "windows") {
[13:36:38.431]                 old_names <- names(...future.oldEnvVars)
[13:36:38.431]                 envs <- base::Sys.getenv()
[13:36:38.431]                 names <- names(envs)
[13:36:38.431]                 common <- intersect(names, old_names)
[13:36:38.431]                 added <- setdiff(names, old_names)
[13:36:38.431]                 removed <- setdiff(old_names, names)
[13:36:38.431]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.431]                   envs[common]]
[13:36:38.431]                 NAMES <- toupper(changed)
[13:36:38.431]                 args <- list()
[13:36:38.431]                 for (kk in seq_along(NAMES)) {
[13:36:38.431]                   name <- changed[[kk]]
[13:36:38.431]                   NAME <- NAMES[[kk]]
[13:36:38.431]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.431]                     next
[13:36:38.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.431]                 }
[13:36:38.431]                 NAMES <- toupper(added)
[13:36:38.431]                 for (kk in seq_along(NAMES)) {
[13:36:38.431]                   name <- added[[kk]]
[13:36:38.431]                   NAME <- NAMES[[kk]]
[13:36:38.431]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.431]                     next
[13:36:38.431]                   args[[name]] <- ""
[13:36:38.431]                 }
[13:36:38.431]                 NAMES <- toupper(removed)
[13:36:38.431]                 for (kk in seq_along(NAMES)) {
[13:36:38.431]                   name <- removed[[kk]]
[13:36:38.431]                   NAME <- NAMES[[kk]]
[13:36:38.431]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.431]                     next
[13:36:38.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.431]                 }
[13:36:38.431]                 if (length(args) > 0) 
[13:36:38.431]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.431]             }
[13:36:38.431]             else {
[13:36:38.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.431]             }
[13:36:38.431]             {
[13:36:38.431]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.431]                   0L) {
[13:36:38.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.431]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.431]                   base::options(opts)
[13:36:38.431]                 }
[13:36:38.431]                 {
[13:36:38.431]                   {
[13:36:38.431]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.431]                     NULL
[13:36:38.431]                   }
[13:36:38.431]                   options(future.plan = NULL)
[13:36:38.431]                   if (is.na(NA_character_)) 
[13:36:38.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.431]                     .init = FALSE)
[13:36:38.431]                 }
[13:36:38.431]             }
[13:36:38.431]         }
[13:36:38.431]     })
[13:36:38.431]     if (TRUE) {
[13:36:38.431]         base::sink(type = "output", split = FALSE)
[13:36:38.431]         if (TRUE) {
[13:36:38.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.431]         }
[13:36:38.431]         else {
[13:36:38.431]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.431]         }
[13:36:38.431]         base::close(...future.stdout)
[13:36:38.431]         ...future.stdout <- NULL
[13:36:38.431]     }
[13:36:38.431]     ...future.result$conditions <- ...future.conditions
[13:36:38.431]     ...future.result$finished <- base::Sys.time()
[13:36:38.431]     ...future.result
[13:36:38.431] }
[13:36:38.433] MultisessionFuture started
[13:36:38.434] - Launch lazy future ... done
[13:36:38.434] run() for ‘MultisessionFuture’ ... done
[13:36:38.434] getGlobalsAndPackages() ...
[13:36:38.434] Searching for globals...
[13:36:38.434] 
[13:36:38.434] Searching for globals ... DONE
[13:36:38.434] - globals: [0] <none>
[13:36:38.435] getGlobalsAndPackages() ... DONE
[13:36:38.435] run() for ‘Future’ ...
[13:36:38.435] - state: ‘created’
[13:36:38.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.449]   - Field: ‘node’
[13:36:38.449]   - Field: ‘label’
[13:36:38.449]   - Field: ‘local’
[13:36:38.449]   - Field: ‘owner’
[13:36:38.449]   - Field: ‘envir’
[13:36:38.449]   - Field: ‘workers’
[13:36:38.449]   - Field: ‘packages’
[13:36:38.449]   - Field: ‘gc’
[13:36:38.449]   - Field: ‘conditions’
[13:36:38.449]   - Field: ‘persistent’
[13:36:38.450]   - Field: ‘expr’
[13:36:38.450]   - Field: ‘uuid’
[13:36:38.450]   - Field: ‘seed’
[13:36:38.450]   - Field: ‘version’
[13:36:38.450]   - Field: ‘result’
[13:36:38.450]   - Field: ‘asynchronous’
[13:36:38.450]   - Field: ‘calls’
[13:36:38.450]   - Field: ‘globals’
[13:36:38.450]   - Field: ‘stdout’
[13:36:38.450]   - Field: ‘earlySignal’
[13:36:38.450]   - Field: ‘lazy’
[13:36:38.451]   - Field: ‘state’
[13:36:38.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.451] - Launch lazy future ...
[13:36:38.451] Packages needed by the future expression (n = 0): <none>
[13:36:38.451] Packages needed by future strategies (n = 0): <none>
[13:36:38.452] {
[13:36:38.452]     {
[13:36:38.452]         {
[13:36:38.452]             ...future.startTime <- base::Sys.time()
[13:36:38.452]             {
[13:36:38.452]                 {
[13:36:38.452]                   {
[13:36:38.452]                     {
[13:36:38.452]                       base::local({
[13:36:38.452]                         has_future <- base::requireNamespace("future", 
[13:36:38.452]                           quietly = TRUE)
[13:36:38.452]                         if (has_future) {
[13:36:38.452]                           ns <- base::getNamespace("future")
[13:36:38.452]                           version <- ns[[".package"]][["version"]]
[13:36:38.452]                           if (is.null(version)) 
[13:36:38.452]                             version <- utils::packageVersion("future")
[13:36:38.452]                         }
[13:36:38.452]                         else {
[13:36:38.452]                           version <- NULL
[13:36:38.452]                         }
[13:36:38.452]                         if (!has_future || version < "1.8.0") {
[13:36:38.452]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.452]                             "", base::R.version$version.string), 
[13:36:38.452]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.452]                               "release", "version")], collapse = " "), 
[13:36:38.452]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.452]                             info)
[13:36:38.452]                           info <- base::paste(info, collapse = "; ")
[13:36:38.452]                           if (!has_future) {
[13:36:38.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.452]                               info)
[13:36:38.452]                           }
[13:36:38.452]                           else {
[13:36:38.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.452]                               info, version)
[13:36:38.452]                           }
[13:36:38.452]                           base::stop(msg)
[13:36:38.452]                         }
[13:36:38.452]                       })
[13:36:38.452]                     }
[13:36:38.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.452]                     base::options(mc.cores = 1L)
[13:36:38.452]                   }
[13:36:38.452]                   ...future.strategy.old <- future::plan("list")
[13:36:38.452]                   options(future.plan = NULL)
[13:36:38.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.452]                 }
[13:36:38.452]                 ...future.workdir <- getwd()
[13:36:38.452]             }
[13:36:38.452]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.452]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.452]         }
[13:36:38.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.452]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.452]             base::names(...future.oldOptions))
[13:36:38.452]     }
[13:36:38.452]     if (FALSE) {
[13:36:38.452]     }
[13:36:38.452]     else {
[13:36:38.452]         if (TRUE) {
[13:36:38.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.452]                 open = "w")
[13:36:38.452]         }
[13:36:38.452]         else {
[13:36:38.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.452]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.452]         }
[13:36:38.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.452]             base::sink(type = "output", split = FALSE)
[13:36:38.452]             base::close(...future.stdout)
[13:36:38.452]         }, add = TRUE)
[13:36:38.452]     }
[13:36:38.452]     ...future.frame <- base::sys.nframe()
[13:36:38.452]     ...future.conditions <- base::list()
[13:36:38.452]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.452]     if (FALSE) {
[13:36:38.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.452]     }
[13:36:38.452]     ...future.result <- base::tryCatch({
[13:36:38.452]         base::withCallingHandlers({
[13:36:38.452]             ...future.value <- base::withVisible(base::local({
[13:36:38.452]                 ...future.makeSendCondition <- base::local({
[13:36:38.452]                   sendCondition <- NULL
[13:36:38.452]                   function(frame = 1L) {
[13:36:38.452]                     if (is.function(sendCondition)) 
[13:36:38.452]                       return(sendCondition)
[13:36:38.452]                     ns <- getNamespace("parallel")
[13:36:38.452]                     if (exists("sendData", mode = "function", 
[13:36:38.452]                       envir = ns)) {
[13:36:38.452]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.452]                         envir = ns)
[13:36:38.452]                       envir <- sys.frame(frame)
[13:36:38.452]                       master <- NULL
[13:36:38.452]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.452]                         !identical(envir, emptyenv())) {
[13:36:38.452]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.452]                           inherits = FALSE)) {
[13:36:38.452]                           master <- get("master", mode = "list", 
[13:36:38.452]                             envir = envir, inherits = FALSE)
[13:36:38.452]                           if (inherits(master, c("SOCKnode", 
[13:36:38.452]                             "SOCK0node"))) {
[13:36:38.452]                             sendCondition <<- function(cond) {
[13:36:38.452]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.452]                                 success = TRUE)
[13:36:38.452]                               parallel_sendData(master, data)
[13:36:38.452]                             }
[13:36:38.452]                             return(sendCondition)
[13:36:38.452]                           }
[13:36:38.452]                         }
[13:36:38.452]                         frame <- frame + 1L
[13:36:38.452]                         envir <- sys.frame(frame)
[13:36:38.452]                       }
[13:36:38.452]                     }
[13:36:38.452]                     sendCondition <<- function(cond) NULL
[13:36:38.452]                   }
[13:36:38.452]                 })
[13:36:38.452]                 withCallingHandlers({
[13:36:38.452]                   NULL
[13:36:38.452]                 }, immediateCondition = function(cond) {
[13:36:38.452]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.452]                   sendCondition(cond)
[13:36:38.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.452]                   {
[13:36:38.452]                     inherits <- base::inherits
[13:36:38.452]                     invokeRestart <- base::invokeRestart
[13:36:38.452]                     is.null <- base::is.null
[13:36:38.452]                     muffled <- FALSE
[13:36:38.452]                     if (inherits(cond, "message")) {
[13:36:38.452]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.452]                       if (muffled) 
[13:36:38.452]                         invokeRestart("muffleMessage")
[13:36:38.452]                     }
[13:36:38.452]                     else if (inherits(cond, "warning")) {
[13:36:38.452]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.452]                       if (muffled) 
[13:36:38.452]                         invokeRestart("muffleWarning")
[13:36:38.452]                     }
[13:36:38.452]                     else if (inherits(cond, "condition")) {
[13:36:38.452]                       if (!is.null(pattern)) {
[13:36:38.452]                         computeRestarts <- base::computeRestarts
[13:36:38.452]                         grepl <- base::grepl
[13:36:38.452]                         restarts <- computeRestarts(cond)
[13:36:38.452]                         for (restart in restarts) {
[13:36:38.452]                           name <- restart$name
[13:36:38.452]                           if (is.null(name)) 
[13:36:38.452]                             next
[13:36:38.452]                           if (!grepl(pattern, name)) 
[13:36:38.452]                             next
[13:36:38.452]                           invokeRestart(restart)
[13:36:38.452]                           muffled <- TRUE
[13:36:38.452]                           break
[13:36:38.452]                         }
[13:36:38.452]                       }
[13:36:38.452]                     }
[13:36:38.452]                     invisible(muffled)
[13:36:38.452]                   }
[13:36:38.452]                   muffleCondition(cond)
[13:36:38.452]                 })
[13:36:38.452]             }))
[13:36:38.452]             future::FutureResult(value = ...future.value$value, 
[13:36:38.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.452]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.452]                     ...future.globalenv.names))
[13:36:38.452]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.452]         }, condition = base::local({
[13:36:38.452]             c <- base::c
[13:36:38.452]             inherits <- base::inherits
[13:36:38.452]             invokeRestart <- base::invokeRestart
[13:36:38.452]             length <- base::length
[13:36:38.452]             list <- base::list
[13:36:38.452]             seq.int <- base::seq.int
[13:36:38.452]             signalCondition <- base::signalCondition
[13:36:38.452]             sys.calls <- base::sys.calls
[13:36:38.452]             `[[` <- base::`[[`
[13:36:38.452]             `+` <- base::`+`
[13:36:38.452]             `<<-` <- base::`<<-`
[13:36:38.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.452]                   3L)]
[13:36:38.452]             }
[13:36:38.452]             function(cond) {
[13:36:38.452]                 is_error <- inherits(cond, "error")
[13:36:38.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.452]                   NULL)
[13:36:38.452]                 if (is_error) {
[13:36:38.452]                   sessionInformation <- function() {
[13:36:38.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.452]                       search = base::search(), system = base::Sys.info())
[13:36:38.452]                   }
[13:36:38.452]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.452]                     cond$call), session = sessionInformation(), 
[13:36:38.452]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.452]                   signalCondition(cond)
[13:36:38.452]                 }
[13:36:38.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.452]                 "immediateCondition"))) {
[13:36:38.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.452]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.452]                   if (TRUE && !signal) {
[13:36:38.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.452]                     {
[13:36:38.452]                       inherits <- base::inherits
[13:36:38.452]                       invokeRestart <- base::invokeRestart
[13:36:38.452]                       is.null <- base::is.null
[13:36:38.452]                       muffled <- FALSE
[13:36:38.452]                       if (inherits(cond, "message")) {
[13:36:38.452]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.452]                         if (muffled) 
[13:36:38.452]                           invokeRestart("muffleMessage")
[13:36:38.452]                       }
[13:36:38.452]                       else if (inherits(cond, "warning")) {
[13:36:38.452]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.452]                         if (muffled) 
[13:36:38.452]                           invokeRestart("muffleWarning")
[13:36:38.452]                       }
[13:36:38.452]                       else if (inherits(cond, "condition")) {
[13:36:38.452]                         if (!is.null(pattern)) {
[13:36:38.452]                           computeRestarts <- base::computeRestarts
[13:36:38.452]                           grepl <- base::grepl
[13:36:38.452]                           restarts <- computeRestarts(cond)
[13:36:38.452]                           for (restart in restarts) {
[13:36:38.452]                             name <- restart$name
[13:36:38.452]                             if (is.null(name)) 
[13:36:38.452]                               next
[13:36:38.452]                             if (!grepl(pattern, name)) 
[13:36:38.452]                               next
[13:36:38.452]                             invokeRestart(restart)
[13:36:38.452]                             muffled <- TRUE
[13:36:38.452]                             break
[13:36:38.452]                           }
[13:36:38.452]                         }
[13:36:38.452]                       }
[13:36:38.452]                       invisible(muffled)
[13:36:38.452]                     }
[13:36:38.452]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.452]                   }
[13:36:38.452]                 }
[13:36:38.452]                 else {
[13:36:38.452]                   if (TRUE) {
[13:36:38.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.452]                     {
[13:36:38.452]                       inherits <- base::inherits
[13:36:38.452]                       invokeRestart <- base::invokeRestart
[13:36:38.452]                       is.null <- base::is.null
[13:36:38.452]                       muffled <- FALSE
[13:36:38.452]                       if (inherits(cond, "message")) {
[13:36:38.452]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.452]                         if (muffled) 
[13:36:38.452]                           invokeRestart("muffleMessage")
[13:36:38.452]                       }
[13:36:38.452]                       else if (inherits(cond, "warning")) {
[13:36:38.452]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.452]                         if (muffled) 
[13:36:38.452]                           invokeRestart("muffleWarning")
[13:36:38.452]                       }
[13:36:38.452]                       else if (inherits(cond, "condition")) {
[13:36:38.452]                         if (!is.null(pattern)) {
[13:36:38.452]                           computeRestarts <- base::computeRestarts
[13:36:38.452]                           grepl <- base::grepl
[13:36:38.452]                           restarts <- computeRestarts(cond)
[13:36:38.452]                           for (restart in restarts) {
[13:36:38.452]                             name <- restart$name
[13:36:38.452]                             if (is.null(name)) 
[13:36:38.452]                               next
[13:36:38.452]                             if (!grepl(pattern, name)) 
[13:36:38.452]                               next
[13:36:38.452]                             invokeRestart(restart)
[13:36:38.452]                             muffled <- TRUE
[13:36:38.452]                             break
[13:36:38.452]                           }
[13:36:38.452]                         }
[13:36:38.452]                       }
[13:36:38.452]                       invisible(muffled)
[13:36:38.452]                     }
[13:36:38.452]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.452]                   }
[13:36:38.452]                 }
[13:36:38.452]             }
[13:36:38.452]         }))
[13:36:38.452]     }, error = function(ex) {
[13:36:38.452]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.452]                 ...future.rng), started = ...future.startTime, 
[13:36:38.452]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.452]             version = "1.8"), class = "FutureResult")
[13:36:38.452]     }, finally = {
[13:36:38.452]         if (!identical(...future.workdir, getwd())) 
[13:36:38.452]             setwd(...future.workdir)
[13:36:38.452]         {
[13:36:38.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.452]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.452]             }
[13:36:38.452]             base::options(...future.oldOptions)
[13:36:38.452]             if (.Platform$OS.type == "windows") {
[13:36:38.452]                 old_names <- names(...future.oldEnvVars)
[13:36:38.452]                 envs <- base::Sys.getenv()
[13:36:38.452]                 names <- names(envs)
[13:36:38.452]                 common <- intersect(names, old_names)
[13:36:38.452]                 added <- setdiff(names, old_names)
[13:36:38.452]                 removed <- setdiff(old_names, names)
[13:36:38.452]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.452]                   envs[common]]
[13:36:38.452]                 NAMES <- toupper(changed)
[13:36:38.452]                 args <- list()
[13:36:38.452]                 for (kk in seq_along(NAMES)) {
[13:36:38.452]                   name <- changed[[kk]]
[13:36:38.452]                   NAME <- NAMES[[kk]]
[13:36:38.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.452]                     next
[13:36:38.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.452]                 }
[13:36:38.452]                 NAMES <- toupper(added)
[13:36:38.452]                 for (kk in seq_along(NAMES)) {
[13:36:38.452]                   name <- added[[kk]]
[13:36:38.452]                   NAME <- NAMES[[kk]]
[13:36:38.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.452]                     next
[13:36:38.452]                   args[[name]] <- ""
[13:36:38.452]                 }
[13:36:38.452]                 NAMES <- toupper(removed)
[13:36:38.452]                 for (kk in seq_along(NAMES)) {
[13:36:38.452]                   name <- removed[[kk]]
[13:36:38.452]                   NAME <- NAMES[[kk]]
[13:36:38.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.452]                     next
[13:36:38.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.452]                 }
[13:36:38.452]                 if (length(args) > 0) 
[13:36:38.452]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.452]             }
[13:36:38.452]             else {
[13:36:38.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.452]             }
[13:36:38.452]             {
[13:36:38.452]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.452]                   0L) {
[13:36:38.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.452]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.452]                   base::options(opts)
[13:36:38.452]                 }
[13:36:38.452]                 {
[13:36:38.452]                   {
[13:36:38.452]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.452]                     NULL
[13:36:38.452]                   }
[13:36:38.452]                   options(future.plan = NULL)
[13:36:38.452]                   if (is.na(NA_character_)) 
[13:36:38.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.452]                     .init = FALSE)
[13:36:38.452]                 }
[13:36:38.452]             }
[13:36:38.452]         }
[13:36:38.452]     })
[13:36:38.452]     if (TRUE) {
[13:36:38.452]         base::sink(type = "output", split = FALSE)
[13:36:38.452]         if (TRUE) {
[13:36:38.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.452]         }
[13:36:38.452]         else {
[13:36:38.452]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.452]         }
[13:36:38.452]         base::close(...future.stdout)
[13:36:38.452]         ...future.stdout <- NULL
[13:36:38.452]     }
[13:36:38.452]     ...future.result$conditions <- ...future.conditions
[13:36:38.452]     ...future.result$finished <- base::Sys.time()
[13:36:38.452]     ...future.result
[13:36:38.452] }
[13:36:38.505] MultisessionFuture started
[13:36:38.505] - Launch lazy future ... done
[13:36:38.505] run() for ‘MultisessionFuture’ ... done
[13:36:38.506] getGlobalsAndPackages() ...
[13:36:38.506] Searching for globals...
[13:36:38.507] - globals found: [1] ‘{’
[13:36:38.507] Searching for globals ... DONE
[13:36:38.507] Resolving globals: FALSE
[13:36:38.507] 
[13:36:38.507] 
[13:36:38.507] getGlobalsAndPackages() ... DONE
[13:36:38.508] run() for ‘Future’ ...
[13:36:38.508] - state: ‘created’
[13:36:38.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.522]   - Field: ‘node’
[13:36:38.522]   - Field: ‘label’
[13:36:38.522]   - Field: ‘local’
[13:36:38.523]   - Field: ‘owner’
[13:36:38.523]   - Field: ‘envir’
[13:36:38.523]   - Field: ‘workers’
[13:36:38.523]   - Field: ‘packages’
[13:36:38.523]   - Field: ‘gc’
[13:36:38.523]   - Field: ‘conditions’
[13:36:38.523]   - Field: ‘persistent’
[13:36:38.523]   - Field: ‘expr’
[13:36:38.523]   - Field: ‘uuid’
[13:36:38.523]   - Field: ‘seed’
[13:36:38.524]   - Field: ‘version’
[13:36:38.524]   - Field: ‘result’
[13:36:38.524]   - Field: ‘asynchronous’
[13:36:38.524]   - Field: ‘calls’
[13:36:38.524]   - Field: ‘globals’
[13:36:38.524]   - Field: ‘stdout’
[13:36:38.524]   - Field: ‘earlySignal’
[13:36:38.524]   - Field: ‘lazy’
[13:36:38.524]   - Field: ‘state’
[13:36:38.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.524] - Launch lazy future ...
[13:36:38.525] Packages needed by the future expression (n = 0): <none>
[13:36:38.525] Packages needed by future strategies (n = 0): <none>
[13:36:38.525] {
[13:36:38.525]     {
[13:36:38.525]         {
[13:36:38.525]             ...future.startTime <- base::Sys.time()
[13:36:38.525]             {
[13:36:38.525]                 {
[13:36:38.525]                   {
[13:36:38.525]                     {
[13:36:38.525]                       base::local({
[13:36:38.525]                         has_future <- base::requireNamespace("future", 
[13:36:38.525]                           quietly = TRUE)
[13:36:38.525]                         if (has_future) {
[13:36:38.525]                           ns <- base::getNamespace("future")
[13:36:38.525]                           version <- ns[[".package"]][["version"]]
[13:36:38.525]                           if (is.null(version)) 
[13:36:38.525]                             version <- utils::packageVersion("future")
[13:36:38.525]                         }
[13:36:38.525]                         else {
[13:36:38.525]                           version <- NULL
[13:36:38.525]                         }
[13:36:38.525]                         if (!has_future || version < "1.8.0") {
[13:36:38.525]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.525]                             "", base::R.version$version.string), 
[13:36:38.525]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.525]                               "release", "version")], collapse = " "), 
[13:36:38.525]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.525]                             info)
[13:36:38.525]                           info <- base::paste(info, collapse = "; ")
[13:36:38.525]                           if (!has_future) {
[13:36:38.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.525]                               info)
[13:36:38.525]                           }
[13:36:38.525]                           else {
[13:36:38.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.525]                               info, version)
[13:36:38.525]                           }
[13:36:38.525]                           base::stop(msg)
[13:36:38.525]                         }
[13:36:38.525]                       })
[13:36:38.525]                     }
[13:36:38.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.525]                     base::options(mc.cores = 1L)
[13:36:38.525]                   }
[13:36:38.525]                   ...future.strategy.old <- future::plan("list")
[13:36:38.525]                   options(future.plan = NULL)
[13:36:38.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.525]                 }
[13:36:38.525]                 ...future.workdir <- getwd()
[13:36:38.525]             }
[13:36:38.525]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.525]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.525]         }
[13:36:38.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.525]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.525]             base::names(...future.oldOptions))
[13:36:38.525]     }
[13:36:38.525]     if (FALSE) {
[13:36:38.525]     }
[13:36:38.525]     else {
[13:36:38.525]         if (TRUE) {
[13:36:38.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.525]                 open = "w")
[13:36:38.525]         }
[13:36:38.525]         else {
[13:36:38.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.525]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.525]         }
[13:36:38.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.525]             base::sink(type = "output", split = FALSE)
[13:36:38.525]             base::close(...future.stdout)
[13:36:38.525]         }, add = TRUE)
[13:36:38.525]     }
[13:36:38.525]     ...future.frame <- base::sys.nframe()
[13:36:38.525]     ...future.conditions <- base::list()
[13:36:38.525]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.525]     if (FALSE) {
[13:36:38.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.525]     }
[13:36:38.525]     ...future.result <- base::tryCatch({
[13:36:38.525]         base::withCallingHandlers({
[13:36:38.525]             ...future.value <- base::withVisible(base::local({
[13:36:38.525]                 ...future.makeSendCondition <- base::local({
[13:36:38.525]                   sendCondition <- NULL
[13:36:38.525]                   function(frame = 1L) {
[13:36:38.525]                     if (is.function(sendCondition)) 
[13:36:38.525]                       return(sendCondition)
[13:36:38.525]                     ns <- getNamespace("parallel")
[13:36:38.525]                     if (exists("sendData", mode = "function", 
[13:36:38.525]                       envir = ns)) {
[13:36:38.525]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.525]                         envir = ns)
[13:36:38.525]                       envir <- sys.frame(frame)
[13:36:38.525]                       master <- NULL
[13:36:38.525]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.525]                         !identical(envir, emptyenv())) {
[13:36:38.525]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.525]                           inherits = FALSE)) {
[13:36:38.525]                           master <- get("master", mode = "list", 
[13:36:38.525]                             envir = envir, inherits = FALSE)
[13:36:38.525]                           if (inherits(master, c("SOCKnode", 
[13:36:38.525]                             "SOCK0node"))) {
[13:36:38.525]                             sendCondition <<- function(cond) {
[13:36:38.525]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.525]                                 success = TRUE)
[13:36:38.525]                               parallel_sendData(master, data)
[13:36:38.525]                             }
[13:36:38.525]                             return(sendCondition)
[13:36:38.525]                           }
[13:36:38.525]                         }
[13:36:38.525]                         frame <- frame + 1L
[13:36:38.525]                         envir <- sys.frame(frame)
[13:36:38.525]                       }
[13:36:38.525]                     }
[13:36:38.525]                     sendCondition <<- function(cond) NULL
[13:36:38.525]                   }
[13:36:38.525]                 })
[13:36:38.525]                 withCallingHandlers({
[13:36:38.525]                   {
[13:36:38.525]                     4
[13:36:38.525]                   }
[13:36:38.525]                 }, immediateCondition = function(cond) {
[13:36:38.525]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.525]                   sendCondition(cond)
[13:36:38.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.525]                   {
[13:36:38.525]                     inherits <- base::inherits
[13:36:38.525]                     invokeRestart <- base::invokeRestart
[13:36:38.525]                     is.null <- base::is.null
[13:36:38.525]                     muffled <- FALSE
[13:36:38.525]                     if (inherits(cond, "message")) {
[13:36:38.525]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.525]                       if (muffled) 
[13:36:38.525]                         invokeRestart("muffleMessage")
[13:36:38.525]                     }
[13:36:38.525]                     else if (inherits(cond, "warning")) {
[13:36:38.525]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.525]                       if (muffled) 
[13:36:38.525]                         invokeRestart("muffleWarning")
[13:36:38.525]                     }
[13:36:38.525]                     else if (inherits(cond, "condition")) {
[13:36:38.525]                       if (!is.null(pattern)) {
[13:36:38.525]                         computeRestarts <- base::computeRestarts
[13:36:38.525]                         grepl <- base::grepl
[13:36:38.525]                         restarts <- computeRestarts(cond)
[13:36:38.525]                         for (restart in restarts) {
[13:36:38.525]                           name <- restart$name
[13:36:38.525]                           if (is.null(name)) 
[13:36:38.525]                             next
[13:36:38.525]                           if (!grepl(pattern, name)) 
[13:36:38.525]                             next
[13:36:38.525]                           invokeRestart(restart)
[13:36:38.525]                           muffled <- TRUE
[13:36:38.525]                           break
[13:36:38.525]                         }
[13:36:38.525]                       }
[13:36:38.525]                     }
[13:36:38.525]                     invisible(muffled)
[13:36:38.525]                   }
[13:36:38.525]                   muffleCondition(cond)
[13:36:38.525]                 })
[13:36:38.525]             }))
[13:36:38.525]             future::FutureResult(value = ...future.value$value, 
[13:36:38.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.525]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.525]                     ...future.globalenv.names))
[13:36:38.525]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.525]         }, condition = base::local({
[13:36:38.525]             c <- base::c
[13:36:38.525]             inherits <- base::inherits
[13:36:38.525]             invokeRestart <- base::invokeRestart
[13:36:38.525]             length <- base::length
[13:36:38.525]             list <- base::list
[13:36:38.525]             seq.int <- base::seq.int
[13:36:38.525]             signalCondition <- base::signalCondition
[13:36:38.525]             sys.calls <- base::sys.calls
[13:36:38.525]             `[[` <- base::`[[`
[13:36:38.525]             `+` <- base::`+`
[13:36:38.525]             `<<-` <- base::`<<-`
[13:36:38.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.525]                   3L)]
[13:36:38.525]             }
[13:36:38.525]             function(cond) {
[13:36:38.525]                 is_error <- inherits(cond, "error")
[13:36:38.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.525]                   NULL)
[13:36:38.525]                 if (is_error) {
[13:36:38.525]                   sessionInformation <- function() {
[13:36:38.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.525]                       search = base::search(), system = base::Sys.info())
[13:36:38.525]                   }
[13:36:38.525]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.525]                     cond$call), session = sessionInformation(), 
[13:36:38.525]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.525]                   signalCondition(cond)
[13:36:38.525]                 }
[13:36:38.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.525]                 "immediateCondition"))) {
[13:36:38.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.525]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.525]                   if (TRUE && !signal) {
[13:36:38.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.525]                     {
[13:36:38.525]                       inherits <- base::inherits
[13:36:38.525]                       invokeRestart <- base::invokeRestart
[13:36:38.525]                       is.null <- base::is.null
[13:36:38.525]                       muffled <- FALSE
[13:36:38.525]                       if (inherits(cond, "message")) {
[13:36:38.525]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.525]                         if (muffled) 
[13:36:38.525]                           invokeRestart("muffleMessage")
[13:36:38.525]                       }
[13:36:38.525]                       else if (inherits(cond, "warning")) {
[13:36:38.525]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.525]                         if (muffled) 
[13:36:38.525]                           invokeRestart("muffleWarning")
[13:36:38.525]                       }
[13:36:38.525]                       else if (inherits(cond, "condition")) {
[13:36:38.525]                         if (!is.null(pattern)) {
[13:36:38.525]                           computeRestarts <- base::computeRestarts
[13:36:38.525]                           grepl <- base::grepl
[13:36:38.525]                           restarts <- computeRestarts(cond)
[13:36:38.525]                           for (restart in restarts) {
[13:36:38.525]                             name <- restart$name
[13:36:38.525]                             if (is.null(name)) 
[13:36:38.525]                               next
[13:36:38.525]                             if (!grepl(pattern, name)) 
[13:36:38.525]                               next
[13:36:38.525]                             invokeRestart(restart)
[13:36:38.525]                             muffled <- TRUE
[13:36:38.525]                             break
[13:36:38.525]                           }
[13:36:38.525]                         }
[13:36:38.525]                       }
[13:36:38.525]                       invisible(muffled)
[13:36:38.525]                     }
[13:36:38.525]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.525]                   }
[13:36:38.525]                 }
[13:36:38.525]                 else {
[13:36:38.525]                   if (TRUE) {
[13:36:38.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.525]                     {
[13:36:38.525]                       inherits <- base::inherits
[13:36:38.525]                       invokeRestart <- base::invokeRestart
[13:36:38.525]                       is.null <- base::is.null
[13:36:38.525]                       muffled <- FALSE
[13:36:38.525]                       if (inherits(cond, "message")) {
[13:36:38.525]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.525]                         if (muffled) 
[13:36:38.525]                           invokeRestart("muffleMessage")
[13:36:38.525]                       }
[13:36:38.525]                       else if (inherits(cond, "warning")) {
[13:36:38.525]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.525]                         if (muffled) 
[13:36:38.525]                           invokeRestart("muffleWarning")
[13:36:38.525]                       }
[13:36:38.525]                       else if (inherits(cond, "condition")) {
[13:36:38.525]                         if (!is.null(pattern)) {
[13:36:38.525]                           computeRestarts <- base::computeRestarts
[13:36:38.525]                           grepl <- base::grepl
[13:36:38.525]                           restarts <- computeRestarts(cond)
[13:36:38.525]                           for (restart in restarts) {
[13:36:38.525]                             name <- restart$name
[13:36:38.525]                             if (is.null(name)) 
[13:36:38.525]                               next
[13:36:38.525]                             if (!grepl(pattern, name)) 
[13:36:38.525]                               next
[13:36:38.525]                             invokeRestart(restart)
[13:36:38.525]                             muffled <- TRUE
[13:36:38.525]                             break
[13:36:38.525]                           }
[13:36:38.525]                         }
[13:36:38.525]                       }
[13:36:38.525]                       invisible(muffled)
[13:36:38.525]                     }
[13:36:38.525]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.525]                   }
[13:36:38.525]                 }
[13:36:38.525]             }
[13:36:38.525]         }))
[13:36:38.525]     }, error = function(ex) {
[13:36:38.525]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.525]                 ...future.rng), started = ...future.startTime, 
[13:36:38.525]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.525]             version = "1.8"), class = "FutureResult")
[13:36:38.525]     }, finally = {
[13:36:38.525]         if (!identical(...future.workdir, getwd())) 
[13:36:38.525]             setwd(...future.workdir)
[13:36:38.525]         {
[13:36:38.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.525]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.525]             }
[13:36:38.525]             base::options(...future.oldOptions)
[13:36:38.525]             if (.Platform$OS.type == "windows") {
[13:36:38.525]                 old_names <- names(...future.oldEnvVars)
[13:36:38.525]                 envs <- base::Sys.getenv()
[13:36:38.525]                 names <- names(envs)
[13:36:38.525]                 common <- intersect(names, old_names)
[13:36:38.525]                 added <- setdiff(names, old_names)
[13:36:38.525]                 removed <- setdiff(old_names, names)
[13:36:38.525]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.525]                   envs[common]]
[13:36:38.525]                 NAMES <- toupper(changed)
[13:36:38.525]                 args <- list()
[13:36:38.525]                 for (kk in seq_along(NAMES)) {
[13:36:38.525]                   name <- changed[[kk]]
[13:36:38.525]                   NAME <- NAMES[[kk]]
[13:36:38.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.525]                     next
[13:36:38.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.525]                 }
[13:36:38.525]                 NAMES <- toupper(added)
[13:36:38.525]                 for (kk in seq_along(NAMES)) {
[13:36:38.525]                   name <- added[[kk]]
[13:36:38.525]                   NAME <- NAMES[[kk]]
[13:36:38.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.525]                     next
[13:36:38.525]                   args[[name]] <- ""
[13:36:38.525]                 }
[13:36:38.525]                 NAMES <- toupper(removed)
[13:36:38.525]                 for (kk in seq_along(NAMES)) {
[13:36:38.525]                   name <- removed[[kk]]
[13:36:38.525]                   NAME <- NAMES[[kk]]
[13:36:38.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.525]                     next
[13:36:38.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.525]                 }
[13:36:38.525]                 if (length(args) > 0) 
[13:36:38.525]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.525]             }
[13:36:38.525]             else {
[13:36:38.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.525]             }
[13:36:38.525]             {
[13:36:38.525]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.525]                   0L) {
[13:36:38.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.525]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.525]                   base::options(opts)
[13:36:38.525]                 }
[13:36:38.525]                 {
[13:36:38.525]                   {
[13:36:38.525]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.525]                     NULL
[13:36:38.525]                   }
[13:36:38.525]                   options(future.plan = NULL)
[13:36:38.525]                   if (is.na(NA_character_)) 
[13:36:38.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.525]                     .init = FALSE)
[13:36:38.525]                 }
[13:36:38.525]             }
[13:36:38.525]         }
[13:36:38.525]     })
[13:36:38.525]     if (TRUE) {
[13:36:38.525]         base::sink(type = "output", split = FALSE)
[13:36:38.525]         if (TRUE) {
[13:36:38.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.525]         }
[13:36:38.525]         else {
[13:36:38.525]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.525]         }
[13:36:38.525]         base::close(...future.stdout)
[13:36:38.525]         ...future.stdout <- NULL
[13:36:38.525]     }
[13:36:38.525]     ...future.result$conditions <- ...future.conditions
[13:36:38.525]     ...future.result$finished <- base::Sys.time()
[13:36:38.525]     ...future.result
[13:36:38.525] }
[13:36:38.528] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:38.538] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.539] - Validating connection of MultisessionFuture
[13:36:38.539] - received message: FutureResult
[13:36:38.539] - Received FutureResult
[13:36:38.539] - Erased future from FutureRegistry
[13:36:38.539] result() for ClusterFuture ...
[13:36:38.539] - result already collected: FutureResult
[13:36:38.539] result() for ClusterFuture ... done
[13:36:38.539] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.539] result() for ClusterFuture ...
[13:36:38.540] - result already collected: FutureResult
[13:36:38.540] result() for ClusterFuture ... done
[13:36:38.540] result() for ClusterFuture ...
[13:36:38.540] - result already collected: FutureResult
[13:36:38.540] result() for ClusterFuture ... done
[13:36:38.541] MultisessionFuture started
[13:36:38.541] - Launch lazy future ... done
[13:36:38.541] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a74fc7d78> 
Classes 'listenv', 'environment' <environment: 0x564a71c5c740> 
[13:36:38.544] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.544] - Validating connection of MultisessionFuture
[13:36:38.544] - received message: FutureResult
[13:36:38.545] - Received FutureResult
[13:36:38.545] - Erased future from FutureRegistry
[13:36:38.545] result() for ClusterFuture ...
[13:36:38.545] - result already collected: FutureResult
[13:36:38.545] result() for ClusterFuture ... done
[13:36:38.545] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.545] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.546] - Validating connection of MultisessionFuture
[13:36:38.546] - received message: FutureResult
[13:36:38.546] - Received FutureResult
[13:36:38.546] - Erased future from FutureRegistry
[13:36:38.546] result() for ClusterFuture ...
[13:36:38.546] - result already collected: FutureResult
[13:36:38.546] result() for ClusterFuture ... done
[13:36:38.546] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:38.548] resolve() on list environment ...
[13:36:38.548]  recursive: 0
[13:36:38.549]  length: 6
[13:36:38.549]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:38.549] signalConditionsASAP(numeric, pos=1) ...
[13:36:38.549] - nx: 6
[13:36:38.549] - relay: TRUE
[13:36:38.549] - stdout: TRUE
[13:36:38.550] - signal: TRUE
[13:36:38.550] - resignal: FALSE
[13:36:38.550] - force: TRUE
[13:36:38.550] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.550] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.550]  - until=2
[13:36:38.550]  - relaying element #2
[13:36:38.550] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.550] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.550] signalConditionsASAP(NULL, pos=1) ... done
[13:36:38.551]  length: 5 (resolved future 1)
[13:36:38.551] Future #2
[13:36:38.551] result() for ClusterFuture ...
[13:36:38.551] - result already collected: FutureResult
[13:36:38.551] result() for ClusterFuture ... done
[13:36:38.551] result() for ClusterFuture ...
[13:36:38.551] - result already collected: FutureResult
[13:36:38.551] result() for ClusterFuture ... done
[13:36:38.551] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:38.551] - nx: 6
[13:36:38.552] - relay: TRUE
[13:36:38.552] - stdout: TRUE
[13:36:38.552] - signal: TRUE
[13:36:38.552] - resignal: FALSE
[13:36:38.552] - force: TRUE
[13:36:38.552] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.552] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.552]  - until=2
[13:36:38.552]  - relaying element #2
[13:36:38.552] result() for ClusterFuture ...
[13:36:38.552] - result already collected: FutureResult
[13:36:38.552] result() for ClusterFuture ... done
[13:36:38.553] result() for ClusterFuture ...
[13:36:38.553] - result already collected: FutureResult
[13:36:38.553] result() for ClusterFuture ... done
[13:36:38.553] result() for ClusterFuture ...
[13:36:38.553] - result already collected: FutureResult
[13:36:38.553] result() for ClusterFuture ... done
[13:36:38.553] result() for ClusterFuture ...
[13:36:38.553] - result already collected: FutureResult
[13:36:38.553] result() for ClusterFuture ... done
[13:36:38.553] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.553] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.554] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:38.554]  length: 4 (resolved future 2)
[13:36:38.554] Future #3
[13:36:38.554] result() for ClusterFuture ...
[13:36:38.554] - result already collected: FutureResult
[13:36:38.554] result() for ClusterFuture ... done
[13:36:38.554] result() for ClusterFuture ...
[13:36:38.554] - result already collected: FutureResult
[13:36:38.554] result() for ClusterFuture ... done
[13:36:38.554] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:38.555] - nx: 6
[13:36:38.555] - relay: TRUE
[13:36:38.555] - stdout: TRUE
[13:36:38.555] - signal: TRUE
[13:36:38.555] - resignal: FALSE
[13:36:38.555] - force: TRUE
[13:36:38.555] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.555] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.555]  - until=3
[13:36:38.555]  - relaying element #3
[13:36:38.555] result() for ClusterFuture ...
[13:36:38.556] - result already collected: FutureResult
[13:36:38.556] result() for ClusterFuture ... done
[13:36:38.556] result() for ClusterFuture ...
[13:36:38.556] - result already collected: FutureResult
[13:36:38.556] result() for ClusterFuture ... done
[13:36:38.556] result() for ClusterFuture ...
[13:36:38.556] - result already collected: FutureResult
[13:36:38.556] result() for ClusterFuture ... done
[13:36:38.556] result() for ClusterFuture ...
[13:36:38.556] - result already collected: FutureResult
[13:36:38.556] result() for ClusterFuture ... done
[13:36:38.556] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.557] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.557] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:38.557]  length: 3 (resolved future 3)
[13:36:38.557] Future #4
[13:36:38.557] result() for ClusterFuture ...
[13:36:38.557] - result already collected: FutureResult
[13:36:38.557] result() for ClusterFuture ... done
[13:36:38.557] result() for ClusterFuture ...
[13:36:38.557] - result already collected: FutureResult
[13:36:38.557] result() for ClusterFuture ... done
[13:36:38.558] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:38.558] - nx: 6
[13:36:38.558] - relay: TRUE
[13:36:38.558] - stdout: TRUE
[13:36:38.558] - signal: TRUE
[13:36:38.558] - resignal: FALSE
[13:36:38.558] - force: TRUE
[13:36:38.558] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.558] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.558]  - until=4
[13:36:38.558]  - relaying element #4
[13:36:38.559] result() for ClusterFuture ...
[13:36:38.559] - result already collected: FutureResult
[13:36:38.559] result() for ClusterFuture ... done
[13:36:38.559] result() for ClusterFuture ...
[13:36:38.559] - result already collected: FutureResult
[13:36:38.559] result() for ClusterFuture ... done
[13:36:38.559] result() for ClusterFuture ...
[13:36:38.559] - result already collected: FutureResult
[13:36:38.559] result() for ClusterFuture ... done
[13:36:38.559] result() for ClusterFuture ...
[13:36:38.559] - result already collected: FutureResult
[13:36:38.560] result() for ClusterFuture ... done
[13:36:38.560] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.560] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.560] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:38.560]  length: 2 (resolved future 4)
[13:36:38.560] signalConditionsASAP(NULL, pos=5) ...
[13:36:38.560] - nx: 6
[13:36:38.560] - relay: TRUE
[13:36:38.560] - stdout: TRUE
[13:36:38.560] - signal: TRUE
[13:36:38.560] - resignal: FALSE
[13:36:38.561] - force: TRUE
[13:36:38.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.561] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.561]  - until=6
[13:36:38.561]  - relaying element #6
[13:36:38.561] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.561] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.561] signalConditionsASAP(NULL, pos=5) ... done
[13:36:38.561]  length: 1 (resolved future 5)
[13:36:38.561] signalConditionsASAP(numeric, pos=6) ...
[13:36:38.561] - nx: 6
[13:36:38.561] - relay: TRUE
[13:36:38.562] - stdout: TRUE
[13:36:38.562] - signal: TRUE
[13:36:38.562] - resignal: FALSE
[13:36:38.562] - force: TRUE
[13:36:38.562] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.562] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.562]  - until=6
[13:36:38.562] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.562] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.562] signalConditionsASAP(numeric, pos=6) ... done
[13:36:38.562]  length: 0 (resolved future 6)
[13:36:38.563] Relaying remaining futures
[13:36:38.563] signalConditionsASAP(NULL, pos=0) ...
[13:36:38.563] - nx: 6
[13:36:38.563] - relay: TRUE
[13:36:38.563] - stdout: TRUE
[13:36:38.563] - signal: TRUE
[13:36:38.563] - resignal: FALSE
[13:36:38.563] - force: TRUE
[13:36:38.563] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.563] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:38.563] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.564] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.564] signalConditionsASAP(NULL, pos=0) ... done
[13:36:38.564] resolve() on list environment ... DONE
[13:36:38.564] result() for ClusterFuture ...
[13:36:38.564] - result already collected: FutureResult
[13:36:38.564] result() for ClusterFuture ... done
[13:36:38.564] result() for ClusterFuture ...
[13:36:38.564] - result already collected: FutureResult
[13:36:38.564] result() for ClusterFuture ... done
[13:36:38.564] result() for ClusterFuture ...
[13:36:38.565] - result already collected: FutureResult
[13:36:38.565] result() for ClusterFuture ... done
[13:36:38.565] result() for ClusterFuture ...
[13:36:38.565] - result already collected: FutureResult
[13:36:38.565] result() for ClusterFuture ... done
[13:36:38.565] result() for ClusterFuture ...
[13:36:38.565] - result already collected: FutureResult
[13:36:38.565] result() for ClusterFuture ... done
[13:36:38.565] result() for ClusterFuture ...
[13:36:38.565] - result already collected: FutureResult
[13:36:38.565] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a738a3668> 
Dimensions: c(1, 6)
[13:36:38.566] getGlobalsAndPackages() ...
[13:36:38.566] Searching for globals...
[13:36:38.566] 
[13:36:38.567] Searching for globals ... DONE
[13:36:38.567] - globals: [0] <none>
[13:36:38.567] getGlobalsAndPackages() ... DONE
[13:36:38.567] run() for ‘Future’ ...
[13:36:38.567] - state: ‘created’
[13:36:38.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.581] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.581]   - Field: ‘node’
[13:36:38.581]   - Field: ‘label’
[13:36:38.582]   - Field: ‘local’
[13:36:38.582]   - Field: ‘owner’
[13:36:38.582]   - Field: ‘envir’
[13:36:38.582]   - Field: ‘workers’
[13:36:38.582]   - Field: ‘packages’
[13:36:38.582]   - Field: ‘gc’
[13:36:38.582]   - Field: ‘conditions’
[13:36:38.582]   - Field: ‘persistent’
[13:36:38.582]   - Field: ‘expr’
[13:36:38.582]   - Field: ‘uuid’
[13:36:38.583]   - Field: ‘seed’
[13:36:38.583]   - Field: ‘version’
[13:36:38.583]   - Field: ‘result’
[13:36:38.583]   - Field: ‘asynchronous’
[13:36:38.583]   - Field: ‘calls’
[13:36:38.583]   - Field: ‘globals’
[13:36:38.583]   - Field: ‘stdout’
[13:36:38.583]   - Field: ‘earlySignal’
[13:36:38.583]   - Field: ‘lazy’
[13:36:38.583]   - Field: ‘state’
[13:36:38.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.584] - Launch lazy future ...
[13:36:38.584] Packages needed by the future expression (n = 0): <none>
[13:36:38.584] Packages needed by future strategies (n = 0): <none>
[13:36:38.584] {
[13:36:38.584]     {
[13:36:38.584]         {
[13:36:38.584]             ...future.startTime <- base::Sys.time()
[13:36:38.584]             {
[13:36:38.584]                 {
[13:36:38.584]                   {
[13:36:38.584]                     {
[13:36:38.584]                       base::local({
[13:36:38.584]                         has_future <- base::requireNamespace("future", 
[13:36:38.584]                           quietly = TRUE)
[13:36:38.584]                         if (has_future) {
[13:36:38.584]                           ns <- base::getNamespace("future")
[13:36:38.584]                           version <- ns[[".package"]][["version"]]
[13:36:38.584]                           if (is.null(version)) 
[13:36:38.584]                             version <- utils::packageVersion("future")
[13:36:38.584]                         }
[13:36:38.584]                         else {
[13:36:38.584]                           version <- NULL
[13:36:38.584]                         }
[13:36:38.584]                         if (!has_future || version < "1.8.0") {
[13:36:38.584]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.584]                             "", base::R.version$version.string), 
[13:36:38.584]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.584]                               "release", "version")], collapse = " "), 
[13:36:38.584]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.584]                             info)
[13:36:38.584]                           info <- base::paste(info, collapse = "; ")
[13:36:38.584]                           if (!has_future) {
[13:36:38.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.584]                               info)
[13:36:38.584]                           }
[13:36:38.584]                           else {
[13:36:38.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.584]                               info, version)
[13:36:38.584]                           }
[13:36:38.584]                           base::stop(msg)
[13:36:38.584]                         }
[13:36:38.584]                       })
[13:36:38.584]                     }
[13:36:38.584]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.584]                     base::options(mc.cores = 1L)
[13:36:38.584]                   }
[13:36:38.584]                   ...future.strategy.old <- future::plan("list")
[13:36:38.584]                   options(future.plan = NULL)
[13:36:38.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.584]                 }
[13:36:38.584]                 ...future.workdir <- getwd()
[13:36:38.584]             }
[13:36:38.584]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.584]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.584]         }
[13:36:38.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.584]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.584]             base::names(...future.oldOptions))
[13:36:38.584]     }
[13:36:38.584]     if (FALSE) {
[13:36:38.584]     }
[13:36:38.584]     else {
[13:36:38.584]         if (TRUE) {
[13:36:38.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.584]                 open = "w")
[13:36:38.584]         }
[13:36:38.584]         else {
[13:36:38.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.584]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.584]         }
[13:36:38.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.584]             base::sink(type = "output", split = FALSE)
[13:36:38.584]             base::close(...future.stdout)
[13:36:38.584]         }, add = TRUE)
[13:36:38.584]     }
[13:36:38.584]     ...future.frame <- base::sys.nframe()
[13:36:38.584]     ...future.conditions <- base::list()
[13:36:38.584]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.584]     if (FALSE) {
[13:36:38.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.584]     }
[13:36:38.584]     ...future.result <- base::tryCatch({
[13:36:38.584]         base::withCallingHandlers({
[13:36:38.584]             ...future.value <- base::withVisible(base::local({
[13:36:38.584]                 ...future.makeSendCondition <- base::local({
[13:36:38.584]                   sendCondition <- NULL
[13:36:38.584]                   function(frame = 1L) {
[13:36:38.584]                     if (is.function(sendCondition)) 
[13:36:38.584]                       return(sendCondition)
[13:36:38.584]                     ns <- getNamespace("parallel")
[13:36:38.584]                     if (exists("sendData", mode = "function", 
[13:36:38.584]                       envir = ns)) {
[13:36:38.584]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.584]                         envir = ns)
[13:36:38.584]                       envir <- sys.frame(frame)
[13:36:38.584]                       master <- NULL
[13:36:38.584]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.584]                         !identical(envir, emptyenv())) {
[13:36:38.584]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.584]                           inherits = FALSE)) {
[13:36:38.584]                           master <- get("master", mode = "list", 
[13:36:38.584]                             envir = envir, inherits = FALSE)
[13:36:38.584]                           if (inherits(master, c("SOCKnode", 
[13:36:38.584]                             "SOCK0node"))) {
[13:36:38.584]                             sendCondition <<- function(cond) {
[13:36:38.584]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.584]                                 success = TRUE)
[13:36:38.584]                               parallel_sendData(master, data)
[13:36:38.584]                             }
[13:36:38.584]                             return(sendCondition)
[13:36:38.584]                           }
[13:36:38.584]                         }
[13:36:38.584]                         frame <- frame + 1L
[13:36:38.584]                         envir <- sys.frame(frame)
[13:36:38.584]                       }
[13:36:38.584]                     }
[13:36:38.584]                     sendCondition <<- function(cond) NULL
[13:36:38.584]                   }
[13:36:38.584]                 })
[13:36:38.584]                 withCallingHandlers({
[13:36:38.584]                   2
[13:36:38.584]                 }, immediateCondition = function(cond) {
[13:36:38.584]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.584]                   sendCondition(cond)
[13:36:38.584]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.584]                   {
[13:36:38.584]                     inherits <- base::inherits
[13:36:38.584]                     invokeRestart <- base::invokeRestart
[13:36:38.584]                     is.null <- base::is.null
[13:36:38.584]                     muffled <- FALSE
[13:36:38.584]                     if (inherits(cond, "message")) {
[13:36:38.584]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.584]                       if (muffled) 
[13:36:38.584]                         invokeRestart("muffleMessage")
[13:36:38.584]                     }
[13:36:38.584]                     else if (inherits(cond, "warning")) {
[13:36:38.584]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.584]                       if (muffled) 
[13:36:38.584]                         invokeRestart("muffleWarning")
[13:36:38.584]                     }
[13:36:38.584]                     else if (inherits(cond, "condition")) {
[13:36:38.584]                       if (!is.null(pattern)) {
[13:36:38.584]                         computeRestarts <- base::computeRestarts
[13:36:38.584]                         grepl <- base::grepl
[13:36:38.584]                         restarts <- computeRestarts(cond)
[13:36:38.584]                         for (restart in restarts) {
[13:36:38.584]                           name <- restart$name
[13:36:38.584]                           if (is.null(name)) 
[13:36:38.584]                             next
[13:36:38.584]                           if (!grepl(pattern, name)) 
[13:36:38.584]                             next
[13:36:38.584]                           invokeRestart(restart)
[13:36:38.584]                           muffled <- TRUE
[13:36:38.584]                           break
[13:36:38.584]                         }
[13:36:38.584]                       }
[13:36:38.584]                     }
[13:36:38.584]                     invisible(muffled)
[13:36:38.584]                   }
[13:36:38.584]                   muffleCondition(cond)
[13:36:38.584]                 })
[13:36:38.584]             }))
[13:36:38.584]             future::FutureResult(value = ...future.value$value, 
[13:36:38.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.584]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.584]                     ...future.globalenv.names))
[13:36:38.584]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.584]         }, condition = base::local({
[13:36:38.584]             c <- base::c
[13:36:38.584]             inherits <- base::inherits
[13:36:38.584]             invokeRestart <- base::invokeRestart
[13:36:38.584]             length <- base::length
[13:36:38.584]             list <- base::list
[13:36:38.584]             seq.int <- base::seq.int
[13:36:38.584]             signalCondition <- base::signalCondition
[13:36:38.584]             sys.calls <- base::sys.calls
[13:36:38.584]             `[[` <- base::`[[`
[13:36:38.584]             `+` <- base::`+`
[13:36:38.584]             `<<-` <- base::`<<-`
[13:36:38.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.584]                   3L)]
[13:36:38.584]             }
[13:36:38.584]             function(cond) {
[13:36:38.584]                 is_error <- inherits(cond, "error")
[13:36:38.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.584]                   NULL)
[13:36:38.584]                 if (is_error) {
[13:36:38.584]                   sessionInformation <- function() {
[13:36:38.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.584]                       search = base::search(), system = base::Sys.info())
[13:36:38.584]                   }
[13:36:38.584]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.584]                     cond$call), session = sessionInformation(), 
[13:36:38.584]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.584]                   signalCondition(cond)
[13:36:38.584]                 }
[13:36:38.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.584]                 "immediateCondition"))) {
[13:36:38.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.584]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.584]                   if (TRUE && !signal) {
[13:36:38.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.584]                     {
[13:36:38.584]                       inherits <- base::inherits
[13:36:38.584]                       invokeRestart <- base::invokeRestart
[13:36:38.584]                       is.null <- base::is.null
[13:36:38.584]                       muffled <- FALSE
[13:36:38.584]                       if (inherits(cond, "message")) {
[13:36:38.584]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.584]                         if (muffled) 
[13:36:38.584]                           invokeRestart("muffleMessage")
[13:36:38.584]                       }
[13:36:38.584]                       else if (inherits(cond, "warning")) {
[13:36:38.584]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.584]                         if (muffled) 
[13:36:38.584]                           invokeRestart("muffleWarning")
[13:36:38.584]                       }
[13:36:38.584]                       else if (inherits(cond, "condition")) {
[13:36:38.584]                         if (!is.null(pattern)) {
[13:36:38.584]                           computeRestarts <- base::computeRestarts
[13:36:38.584]                           grepl <- base::grepl
[13:36:38.584]                           restarts <- computeRestarts(cond)
[13:36:38.584]                           for (restart in restarts) {
[13:36:38.584]                             name <- restart$name
[13:36:38.584]                             if (is.null(name)) 
[13:36:38.584]                               next
[13:36:38.584]                             if (!grepl(pattern, name)) 
[13:36:38.584]                               next
[13:36:38.584]                             invokeRestart(restart)
[13:36:38.584]                             muffled <- TRUE
[13:36:38.584]                             break
[13:36:38.584]                           }
[13:36:38.584]                         }
[13:36:38.584]                       }
[13:36:38.584]                       invisible(muffled)
[13:36:38.584]                     }
[13:36:38.584]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.584]                   }
[13:36:38.584]                 }
[13:36:38.584]                 else {
[13:36:38.584]                   if (TRUE) {
[13:36:38.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.584]                     {
[13:36:38.584]                       inherits <- base::inherits
[13:36:38.584]                       invokeRestart <- base::invokeRestart
[13:36:38.584]                       is.null <- base::is.null
[13:36:38.584]                       muffled <- FALSE
[13:36:38.584]                       if (inherits(cond, "message")) {
[13:36:38.584]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.584]                         if (muffled) 
[13:36:38.584]                           invokeRestart("muffleMessage")
[13:36:38.584]                       }
[13:36:38.584]                       else if (inherits(cond, "warning")) {
[13:36:38.584]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.584]                         if (muffled) 
[13:36:38.584]                           invokeRestart("muffleWarning")
[13:36:38.584]                       }
[13:36:38.584]                       else if (inherits(cond, "condition")) {
[13:36:38.584]                         if (!is.null(pattern)) {
[13:36:38.584]                           computeRestarts <- base::computeRestarts
[13:36:38.584]                           grepl <- base::grepl
[13:36:38.584]                           restarts <- computeRestarts(cond)
[13:36:38.584]                           for (restart in restarts) {
[13:36:38.584]                             name <- restart$name
[13:36:38.584]                             if (is.null(name)) 
[13:36:38.584]                               next
[13:36:38.584]                             if (!grepl(pattern, name)) 
[13:36:38.584]                               next
[13:36:38.584]                             invokeRestart(restart)
[13:36:38.584]                             muffled <- TRUE
[13:36:38.584]                             break
[13:36:38.584]                           }
[13:36:38.584]                         }
[13:36:38.584]                       }
[13:36:38.584]                       invisible(muffled)
[13:36:38.584]                     }
[13:36:38.584]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.584]                   }
[13:36:38.584]                 }
[13:36:38.584]             }
[13:36:38.584]         }))
[13:36:38.584]     }, error = function(ex) {
[13:36:38.584]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.584]                 ...future.rng), started = ...future.startTime, 
[13:36:38.584]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.584]             version = "1.8"), class = "FutureResult")
[13:36:38.584]     }, finally = {
[13:36:38.584]         if (!identical(...future.workdir, getwd())) 
[13:36:38.584]             setwd(...future.workdir)
[13:36:38.584]         {
[13:36:38.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.584]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.584]             }
[13:36:38.584]             base::options(...future.oldOptions)
[13:36:38.584]             if (.Platform$OS.type == "windows") {
[13:36:38.584]                 old_names <- names(...future.oldEnvVars)
[13:36:38.584]                 envs <- base::Sys.getenv()
[13:36:38.584]                 names <- names(envs)
[13:36:38.584]                 common <- intersect(names, old_names)
[13:36:38.584]                 added <- setdiff(names, old_names)
[13:36:38.584]                 removed <- setdiff(old_names, names)
[13:36:38.584]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.584]                   envs[common]]
[13:36:38.584]                 NAMES <- toupper(changed)
[13:36:38.584]                 args <- list()
[13:36:38.584]                 for (kk in seq_along(NAMES)) {
[13:36:38.584]                   name <- changed[[kk]]
[13:36:38.584]                   NAME <- NAMES[[kk]]
[13:36:38.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.584]                     next
[13:36:38.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.584]                 }
[13:36:38.584]                 NAMES <- toupper(added)
[13:36:38.584]                 for (kk in seq_along(NAMES)) {
[13:36:38.584]                   name <- added[[kk]]
[13:36:38.584]                   NAME <- NAMES[[kk]]
[13:36:38.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.584]                     next
[13:36:38.584]                   args[[name]] <- ""
[13:36:38.584]                 }
[13:36:38.584]                 NAMES <- toupper(removed)
[13:36:38.584]                 for (kk in seq_along(NAMES)) {
[13:36:38.584]                   name <- removed[[kk]]
[13:36:38.584]                   NAME <- NAMES[[kk]]
[13:36:38.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.584]                     next
[13:36:38.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.584]                 }
[13:36:38.584]                 if (length(args) > 0) 
[13:36:38.584]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.584]             }
[13:36:38.584]             else {
[13:36:38.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.584]             }
[13:36:38.584]             {
[13:36:38.584]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.584]                   0L) {
[13:36:38.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.584]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.584]                   base::options(opts)
[13:36:38.584]                 }
[13:36:38.584]                 {
[13:36:38.584]                   {
[13:36:38.584]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.584]                     NULL
[13:36:38.584]                   }
[13:36:38.584]                   options(future.plan = NULL)
[13:36:38.584]                   if (is.na(NA_character_)) 
[13:36:38.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.584]                     .init = FALSE)
[13:36:38.584]                 }
[13:36:38.584]             }
[13:36:38.584]         }
[13:36:38.584]     })
[13:36:38.584]     if (TRUE) {
[13:36:38.584]         base::sink(type = "output", split = FALSE)
[13:36:38.584]         if (TRUE) {
[13:36:38.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.584]         }
[13:36:38.584]         else {
[13:36:38.584]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.584]         }
[13:36:38.584]         base::close(...future.stdout)
[13:36:38.584]         ...future.stdout <- NULL
[13:36:38.584]     }
[13:36:38.584]     ...future.result$conditions <- ...future.conditions
[13:36:38.584]     ...future.result$finished <- base::Sys.time()
[13:36:38.584]     ...future.result
[13:36:38.584] }
[13:36:38.587] MultisessionFuture started
[13:36:38.588] - Launch lazy future ... done
[13:36:38.588] run() for ‘MultisessionFuture’ ... done
[13:36:38.588] getGlobalsAndPackages() ...
[13:36:38.588] Searching for globals...
[13:36:38.588] 
[13:36:38.588] Searching for globals ... DONE
[13:36:38.588] - globals: [0] <none>
[13:36:38.589] getGlobalsAndPackages() ... DONE
[13:36:38.589] run() for ‘Future’ ...
[13:36:38.589] - state: ‘created’
[13:36:38.589] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.603] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.603]   - Field: ‘node’
[13:36:38.603]   - Field: ‘label’
[13:36:38.603]   - Field: ‘local’
[13:36:38.604]   - Field: ‘owner’
[13:36:38.604]   - Field: ‘envir’
[13:36:38.604]   - Field: ‘workers’
[13:36:38.604]   - Field: ‘packages’
[13:36:38.604]   - Field: ‘gc’
[13:36:38.604]   - Field: ‘conditions’
[13:36:38.604]   - Field: ‘persistent’
[13:36:38.604]   - Field: ‘expr’
[13:36:38.604]   - Field: ‘uuid’
[13:36:38.604]   - Field: ‘seed’
[13:36:38.604]   - Field: ‘version’
[13:36:38.605]   - Field: ‘result’
[13:36:38.605]   - Field: ‘asynchronous’
[13:36:38.605]   - Field: ‘calls’
[13:36:38.605]   - Field: ‘globals’
[13:36:38.605]   - Field: ‘stdout’
[13:36:38.605]   - Field: ‘earlySignal’
[13:36:38.605]   - Field: ‘lazy’
[13:36:38.605]   - Field: ‘state’
[13:36:38.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.605] - Launch lazy future ...
[13:36:38.606] Packages needed by the future expression (n = 0): <none>
[13:36:38.606] Packages needed by future strategies (n = 0): <none>
[13:36:38.610] {
[13:36:38.610]     {
[13:36:38.610]         {
[13:36:38.610]             ...future.startTime <- base::Sys.time()
[13:36:38.610]             {
[13:36:38.610]                 {
[13:36:38.610]                   {
[13:36:38.610]                     {
[13:36:38.610]                       base::local({
[13:36:38.610]                         has_future <- base::requireNamespace("future", 
[13:36:38.610]                           quietly = TRUE)
[13:36:38.610]                         if (has_future) {
[13:36:38.610]                           ns <- base::getNamespace("future")
[13:36:38.610]                           version <- ns[[".package"]][["version"]]
[13:36:38.610]                           if (is.null(version)) 
[13:36:38.610]                             version <- utils::packageVersion("future")
[13:36:38.610]                         }
[13:36:38.610]                         else {
[13:36:38.610]                           version <- NULL
[13:36:38.610]                         }
[13:36:38.610]                         if (!has_future || version < "1.8.0") {
[13:36:38.610]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.610]                             "", base::R.version$version.string), 
[13:36:38.610]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.610]                               "release", "version")], collapse = " "), 
[13:36:38.610]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.610]                             info)
[13:36:38.610]                           info <- base::paste(info, collapse = "; ")
[13:36:38.610]                           if (!has_future) {
[13:36:38.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.610]                               info)
[13:36:38.610]                           }
[13:36:38.610]                           else {
[13:36:38.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.610]                               info, version)
[13:36:38.610]                           }
[13:36:38.610]                           base::stop(msg)
[13:36:38.610]                         }
[13:36:38.610]                       })
[13:36:38.610]                     }
[13:36:38.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.610]                     base::options(mc.cores = 1L)
[13:36:38.610]                   }
[13:36:38.610]                   ...future.strategy.old <- future::plan("list")
[13:36:38.610]                   options(future.plan = NULL)
[13:36:38.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.610]                 }
[13:36:38.610]                 ...future.workdir <- getwd()
[13:36:38.610]             }
[13:36:38.610]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.610]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.610]         }
[13:36:38.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.610]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.610]             base::names(...future.oldOptions))
[13:36:38.610]     }
[13:36:38.610]     if (FALSE) {
[13:36:38.610]     }
[13:36:38.610]     else {
[13:36:38.610]         if (TRUE) {
[13:36:38.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.610]                 open = "w")
[13:36:38.610]         }
[13:36:38.610]         else {
[13:36:38.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.610]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.610]         }
[13:36:38.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.610]             base::sink(type = "output", split = FALSE)
[13:36:38.610]             base::close(...future.stdout)
[13:36:38.610]         }, add = TRUE)
[13:36:38.610]     }
[13:36:38.610]     ...future.frame <- base::sys.nframe()
[13:36:38.610]     ...future.conditions <- base::list()
[13:36:38.610]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.610]     if (FALSE) {
[13:36:38.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.610]     }
[13:36:38.610]     ...future.result <- base::tryCatch({
[13:36:38.610]         base::withCallingHandlers({
[13:36:38.610]             ...future.value <- base::withVisible(base::local({
[13:36:38.610]                 ...future.makeSendCondition <- base::local({
[13:36:38.610]                   sendCondition <- NULL
[13:36:38.610]                   function(frame = 1L) {
[13:36:38.610]                     if (is.function(sendCondition)) 
[13:36:38.610]                       return(sendCondition)
[13:36:38.610]                     ns <- getNamespace("parallel")
[13:36:38.610]                     if (exists("sendData", mode = "function", 
[13:36:38.610]                       envir = ns)) {
[13:36:38.610]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.610]                         envir = ns)
[13:36:38.610]                       envir <- sys.frame(frame)
[13:36:38.610]                       master <- NULL
[13:36:38.610]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.610]                         !identical(envir, emptyenv())) {
[13:36:38.610]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.610]                           inherits = FALSE)) {
[13:36:38.610]                           master <- get("master", mode = "list", 
[13:36:38.610]                             envir = envir, inherits = FALSE)
[13:36:38.610]                           if (inherits(master, c("SOCKnode", 
[13:36:38.610]                             "SOCK0node"))) {
[13:36:38.610]                             sendCondition <<- function(cond) {
[13:36:38.610]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.610]                                 success = TRUE)
[13:36:38.610]                               parallel_sendData(master, data)
[13:36:38.610]                             }
[13:36:38.610]                             return(sendCondition)
[13:36:38.610]                           }
[13:36:38.610]                         }
[13:36:38.610]                         frame <- frame + 1L
[13:36:38.610]                         envir <- sys.frame(frame)
[13:36:38.610]                       }
[13:36:38.610]                     }
[13:36:38.610]                     sendCondition <<- function(cond) NULL
[13:36:38.610]                   }
[13:36:38.610]                 })
[13:36:38.610]                 withCallingHandlers({
[13:36:38.610]                   NULL
[13:36:38.610]                 }, immediateCondition = function(cond) {
[13:36:38.610]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.610]                   sendCondition(cond)
[13:36:38.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.610]                   {
[13:36:38.610]                     inherits <- base::inherits
[13:36:38.610]                     invokeRestart <- base::invokeRestart
[13:36:38.610]                     is.null <- base::is.null
[13:36:38.610]                     muffled <- FALSE
[13:36:38.610]                     if (inherits(cond, "message")) {
[13:36:38.610]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.610]                       if (muffled) 
[13:36:38.610]                         invokeRestart("muffleMessage")
[13:36:38.610]                     }
[13:36:38.610]                     else if (inherits(cond, "warning")) {
[13:36:38.610]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.610]                       if (muffled) 
[13:36:38.610]                         invokeRestart("muffleWarning")
[13:36:38.610]                     }
[13:36:38.610]                     else if (inherits(cond, "condition")) {
[13:36:38.610]                       if (!is.null(pattern)) {
[13:36:38.610]                         computeRestarts <- base::computeRestarts
[13:36:38.610]                         grepl <- base::grepl
[13:36:38.610]                         restarts <- computeRestarts(cond)
[13:36:38.610]                         for (restart in restarts) {
[13:36:38.610]                           name <- restart$name
[13:36:38.610]                           if (is.null(name)) 
[13:36:38.610]                             next
[13:36:38.610]                           if (!grepl(pattern, name)) 
[13:36:38.610]                             next
[13:36:38.610]                           invokeRestart(restart)
[13:36:38.610]                           muffled <- TRUE
[13:36:38.610]                           break
[13:36:38.610]                         }
[13:36:38.610]                       }
[13:36:38.610]                     }
[13:36:38.610]                     invisible(muffled)
[13:36:38.610]                   }
[13:36:38.610]                   muffleCondition(cond)
[13:36:38.610]                 })
[13:36:38.610]             }))
[13:36:38.610]             future::FutureResult(value = ...future.value$value, 
[13:36:38.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.610]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.610]                     ...future.globalenv.names))
[13:36:38.610]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.610]         }, condition = base::local({
[13:36:38.610]             c <- base::c
[13:36:38.610]             inherits <- base::inherits
[13:36:38.610]             invokeRestart <- base::invokeRestart
[13:36:38.610]             length <- base::length
[13:36:38.610]             list <- base::list
[13:36:38.610]             seq.int <- base::seq.int
[13:36:38.610]             signalCondition <- base::signalCondition
[13:36:38.610]             sys.calls <- base::sys.calls
[13:36:38.610]             `[[` <- base::`[[`
[13:36:38.610]             `+` <- base::`+`
[13:36:38.610]             `<<-` <- base::`<<-`
[13:36:38.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.610]                   3L)]
[13:36:38.610]             }
[13:36:38.610]             function(cond) {
[13:36:38.610]                 is_error <- inherits(cond, "error")
[13:36:38.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.610]                   NULL)
[13:36:38.610]                 if (is_error) {
[13:36:38.610]                   sessionInformation <- function() {
[13:36:38.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.610]                       search = base::search(), system = base::Sys.info())
[13:36:38.610]                   }
[13:36:38.610]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.610]                     cond$call), session = sessionInformation(), 
[13:36:38.610]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.610]                   signalCondition(cond)
[13:36:38.610]                 }
[13:36:38.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.610]                 "immediateCondition"))) {
[13:36:38.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.610]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.610]                   if (TRUE && !signal) {
[13:36:38.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.610]                     {
[13:36:38.610]                       inherits <- base::inherits
[13:36:38.610]                       invokeRestart <- base::invokeRestart
[13:36:38.610]                       is.null <- base::is.null
[13:36:38.610]                       muffled <- FALSE
[13:36:38.610]                       if (inherits(cond, "message")) {
[13:36:38.610]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.610]                         if (muffled) 
[13:36:38.610]                           invokeRestart("muffleMessage")
[13:36:38.610]                       }
[13:36:38.610]                       else if (inherits(cond, "warning")) {
[13:36:38.610]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.610]                         if (muffled) 
[13:36:38.610]                           invokeRestart("muffleWarning")
[13:36:38.610]                       }
[13:36:38.610]                       else if (inherits(cond, "condition")) {
[13:36:38.610]                         if (!is.null(pattern)) {
[13:36:38.610]                           computeRestarts <- base::computeRestarts
[13:36:38.610]                           grepl <- base::grepl
[13:36:38.610]                           restarts <- computeRestarts(cond)
[13:36:38.610]                           for (restart in restarts) {
[13:36:38.610]                             name <- restart$name
[13:36:38.610]                             if (is.null(name)) 
[13:36:38.610]                               next
[13:36:38.610]                             if (!grepl(pattern, name)) 
[13:36:38.610]                               next
[13:36:38.610]                             invokeRestart(restart)
[13:36:38.610]                             muffled <- TRUE
[13:36:38.610]                             break
[13:36:38.610]                           }
[13:36:38.610]                         }
[13:36:38.610]                       }
[13:36:38.610]                       invisible(muffled)
[13:36:38.610]                     }
[13:36:38.610]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.610]                   }
[13:36:38.610]                 }
[13:36:38.610]                 else {
[13:36:38.610]                   if (TRUE) {
[13:36:38.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.610]                     {
[13:36:38.610]                       inherits <- base::inherits
[13:36:38.610]                       invokeRestart <- base::invokeRestart
[13:36:38.610]                       is.null <- base::is.null
[13:36:38.610]                       muffled <- FALSE
[13:36:38.610]                       if (inherits(cond, "message")) {
[13:36:38.610]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.610]                         if (muffled) 
[13:36:38.610]                           invokeRestart("muffleMessage")
[13:36:38.610]                       }
[13:36:38.610]                       else if (inherits(cond, "warning")) {
[13:36:38.610]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.610]                         if (muffled) 
[13:36:38.610]                           invokeRestart("muffleWarning")
[13:36:38.610]                       }
[13:36:38.610]                       else if (inherits(cond, "condition")) {
[13:36:38.610]                         if (!is.null(pattern)) {
[13:36:38.610]                           computeRestarts <- base::computeRestarts
[13:36:38.610]                           grepl <- base::grepl
[13:36:38.610]                           restarts <- computeRestarts(cond)
[13:36:38.610]                           for (restart in restarts) {
[13:36:38.610]                             name <- restart$name
[13:36:38.610]                             if (is.null(name)) 
[13:36:38.610]                               next
[13:36:38.610]                             if (!grepl(pattern, name)) 
[13:36:38.610]                               next
[13:36:38.610]                             invokeRestart(restart)
[13:36:38.610]                             muffled <- TRUE
[13:36:38.610]                             break
[13:36:38.610]                           }
[13:36:38.610]                         }
[13:36:38.610]                       }
[13:36:38.610]                       invisible(muffled)
[13:36:38.610]                     }
[13:36:38.610]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.610]                   }
[13:36:38.610]                 }
[13:36:38.610]             }
[13:36:38.610]         }))
[13:36:38.610]     }, error = function(ex) {
[13:36:38.610]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.610]                 ...future.rng), started = ...future.startTime, 
[13:36:38.610]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.610]             version = "1.8"), class = "FutureResult")
[13:36:38.610]     }, finally = {
[13:36:38.610]         if (!identical(...future.workdir, getwd())) 
[13:36:38.610]             setwd(...future.workdir)
[13:36:38.610]         {
[13:36:38.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.610]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.610]             }
[13:36:38.610]             base::options(...future.oldOptions)
[13:36:38.610]             if (.Platform$OS.type == "windows") {
[13:36:38.610]                 old_names <- names(...future.oldEnvVars)
[13:36:38.610]                 envs <- base::Sys.getenv()
[13:36:38.610]                 names <- names(envs)
[13:36:38.610]                 common <- intersect(names, old_names)
[13:36:38.610]                 added <- setdiff(names, old_names)
[13:36:38.610]                 removed <- setdiff(old_names, names)
[13:36:38.610]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.610]                   envs[common]]
[13:36:38.610]                 NAMES <- toupper(changed)
[13:36:38.610]                 args <- list()
[13:36:38.610]                 for (kk in seq_along(NAMES)) {
[13:36:38.610]                   name <- changed[[kk]]
[13:36:38.610]                   NAME <- NAMES[[kk]]
[13:36:38.610]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.610]                     next
[13:36:38.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.610]                 }
[13:36:38.610]                 NAMES <- toupper(added)
[13:36:38.610]                 for (kk in seq_along(NAMES)) {
[13:36:38.610]                   name <- added[[kk]]
[13:36:38.610]                   NAME <- NAMES[[kk]]
[13:36:38.610]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.610]                     next
[13:36:38.610]                   args[[name]] <- ""
[13:36:38.610]                 }
[13:36:38.610]                 NAMES <- toupper(removed)
[13:36:38.610]                 for (kk in seq_along(NAMES)) {
[13:36:38.610]                   name <- removed[[kk]]
[13:36:38.610]                   NAME <- NAMES[[kk]]
[13:36:38.610]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.610]                     next
[13:36:38.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.610]                 }
[13:36:38.610]                 if (length(args) > 0) 
[13:36:38.610]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.610]             }
[13:36:38.610]             else {
[13:36:38.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.610]             }
[13:36:38.610]             {
[13:36:38.610]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.610]                   0L) {
[13:36:38.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.610]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.610]                   base::options(opts)
[13:36:38.610]                 }
[13:36:38.610]                 {
[13:36:38.610]                   {
[13:36:38.610]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.610]                     NULL
[13:36:38.610]                   }
[13:36:38.610]                   options(future.plan = NULL)
[13:36:38.610]                   if (is.na(NA_character_)) 
[13:36:38.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.610]                     .init = FALSE)
[13:36:38.610]                 }
[13:36:38.610]             }
[13:36:38.610]         }
[13:36:38.610]     })
[13:36:38.610]     if (TRUE) {
[13:36:38.610]         base::sink(type = "output", split = FALSE)
[13:36:38.610]         if (TRUE) {
[13:36:38.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.610]         }
[13:36:38.610]         else {
[13:36:38.610]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.610]         }
[13:36:38.610]         base::close(...future.stdout)
[13:36:38.610]         ...future.stdout <- NULL
[13:36:38.610]     }
[13:36:38.610]     ...future.result$conditions <- ...future.conditions
[13:36:38.610]     ...future.result$finished <- base::Sys.time()
[13:36:38.610]     ...future.result
[13:36:38.610] }
[13:36:38.612] MultisessionFuture started
[13:36:38.613] - Launch lazy future ... done
[13:36:38.613] run() for ‘MultisessionFuture’ ... done
[13:36:38.613] getGlobalsAndPackages() ...
[13:36:38.613] Searching for globals...
[13:36:38.614] - globals found: [1] ‘{’
[13:36:38.614] Searching for globals ... DONE
[13:36:38.614] Resolving globals: FALSE
[13:36:38.614] 
[13:36:38.614] 
[13:36:38.615] getGlobalsAndPackages() ... DONE
[13:36:38.615] run() for ‘Future’ ...
[13:36:38.615] - state: ‘created’
[13:36:38.615] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.629]   - Field: ‘node’
[13:36:38.629]   - Field: ‘label’
[13:36:38.629]   - Field: ‘local’
[13:36:38.629]   - Field: ‘owner’
[13:36:38.630]   - Field: ‘envir’
[13:36:38.630]   - Field: ‘workers’
[13:36:38.630]   - Field: ‘packages’
[13:36:38.630]   - Field: ‘gc’
[13:36:38.630]   - Field: ‘conditions’
[13:36:38.630]   - Field: ‘persistent’
[13:36:38.630]   - Field: ‘expr’
[13:36:38.630]   - Field: ‘uuid’
[13:36:38.630]   - Field: ‘seed’
[13:36:38.630]   - Field: ‘version’
[13:36:38.631]   - Field: ‘result’
[13:36:38.631]   - Field: ‘asynchronous’
[13:36:38.631]   - Field: ‘calls’
[13:36:38.631]   - Field: ‘globals’
[13:36:38.631]   - Field: ‘stdout’
[13:36:38.631]   - Field: ‘earlySignal’
[13:36:38.631]   - Field: ‘lazy’
[13:36:38.631]   - Field: ‘state’
[13:36:38.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.631] - Launch lazy future ...
[13:36:38.632] Packages needed by the future expression (n = 0): <none>
[13:36:38.632] Packages needed by future strategies (n = 0): <none>
[13:36:38.632] {
[13:36:38.632]     {
[13:36:38.632]         {
[13:36:38.632]             ...future.startTime <- base::Sys.time()
[13:36:38.632]             {
[13:36:38.632]                 {
[13:36:38.632]                   {
[13:36:38.632]                     {
[13:36:38.632]                       base::local({
[13:36:38.632]                         has_future <- base::requireNamespace("future", 
[13:36:38.632]                           quietly = TRUE)
[13:36:38.632]                         if (has_future) {
[13:36:38.632]                           ns <- base::getNamespace("future")
[13:36:38.632]                           version <- ns[[".package"]][["version"]]
[13:36:38.632]                           if (is.null(version)) 
[13:36:38.632]                             version <- utils::packageVersion("future")
[13:36:38.632]                         }
[13:36:38.632]                         else {
[13:36:38.632]                           version <- NULL
[13:36:38.632]                         }
[13:36:38.632]                         if (!has_future || version < "1.8.0") {
[13:36:38.632]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.632]                             "", base::R.version$version.string), 
[13:36:38.632]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.632]                               "release", "version")], collapse = " "), 
[13:36:38.632]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.632]                             info)
[13:36:38.632]                           info <- base::paste(info, collapse = "; ")
[13:36:38.632]                           if (!has_future) {
[13:36:38.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.632]                               info)
[13:36:38.632]                           }
[13:36:38.632]                           else {
[13:36:38.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.632]                               info, version)
[13:36:38.632]                           }
[13:36:38.632]                           base::stop(msg)
[13:36:38.632]                         }
[13:36:38.632]                       })
[13:36:38.632]                     }
[13:36:38.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.632]                     base::options(mc.cores = 1L)
[13:36:38.632]                   }
[13:36:38.632]                   ...future.strategy.old <- future::plan("list")
[13:36:38.632]                   options(future.plan = NULL)
[13:36:38.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.632]                 }
[13:36:38.632]                 ...future.workdir <- getwd()
[13:36:38.632]             }
[13:36:38.632]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.632]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.632]         }
[13:36:38.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.632]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.632]             base::names(...future.oldOptions))
[13:36:38.632]     }
[13:36:38.632]     if (FALSE) {
[13:36:38.632]     }
[13:36:38.632]     else {
[13:36:38.632]         if (TRUE) {
[13:36:38.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.632]                 open = "w")
[13:36:38.632]         }
[13:36:38.632]         else {
[13:36:38.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.632]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.632]         }
[13:36:38.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.632]             base::sink(type = "output", split = FALSE)
[13:36:38.632]             base::close(...future.stdout)
[13:36:38.632]         }, add = TRUE)
[13:36:38.632]     }
[13:36:38.632]     ...future.frame <- base::sys.nframe()
[13:36:38.632]     ...future.conditions <- base::list()
[13:36:38.632]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.632]     if (FALSE) {
[13:36:38.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.632]     }
[13:36:38.632]     ...future.result <- base::tryCatch({
[13:36:38.632]         base::withCallingHandlers({
[13:36:38.632]             ...future.value <- base::withVisible(base::local({
[13:36:38.632]                 ...future.makeSendCondition <- base::local({
[13:36:38.632]                   sendCondition <- NULL
[13:36:38.632]                   function(frame = 1L) {
[13:36:38.632]                     if (is.function(sendCondition)) 
[13:36:38.632]                       return(sendCondition)
[13:36:38.632]                     ns <- getNamespace("parallel")
[13:36:38.632]                     if (exists("sendData", mode = "function", 
[13:36:38.632]                       envir = ns)) {
[13:36:38.632]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.632]                         envir = ns)
[13:36:38.632]                       envir <- sys.frame(frame)
[13:36:38.632]                       master <- NULL
[13:36:38.632]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.632]                         !identical(envir, emptyenv())) {
[13:36:38.632]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.632]                           inherits = FALSE)) {
[13:36:38.632]                           master <- get("master", mode = "list", 
[13:36:38.632]                             envir = envir, inherits = FALSE)
[13:36:38.632]                           if (inherits(master, c("SOCKnode", 
[13:36:38.632]                             "SOCK0node"))) {
[13:36:38.632]                             sendCondition <<- function(cond) {
[13:36:38.632]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.632]                                 success = TRUE)
[13:36:38.632]                               parallel_sendData(master, data)
[13:36:38.632]                             }
[13:36:38.632]                             return(sendCondition)
[13:36:38.632]                           }
[13:36:38.632]                         }
[13:36:38.632]                         frame <- frame + 1L
[13:36:38.632]                         envir <- sys.frame(frame)
[13:36:38.632]                       }
[13:36:38.632]                     }
[13:36:38.632]                     sendCondition <<- function(cond) NULL
[13:36:38.632]                   }
[13:36:38.632]                 })
[13:36:38.632]                 withCallingHandlers({
[13:36:38.632]                   {
[13:36:38.632]                     4
[13:36:38.632]                   }
[13:36:38.632]                 }, immediateCondition = function(cond) {
[13:36:38.632]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.632]                   sendCondition(cond)
[13:36:38.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.632]                   {
[13:36:38.632]                     inherits <- base::inherits
[13:36:38.632]                     invokeRestart <- base::invokeRestart
[13:36:38.632]                     is.null <- base::is.null
[13:36:38.632]                     muffled <- FALSE
[13:36:38.632]                     if (inherits(cond, "message")) {
[13:36:38.632]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.632]                       if (muffled) 
[13:36:38.632]                         invokeRestart("muffleMessage")
[13:36:38.632]                     }
[13:36:38.632]                     else if (inherits(cond, "warning")) {
[13:36:38.632]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.632]                       if (muffled) 
[13:36:38.632]                         invokeRestart("muffleWarning")
[13:36:38.632]                     }
[13:36:38.632]                     else if (inherits(cond, "condition")) {
[13:36:38.632]                       if (!is.null(pattern)) {
[13:36:38.632]                         computeRestarts <- base::computeRestarts
[13:36:38.632]                         grepl <- base::grepl
[13:36:38.632]                         restarts <- computeRestarts(cond)
[13:36:38.632]                         for (restart in restarts) {
[13:36:38.632]                           name <- restart$name
[13:36:38.632]                           if (is.null(name)) 
[13:36:38.632]                             next
[13:36:38.632]                           if (!grepl(pattern, name)) 
[13:36:38.632]                             next
[13:36:38.632]                           invokeRestart(restart)
[13:36:38.632]                           muffled <- TRUE
[13:36:38.632]                           break
[13:36:38.632]                         }
[13:36:38.632]                       }
[13:36:38.632]                     }
[13:36:38.632]                     invisible(muffled)
[13:36:38.632]                   }
[13:36:38.632]                   muffleCondition(cond)
[13:36:38.632]                 })
[13:36:38.632]             }))
[13:36:38.632]             future::FutureResult(value = ...future.value$value, 
[13:36:38.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.632]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.632]                     ...future.globalenv.names))
[13:36:38.632]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.632]         }, condition = base::local({
[13:36:38.632]             c <- base::c
[13:36:38.632]             inherits <- base::inherits
[13:36:38.632]             invokeRestart <- base::invokeRestart
[13:36:38.632]             length <- base::length
[13:36:38.632]             list <- base::list
[13:36:38.632]             seq.int <- base::seq.int
[13:36:38.632]             signalCondition <- base::signalCondition
[13:36:38.632]             sys.calls <- base::sys.calls
[13:36:38.632]             `[[` <- base::`[[`
[13:36:38.632]             `+` <- base::`+`
[13:36:38.632]             `<<-` <- base::`<<-`
[13:36:38.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.632]                   3L)]
[13:36:38.632]             }
[13:36:38.632]             function(cond) {
[13:36:38.632]                 is_error <- inherits(cond, "error")
[13:36:38.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.632]                   NULL)
[13:36:38.632]                 if (is_error) {
[13:36:38.632]                   sessionInformation <- function() {
[13:36:38.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.632]                       search = base::search(), system = base::Sys.info())
[13:36:38.632]                   }
[13:36:38.632]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.632]                     cond$call), session = sessionInformation(), 
[13:36:38.632]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.632]                   signalCondition(cond)
[13:36:38.632]                 }
[13:36:38.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.632]                 "immediateCondition"))) {
[13:36:38.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.632]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.632]                   if (TRUE && !signal) {
[13:36:38.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.632]                     {
[13:36:38.632]                       inherits <- base::inherits
[13:36:38.632]                       invokeRestart <- base::invokeRestart
[13:36:38.632]                       is.null <- base::is.null
[13:36:38.632]                       muffled <- FALSE
[13:36:38.632]                       if (inherits(cond, "message")) {
[13:36:38.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.632]                         if (muffled) 
[13:36:38.632]                           invokeRestart("muffleMessage")
[13:36:38.632]                       }
[13:36:38.632]                       else if (inherits(cond, "warning")) {
[13:36:38.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.632]                         if (muffled) 
[13:36:38.632]                           invokeRestart("muffleWarning")
[13:36:38.632]                       }
[13:36:38.632]                       else if (inherits(cond, "condition")) {
[13:36:38.632]                         if (!is.null(pattern)) {
[13:36:38.632]                           computeRestarts <- base::computeRestarts
[13:36:38.632]                           grepl <- base::grepl
[13:36:38.632]                           restarts <- computeRestarts(cond)
[13:36:38.632]                           for (restart in restarts) {
[13:36:38.632]                             name <- restart$name
[13:36:38.632]                             if (is.null(name)) 
[13:36:38.632]                               next
[13:36:38.632]                             if (!grepl(pattern, name)) 
[13:36:38.632]                               next
[13:36:38.632]                             invokeRestart(restart)
[13:36:38.632]                             muffled <- TRUE
[13:36:38.632]                             break
[13:36:38.632]                           }
[13:36:38.632]                         }
[13:36:38.632]                       }
[13:36:38.632]                       invisible(muffled)
[13:36:38.632]                     }
[13:36:38.632]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.632]                   }
[13:36:38.632]                 }
[13:36:38.632]                 else {
[13:36:38.632]                   if (TRUE) {
[13:36:38.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.632]                     {
[13:36:38.632]                       inherits <- base::inherits
[13:36:38.632]                       invokeRestart <- base::invokeRestart
[13:36:38.632]                       is.null <- base::is.null
[13:36:38.632]                       muffled <- FALSE
[13:36:38.632]                       if (inherits(cond, "message")) {
[13:36:38.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.632]                         if (muffled) 
[13:36:38.632]                           invokeRestart("muffleMessage")
[13:36:38.632]                       }
[13:36:38.632]                       else if (inherits(cond, "warning")) {
[13:36:38.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.632]                         if (muffled) 
[13:36:38.632]                           invokeRestart("muffleWarning")
[13:36:38.632]                       }
[13:36:38.632]                       else if (inherits(cond, "condition")) {
[13:36:38.632]                         if (!is.null(pattern)) {
[13:36:38.632]                           computeRestarts <- base::computeRestarts
[13:36:38.632]                           grepl <- base::grepl
[13:36:38.632]                           restarts <- computeRestarts(cond)
[13:36:38.632]                           for (restart in restarts) {
[13:36:38.632]                             name <- restart$name
[13:36:38.632]                             if (is.null(name)) 
[13:36:38.632]                               next
[13:36:38.632]                             if (!grepl(pattern, name)) 
[13:36:38.632]                               next
[13:36:38.632]                             invokeRestart(restart)
[13:36:38.632]                             muffled <- TRUE
[13:36:38.632]                             break
[13:36:38.632]                           }
[13:36:38.632]                         }
[13:36:38.632]                       }
[13:36:38.632]                       invisible(muffled)
[13:36:38.632]                     }
[13:36:38.632]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.632]                   }
[13:36:38.632]                 }
[13:36:38.632]             }
[13:36:38.632]         }))
[13:36:38.632]     }, error = function(ex) {
[13:36:38.632]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.632]                 ...future.rng), started = ...future.startTime, 
[13:36:38.632]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.632]             version = "1.8"), class = "FutureResult")
[13:36:38.632]     }, finally = {
[13:36:38.632]         if (!identical(...future.workdir, getwd())) 
[13:36:38.632]             setwd(...future.workdir)
[13:36:38.632]         {
[13:36:38.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.632]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.632]             }
[13:36:38.632]             base::options(...future.oldOptions)
[13:36:38.632]             if (.Platform$OS.type == "windows") {
[13:36:38.632]                 old_names <- names(...future.oldEnvVars)
[13:36:38.632]                 envs <- base::Sys.getenv()
[13:36:38.632]                 names <- names(envs)
[13:36:38.632]                 common <- intersect(names, old_names)
[13:36:38.632]                 added <- setdiff(names, old_names)
[13:36:38.632]                 removed <- setdiff(old_names, names)
[13:36:38.632]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.632]                   envs[common]]
[13:36:38.632]                 NAMES <- toupper(changed)
[13:36:38.632]                 args <- list()
[13:36:38.632]                 for (kk in seq_along(NAMES)) {
[13:36:38.632]                   name <- changed[[kk]]
[13:36:38.632]                   NAME <- NAMES[[kk]]
[13:36:38.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.632]                     next
[13:36:38.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.632]                 }
[13:36:38.632]                 NAMES <- toupper(added)
[13:36:38.632]                 for (kk in seq_along(NAMES)) {
[13:36:38.632]                   name <- added[[kk]]
[13:36:38.632]                   NAME <- NAMES[[kk]]
[13:36:38.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.632]                     next
[13:36:38.632]                   args[[name]] <- ""
[13:36:38.632]                 }
[13:36:38.632]                 NAMES <- toupper(removed)
[13:36:38.632]                 for (kk in seq_along(NAMES)) {
[13:36:38.632]                   name <- removed[[kk]]
[13:36:38.632]                   NAME <- NAMES[[kk]]
[13:36:38.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.632]                     next
[13:36:38.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.632]                 }
[13:36:38.632]                 if (length(args) > 0) 
[13:36:38.632]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.632]             }
[13:36:38.632]             else {
[13:36:38.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.632]             }
[13:36:38.632]             {
[13:36:38.632]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.632]                   0L) {
[13:36:38.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.632]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.632]                   base::options(opts)
[13:36:38.632]                 }
[13:36:38.632]                 {
[13:36:38.632]                   {
[13:36:38.632]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.632]                     NULL
[13:36:38.632]                   }
[13:36:38.632]                   options(future.plan = NULL)
[13:36:38.632]                   if (is.na(NA_character_)) 
[13:36:38.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.632]                     .init = FALSE)
[13:36:38.632]                 }
[13:36:38.632]             }
[13:36:38.632]         }
[13:36:38.632]     })
[13:36:38.632]     if (TRUE) {
[13:36:38.632]         base::sink(type = "output", split = FALSE)
[13:36:38.632]         if (TRUE) {
[13:36:38.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.632]         }
[13:36:38.632]         else {
[13:36:38.632]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.632]         }
[13:36:38.632]         base::close(...future.stdout)
[13:36:38.632]         ...future.stdout <- NULL
[13:36:38.632]     }
[13:36:38.632]     ...future.result$conditions <- ...future.conditions
[13:36:38.632]     ...future.result$finished <- base::Sys.time()
[13:36:38.632]     ...future.result
[13:36:38.632] }
[13:36:38.634] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:38.645] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.645] - Validating connection of MultisessionFuture
[13:36:38.645] - received message: FutureResult
[13:36:38.646] - Received FutureResult
[13:36:38.646] - Erased future from FutureRegistry
[13:36:38.646] result() for ClusterFuture ...
[13:36:38.646] - result already collected: FutureResult
[13:36:38.646] result() for ClusterFuture ... done
[13:36:38.646] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.646] result() for ClusterFuture ...
[13:36:38.646] - result already collected: FutureResult
[13:36:38.646] result() for ClusterFuture ... done
[13:36:38.647] result() for ClusterFuture ...
[13:36:38.647] - result already collected: FutureResult
[13:36:38.647] result() for ClusterFuture ... done
[13:36:38.648] MultisessionFuture started
[13:36:38.648] - Launch lazy future ... done
[13:36:38.648] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a74a78228> 
Classes 'listenv', 'environment' <environment: 0x564a73017190> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:36:38.652] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.652] - Validating connection of MultisessionFuture
[13:36:38.652] - received message: FutureResult
[13:36:38.652] - Received FutureResult
[13:36:38.652] - Erased future from FutureRegistry
[13:36:38.653] result() for ClusterFuture ...
[13:36:38.653] - result already collected: FutureResult
[13:36:38.653] result() for ClusterFuture ... done
[13:36:38.653] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.653] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.653] - Validating connection of MultisessionFuture
[13:36:38.653] - received message: FutureResult
[13:36:38.654] - Received FutureResult
[13:36:38.654] - Erased future from FutureRegistry
[13:36:38.654] result() for ClusterFuture ...
[13:36:38.654] - result already collected: FutureResult
[13:36:38.654] result() for ClusterFuture ... done
[13:36:38.654] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:38.656] resolve() on list environment ...
[13:36:38.656]  recursive: 0
[13:36:38.657]  length: 6
[13:36:38.658]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:38.658] signalConditionsASAP(numeric, pos=1) ...
[13:36:38.658] - nx: 6
[13:36:38.658] - relay: TRUE
[13:36:38.658] - stdout: TRUE
[13:36:38.658] - signal: TRUE
[13:36:38.658] - resignal: FALSE
[13:36:38.658] - force: TRUE
[13:36:38.658] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.658] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.659]  - until=2
[13:36:38.659]  - relaying element #2
[13:36:38.659] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.659] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.659] signalConditionsASAP(NULL, pos=1) ... done
[13:36:38.659]  length: 5 (resolved future 1)
[13:36:38.659] Future #2
[13:36:38.659] result() for ClusterFuture ...
[13:36:38.659] - result already collected: FutureResult
[13:36:38.659] result() for ClusterFuture ... done
[13:36:38.659] result() for ClusterFuture ...
[13:36:38.660] - result already collected: FutureResult
[13:36:38.660] result() for ClusterFuture ... done
[13:36:38.660] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:38.660] - nx: 6
[13:36:38.660] - relay: TRUE
[13:36:38.660] - stdout: TRUE
[13:36:38.660] - signal: TRUE
[13:36:38.660] - resignal: FALSE
[13:36:38.660] - force: TRUE
[13:36:38.660] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.660] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.661]  - until=2
[13:36:38.661]  - relaying element #2
[13:36:38.661] result() for ClusterFuture ...
[13:36:38.661] - result already collected: FutureResult
[13:36:38.661] result() for ClusterFuture ... done
[13:36:38.661] result() for ClusterFuture ...
[13:36:38.661] - result already collected: FutureResult
[13:36:38.661] result() for ClusterFuture ... done
[13:36:38.661] result() for ClusterFuture ...
[13:36:38.661] - result already collected: FutureResult
[13:36:38.661] result() for ClusterFuture ... done
[13:36:38.662] result() for ClusterFuture ...
[13:36:38.662] - result already collected: FutureResult
[13:36:38.662] result() for ClusterFuture ... done
[13:36:38.662] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.662] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.662] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:38.662]  length: 4 (resolved future 2)
[13:36:38.662] Future #3
[13:36:38.662] result() for ClusterFuture ...
[13:36:38.662] - result already collected: FutureResult
[13:36:38.663] result() for ClusterFuture ... done
[13:36:38.663] result() for ClusterFuture ...
[13:36:38.663] - result already collected: FutureResult
[13:36:38.663] result() for ClusterFuture ... done
[13:36:38.663] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:38.663] - nx: 6
[13:36:38.663] - relay: TRUE
[13:36:38.663] - stdout: TRUE
[13:36:38.663] - signal: TRUE
[13:36:38.663] - resignal: FALSE
[13:36:38.663] - force: TRUE
[13:36:38.664] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.664] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.664]  - until=3
[13:36:38.664]  - relaying element #3
[13:36:38.664] result() for ClusterFuture ...
[13:36:38.664] - result already collected: FutureResult
[13:36:38.664] result() for ClusterFuture ... done
[13:36:38.664] result() for ClusterFuture ...
[13:36:38.664] - result already collected: FutureResult
[13:36:38.664] result() for ClusterFuture ... done
[13:36:38.664] result() for ClusterFuture ...
[13:36:38.665] - result already collected: FutureResult
[13:36:38.665] result() for ClusterFuture ... done
[13:36:38.665] result() for ClusterFuture ...
[13:36:38.665] - result already collected: FutureResult
[13:36:38.665] result() for ClusterFuture ... done
[13:36:38.665] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.665] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.665] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:38.665]  length: 3 (resolved future 3)
[13:36:38.665] Future #4
[13:36:38.665] result() for ClusterFuture ...
[13:36:38.666] - result already collected: FutureResult
[13:36:38.666] result() for ClusterFuture ... done
[13:36:38.666] result() for ClusterFuture ...
[13:36:38.666] - result already collected: FutureResult
[13:36:38.666] result() for ClusterFuture ... done
[13:36:38.666] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:38.666] - nx: 6
[13:36:38.666] - relay: TRUE
[13:36:38.666] - stdout: TRUE
[13:36:38.666] - signal: TRUE
[13:36:38.666] - resignal: FALSE
[13:36:38.667] - force: TRUE
[13:36:38.667] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.667] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.667]  - until=4
[13:36:38.667]  - relaying element #4
[13:36:38.667] result() for ClusterFuture ...
[13:36:38.667] - result already collected: FutureResult
[13:36:38.667] result() for ClusterFuture ... done
[13:36:38.667] result() for ClusterFuture ...
[13:36:38.667] - result already collected: FutureResult
[13:36:38.667] result() for ClusterFuture ... done
[13:36:38.668] result() for ClusterFuture ...
[13:36:38.668] - result already collected: FutureResult
[13:36:38.668] result() for ClusterFuture ... done
[13:36:38.668] result() for ClusterFuture ...
[13:36:38.668] - result already collected: FutureResult
[13:36:38.668] result() for ClusterFuture ... done
[13:36:38.668] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.668] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.668] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:38.668]  length: 2 (resolved future 4)
[13:36:38.668] signalConditionsASAP(NULL, pos=5) ...
[13:36:38.669] - nx: 6
[13:36:38.669] - relay: TRUE
[13:36:38.669] - stdout: TRUE
[13:36:38.669] - signal: TRUE
[13:36:38.669] - resignal: FALSE
[13:36:38.669] - force: TRUE
[13:36:38.669] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.669] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.669]  - until=6
[13:36:38.669]  - relaying element #6
[13:36:38.669] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.669] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.670] signalConditionsASAP(NULL, pos=5) ... done
[13:36:38.670]  length: 1 (resolved future 5)
[13:36:38.670] signalConditionsASAP(numeric, pos=6) ...
[13:36:38.670] - nx: 6
[13:36:38.670] - relay: TRUE
[13:36:38.670] - stdout: TRUE
[13:36:38.670] - signal: TRUE
[13:36:38.670] - resignal: FALSE
[13:36:38.670] - force: TRUE
[13:36:38.670] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.670] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.671]  - until=6
[13:36:38.671] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.671] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.671] signalConditionsASAP(numeric, pos=6) ... done
[13:36:38.671]  length: 0 (resolved future 6)
[13:36:38.671] Relaying remaining futures
[13:36:38.671] signalConditionsASAP(NULL, pos=0) ...
[13:36:38.671] - nx: 6
[13:36:38.671] - relay: TRUE
[13:36:38.671] - stdout: TRUE
[13:36:38.671] - signal: TRUE
[13:36:38.671] - resignal: FALSE
[13:36:38.672] - force: TRUE
[13:36:38.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.672] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:38.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.672] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.672] signalConditionsASAP(NULL, pos=0) ... done
[13:36:38.672] resolve() on list environment ... DONE
[13:36:38.672] result() for ClusterFuture ...
[13:36:38.672] - result already collected: FutureResult
[13:36:38.672] result() for ClusterFuture ... done
[13:36:38.673] result() for ClusterFuture ...
[13:36:38.673] - result already collected: FutureResult
[13:36:38.673] result() for ClusterFuture ... done
[13:36:38.673] result() for ClusterFuture ...
[13:36:38.673] - result already collected: FutureResult
[13:36:38.673] result() for ClusterFuture ... done
[13:36:38.673] result() for ClusterFuture ...
[13:36:38.673] - result already collected: FutureResult
[13:36:38.673] result() for ClusterFuture ... done
[13:36:38.674] result() for ClusterFuture ...
[13:36:38.674] - result already collected: FutureResult
[13:36:38.674] result() for ClusterFuture ... done
[13:36:38.674] result() for ClusterFuture ...
[13:36:38.674] - result already collected: FutureResult
[13:36:38.674] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a7262ed58> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:36:38.676] getGlobalsAndPackages() ...
[13:36:38.676] Searching for globals...
[13:36:38.676] 
[13:36:38.676] Searching for globals ... DONE
[13:36:38.676] - globals: [0] <none>
[13:36:38.676] getGlobalsAndPackages() ... DONE
[13:36:38.677] run() for ‘Future’ ...
[13:36:38.677] - state: ‘created’
[13:36:38.677] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.690] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.691]   - Field: ‘node’
[13:36:38.691]   - Field: ‘label’
[13:36:38.691]   - Field: ‘local’
[13:36:38.691]   - Field: ‘owner’
[13:36:38.691]   - Field: ‘envir’
[13:36:38.691]   - Field: ‘workers’
[13:36:38.691]   - Field: ‘packages’
[13:36:38.691]   - Field: ‘gc’
[13:36:38.691]   - Field: ‘conditions’
[13:36:38.692]   - Field: ‘persistent’
[13:36:38.692]   - Field: ‘expr’
[13:36:38.692]   - Field: ‘uuid’
[13:36:38.692]   - Field: ‘seed’
[13:36:38.692]   - Field: ‘version’
[13:36:38.692]   - Field: ‘result’
[13:36:38.692]   - Field: ‘asynchronous’
[13:36:38.692]   - Field: ‘calls’
[13:36:38.692]   - Field: ‘globals’
[13:36:38.692]   - Field: ‘stdout’
[13:36:38.693]   - Field: ‘earlySignal’
[13:36:38.693]   - Field: ‘lazy’
[13:36:38.693]   - Field: ‘state’
[13:36:38.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.693] - Launch lazy future ...
[13:36:38.693] Packages needed by the future expression (n = 0): <none>
[13:36:38.693] Packages needed by future strategies (n = 0): <none>
[13:36:38.694] {
[13:36:38.694]     {
[13:36:38.694]         {
[13:36:38.694]             ...future.startTime <- base::Sys.time()
[13:36:38.694]             {
[13:36:38.694]                 {
[13:36:38.694]                   {
[13:36:38.694]                     {
[13:36:38.694]                       base::local({
[13:36:38.694]                         has_future <- base::requireNamespace("future", 
[13:36:38.694]                           quietly = TRUE)
[13:36:38.694]                         if (has_future) {
[13:36:38.694]                           ns <- base::getNamespace("future")
[13:36:38.694]                           version <- ns[[".package"]][["version"]]
[13:36:38.694]                           if (is.null(version)) 
[13:36:38.694]                             version <- utils::packageVersion("future")
[13:36:38.694]                         }
[13:36:38.694]                         else {
[13:36:38.694]                           version <- NULL
[13:36:38.694]                         }
[13:36:38.694]                         if (!has_future || version < "1.8.0") {
[13:36:38.694]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.694]                             "", base::R.version$version.string), 
[13:36:38.694]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.694]                               "release", "version")], collapse = " "), 
[13:36:38.694]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.694]                             info)
[13:36:38.694]                           info <- base::paste(info, collapse = "; ")
[13:36:38.694]                           if (!has_future) {
[13:36:38.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.694]                               info)
[13:36:38.694]                           }
[13:36:38.694]                           else {
[13:36:38.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.694]                               info, version)
[13:36:38.694]                           }
[13:36:38.694]                           base::stop(msg)
[13:36:38.694]                         }
[13:36:38.694]                       })
[13:36:38.694]                     }
[13:36:38.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.694]                     base::options(mc.cores = 1L)
[13:36:38.694]                   }
[13:36:38.694]                   ...future.strategy.old <- future::plan("list")
[13:36:38.694]                   options(future.plan = NULL)
[13:36:38.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.694]                 }
[13:36:38.694]                 ...future.workdir <- getwd()
[13:36:38.694]             }
[13:36:38.694]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.694]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.694]         }
[13:36:38.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.694]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.694]             base::names(...future.oldOptions))
[13:36:38.694]     }
[13:36:38.694]     if (FALSE) {
[13:36:38.694]     }
[13:36:38.694]     else {
[13:36:38.694]         if (TRUE) {
[13:36:38.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.694]                 open = "w")
[13:36:38.694]         }
[13:36:38.694]         else {
[13:36:38.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.694]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.694]         }
[13:36:38.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.694]             base::sink(type = "output", split = FALSE)
[13:36:38.694]             base::close(...future.stdout)
[13:36:38.694]         }, add = TRUE)
[13:36:38.694]     }
[13:36:38.694]     ...future.frame <- base::sys.nframe()
[13:36:38.694]     ...future.conditions <- base::list()
[13:36:38.694]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.694]     if (FALSE) {
[13:36:38.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.694]     }
[13:36:38.694]     ...future.result <- base::tryCatch({
[13:36:38.694]         base::withCallingHandlers({
[13:36:38.694]             ...future.value <- base::withVisible(base::local({
[13:36:38.694]                 ...future.makeSendCondition <- base::local({
[13:36:38.694]                   sendCondition <- NULL
[13:36:38.694]                   function(frame = 1L) {
[13:36:38.694]                     if (is.function(sendCondition)) 
[13:36:38.694]                       return(sendCondition)
[13:36:38.694]                     ns <- getNamespace("parallel")
[13:36:38.694]                     if (exists("sendData", mode = "function", 
[13:36:38.694]                       envir = ns)) {
[13:36:38.694]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.694]                         envir = ns)
[13:36:38.694]                       envir <- sys.frame(frame)
[13:36:38.694]                       master <- NULL
[13:36:38.694]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.694]                         !identical(envir, emptyenv())) {
[13:36:38.694]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.694]                           inherits = FALSE)) {
[13:36:38.694]                           master <- get("master", mode = "list", 
[13:36:38.694]                             envir = envir, inherits = FALSE)
[13:36:38.694]                           if (inherits(master, c("SOCKnode", 
[13:36:38.694]                             "SOCK0node"))) {
[13:36:38.694]                             sendCondition <<- function(cond) {
[13:36:38.694]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.694]                                 success = TRUE)
[13:36:38.694]                               parallel_sendData(master, data)
[13:36:38.694]                             }
[13:36:38.694]                             return(sendCondition)
[13:36:38.694]                           }
[13:36:38.694]                         }
[13:36:38.694]                         frame <- frame + 1L
[13:36:38.694]                         envir <- sys.frame(frame)
[13:36:38.694]                       }
[13:36:38.694]                     }
[13:36:38.694]                     sendCondition <<- function(cond) NULL
[13:36:38.694]                   }
[13:36:38.694]                 })
[13:36:38.694]                 withCallingHandlers({
[13:36:38.694]                   2
[13:36:38.694]                 }, immediateCondition = function(cond) {
[13:36:38.694]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.694]                   sendCondition(cond)
[13:36:38.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.694]                   {
[13:36:38.694]                     inherits <- base::inherits
[13:36:38.694]                     invokeRestart <- base::invokeRestart
[13:36:38.694]                     is.null <- base::is.null
[13:36:38.694]                     muffled <- FALSE
[13:36:38.694]                     if (inherits(cond, "message")) {
[13:36:38.694]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.694]                       if (muffled) 
[13:36:38.694]                         invokeRestart("muffleMessage")
[13:36:38.694]                     }
[13:36:38.694]                     else if (inherits(cond, "warning")) {
[13:36:38.694]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.694]                       if (muffled) 
[13:36:38.694]                         invokeRestart("muffleWarning")
[13:36:38.694]                     }
[13:36:38.694]                     else if (inherits(cond, "condition")) {
[13:36:38.694]                       if (!is.null(pattern)) {
[13:36:38.694]                         computeRestarts <- base::computeRestarts
[13:36:38.694]                         grepl <- base::grepl
[13:36:38.694]                         restarts <- computeRestarts(cond)
[13:36:38.694]                         for (restart in restarts) {
[13:36:38.694]                           name <- restart$name
[13:36:38.694]                           if (is.null(name)) 
[13:36:38.694]                             next
[13:36:38.694]                           if (!grepl(pattern, name)) 
[13:36:38.694]                             next
[13:36:38.694]                           invokeRestart(restart)
[13:36:38.694]                           muffled <- TRUE
[13:36:38.694]                           break
[13:36:38.694]                         }
[13:36:38.694]                       }
[13:36:38.694]                     }
[13:36:38.694]                     invisible(muffled)
[13:36:38.694]                   }
[13:36:38.694]                   muffleCondition(cond)
[13:36:38.694]                 })
[13:36:38.694]             }))
[13:36:38.694]             future::FutureResult(value = ...future.value$value, 
[13:36:38.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.694]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.694]                     ...future.globalenv.names))
[13:36:38.694]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.694]         }, condition = base::local({
[13:36:38.694]             c <- base::c
[13:36:38.694]             inherits <- base::inherits
[13:36:38.694]             invokeRestart <- base::invokeRestart
[13:36:38.694]             length <- base::length
[13:36:38.694]             list <- base::list
[13:36:38.694]             seq.int <- base::seq.int
[13:36:38.694]             signalCondition <- base::signalCondition
[13:36:38.694]             sys.calls <- base::sys.calls
[13:36:38.694]             `[[` <- base::`[[`
[13:36:38.694]             `+` <- base::`+`
[13:36:38.694]             `<<-` <- base::`<<-`
[13:36:38.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.694]                   3L)]
[13:36:38.694]             }
[13:36:38.694]             function(cond) {
[13:36:38.694]                 is_error <- inherits(cond, "error")
[13:36:38.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.694]                   NULL)
[13:36:38.694]                 if (is_error) {
[13:36:38.694]                   sessionInformation <- function() {
[13:36:38.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.694]                       search = base::search(), system = base::Sys.info())
[13:36:38.694]                   }
[13:36:38.694]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.694]                     cond$call), session = sessionInformation(), 
[13:36:38.694]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.694]                   signalCondition(cond)
[13:36:38.694]                 }
[13:36:38.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.694]                 "immediateCondition"))) {
[13:36:38.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.694]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.694]                   if (TRUE && !signal) {
[13:36:38.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.694]                     {
[13:36:38.694]                       inherits <- base::inherits
[13:36:38.694]                       invokeRestart <- base::invokeRestart
[13:36:38.694]                       is.null <- base::is.null
[13:36:38.694]                       muffled <- FALSE
[13:36:38.694]                       if (inherits(cond, "message")) {
[13:36:38.694]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.694]                         if (muffled) 
[13:36:38.694]                           invokeRestart("muffleMessage")
[13:36:38.694]                       }
[13:36:38.694]                       else if (inherits(cond, "warning")) {
[13:36:38.694]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.694]                         if (muffled) 
[13:36:38.694]                           invokeRestart("muffleWarning")
[13:36:38.694]                       }
[13:36:38.694]                       else if (inherits(cond, "condition")) {
[13:36:38.694]                         if (!is.null(pattern)) {
[13:36:38.694]                           computeRestarts <- base::computeRestarts
[13:36:38.694]                           grepl <- base::grepl
[13:36:38.694]                           restarts <- computeRestarts(cond)
[13:36:38.694]                           for (restart in restarts) {
[13:36:38.694]                             name <- restart$name
[13:36:38.694]                             if (is.null(name)) 
[13:36:38.694]                               next
[13:36:38.694]                             if (!grepl(pattern, name)) 
[13:36:38.694]                               next
[13:36:38.694]                             invokeRestart(restart)
[13:36:38.694]                             muffled <- TRUE
[13:36:38.694]                             break
[13:36:38.694]                           }
[13:36:38.694]                         }
[13:36:38.694]                       }
[13:36:38.694]                       invisible(muffled)
[13:36:38.694]                     }
[13:36:38.694]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.694]                   }
[13:36:38.694]                 }
[13:36:38.694]                 else {
[13:36:38.694]                   if (TRUE) {
[13:36:38.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.694]                     {
[13:36:38.694]                       inherits <- base::inherits
[13:36:38.694]                       invokeRestart <- base::invokeRestart
[13:36:38.694]                       is.null <- base::is.null
[13:36:38.694]                       muffled <- FALSE
[13:36:38.694]                       if (inherits(cond, "message")) {
[13:36:38.694]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.694]                         if (muffled) 
[13:36:38.694]                           invokeRestart("muffleMessage")
[13:36:38.694]                       }
[13:36:38.694]                       else if (inherits(cond, "warning")) {
[13:36:38.694]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.694]                         if (muffled) 
[13:36:38.694]                           invokeRestart("muffleWarning")
[13:36:38.694]                       }
[13:36:38.694]                       else if (inherits(cond, "condition")) {
[13:36:38.694]                         if (!is.null(pattern)) {
[13:36:38.694]                           computeRestarts <- base::computeRestarts
[13:36:38.694]                           grepl <- base::grepl
[13:36:38.694]                           restarts <- computeRestarts(cond)
[13:36:38.694]                           for (restart in restarts) {
[13:36:38.694]                             name <- restart$name
[13:36:38.694]                             if (is.null(name)) 
[13:36:38.694]                               next
[13:36:38.694]                             if (!grepl(pattern, name)) 
[13:36:38.694]                               next
[13:36:38.694]                             invokeRestart(restart)
[13:36:38.694]                             muffled <- TRUE
[13:36:38.694]                             break
[13:36:38.694]                           }
[13:36:38.694]                         }
[13:36:38.694]                       }
[13:36:38.694]                       invisible(muffled)
[13:36:38.694]                     }
[13:36:38.694]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.694]                   }
[13:36:38.694]                 }
[13:36:38.694]             }
[13:36:38.694]         }))
[13:36:38.694]     }, error = function(ex) {
[13:36:38.694]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.694]                 ...future.rng), started = ...future.startTime, 
[13:36:38.694]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.694]             version = "1.8"), class = "FutureResult")
[13:36:38.694]     }, finally = {
[13:36:38.694]         if (!identical(...future.workdir, getwd())) 
[13:36:38.694]             setwd(...future.workdir)
[13:36:38.694]         {
[13:36:38.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.694]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.694]             }
[13:36:38.694]             base::options(...future.oldOptions)
[13:36:38.694]             if (.Platform$OS.type == "windows") {
[13:36:38.694]                 old_names <- names(...future.oldEnvVars)
[13:36:38.694]                 envs <- base::Sys.getenv()
[13:36:38.694]                 names <- names(envs)
[13:36:38.694]                 common <- intersect(names, old_names)
[13:36:38.694]                 added <- setdiff(names, old_names)
[13:36:38.694]                 removed <- setdiff(old_names, names)
[13:36:38.694]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.694]                   envs[common]]
[13:36:38.694]                 NAMES <- toupper(changed)
[13:36:38.694]                 args <- list()
[13:36:38.694]                 for (kk in seq_along(NAMES)) {
[13:36:38.694]                   name <- changed[[kk]]
[13:36:38.694]                   NAME <- NAMES[[kk]]
[13:36:38.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.694]                     next
[13:36:38.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.694]                 }
[13:36:38.694]                 NAMES <- toupper(added)
[13:36:38.694]                 for (kk in seq_along(NAMES)) {
[13:36:38.694]                   name <- added[[kk]]
[13:36:38.694]                   NAME <- NAMES[[kk]]
[13:36:38.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.694]                     next
[13:36:38.694]                   args[[name]] <- ""
[13:36:38.694]                 }
[13:36:38.694]                 NAMES <- toupper(removed)
[13:36:38.694]                 for (kk in seq_along(NAMES)) {
[13:36:38.694]                   name <- removed[[kk]]
[13:36:38.694]                   NAME <- NAMES[[kk]]
[13:36:38.694]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.694]                     next
[13:36:38.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.694]                 }
[13:36:38.694]                 if (length(args) > 0) 
[13:36:38.694]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.694]             }
[13:36:38.694]             else {
[13:36:38.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.694]             }
[13:36:38.694]             {
[13:36:38.694]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.694]                   0L) {
[13:36:38.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.694]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.694]                   base::options(opts)
[13:36:38.694]                 }
[13:36:38.694]                 {
[13:36:38.694]                   {
[13:36:38.694]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.694]                     NULL
[13:36:38.694]                   }
[13:36:38.694]                   options(future.plan = NULL)
[13:36:38.694]                   if (is.na(NA_character_)) 
[13:36:38.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.694]                     .init = FALSE)
[13:36:38.694]                 }
[13:36:38.694]             }
[13:36:38.694]         }
[13:36:38.694]     })
[13:36:38.694]     if (TRUE) {
[13:36:38.694]         base::sink(type = "output", split = FALSE)
[13:36:38.694]         if (TRUE) {
[13:36:38.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.694]         }
[13:36:38.694]         else {
[13:36:38.694]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.694]         }
[13:36:38.694]         base::close(...future.stdout)
[13:36:38.694]         ...future.stdout <- NULL
[13:36:38.694]     }
[13:36:38.694]     ...future.result$conditions <- ...future.conditions
[13:36:38.694]     ...future.result$finished <- base::Sys.time()
[13:36:38.694]     ...future.result
[13:36:38.694] }
[13:36:38.696] MultisessionFuture started
[13:36:38.697] - Launch lazy future ... done
[13:36:38.697] run() for ‘MultisessionFuture’ ... done
[13:36:38.697] getGlobalsAndPackages() ...
[13:36:38.697] Searching for globals...
[13:36:38.697] 
[13:36:38.697] Searching for globals ... DONE
[13:36:38.697] - globals: [0] <none>
[13:36:38.698] getGlobalsAndPackages() ... DONE
[13:36:38.698] run() for ‘Future’ ...
[13:36:38.698] - state: ‘created’
[13:36:38.698] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.712]   - Field: ‘node’
[13:36:38.712]   - Field: ‘label’
[13:36:38.712]   - Field: ‘local’
[13:36:38.712]   - Field: ‘owner’
[13:36:38.712]   - Field: ‘envir’
[13:36:38.712]   - Field: ‘workers’
[13:36:38.712]   - Field: ‘packages’
[13:36:38.712]   - Field: ‘gc’
[13:36:38.712]   - Field: ‘conditions’
[13:36:38.712]   - Field: ‘persistent’
[13:36:38.712]   - Field: ‘expr’
[13:36:38.713]   - Field: ‘uuid’
[13:36:38.713]   - Field: ‘seed’
[13:36:38.713]   - Field: ‘version’
[13:36:38.713]   - Field: ‘result’
[13:36:38.713]   - Field: ‘asynchronous’
[13:36:38.713]   - Field: ‘calls’
[13:36:38.713]   - Field: ‘globals’
[13:36:38.713]   - Field: ‘stdout’
[13:36:38.713]   - Field: ‘earlySignal’
[13:36:38.713]   - Field: ‘lazy’
[13:36:38.713]   - Field: ‘state’
[13:36:38.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.714] - Launch lazy future ...
[13:36:38.714] Packages needed by the future expression (n = 0): <none>
[13:36:38.714] Packages needed by future strategies (n = 0): <none>
[13:36:38.714] {
[13:36:38.714]     {
[13:36:38.714]         {
[13:36:38.714]             ...future.startTime <- base::Sys.time()
[13:36:38.714]             {
[13:36:38.714]                 {
[13:36:38.714]                   {
[13:36:38.714]                     {
[13:36:38.714]                       base::local({
[13:36:38.714]                         has_future <- base::requireNamespace("future", 
[13:36:38.714]                           quietly = TRUE)
[13:36:38.714]                         if (has_future) {
[13:36:38.714]                           ns <- base::getNamespace("future")
[13:36:38.714]                           version <- ns[[".package"]][["version"]]
[13:36:38.714]                           if (is.null(version)) 
[13:36:38.714]                             version <- utils::packageVersion("future")
[13:36:38.714]                         }
[13:36:38.714]                         else {
[13:36:38.714]                           version <- NULL
[13:36:38.714]                         }
[13:36:38.714]                         if (!has_future || version < "1.8.0") {
[13:36:38.714]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.714]                             "", base::R.version$version.string), 
[13:36:38.714]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.714]                               "release", "version")], collapse = " "), 
[13:36:38.714]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.714]                             info)
[13:36:38.714]                           info <- base::paste(info, collapse = "; ")
[13:36:38.714]                           if (!has_future) {
[13:36:38.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.714]                               info)
[13:36:38.714]                           }
[13:36:38.714]                           else {
[13:36:38.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.714]                               info, version)
[13:36:38.714]                           }
[13:36:38.714]                           base::stop(msg)
[13:36:38.714]                         }
[13:36:38.714]                       })
[13:36:38.714]                     }
[13:36:38.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.714]                     base::options(mc.cores = 1L)
[13:36:38.714]                   }
[13:36:38.714]                   ...future.strategy.old <- future::plan("list")
[13:36:38.714]                   options(future.plan = NULL)
[13:36:38.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.714]                 }
[13:36:38.714]                 ...future.workdir <- getwd()
[13:36:38.714]             }
[13:36:38.714]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.714]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.714]         }
[13:36:38.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.714]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.714]             base::names(...future.oldOptions))
[13:36:38.714]     }
[13:36:38.714]     if (FALSE) {
[13:36:38.714]     }
[13:36:38.714]     else {
[13:36:38.714]         if (TRUE) {
[13:36:38.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.714]                 open = "w")
[13:36:38.714]         }
[13:36:38.714]         else {
[13:36:38.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.714]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.714]         }
[13:36:38.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.714]             base::sink(type = "output", split = FALSE)
[13:36:38.714]             base::close(...future.stdout)
[13:36:38.714]         }, add = TRUE)
[13:36:38.714]     }
[13:36:38.714]     ...future.frame <- base::sys.nframe()
[13:36:38.714]     ...future.conditions <- base::list()
[13:36:38.714]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.714]     if (FALSE) {
[13:36:38.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.714]     }
[13:36:38.714]     ...future.result <- base::tryCatch({
[13:36:38.714]         base::withCallingHandlers({
[13:36:38.714]             ...future.value <- base::withVisible(base::local({
[13:36:38.714]                 ...future.makeSendCondition <- base::local({
[13:36:38.714]                   sendCondition <- NULL
[13:36:38.714]                   function(frame = 1L) {
[13:36:38.714]                     if (is.function(sendCondition)) 
[13:36:38.714]                       return(sendCondition)
[13:36:38.714]                     ns <- getNamespace("parallel")
[13:36:38.714]                     if (exists("sendData", mode = "function", 
[13:36:38.714]                       envir = ns)) {
[13:36:38.714]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.714]                         envir = ns)
[13:36:38.714]                       envir <- sys.frame(frame)
[13:36:38.714]                       master <- NULL
[13:36:38.714]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.714]                         !identical(envir, emptyenv())) {
[13:36:38.714]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.714]                           inherits = FALSE)) {
[13:36:38.714]                           master <- get("master", mode = "list", 
[13:36:38.714]                             envir = envir, inherits = FALSE)
[13:36:38.714]                           if (inherits(master, c("SOCKnode", 
[13:36:38.714]                             "SOCK0node"))) {
[13:36:38.714]                             sendCondition <<- function(cond) {
[13:36:38.714]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.714]                                 success = TRUE)
[13:36:38.714]                               parallel_sendData(master, data)
[13:36:38.714]                             }
[13:36:38.714]                             return(sendCondition)
[13:36:38.714]                           }
[13:36:38.714]                         }
[13:36:38.714]                         frame <- frame + 1L
[13:36:38.714]                         envir <- sys.frame(frame)
[13:36:38.714]                       }
[13:36:38.714]                     }
[13:36:38.714]                     sendCondition <<- function(cond) NULL
[13:36:38.714]                   }
[13:36:38.714]                 })
[13:36:38.714]                 withCallingHandlers({
[13:36:38.714]                   NULL
[13:36:38.714]                 }, immediateCondition = function(cond) {
[13:36:38.714]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.714]                   sendCondition(cond)
[13:36:38.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.714]                   {
[13:36:38.714]                     inherits <- base::inherits
[13:36:38.714]                     invokeRestart <- base::invokeRestart
[13:36:38.714]                     is.null <- base::is.null
[13:36:38.714]                     muffled <- FALSE
[13:36:38.714]                     if (inherits(cond, "message")) {
[13:36:38.714]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.714]                       if (muffled) 
[13:36:38.714]                         invokeRestart("muffleMessage")
[13:36:38.714]                     }
[13:36:38.714]                     else if (inherits(cond, "warning")) {
[13:36:38.714]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.714]                       if (muffled) 
[13:36:38.714]                         invokeRestart("muffleWarning")
[13:36:38.714]                     }
[13:36:38.714]                     else if (inherits(cond, "condition")) {
[13:36:38.714]                       if (!is.null(pattern)) {
[13:36:38.714]                         computeRestarts <- base::computeRestarts
[13:36:38.714]                         grepl <- base::grepl
[13:36:38.714]                         restarts <- computeRestarts(cond)
[13:36:38.714]                         for (restart in restarts) {
[13:36:38.714]                           name <- restart$name
[13:36:38.714]                           if (is.null(name)) 
[13:36:38.714]                             next
[13:36:38.714]                           if (!grepl(pattern, name)) 
[13:36:38.714]                             next
[13:36:38.714]                           invokeRestart(restart)
[13:36:38.714]                           muffled <- TRUE
[13:36:38.714]                           break
[13:36:38.714]                         }
[13:36:38.714]                       }
[13:36:38.714]                     }
[13:36:38.714]                     invisible(muffled)
[13:36:38.714]                   }
[13:36:38.714]                   muffleCondition(cond)
[13:36:38.714]                 })
[13:36:38.714]             }))
[13:36:38.714]             future::FutureResult(value = ...future.value$value, 
[13:36:38.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.714]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.714]                     ...future.globalenv.names))
[13:36:38.714]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.714]         }, condition = base::local({
[13:36:38.714]             c <- base::c
[13:36:38.714]             inherits <- base::inherits
[13:36:38.714]             invokeRestart <- base::invokeRestart
[13:36:38.714]             length <- base::length
[13:36:38.714]             list <- base::list
[13:36:38.714]             seq.int <- base::seq.int
[13:36:38.714]             signalCondition <- base::signalCondition
[13:36:38.714]             sys.calls <- base::sys.calls
[13:36:38.714]             `[[` <- base::`[[`
[13:36:38.714]             `+` <- base::`+`
[13:36:38.714]             `<<-` <- base::`<<-`
[13:36:38.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.714]                   3L)]
[13:36:38.714]             }
[13:36:38.714]             function(cond) {
[13:36:38.714]                 is_error <- inherits(cond, "error")
[13:36:38.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.714]                   NULL)
[13:36:38.714]                 if (is_error) {
[13:36:38.714]                   sessionInformation <- function() {
[13:36:38.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.714]                       search = base::search(), system = base::Sys.info())
[13:36:38.714]                   }
[13:36:38.714]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.714]                     cond$call), session = sessionInformation(), 
[13:36:38.714]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.714]                   signalCondition(cond)
[13:36:38.714]                 }
[13:36:38.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.714]                 "immediateCondition"))) {
[13:36:38.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.714]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.714]                   if (TRUE && !signal) {
[13:36:38.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.714]                     {
[13:36:38.714]                       inherits <- base::inherits
[13:36:38.714]                       invokeRestart <- base::invokeRestart
[13:36:38.714]                       is.null <- base::is.null
[13:36:38.714]                       muffled <- FALSE
[13:36:38.714]                       if (inherits(cond, "message")) {
[13:36:38.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.714]                         if (muffled) 
[13:36:38.714]                           invokeRestart("muffleMessage")
[13:36:38.714]                       }
[13:36:38.714]                       else if (inherits(cond, "warning")) {
[13:36:38.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.714]                         if (muffled) 
[13:36:38.714]                           invokeRestart("muffleWarning")
[13:36:38.714]                       }
[13:36:38.714]                       else if (inherits(cond, "condition")) {
[13:36:38.714]                         if (!is.null(pattern)) {
[13:36:38.714]                           computeRestarts <- base::computeRestarts
[13:36:38.714]                           grepl <- base::grepl
[13:36:38.714]                           restarts <- computeRestarts(cond)
[13:36:38.714]                           for (restart in restarts) {
[13:36:38.714]                             name <- restart$name
[13:36:38.714]                             if (is.null(name)) 
[13:36:38.714]                               next
[13:36:38.714]                             if (!grepl(pattern, name)) 
[13:36:38.714]                               next
[13:36:38.714]                             invokeRestart(restart)
[13:36:38.714]                             muffled <- TRUE
[13:36:38.714]                             break
[13:36:38.714]                           }
[13:36:38.714]                         }
[13:36:38.714]                       }
[13:36:38.714]                       invisible(muffled)
[13:36:38.714]                     }
[13:36:38.714]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.714]                   }
[13:36:38.714]                 }
[13:36:38.714]                 else {
[13:36:38.714]                   if (TRUE) {
[13:36:38.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.714]                     {
[13:36:38.714]                       inherits <- base::inherits
[13:36:38.714]                       invokeRestart <- base::invokeRestart
[13:36:38.714]                       is.null <- base::is.null
[13:36:38.714]                       muffled <- FALSE
[13:36:38.714]                       if (inherits(cond, "message")) {
[13:36:38.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.714]                         if (muffled) 
[13:36:38.714]                           invokeRestart("muffleMessage")
[13:36:38.714]                       }
[13:36:38.714]                       else if (inherits(cond, "warning")) {
[13:36:38.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.714]                         if (muffled) 
[13:36:38.714]                           invokeRestart("muffleWarning")
[13:36:38.714]                       }
[13:36:38.714]                       else if (inherits(cond, "condition")) {
[13:36:38.714]                         if (!is.null(pattern)) {
[13:36:38.714]                           computeRestarts <- base::computeRestarts
[13:36:38.714]                           grepl <- base::grepl
[13:36:38.714]                           restarts <- computeRestarts(cond)
[13:36:38.714]                           for (restart in restarts) {
[13:36:38.714]                             name <- restart$name
[13:36:38.714]                             if (is.null(name)) 
[13:36:38.714]                               next
[13:36:38.714]                             if (!grepl(pattern, name)) 
[13:36:38.714]                               next
[13:36:38.714]                             invokeRestart(restart)
[13:36:38.714]                             muffled <- TRUE
[13:36:38.714]                             break
[13:36:38.714]                           }
[13:36:38.714]                         }
[13:36:38.714]                       }
[13:36:38.714]                       invisible(muffled)
[13:36:38.714]                     }
[13:36:38.714]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.714]                   }
[13:36:38.714]                 }
[13:36:38.714]             }
[13:36:38.714]         }))
[13:36:38.714]     }, error = function(ex) {
[13:36:38.714]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.714]                 ...future.rng), started = ...future.startTime, 
[13:36:38.714]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.714]             version = "1.8"), class = "FutureResult")
[13:36:38.714]     }, finally = {
[13:36:38.714]         if (!identical(...future.workdir, getwd())) 
[13:36:38.714]             setwd(...future.workdir)
[13:36:38.714]         {
[13:36:38.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.714]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.714]             }
[13:36:38.714]             base::options(...future.oldOptions)
[13:36:38.714]             if (.Platform$OS.type == "windows") {
[13:36:38.714]                 old_names <- names(...future.oldEnvVars)
[13:36:38.714]                 envs <- base::Sys.getenv()
[13:36:38.714]                 names <- names(envs)
[13:36:38.714]                 common <- intersect(names, old_names)
[13:36:38.714]                 added <- setdiff(names, old_names)
[13:36:38.714]                 removed <- setdiff(old_names, names)
[13:36:38.714]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.714]                   envs[common]]
[13:36:38.714]                 NAMES <- toupper(changed)
[13:36:38.714]                 args <- list()
[13:36:38.714]                 for (kk in seq_along(NAMES)) {
[13:36:38.714]                   name <- changed[[kk]]
[13:36:38.714]                   NAME <- NAMES[[kk]]
[13:36:38.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.714]                     next
[13:36:38.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.714]                 }
[13:36:38.714]                 NAMES <- toupper(added)
[13:36:38.714]                 for (kk in seq_along(NAMES)) {
[13:36:38.714]                   name <- added[[kk]]
[13:36:38.714]                   NAME <- NAMES[[kk]]
[13:36:38.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.714]                     next
[13:36:38.714]                   args[[name]] <- ""
[13:36:38.714]                 }
[13:36:38.714]                 NAMES <- toupper(removed)
[13:36:38.714]                 for (kk in seq_along(NAMES)) {
[13:36:38.714]                   name <- removed[[kk]]
[13:36:38.714]                   NAME <- NAMES[[kk]]
[13:36:38.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.714]                     next
[13:36:38.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.714]                 }
[13:36:38.714]                 if (length(args) > 0) 
[13:36:38.714]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.714]             }
[13:36:38.714]             else {
[13:36:38.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.714]             }
[13:36:38.714]             {
[13:36:38.714]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.714]                   0L) {
[13:36:38.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.714]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.714]                   base::options(opts)
[13:36:38.714]                 }
[13:36:38.714]                 {
[13:36:38.714]                   {
[13:36:38.714]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.714]                     NULL
[13:36:38.714]                   }
[13:36:38.714]                   options(future.plan = NULL)
[13:36:38.714]                   if (is.na(NA_character_)) 
[13:36:38.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.714]                     .init = FALSE)
[13:36:38.714]                 }
[13:36:38.714]             }
[13:36:38.714]         }
[13:36:38.714]     })
[13:36:38.714]     if (TRUE) {
[13:36:38.714]         base::sink(type = "output", split = FALSE)
[13:36:38.714]         if (TRUE) {
[13:36:38.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.714]         }
[13:36:38.714]         else {
[13:36:38.714]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.714]         }
[13:36:38.714]         base::close(...future.stdout)
[13:36:38.714]         ...future.stdout <- NULL
[13:36:38.714]     }
[13:36:38.714]     ...future.result$conditions <- ...future.conditions
[13:36:38.714]     ...future.result$finished <- base::Sys.time()
[13:36:38.714]     ...future.result
[13:36:38.714] }
[13:36:38.717] MultisessionFuture started
[13:36:38.717] - Launch lazy future ... done
[13:36:38.717] run() for ‘MultisessionFuture’ ... done
[13:36:38.718] getGlobalsAndPackages() ...
[13:36:38.718] Searching for globals...
[13:36:38.719] - globals found: [1] ‘{’
[13:36:38.719] Searching for globals ... DONE
[13:36:38.719] Resolving globals: FALSE
[13:36:38.720] 
[13:36:38.720] 
[13:36:38.720] getGlobalsAndPackages() ... DONE
[13:36:38.720] run() for ‘Future’ ...
[13:36:38.720] - state: ‘created’
[13:36:38.720] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.735] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.735]   - Field: ‘node’
[13:36:38.735]   - Field: ‘label’
[13:36:38.735]   - Field: ‘local’
[13:36:38.735]   - Field: ‘owner’
[13:36:38.739]   - Field: ‘envir’
[13:36:38.739]   - Field: ‘workers’
[13:36:38.739]   - Field: ‘packages’
[13:36:38.739]   - Field: ‘gc’
[13:36:38.739]   - Field: ‘conditions’
[13:36:38.739]   - Field: ‘persistent’
[13:36:38.739]   - Field: ‘expr’
[13:36:38.740]   - Field: ‘uuid’
[13:36:38.740]   - Field: ‘seed’
[13:36:38.740]   - Field: ‘version’
[13:36:38.740]   - Field: ‘result’
[13:36:38.740]   - Field: ‘asynchronous’
[13:36:38.740]   - Field: ‘calls’
[13:36:38.740]   - Field: ‘globals’
[13:36:38.740]   - Field: ‘stdout’
[13:36:38.740]   - Field: ‘earlySignal’
[13:36:38.740]   - Field: ‘lazy’
[13:36:38.740]   - Field: ‘state’
[13:36:38.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.741] - Launch lazy future ...
[13:36:38.741] Packages needed by the future expression (n = 0): <none>
[13:36:38.741] Packages needed by future strategies (n = 0): <none>
[13:36:38.741] {
[13:36:38.741]     {
[13:36:38.741]         {
[13:36:38.741]             ...future.startTime <- base::Sys.time()
[13:36:38.741]             {
[13:36:38.741]                 {
[13:36:38.741]                   {
[13:36:38.741]                     {
[13:36:38.741]                       base::local({
[13:36:38.741]                         has_future <- base::requireNamespace("future", 
[13:36:38.741]                           quietly = TRUE)
[13:36:38.741]                         if (has_future) {
[13:36:38.741]                           ns <- base::getNamespace("future")
[13:36:38.741]                           version <- ns[[".package"]][["version"]]
[13:36:38.741]                           if (is.null(version)) 
[13:36:38.741]                             version <- utils::packageVersion("future")
[13:36:38.741]                         }
[13:36:38.741]                         else {
[13:36:38.741]                           version <- NULL
[13:36:38.741]                         }
[13:36:38.741]                         if (!has_future || version < "1.8.0") {
[13:36:38.741]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.741]                             "", base::R.version$version.string), 
[13:36:38.741]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.741]                               "release", "version")], collapse = " "), 
[13:36:38.741]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.741]                             info)
[13:36:38.741]                           info <- base::paste(info, collapse = "; ")
[13:36:38.741]                           if (!has_future) {
[13:36:38.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.741]                               info)
[13:36:38.741]                           }
[13:36:38.741]                           else {
[13:36:38.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.741]                               info, version)
[13:36:38.741]                           }
[13:36:38.741]                           base::stop(msg)
[13:36:38.741]                         }
[13:36:38.741]                       })
[13:36:38.741]                     }
[13:36:38.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.741]                     base::options(mc.cores = 1L)
[13:36:38.741]                   }
[13:36:38.741]                   ...future.strategy.old <- future::plan("list")
[13:36:38.741]                   options(future.plan = NULL)
[13:36:38.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.741]                 }
[13:36:38.741]                 ...future.workdir <- getwd()
[13:36:38.741]             }
[13:36:38.741]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.741]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.741]         }
[13:36:38.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.741]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.741]             base::names(...future.oldOptions))
[13:36:38.741]     }
[13:36:38.741]     if (FALSE) {
[13:36:38.741]     }
[13:36:38.741]     else {
[13:36:38.741]         if (TRUE) {
[13:36:38.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.741]                 open = "w")
[13:36:38.741]         }
[13:36:38.741]         else {
[13:36:38.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.741]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.741]         }
[13:36:38.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.741]             base::sink(type = "output", split = FALSE)
[13:36:38.741]             base::close(...future.stdout)
[13:36:38.741]         }, add = TRUE)
[13:36:38.741]     }
[13:36:38.741]     ...future.frame <- base::sys.nframe()
[13:36:38.741]     ...future.conditions <- base::list()
[13:36:38.741]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.741]     if (FALSE) {
[13:36:38.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.741]     }
[13:36:38.741]     ...future.result <- base::tryCatch({
[13:36:38.741]         base::withCallingHandlers({
[13:36:38.741]             ...future.value <- base::withVisible(base::local({
[13:36:38.741]                 ...future.makeSendCondition <- base::local({
[13:36:38.741]                   sendCondition <- NULL
[13:36:38.741]                   function(frame = 1L) {
[13:36:38.741]                     if (is.function(sendCondition)) 
[13:36:38.741]                       return(sendCondition)
[13:36:38.741]                     ns <- getNamespace("parallel")
[13:36:38.741]                     if (exists("sendData", mode = "function", 
[13:36:38.741]                       envir = ns)) {
[13:36:38.741]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.741]                         envir = ns)
[13:36:38.741]                       envir <- sys.frame(frame)
[13:36:38.741]                       master <- NULL
[13:36:38.741]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.741]                         !identical(envir, emptyenv())) {
[13:36:38.741]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.741]                           inherits = FALSE)) {
[13:36:38.741]                           master <- get("master", mode = "list", 
[13:36:38.741]                             envir = envir, inherits = FALSE)
[13:36:38.741]                           if (inherits(master, c("SOCKnode", 
[13:36:38.741]                             "SOCK0node"))) {
[13:36:38.741]                             sendCondition <<- function(cond) {
[13:36:38.741]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.741]                                 success = TRUE)
[13:36:38.741]                               parallel_sendData(master, data)
[13:36:38.741]                             }
[13:36:38.741]                             return(sendCondition)
[13:36:38.741]                           }
[13:36:38.741]                         }
[13:36:38.741]                         frame <- frame + 1L
[13:36:38.741]                         envir <- sys.frame(frame)
[13:36:38.741]                       }
[13:36:38.741]                     }
[13:36:38.741]                     sendCondition <<- function(cond) NULL
[13:36:38.741]                   }
[13:36:38.741]                 })
[13:36:38.741]                 withCallingHandlers({
[13:36:38.741]                   {
[13:36:38.741]                     4
[13:36:38.741]                   }
[13:36:38.741]                 }, immediateCondition = function(cond) {
[13:36:38.741]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.741]                   sendCondition(cond)
[13:36:38.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.741]                   {
[13:36:38.741]                     inherits <- base::inherits
[13:36:38.741]                     invokeRestart <- base::invokeRestart
[13:36:38.741]                     is.null <- base::is.null
[13:36:38.741]                     muffled <- FALSE
[13:36:38.741]                     if (inherits(cond, "message")) {
[13:36:38.741]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.741]                       if (muffled) 
[13:36:38.741]                         invokeRestart("muffleMessage")
[13:36:38.741]                     }
[13:36:38.741]                     else if (inherits(cond, "warning")) {
[13:36:38.741]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.741]                       if (muffled) 
[13:36:38.741]                         invokeRestart("muffleWarning")
[13:36:38.741]                     }
[13:36:38.741]                     else if (inherits(cond, "condition")) {
[13:36:38.741]                       if (!is.null(pattern)) {
[13:36:38.741]                         computeRestarts <- base::computeRestarts
[13:36:38.741]                         grepl <- base::grepl
[13:36:38.741]                         restarts <- computeRestarts(cond)
[13:36:38.741]                         for (restart in restarts) {
[13:36:38.741]                           name <- restart$name
[13:36:38.741]                           if (is.null(name)) 
[13:36:38.741]                             next
[13:36:38.741]                           if (!grepl(pattern, name)) 
[13:36:38.741]                             next
[13:36:38.741]                           invokeRestart(restart)
[13:36:38.741]                           muffled <- TRUE
[13:36:38.741]                           break
[13:36:38.741]                         }
[13:36:38.741]                       }
[13:36:38.741]                     }
[13:36:38.741]                     invisible(muffled)
[13:36:38.741]                   }
[13:36:38.741]                   muffleCondition(cond)
[13:36:38.741]                 })
[13:36:38.741]             }))
[13:36:38.741]             future::FutureResult(value = ...future.value$value, 
[13:36:38.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.741]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.741]                     ...future.globalenv.names))
[13:36:38.741]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.741]         }, condition = base::local({
[13:36:38.741]             c <- base::c
[13:36:38.741]             inherits <- base::inherits
[13:36:38.741]             invokeRestart <- base::invokeRestart
[13:36:38.741]             length <- base::length
[13:36:38.741]             list <- base::list
[13:36:38.741]             seq.int <- base::seq.int
[13:36:38.741]             signalCondition <- base::signalCondition
[13:36:38.741]             sys.calls <- base::sys.calls
[13:36:38.741]             `[[` <- base::`[[`
[13:36:38.741]             `+` <- base::`+`
[13:36:38.741]             `<<-` <- base::`<<-`
[13:36:38.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.741]                   3L)]
[13:36:38.741]             }
[13:36:38.741]             function(cond) {
[13:36:38.741]                 is_error <- inherits(cond, "error")
[13:36:38.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.741]                   NULL)
[13:36:38.741]                 if (is_error) {
[13:36:38.741]                   sessionInformation <- function() {
[13:36:38.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.741]                       search = base::search(), system = base::Sys.info())
[13:36:38.741]                   }
[13:36:38.741]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.741]                     cond$call), session = sessionInformation(), 
[13:36:38.741]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.741]                   signalCondition(cond)
[13:36:38.741]                 }
[13:36:38.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.741]                 "immediateCondition"))) {
[13:36:38.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.741]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.741]                   if (TRUE && !signal) {
[13:36:38.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.741]                     {
[13:36:38.741]                       inherits <- base::inherits
[13:36:38.741]                       invokeRestart <- base::invokeRestart
[13:36:38.741]                       is.null <- base::is.null
[13:36:38.741]                       muffled <- FALSE
[13:36:38.741]                       if (inherits(cond, "message")) {
[13:36:38.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.741]                         if (muffled) 
[13:36:38.741]                           invokeRestart("muffleMessage")
[13:36:38.741]                       }
[13:36:38.741]                       else if (inherits(cond, "warning")) {
[13:36:38.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.741]                         if (muffled) 
[13:36:38.741]                           invokeRestart("muffleWarning")
[13:36:38.741]                       }
[13:36:38.741]                       else if (inherits(cond, "condition")) {
[13:36:38.741]                         if (!is.null(pattern)) {
[13:36:38.741]                           computeRestarts <- base::computeRestarts
[13:36:38.741]                           grepl <- base::grepl
[13:36:38.741]                           restarts <- computeRestarts(cond)
[13:36:38.741]                           for (restart in restarts) {
[13:36:38.741]                             name <- restart$name
[13:36:38.741]                             if (is.null(name)) 
[13:36:38.741]                               next
[13:36:38.741]                             if (!grepl(pattern, name)) 
[13:36:38.741]                               next
[13:36:38.741]                             invokeRestart(restart)
[13:36:38.741]                             muffled <- TRUE
[13:36:38.741]                             break
[13:36:38.741]                           }
[13:36:38.741]                         }
[13:36:38.741]                       }
[13:36:38.741]                       invisible(muffled)
[13:36:38.741]                     }
[13:36:38.741]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.741]                   }
[13:36:38.741]                 }
[13:36:38.741]                 else {
[13:36:38.741]                   if (TRUE) {
[13:36:38.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.741]                     {
[13:36:38.741]                       inherits <- base::inherits
[13:36:38.741]                       invokeRestart <- base::invokeRestart
[13:36:38.741]                       is.null <- base::is.null
[13:36:38.741]                       muffled <- FALSE
[13:36:38.741]                       if (inherits(cond, "message")) {
[13:36:38.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.741]                         if (muffled) 
[13:36:38.741]                           invokeRestart("muffleMessage")
[13:36:38.741]                       }
[13:36:38.741]                       else if (inherits(cond, "warning")) {
[13:36:38.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.741]                         if (muffled) 
[13:36:38.741]                           invokeRestart("muffleWarning")
[13:36:38.741]                       }
[13:36:38.741]                       else if (inherits(cond, "condition")) {
[13:36:38.741]                         if (!is.null(pattern)) {
[13:36:38.741]                           computeRestarts <- base::computeRestarts
[13:36:38.741]                           grepl <- base::grepl
[13:36:38.741]                           restarts <- computeRestarts(cond)
[13:36:38.741]                           for (restart in restarts) {
[13:36:38.741]                             name <- restart$name
[13:36:38.741]                             if (is.null(name)) 
[13:36:38.741]                               next
[13:36:38.741]                             if (!grepl(pattern, name)) 
[13:36:38.741]                               next
[13:36:38.741]                             invokeRestart(restart)
[13:36:38.741]                             muffled <- TRUE
[13:36:38.741]                             break
[13:36:38.741]                           }
[13:36:38.741]                         }
[13:36:38.741]                       }
[13:36:38.741]                       invisible(muffled)
[13:36:38.741]                     }
[13:36:38.741]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.741]                   }
[13:36:38.741]                 }
[13:36:38.741]             }
[13:36:38.741]         }))
[13:36:38.741]     }, error = function(ex) {
[13:36:38.741]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.741]                 ...future.rng), started = ...future.startTime, 
[13:36:38.741]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.741]             version = "1.8"), class = "FutureResult")
[13:36:38.741]     }, finally = {
[13:36:38.741]         if (!identical(...future.workdir, getwd())) 
[13:36:38.741]             setwd(...future.workdir)
[13:36:38.741]         {
[13:36:38.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.741]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.741]             }
[13:36:38.741]             base::options(...future.oldOptions)
[13:36:38.741]             if (.Platform$OS.type == "windows") {
[13:36:38.741]                 old_names <- names(...future.oldEnvVars)
[13:36:38.741]                 envs <- base::Sys.getenv()
[13:36:38.741]                 names <- names(envs)
[13:36:38.741]                 common <- intersect(names, old_names)
[13:36:38.741]                 added <- setdiff(names, old_names)
[13:36:38.741]                 removed <- setdiff(old_names, names)
[13:36:38.741]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.741]                   envs[common]]
[13:36:38.741]                 NAMES <- toupper(changed)
[13:36:38.741]                 args <- list()
[13:36:38.741]                 for (kk in seq_along(NAMES)) {
[13:36:38.741]                   name <- changed[[kk]]
[13:36:38.741]                   NAME <- NAMES[[kk]]
[13:36:38.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.741]                     next
[13:36:38.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.741]                 }
[13:36:38.741]                 NAMES <- toupper(added)
[13:36:38.741]                 for (kk in seq_along(NAMES)) {
[13:36:38.741]                   name <- added[[kk]]
[13:36:38.741]                   NAME <- NAMES[[kk]]
[13:36:38.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.741]                     next
[13:36:38.741]                   args[[name]] <- ""
[13:36:38.741]                 }
[13:36:38.741]                 NAMES <- toupper(removed)
[13:36:38.741]                 for (kk in seq_along(NAMES)) {
[13:36:38.741]                   name <- removed[[kk]]
[13:36:38.741]                   NAME <- NAMES[[kk]]
[13:36:38.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.741]                     next
[13:36:38.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.741]                 }
[13:36:38.741]                 if (length(args) > 0) 
[13:36:38.741]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.741]             }
[13:36:38.741]             else {
[13:36:38.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.741]             }
[13:36:38.741]             {
[13:36:38.741]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.741]                   0L) {
[13:36:38.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.741]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.741]                   base::options(opts)
[13:36:38.741]                 }
[13:36:38.741]                 {
[13:36:38.741]                   {
[13:36:38.741]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.741]                     NULL
[13:36:38.741]                   }
[13:36:38.741]                   options(future.plan = NULL)
[13:36:38.741]                   if (is.na(NA_character_)) 
[13:36:38.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.741]                     .init = FALSE)
[13:36:38.741]                 }
[13:36:38.741]             }
[13:36:38.741]         }
[13:36:38.741]     })
[13:36:38.741]     if (TRUE) {
[13:36:38.741]         base::sink(type = "output", split = FALSE)
[13:36:38.741]         if (TRUE) {
[13:36:38.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.741]         }
[13:36:38.741]         else {
[13:36:38.741]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.741]         }
[13:36:38.741]         base::close(...future.stdout)
[13:36:38.741]         ...future.stdout <- NULL
[13:36:38.741]     }
[13:36:38.741]     ...future.result$conditions <- ...future.conditions
[13:36:38.741]     ...future.result$finished <- base::Sys.time()
[13:36:38.741]     ...future.result
[13:36:38.741] }
[13:36:38.744] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:38.754] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.754] - Validating connection of MultisessionFuture
[13:36:38.755] - received message: FutureResult
[13:36:38.755] - Received FutureResult
[13:36:38.755] - Erased future from FutureRegistry
[13:36:38.755] result() for ClusterFuture ...
[13:36:38.755] - result already collected: FutureResult
[13:36:38.755] result() for ClusterFuture ... done
[13:36:38.755] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.755] result() for ClusterFuture ...
[13:36:38.755] - result already collected: FutureResult
[13:36:38.756] result() for ClusterFuture ... done
[13:36:38.756] result() for ClusterFuture ...
[13:36:38.756] - result already collected: FutureResult
[13:36:38.756] result() for ClusterFuture ... done
[13:36:38.757] MultisessionFuture started
[13:36:38.757] - Launch lazy future ... done
[13:36:38.757] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a74691298> 
Classes 'listenv', 'environment' <environment: 0x564a734b8b68> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:36:38.761] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.761] - Validating connection of MultisessionFuture
[13:36:38.761] - received message: FutureResult
[13:36:38.761] - Received FutureResult
[13:36:38.761] - Erased future from FutureRegistry
[13:36:38.761] result() for ClusterFuture ...
[13:36:38.761] - result already collected: FutureResult
[13:36:38.762] result() for ClusterFuture ... done
[13:36:38.762] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.762] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.762] - Validating connection of MultisessionFuture
[13:36:38.762] - received message: FutureResult
[13:36:38.762] - Received FutureResult
[13:36:38.763] - Erased future from FutureRegistry
[13:36:38.763] result() for ClusterFuture ...
[13:36:38.763] - result already collected: FutureResult
[13:36:38.763] result() for ClusterFuture ... done
[13:36:38.763] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:38.765] resolve() on list environment ...
[13:36:38.765]  recursive: 0
[13:36:38.766]  length: 6
[13:36:38.766]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:38.766] signalConditionsASAP(numeric, pos=1) ...
[13:36:38.766] - nx: 6
[13:36:38.767] - relay: TRUE
[13:36:38.767] - stdout: TRUE
[13:36:38.767] - signal: TRUE
[13:36:38.767] - resignal: FALSE
[13:36:38.767] - force: TRUE
[13:36:38.767] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.767] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.767]  - until=2
[13:36:38.767]  - relaying element #2
[13:36:38.767] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.767] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.768] signalConditionsASAP(NULL, pos=1) ... done
[13:36:38.768]  length: 5 (resolved future 1)
[13:36:38.768] Future #2
[13:36:38.768] result() for ClusterFuture ...
[13:36:38.768] - result already collected: FutureResult
[13:36:38.768] result() for ClusterFuture ... done
[13:36:38.768] result() for ClusterFuture ...
[13:36:38.768] - result already collected: FutureResult
[13:36:38.768] result() for ClusterFuture ... done
[13:36:38.768] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:38.768] - nx: 6
[13:36:38.769] - relay: TRUE
[13:36:38.769] - stdout: TRUE
[13:36:38.769] - signal: TRUE
[13:36:38.769] - resignal: FALSE
[13:36:38.769] - force: TRUE
[13:36:38.769] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.769] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.769]  - until=2
[13:36:38.769]  - relaying element #2
[13:36:38.769] result() for ClusterFuture ...
[13:36:38.769] - result already collected: FutureResult
[13:36:38.769] result() for ClusterFuture ... done
[13:36:38.770] result() for ClusterFuture ...
[13:36:38.770] - result already collected: FutureResult
[13:36:38.770] result() for ClusterFuture ... done
[13:36:38.770] result() for ClusterFuture ...
[13:36:38.770] - result already collected: FutureResult
[13:36:38.770] result() for ClusterFuture ... done
[13:36:38.770] result() for ClusterFuture ...
[13:36:38.770] - result already collected: FutureResult
[13:36:38.770] result() for ClusterFuture ... done
[13:36:38.770] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.770] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.771] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:38.771]  length: 4 (resolved future 2)
[13:36:38.771] Future #3
[13:36:38.771] result() for ClusterFuture ...
[13:36:38.771] - result already collected: FutureResult
[13:36:38.771] result() for ClusterFuture ... done
[13:36:38.771] result() for ClusterFuture ...
[13:36:38.771] - result already collected: FutureResult
[13:36:38.771] result() for ClusterFuture ... done
[13:36:38.771] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:38.772] - nx: 6
[13:36:38.772] - relay: TRUE
[13:36:38.772] - stdout: TRUE
[13:36:38.772] - signal: TRUE
[13:36:38.772] - resignal: FALSE
[13:36:38.772] - force: TRUE
[13:36:38.772] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.772] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.772]  - until=3
[13:36:38.772]  - relaying element #3
[13:36:38.772] result() for ClusterFuture ...
[13:36:38.773] - result already collected: FutureResult
[13:36:38.773] result() for ClusterFuture ... done
[13:36:38.773] result() for ClusterFuture ...
[13:36:38.773] - result already collected: FutureResult
[13:36:38.773] result() for ClusterFuture ... done
[13:36:38.773] result() for ClusterFuture ...
[13:36:38.773] - result already collected: FutureResult
[13:36:38.773] result() for ClusterFuture ... done
[13:36:38.773] result() for ClusterFuture ...
[13:36:38.773] - result already collected: FutureResult
[13:36:38.773] result() for ClusterFuture ... done
[13:36:38.774] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.774] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.774] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:38.774]  length: 3 (resolved future 3)
[13:36:38.774] Future #4
[13:36:38.774] result() for ClusterFuture ...
[13:36:38.774] - result already collected: FutureResult
[13:36:38.774] result() for ClusterFuture ... done
[13:36:38.774] result() for ClusterFuture ...
[13:36:38.774] - result already collected: FutureResult
[13:36:38.774] result() for ClusterFuture ... done
[13:36:38.775] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:38.775] - nx: 6
[13:36:38.775] - relay: TRUE
[13:36:38.775] - stdout: TRUE
[13:36:38.775] - signal: TRUE
[13:36:38.775] - resignal: FALSE
[13:36:38.775] - force: TRUE
[13:36:38.775] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.775]  - until=4
[13:36:38.775]  - relaying element #4
[13:36:38.776] result() for ClusterFuture ...
[13:36:38.776] - result already collected: FutureResult
[13:36:38.776] result() for ClusterFuture ... done
[13:36:38.776] result() for ClusterFuture ...
[13:36:38.776] - result already collected: FutureResult
[13:36:38.776] result() for ClusterFuture ... done
[13:36:38.776] result() for ClusterFuture ...
[13:36:38.776] - result already collected: FutureResult
[13:36:38.776] result() for ClusterFuture ... done
[13:36:38.776] result() for ClusterFuture ...
[13:36:38.776] - result already collected: FutureResult
[13:36:38.777] result() for ClusterFuture ... done
[13:36:38.777] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.777] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.777] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:38.777]  length: 2 (resolved future 4)
[13:36:38.777] signalConditionsASAP(NULL, pos=5) ...
[13:36:38.777] - nx: 6
[13:36:38.777] - relay: TRUE
[13:36:38.777] - stdout: TRUE
[13:36:38.777] - signal: TRUE
[13:36:38.777] - resignal: FALSE
[13:36:38.778] - force: TRUE
[13:36:38.778] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.778] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.778]  - until=6
[13:36:38.778]  - relaying element #6
[13:36:38.778] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.778] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.778] signalConditionsASAP(NULL, pos=5) ... done
[13:36:38.778]  length: 1 (resolved future 5)
[13:36:38.778] signalConditionsASAP(numeric, pos=6) ...
[13:36:38.778] - nx: 6
[13:36:38.779] - relay: TRUE
[13:36:38.779] - stdout: TRUE
[13:36:38.779] - signal: TRUE
[13:36:38.779] - resignal: FALSE
[13:36:38.779] - force: TRUE
[13:36:38.779] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.779] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.779]  - until=6
[13:36:38.779] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.779] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.779] signalConditionsASAP(numeric, pos=6) ... done
[13:36:38.779]  length: 0 (resolved future 6)
[13:36:38.780] Relaying remaining futures
[13:36:38.780] signalConditionsASAP(NULL, pos=0) ...
[13:36:38.780] - nx: 6
[13:36:38.780] - relay: TRUE
[13:36:38.780] - stdout: TRUE
[13:36:38.780] - signal: TRUE
[13:36:38.780] - resignal: FALSE
[13:36:38.780] - force: TRUE
[13:36:38.780] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.780] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:38.780] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.781] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.781] signalConditionsASAP(NULL, pos=0) ... done
[13:36:38.781] resolve() on list environment ... DONE
[13:36:38.781] result() for ClusterFuture ...
[13:36:38.781] - result already collected: FutureResult
[13:36:38.781] result() for ClusterFuture ... done
[13:36:38.781] result() for ClusterFuture ...
[13:36:38.781] - result already collected: FutureResult
[13:36:38.781] result() for ClusterFuture ... done
[13:36:38.781] result() for ClusterFuture ...
[13:36:38.781] - result already collected: FutureResult
[13:36:38.782] result() for ClusterFuture ... done
[13:36:38.782] result() for ClusterFuture ...
[13:36:38.782] - result already collected: FutureResult
[13:36:38.782] result() for ClusterFuture ... done
[13:36:38.782] result() for ClusterFuture ...
[13:36:38.782] - result already collected: FutureResult
[13:36:38.782] result() for ClusterFuture ... done
[13:36:38.782] result() for ClusterFuture ...
[13:36:38.782] - result already collected: FutureResult
[13:36:38.783] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a72f506c8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:36:38.784] getGlobalsAndPackages() ...
[13:36:38.784] Searching for globals...
[13:36:38.785] 
[13:36:38.785] Searching for globals ... DONE
[13:36:38.785] - globals: [0] <none>
[13:36:38.785] getGlobalsAndPackages() ... DONE
[13:36:38.785] run() for ‘Future’ ...
[13:36:38.785] - state: ‘created’
[13:36:38.785] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.799] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.799]   - Field: ‘node’
[13:36:38.799]   - Field: ‘label’
[13:36:38.799]   - Field: ‘local’
[13:36:38.799]   - Field: ‘owner’
[13:36:38.799]   - Field: ‘envir’
[13:36:38.800]   - Field: ‘workers’
[13:36:38.800]   - Field: ‘packages’
[13:36:38.800]   - Field: ‘gc’
[13:36:38.800]   - Field: ‘conditions’
[13:36:38.800]   - Field: ‘persistent’
[13:36:38.800]   - Field: ‘expr’
[13:36:38.800]   - Field: ‘uuid’
[13:36:38.800]   - Field: ‘seed’
[13:36:38.800]   - Field: ‘version’
[13:36:38.800]   - Field: ‘result’
[13:36:38.800]   - Field: ‘asynchronous’
[13:36:38.801]   - Field: ‘calls’
[13:36:38.801]   - Field: ‘globals’
[13:36:38.801]   - Field: ‘stdout’
[13:36:38.801]   - Field: ‘earlySignal’
[13:36:38.801]   - Field: ‘lazy’
[13:36:38.801]   - Field: ‘state’
[13:36:38.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.801] - Launch lazy future ...
[13:36:38.801] Packages needed by the future expression (n = 0): <none>
[13:36:38.802] Packages needed by future strategies (n = 0): <none>
[13:36:38.802] {
[13:36:38.802]     {
[13:36:38.802]         {
[13:36:38.802]             ...future.startTime <- base::Sys.time()
[13:36:38.802]             {
[13:36:38.802]                 {
[13:36:38.802]                   {
[13:36:38.802]                     {
[13:36:38.802]                       base::local({
[13:36:38.802]                         has_future <- base::requireNamespace("future", 
[13:36:38.802]                           quietly = TRUE)
[13:36:38.802]                         if (has_future) {
[13:36:38.802]                           ns <- base::getNamespace("future")
[13:36:38.802]                           version <- ns[[".package"]][["version"]]
[13:36:38.802]                           if (is.null(version)) 
[13:36:38.802]                             version <- utils::packageVersion("future")
[13:36:38.802]                         }
[13:36:38.802]                         else {
[13:36:38.802]                           version <- NULL
[13:36:38.802]                         }
[13:36:38.802]                         if (!has_future || version < "1.8.0") {
[13:36:38.802]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.802]                             "", base::R.version$version.string), 
[13:36:38.802]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.802]                               "release", "version")], collapse = " "), 
[13:36:38.802]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.802]                             info)
[13:36:38.802]                           info <- base::paste(info, collapse = "; ")
[13:36:38.802]                           if (!has_future) {
[13:36:38.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.802]                               info)
[13:36:38.802]                           }
[13:36:38.802]                           else {
[13:36:38.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.802]                               info, version)
[13:36:38.802]                           }
[13:36:38.802]                           base::stop(msg)
[13:36:38.802]                         }
[13:36:38.802]                       })
[13:36:38.802]                     }
[13:36:38.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.802]                     base::options(mc.cores = 1L)
[13:36:38.802]                   }
[13:36:38.802]                   ...future.strategy.old <- future::plan("list")
[13:36:38.802]                   options(future.plan = NULL)
[13:36:38.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.802]                 }
[13:36:38.802]                 ...future.workdir <- getwd()
[13:36:38.802]             }
[13:36:38.802]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.802]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.802]         }
[13:36:38.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.802]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.802]             base::names(...future.oldOptions))
[13:36:38.802]     }
[13:36:38.802]     if (FALSE) {
[13:36:38.802]     }
[13:36:38.802]     else {
[13:36:38.802]         if (TRUE) {
[13:36:38.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.802]                 open = "w")
[13:36:38.802]         }
[13:36:38.802]         else {
[13:36:38.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.802]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.802]         }
[13:36:38.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.802]             base::sink(type = "output", split = FALSE)
[13:36:38.802]             base::close(...future.stdout)
[13:36:38.802]         }, add = TRUE)
[13:36:38.802]     }
[13:36:38.802]     ...future.frame <- base::sys.nframe()
[13:36:38.802]     ...future.conditions <- base::list()
[13:36:38.802]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.802]     if (FALSE) {
[13:36:38.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.802]     }
[13:36:38.802]     ...future.result <- base::tryCatch({
[13:36:38.802]         base::withCallingHandlers({
[13:36:38.802]             ...future.value <- base::withVisible(base::local({
[13:36:38.802]                 ...future.makeSendCondition <- base::local({
[13:36:38.802]                   sendCondition <- NULL
[13:36:38.802]                   function(frame = 1L) {
[13:36:38.802]                     if (is.function(sendCondition)) 
[13:36:38.802]                       return(sendCondition)
[13:36:38.802]                     ns <- getNamespace("parallel")
[13:36:38.802]                     if (exists("sendData", mode = "function", 
[13:36:38.802]                       envir = ns)) {
[13:36:38.802]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.802]                         envir = ns)
[13:36:38.802]                       envir <- sys.frame(frame)
[13:36:38.802]                       master <- NULL
[13:36:38.802]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.802]                         !identical(envir, emptyenv())) {
[13:36:38.802]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.802]                           inherits = FALSE)) {
[13:36:38.802]                           master <- get("master", mode = "list", 
[13:36:38.802]                             envir = envir, inherits = FALSE)
[13:36:38.802]                           if (inherits(master, c("SOCKnode", 
[13:36:38.802]                             "SOCK0node"))) {
[13:36:38.802]                             sendCondition <<- function(cond) {
[13:36:38.802]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.802]                                 success = TRUE)
[13:36:38.802]                               parallel_sendData(master, data)
[13:36:38.802]                             }
[13:36:38.802]                             return(sendCondition)
[13:36:38.802]                           }
[13:36:38.802]                         }
[13:36:38.802]                         frame <- frame + 1L
[13:36:38.802]                         envir <- sys.frame(frame)
[13:36:38.802]                       }
[13:36:38.802]                     }
[13:36:38.802]                     sendCondition <<- function(cond) NULL
[13:36:38.802]                   }
[13:36:38.802]                 })
[13:36:38.802]                 withCallingHandlers({
[13:36:38.802]                   2
[13:36:38.802]                 }, immediateCondition = function(cond) {
[13:36:38.802]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.802]                   sendCondition(cond)
[13:36:38.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.802]                   {
[13:36:38.802]                     inherits <- base::inherits
[13:36:38.802]                     invokeRestart <- base::invokeRestart
[13:36:38.802]                     is.null <- base::is.null
[13:36:38.802]                     muffled <- FALSE
[13:36:38.802]                     if (inherits(cond, "message")) {
[13:36:38.802]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.802]                       if (muffled) 
[13:36:38.802]                         invokeRestart("muffleMessage")
[13:36:38.802]                     }
[13:36:38.802]                     else if (inherits(cond, "warning")) {
[13:36:38.802]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.802]                       if (muffled) 
[13:36:38.802]                         invokeRestart("muffleWarning")
[13:36:38.802]                     }
[13:36:38.802]                     else if (inherits(cond, "condition")) {
[13:36:38.802]                       if (!is.null(pattern)) {
[13:36:38.802]                         computeRestarts <- base::computeRestarts
[13:36:38.802]                         grepl <- base::grepl
[13:36:38.802]                         restarts <- computeRestarts(cond)
[13:36:38.802]                         for (restart in restarts) {
[13:36:38.802]                           name <- restart$name
[13:36:38.802]                           if (is.null(name)) 
[13:36:38.802]                             next
[13:36:38.802]                           if (!grepl(pattern, name)) 
[13:36:38.802]                             next
[13:36:38.802]                           invokeRestart(restart)
[13:36:38.802]                           muffled <- TRUE
[13:36:38.802]                           break
[13:36:38.802]                         }
[13:36:38.802]                       }
[13:36:38.802]                     }
[13:36:38.802]                     invisible(muffled)
[13:36:38.802]                   }
[13:36:38.802]                   muffleCondition(cond)
[13:36:38.802]                 })
[13:36:38.802]             }))
[13:36:38.802]             future::FutureResult(value = ...future.value$value, 
[13:36:38.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.802]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.802]                     ...future.globalenv.names))
[13:36:38.802]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.802]         }, condition = base::local({
[13:36:38.802]             c <- base::c
[13:36:38.802]             inherits <- base::inherits
[13:36:38.802]             invokeRestart <- base::invokeRestart
[13:36:38.802]             length <- base::length
[13:36:38.802]             list <- base::list
[13:36:38.802]             seq.int <- base::seq.int
[13:36:38.802]             signalCondition <- base::signalCondition
[13:36:38.802]             sys.calls <- base::sys.calls
[13:36:38.802]             `[[` <- base::`[[`
[13:36:38.802]             `+` <- base::`+`
[13:36:38.802]             `<<-` <- base::`<<-`
[13:36:38.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.802]                   3L)]
[13:36:38.802]             }
[13:36:38.802]             function(cond) {
[13:36:38.802]                 is_error <- inherits(cond, "error")
[13:36:38.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.802]                   NULL)
[13:36:38.802]                 if (is_error) {
[13:36:38.802]                   sessionInformation <- function() {
[13:36:38.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.802]                       search = base::search(), system = base::Sys.info())
[13:36:38.802]                   }
[13:36:38.802]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.802]                     cond$call), session = sessionInformation(), 
[13:36:38.802]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.802]                   signalCondition(cond)
[13:36:38.802]                 }
[13:36:38.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.802]                 "immediateCondition"))) {
[13:36:38.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.802]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.802]                   if (TRUE && !signal) {
[13:36:38.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.802]                     {
[13:36:38.802]                       inherits <- base::inherits
[13:36:38.802]                       invokeRestart <- base::invokeRestart
[13:36:38.802]                       is.null <- base::is.null
[13:36:38.802]                       muffled <- FALSE
[13:36:38.802]                       if (inherits(cond, "message")) {
[13:36:38.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.802]                         if (muffled) 
[13:36:38.802]                           invokeRestart("muffleMessage")
[13:36:38.802]                       }
[13:36:38.802]                       else if (inherits(cond, "warning")) {
[13:36:38.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.802]                         if (muffled) 
[13:36:38.802]                           invokeRestart("muffleWarning")
[13:36:38.802]                       }
[13:36:38.802]                       else if (inherits(cond, "condition")) {
[13:36:38.802]                         if (!is.null(pattern)) {
[13:36:38.802]                           computeRestarts <- base::computeRestarts
[13:36:38.802]                           grepl <- base::grepl
[13:36:38.802]                           restarts <- computeRestarts(cond)
[13:36:38.802]                           for (restart in restarts) {
[13:36:38.802]                             name <- restart$name
[13:36:38.802]                             if (is.null(name)) 
[13:36:38.802]                               next
[13:36:38.802]                             if (!grepl(pattern, name)) 
[13:36:38.802]                               next
[13:36:38.802]                             invokeRestart(restart)
[13:36:38.802]                             muffled <- TRUE
[13:36:38.802]                             break
[13:36:38.802]                           }
[13:36:38.802]                         }
[13:36:38.802]                       }
[13:36:38.802]                       invisible(muffled)
[13:36:38.802]                     }
[13:36:38.802]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.802]                   }
[13:36:38.802]                 }
[13:36:38.802]                 else {
[13:36:38.802]                   if (TRUE) {
[13:36:38.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.802]                     {
[13:36:38.802]                       inherits <- base::inherits
[13:36:38.802]                       invokeRestart <- base::invokeRestart
[13:36:38.802]                       is.null <- base::is.null
[13:36:38.802]                       muffled <- FALSE
[13:36:38.802]                       if (inherits(cond, "message")) {
[13:36:38.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.802]                         if (muffled) 
[13:36:38.802]                           invokeRestart("muffleMessage")
[13:36:38.802]                       }
[13:36:38.802]                       else if (inherits(cond, "warning")) {
[13:36:38.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.802]                         if (muffled) 
[13:36:38.802]                           invokeRestart("muffleWarning")
[13:36:38.802]                       }
[13:36:38.802]                       else if (inherits(cond, "condition")) {
[13:36:38.802]                         if (!is.null(pattern)) {
[13:36:38.802]                           computeRestarts <- base::computeRestarts
[13:36:38.802]                           grepl <- base::grepl
[13:36:38.802]                           restarts <- computeRestarts(cond)
[13:36:38.802]                           for (restart in restarts) {
[13:36:38.802]                             name <- restart$name
[13:36:38.802]                             if (is.null(name)) 
[13:36:38.802]                               next
[13:36:38.802]                             if (!grepl(pattern, name)) 
[13:36:38.802]                               next
[13:36:38.802]                             invokeRestart(restart)
[13:36:38.802]                             muffled <- TRUE
[13:36:38.802]                             break
[13:36:38.802]                           }
[13:36:38.802]                         }
[13:36:38.802]                       }
[13:36:38.802]                       invisible(muffled)
[13:36:38.802]                     }
[13:36:38.802]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.802]                   }
[13:36:38.802]                 }
[13:36:38.802]             }
[13:36:38.802]         }))
[13:36:38.802]     }, error = function(ex) {
[13:36:38.802]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.802]                 ...future.rng), started = ...future.startTime, 
[13:36:38.802]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.802]             version = "1.8"), class = "FutureResult")
[13:36:38.802]     }, finally = {
[13:36:38.802]         if (!identical(...future.workdir, getwd())) 
[13:36:38.802]             setwd(...future.workdir)
[13:36:38.802]         {
[13:36:38.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.802]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.802]             }
[13:36:38.802]             base::options(...future.oldOptions)
[13:36:38.802]             if (.Platform$OS.type == "windows") {
[13:36:38.802]                 old_names <- names(...future.oldEnvVars)
[13:36:38.802]                 envs <- base::Sys.getenv()
[13:36:38.802]                 names <- names(envs)
[13:36:38.802]                 common <- intersect(names, old_names)
[13:36:38.802]                 added <- setdiff(names, old_names)
[13:36:38.802]                 removed <- setdiff(old_names, names)
[13:36:38.802]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.802]                   envs[common]]
[13:36:38.802]                 NAMES <- toupper(changed)
[13:36:38.802]                 args <- list()
[13:36:38.802]                 for (kk in seq_along(NAMES)) {
[13:36:38.802]                   name <- changed[[kk]]
[13:36:38.802]                   NAME <- NAMES[[kk]]
[13:36:38.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.802]                     next
[13:36:38.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.802]                 }
[13:36:38.802]                 NAMES <- toupper(added)
[13:36:38.802]                 for (kk in seq_along(NAMES)) {
[13:36:38.802]                   name <- added[[kk]]
[13:36:38.802]                   NAME <- NAMES[[kk]]
[13:36:38.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.802]                     next
[13:36:38.802]                   args[[name]] <- ""
[13:36:38.802]                 }
[13:36:38.802]                 NAMES <- toupper(removed)
[13:36:38.802]                 for (kk in seq_along(NAMES)) {
[13:36:38.802]                   name <- removed[[kk]]
[13:36:38.802]                   NAME <- NAMES[[kk]]
[13:36:38.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.802]                     next
[13:36:38.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.802]                 }
[13:36:38.802]                 if (length(args) > 0) 
[13:36:38.802]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.802]             }
[13:36:38.802]             else {
[13:36:38.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.802]             }
[13:36:38.802]             {
[13:36:38.802]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.802]                   0L) {
[13:36:38.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.802]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.802]                   base::options(opts)
[13:36:38.802]                 }
[13:36:38.802]                 {
[13:36:38.802]                   {
[13:36:38.802]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.802]                     NULL
[13:36:38.802]                   }
[13:36:38.802]                   options(future.plan = NULL)
[13:36:38.802]                   if (is.na(NA_character_)) 
[13:36:38.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.802]                     .init = FALSE)
[13:36:38.802]                 }
[13:36:38.802]             }
[13:36:38.802]         }
[13:36:38.802]     })
[13:36:38.802]     if (TRUE) {
[13:36:38.802]         base::sink(type = "output", split = FALSE)
[13:36:38.802]         if (TRUE) {
[13:36:38.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.802]         }
[13:36:38.802]         else {
[13:36:38.802]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.802]         }
[13:36:38.802]         base::close(...future.stdout)
[13:36:38.802]         ...future.stdout <- NULL
[13:36:38.802]     }
[13:36:38.802]     ...future.result$conditions <- ...future.conditions
[13:36:38.802]     ...future.result$finished <- base::Sys.time()
[13:36:38.802]     ...future.result
[13:36:38.802] }
[13:36:38.805] MultisessionFuture started
[13:36:38.805] - Launch lazy future ... done
[13:36:38.805] run() for ‘MultisessionFuture’ ... done
[13:36:38.805] getGlobalsAndPackages() ...
[13:36:38.805] Searching for globals...
[13:36:38.806] 
[13:36:38.806] Searching for globals ... DONE
[13:36:38.806] - globals: [0] <none>
[13:36:38.806] getGlobalsAndPackages() ... DONE
[13:36:38.806] run() for ‘Future’ ...
[13:36:38.806] - state: ‘created’
[13:36:38.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.819] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.820]   - Field: ‘node’
[13:36:38.820]   - Field: ‘label’
[13:36:38.820]   - Field: ‘local’
[13:36:38.820]   - Field: ‘owner’
[13:36:38.820]   - Field: ‘envir’
[13:36:38.820]   - Field: ‘workers’
[13:36:38.820]   - Field: ‘packages’
[13:36:38.820]   - Field: ‘gc’
[13:36:38.820]   - Field: ‘conditions’
[13:36:38.821]   - Field: ‘persistent’
[13:36:38.821]   - Field: ‘expr’
[13:36:38.821]   - Field: ‘uuid’
[13:36:38.821]   - Field: ‘seed’
[13:36:38.821]   - Field: ‘version’
[13:36:38.821]   - Field: ‘result’
[13:36:38.821]   - Field: ‘asynchronous’
[13:36:38.821]   - Field: ‘calls’
[13:36:38.821]   - Field: ‘globals’
[13:36:38.821]   - Field: ‘stdout’
[13:36:38.821]   - Field: ‘earlySignal’
[13:36:38.821]   - Field: ‘lazy’
[13:36:38.822]   - Field: ‘state’
[13:36:38.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.822] - Launch lazy future ...
[13:36:38.822] Packages needed by the future expression (n = 0): <none>
[13:36:38.822] Packages needed by future strategies (n = 0): <none>
[13:36:38.823] {
[13:36:38.823]     {
[13:36:38.823]         {
[13:36:38.823]             ...future.startTime <- base::Sys.time()
[13:36:38.823]             {
[13:36:38.823]                 {
[13:36:38.823]                   {
[13:36:38.823]                     {
[13:36:38.823]                       base::local({
[13:36:38.823]                         has_future <- base::requireNamespace("future", 
[13:36:38.823]                           quietly = TRUE)
[13:36:38.823]                         if (has_future) {
[13:36:38.823]                           ns <- base::getNamespace("future")
[13:36:38.823]                           version <- ns[[".package"]][["version"]]
[13:36:38.823]                           if (is.null(version)) 
[13:36:38.823]                             version <- utils::packageVersion("future")
[13:36:38.823]                         }
[13:36:38.823]                         else {
[13:36:38.823]                           version <- NULL
[13:36:38.823]                         }
[13:36:38.823]                         if (!has_future || version < "1.8.0") {
[13:36:38.823]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.823]                             "", base::R.version$version.string), 
[13:36:38.823]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.823]                               "release", "version")], collapse = " "), 
[13:36:38.823]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.823]                             info)
[13:36:38.823]                           info <- base::paste(info, collapse = "; ")
[13:36:38.823]                           if (!has_future) {
[13:36:38.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.823]                               info)
[13:36:38.823]                           }
[13:36:38.823]                           else {
[13:36:38.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.823]                               info, version)
[13:36:38.823]                           }
[13:36:38.823]                           base::stop(msg)
[13:36:38.823]                         }
[13:36:38.823]                       })
[13:36:38.823]                     }
[13:36:38.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.823]                     base::options(mc.cores = 1L)
[13:36:38.823]                   }
[13:36:38.823]                   ...future.strategy.old <- future::plan("list")
[13:36:38.823]                   options(future.plan = NULL)
[13:36:38.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.823]                 }
[13:36:38.823]                 ...future.workdir <- getwd()
[13:36:38.823]             }
[13:36:38.823]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.823]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.823]         }
[13:36:38.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.823]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.823]             base::names(...future.oldOptions))
[13:36:38.823]     }
[13:36:38.823]     if (FALSE) {
[13:36:38.823]     }
[13:36:38.823]     else {
[13:36:38.823]         if (TRUE) {
[13:36:38.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.823]                 open = "w")
[13:36:38.823]         }
[13:36:38.823]         else {
[13:36:38.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.823]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.823]         }
[13:36:38.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.823]             base::sink(type = "output", split = FALSE)
[13:36:38.823]             base::close(...future.stdout)
[13:36:38.823]         }, add = TRUE)
[13:36:38.823]     }
[13:36:38.823]     ...future.frame <- base::sys.nframe()
[13:36:38.823]     ...future.conditions <- base::list()
[13:36:38.823]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.823]     if (FALSE) {
[13:36:38.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.823]     }
[13:36:38.823]     ...future.result <- base::tryCatch({
[13:36:38.823]         base::withCallingHandlers({
[13:36:38.823]             ...future.value <- base::withVisible(base::local({
[13:36:38.823]                 ...future.makeSendCondition <- base::local({
[13:36:38.823]                   sendCondition <- NULL
[13:36:38.823]                   function(frame = 1L) {
[13:36:38.823]                     if (is.function(sendCondition)) 
[13:36:38.823]                       return(sendCondition)
[13:36:38.823]                     ns <- getNamespace("parallel")
[13:36:38.823]                     if (exists("sendData", mode = "function", 
[13:36:38.823]                       envir = ns)) {
[13:36:38.823]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.823]                         envir = ns)
[13:36:38.823]                       envir <- sys.frame(frame)
[13:36:38.823]                       master <- NULL
[13:36:38.823]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.823]                         !identical(envir, emptyenv())) {
[13:36:38.823]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.823]                           inherits = FALSE)) {
[13:36:38.823]                           master <- get("master", mode = "list", 
[13:36:38.823]                             envir = envir, inherits = FALSE)
[13:36:38.823]                           if (inherits(master, c("SOCKnode", 
[13:36:38.823]                             "SOCK0node"))) {
[13:36:38.823]                             sendCondition <<- function(cond) {
[13:36:38.823]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.823]                                 success = TRUE)
[13:36:38.823]                               parallel_sendData(master, data)
[13:36:38.823]                             }
[13:36:38.823]                             return(sendCondition)
[13:36:38.823]                           }
[13:36:38.823]                         }
[13:36:38.823]                         frame <- frame + 1L
[13:36:38.823]                         envir <- sys.frame(frame)
[13:36:38.823]                       }
[13:36:38.823]                     }
[13:36:38.823]                     sendCondition <<- function(cond) NULL
[13:36:38.823]                   }
[13:36:38.823]                 })
[13:36:38.823]                 withCallingHandlers({
[13:36:38.823]                   NULL
[13:36:38.823]                 }, immediateCondition = function(cond) {
[13:36:38.823]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.823]                   sendCondition(cond)
[13:36:38.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.823]                   {
[13:36:38.823]                     inherits <- base::inherits
[13:36:38.823]                     invokeRestart <- base::invokeRestart
[13:36:38.823]                     is.null <- base::is.null
[13:36:38.823]                     muffled <- FALSE
[13:36:38.823]                     if (inherits(cond, "message")) {
[13:36:38.823]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.823]                       if (muffled) 
[13:36:38.823]                         invokeRestart("muffleMessage")
[13:36:38.823]                     }
[13:36:38.823]                     else if (inherits(cond, "warning")) {
[13:36:38.823]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.823]                       if (muffled) 
[13:36:38.823]                         invokeRestart("muffleWarning")
[13:36:38.823]                     }
[13:36:38.823]                     else if (inherits(cond, "condition")) {
[13:36:38.823]                       if (!is.null(pattern)) {
[13:36:38.823]                         computeRestarts <- base::computeRestarts
[13:36:38.823]                         grepl <- base::grepl
[13:36:38.823]                         restarts <- computeRestarts(cond)
[13:36:38.823]                         for (restart in restarts) {
[13:36:38.823]                           name <- restart$name
[13:36:38.823]                           if (is.null(name)) 
[13:36:38.823]                             next
[13:36:38.823]                           if (!grepl(pattern, name)) 
[13:36:38.823]                             next
[13:36:38.823]                           invokeRestart(restart)
[13:36:38.823]                           muffled <- TRUE
[13:36:38.823]                           break
[13:36:38.823]                         }
[13:36:38.823]                       }
[13:36:38.823]                     }
[13:36:38.823]                     invisible(muffled)
[13:36:38.823]                   }
[13:36:38.823]                   muffleCondition(cond)
[13:36:38.823]                 })
[13:36:38.823]             }))
[13:36:38.823]             future::FutureResult(value = ...future.value$value, 
[13:36:38.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.823]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.823]                     ...future.globalenv.names))
[13:36:38.823]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.823]         }, condition = base::local({
[13:36:38.823]             c <- base::c
[13:36:38.823]             inherits <- base::inherits
[13:36:38.823]             invokeRestart <- base::invokeRestart
[13:36:38.823]             length <- base::length
[13:36:38.823]             list <- base::list
[13:36:38.823]             seq.int <- base::seq.int
[13:36:38.823]             signalCondition <- base::signalCondition
[13:36:38.823]             sys.calls <- base::sys.calls
[13:36:38.823]             `[[` <- base::`[[`
[13:36:38.823]             `+` <- base::`+`
[13:36:38.823]             `<<-` <- base::`<<-`
[13:36:38.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.823]                   3L)]
[13:36:38.823]             }
[13:36:38.823]             function(cond) {
[13:36:38.823]                 is_error <- inherits(cond, "error")
[13:36:38.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.823]                   NULL)
[13:36:38.823]                 if (is_error) {
[13:36:38.823]                   sessionInformation <- function() {
[13:36:38.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.823]                       search = base::search(), system = base::Sys.info())
[13:36:38.823]                   }
[13:36:38.823]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.823]                     cond$call), session = sessionInformation(), 
[13:36:38.823]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.823]                   signalCondition(cond)
[13:36:38.823]                 }
[13:36:38.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.823]                 "immediateCondition"))) {
[13:36:38.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.823]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.823]                   if (TRUE && !signal) {
[13:36:38.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.823]                     {
[13:36:38.823]                       inherits <- base::inherits
[13:36:38.823]                       invokeRestart <- base::invokeRestart
[13:36:38.823]                       is.null <- base::is.null
[13:36:38.823]                       muffled <- FALSE
[13:36:38.823]                       if (inherits(cond, "message")) {
[13:36:38.823]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.823]                         if (muffled) 
[13:36:38.823]                           invokeRestart("muffleMessage")
[13:36:38.823]                       }
[13:36:38.823]                       else if (inherits(cond, "warning")) {
[13:36:38.823]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.823]                         if (muffled) 
[13:36:38.823]                           invokeRestart("muffleWarning")
[13:36:38.823]                       }
[13:36:38.823]                       else if (inherits(cond, "condition")) {
[13:36:38.823]                         if (!is.null(pattern)) {
[13:36:38.823]                           computeRestarts <- base::computeRestarts
[13:36:38.823]                           grepl <- base::grepl
[13:36:38.823]                           restarts <- computeRestarts(cond)
[13:36:38.823]                           for (restart in restarts) {
[13:36:38.823]                             name <- restart$name
[13:36:38.823]                             if (is.null(name)) 
[13:36:38.823]                               next
[13:36:38.823]                             if (!grepl(pattern, name)) 
[13:36:38.823]                               next
[13:36:38.823]                             invokeRestart(restart)
[13:36:38.823]                             muffled <- TRUE
[13:36:38.823]                             break
[13:36:38.823]                           }
[13:36:38.823]                         }
[13:36:38.823]                       }
[13:36:38.823]                       invisible(muffled)
[13:36:38.823]                     }
[13:36:38.823]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.823]                   }
[13:36:38.823]                 }
[13:36:38.823]                 else {
[13:36:38.823]                   if (TRUE) {
[13:36:38.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.823]                     {
[13:36:38.823]                       inherits <- base::inherits
[13:36:38.823]                       invokeRestart <- base::invokeRestart
[13:36:38.823]                       is.null <- base::is.null
[13:36:38.823]                       muffled <- FALSE
[13:36:38.823]                       if (inherits(cond, "message")) {
[13:36:38.823]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.823]                         if (muffled) 
[13:36:38.823]                           invokeRestart("muffleMessage")
[13:36:38.823]                       }
[13:36:38.823]                       else if (inherits(cond, "warning")) {
[13:36:38.823]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.823]                         if (muffled) 
[13:36:38.823]                           invokeRestart("muffleWarning")
[13:36:38.823]                       }
[13:36:38.823]                       else if (inherits(cond, "condition")) {
[13:36:38.823]                         if (!is.null(pattern)) {
[13:36:38.823]                           computeRestarts <- base::computeRestarts
[13:36:38.823]                           grepl <- base::grepl
[13:36:38.823]                           restarts <- computeRestarts(cond)
[13:36:38.823]                           for (restart in restarts) {
[13:36:38.823]                             name <- restart$name
[13:36:38.823]                             if (is.null(name)) 
[13:36:38.823]                               next
[13:36:38.823]                             if (!grepl(pattern, name)) 
[13:36:38.823]                               next
[13:36:38.823]                             invokeRestart(restart)
[13:36:38.823]                             muffled <- TRUE
[13:36:38.823]                             break
[13:36:38.823]                           }
[13:36:38.823]                         }
[13:36:38.823]                       }
[13:36:38.823]                       invisible(muffled)
[13:36:38.823]                     }
[13:36:38.823]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.823]                   }
[13:36:38.823]                 }
[13:36:38.823]             }
[13:36:38.823]         }))
[13:36:38.823]     }, error = function(ex) {
[13:36:38.823]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.823]                 ...future.rng), started = ...future.startTime, 
[13:36:38.823]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.823]             version = "1.8"), class = "FutureResult")
[13:36:38.823]     }, finally = {
[13:36:38.823]         if (!identical(...future.workdir, getwd())) 
[13:36:38.823]             setwd(...future.workdir)
[13:36:38.823]         {
[13:36:38.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.823]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.823]             }
[13:36:38.823]             base::options(...future.oldOptions)
[13:36:38.823]             if (.Platform$OS.type == "windows") {
[13:36:38.823]                 old_names <- names(...future.oldEnvVars)
[13:36:38.823]                 envs <- base::Sys.getenv()
[13:36:38.823]                 names <- names(envs)
[13:36:38.823]                 common <- intersect(names, old_names)
[13:36:38.823]                 added <- setdiff(names, old_names)
[13:36:38.823]                 removed <- setdiff(old_names, names)
[13:36:38.823]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.823]                   envs[common]]
[13:36:38.823]                 NAMES <- toupper(changed)
[13:36:38.823]                 args <- list()
[13:36:38.823]                 for (kk in seq_along(NAMES)) {
[13:36:38.823]                   name <- changed[[kk]]
[13:36:38.823]                   NAME <- NAMES[[kk]]
[13:36:38.823]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.823]                     next
[13:36:38.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.823]                 }
[13:36:38.823]                 NAMES <- toupper(added)
[13:36:38.823]                 for (kk in seq_along(NAMES)) {
[13:36:38.823]                   name <- added[[kk]]
[13:36:38.823]                   NAME <- NAMES[[kk]]
[13:36:38.823]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.823]                     next
[13:36:38.823]                   args[[name]] <- ""
[13:36:38.823]                 }
[13:36:38.823]                 NAMES <- toupper(removed)
[13:36:38.823]                 for (kk in seq_along(NAMES)) {
[13:36:38.823]                   name <- removed[[kk]]
[13:36:38.823]                   NAME <- NAMES[[kk]]
[13:36:38.823]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.823]                     next
[13:36:38.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.823]                 }
[13:36:38.823]                 if (length(args) > 0) 
[13:36:38.823]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.823]             }
[13:36:38.823]             else {
[13:36:38.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.823]             }
[13:36:38.823]             {
[13:36:38.823]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.823]                   0L) {
[13:36:38.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.823]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.823]                   base::options(opts)
[13:36:38.823]                 }
[13:36:38.823]                 {
[13:36:38.823]                   {
[13:36:38.823]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.823]                     NULL
[13:36:38.823]                   }
[13:36:38.823]                   options(future.plan = NULL)
[13:36:38.823]                   if (is.na(NA_character_)) 
[13:36:38.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.823]                     .init = FALSE)
[13:36:38.823]                 }
[13:36:38.823]             }
[13:36:38.823]         }
[13:36:38.823]     })
[13:36:38.823]     if (TRUE) {
[13:36:38.823]         base::sink(type = "output", split = FALSE)
[13:36:38.823]         if (TRUE) {
[13:36:38.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.823]         }
[13:36:38.823]         else {
[13:36:38.823]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.823]         }
[13:36:38.823]         base::close(...future.stdout)
[13:36:38.823]         ...future.stdout <- NULL
[13:36:38.823]     }
[13:36:38.823]     ...future.result$conditions <- ...future.conditions
[13:36:38.823]     ...future.result$finished <- base::Sys.time()
[13:36:38.823]     ...future.result
[13:36:38.823] }
[13:36:38.825] MultisessionFuture started
[13:36:38.825] - Launch lazy future ... done
[13:36:38.826] run() for ‘MultisessionFuture’ ... done
[13:36:38.826] getGlobalsAndPackages() ...
[13:36:38.826] Searching for globals...
[13:36:38.827] - globals found: [1] ‘{’
[13:36:38.827] Searching for globals ... DONE
[13:36:38.827] Resolving globals: FALSE
[13:36:38.827] 
[13:36:38.827] 
[13:36:38.827] getGlobalsAndPackages() ... DONE
[13:36:38.828] run() for ‘Future’ ...
[13:36:38.828] - state: ‘created’
[13:36:38.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.841] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.841]   - Field: ‘node’
[13:36:38.841]   - Field: ‘label’
[13:36:38.842]   - Field: ‘local’
[13:36:38.842]   - Field: ‘owner’
[13:36:38.842]   - Field: ‘envir’
[13:36:38.842]   - Field: ‘workers’
[13:36:38.842]   - Field: ‘packages’
[13:36:38.842]   - Field: ‘gc’
[13:36:38.842]   - Field: ‘conditions’
[13:36:38.842]   - Field: ‘persistent’
[13:36:38.842]   - Field: ‘expr’
[13:36:38.842]   - Field: ‘uuid’
[13:36:38.843]   - Field: ‘seed’
[13:36:38.843]   - Field: ‘version’
[13:36:38.843]   - Field: ‘result’
[13:36:38.843]   - Field: ‘asynchronous’
[13:36:38.843]   - Field: ‘calls’
[13:36:38.843]   - Field: ‘globals’
[13:36:38.843]   - Field: ‘stdout’
[13:36:38.843]   - Field: ‘earlySignal’
[13:36:38.843]   - Field: ‘lazy’
[13:36:38.843]   - Field: ‘state’
[13:36:38.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.844] - Launch lazy future ...
[13:36:38.844] Packages needed by the future expression (n = 0): <none>
[13:36:38.844] Packages needed by future strategies (n = 0): <none>
[13:36:38.844] {
[13:36:38.844]     {
[13:36:38.844]         {
[13:36:38.844]             ...future.startTime <- base::Sys.time()
[13:36:38.844]             {
[13:36:38.844]                 {
[13:36:38.844]                   {
[13:36:38.844]                     {
[13:36:38.844]                       base::local({
[13:36:38.844]                         has_future <- base::requireNamespace("future", 
[13:36:38.844]                           quietly = TRUE)
[13:36:38.844]                         if (has_future) {
[13:36:38.844]                           ns <- base::getNamespace("future")
[13:36:38.844]                           version <- ns[[".package"]][["version"]]
[13:36:38.844]                           if (is.null(version)) 
[13:36:38.844]                             version <- utils::packageVersion("future")
[13:36:38.844]                         }
[13:36:38.844]                         else {
[13:36:38.844]                           version <- NULL
[13:36:38.844]                         }
[13:36:38.844]                         if (!has_future || version < "1.8.0") {
[13:36:38.844]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.844]                             "", base::R.version$version.string), 
[13:36:38.844]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.844]                               "release", "version")], collapse = " "), 
[13:36:38.844]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.844]                             info)
[13:36:38.844]                           info <- base::paste(info, collapse = "; ")
[13:36:38.844]                           if (!has_future) {
[13:36:38.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.844]                               info)
[13:36:38.844]                           }
[13:36:38.844]                           else {
[13:36:38.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.844]                               info, version)
[13:36:38.844]                           }
[13:36:38.844]                           base::stop(msg)
[13:36:38.844]                         }
[13:36:38.844]                       })
[13:36:38.844]                     }
[13:36:38.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.844]                     base::options(mc.cores = 1L)
[13:36:38.844]                   }
[13:36:38.844]                   ...future.strategy.old <- future::plan("list")
[13:36:38.844]                   options(future.plan = NULL)
[13:36:38.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.844]                 }
[13:36:38.844]                 ...future.workdir <- getwd()
[13:36:38.844]             }
[13:36:38.844]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.844]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.844]         }
[13:36:38.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.844]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.844]             base::names(...future.oldOptions))
[13:36:38.844]     }
[13:36:38.844]     if (FALSE) {
[13:36:38.844]     }
[13:36:38.844]     else {
[13:36:38.844]         if (TRUE) {
[13:36:38.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.844]                 open = "w")
[13:36:38.844]         }
[13:36:38.844]         else {
[13:36:38.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.844]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.844]         }
[13:36:38.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.844]             base::sink(type = "output", split = FALSE)
[13:36:38.844]             base::close(...future.stdout)
[13:36:38.844]         }, add = TRUE)
[13:36:38.844]     }
[13:36:38.844]     ...future.frame <- base::sys.nframe()
[13:36:38.844]     ...future.conditions <- base::list()
[13:36:38.844]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.844]     if (FALSE) {
[13:36:38.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.844]     }
[13:36:38.844]     ...future.result <- base::tryCatch({
[13:36:38.844]         base::withCallingHandlers({
[13:36:38.844]             ...future.value <- base::withVisible(base::local({
[13:36:38.844]                 ...future.makeSendCondition <- base::local({
[13:36:38.844]                   sendCondition <- NULL
[13:36:38.844]                   function(frame = 1L) {
[13:36:38.844]                     if (is.function(sendCondition)) 
[13:36:38.844]                       return(sendCondition)
[13:36:38.844]                     ns <- getNamespace("parallel")
[13:36:38.844]                     if (exists("sendData", mode = "function", 
[13:36:38.844]                       envir = ns)) {
[13:36:38.844]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.844]                         envir = ns)
[13:36:38.844]                       envir <- sys.frame(frame)
[13:36:38.844]                       master <- NULL
[13:36:38.844]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.844]                         !identical(envir, emptyenv())) {
[13:36:38.844]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.844]                           inherits = FALSE)) {
[13:36:38.844]                           master <- get("master", mode = "list", 
[13:36:38.844]                             envir = envir, inherits = FALSE)
[13:36:38.844]                           if (inherits(master, c("SOCKnode", 
[13:36:38.844]                             "SOCK0node"))) {
[13:36:38.844]                             sendCondition <<- function(cond) {
[13:36:38.844]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.844]                                 success = TRUE)
[13:36:38.844]                               parallel_sendData(master, data)
[13:36:38.844]                             }
[13:36:38.844]                             return(sendCondition)
[13:36:38.844]                           }
[13:36:38.844]                         }
[13:36:38.844]                         frame <- frame + 1L
[13:36:38.844]                         envir <- sys.frame(frame)
[13:36:38.844]                       }
[13:36:38.844]                     }
[13:36:38.844]                     sendCondition <<- function(cond) NULL
[13:36:38.844]                   }
[13:36:38.844]                 })
[13:36:38.844]                 withCallingHandlers({
[13:36:38.844]                   {
[13:36:38.844]                     4
[13:36:38.844]                   }
[13:36:38.844]                 }, immediateCondition = function(cond) {
[13:36:38.844]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.844]                   sendCondition(cond)
[13:36:38.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.844]                   {
[13:36:38.844]                     inherits <- base::inherits
[13:36:38.844]                     invokeRestart <- base::invokeRestart
[13:36:38.844]                     is.null <- base::is.null
[13:36:38.844]                     muffled <- FALSE
[13:36:38.844]                     if (inherits(cond, "message")) {
[13:36:38.844]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.844]                       if (muffled) 
[13:36:38.844]                         invokeRestart("muffleMessage")
[13:36:38.844]                     }
[13:36:38.844]                     else if (inherits(cond, "warning")) {
[13:36:38.844]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.844]                       if (muffled) 
[13:36:38.844]                         invokeRestart("muffleWarning")
[13:36:38.844]                     }
[13:36:38.844]                     else if (inherits(cond, "condition")) {
[13:36:38.844]                       if (!is.null(pattern)) {
[13:36:38.844]                         computeRestarts <- base::computeRestarts
[13:36:38.844]                         grepl <- base::grepl
[13:36:38.844]                         restarts <- computeRestarts(cond)
[13:36:38.844]                         for (restart in restarts) {
[13:36:38.844]                           name <- restart$name
[13:36:38.844]                           if (is.null(name)) 
[13:36:38.844]                             next
[13:36:38.844]                           if (!grepl(pattern, name)) 
[13:36:38.844]                             next
[13:36:38.844]                           invokeRestart(restart)
[13:36:38.844]                           muffled <- TRUE
[13:36:38.844]                           break
[13:36:38.844]                         }
[13:36:38.844]                       }
[13:36:38.844]                     }
[13:36:38.844]                     invisible(muffled)
[13:36:38.844]                   }
[13:36:38.844]                   muffleCondition(cond)
[13:36:38.844]                 })
[13:36:38.844]             }))
[13:36:38.844]             future::FutureResult(value = ...future.value$value, 
[13:36:38.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.844]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.844]                     ...future.globalenv.names))
[13:36:38.844]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.844]         }, condition = base::local({
[13:36:38.844]             c <- base::c
[13:36:38.844]             inherits <- base::inherits
[13:36:38.844]             invokeRestart <- base::invokeRestart
[13:36:38.844]             length <- base::length
[13:36:38.844]             list <- base::list
[13:36:38.844]             seq.int <- base::seq.int
[13:36:38.844]             signalCondition <- base::signalCondition
[13:36:38.844]             sys.calls <- base::sys.calls
[13:36:38.844]             `[[` <- base::`[[`
[13:36:38.844]             `+` <- base::`+`
[13:36:38.844]             `<<-` <- base::`<<-`
[13:36:38.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.844]                   3L)]
[13:36:38.844]             }
[13:36:38.844]             function(cond) {
[13:36:38.844]                 is_error <- inherits(cond, "error")
[13:36:38.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.844]                   NULL)
[13:36:38.844]                 if (is_error) {
[13:36:38.844]                   sessionInformation <- function() {
[13:36:38.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.844]                       search = base::search(), system = base::Sys.info())
[13:36:38.844]                   }
[13:36:38.844]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.844]                     cond$call), session = sessionInformation(), 
[13:36:38.844]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.844]                   signalCondition(cond)
[13:36:38.844]                 }
[13:36:38.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.844]                 "immediateCondition"))) {
[13:36:38.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.844]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.844]                   if (TRUE && !signal) {
[13:36:38.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.844]                     {
[13:36:38.844]                       inherits <- base::inherits
[13:36:38.844]                       invokeRestart <- base::invokeRestart
[13:36:38.844]                       is.null <- base::is.null
[13:36:38.844]                       muffled <- FALSE
[13:36:38.844]                       if (inherits(cond, "message")) {
[13:36:38.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.844]                         if (muffled) 
[13:36:38.844]                           invokeRestart("muffleMessage")
[13:36:38.844]                       }
[13:36:38.844]                       else if (inherits(cond, "warning")) {
[13:36:38.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.844]                         if (muffled) 
[13:36:38.844]                           invokeRestart("muffleWarning")
[13:36:38.844]                       }
[13:36:38.844]                       else if (inherits(cond, "condition")) {
[13:36:38.844]                         if (!is.null(pattern)) {
[13:36:38.844]                           computeRestarts <- base::computeRestarts
[13:36:38.844]                           grepl <- base::grepl
[13:36:38.844]                           restarts <- computeRestarts(cond)
[13:36:38.844]                           for (restart in restarts) {
[13:36:38.844]                             name <- restart$name
[13:36:38.844]                             if (is.null(name)) 
[13:36:38.844]                               next
[13:36:38.844]                             if (!grepl(pattern, name)) 
[13:36:38.844]                               next
[13:36:38.844]                             invokeRestart(restart)
[13:36:38.844]                             muffled <- TRUE
[13:36:38.844]                             break
[13:36:38.844]                           }
[13:36:38.844]                         }
[13:36:38.844]                       }
[13:36:38.844]                       invisible(muffled)
[13:36:38.844]                     }
[13:36:38.844]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.844]                   }
[13:36:38.844]                 }
[13:36:38.844]                 else {
[13:36:38.844]                   if (TRUE) {
[13:36:38.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.844]                     {
[13:36:38.844]                       inherits <- base::inherits
[13:36:38.844]                       invokeRestart <- base::invokeRestart
[13:36:38.844]                       is.null <- base::is.null
[13:36:38.844]                       muffled <- FALSE
[13:36:38.844]                       if (inherits(cond, "message")) {
[13:36:38.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.844]                         if (muffled) 
[13:36:38.844]                           invokeRestart("muffleMessage")
[13:36:38.844]                       }
[13:36:38.844]                       else if (inherits(cond, "warning")) {
[13:36:38.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.844]                         if (muffled) 
[13:36:38.844]                           invokeRestart("muffleWarning")
[13:36:38.844]                       }
[13:36:38.844]                       else if (inherits(cond, "condition")) {
[13:36:38.844]                         if (!is.null(pattern)) {
[13:36:38.844]                           computeRestarts <- base::computeRestarts
[13:36:38.844]                           grepl <- base::grepl
[13:36:38.844]                           restarts <- computeRestarts(cond)
[13:36:38.844]                           for (restart in restarts) {
[13:36:38.844]                             name <- restart$name
[13:36:38.844]                             if (is.null(name)) 
[13:36:38.844]                               next
[13:36:38.844]                             if (!grepl(pattern, name)) 
[13:36:38.844]                               next
[13:36:38.844]                             invokeRestart(restart)
[13:36:38.844]                             muffled <- TRUE
[13:36:38.844]                             break
[13:36:38.844]                           }
[13:36:38.844]                         }
[13:36:38.844]                       }
[13:36:38.844]                       invisible(muffled)
[13:36:38.844]                     }
[13:36:38.844]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.844]                   }
[13:36:38.844]                 }
[13:36:38.844]             }
[13:36:38.844]         }))
[13:36:38.844]     }, error = function(ex) {
[13:36:38.844]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.844]                 ...future.rng), started = ...future.startTime, 
[13:36:38.844]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.844]             version = "1.8"), class = "FutureResult")
[13:36:38.844]     }, finally = {
[13:36:38.844]         if (!identical(...future.workdir, getwd())) 
[13:36:38.844]             setwd(...future.workdir)
[13:36:38.844]         {
[13:36:38.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.844]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.844]             }
[13:36:38.844]             base::options(...future.oldOptions)
[13:36:38.844]             if (.Platform$OS.type == "windows") {
[13:36:38.844]                 old_names <- names(...future.oldEnvVars)
[13:36:38.844]                 envs <- base::Sys.getenv()
[13:36:38.844]                 names <- names(envs)
[13:36:38.844]                 common <- intersect(names, old_names)
[13:36:38.844]                 added <- setdiff(names, old_names)
[13:36:38.844]                 removed <- setdiff(old_names, names)
[13:36:38.844]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.844]                   envs[common]]
[13:36:38.844]                 NAMES <- toupper(changed)
[13:36:38.844]                 args <- list()
[13:36:38.844]                 for (kk in seq_along(NAMES)) {
[13:36:38.844]                   name <- changed[[kk]]
[13:36:38.844]                   NAME <- NAMES[[kk]]
[13:36:38.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.844]                     next
[13:36:38.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.844]                 }
[13:36:38.844]                 NAMES <- toupper(added)
[13:36:38.844]                 for (kk in seq_along(NAMES)) {
[13:36:38.844]                   name <- added[[kk]]
[13:36:38.844]                   NAME <- NAMES[[kk]]
[13:36:38.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.844]                     next
[13:36:38.844]                   args[[name]] <- ""
[13:36:38.844]                 }
[13:36:38.844]                 NAMES <- toupper(removed)
[13:36:38.844]                 for (kk in seq_along(NAMES)) {
[13:36:38.844]                   name <- removed[[kk]]
[13:36:38.844]                   NAME <- NAMES[[kk]]
[13:36:38.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.844]                     next
[13:36:38.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.844]                 }
[13:36:38.844]                 if (length(args) > 0) 
[13:36:38.844]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.844]             }
[13:36:38.844]             else {
[13:36:38.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.844]             }
[13:36:38.844]             {
[13:36:38.844]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.844]                   0L) {
[13:36:38.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.844]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.844]                   base::options(opts)
[13:36:38.844]                 }
[13:36:38.844]                 {
[13:36:38.844]                   {
[13:36:38.844]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.844]                     NULL
[13:36:38.844]                   }
[13:36:38.844]                   options(future.plan = NULL)
[13:36:38.844]                   if (is.na(NA_character_)) 
[13:36:38.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.844]                     .init = FALSE)
[13:36:38.844]                 }
[13:36:38.844]             }
[13:36:38.844]         }
[13:36:38.844]     })
[13:36:38.844]     if (TRUE) {
[13:36:38.844]         base::sink(type = "output", split = FALSE)
[13:36:38.844]         if (TRUE) {
[13:36:38.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.844]         }
[13:36:38.844]         else {
[13:36:38.844]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.844]         }
[13:36:38.844]         base::close(...future.stdout)
[13:36:38.844]         ...future.stdout <- NULL
[13:36:38.844]     }
[13:36:38.844]     ...future.result$conditions <- ...future.conditions
[13:36:38.844]     ...future.result$finished <- base::Sys.time()
[13:36:38.844]     ...future.result
[13:36:38.844] }
[13:36:38.846] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:38.857] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.857] - Validating connection of MultisessionFuture
[13:36:38.858] - received message: FutureResult
[13:36:38.858] - Received FutureResult
[13:36:38.858] - Erased future from FutureRegistry
[13:36:38.858] result() for ClusterFuture ...
[13:36:38.858] - result already collected: FutureResult
[13:36:38.858] result() for ClusterFuture ... done
[13:36:38.858] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.858] result() for ClusterFuture ...
[13:36:38.858] - result already collected: FutureResult
[13:36:38.859] result() for ClusterFuture ... done
[13:36:38.859] result() for ClusterFuture ...
[13:36:38.859] - result already collected: FutureResult
[13:36:38.859] result() for ClusterFuture ... done
[13:36:38.860] MultisessionFuture started
[13:36:38.860] - Launch lazy future ... done
[13:36:38.860] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a742d4ca8> 
Classes 'listenv', 'environment' <environment: 0x564a73aaf498> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:38.868] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.868] - Validating connection of MultisessionFuture
[13:36:38.868] - received message: FutureResult
[13:36:38.868] - Received FutureResult
[13:36:38.868] - Erased future from FutureRegistry
[13:36:38.868] result() for ClusterFuture ...
[13:36:38.868] - result already collected: FutureResult
[13:36:38.868] result() for ClusterFuture ... done
[13:36:38.869] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.869] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.869] - Validating connection of MultisessionFuture
[13:36:38.869] - received message: FutureResult
[13:36:38.869] - Received FutureResult
[13:36:38.869] - Erased future from FutureRegistry
[13:36:38.870] result() for ClusterFuture ...
[13:36:38.870] - result already collected: FutureResult
[13:36:38.870] result() for ClusterFuture ... done
[13:36:38.870] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:38.872] resolve() on list environment ...
[13:36:38.872]  recursive: 0
[13:36:38.873]  length: 6
[13:36:38.873]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:38.874] signalConditionsASAP(numeric, pos=1) ...
[13:36:38.874] - nx: 6
[13:36:38.874] - relay: TRUE
[13:36:38.874] - stdout: TRUE
[13:36:38.874] - signal: TRUE
[13:36:38.874] - resignal: FALSE
[13:36:38.874] - force: TRUE
[13:36:38.874] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.874] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.874]  - until=2
[13:36:38.875]  - relaying element #2
[13:36:38.875] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.875] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.875] signalConditionsASAP(NULL, pos=1) ... done
[13:36:38.875]  length: 5 (resolved future 1)
[13:36:38.875] Future #2
[13:36:38.875] result() for ClusterFuture ...
[13:36:38.875] - result already collected: FutureResult
[13:36:38.875] result() for ClusterFuture ... done
[13:36:38.875] result() for ClusterFuture ...
[13:36:38.875] - result already collected: FutureResult
[13:36:38.876] result() for ClusterFuture ... done
[13:36:38.876] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:38.876] - nx: 6
[13:36:38.876] - relay: TRUE
[13:36:38.876] - stdout: TRUE
[13:36:38.876] - signal: TRUE
[13:36:38.876] - resignal: FALSE
[13:36:38.876] - force: TRUE
[13:36:38.876] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.876] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.876]  - until=2
[13:36:38.876]  - relaying element #2
[13:36:38.877] result() for ClusterFuture ...
[13:36:38.877] - result already collected: FutureResult
[13:36:38.877] result() for ClusterFuture ... done
[13:36:38.877] result() for ClusterFuture ...
[13:36:38.877] - result already collected: FutureResult
[13:36:38.877] result() for ClusterFuture ... done
[13:36:38.877] result() for ClusterFuture ...
[13:36:38.877] - result already collected: FutureResult
[13:36:38.877] result() for ClusterFuture ... done
[13:36:38.877] result() for ClusterFuture ...
[13:36:38.877] - result already collected: FutureResult
[13:36:38.878] result() for ClusterFuture ... done
[13:36:38.878] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.878] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.878] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:38.878]  length: 4 (resolved future 2)
[13:36:38.878] Future #3
[13:36:38.878] result() for ClusterFuture ...
[13:36:38.878] - result already collected: FutureResult
[13:36:38.878] result() for ClusterFuture ... done
[13:36:38.878] result() for ClusterFuture ...
[13:36:38.878] - result already collected: FutureResult
[13:36:38.879] result() for ClusterFuture ... done
[13:36:38.879] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:38.879] - nx: 6
[13:36:38.879] - relay: TRUE
[13:36:38.879] - stdout: TRUE
[13:36:38.879] - signal: TRUE
[13:36:38.879] - resignal: FALSE
[13:36:38.879] - force: TRUE
[13:36:38.879] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.879] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.879]  - until=3
[13:36:38.880]  - relaying element #3
[13:36:38.880] result() for ClusterFuture ...
[13:36:38.880] - result already collected: FutureResult
[13:36:38.880] result() for ClusterFuture ... done
[13:36:38.880] result() for ClusterFuture ...
[13:36:38.880] - result already collected: FutureResult
[13:36:38.880] result() for ClusterFuture ... done
[13:36:38.880] result() for ClusterFuture ...
[13:36:38.880] - result already collected: FutureResult
[13:36:38.880] result() for ClusterFuture ... done
[13:36:38.880] result() for ClusterFuture ...
[13:36:38.881] - result already collected: FutureResult
[13:36:38.881] result() for ClusterFuture ... done
[13:36:38.881] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.881] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.881] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:38.881]  length: 3 (resolved future 3)
[13:36:38.881] Future #4
[13:36:38.881] result() for ClusterFuture ...
[13:36:38.881] - result already collected: FutureResult
[13:36:38.881] result() for ClusterFuture ... done
[13:36:38.881] result() for ClusterFuture ...
[13:36:38.882] - result already collected: FutureResult
[13:36:38.882] result() for ClusterFuture ... done
[13:36:38.882] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:38.882] - nx: 6
[13:36:38.882] - relay: TRUE
[13:36:38.882] - stdout: TRUE
[13:36:38.882] - signal: TRUE
[13:36:38.882] - resignal: FALSE
[13:36:38.882] - force: TRUE
[13:36:38.882] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.882] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.883]  - until=4
[13:36:38.883]  - relaying element #4
[13:36:38.883] result() for ClusterFuture ...
[13:36:38.883] - result already collected: FutureResult
[13:36:38.883] result() for ClusterFuture ... done
[13:36:38.883] result() for ClusterFuture ...
[13:36:38.883] - result already collected: FutureResult
[13:36:38.883] result() for ClusterFuture ... done
[13:36:38.883] result() for ClusterFuture ...
[13:36:38.883] - result already collected: FutureResult
[13:36:38.883] result() for ClusterFuture ... done
[13:36:38.883] result() for ClusterFuture ...
[13:36:38.884] - result already collected: FutureResult
[13:36:38.884] result() for ClusterFuture ... done
[13:36:38.884] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.884] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.884] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:38.884]  length: 2 (resolved future 4)
[13:36:38.884] signalConditionsASAP(NULL, pos=5) ...
[13:36:38.884] - nx: 6
[13:36:38.884] - relay: TRUE
[13:36:38.884] - stdout: TRUE
[13:36:38.884] - signal: TRUE
[13:36:38.885] - resignal: FALSE
[13:36:38.885] - force: TRUE
[13:36:38.885] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.885] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.885]  - until=6
[13:36:38.885]  - relaying element #6
[13:36:38.885] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.885] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.885] signalConditionsASAP(NULL, pos=5) ... done
[13:36:38.885]  length: 1 (resolved future 5)
[13:36:38.885] signalConditionsASAP(numeric, pos=6) ...
[13:36:38.886] - nx: 6
[13:36:38.886] - relay: TRUE
[13:36:38.886] - stdout: TRUE
[13:36:38.886] - signal: TRUE
[13:36:38.886] - resignal: FALSE
[13:36:38.886] - force: TRUE
[13:36:38.886] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.886] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.886]  - until=6
[13:36:38.886] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.886] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.887] signalConditionsASAP(numeric, pos=6) ... done
[13:36:38.887]  length: 0 (resolved future 6)
[13:36:38.887] Relaying remaining futures
[13:36:38.887] signalConditionsASAP(NULL, pos=0) ...
[13:36:38.887] - nx: 6
[13:36:38.887] - relay: TRUE
[13:36:38.887] - stdout: TRUE
[13:36:38.887] - signal: TRUE
[13:36:38.887] - resignal: FALSE
[13:36:38.887] - force: TRUE
[13:36:38.887] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.887] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:38.888] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.888] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.888] signalConditionsASAP(NULL, pos=0) ... done
[13:36:38.888] resolve() on list environment ... DONE
[13:36:38.888] result() for ClusterFuture ...
[13:36:38.888] - result already collected: FutureResult
[13:36:38.888] result() for ClusterFuture ... done
[13:36:38.888] result() for ClusterFuture ...
[13:36:38.888] - result already collected: FutureResult
[13:36:38.888] result() for ClusterFuture ... done
[13:36:38.889] result() for ClusterFuture ...
[13:36:38.889] - result already collected: FutureResult
[13:36:38.889] result() for ClusterFuture ... done
[13:36:38.889] result() for ClusterFuture ...
[13:36:38.889] - result already collected: FutureResult
[13:36:38.889] result() for ClusterFuture ... done
[13:36:38.889] result() for ClusterFuture ...
[13:36:38.889] - result already collected: FutureResult
[13:36:38.889] result() for ClusterFuture ... done
[13:36:38.889] result() for ClusterFuture ...
[13:36:38.890] - result already collected: FutureResult
[13:36:38.890] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a7332fb28> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:36:38.892] getGlobalsAndPackages() ...
[13:36:38.892] Searching for globals...
[13:36:38.892] 
[13:36:38.892] Searching for globals ... DONE
[13:36:38.892] - globals: [0] <none>
[13:36:38.892] getGlobalsAndPackages() ... DONE
[13:36:38.892] run() for ‘Future’ ...
[13:36:38.893] - state: ‘created’
[13:36:38.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.907]   - Field: ‘node’
[13:36:38.907]   - Field: ‘label’
[13:36:38.907]   - Field: ‘local’
[13:36:38.907]   - Field: ‘owner’
[13:36:38.907]   - Field: ‘envir’
[13:36:38.907]   - Field: ‘workers’
[13:36:38.907]   - Field: ‘packages’
[13:36:38.907]   - Field: ‘gc’
[13:36:38.907]   - Field: ‘conditions’
[13:36:38.907]   - Field: ‘persistent’
[13:36:38.908]   - Field: ‘expr’
[13:36:38.908]   - Field: ‘uuid’
[13:36:38.908]   - Field: ‘seed’
[13:36:38.908]   - Field: ‘version’
[13:36:38.908]   - Field: ‘result’
[13:36:38.908]   - Field: ‘asynchronous’
[13:36:38.908]   - Field: ‘calls’
[13:36:38.908]   - Field: ‘globals’
[13:36:38.908]   - Field: ‘stdout’
[13:36:38.908]   - Field: ‘earlySignal’
[13:36:38.908]   - Field: ‘lazy’
[13:36:38.909]   - Field: ‘state’
[13:36:38.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.909] - Launch lazy future ...
[13:36:38.909] Packages needed by the future expression (n = 0): <none>
[13:36:38.909] Packages needed by future strategies (n = 0): <none>
[13:36:38.910] {
[13:36:38.910]     {
[13:36:38.910]         {
[13:36:38.910]             ...future.startTime <- base::Sys.time()
[13:36:38.910]             {
[13:36:38.910]                 {
[13:36:38.910]                   {
[13:36:38.910]                     {
[13:36:38.910]                       base::local({
[13:36:38.910]                         has_future <- base::requireNamespace("future", 
[13:36:38.910]                           quietly = TRUE)
[13:36:38.910]                         if (has_future) {
[13:36:38.910]                           ns <- base::getNamespace("future")
[13:36:38.910]                           version <- ns[[".package"]][["version"]]
[13:36:38.910]                           if (is.null(version)) 
[13:36:38.910]                             version <- utils::packageVersion("future")
[13:36:38.910]                         }
[13:36:38.910]                         else {
[13:36:38.910]                           version <- NULL
[13:36:38.910]                         }
[13:36:38.910]                         if (!has_future || version < "1.8.0") {
[13:36:38.910]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.910]                             "", base::R.version$version.string), 
[13:36:38.910]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.910]                               "release", "version")], collapse = " "), 
[13:36:38.910]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.910]                             info)
[13:36:38.910]                           info <- base::paste(info, collapse = "; ")
[13:36:38.910]                           if (!has_future) {
[13:36:38.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.910]                               info)
[13:36:38.910]                           }
[13:36:38.910]                           else {
[13:36:38.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.910]                               info, version)
[13:36:38.910]                           }
[13:36:38.910]                           base::stop(msg)
[13:36:38.910]                         }
[13:36:38.910]                       })
[13:36:38.910]                     }
[13:36:38.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.910]                     base::options(mc.cores = 1L)
[13:36:38.910]                   }
[13:36:38.910]                   ...future.strategy.old <- future::plan("list")
[13:36:38.910]                   options(future.plan = NULL)
[13:36:38.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.910]                 }
[13:36:38.910]                 ...future.workdir <- getwd()
[13:36:38.910]             }
[13:36:38.910]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.910]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.910]         }
[13:36:38.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.910]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.910]             base::names(...future.oldOptions))
[13:36:38.910]     }
[13:36:38.910]     if (FALSE) {
[13:36:38.910]     }
[13:36:38.910]     else {
[13:36:38.910]         if (TRUE) {
[13:36:38.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.910]                 open = "w")
[13:36:38.910]         }
[13:36:38.910]         else {
[13:36:38.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.910]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.910]         }
[13:36:38.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.910]             base::sink(type = "output", split = FALSE)
[13:36:38.910]             base::close(...future.stdout)
[13:36:38.910]         }, add = TRUE)
[13:36:38.910]     }
[13:36:38.910]     ...future.frame <- base::sys.nframe()
[13:36:38.910]     ...future.conditions <- base::list()
[13:36:38.910]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.910]     if (FALSE) {
[13:36:38.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.910]     }
[13:36:38.910]     ...future.result <- base::tryCatch({
[13:36:38.910]         base::withCallingHandlers({
[13:36:38.910]             ...future.value <- base::withVisible(base::local({
[13:36:38.910]                 ...future.makeSendCondition <- base::local({
[13:36:38.910]                   sendCondition <- NULL
[13:36:38.910]                   function(frame = 1L) {
[13:36:38.910]                     if (is.function(sendCondition)) 
[13:36:38.910]                       return(sendCondition)
[13:36:38.910]                     ns <- getNamespace("parallel")
[13:36:38.910]                     if (exists("sendData", mode = "function", 
[13:36:38.910]                       envir = ns)) {
[13:36:38.910]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.910]                         envir = ns)
[13:36:38.910]                       envir <- sys.frame(frame)
[13:36:38.910]                       master <- NULL
[13:36:38.910]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.910]                         !identical(envir, emptyenv())) {
[13:36:38.910]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.910]                           inherits = FALSE)) {
[13:36:38.910]                           master <- get("master", mode = "list", 
[13:36:38.910]                             envir = envir, inherits = FALSE)
[13:36:38.910]                           if (inherits(master, c("SOCKnode", 
[13:36:38.910]                             "SOCK0node"))) {
[13:36:38.910]                             sendCondition <<- function(cond) {
[13:36:38.910]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.910]                                 success = TRUE)
[13:36:38.910]                               parallel_sendData(master, data)
[13:36:38.910]                             }
[13:36:38.910]                             return(sendCondition)
[13:36:38.910]                           }
[13:36:38.910]                         }
[13:36:38.910]                         frame <- frame + 1L
[13:36:38.910]                         envir <- sys.frame(frame)
[13:36:38.910]                       }
[13:36:38.910]                     }
[13:36:38.910]                     sendCondition <<- function(cond) NULL
[13:36:38.910]                   }
[13:36:38.910]                 })
[13:36:38.910]                 withCallingHandlers({
[13:36:38.910]                   2
[13:36:38.910]                 }, immediateCondition = function(cond) {
[13:36:38.910]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.910]                   sendCondition(cond)
[13:36:38.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.910]                   {
[13:36:38.910]                     inherits <- base::inherits
[13:36:38.910]                     invokeRestart <- base::invokeRestart
[13:36:38.910]                     is.null <- base::is.null
[13:36:38.910]                     muffled <- FALSE
[13:36:38.910]                     if (inherits(cond, "message")) {
[13:36:38.910]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.910]                       if (muffled) 
[13:36:38.910]                         invokeRestart("muffleMessage")
[13:36:38.910]                     }
[13:36:38.910]                     else if (inherits(cond, "warning")) {
[13:36:38.910]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.910]                       if (muffled) 
[13:36:38.910]                         invokeRestart("muffleWarning")
[13:36:38.910]                     }
[13:36:38.910]                     else if (inherits(cond, "condition")) {
[13:36:38.910]                       if (!is.null(pattern)) {
[13:36:38.910]                         computeRestarts <- base::computeRestarts
[13:36:38.910]                         grepl <- base::grepl
[13:36:38.910]                         restarts <- computeRestarts(cond)
[13:36:38.910]                         for (restart in restarts) {
[13:36:38.910]                           name <- restart$name
[13:36:38.910]                           if (is.null(name)) 
[13:36:38.910]                             next
[13:36:38.910]                           if (!grepl(pattern, name)) 
[13:36:38.910]                             next
[13:36:38.910]                           invokeRestart(restart)
[13:36:38.910]                           muffled <- TRUE
[13:36:38.910]                           break
[13:36:38.910]                         }
[13:36:38.910]                       }
[13:36:38.910]                     }
[13:36:38.910]                     invisible(muffled)
[13:36:38.910]                   }
[13:36:38.910]                   muffleCondition(cond)
[13:36:38.910]                 })
[13:36:38.910]             }))
[13:36:38.910]             future::FutureResult(value = ...future.value$value, 
[13:36:38.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.910]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.910]                     ...future.globalenv.names))
[13:36:38.910]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.910]         }, condition = base::local({
[13:36:38.910]             c <- base::c
[13:36:38.910]             inherits <- base::inherits
[13:36:38.910]             invokeRestart <- base::invokeRestart
[13:36:38.910]             length <- base::length
[13:36:38.910]             list <- base::list
[13:36:38.910]             seq.int <- base::seq.int
[13:36:38.910]             signalCondition <- base::signalCondition
[13:36:38.910]             sys.calls <- base::sys.calls
[13:36:38.910]             `[[` <- base::`[[`
[13:36:38.910]             `+` <- base::`+`
[13:36:38.910]             `<<-` <- base::`<<-`
[13:36:38.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.910]                   3L)]
[13:36:38.910]             }
[13:36:38.910]             function(cond) {
[13:36:38.910]                 is_error <- inherits(cond, "error")
[13:36:38.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.910]                   NULL)
[13:36:38.910]                 if (is_error) {
[13:36:38.910]                   sessionInformation <- function() {
[13:36:38.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.910]                       search = base::search(), system = base::Sys.info())
[13:36:38.910]                   }
[13:36:38.910]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.910]                     cond$call), session = sessionInformation(), 
[13:36:38.910]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.910]                   signalCondition(cond)
[13:36:38.910]                 }
[13:36:38.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.910]                 "immediateCondition"))) {
[13:36:38.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.910]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.910]                   if (TRUE && !signal) {
[13:36:38.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.910]                     {
[13:36:38.910]                       inherits <- base::inherits
[13:36:38.910]                       invokeRestart <- base::invokeRestart
[13:36:38.910]                       is.null <- base::is.null
[13:36:38.910]                       muffled <- FALSE
[13:36:38.910]                       if (inherits(cond, "message")) {
[13:36:38.910]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.910]                         if (muffled) 
[13:36:38.910]                           invokeRestart("muffleMessage")
[13:36:38.910]                       }
[13:36:38.910]                       else if (inherits(cond, "warning")) {
[13:36:38.910]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.910]                         if (muffled) 
[13:36:38.910]                           invokeRestart("muffleWarning")
[13:36:38.910]                       }
[13:36:38.910]                       else if (inherits(cond, "condition")) {
[13:36:38.910]                         if (!is.null(pattern)) {
[13:36:38.910]                           computeRestarts <- base::computeRestarts
[13:36:38.910]                           grepl <- base::grepl
[13:36:38.910]                           restarts <- computeRestarts(cond)
[13:36:38.910]                           for (restart in restarts) {
[13:36:38.910]                             name <- restart$name
[13:36:38.910]                             if (is.null(name)) 
[13:36:38.910]                               next
[13:36:38.910]                             if (!grepl(pattern, name)) 
[13:36:38.910]                               next
[13:36:38.910]                             invokeRestart(restart)
[13:36:38.910]                             muffled <- TRUE
[13:36:38.910]                             break
[13:36:38.910]                           }
[13:36:38.910]                         }
[13:36:38.910]                       }
[13:36:38.910]                       invisible(muffled)
[13:36:38.910]                     }
[13:36:38.910]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.910]                   }
[13:36:38.910]                 }
[13:36:38.910]                 else {
[13:36:38.910]                   if (TRUE) {
[13:36:38.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.910]                     {
[13:36:38.910]                       inherits <- base::inherits
[13:36:38.910]                       invokeRestart <- base::invokeRestart
[13:36:38.910]                       is.null <- base::is.null
[13:36:38.910]                       muffled <- FALSE
[13:36:38.910]                       if (inherits(cond, "message")) {
[13:36:38.910]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.910]                         if (muffled) 
[13:36:38.910]                           invokeRestart("muffleMessage")
[13:36:38.910]                       }
[13:36:38.910]                       else if (inherits(cond, "warning")) {
[13:36:38.910]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.910]                         if (muffled) 
[13:36:38.910]                           invokeRestart("muffleWarning")
[13:36:38.910]                       }
[13:36:38.910]                       else if (inherits(cond, "condition")) {
[13:36:38.910]                         if (!is.null(pattern)) {
[13:36:38.910]                           computeRestarts <- base::computeRestarts
[13:36:38.910]                           grepl <- base::grepl
[13:36:38.910]                           restarts <- computeRestarts(cond)
[13:36:38.910]                           for (restart in restarts) {
[13:36:38.910]                             name <- restart$name
[13:36:38.910]                             if (is.null(name)) 
[13:36:38.910]                               next
[13:36:38.910]                             if (!grepl(pattern, name)) 
[13:36:38.910]                               next
[13:36:38.910]                             invokeRestart(restart)
[13:36:38.910]                             muffled <- TRUE
[13:36:38.910]                             break
[13:36:38.910]                           }
[13:36:38.910]                         }
[13:36:38.910]                       }
[13:36:38.910]                       invisible(muffled)
[13:36:38.910]                     }
[13:36:38.910]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.910]                   }
[13:36:38.910]                 }
[13:36:38.910]             }
[13:36:38.910]         }))
[13:36:38.910]     }, error = function(ex) {
[13:36:38.910]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.910]                 ...future.rng), started = ...future.startTime, 
[13:36:38.910]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.910]             version = "1.8"), class = "FutureResult")
[13:36:38.910]     }, finally = {
[13:36:38.910]         if (!identical(...future.workdir, getwd())) 
[13:36:38.910]             setwd(...future.workdir)
[13:36:38.910]         {
[13:36:38.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.910]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.910]             }
[13:36:38.910]             base::options(...future.oldOptions)
[13:36:38.910]             if (.Platform$OS.type == "windows") {
[13:36:38.910]                 old_names <- names(...future.oldEnvVars)
[13:36:38.910]                 envs <- base::Sys.getenv()
[13:36:38.910]                 names <- names(envs)
[13:36:38.910]                 common <- intersect(names, old_names)
[13:36:38.910]                 added <- setdiff(names, old_names)
[13:36:38.910]                 removed <- setdiff(old_names, names)
[13:36:38.910]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.910]                   envs[common]]
[13:36:38.910]                 NAMES <- toupper(changed)
[13:36:38.910]                 args <- list()
[13:36:38.910]                 for (kk in seq_along(NAMES)) {
[13:36:38.910]                   name <- changed[[kk]]
[13:36:38.910]                   NAME <- NAMES[[kk]]
[13:36:38.910]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.910]                     next
[13:36:38.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.910]                 }
[13:36:38.910]                 NAMES <- toupper(added)
[13:36:38.910]                 for (kk in seq_along(NAMES)) {
[13:36:38.910]                   name <- added[[kk]]
[13:36:38.910]                   NAME <- NAMES[[kk]]
[13:36:38.910]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.910]                     next
[13:36:38.910]                   args[[name]] <- ""
[13:36:38.910]                 }
[13:36:38.910]                 NAMES <- toupper(removed)
[13:36:38.910]                 for (kk in seq_along(NAMES)) {
[13:36:38.910]                   name <- removed[[kk]]
[13:36:38.910]                   NAME <- NAMES[[kk]]
[13:36:38.910]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.910]                     next
[13:36:38.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.910]                 }
[13:36:38.910]                 if (length(args) > 0) 
[13:36:38.910]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.910]             }
[13:36:38.910]             else {
[13:36:38.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.910]             }
[13:36:38.910]             {
[13:36:38.910]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.910]                   0L) {
[13:36:38.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.910]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.910]                   base::options(opts)
[13:36:38.910]                 }
[13:36:38.910]                 {
[13:36:38.910]                   {
[13:36:38.910]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.910]                     NULL
[13:36:38.910]                   }
[13:36:38.910]                   options(future.plan = NULL)
[13:36:38.910]                   if (is.na(NA_character_)) 
[13:36:38.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.910]                     .init = FALSE)
[13:36:38.910]                 }
[13:36:38.910]             }
[13:36:38.910]         }
[13:36:38.910]     })
[13:36:38.910]     if (TRUE) {
[13:36:38.910]         base::sink(type = "output", split = FALSE)
[13:36:38.910]         if (TRUE) {
[13:36:38.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.910]         }
[13:36:38.910]         else {
[13:36:38.910]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.910]         }
[13:36:38.910]         base::close(...future.stdout)
[13:36:38.910]         ...future.stdout <- NULL
[13:36:38.910]     }
[13:36:38.910]     ...future.result$conditions <- ...future.conditions
[13:36:38.910]     ...future.result$finished <- base::Sys.time()
[13:36:38.910]     ...future.result
[13:36:38.910] }
[13:36:38.912] MultisessionFuture started
[13:36:38.913] - Launch lazy future ... done
[13:36:38.913] run() for ‘MultisessionFuture’ ... done
[13:36:38.913] getGlobalsAndPackages() ...
[13:36:38.913] Searching for globals...
[13:36:38.913] 
[13:36:38.913] Searching for globals ... DONE
[13:36:38.913] - globals: [0] <none>
[13:36:38.913] getGlobalsAndPackages() ... DONE
[13:36:38.914] run() for ‘Future’ ...
[13:36:38.914] - state: ‘created’
[13:36:38.914] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.927] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.928]   - Field: ‘node’
[13:36:38.928]   - Field: ‘label’
[13:36:38.928]   - Field: ‘local’
[13:36:38.928]   - Field: ‘owner’
[13:36:38.928]   - Field: ‘envir’
[13:36:38.928]   - Field: ‘workers’
[13:36:38.928]   - Field: ‘packages’
[13:36:38.928]   - Field: ‘gc’
[13:36:38.928]   - Field: ‘conditions’
[13:36:38.929]   - Field: ‘persistent’
[13:36:38.929]   - Field: ‘expr’
[13:36:38.929]   - Field: ‘uuid’
[13:36:38.929]   - Field: ‘seed’
[13:36:38.929]   - Field: ‘version’
[13:36:38.929]   - Field: ‘result’
[13:36:38.929]   - Field: ‘asynchronous’
[13:36:38.929]   - Field: ‘calls’
[13:36:38.929]   - Field: ‘globals’
[13:36:38.929]   - Field: ‘stdout’
[13:36:38.929]   - Field: ‘earlySignal’
[13:36:38.930]   - Field: ‘lazy’
[13:36:38.930]   - Field: ‘state’
[13:36:38.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.930] - Launch lazy future ...
[13:36:38.930] Packages needed by the future expression (n = 0): <none>
[13:36:38.930] Packages needed by future strategies (n = 0): <none>
[13:36:38.931] {
[13:36:38.931]     {
[13:36:38.931]         {
[13:36:38.931]             ...future.startTime <- base::Sys.time()
[13:36:38.931]             {
[13:36:38.931]                 {
[13:36:38.931]                   {
[13:36:38.931]                     {
[13:36:38.931]                       base::local({
[13:36:38.931]                         has_future <- base::requireNamespace("future", 
[13:36:38.931]                           quietly = TRUE)
[13:36:38.931]                         if (has_future) {
[13:36:38.931]                           ns <- base::getNamespace("future")
[13:36:38.931]                           version <- ns[[".package"]][["version"]]
[13:36:38.931]                           if (is.null(version)) 
[13:36:38.931]                             version <- utils::packageVersion("future")
[13:36:38.931]                         }
[13:36:38.931]                         else {
[13:36:38.931]                           version <- NULL
[13:36:38.931]                         }
[13:36:38.931]                         if (!has_future || version < "1.8.0") {
[13:36:38.931]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.931]                             "", base::R.version$version.string), 
[13:36:38.931]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.931]                               "release", "version")], collapse = " "), 
[13:36:38.931]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.931]                             info)
[13:36:38.931]                           info <- base::paste(info, collapse = "; ")
[13:36:38.931]                           if (!has_future) {
[13:36:38.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.931]                               info)
[13:36:38.931]                           }
[13:36:38.931]                           else {
[13:36:38.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.931]                               info, version)
[13:36:38.931]                           }
[13:36:38.931]                           base::stop(msg)
[13:36:38.931]                         }
[13:36:38.931]                       })
[13:36:38.931]                     }
[13:36:38.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.931]                     base::options(mc.cores = 1L)
[13:36:38.931]                   }
[13:36:38.931]                   ...future.strategy.old <- future::plan("list")
[13:36:38.931]                   options(future.plan = NULL)
[13:36:38.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.931]                 }
[13:36:38.931]                 ...future.workdir <- getwd()
[13:36:38.931]             }
[13:36:38.931]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.931]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.931]         }
[13:36:38.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.931]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.931]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.931]             base::names(...future.oldOptions))
[13:36:38.931]     }
[13:36:38.931]     if (FALSE) {
[13:36:38.931]     }
[13:36:38.931]     else {
[13:36:38.931]         if (TRUE) {
[13:36:38.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.931]                 open = "w")
[13:36:38.931]         }
[13:36:38.931]         else {
[13:36:38.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.931]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.931]         }
[13:36:38.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.931]             base::sink(type = "output", split = FALSE)
[13:36:38.931]             base::close(...future.stdout)
[13:36:38.931]         }, add = TRUE)
[13:36:38.931]     }
[13:36:38.931]     ...future.frame <- base::sys.nframe()
[13:36:38.931]     ...future.conditions <- base::list()
[13:36:38.931]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.931]     if (FALSE) {
[13:36:38.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.931]     }
[13:36:38.931]     ...future.result <- base::tryCatch({
[13:36:38.931]         base::withCallingHandlers({
[13:36:38.931]             ...future.value <- base::withVisible(base::local({
[13:36:38.931]                 ...future.makeSendCondition <- base::local({
[13:36:38.931]                   sendCondition <- NULL
[13:36:38.931]                   function(frame = 1L) {
[13:36:38.931]                     if (is.function(sendCondition)) 
[13:36:38.931]                       return(sendCondition)
[13:36:38.931]                     ns <- getNamespace("parallel")
[13:36:38.931]                     if (exists("sendData", mode = "function", 
[13:36:38.931]                       envir = ns)) {
[13:36:38.931]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.931]                         envir = ns)
[13:36:38.931]                       envir <- sys.frame(frame)
[13:36:38.931]                       master <- NULL
[13:36:38.931]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.931]                         !identical(envir, emptyenv())) {
[13:36:38.931]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.931]                           inherits = FALSE)) {
[13:36:38.931]                           master <- get("master", mode = "list", 
[13:36:38.931]                             envir = envir, inherits = FALSE)
[13:36:38.931]                           if (inherits(master, c("SOCKnode", 
[13:36:38.931]                             "SOCK0node"))) {
[13:36:38.931]                             sendCondition <<- function(cond) {
[13:36:38.931]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.931]                                 success = TRUE)
[13:36:38.931]                               parallel_sendData(master, data)
[13:36:38.931]                             }
[13:36:38.931]                             return(sendCondition)
[13:36:38.931]                           }
[13:36:38.931]                         }
[13:36:38.931]                         frame <- frame + 1L
[13:36:38.931]                         envir <- sys.frame(frame)
[13:36:38.931]                       }
[13:36:38.931]                     }
[13:36:38.931]                     sendCondition <<- function(cond) NULL
[13:36:38.931]                   }
[13:36:38.931]                 })
[13:36:38.931]                 withCallingHandlers({
[13:36:38.931]                   NULL
[13:36:38.931]                 }, immediateCondition = function(cond) {
[13:36:38.931]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.931]                   sendCondition(cond)
[13:36:38.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.931]                   {
[13:36:38.931]                     inherits <- base::inherits
[13:36:38.931]                     invokeRestart <- base::invokeRestart
[13:36:38.931]                     is.null <- base::is.null
[13:36:38.931]                     muffled <- FALSE
[13:36:38.931]                     if (inherits(cond, "message")) {
[13:36:38.931]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.931]                       if (muffled) 
[13:36:38.931]                         invokeRestart("muffleMessage")
[13:36:38.931]                     }
[13:36:38.931]                     else if (inherits(cond, "warning")) {
[13:36:38.931]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.931]                       if (muffled) 
[13:36:38.931]                         invokeRestart("muffleWarning")
[13:36:38.931]                     }
[13:36:38.931]                     else if (inherits(cond, "condition")) {
[13:36:38.931]                       if (!is.null(pattern)) {
[13:36:38.931]                         computeRestarts <- base::computeRestarts
[13:36:38.931]                         grepl <- base::grepl
[13:36:38.931]                         restarts <- computeRestarts(cond)
[13:36:38.931]                         for (restart in restarts) {
[13:36:38.931]                           name <- restart$name
[13:36:38.931]                           if (is.null(name)) 
[13:36:38.931]                             next
[13:36:38.931]                           if (!grepl(pattern, name)) 
[13:36:38.931]                             next
[13:36:38.931]                           invokeRestart(restart)
[13:36:38.931]                           muffled <- TRUE
[13:36:38.931]                           break
[13:36:38.931]                         }
[13:36:38.931]                       }
[13:36:38.931]                     }
[13:36:38.931]                     invisible(muffled)
[13:36:38.931]                   }
[13:36:38.931]                   muffleCondition(cond)
[13:36:38.931]                 })
[13:36:38.931]             }))
[13:36:38.931]             future::FutureResult(value = ...future.value$value, 
[13:36:38.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.931]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.931]                     ...future.globalenv.names))
[13:36:38.931]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.931]         }, condition = base::local({
[13:36:38.931]             c <- base::c
[13:36:38.931]             inherits <- base::inherits
[13:36:38.931]             invokeRestart <- base::invokeRestart
[13:36:38.931]             length <- base::length
[13:36:38.931]             list <- base::list
[13:36:38.931]             seq.int <- base::seq.int
[13:36:38.931]             signalCondition <- base::signalCondition
[13:36:38.931]             sys.calls <- base::sys.calls
[13:36:38.931]             `[[` <- base::`[[`
[13:36:38.931]             `+` <- base::`+`
[13:36:38.931]             `<<-` <- base::`<<-`
[13:36:38.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.931]                   3L)]
[13:36:38.931]             }
[13:36:38.931]             function(cond) {
[13:36:38.931]                 is_error <- inherits(cond, "error")
[13:36:38.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.931]                   NULL)
[13:36:38.931]                 if (is_error) {
[13:36:38.931]                   sessionInformation <- function() {
[13:36:38.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.931]                       search = base::search(), system = base::Sys.info())
[13:36:38.931]                   }
[13:36:38.931]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.931]                     cond$call), session = sessionInformation(), 
[13:36:38.931]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.931]                   signalCondition(cond)
[13:36:38.931]                 }
[13:36:38.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.931]                 "immediateCondition"))) {
[13:36:38.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.931]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.931]                   if (TRUE && !signal) {
[13:36:38.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.931]                     {
[13:36:38.931]                       inherits <- base::inherits
[13:36:38.931]                       invokeRestart <- base::invokeRestart
[13:36:38.931]                       is.null <- base::is.null
[13:36:38.931]                       muffled <- FALSE
[13:36:38.931]                       if (inherits(cond, "message")) {
[13:36:38.931]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.931]                         if (muffled) 
[13:36:38.931]                           invokeRestart("muffleMessage")
[13:36:38.931]                       }
[13:36:38.931]                       else if (inherits(cond, "warning")) {
[13:36:38.931]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.931]                         if (muffled) 
[13:36:38.931]                           invokeRestart("muffleWarning")
[13:36:38.931]                       }
[13:36:38.931]                       else if (inherits(cond, "condition")) {
[13:36:38.931]                         if (!is.null(pattern)) {
[13:36:38.931]                           computeRestarts <- base::computeRestarts
[13:36:38.931]                           grepl <- base::grepl
[13:36:38.931]                           restarts <- computeRestarts(cond)
[13:36:38.931]                           for (restart in restarts) {
[13:36:38.931]                             name <- restart$name
[13:36:38.931]                             if (is.null(name)) 
[13:36:38.931]                               next
[13:36:38.931]                             if (!grepl(pattern, name)) 
[13:36:38.931]                               next
[13:36:38.931]                             invokeRestart(restart)
[13:36:38.931]                             muffled <- TRUE
[13:36:38.931]                             break
[13:36:38.931]                           }
[13:36:38.931]                         }
[13:36:38.931]                       }
[13:36:38.931]                       invisible(muffled)
[13:36:38.931]                     }
[13:36:38.931]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.931]                   }
[13:36:38.931]                 }
[13:36:38.931]                 else {
[13:36:38.931]                   if (TRUE) {
[13:36:38.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.931]                     {
[13:36:38.931]                       inherits <- base::inherits
[13:36:38.931]                       invokeRestart <- base::invokeRestart
[13:36:38.931]                       is.null <- base::is.null
[13:36:38.931]                       muffled <- FALSE
[13:36:38.931]                       if (inherits(cond, "message")) {
[13:36:38.931]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.931]                         if (muffled) 
[13:36:38.931]                           invokeRestart("muffleMessage")
[13:36:38.931]                       }
[13:36:38.931]                       else if (inherits(cond, "warning")) {
[13:36:38.931]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.931]                         if (muffled) 
[13:36:38.931]                           invokeRestart("muffleWarning")
[13:36:38.931]                       }
[13:36:38.931]                       else if (inherits(cond, "condition")) {
[13:36:38.931]                         if (!is.null(pattern)) {
[13:36:38.931]                           computeRestarts <- base::computeRestarts
[13:36:38.931]                           grepl <- base::grepl
[13:36:38.931]                           restarts <- computeRestarts(cond)
[13:36:38.931]                           for (restart in restarts) {
[13:36:38.931]                             name <- restart$name
[13:36:38.931]                             if (is.null(name)) 
[13:36:38.931]                               next
[13:36:38.931]                             if (!grepl(pattern, name)) 
[13:36:38.931]                               next
[13:36:38.931]                             invokeRestart(restart)
[13:36:38.931]                             muffled <- TRUE
[13:36:38.931]                             break
[13:36:38.931]                           }
[13:36:38.931]                         }
[13:36:38.931]                       }
[13:36:38.931]                       invisible(muffled)
[13:36:38.931]                     }
[13:36:38.931]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.931]                   }
[13:36:38.931]                 }
[13:36:38.931]             }
[13:36:38.931]         }))
[13:36:38.931]     }, error = function(ex) {
[13:36:38.931]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.931]                 ...future.rng), started = ...future.startTime, 
[13:36:38.931]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.931]             version = "1.8"), class = "FutureResult")
[13:36:38.931]     }, finally = {
[13:36:38.931]         if (!identical(...future.workdir, getwd())) 
[13:36:38.931]             setwd(...future.workdir)
[13:36:38.931]         {
[13:36:38.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.931]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.931]             }
[13:36:38.931]             base::options(...future.oldOptions)
[13:36:38.931]             if (.Platform$OS.type == "windows") {
[13:36:38.931]                 old_names <- names(...future.oldEnvVars)
[13:36:38.931]                 envs <- base::Sys.getenv()
[13:36:38.931]                 names <- names(envs)
[13:36:38.931]                 common <- intersect(names, old_names)
[13:36:38.931]                 added <- setdiff(names, old_names)
[13:36:38.931]                 removed <- setdiff(old_names, names)
[13:36:38.931]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.931]                   envs[common]]
[13:36:38.931]                 NAMES <- toupper(changed)
[13:36:38.931]                 args <- list()
[13:36:38.931]                 for (kk in seq_along(NAMES)) {
[13:36:38.931]                   name <- changed[[kk]]
[13:36:38.931]                   NAME <- NAMES[[kk]]
[13:36:38.931]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.931]                     next
[13:36:38.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.931]                 }
[13:36:38.931]                 NAMES <- toupper(added)
[13:36:38.931]                 for (kk in seq_along(NAMES)) {
[13:36:38.931]                   name <- added[[kk]]
[13:36:38.931]                   NAME <- NAMES[[kk]]
[13:36:38.931]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.931]                     next
[13:36:38.931]                   args[[name]] <- ""
[13:36:38.931]                 }
[13:36:38.931]                 NAMES <- toupper(removed)
[13:36:38.931]                 for (kk in seq_along(NAMES)) {
[13:36:38.931]                   name <- removed[[kk]]
[13:36:38.931]                   NAME <- NAMES[[kk]]
[13:36:38.931]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.931]                     next
[13:36:38.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.931]                 }
[13:36:38.931]                 if (length(args) > 0) 
[13:36:38.931]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.931]             }
[13:36:38.931]             else {
[13:36:38.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.931]             }
[13:36:38.931]             {
[13:36:38.931]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.931]                   0L) {
[13:36:38.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.931]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.931]                   base::options(opts)
[13:36:38.931]                 }
[13:36:38.931]                 {
[13:36:38.931]                   {
[13:36:38.931]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.931]                     NULL
[13:36:38.931]                   }
[13:36:38.931]                   options(future.plan = NULL)
[13:36:38.931]                   if (is.na(NA_character_)) 
[13:36:38.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.931]                     .init = FALSE)
[13:36:38.931]                 }
[13:36:38.931]             }
[13:36:38.931]         }
[13:36:38.931]     })
[13:36:38.931]     if (TRUE) {
[13:36:38.931]         base::sink(type = "output", split = FALSE)
[13:36:38.931]         if (TRUE) {
[13:36:38.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.931]         }
[13:36:38.931]         else {
[13:36:38.931]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.931]         }
[13:36:38.931]         base::close(...future.stdout)
[13:36:38.931]         ...future.stdout <- NULL
[13:36:38.931]     }
[13:36:38.931]     ...future.result$conditions <- ...future.conditions
[13:36:38.931]     ...future.result$finished <- base::Sys.time()
[13:36:38.931]     ...future.result
[13:36:38.931] }
[13:36:38.934] MultisessionFuture started
[13:36:38.934] - Launch lazy future ... done
[13:36:38.934] run() for ‘MultisessionFuture’ ... done
[13:36:38.934] getGlobalsAndPackages() ...
[13:36:38.935] Searching for globals...
[13:36:38.936] - globals found: [1] ‘{’
[13:36:38.936] Searching for globals ... DONE
[13:36:38.936] Resolving globals: FALSE
[13:36:38.936] 
[13:36:38.936] 
[13:36:38.936] getGlobalsAndPackages() ... DONE
[13:36:38.937] run() for ‘Future’ ...
[13:36:38.937] - state: ‘created’
[13:36:38.937] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:38.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:38.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:38.951]   - Field: ‘node’
[13:36:38.951]   - Field: ‘label’
[13:36:38.951]   - Field: ‘local’
[13:36:38.951]   - Field: ‘owner’
[13:36:38.951]   - Field: ‘envir’
[13:36:38.951]   - Field: ‘workers’
[13:36:38.951]   - Field: ‘packages’
[13:36:38.951]   - Field: ‘gc’
[13:36:38.951]   - Field: ‘conditions’
[13:36:38.951]   - Field: ‘persistent’
[13:36:38.952]   - Field: ‘expr’
[13:36:38.952]   - Field: ‘uuid’
[13:36:38.952]   - Field: ‘seed’
[13:36:38.952]   - Field: ‘version’
[13:36:38.952]   - Field: ‘result’
[13:36:38.952]   - Field: ‘asynchronous’
[13:36:38.952]   - Field: ‘calls’
[13:36:38.952]   - Field: ‘globals’
[13:36:38.952]   - Field: ‘stdout’
[13:36:38.952]   - Field: ‘earlySignal’
[13:36:38.952]   - Field: ‘lazy’
[13:36:38.953]   - Field: ‘state’
[13:36:38.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:38.953] - Launch lazy future ...
[13:36:38.953] Packages needed by the future expression (n = 0): <none>
[13:36:38.953] Packages needed by future strategies (n = 0): <none>
[13:36:38.953] {
[13:36:38.953]     {
[13:36:38.953]         {
[13:36:38.953]             ...future.startTime <- base::Sys.time()
[13:36:38.953]             {
[13:36:38.953]                 {
[13:36:38.953]                   {
[13:36:38.953]                     {
[13:36:38.953]                       base::local({
[13:36:38.953]                         has_future <- base::requireNamespace("future", 
[13:36:38.953]                           quietly = TRUE)
[13:36:38.953]                         if (has_future) {
[13:36:38.953]                           ns <- base::getNamespace("future")
[13:36:38.953]                           version <- ns[[".package"]][["version"]]
[13:36:38.953]                           if (is.null(version)) 
[13:36:38.953]                             version <- utils::packageVersion("future")
[13:36:38.953]                         }
[13:36:38.953]                         else {
[13:36:38.953]                           version <- NULL
[13:36:38.953]                         }
[13:36:38.953]                         if (!has_future || version < "1.8.0") {
[13:36:38.953]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:38.953]                             "", base::R.version$version.string), 
[13:36:38.953]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:38.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:38.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:38.953]                               "release", "version")], collapse = " "), 
[13:36:38.953]                             hostname = base::Sys.info()[["nodename"]])
[13:36:38.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:38.953]                             info)
[13:36:38.953]                           info <- base::paste(info, collapse = "; ")
[13:36:38.953]                           if (!has_future) {
[13:36:38.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:38.953]                               info)
[13:36:38.953]                           }
[13:36:38.953]                           else {
[13:36:38.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:38.953]                               info, version)
[13:36:38.953]                           }
[13:36:38.953]                           base::stop(msg)
[13:36:38.953]                         }
[13:36:38.953]                       })
[13:36:38.953]                     }
[13:36:38.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:38.953]                     base::options(mc.cores = 1L)
[13:36:38.953]                   }
[13:36:38.953]                   ...future.strategy.old <- future::plan("list")
[13:36:38.953]                   options(future.plan = NULL)
[13:36:38.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:38.953]                 }
[13:36:38.953]                 ...future.workdir <- getwd()
[13:36:38.953]             }
[13:36:38.953]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:38.953]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:38.953]         }
[13:36:38.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:38.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:38.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:38.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:38.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:38.953]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:38.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:38.953]             base::names(...future.oldOptions))
[13:36:38.953]     }
[13:36:38.953]     if (FALSE) {
[13:36:38.953]     }
[13:36:38.953]     else {
[13:36:38.953]         if (TRUE) {
[13:36:38.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:38.953]                 open = "w")
[13:36:38.953]         }
[13:36:38.953]         else {
[13:36:38.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:38.953]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:38.953]         }
[13:36:38.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:38.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:38.953]             base::sink(type = "output", split = FALSE)
[13:36:38.953]             base::close(...future.stdout)
[13:36:38.953]         }, add = TRUE)
[13:36:38.953]     }
[13:36:38.953]     ...future.frame <- base::sys.nframe()
[13:36:38.953]     ...future.conditions <- base::list()
[13:36:38.953]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:38.953]     if (FALSE) {
[13:36:38.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:38.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:38.953]     }
[13:36:38.953]     ...future.result <- base::tryCatch({
[13:36:38.953]         base::withCallingHandlers({
[13:36:38.953]             ...future.value <- base::withVisible(base::local({
[13:36:38.953]                 ...future.makeSendCondition <- base::local({
[13:36:38.953]                   sendCondition <- NULL
[13:36:38.953]                   function(frame = 1L) {
[13:36:38.953]                     if (is.function(sendCondition)) 
[13:36:38.953]                       return(sendCondition)
[13:36:38.953]                     ns <- getNamespace("parallel")
[13:36:38.953]                     if (exists("sendData", mode = "function", 
[13:36:38.953]                       envir = ns)) {
[13:36:38.953]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:38.953]                         envir = ns)
[13:36:38.953]                       envir <- sys.frame(frame)
[13:36:38.953]                       master <- NULL
[13:36:38.953]                       while (!identical(envir, .GlobalEnv) && 
[13:36:38.953]                         !identical(envir, emptyenv())) {
[13:36:38.953]                         if (exists("master", mode = "list", envir = envir, 
[13:36:38.953]                           inherits = FALSE)) {
[13:36:38.953]                           master <- get("master", mode = "list", 
[13:36:38.953]                             envir = envir, inherits = FALSE)
[13:36:38.953]                           if (inherits(master, c("SOCKnode", 
[13:36:38.953]                             "SOCK0node"))) {
[13:36:38.953]                             sendCondition <<- function(cond) {
[13:36:38.953]                               data <- list(type = "VALUE", value = cond, 
[13:36:38.953]                                 success = TRUE)
[13:36:38.953]                               parallel_sendData(master, data)
[13:36:38.953]                             }
[13:36:38.953]                             return(sendCondition)
[13:36:38.953]                           }
[13:36:38.953]                         }
[13:36:38.953]                         frame <- frame + 1L
[13:36:38.953]                         envir <- sys.frame(frame)
[13:36:38.953]                       }
[13:36:38.953]                     }
[13:36:38.953]                     sendCondition <<- function(cond) NULL
[13:36:38.953]                   }
[13:36:38.953]                 })
[13:36:38.953]                 withCallingHandlers({
[13:36:38.953]                   {
[13:36:38.953]                     4
[13:36:38.953]                   }
[13:36:38.953]                 }, immediateCondition = function(cond) {
[13:36:38.953]                   sendCondition <- ...future.makeSendCondition()
[13:36:38.953]                   sendCondition(cond)
[13:36:38.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.953]                   {
[13:36:38.953]                     inherits <- base::inherits
[13:36:38.953]                     invokeRestart <- base::invokeRestart
[13:36:38.953]                     is.null <- base::is.null
[13:36:38.953]                     muffled <- FALSE
[13:36:38.953]                     if (inherits(cond, "message")) {
[13:36:38.953]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:38.953]                       if (muffled) 
[13:36:38.953]                         invokeRestart("muffleMessage")
[13:36:38.953]                     }
[13:36:38.953]                     else if (inherits(cond, "warning")) {
[13:36:38.953]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:38.953]                       if (muffled) 
[13:36:38.953]                         invokeRestart("muffleWarning")
[13:36:38.953]                     }
[13:36:38.953]                     else if (inherits(cond, "condition")) {
[13:36:38.953]                       if (!is.null(pattern)) {
[13:36:38.953]                         computeRestarts <- base::computeRestarts
[13:36:38.953]                         grepl <- base::grepl
[13:36:38.953]                         restarts <- computeRestarts(cond)
[13:36:38.953]                         for (restart in restarts) {
[13:36:38.953]                           name <- restart$name
[13:36:38.953]                           if (is.null(name)) 
[13:36:38.953]                             next
[13:36:38.953]                           if (!grepl(pattern, name)) 
[13:36:38.953]                             next
[13:36:38.953]                           invokeRestart(restart)
[13:36:38.953]                           muffled <- TRUE
[13:36:38.953]                           break
[13:36:38.953]                         }
[13:36:38.953]                       }
[13:36:38.953]                     }
[13:36:38.953]                     invisible(muffled)
[13:36:38.953]                   }
[13:36:38.953]                   muffleCondition(cond)
[13:36:38.953]                 })
[13:36:38.953]             }))
[13:36:38.953]             future::FutureResult(value = ...future.value$value, 
[13:36:38.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.953]                   ...future.rng), globalenv = if (FALSE) 
[13:36:38.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:38.953]                     ...future.globalenv.names))
[13:36:38.953]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:38.953]         }, condition = base::local({
[13:36:38.953]             c <- base::c
[13:36:38.953]             inherits <- base::inherits
[13:36:38.953]             invokeRestart <- base::invokeRestart
[13:36:38.953]             length <- base::length
[13:36:38.953]             list <- base::list
[13:36:38.953]             seq.int <- base::seq.int
[13:36:38.953]             signalCondition <- base::signalCondition
[13:36:38.953]             sys.calls <- base::sys.calls
[13:36:38.953]             `[[` <- base::`[[`
[13:36:38.953]             `+` <- base::`+`
[13:36:38.953]             `<<-` <- base::`<<-`
[13:36:38.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:38.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:38.953]                   3L)]
[13:36:38.953]             }
[13:36:38.953]             function(cond) {
[13:36:38.953]                 is_error <- inherits(cond, "error")
[13:36:38.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:38.953]                   NULL)
[13:36:38.953]                 if (is_error) {
[13:36:38.953]                   sessionInformation <- function() {
[13:36:38.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:38.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:38.953]                       search = base::search(), system = base::Sys.info())
[13:36:38.953]                   }
[13:36:38.953]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:38.953]                     cond$call), session = sessionInformation(), 
[13:36:38.953]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:38.953]                   signalCondition(cond)
[13:36:38.953]                 }
[13:36:38.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:38.953]                 "immediateCondition"))) {
[13:36:38.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:38.953]                   ...future.conditions[[length(...future.conditions) + 
[13:36:38.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:38.953]                   if (TRUE && !signal) {
[13:36:38.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.953]                     {
[13:36:38.953]                       inherits <- base::inherits
[13:36:38.953]                       invokeRestart <- base::invokeRestart
[13:36:38.953]                       is.null <- base::is.null
[13:36:38.953]                       muffled <- FALSE
[13:36:38.953]                       if (inherits(cond, "message")) {
[13:36:38.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.953]                         if (muffled) 
[13:36:38.953]                           invokeRestart("muffleMessage")
[13:36:38.953]                       }
[13:36:38.953]                       else if (inherits(cond, "warning")) {
[13:36:38.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.953]                         if (muffled) 
[13:36:38.953]                           invokeRestart("muffleWarning")
[13:36:38.953]                       }
[13:36:38.953]                       else if (inherits(cond, "condition")) {
[13:36:38.953]                         if (!is.null(pattern)) {
[13:36:38.953]                           computeRestarts <- base::computeRestarts
[13:36:38.953]                           grepl <- base::grepl
[13:36:38.953]                           restarts <- computeRestarts(cond)
[13:36:38.953]                           for (restart in restarts) {
[13:36:38.953]                             name <- restart$name
[13:36:38.953]                             if (is.null(name)) 
[13:36:38.953]                               next
[13:36:38.953]                             if (!grepl(pattern, name)) 
[13:36:38.953]                               next
[13:36:38.953]                             invokeRestart(restart)
[13:36:38.953]                             muffled <- TRUE
[13:36:38.953]                             break
[13:36:38.953]                           }
[13:36:38.953]                         }
[13:36:38.953]                       }
[13:36:38.953]                       invisible(muffled)
[13:36:38.953]                     }
[13:36:38.953]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.953]                   }
[13:36:38.953]                 }
[13:36:38.953]                 else {
[13:36:38.953]                   if (TRUE) {
[13:36:38.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:38.953]                     {
[13:36:38.953]                       inherits <- base::inherits
[13:36:38.953]                       invokeRestart <- base::invokeRestart
[13:36:38.953]                       is.null <- base::is.null
[13:36:38.953]                       muffled <- FALSE
[13:36:38.953]                       if (inherits(cond, "message")) {
[13:36:38.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:38.953]                         if (muffled) 
[13:36:38.953]                           invokeRestart("muffleMessage")
[13:36:38.953]                       }
[13:36:38.953]                       else if (inherits(cond, "warning")) {
[13:36:38.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:38.953]                         if (muffled) 
[13:36:38.953]                           invokeRestart("muffleWarning")
[13:36:38.953]                       }
[13:36:38.953]                       else if (inherits(cond, "condition")) {
[13:36:38.953]                         if (!is.null(pattern)) {
[13:36:38.953]                           computeRestarts <- base::computeRestarts
[13:36:38.953]                           grepl <- base::grepl
[13:36:38.953]                           restarts <- computeRestarts(cond)
[13:36:38.953]                           for (restart in restarts) {
[13:36:38.953]                             name <- restart$name
[13:36:38.953]                             if (is.null(name)) 
[13:36:38.953]                               next
[13:36:38.953]                             if (!grepl(pattern, name)) 
[13:36:38.953]                               next
[13:36:38.953]                             invokeRestart(restart)
[13:36:38.953]                             muffled <- TRUE
[13:36:38.953]                             break
[13:36:38.953]                           }
[13:36:38.953]                         }
[13:36:38.953]                       }
[13:36:38.953]                       invisible(muffled)
[13:36:38.953]                     }
[13:36:38.953]                     muffleCondition(cond, pattern = "^muffle")
[13:36:38.953]                   }
[13:36:38.953]                 }
[13:36:38.953]             }
[13:36:38.953]         }))
[13:36:38.953]     }, error = function(ex) {
[13:36:38.953]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:38.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:38.953]                 ...future.rng), started = ...future.startTime, 
[13:36:38.953]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:38.953]             version = "1.8"), class = "FutureResult")
[13:36:38.953]     }, finally = {
[13:36:38.953]         if (!identical(...future.workdir, getwd())) 
[13:36:38.953]             setwd(...future.workdir)
[13:36:38.953]         {
[13:36:38.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:38.953]                 ...future.oldOptions$nwarnings <- NULL
[13:36:38.953]             }
[13:36:38.953]             base::options(...future.oldOptions)
[13:36:38.953]             if (.Platform$OS.type == "windows") {
[13:36:38.953]                 old_names <- names(...future.oldEnvVars)
[13:36:38.953]                 envs <- base::Sys.getenv()
[13:36:38.953]                 names <- names(envs)
[13:36:38.953]                 common <- intersect(names, old_names)
[13:36:38.953]                 added <- setdiff(names, old_names)
[13:36:38.953]                 removed <- setdiff(old_names, names)
[13:36:38.953]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:38.953]                   envs[common]]
[13:36:38.953]                 NAMES <- toupper(changed)
[13:36:38.953]                 args <- list()
[13:36:38.953]                 for (kk in seq_along(NAMES)) {
[13:36:38.953]                   name <- changed[[kk]]
[13:36:38.953]                   NAME <- NAMES[[kk]]
[13:36:38.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.953]                     next
[13:36:38.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.953]                 }
[13:36:38.953]                 NAMES <- toupper(added)
[13:36:38.953]                 for (kk in seq_along(NAMES)) {
[13:36:38.953]                   name <- added[[kk]]
[13:36:38.953]                   NAME <- NAMES[[kk]]
[13:36:38.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.953]                     next
[13:36:38.953]                   args[[name]] <- ""
[13:36:38.953]                 }
[13:36:38.953]                 NAMES <- toupper(removed)
[13:36:38.953]                 for (kk in seq_along(NAMES)) {
[13:36:38.953]                   name <- removed[[kk]]
[13:36:38.953]                   NAME <- NAMES[[kk]]
[13:36:38.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:38.953]                     next
[13:36:38.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:38.953]                 }
[13:36:38.953]                 if (length(args) > 0) 
[13:36:38.953]                   base::do.call(base::Sys.setenv, args = args)
[13:36:38.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:38.953]             }
[13:36:38.953]             else {
[13:36:38.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:38.953]             }
[13:36:38.953]             {
[13:36:38.953]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:38.953]                   0L) {
[13:36:38.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:38.953]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:38.953]                   base::options(opts)
[13:36:38.953]                 }
[13:36:38.953]                 {
[13:36:38.953]                   {
[13:36:38.953]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:38.953]                     NULL
[13:36:38.953]                   }
[13:36:38.953]                   options(future.plan = NULL)
[13:36:38.953]                   if (is.na(NA_character_)) 
[13:36:38.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:38.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:38.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:38.953]                     .init = FALSE)
[13:36:38.953]                 }
[13:36:38.953]             }
[13:36:38.953]         }
[13:36:38.953]     })
[13:36:38.953]     if (TRUE) {
[13:36:38.953]         base::sink(type = "output", split = FALSE)
[13:36:38.953]         if (TRUE) {
[13:36:38.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:38.953]         }
[13:36:38.953]         else {
[13:36:38.953]             ...future.result["stdout"] <- base::list(NULL)
[13:36:38.953]         }
[13:36:38.953]         base::close(...future.stdout)
[13:36:38.953]         ...future.stdout <- NULL
[13:36:38.953]     }
[13:36:38.953]     ...future.result$conditions <- ...future.conditions
[13:36:38.953]     ...future.result$finished <- base::Sys.time()
[13:36:38.953]     ...future.result
[13:36:38.953] }
[13:36:38.956] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:38.966] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.967] - Validating connection of MultisessionFuture
[13:36:38.967] - received message: FutureResult
[13:36:38.967] - Received FutureResult
[13:36:38.967] - Erased future from FutureRegistry
[13:36:38.967] result() for ClusterFuture ...
[13:36:38.967] - result already collected: FutureResult
[13:36:38.967] result() for ClusterFuture ... done
[13:36:38.967] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.968] result() for ClusterFuture ...
[13:36:38.968] - result already collected: FutureResult
[13:36:38.968] result() for ClusterFuture ... done
[13:36:38.968] result() for ClusterFuture ...
[13:36:38.968] - result already collected: FutureResult
[13:36:38.968] result() for ClusterFuture ... done
[13:36:38.969] MultisessionFuture started
[13:36:38.969] - Launch lazy future ... done
[13:36:38.969] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x564a73ff2ff8> 
Classes 'listenv', 'environment' <environment: 0x564a74ed5770> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:36:38.974] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.974] - Validating connection of MultisessionFuture
[13:36:38.974] - received message: FutureResult
[13:36:38.974] - Received FutureResult
[13:36:38.974] - Erased future from FutureRegistry
[13:36:38.977] result() for ClusterFuture ...
[13:36:38.978] - result already collected: FutureResult
[13:36:38.978] result() for ClusterFuture ... done
[13:36:38.978] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:38.978] receiveMessageFromWorker() for ClusterFuture ...
[13:36:38.978] - Validating connection of MultisessionFuture
[13:36:38.979] - received message: FutureResult
[13:36:38.979] - Received FutureResult
[13:36:38.979] - Erased future from FutureRegistry
[13:36:38.979] result() for ClusterFuture ...
[13:36:38.979] - result already collected: FutureResult
[13:36:38.979] result() for ClusterFuture ... done
[13:36:38.979] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:36:38.982] resolve() on list environment ...
[13:36:38.982]  recursive: 0
[13:36:38.983]  length: 6
[13:36:38.983]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:36:38.983] signalConditionsASAP(numeric, pos=1) ...
[13:36:38.983] - nx: 6
[13:36:38.983] - relay: TRUE
[13:36:38.983] - stdout: TRUE
[13:36:38.984] - signal: TRUE
[13:36:38.984] - resignal: FALSE
[13:36:38.984] - force: TRUE
[13:36:38.984] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.984] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.984]  - until=2
[13:36:38.984]  - relaying element #2
[13:36:38.984] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.984] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.984] signalConditionsASAP(NULL, pos=1) ... done
[13:36:38.984]  length: 5 (resolved future 1)
[13:36:38.985] Future #2
[13:36:38.985] result() for ClusterFuture ...
[13:36:38.985] - result already collected: FutureResult
[13:36:38.985] result() for ClusterFuture ... done
[13:36:38.985] result() for ClusterFuture ...
[13:36:38.985] - result already collected: FutureResult
[13:36:38.985] result() for ClusterFuture ... done
[13:36:38.985] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:36:38.985] - nx: 6
[13:36:38.985] - relay: TRUE
[13:36:38.985] - stdout: TRUE
[13:36:38.986] - signal: TRUE
[13:36:38.986] - resignal: FALSE
[13:36:38.986] - force: TRUE
[13:36:38.986] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.986] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:36:38.986]  - until=2
[13:36:38.986]  - relaying element #2
[13:36:38.986] result() for ClusterFuture ...
[13:36:38.986] - result already collected: FutureResult
[13:36:38.986] result() for ClusterFuture ... done
[13:36:38.986] result() for ClusterFuture ...
[13:36:38.987] - result already collected: FutureResult
[13:36:38.987] result() for ClusterFuture ... done
[13:36:38.987] result() for ClusterFuture ...
[13:36:38.987] - result already collected: FutureResult
[13:36:38.987] result() for ClusterFuture ... done
[13:36:38.987] result() for ClusterFuture ...
[13:36:38.987] - result already collected: FutureResult
[13:36:38.987] result() for ClusterFuture ... done
[13:36:38.987] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.987] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.987] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:36:38.988]  length: 4 (resolved future 2)
[13:36:38.988] Future #3
[13:36:38.988] result() for ClusterFuture ...
[13:36:38.988] - result already collected: FutureResult
[13:36:38.988] result() for ClusterFuture ... done
[13:36:38.988] result() for ClusterFuture ...
[13:36:38.988] - result already collected: FutureResult
[13:36:38.988] result() for ClusterFuture ... done
[13:36:38.988] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:36:38.988] - nx: 6
[13:36:38.988] - relay: TRUE
[13:36:38.988] - stdout: TRUE
[13:36:38.989] - signal: TRUE
[13:36:38.989] - resignal: FALSE
[13:36:38.989] - force: TRUE
[13:36:38.989] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.989] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:36:38.989]  - until=3
[13:36:38.989]  - relaying element #3
[13:36:38.989] result() for ClusterFuture ...
[13:36:38.989] - result already collected: FutureResult
[13:36:38.989] result() for ClusterFuture ... done
[13:36:38.989] result() for ClusterFuture ...
[13:36:38.989] - result already collected: FutureResult
[13:36:38.990] result() for ClusterFuture ... done
[13:36:38.990] result() for ClusterFuture ...
[13:36:38.990] - result already collected: FutureResult
[13:36:38.990] result() for ClusterFuture ... done
[13:36:38.990] result() for ClusterFuture ...
[13:36:38.990] - result already collected: FutureResult
[13:36:38.990] result() for ClusterFuture ... done
[13:36:38.990] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.990] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.990] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:36:38.991]  length: 3 (resolved future 3)
[13:36:38.991] Future #4
[13:36:38.991] result() for ClusterFuture ...
[13:36:38.991] - result already collected: FutureResult
[13:36:38.991] result() for ClusterFuture ... done
[13:36:38.991] result() for ClusterFuture ...
[13:36:38.991] - result already collected: FutureResult
[13:36:38.991] result() for ClusterFuture ... done
[13:36:38.991] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:36:38.991] - nx: 6
[13:36:38.991] - relay: TRUE
[13:36:38.992] - stdout: TRUE
[13:36:38.992] - signal: TRUE
[13:36:38.992] - resignal: FALSE
[13:36:38.992] - force: TRUE
[13:36:38.992] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.992] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:36:38.992]  - until=4
[13:36:38.992]  - relaying element #4
[13:36:38.992] result() for ClusterFuture ...
[13:36:38.992] - result already collected: FutureResult
[13:36:38.992] result() for ClusterFuture ... done
[13:36:38.992] result() for ClusterFuture ...
[13:36:38.993] - result already collected: FutureResult
[13:36:38.993] result() for ClusterFuture ... done
[13:36:38.993] result() for ClusterFuture ...
[13:36:38.993] - result already collected: FutureResult
[13:36:38.993] result() for ClusterFuture ... done
[13:36:38.993] result() for ClusterFuture ...
[13:36:38.993] - result already collected: FutureResult
[13:36:38.993] result() for ClusterFuture ... done
[13:36:38.993] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.993] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.993] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:36:38.994]  length: 2 (resolved future 4)
[13:36:38.994] signalConditionsASAP(NULL, pos=5) ...
[13:36:38.994] - nx: 6
[13:36:38.994] - relay: TRUE
[13:36:38.994] - stdout: TRUE
[13:36:38.994] - signal: TRUE
[13:36:38.994] - resignal: FALSE
[13:36:38.994] - force: TRUE
[13:36:38.994] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.994] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.994]  - until=6
[13:36:38.995]  - relaying element #6
[13:36:38.995] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.995] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.995] signalConditionsASAP(NULL, pos=5) ... done
[13:36:38.995]  length: 1 (resolved future 5)
[13:36:38.995] signalConditionsASAP(numeric, pos=6) ...
[13:36:38.995] - nx: 6
[13:36:38.995] - relay: TRUE
[13:36:38.995] - stdout: TRUE
[13:36:38.995] - signal: TRUE
[13:36:38.995] - resignal: FALSE
[13:36:38.996] - force: TRUE
[13:36:38.996] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:36:38.996] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.996]  - until=6
[13:36:38.996] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.996] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.996] signalConditionsASAP(numeric, pos=6) ... done
[13:36:38.996]  length: 0 (resolved future 6)
[13:36:38.996] Relaying remaining futures
[13:36:38.996] signalConditionsASAP(NULL, pos=0) ...
[13:36:38.996] - nx: 6
[13:36:38.996] - relay: TRUE
[13:36:38.997] - stdout: TRUE
[13:36:38.997] - signal: TRUE
[13:36:38.997] - resignal: FALSE
[13:36:38.997] - force: TRUE
[13:36:38.997] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.997] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:36:38.997] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:36:38.997] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:36:38.997] signalConditionsASAP(NULL, pos=0) ... done
[13:36:38.997] resolve() on list environment ... DONE
[13:36:38.998] result() for ClusterFuture ...
[13:36:38.998] - result already collected: FutureResult
[13:36:38.998] result() for ClusterFuture ... done
[13:36:38.998] result() for ClusterFuture ...
[13:36:38.998] - result already collected: FutureResult
[13:36:38.998] result() for ClusterFuture ... done
[13:36:38.998] result() for ClusterFuture ...
[13:36:38.998] - result already collected: FutureResult
[13:36:38.998] result() for ClusterFuture ... done
[13:36:38.998] result() for ClusterFuture ...
[13:36:38.998] - result already collected: FutureResult
[13:36:38.999] result() for ClusterFuture ... done
[13:36:38.999] result() for ClusterFuture ...
[13:36:38.999] - result already collected: FutureResult
[13:36:38.999] result() for ClusterFuture ... done
[13:36:38.999] result() for ClusterFuture ...
[13:36:38.999] - result already collected: FutureResult
[13:36:38.999] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x564a7372a5a0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[13:36:39.002] plan(): Setting new future strategy stack:
[13:36:39.002] List of future strategies:
[13:36:39.002] 1. FutureStrategy:
[13:36:39.002]    - args: function (..., envir = parent.frame())
[13:36:39.002]    - tweaked: FALSE
[13:36:39.002]    - call: future::plan(oplan)
[13:36:39.003] plan(): nbrOfWorkers() = 1
> 
